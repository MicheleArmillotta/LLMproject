[
  {
    "function_name": "ufs_clusteracct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/balloc.c",
    "lines": "848-899",
    "snippet": "static void ufs_clusteracct(struct super_block * sb,\n\tstruct ufs_cg_private_info * ucpi, unsigned blkno, int cnt)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tint i, start, end, forw, back;\n\t\n\tuspi = UFS_SB(sb)->s_uspi;\n\tif (uspi->s_contigsumsize <= 0)\n\t\treturn;\n\n\tif (cnt > 0)\n\t\tubh_setbit(UCPI_UBH(ucpi), ucpi->c_clusteroff, blkno);\n\telse\n\t\tubh_clrbit(UCPI_UBH(ucpi), ucpi->c_clusteroff, blkno);\n\n\t/*\n\t * Find the size of the cluster going forward.\n\t */\n\tstart = blkno + 1;\n\tend = start + uspi->s_contigsumsize;\n\tif ( end >= ucpi->c_nclusterblks)\n\t\tend = ucpi->c_nclusterblks;\n\ti = ubh_find_next_zero_bit (UCPI_UBH(ucpi), ucpi->c_clusteroff, end, start);\n\tif (i > end)\n\t\ti = end;\n\tforw = i - start;\n\t\n\t/*\n\t * Find the size of the cluster going backward.\n\t */\n\tstart = blkno - 1;\n\tend = start - uspi->s_contigsumsize;\n\tif (end < 0 ) \n\t\tend = -1;\n\ti = ubh_find_last_zero_bit (UCPI_UBH(ucpi), ucpi->c_clusteroff, start, end);\n\tif ( i < end) \n\t\ti = end;\n\tback = start - i;\n\t\n\t/*\n\t * Account for old cluster and the possibly new forward and\n\t * back clusters.\n\t */\n\ti = back + forw + 1;\n\tif (i > uspi->s_contigsumsize)\n\t\ti = uspi->s_contigsumsize;\n\tfs32_add(sb, (__fs32*)ubh_get_addr(UCPI_UBH(ucpi), ucpi->c_clustersumoff + (i << 2)), cnt);\n\tif (back > 0)\n\t\tfs32_sub(sb, (__fs32*)ubh_get_addr(UCPI_UBH(ucpi), ucpi->c_clustersumoff + (back << 2)), cnt);\n\tif (forw > 0)\n\t\tfs32_sub(sb, (__fs32*)ubh_get_addr(UCPI_UBH(ucpi), ucpi->c_clustersumoff + (forw << 2)), cnt);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/bitops.h>",
      "#include <linux/capability.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ufs_clusteracct(struct super_block *, struct ufs_cg_private_info *, unsigned, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs32_sub",
          "args": [
            "sb",
            "(__fs32*)ubh_get_addr(UCPI_UBH(ucpi), ucpi->c_clustersumoff + (forw << 2))",
            "cnt"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "fs32_sub",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "70-77",
          "snippet": "static inline void\nfs32_sub(struct super_block *sbp, __fs32 *n, int d)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\tle32_add_cpu((__le32 *)n, -d);\n\telse\n\t\tbe32_add_cpu((__be32 *)n, -d);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nfs32_sub(struct super_block *sbp, __fs32 *n, int d)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\tle32_add_cpu((__le32 *)n, -d);\n\telse\n\t\tbe32_add_cpu((__be32 *)n, -d);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubh_get_addr",
          "args": [
            "UCPI_UBH(ucpi)",
            "ucpi->c_clustersumoff + (forw << 2)"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UCPI_UBH",
          "args": [
            "ucpi"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "UCPI_UBH",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "22-25",
          "snippet": "static inline struct ufs_buffer_head *UCPI_UBH(struct ufs_cg_private_info *cpi)\n{\n\treturn &cpi->c_ubh;\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ubh_brelse (struct ufs_buffer_head *);",
            "extern void ubh_mark_buffer_dirty (struct ufs_buffer_head *);",
            "extern void ubh_mark_buffer_uptodate (struct ufs_buffer_head *, int);",
            "extern void ubh_sync_block(struct ufs_buffer_head *);",
            "extern void ubh_bforget (struct ufs_buffer_head *);",
            "extern int  ubh_buffer_dirty (struct ufs_buffer_head *);",
            "extern void _ubh_ubhcpymem_(struct ufs_sb_private_info *, unsigned char *, struct ufs_buffer_head *, unsigned);",
            "extern void _ubh_memcpyubh_(struct ufs_sb_private_info *, struct ufs_buffer_head *, unsigned char *, unsigned);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nextern void ubh_brelse (struct ufs_buffer_head *);\nextern void ubh_mark_buffer_dirty (struct ufs_buffer_head *);\nextern void ubh_mark_buffer_uptodate (struct ufs_buffer_head *, int);\nextern void ubh_sync_block(struct ufs_buffer_head *);\nextern void ubh_bforget (struct ufs_buffer_head *);\nextern int  ubh_buffer_dirty (struct ufs_buffer_head *);\nextern void _ubh_ubhcpymem_(struct ufs_sb_private_info *, unsigned char *, struct ufs_buffer_head *, unsigned);\nextern void _ubh_memcpyubh_(struct ufs_sb_private_info *, struct ufs_buffer_head *, unsigned char *, unsigned);\n\nstatic inline struct ufs_buffer_head *UCPI_UBH(struct ufs_cg_private_info *cpi)\n{\n\treturn &cpi->c_ubh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubh_get_addr",
          "args": [
            "UCPI_UBH(ucpi)",
            "ucpi->c_clustersumoff + (back << 2)"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs32_add",
          "args": [
            "sb",
            "(__fs32*)ubh_get_addr(UCPI_UBH(ucpi), ucpi->c_clustersumoff + (i << 2))",
            "cnt"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "fs32_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "61-68",
          "snippet": "static inline void\nfs32_add(struct super_block *sbp, __fs32 *n, int d)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\tle32_add_cpu((__le32 *)n, d);\n\telse\n\t\tbe32_add_cpu((__be32 *)n, d);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nfs32_add(struct super_block *sbp, __fs32 *n, int d)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\tle32_add_cpu((__le32 *)n, d);\n\telse\n\t\tbe32_add_cpu((__be32 *)n, d);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubh_get_addr",
          "args": [
            "UCPI_UBH(ucpi)",
            "ucpi->c_clustersumoff + (i << 2)"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubh_find_last_zero_bit",
          "args": [
            "UCPI_UBH(ucpi)",
            "ucpi->c_clusteroff",
            "start",
            "end"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubh_find_next_zero_bit",
          "args": [
            "UCPI_UBH(ucpi)",
            "ucpi->c_clusteroff",
            "end",
            "start"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubh_clrbit",
          "args": [
            "UCPI_UBH(ucpi)",
            "ucpi->c_clusteroff",
            "blkno"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubh_setbit",
          "args": [
            "UCPI_UBH(ucpi)",
            "ucpi->c_clusteroff",
            "blkno"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <asm/byteorder.h>\n#include <linux/bitops.h>\n#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nstatic void ufs_clusteracct(struct super_block *, struct ufs_cg_private_info *, unsigned, int);\n\nstatic void ufs_clusteracct(struct super_block * sb,\n\tstruct ufs_cg_private_info * ucpi, unsigned blkno, int cnt)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tint i, start, end, forw, back;\n\t\n\tuspi = UFS_SB(sb)->s_uspi;\n\tif (uspi->s_contigsumsize <= 0)\n\t\treturn;\n\n\tif (cnt > 0)\n\t\tubh_setbit(UCPI_UBH(ucpi), ucpi->c_clusteroff, blkno);\n\telse\n\t\tubh_clrbit(UCPI_UBH(ucpi), ucpi->c_clusteroff, blkno);\n\n\t/*\n\t * Find the size of the cluster going forward.\n\t */\n\tstart = blkno + 1;\n\tend = start + uspi->s_contigsumsize;\n\tif ( end >= ucpi->c_nclusterblks)\n\t\tend = ucpi->c_nclusterblks;\n\ti = ubh_find_next_zero_bit (UCPI_UBH(ucpi), ucpi->c_clusteroff, end, start);\n\tif (i > end)\n\t\ti = end;\n\tforw = i - start;\n\t\n\t/*\n\t * Find the size of the cluster going backward.\n\t */\n\tstart = blkno - 1;\n\tend = start - uspi->s_contigsumsize;\n\tif (end < 0 ) \n\t\tend = -1;\n\ti = ubh_find_last_zero_bit (UCPI_UBH(ucpi), ucpi->c_clusteroff, start, end);\n\tif ( i < end) \n\t\ti = end;\n\tback = start - i;\n\t\n\t/*\n\t * Account for old cluster and the possibly new forward and\n\t * back clusters.\n\t */\n\ti = back + forw + 1;\n\tif (i > uspi->s_contigsumsize)\n\t\ti = uspi->s_contigsumsize;\n\tfs32_add(sb, (__fs32*)ubh_get_addr(UCPI_UBH(ucpi), ucpi->c_clustersumoff + (i << 2)), cnt);\n\tif (back > 0)\n\t\tfs32_sub(sb, (__fs32*)ubh_get_addr(UCPI_UBH(ucpi), ucpi->c_clustersumoff + (back << 2)), cnt);\n\tif (forw > 0)\n\t\tfs32_sub(sb, (__fs32*)ubh_get_addr(UCPI_UBH(ucpi), ucpi->c_clustersumoff + (forw << 2)), cnt);\n}"
  },
  {
    "function_name": "ufs_bitmap_search",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/balloc.c",
    "lines": "772-846",
    "snippet": "static u64 ufs_bitmap_search(struct super_block *sb,\n\t\t\t     struct ufs_cg_private_info *ucpi,\n\t\t\t     u64 goal, unsigned count)\n{\n\t/*\n\t * Bit patterns for identifying fragments in the block map\n\t * used as ((map & mask_arr) == want_arr)\n\t */\n\tstatic const int mask_arr[9] = {\n\t\t0x3, 0x7, 0xf, 0x1f, 0x3f, 0x7f, 0xff, 0x1ff, 0x3ff\n\t};\n\tstatic const int want_arr[9] = {\n\t\t0x0, 0x2, 0x6, 0xe, 0x1e, 0x3e, 0x7e, 0xfe, 0x1fe\n\t};\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tunsigned start, length, loc;\n\tunsigned pos, want, blockmap, mask, end;\n\tu64 result;\n\n\tUFSD(\"ENTER, cg %u, goal %llu, count %u\\n\", ucpi->c_cgx,\n\t     (unsigned long long)goal, count);\n\n\tif (goal)\n\t\tstart = ufs_dtogd(uspi, goal) >> 3;\n\telse\n\t\tstart = ucpi->c_frotor >> 3;\n\t\t\n\tlength = ((uspi->s_fpg + 7) >> 3) - start;\n\tloc = ubh_scanc(uspi, UCPI_UBH(ucpi), ucpi->c_freeoff + start, length,\n\t\t(uspi->s_fpb == 8) ? ufs_fragtable_8fpb : ufs_fragtable_other,\n\t\t1 << (count - 1 + (uspi->s_fpb & 7))); \n\tif (loc == 0) {\n\t\tlength = start + 1;\n\t\tloc = ubh_scanc(uspi, UCPI_UBH(ucpi), ucpi->c_freeoff, length,\n\t\t\t\t(uspi->s_fpb == 8) ? ufs_fragtable_8fpb :\n\t\t\t\tufs_fragtable_other,\n\t\t\t\t1 << (count - 1 + (uspi->s_fpb & 7)));\n\t\tif (loc == 0) {\n\t\t\tufs_error(sb, \"ufs_bitmap_search\",\n\t\t\t\t  \"bitmap corrupted on cg %u, start %u,\"\n\t\t\t\t  \" length %u, count %u, freeoff %u\\n\",\n\t\t\t\t  ucpi->c_cgx, start, length, count,\n\t\t\t\t  ucpi->c_freeoff);\n\t\t\treturn INVBLOCK;\n\t\t}\n\t\tstart = 0;\n\t}\n\tresult = (start + length - loc) << 3;\n\tucpi->c_frotor = result;\n\n\t/*\n\t * found the byte in the map\n\t */\n\n\tfor (end = result + 8; result < end; result += uspi->s_fpb) {\n\t\tblockmap = ubh_blkmap(UCPI_UBH(ucpi), ucpi->c_freeoff, result);\n\t\tblockmap <<= 1;\n\t\tmask = mask_arr[count];\n\t\twant = want_arr[count];\n\t\tfor (pos = 0; pos <= uspi->s_fpb - count; pos++) {\n\t\t\tif ((blockmap & mask) == want) {\n\t\t\t\tUFSD(\"EXIT, result %llu\\n\",\n\t\t\t\t     (unsigned long long)result);\n\t\t\t\treturn result + pos;\n \t\t\t}\n\t\t\tmask <<= 1;\n\t\t\twant <<= 1;\n \t\t}\n \t}\n\n\tufs_error(sb, \"ufs_bitmap_search\", \"block not in map on cg %u\\n\",\n\t\t  ucpi->c_cgx);\n\tUFSD(\"EXIT (FAILED)\\n\");\n\treturn INVBLOCK;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/bitops.h>",
      "#include <linux/capability.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define INVBLOCK ((u64)-1L)"
    ],
    "globals_used": [
      "static u64 ufs_add_fragments(struct inode *, u64, unsigned, unsigned);",
      "static u64 ufs_alloc_fragments(struct inode *, unsigned, u64, unsigned, int *);",
      "static u64 ufs_alloccg_block(struct inode *, struct ufs_cg_private_info *, u64, int *);",
      "static u64 ufs_bitmap_search (struct super_block *, struct ufs_cg_private_info *, u64, unsigned);",
      "static unsigned char ufs_fragtable_8fpb[], ufs_fragtable_other[];",
      "static void ufs_clusteracct(struct super_block *, struct ufs_cg_private_info *, unsigned, int);",
      "static unsigned char ufs_fragtable_8fpb[] = {\n\t0x00, 0x01, 0x01, 0x02, 0x01, 0x01, 0x02, 0x04, 0x01, 0x01, 0x01, 0x03, 0x02, 0x03, 0x04, 0x08,\n\t0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x03, 0x05, 0x02, 0x03, 0x03, 0x02, 0x04, 0x05, 0x08, 0x10,\n\t0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x03, 0x05, 0x01, 0x01, 0x01, 0x03, 0x03, 0x03, 0x05, 0x09,\n\t0x02, 0x03, 0x03, 0x02, 0x03, 0x03, 0x02, 0x06, 0x04, 0x05, 0x05, 0x06, 0x08, 0x09, 0x10, 0x20,\n\t0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x03, 0x05, 0x01, 0x01, 0x01, 0x03, 0x03, 0x03, 0x05, 0x09,\t\n\t0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x03, 0x05, 0x03, 0x03, 0x03, 0x03, 0x05, 0x05, 0x09, 0x11,\n\t0x02, 0x03, 0x03, 0x02, 0x03, 0x03, 0x02, 0x06, 0x03, 0x03, 0x03, 0x03, 0x02, 0x03, 0x06, 0x0A,\n\t0x04, 0x05, 0x05, 0x06, 0x05, 0x05, 0x06, 0x04, 0x08, 0x09, 0x09, 0x0A, 0x10, 0x11, 0x20, 0x40,\n\t0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x03, 0x05, 0x01, 0x01, 0x01, 0x03, 0x03, 0x03, 0x05, 0x09,\n\t0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x03, 0x05, 0x03, 0x03, 0x03, 0x03, 0x05, 0x05, 0x09, 0x11,\n\t0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x03, 0x05, 0x01, 0x01, 0x01, 0x03, 0x03, 0x03, 0x05, 0x09,\n\t0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x07, 0x05, 0x05, 0x05, 0x07, 0x09, 0x09, 0x11, 0x21,\n\t0x02, 0x03, 0x03, 0x02, 0x03, 0x03, 0x02, 0x06, 0x03, 0x03, 0x03, 0x03, 0x02, 0x03, 0x06, 0x0A,\n\t0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x07, 0x02, 0x03, 0x03, 0x02, 0x06, 0x07, 0x0A, 0x12,\n\t0x04, 0x05, 0x05, 0x06, 0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x05, 0x07, 0x06, 0x07, 0x04, 0x0C,\n\t0x08, 0x09, 0x09, 0x0A, 0x09, 0x09, 0x0A, 0x0C, 0x10, 0x11, 0x11, 0x12, 0x20, 0x21, 0x40, 0x80,\n};",
      "static unsigned char ufs_fragtable_other[] = {\n\t0x00, 0x16, 0x16, 0x2A, 0x16, 0x16, 0x26, 0x4E, 0x16, 0x16, 0x16, 0x3E, 0x2A, 0x3E, 0x4E, 0x8A,\n\t0x16, 0x16, 0x16, 0x3E, 0x16, 0x16, 0x36, 0x5E, 0x16, 0x16, 0x16, 0x3E, 0x3E, 0x3E, 0x5E, 0x9E,\n\t0x16, 0x16, 0x16, 0x3E, 0x16, 0x16, 0x36, 0x5E, 0x16, 0x16, 0x16, 0x3E, 0x3E, 0x3E, 0x5E, 0x9E,\n\t0x2A, 0x3E, 0x3E, 0x2A, 0x3E, 0x3E, 0x2E, 0x6E, 0x3E, 0x3E, 0x3E, 0x3E, 0x2A, 0x3E, 0x6E, 0xAA,\n\t0x16, 0x16, 0x16, 0x3E, 0x16, 0x16, 0x36, 0x5E, 0x16, 0x16, 0x16, 0x3E, 0x3E, 0x3E, 0x5E, 0x9E,\n\t0x16, 0x16, 0x16, 0x3E, 0x16, 0x16, 0x36, 0x5E, 0x16, 0x16, 0x16, 0x3E, 0x3E, 0x3E, 0x5E, 0x9E,\n\t0x26, 0x36, 0x36, 0x2E, 0x36, 0x36, 0x26, 0x6E, 0x36, 0x36, 0x36, 0x3E, 0x2E, 0x3E, 0x6E, 0xAE,\n\t0x4E, 0x5E, 0x5E, 0x6E, 0x5E, 0x5E, 0x6E, 0x4E, 0x5E, 0x5E, 0x5E, 0x7E, 0x6E, 0x7E, 0x4E, 0xCE,\n\t0x16, 0x16, 0x16, 0x3E, 0x16, 0x16, 0x36, 0x5E, 0x16, 0x16, 0x16, 0x3E, 0x3E, 0x3E, 0x5E, 0x9E,\n\t0x16, 0x16, 0x16, 0x3E, 0x16, 0x16, 0x36, 0x5E, 0x16, 0x16, 0x16, 0x3E, 0x3E, 0x3E, 0x5E, 0x9E,\n\t0x16, 0x16, 0x16, 0x3E, 0x16, 0x16, 0x36, 0x5E, 0x16, 0x16, 0x16, 0x3E, 0x3E, 0x3E, 0x5E, 0x9E,\n\t0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x7E, 0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x7E, 0xBE,\n\t0x2A, 0x3E, 0x3E, 0x2A, 0x3E, 0x3E, 0x2E, 0x6E, 0x3E, 0x3E, 0x3E, 0x3E, 0x2A, 0x3E, 0x6E, 0xAA,\n\t0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x7E,\t0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x7E, 0xBE,\n\t0x4E, 0x5E, 0x5E, 0x6E, 0x5E, 0x5E, 0x6E, 0x4E, 0x5E, 0x5E, 0x5E, 0x7E, 0x6E, 0x7E, 0x4E, 0xCE,\n\t0x8A, 0x9E, 0x9E, 0xAA, 0x9E, 0x9E, 0xAE, 0xCE, 0x9E, 0x9E, 0x9E, 0xBE, 0xAA, 0xBE, 0xCE, 0x8A,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"EXIT (FAILED)\\n\""
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_error",
          "args": [
            "sb",
            "\"ufs_bitmap_search\"",
            "\"block not in map on cg %u\\n\"",
            "ucpi->c_cgx"
          ],
          "line": 842
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "285-317",
          "snippet": "void ufs_error (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct va_format vaf;\n\tva_list args;\n\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\t\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tusb1->fs_clean = UFS_FSBAD;\n\t\tubh_mark_buffer_dirty(USPI_UBH(uspi));\n\t\tufs_mark_sb_dirty(sb);\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tswitch (UFS_SB(sb)->s_mount_opt & UFS_MOUNT_ONERROR) {\n\tcase UFS_MOUNT_ONERROR_PANIC:\n\t\tpanic(\"panic (device %s): %s: %pV\\n\",\n\t\t      sb->s_id, function, &vaf);\n\n\tcase UFS_MOUNT_ONERROR_LOCK:\n\tcase UFS_MOUNT_ONERROR_UMOUNT:\n\tcase UFS_MOUNT_ONERROR_REPAIR:\n\t\tpr_crit(\"error (device %s): %s: %pV\\n\",\n\t\t\tsb->s_id, function, &vaf);\n\t}\n\tva_end(args);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid ufs_error (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct va_format vaf;\n\tva_list args;\n\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\t\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tusb1->fs_clean = UFS_FSBAD;\n\t\tubh_mark_buffer_dirty(USPI_UBH(uspi));\n\t\tufs_mark_sb_dirty(sb);\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tswitch (UFS_SB(sb)->s_mount_opt & UFS_MOUNT_ONERROR) {\n\tcase UFS_MOUNT_ONERROR_PANIC:\n\t\tpanic(\"panic (device %s): %s: %pV\\n\",\n\t\t      sb->s_id, function, &vaf);\n\n\tcase UFS_MOUNT_ONERROR_LOCK:\n\tcase UFS_MOUNT_ONERROR_UMOUNT:\n\tcase UFS_MOUNT_ONERROR_REPAIR:\n\t\tpr_crit(\"error (device %s): %s: %pV\\n\",\n\t\t\tsb->s_id, function, &vaf);\n\t}\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"EXIT, result %llu\\n\"",
            "(unsigned long long)result"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubh_blkmap",
          "args": [
            "UCPI_UBH(ucpi)",
            "ucpi->c_freeoff",
            "result"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UCPI_UBH",
          "args": [
            "ucpi"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "UCPI_UBH",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "22-25",
          "snippet": "static inline struct ufs_buffer_head *UCPI_UBH(struct ufs_cg_private_info *cpi)\n{\n\treturn &cpi->c_ubh;\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ubh_brelse (struct ufs_buffer_head *);",
            "extern void ubh_mark_buffer_dirty (struct ufs_buffer_head *);",
            "extern void ubh_mark_buffer_uptodate (struct ufs_buffer_head *, int);",
            "extern void ubh_sync_block(struct ufs_buffer_head *);",
            "extern void ubh_bforget (struct ufs_buffer_head *);",
            "extern int  ubh_buffer_dirty (struct ufs_buffer_head *);",
            "extern void _ubh_ubhcpymem_(struct ufs_sb_private_info *, unsigned char *, struct ufs_buffer_head *, unsigned);",
            "extern void _ubh_memcpyubh_(struct ufs_sb_private_info *, struct ufs_buffer_head *, unsigned char *, unsigned);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nextern void ubh_brelse (struct ufs_buffer_head *);\nextern void ubh_mark_buffer_dirty (struct ufs_buffer_head *);\nextern void ubh_mark_buffer_uptodate (struct ufs_buffer_head *, int);\nextern void ubh_sync_block(struct ufs_buffer_head *);\nextern void ubh_bforget (struct ufs_buffer_head *);\nextern int  ubh_buffer_dirty (struct ufs_buffer_head *);\nextern void _ubh_ubhcpymem_(struct ufs_sb_private_info *, unsigned char *, struct ufs_buffer_head *, unsigned);\nextern void _ubh_memcpyubh_(struct ufs_sb_private_info *, struct ufs_buffer_head *, unsigned char *, unsigned);\n\nstatic inline struct ufs_buffer_head *UCPI_UBH(struct ufs_cg_private_info *cpi)\n{\n\treturn &cpi->c_ubh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubh_scanc",
          "args": [
            "uspi",
            "UCPI_UBH(ucpi)",
            "ucpi->c_freeoff",
            "length",
            "(uspi->s_fpb == 8) ? ufs_fragtable_8fpb :\n\t\t\t\tufs_fragtable_other",
            "1 << (count - 1 + (uspi->s_fpb & 7))"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "ubh_scanc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/balloc.c",
          "lines": "737-763",
          "snippet": "static unsigned ubh_scanc(struct ufs_sb_private_info *uspi,\n\t\t\t  struct ufs_buffer_head *ubh,\n\t\t\t  unsigned begin, unsigned size,\n\t\t\t  unsigned char *table, unsigned char mask)\n{\n\tunsigned rest, offset;\n\tunsigned char *cp;\n\t\n\n\toffset = begin & ~uspi->s_fmask;\n\tbegin >>= uspi->s_fshift;\n\tfor (;;) {\n\t\tif ((offset + size) < uspi->s_fsize)\n\t\t\trest = size;\n\t\telse\n\t\t\trest = uspi->s_fsize - offset;\n\t\tsize -= rest;\n\t\tcp = ubh->bh[begin]->b_data + offset;\n\t\twhile ((table[*cp++] & mask) == 0 && --rest)\n\t\t\t;\n\t\tif (rest || !size)\n\t\t\tbreak;\n\t\tbegin++;\n\t\toffset = 0;\n\t}\n\treturn (size + rest);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/bitops.h>",
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <asm/byteorder.h>\n#include <linux/bitops.h>\n#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nstatic unsigned ubh_scanc(struct ufs_sb_private_info *uspi,\n\t\t\t  struct ufs_buffer_head *ubh,\n\t\t\t  unsigned begin, unsigned size,\n\t\t\t  unsigned char *table, unsigned char mask)\n{\n\tunsigned rest, offset;\n\tunsigned char *cp;\n\t\n\n\toffset = begin & ~uspi->s_fmask;\n\tbegin >>= uspi->s_fshift;\n\tfor (;;) {\n\t\tif ((offset + size) < uspi->s_fsize)\n\t\t\trest = size;\n\t\telse\n\t\t\trest = uspi->s_fsize - offset;\n\t\tsize -= rest;\n\t\tcp = ubh->bh[begin]->b_data + offset;\n\t\twhile ((table[*cp++] & mask) == 0 && --rest)\n\t\t\t;\n\t\tif (rest || !size)\n\t\t\tbreak;\n\t\tbegin++;\n\t\toffset = 0;\n\t}\n\treturn (size + rest);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_dtogd",
          "args": [
            "uspi",
            "goal"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"ENTER, cg %u, goal %llu, count %u\\n\"",
            "ucpi->c_cgx",
            "(unsigned long long)goal",
            "count"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <asm/byteorder.h>\n#include <linux/bitops.h>\n#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\n#define INVBLOCK ((u64)-1L)\n\nstatic u64 ufs_add_fragments(struct inode *, u64, unsigned, unsigned);\nstatic u64 ufs_alloc_fragments(struct inode *, unsigned, u64, unsigned, int *);\nstatic u64 ufs_alloccg_block(struct inode *, struct ufs_cg_private_info *, u64, int *);\nstatic u64 ufs_bitmap_search (struct super_block *, struct ufs_cg_private_info *, u64, unsigned);\nstatic unsigned char ufs_fragtable_8fpb[], ufs_fragtable_other[];\nstatic void ufs_clusteracct(struct super_block *, struct ufs_cg_private_info *, unsigned, int);\nstatic unsigned char ufs_fragtable_8fpb[] = {\n\t0x00, 0x01, 0x01, 0x02, 0x01, 0x01, 0x02, 0x04, 0x01, 0x01, 0x01, 0x03, 0x02, 0x03, 0x04, 0x08,\n\t0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x03, 0x05, 0x02, 0x03, 0x03, 0x02, 0x04, 0x05, 0x08, 0x10,\n\t0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x03, 0x05, 0x01, 0x01, 0x01, 0x03, 0x03, 0x03, 0x05, 0x09,\n\t0x02, 0x03, 0x03, 0x02, 0x03, 0x03, 0x02, 0x06, 0x04, 0x05, 0x05, 0x06, 0x08, 0x09, 0x10, 0x20,\n\t0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x03, 0x05, 0x01, 0x01, 0x01, 0x03, 0x03, 0x03, 0x05, 0x09,\t\n\t0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x03, 0x05, 0x03, 0x03, 0x03, 0x03, 0x05, 0x05, 0x09, 0x11,\n\t0x02, 0x03, 0x03, 0x02, 0x03, 0x03, 0x02, 0x06, 0x03, 0x03, 0x03, 0x03, 0x02, 0x03, 0x06, 0x0A,\n\t0x04, 0x05, 0x05, 0x06, 0x05, 0x05, 0x06, 0x04, 0x08, 0x09, 0x09, 0x0A, 0x10, 0x11, 0x20, 0x40,\n\t0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x03, 0x05, 0x01, 0x01, 0x01, 0x03, 0x03, 0x03, 0x05, 0x09,\n\t0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x03, 0x05, 0x03, 0x03, 0x03, 0x03, 0x05, 0x05, 0x09, 0x11,\n\t0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x03, 0x05, 0x01, 0x01, 0x01, 0x03, 0x03, 0x03, 0x05, 0x09,\n\t0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x07, 0x05, 0x05, 0x05, 0x07, 0x09, 0x09, 0x11, 0x21,\n\t0x02, 0x03, 0x03, 0x02, 0x03, 0x03, 0x02, 0x06, 0x03, 0x03, 0x03, 0x03, 0x02, 0x03, 0x06, 0x0A,\n\t0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x07, 0x02, 0x03, 0x03, 0x02, 0x06, 0x07, 0x0A, 0x12,\n\t0x04, 0x05, 0x05, 0x06, 0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x05, 0x07, 0x06, 0x07, 0x04, 0x0C,\n\t0x08, 0x09, 0x09, 0x0A, 0x09, 0x09, 0x0A, 0x0C, 0x10, 0x11, 0x11, 0x12, 0x20, 0x21, 0x40, 0x80,\n};\nstatic unsigned char ufs_fragtable_other[] = {\n\t0x00, 0x16, 0x16, 0x2A, 0x16, 0x16, 0x26, 0x4E, 0x16, 0x16, 0x16, 0x3E, 0x2A, 0x3E, 0x4E, 0x8A,\n\t0x16, 0x16, 0x16, 0x3E, 0x16, 0x16, 0x36, 0x5E, 0x16, 0x16, 0x16, 0x3E, 0x3E, 0x3E, 0x5E, 0x9E,\n\t0x16, 0x16, 0x16, 0x3E, 0x16, 0x16, 0x36, 0x5E, 0x16, 0x16, 0x16, 0x3E, 0x3E, 0x3E, 0x5E, 0x9E,\n\t0x2A, 0x3E, 0x3E, 0x2A, 0x3E, 0x3E, 0x2E, 0x6E, 0x3E, 0x3E, 0x3E, 0x3E, 0x2A, 0x3E, 0x6E, 0xAA,\n\t0x16, 0x16, 0x16, 0x3E, 0x16, 0x16, 0x36, 0x5E, 0x16, 0x16, 0x16, 0x3E, 0x3E, 0x3E, 0x5E, 0x9E,\n\t0x16, 0x16, 0x16, 0x3E, 0x16, 0x16, 0x36, 0x5E, 0x16, 0x16, 0x16, 0x3E, 0x3E, 0x3E, 0x5E, 0x9E,\n\t0x26, 0x36, 0x36, 0x2E, 0x36, 0x36, 0x26, 0x6E, 0x36, 0x36, 0x36, 0x3E, 0x2E, 0x3E, 0x6E, 0xAE,\n\t0x4E, 0x5E, 0x5E, 0x6E, 0x5E, 0x5E, 0x6E, 0x4E, 0x5E, 0x5E, 0x5E, 0x7E, 0x6E, 0x7E, 0x4E, 0xCE,\n\t0x16, 0x16, 0x16, 0x3E, 0x16, 0x16, 0x36, 0x5E, 0x16, 0x16, 0x16, 0x3E, 0x3E, 0x3E, 0x5E, 0x9E,\n\t0x16, 0x16, 0x16, 0x3E, 0x16, 0x16, 0x36, 0x5E, 0x16, 0x16, 0x16, 0x3E, 0x3E, 0x3E, 0x5E, 0x9E,\n\t0x16, 0x16, 0x16, 0x3E, 0x16, 0x16, 0x36, 0x5E, 0x16, 0x16, 0x16, 0x3E, 0x3E, 0x3E, 0x5E, 0x9E,\n\t0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x7E, 0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x7E, 0xBE,\n\t0x2A, 0x3E, 0x3E, 0x2A, 0x3E, 0x3E, 0x2E, 0x6E, 0x3E, 0x3E, 0x3E, 0x3E, 0x2A, 0x3E, 0x6E, 0xAA,\n\t0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x7E,\t0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x7E, 0xBE,\n\t0x4E, 0x5E, 0x5E, 0x6E, 0x5E, 0x5E, 0x6E, 0x4E, 0x5E, 0x5E, 0x5E, 0x7E, 0x6E, 0x7E, 0x4E, 0xCE,\n\t0x8A, 0x9E, 0x9E, 0xAA, 0x9E, 0x9E, 0xAE, 0xCE, 0x9E, 0x9E, 0x9E, 0xBE, 0xAA, 0xBE, 0xCE, 0x8A,\n};\n\nstatic u64 ufs_bitmap_search(struct super_block *sb,\n\t\t\t     struct ufs_cg_private_info *ucpi,\n\t\t\t     u64 goal, unsigned count)\n{\n\t/*\n\t * Bit patterns for identifying fragments in the block map\n\t * used as ((map & mask_arr) == want_arr)\n\t */\n\tstatic const int mask_arr[9] = {\n\t\t0x3, 0x7, 0xf, 0x1f, 0x3f, 0x7f, 0xff, 0x1ff, 0x3ff\n\t};\n\tstatic const int want_arr[9] = {\n\t\t0x0, 0x2, 0x6, 0xe, 0x1e, 0x3e, 0x7e, 0xfe, 0x1fe\n\t};\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tunsigned start, length, loc;\n\tunsigned pos, want, blockmap, mask, end;\n\tu64 result;\n\n\tUFSD(\"ENTER, cg %u, goal %llu, count %u\\n\", ucpi->c_cgx,\n\t     (unsigned long long)goal, count);\n\n\tif (goal)\n\t\tstart = ufs_dtogd(uspi, goal) >> 3;\n\telse\n\t\tstart = ucpi->c_frotor >> 3;\n\t\t\n\tlength = ((uspi->s_fpg + 7) >> 3) - start;\n\tloc = ubh_scanc(uspi, UCPI_UBH(ucpi), ucpi->c_freeoff + start, length,\n\t\t(uspi->s_fpb == 8) ? ufs_fragtable_8fpb : ufs_fragtable_other,\n\t\t1 << (count - 1 + (uspi->s_fpb & 7))); \n\tif (loc == 0) {\n\t\tlength = start + 1;\n\t\tloc = ubh_scanc(uspi, UCPI_UBH(ucpi), ucpi->c_freeoff, length,\n\t\t\t\t(uspi->s_fpb == 8) ? ufs_fragtable_8fpb :\n\t\t\t\tufs_fragtable_other,\n\t\t\t\t1 << (count - 1 + (uspi->s_fpb & 7)));\n\t\tif (loc == 0) {\n\t\t\tufs_error(sb, \"ufs_bitmap_search\",\n\t\t\t\t  \"bitmap corrupted on cg %u, start %u,\"\n\t\t\t\t  \" length %u, count %u, freeoff %u\\n\",\n\t\t\t\t  ucpi->c_cgx, start, length, count,\n\t\t\t\t  ucpi->c_freeoff);\n\t\t\treturn INVBLOCK;\n\t\t}\n\t\tstart = 0;\n\t}\n\tresult = (start + length - loc) << 3;\n\tucpi->c_frotor = result;\n\n\t/*\n\t * found the byte in the map\n\t */\n\n\tfor (end = result + 8; result < end; result += uspi->s_fpb) {\n\t\tblockmap = ubh_blkmap(UCPI_UBH(ucpi), ucpi->c_freeoff, result);\n\t\tblockmap <<= 1;\n\t\tmask = mask_arr[count];\n\t\twant = want_arr[count];\n\t\tfor (pos = 0; pos <= uspi->s_fpb - count; pos++) {\n\t\t\tif ((blockmap & mask) == want) {\n\t\t\t\tUFSD(\"EXIT, result %llu\\n\",\n\t\t\t\t     (unsigned long long)result);\n\t\t\t\treturn result + pos;\n \t\t\t}\n\t\t\tmask <<= 1;\n\t\t\twant <<= 1;\n \t\t}\n \t}\n\n\tufs_error(sb, \"ufs_bitmap_search\", \"block not in map on cg %u\\n\",\n\t\t  ucpi->c_cgx);\n\tUFSD(\"EXIT (FAILED)\\n\");\n\treturn INVBLOCK;\n}"
  },
  {
    "function_name": "ubh_scanc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/balloc.c",
    "lines": "737-763",
    "snippet": "static unsigned ubh_scanc(struct ufs_sb_private_info *uspi,\n\t\t\t  struct ufs_buffer_head *ubh,\n\t\t\t  unsigned begin, unsigned size,\n\t\t\t  unsigned char *table, unsigned char mask)\n{\n\tunsigned rest, offset;\n\tunsigned char *cp;\n\t\n\n\toffset = begin & ~uspi->s_fmask;\n\tbegin >>= uspi->s_fshift;\n\tfor (;;) {\n\t\tif ((offset + size) < uspi->s_fsize)\n\t\t\trest = size;\n\t\telse\n\t\t\trest = uspi->s_fsize - offset;\n\t\tsize -= rest;\n\t\tcp = ubh->bh[begin]->b_data + offset;\n\t\twhile ((table[*cp++] & mask) == 0 && --rest)\n\t\t\t;\n\t\tif (rest || !size)\n\t\t\tbreak;\n\t\tbegin++;\n\t\toffset = 0;\n\t}\n\treturn (size + rest);\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/bitops.h>",
      "#include <linux/capability.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <asm/byteorder.h>\n#include <linux/bitops.h>\n#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nstatic unsigned ubh_scanc(struct ufs_sb_private_info *uspi,\n\t\t\t  struct ufs_buffer_head *ubh,\n\t\t\t  unsigned begin, unsigned size,\n\t\t\t  unsigned char *table, unsigned char mask)\n{\n\tunsigned rest, offset;\n\tunsigned char *cp;\n\t\n\n\toffset = begin & ~uspi->s_fmask;\n\tbegin >>= uspi->s_fshift;\n\tfor (;;) {\n\t\tif ((offset + size) < uspi->s_fsize)\n\t\t\trest = size;\n\t\telse\n\t\t\trest = uspi->s_fsize - offset;\n\t\tsize -= rest;\n\t\tcp = ubh->bh[begin]->b_data + offset;\n\t\twhile ((table[*cp++] & mask) == 0 && --rest)\n\t\t\t;\n\t\tif (rest || !size)\n\t\t\tbreak;\n\t\tbegin++;\n\t\toffset = 0;\n\t}\n\treturn (size + rest);\n}"
  },
  {
    "function_name": "ufs_alloccg_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/balloc.c",
    "lines": "679-735",
    "snippet": "static u64 ufs_alloccg_block(struct inode *inode,\n\t\t\t     struct ufs_cg_private_info *ucpi,\n\t\t\t     u64 goal, int *err)\n{\n\tstruct super_block * sb;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cylinder_group * ucg;\n\tu64 result, blkno;\n\n\tUFSD(\"ENTER, goal %llu\\n\", (unsigned long long)goal);\n\n\tsb = inode->i_sb;\n\tuspi = UFS_SB(sb)->s_uspi;\n\tucg = ubh_get_ucg(UCPI_UBH(ucpi));\n\n\tif (goal == 0) {\n\t\tgoal = ucpi->c_rotor;\n\t\tgoto norot;\n\t}\n\tgoal = ufs_blknum (goal);\n\tgoal = ufs_dtogd(uspi, goal);\n\t\n\t/*\n\t * If the requested block is available, use it.\n\t */\n\tif (ubh_isblockset(UCPI_UBH(ucpi), ucpi->c_freeoff, ufs_fragstoblks(goal))) {\n\t\tresult = goal;\n\t\tgoto gotit;\n\t}\n\t\nnorot:\t\n\tresult = ufs_bitmap_search (sb, ucpi, goal, uspi->s_fpb);\n\tif (result == INVBLOCK)\n\t\treturn INVBLOCK;\n\tucpi->c_rotor = result;\ngotit:\n\tblkno = ufs_fragstoblks(result);\n\tubh_clrblock (UCPI_UBH(ucpi), ucpi->c_freeoff, blkno);\n\tif ((UFS_SB(sb)->s_flags & UFS_CG_MASK) == UFS_CG_44BSD)\n\t\tufs_clusteracct (sb, ucpi, blkno, -1);\n\n\tfs32_sub(sb, &ucg->cg_cs.cs_nbfree, 1);\n\tuspi->cs_total.cs_nbfree--;\n\tfs32_sub(sb, &UFS_SB(sb)->fs_cs(ucpi->c_cgx).cs_nbfree, 1);\n\n\tif (uspi->fs_magic != UFS2_MAGIC) {\n\t\tunsigned cylno = ufs_cbtocylno((unsigned)result);\n\n\t\tfs16_sub(sb, &ubh_cg_blks(ucpi, cylno,\n\t\t\t\t\t  ufs_cbtorpos((unsigned)result)), 1);\n\t\tfs32_sub(sb, &ubh_cg_blktot(ucpi, cylno), 1);\n\t}\n\t\n\tUFSD(\"EXIT, result %llu\\n\", (unsigned long long)result);\n\n\treturn result;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/bitops.h>",
      "#include <linux/capability.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define INVBLOCK ((u64)-1L)"
    ],
    "globals_used": [
      "static u64 ufs_add_fragments(struct inode *, u64, unsigned, unsigned);",
      "static u64 ufs_alloc_fragments(struct inode *, unsigned, u64, unsigned, int *);",
      "static u64 ufs_alloccg_block(struct inode *, struct ufs_cg_private_info *, u64, int *);",
      "static u64 ufs_bitmap_search (struct super_block *, struct ufs_cg_private_info *, u64, unsigned);",
      "static void ufs_clusteracct(struct super_block *, struct ufs_cg_private_info *, unsigned, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"EXIT, result %llu\\n\"",
            "(unsigned long long)result"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs32_sub",
          "args": [
            "sb",
            "&ubh_cg_blktot(ucpi, cylno)",
            "1"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "fs32_sub",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "70-77",
          "snippet": "static inline void\nfs32_sub(struct super_block *sbp, __fs32 *n, int d)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\tle32_add_cpu((__le32 *)n, -d);\n\telse\n\t\tbe32_add_cpu((__be32 *)n, -d);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nfs32_sub(struct super_block *sbp, __fs32 *n, int d)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\tle32_add_cpu((__le32 *)n, -d);\n\telse\n\t\tbe32_add_cpu((__be32 *)n, -d);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubh_cg_blktot",
          "args": [
            "ucpi",
            "cylno"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs16_sub",
          "args": [
            "sb",
            "&ubh_cg_blks(ucpi, cylno,\n\t\t\t\t\t  ufs_cbtorpos((unsigned)result))",
            "1"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "fs16_sub",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "106-113",
          "snippet": "static inline void\nfs16_sub(struct super_block *sbp, __fs16 *n, int d)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\tle16_add_cpu((__le16 *)n, -d);\n\telse\n\t\tbe16_add_cpu((__be16 *)n, -d);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nfs16_sub(struct super_block *sbp, __fs16 *n, int d)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\tle16_add_cpu((__le16 *)n, -d);\n\telse\n\t\tbe16_add_cpu((__be16 *)n, -d);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubh_cg_blks",
          "args": [
            "ucpi",
            "cylno",
            "ufs_cbtorpos((unsigned)result)"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_cbtorpos",
          "args": [
            "(unsigned)result"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_cbtocylno",
          "args": [
            "(unsigned)result"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "ucpi->c_cgx"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_clusteracct",
          "args": [
            "sb",
            "ucpi",
            "blkno",
            "-1"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_clusteracct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/balloc.c",
          "lines": "848-899",
          "snippet": "static void ufs_clusteracct(struct super_block * sb,\n\tstruct ufs_cg_private_info * ucpi, unsigned blkno, int cnt)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tint i, start, end, forw, back;\n\t\n\tuspi = UFS_SB(sb)->s_uspi;\n\tif (uspi->s_contigsumsize <= 0)\n\t\treturn;\n\n\tif (cnt > 0)\n\t\tubh_setbit(UCPI_UBH(ucpi), ucpi->c_clusteroff, blkno);\n\telse\n\t\tubh_clrbit(UCPI_UBH(ucpi), ucpi->c_clusteroff, blkno);\n\n\t/*\n\t * Find the size of the cluster going forward.\n\t */\n\tstart = blkno + 1;\n\tend = start + uspi->s_contigsumsize;\n\tif ( end >= ucpi->c_nclusterblks)\n\t\tend = ucpi->c_nclusterblks;\n\ti = ubh_find_next_zero_bit (UCPI_UBH(ucpi), ucpi->c_clusteroff, end, start);\n\tif (i > end)\n\t\ti = end;\n\tforw = i - start;\n\t\n\t/*\n\t * Find the size of the cluster going backward.\n\t */\n\tstart = blkno - 1;\n\tend = start - uspi->s_contigsumsize;\n\tif (end < 0 ) \n\t\tend = -1;\n\ti = ubh_find_last_zero_bit (UCPI_UBH(ucpi), ucpi->c_clusteroff, start, end);\n\tif ( i < end) \n\t\ti = end;\n\tback = start - i;\n\t\n\t/*\n\t * Account for old cluster and the possibly new forward and\n\t * back clusters.\n\t */\n\ti = back + forw + 1;\n\tif (i > uspi->s_contigsumsize)\n\t\ti = uspi->s_contigsumsize;\n\tfs32_add(sb, (__fs32*)ubh_get_addr(UCPI_UBH(ucpi), ucpi->c_clustersumoff + (i << 2)), cnt);\n\tif (back > 0)\n\t\tfs32_sub(sb, (__fs32*)ubh_get_addr(UCPI_UBH(ucpi), ucpi->c_clustersumoff + (back << 2)), cnt);\n\tif (forw > 0)\n\t\tfs32_sub(sb, (__fs32*)ubh_get_addr(UCPI_UBH(ucpi), ucpi->c_clustersumoff + (forw << 2)), cnt);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/bitops.h>",
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ufs_clusteracct(struct super_block *, struct ufs_cg_private_info *, unsigned, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <asm/byteorder.h>\n#include <linux/bitops.h>\n#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nstatic void ufs_clusteracct(struct super_block *, struct ufs_cg_private_info *, unsigned, int);\n\nstatic void ufs_clusteracct(struct super_block * sb,\n\tstruct ufs_cg_private_info * ucpi, unsigned blkno, int cnt)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tint i, start, end, forw, back;\n\t\n\tuspi = UFS_SB(sb)->s_uspi;\n\tif (uspi->s_contigsumsize <= 0)\n\t\treturn;\n\n\tif (cnt > 0)\n\t\tubh_setbit(UCPI_UBH(ucpi), ucpi->c_clusteroff, blkno);\n\telse\n\t\tubh_clrbit(UCPI_UBH(ucpi), ucpi->c_clusteroff, blkno);\n\n\t/*\n\t * Find the size of the cluster going forward.\n\t */\n\tstart = blkno + 1;\n\tend = start + uspi->s_contigsumsize;\n\tif ( end >= ucpi->c_nclusterblks)\n\t\tend = ucpi->c_nclusterblks;\n\ti = ubh_find_next_zero_bit (UCPI_UBH(ucpi), ucpi->c_clusteroff, end, start);\n\tif (i > end)\n\t\ti = end;\n\tforw = i - start;\n\t\n\t/*\n\t * Find the size of the cluster going backward.\n\t */\n\tstart = blkno - 1;\n\tend = start - uspi->s_contigsumsize;\n\tif (end < 0 ) \n\t\tend = -1;\n\ti = ubh_find_last_zero_bit (UCPI_UBH(ucpi), ucpi->c_clusteroff, start, end);\n\tif ( i < end) \n\t\ti = end;\n\tback = start - i;\n\t\n\t/*\n\t * Account for old cluster and the possibly new forward and\n\t * back clusters.\n\t */\n\ti = back + forw + 1;\n\tif (i > uspi->s_contigsumsize)\n\t\ti = uspi->s_contigsumsize;\n\tfs32_add(sb, (__fs32*)ubh_get_addr(UCPI_UBH(ucpi), ucpi->c_clustersumoff + (i << 2)), cnt);\n\tif (back > 0)\n\t\tfs32_sub(sb, (__fs32*)ubh_get_addr(UCPI_UBH(ucpi), ucpi->c_clustersumoff + (back << 2)), cnt);\n\tif (forw > 0)\n\t\tfs32_sub(sb, (__fs32*)ubh_get_addr(UCPI_UBH(ucpi), ucpi->c_clustersumoff + (forw << 2)), cnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubh_clrblock",
          "args": [
            "UCPI_UBH(ucpi)",
            "ucpi->c_freeoff",
            "blkno"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UCPI_UBH",
          "args": [
            "ucpi"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "UCPI_UBH",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "22-25",
          "snippet": "static inline struct ufs_buffer_head *UCPI_UBH(struct ufs_cg_private_info *cpi)\n{\n\treturn &cpi->c_ubh;\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ubh_brelse (struct ufs_buffer_head *);",
            "extern void ubh_mark_buffer_dirty (struct ufs_buffer_head *);",
            "extern void ubh_mark_buffer_uptodate (struct ufs_buffer_head *, int);",
            "extern void ubh_sync_block(struct ufs_buffer_head *);",
            "extern void ubh_bforget (struct ufs_buffer_head *);",
            "extern int  ubh_buffer_dirty (struct ufs_buffer_head *);",
            "extern void _ubh_ubhcpymem_(struct ufs_sb_private_info *, unsigned char *, struct ufs_buffer_head *, unsigned);",
            "extern void _ubh_memcpyubh_(struct ufs_sb_private_info *, struct ufs_buffer_head *, unsigned char *, unsigned);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nextern void ubh_brelse (struct ufs_buffer_head *);\nextern void ubh_mark_buffer_dirty (struct ufs_buffer_head *);\nextern void ubh_mark_buffer_uptodate (struct ufs_buffer_head *, int);\nextern void ubh_sync_block(struct ufs_buffer_head *);\nextern void ubh_bforget (struct ufs_buffer_head *);\nextern int  ubh_buffer_dirty (struct ufs_buffer_head *);\nextern void _ubh_ubhcpymem_(struct ufs_sb_private_info *, unsigned char *, struct ufs_buffer_head *, unsigned);\nextern void _ubh_memcpyubh_(struct ufs_sb_private_info *, struct ufs_buffer_head *, unsigned char *, unsigned);\n\nstatic inline struct ufs_buffer_head *UCPI_UBH(struct ufs_cg_private_info *cpi)\n{\n\treturn &cpi->c_ubh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_fragstoblks",
          "args": [
            "result"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_bitmap_search",
          "args": [
            "sb",
            "ucpi",
            "goal",
            "uspi->s_fpb"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_bitmap_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/balloc.c",
          "lines": "772-846",
          "snippet": "static u64 ufs_bitmap_search(struct super_block *sb,\n\t\t\t     struct ufs_cg_private_info *ucpi,\n\t\t\t     u64 goal, unsigned count)\n{\n\t/*\n\t * Bit patterns for identifying fragments in the block map\n\t * used as ((map & mask_arr) == want_arr)\n\t */\n\tstatic const int mask_arr[9] = {\n\t\t0x3, 0x7, 0xf, 0x1f, 0x3f, 0x7f, 0xff, 0x1ff, 0x3ff\n\t};\n\tstatic const int want_arr[9] = {\n\t\t0x0, 0x2, 0x6, 0xe, 0x1e, 0x3e, 0x7e, 0xfe, 0x1fe\n\t};\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tunsigned start, length, loc;\n\tunsigned pos, want, blockmap, mask, end;\n\tu64 result;\n\n\tUFSD(\"ENTER, cg %u, goal %llu, count %u\\n\", ucpi->c_cgx,\n\t     (unsigned long long)goal, count);\n\n\tif (goal)\n\t\tstart = ufs_dtogd(uspi, goal) >> 3;\n\telse\n\t\tstart = ucpi->c_frotor >> 3;\n\t\t\n\tlength = ((uspi->s_fpg + 7) >> 3) - start;\n\tloc = ubh_scanc(uspi, UCPI_UBH(ucpi), ucpi->c_freeoff + start, length,\n\t\t(uspi->s_fpb == 8) ? ufs_fragtable_8fpb : ufs_fragtable_other,\n\t\t1 << (count - 1 + (uspi->s_fpb & 7))); \n\tif (loc == 0) {\n\t\tlength = start + 1;\n\t\tloc = ubh_scanc(uspi, UCPI_UBH(ucpi), ucpi->c_freeoff, length,\n\t\t\t\t(uspi->s_fpb == 8) ? ufs_fragtable_8fpb :\n\t\t\t\tufs_fragtable_other,\n\t\t\t\t1 << (count - 1 + (uspi->s_fpb & 7)));\n\t\tif (loc == 0) {\n\t\t\tufs_error(sb, \"ufs_bitmap_search\",\n\t\t\t\t  \"bitmap corrupted on cg %u, start %u,\"\n\t\t\t\t  \" length %u, count %u, freeoff %u\\n\",\n\t\t\t\t  ucpi->c_cgx, start, length, count,\n\t\t\t\t  ucpi->c_freeoff);\n\t\t\treturn INVBLOCK;\n\t\t}\n\t\tstart = 0;\n\t}\n\tresult = (start + length - loc) << 3;\n\tucpi->c_frotor = result;\n\n\t/*\n\t * found the byte in the map\n\t */\n\n\tfor (end = result + 8; result < end; result += uspi->s_fpb) {\n\t\tblockmap = ubh_blkmap(UCPI_UBH(ucpi), ucpi->c_freeoff, result);\n\t\tblockmap <<= 1;\n\t\tmask = mask_arr[count];\n\t\twant = want_arr[count];\n\t\tfor (pos = 0; pos <= uspi->s_fpb - count; pos++) {\n\t\t\tif ((blockmap & mask) == want) {\n\t\t\t\tUFSD(\"EXIT, result %llu\\n\",\n\t\t\t\t     (unsigned long long)result);\n\t\t\t\treturn result + pos;\n \t\t\t}\n\t\t\tmask <<= 1;\n\t\t\twant <<= 1;\n \t\t}\n \t}\n\n\tufs_error(sb, \"ufs_bitmap_search\", \"block not in map on cg %u\\n\",\n\t\t  ucpi->c_cgx);\n\tUFSD(\"EXIT (FAILED)\\n\");\n\treturn INVBLOCK;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/bitops.h>",
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define INVBLOCK ((u64)-1L)"
          ],
          "globals_used": [
            "static u64 ufs_add_fragments(struct inode *, u64, unsigned, unsigned);",
            "static u64 ufs_alloc_fragments(struct inode *, unsigned, u64, unsigned, int *);",
            "static u64 ufs_alloccg_block(struct inode *, struct ufs_cg_private_info *, u64, int *);",
            "static u64 ufs_bitmap_search (struct super_block *, struct ufs_cg_private_info *, u64, unsigned);",
            "static unsigned char ufs_fragtable_8fpb[], ufs_fragtable_other[];",
            "static void ufs_clusteracct(struct super_block *, struct ufs_cg_private_info *, unsigned, int);",
            "static unsigned char ufs_fragtable_8fpb[] = {\n\t0x00, 0x01, 0x01, 0x02, 0x01, 0x01, 0x02, 0x04, 0x01, 0x01, 0x01, 0x03, 0x02, 0x03, 0x04, 0x08,\n\t0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x03, 0x05, 0x02, 0x03, 0x03, 0x02, 0x04, 0x05, 0x08, 0x10,\n\t0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x03, 0x05, 0x01, 0x01, 0x01, 0x03, 0x03, 0x03, 0x05, 0x09,\n\t0x02, 0x03, 0x03, 0x02, 0x03, 0x03, 0x02, 0x06, 0x04, 0x05, 0x05, 0x06, 0x08, 0x09, 0x10, 0x20,\n\t0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x03, 0x05, 0x01, 0x01, 0x01, 0x03, 0x03, 0x03, 0x05, 0x09,\t\n\t0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x03, 0x05, 0x03, 0x03, 0x03, 0x03, 0x05, 0x05, 0x09, 0x11,\n\t0x02, 0x03, 0x03, 0x02, 0x03, 0x03, 0x02, 0x06, 0x03, 0x03, 0x03, 0x03, 0x02, 0x03, 0x06, 0x0A,\n\t0x04, 0x05, 0x05, 0x06, 0x05, 0x05, 0x06, 0x04, 0x08, 0x09, 0x09, 0x0A, 0x10, 0x11, 0x20, 0x40,\n\t0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x03, 0x05, 0x01, 0x01, 0x01, 0x03, 0x03, 0x03, 0x05, 0x09,\n\t0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x03, 0x05, 0x03, 0x03, 0x03, 0x03, 0x05, 0x05, 0x09, 0x11,\n\t0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x03, 0x05, 0x01, 0x01, 0x01, 0x03, 0x03, 0x03, 0x05, 0x09,\n\t0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x07, 0x05, 0x05, 0x05, 0x07, 0x09, 0x09, 0x11, 0x21,\n\t0x02, 0x03, 0x03, 0x02, 0x03, 0x03, 0x02, 0x06, 0x03, 0x03, 0x03, 0x03, 0x02, 0x03, 0x06, 0x0A,\n\t0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x07, 0x02, 0x03, 0x03, 0x02, 0x06, 0x07, 0x0A, 0x12,\n\t0x04, 0x05, 0x05, 0x06, 0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x05, 0x07, 0x06, 0x07, 0x04, 0x0C,\n\t0x08, 0x09, 0x09, 0x0A, 0x09, 0x09, 0x0A, 0x0C, 0x10, 0x11, 0x11, 0x12, 0x20, 0x21, 0x40, 0x80,\n};",
            "static unsigned char ufs_fragtable_other[] = {\n\t0x00, 0x16, 0x16, 0x2A, 0x16, 0x16, 0x26, 0x4E, 0x16, 0x16, 0x16, 0x3E, 0x2A, 0x3E, 0x4E, 0x8A,\n\t0x16, 0x16, 0x16, 0x3E, 0x16, 0x16, 0x36, 0x5E, 0x16, 0x16, 0x16, 0x3E, 0x3E, 0x3E, 0x5E, 0x9E,\n\t0x16, 0x16, 0x16, 0x3E, 0x16, 0x16, 0x36, 0x5E, 0x16, 0x16, 0x16, 0x3E, 0x3E, 0x3E, 0x5E, 0x9E,\n\t0x2A, 0x3E, 0x3E, 0x2A, 0x3E, 0x3E, 0x2E, 0x6E, 0x3E, 0x3E, 0x3E, 0x3E, 0x2A, 0x3E, 0x6E, 0xAA,\n\t0x16, 0x16, 0x16, 0x3E, 0x16, 0x16, 0x36, 0x5E, 0x16, 0x16, 0x16, 0x3E, 0x3E, 0x3E, 0x5E, 0x9E,\n\t0x16, 0x16, 0x16, 0x3E, 0x16, 0x16, 0x36, 0x5E, 0x16, 0x16, 0x16, 0x3E, 0x3E, 0x3E, 0x5E, 0x9E,\n\t0x26, 0x36, 0x36, 0x2E, 0x36, 0x36, 0x26, 0x6E, 0x36, 0x36, 0x36, 0x3E, 0x2E, 0x3E, 0x6E, 0xAE,\n\t0x4E, 0x5E, 0x5E, 0x6E, 0x5E, 0x5E, 0x6E, 0x4E, 0x5E, 0x5E, 0x5E, 0x7E, 0x6E, 0x7E, 0x4E, 0xCE,\n\t0x16, 0x16, 0x16, 0x3E, 0x16, 0x16, 0x36, 0x5E, 0x16, 0x16, 0x16, 0x3E, 0x3E, 0x3E, 0x5E, 0x9E,\n\t0x16, 0x16, 0x16, 0x3E, 0x16, 0x16, 0x36, 0x5E, 0x16, 0x16, 0x16, 0x3E, 0x3E, 0x3E, 0x5E, 0x9E,\n\t0x16, 0x16, 0x16, 0x3E, 0x16, 0x16, 0x36, 0x5E, 0x16, 0x16, 0x16, 0x3E, 0x3E, 0x3E, 0x5E, 0x9E,\n\t0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x7E, 0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x7E, 0xBE,\n\t0x2A, 0x3E, 0x3E, 0x2A, 0x3E, 0x3E, 0x2E, 0x6E, 0x3E, 0x3E, 0x3E, 0x3E, 0x2A, 0x3E, 0x6E, 0xAA,\n\t0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x7E,\t0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x7E, 0xBE,\n\t0x4E, 0x5E, 0x5E, 0x6E, 0x5E, 0x5E, 0x6E, 0x4E, 0x5E, 0x5E, 0x5E, 0x7E, 0x6E, 0x7E, 0x4E, 0xCE,\n\t0x8A, 0x9E, 0x9E, 0xAA, 0x9E, 0x9E, 0xAE, 0xCE, 0x9E, 0x9E, 0x9E, 0xBE, 0xAA, 0xBE, 0xCE, 0x8A,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <asm/byteorder.h>\n#include <linux/bitops.h>\n#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\n#define INVBLOCK ((u64)-1L)\n\nstatic u64 ufs_add_fragments(struct inode *, u64, unsigned, unsigned);\nstatic u64 ufs_alloc_fragments(struct inode *, unsigned, u64, unsigned, int *);\nstatic u64 ufs_alloccg_block(struct inode *, struct ufs_cg_private_info *, u64, int *);\nstatic u64 ufs_bitmap_search (struct super_block *, struct ufs_cg_private_info *, u64, unsigned);\nstatic unsigned char ufs_fragtable_8fpb[], ufs_fragtable_other[];\nstatic void ufs_clusteracct(struct super_block *, struct ufs_cg_private_info *, unsigned, int);\nstatic unsigned char ufs_fragtable_8fpb[] = {\n\t0x00, 0x01, 0x01, 0x02, 0x01, 0x01, 0x02, 0x04, 0x01, 0x01, 0x01, 0x03, 0x02, 0x03, 0x04, 0x08,\n\t0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x03, 0x05, 0x02, 0x03, 0x03, 0x02, 0x04, 0x05, 0x08, 0x10,\n\t0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x03, 0x05, 0x01, 0x01, 0x01, 0x03, 0x03, 0x03, 0x05, 0x09,\n\t0x02, 0x03, 0x03, 0x02, 0x03, 0x03, 0x02, 0x06, 0x04, 0x05, 0x05, 0x06, 0x08, 0x09, 0x10, 0x20,\n\t0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x03, 0x05, 0x01, 0x01, 0x01, 0x03, 0x03, 0x03, 0x05, 0x09,\t\n\t0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x03, 0x05, 0x03, 0x03, 0x03, 0x03, 0x05, 0x05, 0x09, 0x11,\n\t0x02, 0x03, 0x03, 0x02, 0x03, 0x03, 0x02, 0x06, 0x03, 0x03, 0x03, 0x03, 0x02, 0x03, 0x06, 0x0A,\n\t0x04, 0x05, 0x05, 0x06, 0x05, 0x05, 0x06, 0x04, 0x08, 0x09, 0x09, 0x0A, 0x10, 0x11, 0x20, 0x40,\n\t0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x03, 0x05, 0x01, 0x01, 0x01, 0x03, 0x03, 0x03, 0x05, 0x09,\n\t0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x03, 0x05, 0x03, 0x03, 0x03, 0x03, 0x05, 0x05, 0x09, 0x11,\n\t0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x03, 0x05, 0x01, 0x01, 0x01, 0x03, 0x03, 0x03, 0x05, 0x09,\n\t0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x07, 0x05, 0x05, 0x05, 0x07, 0x09, 0x09, 0x11, 0x21,\n\t0x02, 0x03, 0x03, 0x02, 0x03, 0x03, 0x02, 0x06, 0x03, 0x03, 0x03, 0x03, 0x02, 0x03, 0x06, 0x0A,\n\t0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x07, 0x02, 0x03, 0x03, 0x02, 0x06, 0x07, 0x0A, 0x12,\n\t0x04, 0x05, 0x05, 0x06, 0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x05, 0x07, 0x06, 0x07, 0x04, 0x0C,\n\t0x08, 0x09, 0x09, 0x0A, 0x09, 0x09, 0x0A, 0x0C, 0x10, 0x11, 0x11, 0x12, 0x20, 0x21, 0x40, 0x80,\n};\nstatic unsigned char ufs_fragtable_other[] = {\n\t0x00, 0x16, 0x16, 0x2A, 0x16, 0x16, 0x26, 0x4E, 0x16, 0x16, 0x16, 0x3E, 0x2A, 0x3E, 0x4E, 0x8A,\n\t0x16, 0x16, 0x16, 0x3E, 0x16, 0x16, 0x36, 0x5E, 0x16, 0x16, 0x16, 0x3E, 0x3E, 0x3E, 0x5E, 0x9E,\n\t0x16, 0x16, 0x16, 0x3E, 0x16, 0x16, 0x36, 0x5E, 0x16, 0x16, 0x16, 0x3E, 0x3E, 0x3E, 0x5E, 0x9E,\n\t0x2A, 0x3E, 0x3E, 0x2A, 0x3E, 0x3E, 0x2E, 0x6E, 0x3E, 0x3E, 0x3E, 0x3E, 0x2A, 0x3E, 0x6E, 0xAA,\n\t0x16, 0x16, 0x16, 0x3E, 0x16, 0x16, 0x36, 0x5E, 0x16, 0x16, 0x16, 0x3E, 0x3E, 0x3E, 0x5E, 0x9E,\n\t0x16, 0x16, 0x16, 0x3E, 0x16, 0x16, 0x36, 0x5E, 0x16, 0x16, 0x16, 0x3E, 0x3E, 0x3E, 0x5E, 0x9E,\n\t0x26, 0x36, 0x36, 0x2E, 0x36, 0x36, 0x26, 0x6E, 0x36, 0x36, 0x36, 0x3E, 0x2E, 0x3E, 0x6E, 0xAE,\n\t0x4E, 0x5E, 0x5E, 0x6E, 0x5E, 0x5E, 0x6E, 0x4E, 0x5E, 0x5E, 0x5E, 0x7E, 0x6E, 0x7E, 0x4E, 0xCE,\n\t0x16, 0x16, 0x16, 0x3E, 0x16, 0x16, 0x36, 0x5E, 0x16, 0x16, 0x16, 0x3E, 0x3E, 0x3E, 0x5E, 0x9E,\n\t0x16, 0x16, 0x16, 0x3E, 0x16, 0x16, 0x36, 0x5E, 0x16, 0x16, 0x16, 0x3E, 0x3E, 0x3E, 0x5E, 0x9E,\n\t0x16, 0x16, 0x16, 0x3E, 0x16, 0x16, 0x36, 0x5E, 0x16, 0x16, 0x16, 0x3E, 0x3E, 0x3E, 0x5E, 0x9E,\n\t0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x7E, 0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x7E, 0xBE,\n\t0x2A, 0x3E, 0x3E, 0x2A, 0x3E, 0x3E, 0x2E, 0x6E, 0x3E, 0x3E, 0x3E, 0x3E, 0x2A, 0x3E, 0x6E, 0xAA,\n\t0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x7E,\t0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x7E, 0xBE,\n\t0x4E, 0x5E, 0x5E, 0x6E, 0x5E, 0x5E, 0x6E, 0x4E, 0x5E, 0x5E, 0x5E, 0x7E, 0x6E, 0x7E, 0x4E, 0xCE,\n\t0x8A, 0x9E, 0x9E, 0xAA, 0x9E, 0x9E, 0xAE, 0xCE, 0x9E, 0x9E, 0x9E, 0xBE, 0xAA, 0xBE, 0xCE, 0x8A,\n};\n\nstatic u64 ufs_bitmap_search(struct super_block *sb,\n\t\t\t     struct ufs_cg_private_info *ucpi,\n\t\t\t     u64 goal, unsigned count)\n{\n\t/*\n\t * Bit patterns for identifying fragments in the block map\n\t * used as ((map & mask_arr) == want_arr)\n\t */\n\tstatic const int mask_arr[9] = {\n\t\t0x3, 0x7, 0xf, 0x1f, 0x3f, 0x7f, 0xff, 0x1ff, 0x3ff\n\t};\n\tstatic const int want_arr[9] = {\n\t\t0x0, 0x2, 0x6, 0xe, 0x1e, 0x3e, 0x7e, 0xfe, 0x1fe\n\t};\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tunsigned start, length, loc;\n\tunsigned pos, want, blockmap, mask, end;\n\tu64 result;\n\n\tUFSD(\"ENTER, cg %u, goal %llu, count %u\\n\", ucpi->c_cgx,\n\t     (unsigned long long)goal, count);\n\n\tif (goal)\n\t\tstart = ufs_dtogd(uspi, goal) >> 3;\n\telse\n\t\tstart = ucpi->c_frotor >> 3;\n\t\t\n\tlength = ((uspi->s_fpg + 7) >> 3) - start;\n\tloc = ubh_scanc(uspi, UCPI_UBH(ucpi), ucpi->c_freeoff + start, length,\n\t\t(uspi->s_fpb == 8) ? ufs_fragtable_8fpb : ufs_fragtable_other,\n\t\t1 << (count - 1 + (uspi->s_fpb & 7))); \n\tif (loc == 0) {\n\t\tlength = start + 1;\n\t\tloc = ubh_scanc(uspi, UCPI_UBH(ucpi), ucpi->c_freeoff, length,\n\t\t\t\t(uspi->s_fpb == 8) ? ufs_fragtable_8fpb :\n\t\t\t\tufs_fragtable_other,\n\t\t\t\t1 << (count - 1 + (uspi->s_fpb & 7)));\n\t\tif (loc == 0) {\n\t\t\tufs_error(sb, \"ufs_bitmap_search\",\n\t\t\t\t  \"bitmap corrupted on cg %u, start %u,\"\n\t\t\t\t  \" length %u, count %u, freeoff %u\\n\",\n\t\t\t\t  ucpi->c_cgx, start, length, count,\n\t\t\t\t  ucpi->c_freeoff);\n\t\t\treturn INVBLOCK;\n\t\t}\n\t\tstart = 0;\n\t}\n\tresult = (start + length - loc) << 3;\n\tucpi->c_frotor = result;\n\n\t/*\n\t * found the byte in the map\n\t */\n\n\tfor (end = result + 8; result < end; result += uspi->s_fpb) {\n\t\tblockmap = ubh_blkmap(UCPI_UBH(ucpi), ucpi->c_freeoff, result);\n\t\tblockmap <<= 1;\n\t\tmask = mask_arr[count];\n\t\twant = want_arr[count];\n\t\tfor (pos = 0; pos <= uspi->s_fpb - count; pos++) {\n\t\t\tif ((blockmap & mask) == want) {\n\t\t\t\tUFSD(\"EXIT, result %llu\\n\",\n\t\t\t\t     (unsigned long long)result);\n\t\t\t\treturn result + pos;\n \t\t\t}\n\t\t\tmask <<= 1;\n\t\t\twant <<= 1;\n \t\t}\n \t}\n\n\tufs_error(sb, \"ufs_bitmap_search\", \"block not in map on cg %u\\n\",\n\t\t  ucpi->c_cgx);\n\tUFSD(\"EXIT (FAILED)\\n\");\n\treturn INVBLOCK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubh_isblockset",
          "args": [
            "UCPI_UBH(ucpi)",
            "ucpi->c_freeoff",
            "ufs_fragstoblks(goal)"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_fragstoblks",
          "args": [
            "goal"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_dtogd",
          "args": [
            "uspi",
            "goal"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_blknum",
          "args": [
            "goal"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubh_get_ucg",
          "args": [
            "UCPI_UBH(ucpi)"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"ENTER, goal %llu\\n\"",
            "(unsigned long long)goal"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <asm/byteorder.h>\n#include <linux/bitops.h>\n#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\n#define INVBLOCK ((u64)-1L)\n\nstatic u64 ufs_add_fragments(struct inode *, u64, unsigned, unsigned);\nstatic u64 ufs_alloc_fragments(struct inode *, unsigned, u64, unsigned, int *);\nstatic u64 ufs_alloccg_block(struct inode *, struct ufs_cg_private_info *, u64, int *);\nstatic u64 ufs_bitmap_search (struct super_block *, struct ufs_cg_private_info *, u64, unsigned);\nstatic void ufs_clusteracct(struct super_block *, struct ufs_cg_private_info *, unsigned, int);\n\nstatic u64 ufs_alloccg_block(struct inode *inode,\n\t\t\t     struct ufs_cg_private_info *ucpi,\n\t\t\t     u64 goal, int *err)\n{\n\tstruct super_block * sb;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cylinder_group * ucg;\n\tu64 result, blkno;\n\n\tUFSD(\"ENTER, goal %llu\\n\", (unsigned long long)goal);\n\n\tsb = inode->i_sb;\n\tuspi = UFS_SB(sb)->s_uspi;\n\tucg = ubh_get_ucg(UCPI_UBH(ucpi));\n\n\tif (goal == 0) {\n\t\tgoal = ucpi->c_rotor;\n\t\tgoto norot;\n\t}\n\tgoal = ufs_blknum (goal);\n\tgoal = ufs_dtogd(uspi, goal);\n\t\n\t/*\n\t * If the requested block is available, use it.\n\t */\n\tif (ubh_isblockset(UCPI_UBH(ucpi), ucpi->c_freeoff, ufs_fragstoblks(goal))) {\n\t\tresult = goal;\n\t\tgoto gotit;\n\t}\n\t\nnorot:\t\n\tresult = ufs_bitmap_search (sb, ucpi, goal, uspi->s_fpb);\n\tif (result == INVBLOCK)\n\t\treturn INVBLOCK;\n\tucpi->c_rotor = result;\ngotit:\n\tblkno = ufs_fragstoblks(result);\n\tubh_clrblock (UCPI_UBH(ucpi), ucpi->c_freeoff, blkno);\n\tif ((UFS_SB(sb)->s_flags & UFS_CG_MASK) == UFS_CG_44BSD)\n\t\tufs_clusteracct (sb, ucpi, blkno, -1);\n\n\tfs32_sub(sb, &ucg->cg_cs.cs_nbfree, 1);\n\tuspi->cs_total.cs_nbfree--;\n\tfs32_sub(sb, &UFS_SB(sb)->fs_cs(ucpi->c_cgx).cs_nbfree, 1);\n\n\tif (uspi->fs_magic != UFS2_MAGIC) {\n\t\tunsigned cylno = ufs_cbtocylno((unsigned)result);\n\n\t\tfs16_sub(sb, &ubh_cg_blks(ucpi, cylno,\n\t\t\t\t\t  ufs_cbtorpos((unsigned)result)), 1);\n\t\tfs32_sub(sb, &ubh_cg_blktot(ucpi, cylno), 1);\n\t}\n\t\n\tUFSD(\"EXIT, result %llu\\n\", (unsigned long long)result);\n\n\treturn result;\n}"
  },
  {
    "function_name": "ufs_alloc_fragments",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/balloc.c",
    "lines": "569-677",
    "snippet": "static u64 ufs_alloc_fragments(struct inode *inode, unsigned cgno,\n\t\t\t       u64 goal, unsigned count, int *err)\n{\n\tstruct super_block * sb;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cg_private_info * ucpi;\n\tstruct ufs_cylinder_group * ucg;\n\tunsigned oldcg, i, j, k, allocsize;\n\tu64 result;\n\t\n\tUFSD(\"ENTER, ino %lu, cgno %u, goal %llu, count %u\\n\",\n\t     inode->i_ino, cgno, (unsigned long long)goal, count);\n\n\tsb = inode->i_sb;\n\tuspi = UFS_SB(sb)->s_uspi;\n\toldcg = cgno;\n\t\n\t/*\n\t * 1. searching on preferred cylinder group\n\t */\n\tUFS_TEST_FREE_SPACE_CG\n\n\t/*\n\t * 2. quadratic rehash\n\t */\n\tfor (j = 1; j < uspi->s_ncg; j *= 2) {\n\t\tcgno += j;\n\t\tif (cgno >= uspi->s_ncg) \n\t\t\tcgno -= uspi->s_ncg;\n\t\tUFS_TEST_FREE_SPACE_CG\n\t}\n\n\t/*\n\t * 3. brute force search\n\t * We start at i = 2 ( 0 is checked at 1.step, 1 at 2.step )\n\t */\n\tcgno = (oldcg + 1) % uspi->s_ncg;\n\tfor (j = 2; j < uspi->s_ncg; j++) {\n\t\tcgno++;\n\t\tif (cgno >= uspi->s_ncg)\n\t\t\tcgno = 0;\n\t\tUFS_TEST_FREE_SPACE_CG\n\t}\n\t\n\tUFSD(\"EXIT (FAILED)\\n\");\n\treturn 0;\n\ncg_found:\n\tucpi = ufs_load_cylinder (sb, cgno);\n\tif (!ucpi)\n\t\treturn 0;\n\tucg = ubh_get_ucg (UCPI_UBH(ucpi));\n\tif (!ufs_cg_chkmagic(sb, ucg)) \n\t\tufs_panic (sb, \"ufs_alloc_fragments\",\n\t\t\t\"internal error, bad magic number on cg %u\", cgno);\n\tucg->cg_time = cpu_to_fs32(sb, get_seconds());\n\n\tif (count == uspi->s_fpb) {\n\t\tresult = ufs_alloccg_block (inode, ucpi, goal, err);\n\t\tif (result == INVBLOCK)\n\t\t\treturn 0;\n\t\tgoto succed;\n\t}\n\n\tfor (allocsize = count; allocsize < uspi->s_fpb; allocsize++)\n\t\tif (fs32_to_cpu(sb, ucg->cg_frsum[allocsize]) != 0)\n\t\t\tbreak;\n\t\n\tif (allocsize == uspi->s_fpb) {\n\t\tresult = ufs_alloccg_block (inode, ucpi, goal, err);\n\t\tif (result == INVBLOCK)\n\t\t\treturn 0;\n\t\tgoal = ufs_dtogd(uspi, result);\n\t\tfor (i = count; i < uspi->s_fpb; i++)\n\t\t\tubh_setbit (UCPI_UBH(ucpi), ucpi->c_freeoff, goal + i);\n\t\ti = uspi->s_fpb - count;\n\n\t\tfs32_add(sb, &ucg->cg_cs.cs_nffree, i);\n\t\tuspi->cs_total.cs_nffree += i;\n\t\tfs32_add(sb, &UFS_SB(sb)->fs_cs(cgno).cs_nffree, i);\n\t\tfs32_add(sb, &ucg->cg_frsum[i], 1);\n\t\tgoto succed;\n\t}\n\n\tresult = ufs_bitmap_search (sb, ucpi, goal, allocsize);\n\tif (result == INVBLOCK)\n\t\treturn 0;\n\tfor (i = 0; i < count; i++)\n\t\tubh_clrbit (UCPI_UBH(ucpi), ucpi->c_freeoff, result + i);\n\t\n\tfs32_sub(sb, &ucg->cg_cs.cs_nffree, count);\n\tuspi->cs_total.cs_nffree -= count;\n\tfs32_sub(sb, &UFS_SB(sb)->fs_cs(cgno).cs_nffree, count);\n\tfs32_sub(sb, &ucg->cg_frsum[allocsize], 1);\n\n\tif (count != allocsize)\n\t\tfs32_add(sb, &ucg->cg_frsum[allocsize - count], 1);\n\nsucced:\n\tubh_mark_buffer_dirty (USPI_UBH(uspi));\n\tubh_mark_buffer_dirty (UCPI_UBH(ucpi));\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tubh_sync_block(UCPI_UBH(ucpi));\n\tufs_mark_sb_dirty(sb);\n\n\tresult += cgno * uspi->s_fpg;\n\tUFSD(\"EXIT3, result %llu\\n\", (unsigned long long)result);\n\treturn result;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/bitops.h>",
      "#include <linux/capability.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define UFS_TEST_FREE_SPACE_CG \\\n\tucg = (struct ufs_cylinder_group *) UFS_SB(sb)->s_ucg[cgno]->b_data; \\\n\tif (fs32_to_cpu(sb, ucg->cg_cs.cs_nbfree)) \\\n\t\tgoto cg_found; \\\n\tfor (k = count; k < uspi->s_fpb; k++) \\\n\t\tif (fs32_to_cpu(sb, ucg->cg_frsum[k])) \\\n\t\t\tgoto cg_found;",
      "#define INVBLOCK ((u64)-1L)"
    ],
    "globals_used": [
      "static u64 ufs_add_fragments(struct inode *, u64, unsigned, unsigned);",
      "static u64 ufs_alloc_fragments(struct inode *, unsigned, u64, unsigned, int *);",
      "static u64 ufs_alloccg_block(struct inode *, struct ufs_cg_private_info *, u64, int *);",
      "static u64 ufs_bitmap_search (struct super_block *, struct ufs_cg_private_info *, u64, unsigned);",
      "static void ufs_clusteracct(struct super_block *, struct ufs_cg_private_info *, unsigned, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"EXIT3, result %llu\\n\"",
            "(unsigned long long)result"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_mark_sb_dirty",
          "args": [
            "sb"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_mark_sb_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "732-744",
          "snippet": "void ufs_mark_sb_dirty(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\tunsigned long delay;\n\n\tspin_lock(&sbi->work_lock);\n\tif (!sbi->work_queued) {\n\t\tdelay = msecs_to_jiffies(dirty_writeback_interval * 10);\n\t\tqueue_delayed_work(system_long_wq, &sbi->sync_work, delay);\n\t\tsbi->work_queued = 1;\n\t}\n\tspin_unlock(&sbi->work_lock);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid ufs_mark_sb_dirty(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\tunsigned long delay;\n\n\tspin_lock(&sbi->work_lock);\n\tif (!sbi->work_queued) {\n\t\tdelay = msecs_to_jiffies(dirty_writeback_interval * 10);\n\t\tqueue_delayed_work(system_long_wq, &sbi->sync_work, delay);\n\t\tsbi->work_queued = 1;\n\t}\n\tspin_unlock(&sbi->work_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubh_sync_block",
          "args": [
            "UCPI_UBH(ucpi)"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "ubh_sync_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.c",
          "lines": "115-126",
          "snippet": "void ubh_sync_block(struct ufs_buffer_head *ubh)\n{\n\tif (ubh) {\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < ubh->count; i++)\n\t\t\twrite_dirty_buffer(ubh->bh[i], WRITE);\n\n\t\tfor (i = 0; i < ubh->count; i++)\n\t\t\twait_on_buffer(ubh->bh[i]);\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid ubh_sync_block(struct ufs_buffer_head *ubh)\n{\n\tif (ubh) {\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < ubh->count; i++)\n\t\t\twrite_dirty_buffer(ubh->bh[i], WRITE);\n\n\t\tfor (i = 0; i < ubh->count; i++)\n\t\t\twait_on_buffer(ubh->bh[i]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "UCPI_UBH",
          "args": [
            "ucpi"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "UCPI_UBH",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "22-25",
          "snippet": "static inline struct ufs_buffer_head *UCPI_UBH(struct ufs_cg_private_info *cpi)\n{\n\treturn &cpi->c_ubh;\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ubh_brelse (struct ufs_buffer_head *);",
            "extern void ubh_mark_buffer_dirty (struct ufs_buffer_head *);",
            "extern void ubh_mark_buffer_uptodate (struct ufs_buffer_head *, int);",
            "extern void ubh_sync_block(struct ufs_buffer_head *);",
            "extern void ubh_bforget (struct ufs_buffer_head *);",
            "extern int  ubh_buffer_dirty (struct ufs_buffer_head *);",
            "extern void _ubh_ubhcpymem_(struct ufs_sb_private_info *, unsigned char *, struct ufs_buffer_head *, unsigned);",
            "extern void _ubh_memcpyubh_(struct ufs_sb_private_info *, struct ufs_buffer_head *, unsigned char *, unsigned);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nextern void ubh_brelse (struct ufs_buffer_head *);\nextern void ubh_mark_buffer_dirty (struct ufs_buffer_head *);\nextern void ubh_mark_buffer_uptodate (struct ufs_buffer_head *, int);\nextern void ubh_sync_block(struct ufs_buffer_head *);\nextern void ubh_bforget (struct ufs_buffer_head *);\nextern int  ubh_buffer_dirty (struct ufs_buffer_head *);\nextern void _ubh_ubhcpymem_(struct ufs_sb_private_info *, unsigned char *, struct ufs_buffer_head *, unsigned);\nextern void _ubh_memcpyubh_(struct ufs_sb_private_info *, struct ufs_buffer_head *, unsigned char *, unsigned);\n\nstatic inline struct ufs_buffer_head *UCPI_UBH(struct ufs_cg_private_info *cpi)\n{\n\treturn &cpi->c_ubh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubh_mark_buffer_dirty",
          "args": [
            "UCPI_UBH(ucpi)"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "ubh_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.c",
          "lines": "92-99",
          "snippet": "void ubh_mark_buffer_dirty (struct ufs_buffer_head * ubh)\n{\n\tunsigned i;\n\tif (!ubh)\n\t\treturn;\n\tfor ( i = 0; i < ubh->count; i++ )\n\t\tmark_buffer_dirty (ubh->bh[i]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid ubh_mark_buffer_dirty (struct ufs_buffer_head * ubh)\n{\n\tunsigned i;\n\tif (!ubh)\n\t\treturn;\n\tfor ( i = 0; i < ubh->count; i++ )\n\t\tmark_buffer_dirty (ubh->bh[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "USPI_UBH",
          "args": [
            "uspi"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "USPI_UBH",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "26-29",
          "snippet": "static inline struct ufs_buffer_head *USPI_UBH(struct ufs_sb_private_info *spi)\n{\n\treturn &spi->s_ubh;\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ubh_brelse (struct ufs_buffer_head *);",
            "extern void ubh_brelse_uspi (struct ufs_sb_private_info *);",
            "extern void ubh_mark_buffer_dirty (struct ufs_buffer_head *);",
            "extern void ubh_mark_buffer_uptodate (struct ufs_buffer_head *, int);",
            "extern void ubh_sync_block(struct ufs_buffer_head *);",
            "extern void ubh_bforget (struct ufs_buffer_head *);",
            "extern int  ubh_buffer_dirty (struct ufs_buffer_head *);",
            "extern void _ubh_ubhcpymem_(struct ufs_sb_private_info *, unsigned char *, struct ufs_buffer_head *, unsigned);",
            "extern void _ubh_memcpyubh_(struct ufs_sb_private_info *, struct ufs_buffer_head *, unsigned char *, unsigned);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nextern void ubh_brelse (struct ufs_buffer_head *);\nextern void ubh_brelse_uspi (struct ufs_sb_private_info *);\nextern void ubh_mark_buffer_dirty (struct ufs_buffer_head *);\nextern void ubh_mark_buffer_uptodate (struct ufs_buffer_head *, int);\nextern void ubh_sync_block(struct ufs_buffer_head *);\nextern void ubh_bforget (struct ufs_buffer_head *);\nextern int  ubh_buffer_dirty (struct ufs_buffer_head *);\nextern void _ubh_ubhcpymem_(struct ufs_sb_private_info *, unsigned char *, struct ufs_buffer_head *, unsigned);\nextern void _ubh_memcpyubh_(struct ufs_sb_private_info *, struct ufs_buffer_head *, unsigned char *, unsigned);\n\nstatic inline struct ufs_buffer_head *USPI_UBH(struct ufs_sb_private_info *spi)\n{\n\treturn &spi->s_ubh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs32_add",
          "args": [
            "sb",
            "&ucg->cg_frsum[allocsize - count]",
            "1"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "fs32_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "61-68",
          "snippet": "static inline void\nfs32_add(struct super_block *sbp, __fs32 *n, int d)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\tle32_add_cpu((__le32 *)n, d);\n\telse\n\t\tbe32_add_cpu((__be32 *)n, d);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nfs32_add(struct super_block *sbp, __fs32 *n, int d)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\tle32_add_cpu((__le32 *)n, d);\n\telse\n\t\tbe32_add_cpu((__be32 *)n, d);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs32_sub",
          "args": [
            "sb",
            "&ucg->cg_frsum[allocsize]",
            "1"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "fs32_sub",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "70-77",
          "snippet": "static inline void\nfs32_sub(struct super_block *sbp, __fs32 *n, int d)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\tle32_add_cpu((__le32 *)n, -d);\n\telse\n\t\tbe32_add_cpu((__be32 *)n, -d);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nfs32_sub(struct super_block *sbp, __fs32 *n, int d)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\tle32_add_cpu((__le32 *)n, -d);\n\telse\n\t\tbe32_add_cpu((__be32 *)n, -d);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "cgno"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubh_clrbit",
          "args": [
            "UCPI_UBH(ucpi)",
            "ucpi->c_freeoff",
            "result + i"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_bitmap_search",
          "args": [
            "sb",
            "ucpi",
            "goal",
            "allocsize"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_bitmap_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/balloc.c",
          "lines": "772-846",
          "snippet": "static u64 ufs_bitmap_search(struct super_block *sb,\n\t\t\t     struct ufs_cg_private_info *ucpi,\n\t\t\t     u64 goal, unsigned count)\n{\n\t/*\n\t * Bit patterns for identifying fragments in the block map\n\t * used as ((map & mask_arr) == want_arr)\n\t */\n\tstatic const int mask_arr[9] = {\n\t\t0x3, 0x7, 0xf, 0x1f, 0x3f, 0x7f, 0xff, 0x1ff, 0x3ff\n\t};\n\tstatic const int want_arr[9] = {\n\t\t0x0, 0x2, 0x6, 0xe, 0x1e, 0x3e, 0x7e, 0xfe, 0x1fe\n\t};\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tunsigned start, length, loc;\n\tunsigned pos, want, blockmap, mask, end;\n\tu64 result;\n\n\tUFSD(\"ENTER, cg %u, goal %llu, count %u\\n\", ucpi->c_cgx,\n\t     (unsigned long long)goal, count);\n\n\tif (goal)\n\t\tstart = ufs_dtogd(uspi, goal) >> 3;\n\telse\n\t\tstart = ucpi->c_frotor >> 3;\n\t\t\n\tlength = ((uspi->s_fpg + 7) >> 3) - start;\n\tloc = ubh_scanc(uspi, UCPI_UBH(ucpi), ucpi->c_freeoff + start, length,\n\t\t(uspi->s_fpb == 8) ? ufs_fragtable_8fpb : ufs_fragtable_other,\n\t\t1 << (count - 1 + (uspi->s_fpb & 7))); \n\tif (loc == 0) {\n\t\tlength = start + 1;\n\t\tloc = ubh_scanc(uspi, UCPI_UBH(ucpi), ucpi->c_freeoff, length,\n\t\t\t\t(uspi->s_fpb == 8) ? ufs_fragtable_8fpb :\n\t\t\t\tufs_fragtable_other,\n\t\t\t\t1 << (count - 1 + (uspi->s_fpb & 7)));\n\t\tif (loc == 0) {\n\t\t\tufs_error(sb, \"ufs_bitmap_search\",\n\t\t\t\t  \"bitmap corrupted on cg %u, start %u,\"\n\t\t\t\t  \" length %u, count %u, freeoff %u\\n\",\n\t\t\t\t  ucpi->c_cgx, start, length, count,\n\t\t\t\t  ucpi->c_freeoff);\n\t\t\treturn INVBLOCK;\n\t\t}\n\t\tstart = 0;\n\t}\n\tresult = (start + length - loc) << 3;\n\tucpi->c_frotor = result;\n\n\t/*\n\t * found the byte in the map\n\t */\n\n\tfor (end = result + 8; result < end; result += uspi->s_fpb) {\n\t\tblockmap = ubh_blkmap(UCPI_UBH(ucpi), ucpi->c_freeoff, result);\n\t\tblockmap <<= 1;\n\t\tmask = mask_arr[count];\n\t\twant = want_arr[count];\n\t\tfor (pos = 0; pos <= uspi->s_fpb - count; pos++) {\n\t\t\tif ((blockmap & mask) == want) {\n\t\t\t\tUFSD(\"EXIT, result %llu\\n\",\n\t\t\t\t     (unsigned long long)result);\n\t\t\t\treturn result + pos;\n \t\t\t}\n\t\t\tmask <<= 1;\n\t\t\twant <<= 1;\n \t\t}\n \t}\n\n\tufs_error(sb, \"ufs_bitmap_search\", \"block not in map on cg %u\\n\",\n\t\t  ucpi->c_cgx);\n\tUFSD(\"EXIT (FAILED)\\n\");\n\treturn INVBLOCK;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/bitops.h>",
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define INVBLOCK ((u64)-1L)"
          ],
          "globals_used": [
            "static u64 ufs_add_fragments(struct inode *, u64, unsigned, unsigned);",
            "static u64 ufs_alloc_fragments(struct inode *, unsigned, u64, unsigned, int *);",
            "static u64 ufs_alloccg_block(struct inode *, struct ufs_cg_private_info *, u64, int *);",
            "static u64 ufs_bitmap_search (struct super_block *, struct ufs_cg_private_info *, u64, unsigned);",
            "static unsigned char ufs_fragtable_8fpb[], ufs_fragtable_other[];",
            "static void ufs_clusteracct(struct super_block *, struct ufs_cg_private_info *, unsigned, int);",
            "static unsigned char ufs_fragtable_8fpb[] = {\n\t0x00, 0x01, 0x01, 0x02, 0x01, 0x01, 0x02, 0x04, 0x01, 0x01, 0x01, 0x03, 0x02, 0x03, 0x04, 0x08,\n\t0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x03, 0x05, 0x02, 0x03, 0x03, 0x02, 0x04, 0x05, 0x08, 0x10,\n\t0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x03, 0x05, 0x01, 0x01, 0x01, 0x03, 0x03, 0x03, 0x05, 0x09,\n\t0x02, 0x03, 0x03, 0x02, 0x03, 0x03, 0x02, 0x06, 0x04, 0x05, 0x05, 0x06, 0x08, 0x09, 0x10, 0x20,\n\t0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x03, 0x05, 0x01, 0x01, 0x01, 0x03, 0x03, 0x03, 0x05, 0x09,\t\n\t0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x03, 0x05, 0x03, 0x03, 0x03, 0x03, 0x05, 0x05, 0x09, 0x11,\n\t0x02, 0x03, 0x03, 0x02, 0x03, 0x03, 0x02, 0x06, 0x03, 0x03, 0x03, 0x03, 0x02, 0x03, 0x06, 0x0A,\n\t0x04, 0x05, 0x05, 0x06, 0x05, 0x05, 0x06, 0x04, 0x08, 0x09, 0x09, 0x0A, 0x10, 0x11, 0x20, 0x40,\n\t0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x03, 0x05, 0x01, 0x01, 0x01, 0x03, 0x03, 0x03, 0x05, 0x09,\n\t0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x03, 0x05, 0x03, 0x03, 0x03, 0x03, 0x05, 0x05, 0x09, 0x11,\n\t0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x03, 0x05, 0x01, 0x01, 0x01, 0x03, 0x03, 0x03, 0x05, 0x09,\n\t0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x07, 0x05, 0x05, 0x05, 0x07, 0x09, 0x09, 0x11, 0x21,\n\t0x02, 0x03, 0x03, 0x02, 0x03, 0x03, 0x02, 0x06, 0x03, 0x03, 0x03, 0x03, 0x02, 0x03, 0x06, 0x0A,\n\t0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x07, 0x02, 0x03, 0x03, 0x02, 0x06, 0x07, 0x0A, 0x12,\n\t0x04, 0x05, 0x05, 0x06, 0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x05, 0x07, 0x06, 0x07, 0x04, 0x0C,\n\t0x08, 0x09, 0x09, 0x0A, 0x09, 0x09, 0x0A, 0x0C, 0x10, 0x11, 0x11, 0x12, 0x20, 0x21, 0x40, 0x80,\n};",
            "static unsigned char ufs_fragtable_other[] = {\n\t0x00, 0x16, 0x16, 0x2A, 0x16, 0x16, 0x26, 0x4E, 0x16, 0x16, 0x16, 0x3E, 0x2A, 0x3E, 0x4E, 0x8A,\n\t0x16, 0x16, 0x16, 0x3E, 0x16, 0x16, 0x36, 0x5E, 0x16, 0x16, 0x16, 0x3E, 0x3E, 0x3E, 0x5E, 0x9E,\n\t0x16, 0x16, 0x16, 0x3E, 0x16, 0x16, 0x36, 0x5E, 0x16, 0x16, 0x16, 0x3E, 0x3E, 0x3E, 0x5E, 0x9E,\n\t0x2A, 0x3E, 0x3E, 0x2A, 0x3E, 0x3E, 0x2E, 0x6E, 0x3E, 0x3E, 0x3E, 0x3E, 0x2A, 0x3E, 0x6E, 0xAA,\n\t0x16, 0x16, 0x16, 0x3E, 0x16, 0x16, 0x36, 0x5E, 0x16, 0x16, 0x16, 0x3E, 0x3E, 0x3E, 0x5E, 0x9E,\n\t0x16, 0x16, 0x16, 0x3E, 0x16, 0x16, 0x36, 0x5E, 0x16, 0x16, 0x16, 0x3E, 0x3E, 0x3E, 0x5E, 0x9E,\n\t0x26, 0x36, 0x36, 0x2E, 0x36, 0x36, 0x26, 0x6E, 0x36, 0x36, 0x36, 0x3E, 0x2E, 0x3E, 0x6E, 0xAE,\n\t0x4E, 0x5E, 0x5E, 0x6E, 0x5E, 0x5E, 0x6E, 0x4E, 0x5E, 0x5E, 0x5E, 0x7E, 0x6E, 0x7E, 0x4E, 0xCE,\n\t0x16, 0x16, 0x16, 0x3E, 0x16, 0x16, 0x36, 0x5E, 0x16, 0x16, 0x16, 0x3E, 0x3E, 0x3E, 0x5E, 0x9E,\n\t0x16, 0x16, 0x16, 0x3E, 0x16, 0x16, 0x36, 0x5E, 0x16, 0x16, 0x16, 0x3E, 0x3E, 0x3E, 0x5E, 0x9E,\n\t0x16, 0x16, 0x16, 0x3E, 0x16, 0x16, 0x36, 0x5E, 0x16, 0x16, 0x16, 0x3E, 0x3E, 0x3E, 0x5E, 0x9E,\n\t0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x7E, 0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x7E, 0xBE,\n\t0x2A, 0x3E, 0x3E, 0x2A, 0x3E, 0x3E, 0x2E, 0x6E, 0x3E, 0x3E, 0x3E, 0x3E, 0x2A, 0x3E, 0x6E, 0xAA,\n\t0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x7E,\t0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x7E, 0xBE,\n\t0x4E, 0x5E, 0x5E, 0x6E, 0x5E, 0x5E, 0x6E, 0x4E, 0x5E, 0x5E, 0x5E, 0x7E, 0x6E, 0x7E, 0x4E, 0xCE,\n\t0x8A, 0x9E, 0x9E, 0xAA, 0x9E, 0x9E, 0xAE, 0xCE, 0x9E, 0x9E, 0x9E, 0xBE, 0xAA, 0xBE, 0xCE, 0x8A,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <asm/byteorder.h>\n#include <linux/bitops.h>\n#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\n#define INVBLOCK ((u64)-1L)\n\nstatic u64 ufs_add_fragments(struct inode *, u64, unsigned, unsigned);\nstatic u64 ufs_alloc_fragments(struct inode *, unsigned, u64, unsigned, int *);\nstatic u64 ufs_alloccg_block(struct inode *, struct ufs_cg_private_info *, u64, int *);\nstatic u64 ufs_bitmap_search (struct super_block *, struct ufs_cg_private_info *, u64, unsigned);\nstatic unsigned char ufs_fragtable_8fpb[], ufs_fragtable_other[];\nstatic void ufs_clusteracct(struct super_block *, struct ufs_cg_private_info *, unsigned, int);\nstatic unsigned char ufs_fragtable_8fpb[] = {\n\t0x00, 0x01, 0x01, 0x02, 0x01, 0x01, 0x02, 0x04, 0x01, 0x01, 0x01, 0x03, 0x02, 0x03, 0x04, 0x08,\n\t0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x03, 0x05, 0x02, 0x03, 0x03, 0x02, 0x04, 0x05, 0x08, 0x10,\n\t0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x03, 0x05, 0x01, 0x01, 0x01, 0x03, 0x03, 0x03, 0x05, 0x09,\n\t0x02, 0x03, 0x03, 0x02, 0x03, 0x03, 0x02, 0x06, 0x04, 0x05, 0x05, 0x06, 0x08, 0x09, 0x10, 0x20,\n\t0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x03, 0x05, 0x01, 0x01, 0x01, 0x03, 0x03, 0x03, 0x05, 0x09,\t\n\t0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x03, 0x05, 0x03, 0x03, 0x03, 0x03, 0x05, 0x05, 0x09, 0x11,\n\t0x02, 0x03, 0x03, 0x02, 0x03, 0x03, 0x02, 0x06, 0x03, 0x03, 0x03, 0x03, 0x02, 0x03, 0x06, 0x0A,\n\t0x04, 0x05, 0x05, 0x06, 0x05, 0x05, 0x06, 0x04, 0x08, 0x09, 0x09, 0x0A, 0x10, 0x11, 0x20, 0x40,\n\t0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x03, 0x05, 0x01, 0x01, 0x01, 0x03, 0x03, 0x03, 0x05, 0x09,\n\t0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x03, 0x05, 0x03, 0x03, 0x03, 0x03, 0x05, 0x05, 0x09, 0x11,\n\t0x01, 0x01, 0x01, 0x03, 0x01, 0x01, 0x03, 0x05, 0x01, 0x01, 0x01, 0x03, 0x03, 0x03, 0x05, 0x09,\n\t0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x07, 0x05, 0x05, 0x05, 0x07, 0x09, 0x09, 0x11, 0x21,\n\t0x02, 0x03, 0x03, 0x02, 0x03, 0x03, 0x02, 0x06, 0x03, 0x03, 0x03, 0x03, 0x02, 0x03, 0x06, 0x0A,\n\t0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x07, 0x02, 0x03, 0x03, 0x02, 0x06, 0x07, 0x0A, 0x12,\n\t0x04, 0x05, 0x05, 0x06, 0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x05, 0x07, 0x06, 0x07, 0x04, 0x0C,\n\t0x08, 0x09, 0x09, 0x0A, 0x09, 0x09, 0x0A, 0x0C, 0x10, 0x11, 0x11, 0x12, 0x20, 0x21, 0x40, 0x80,\n};\nstatic unsigned char ufs_fragtable_other[] = {\n\t0x00, 0x16, 0x16, 0x2A, 0x16, 0x16, 0x26, 0x4E, 0x16, 0x16, 0x16, 0x3E, 0x2A, 0x3E, 0x4E, 0x8A,\n\t0x16, 0x16, 0x16, 0x3E, 0x16, 0x16, 0x36, 0x5E, 0x16, 0x16, 0x16, 0x3E, 0x3E, 0x3E, 0x5E, 0x9E,\n\t0x16, 0x16, 0x16, 0x3E, 0x16, 0x16, 0x36, 0x5E, 0x16, 0x16, 0x16, 0x3E, 0x3E, 0x3E, 0x5E, 0x9E,\n\t0x2A, 0x3E, 0x3E, 0x2A, 0x3E, 0x3E, 0x2E, 0x6E, 0x3E, 0x3E, 0x3E, 0x3E, 0x2A, 0x3E, 0x6E, 0xAA,\n\t0x16, 0x16, 0x16, 0x3E, 0x16, 0x16, 0x36, 0x5E, 0x16, 0x16, 0x16, 0x3E, 0x3E, 0x3E, 0x5E, 0x9E,\n\t0x16, 0x16, 0x16, 0x3E, 0x16, 0x16, 0x36, 0x5E, 0x16, 0x16, 0x16, 0x3E, 0x3E, 0x3E, 0x5E, 0x9E,\n\t0x26, 0x36, 0x36, 0x2E, 0x36, 0x36, 0x26, 0x6E, 0x36, 0x36, 0x36, 0x3E, 0x2E, 0x3E, 0x6E, 0xAE,\n\t0x4E, 0x5E, 0x5E, 0x6E, 0x5E, 0x5E, 0x6E, 0x4E, 0x5E, 0x5E, 0x5E, 0x7E, 0x6E, 0x7E, 0x4E, 0xCE,\n\t0x16, 0x16, 0x16, 0x3E, 0x16, 0x16, 0x36, 0x5E, 0x16, 0x16, 0x16, 0x3E, 0x3E, 0x3E, 0x5E, 0x9E,\n\t0x16, 0x16, 0x16, 0x3E, 0x16, 0x16, 0x36, 0x5E, 0x16, 0x16, 0x16, 0x3E, 0x3E, 0x3E, 0x5E, 0x9E,\n\t0x16, 0x16, 0x16, 0x3E, 0x16, 0x16, 0x36, 0x5E, 0x16, 0x16, 0x16, 0x3E, 0x3E, 0x3E, 0x5E, 0x9E,\n\t0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x7E, 0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x7E, 0xBE,\n\t0x2A, 0x3E, 0x3E, 0x2A, 0x3E, 0x3E, 0x2E, 0x6E, 0x3E, 0x3E, 0x3E, 0x3E, 0x2A, 0x3E, 0x6E, 0xAA,\n\t0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x7E,\t0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x7E, 0xBE,\n\t0x4E, 0x5E, 0x5E, 0x6E, 0x5E, 0x5E, 0x6E, 0x4E, 0x5E, 0x5E, 0x5E, 0x7E, 0x6E, 0x7E, 0x4E, 0xCE,\n\t0x8A, 0x9E, 0x9E, 0xAA, 0x9E, 0x9E, 0xAE, 0xCE, 0x9E, 0x9E, 0x9E, 0xBE, 0xAA, 0xBE, 0xCE, 0x8A,\n};\n\nstatic u64 ufs_bitmap_search(struct super_block *sb,\n\t\t\t     struct ufs_cg_private_info *ucpi,\n\t\t\t     u64 goal, unsigned count)\n{\n\t/*\n\t * Bit patterns for identifying fragments in the block map\n\t * used as ((map & mask_arr) == want_arr)\n\t */\n\tstatic const int mask_arr[9] = {\n\t\t0x3, 0x7, 0xf, 0x1f, 0x3f, 0x7f, 0xff, 0x1ff, 0x3ff\n\t};\n\tstatic const int want_arr[9] = {\n\t\t0x0, 0x2, 0x6, 0xe, 0x1e, 0x3e, 0x7e, 0xfe, 0x1fe\n\t};\n\tstruct ufs_sb_private_info *uspi = UFS_SB(sb)->s_uspi;\n\tunsigned start, length, loc;\n\tunsigned pos, want, blockmap, mask, end;\n\tu64 result;\n\n\tUFSD(\"ENTER, cg %u, goal %llu, count %u\\n\", ucpi->c_cgx,\n\t     (unsigned long long)goal, count);\n\n\tif (goal)\n\t\tstart = ufs_dtogd(uspi, goal) >> 3;\n\telse\n\t\tstart = ucpi->c_frotor >> 3;\n\t\t\n\tlength = ((uspi->s_fpg + 7) >> 3) - start;\n\tloc = ubh_scanc(uspi, UCPI_UBH(ucpi), ucpi->c_freeoff + start, length,\n\t\t(uspi->s_fpb == 8) ? ufs_fragtable_8fpb : ufs_fragtable_other,\n\t\t1 << (count - 1 + (uspi->s_fpb & 7))); \n\tif (loc == 0) {\n\t\tlength = start + 1;\n\t\tloc = ubh_scanc(uspi, UCPI_UBH(ucpi), ucpi->c_freeoff, length,\n\t\t\t\t(uspi->s_fpb == 8) ? ufs_fragtable_8fpb :\n\t\t\t\tufs_fragtable_other,\n\t\t\t\t1 << (count - 1 + (uspi->s_fpb & 7)));\n\t\tif (loc == 0) {\n\t\t\tufs_error(sb, \"ufs_bitmap_search\",\n\t\t\t\t  \"bitmap corrupted on cg %u, start %u,\"\n\t\t\t\t  \" length %u, count %u, freeoff %u\\n\",\n\t\t\t\t  ucpi->c_cgx, start, length, count,\n\t\t\t\t  ucpi->c_freeoff);\n\t\t\treturn INVBLOCK;\n\t\t}\n\t\tstart = 0;\n\t}\n\tresult = (start + length - loc) << 3;\n\tucpi->c_frotor = result;\n\n\t/*\n\t * found the byte in the map\n\t */\n\n\tfor (end = result + 8; result < end; result += uspi->s_fpb) {\n\t\tblockmap = ubh_blkmap(UCPI_UBH(ucpi), ucpi->c_freeoff, result);\n\t\tblockmap <<= 1;\n\t\tmask = mask_arr[count];\n\t\twant = want_arr[count];\n\t\tfor (pos = 0; pos <= uspi->s_fpb - count; pos++) {\n\t\t\tif ((blockmap & mask) == want) {\n\t\t\t\tUFSD(\"EXIT, result %llu\\n\",\n\t\t\t\t     (unsigned long long)result);\n\t\t\t\treturn result + pos;\n \t\t\t}\n\t\t\tmask <<= 1;\n\t\t\twant <<= 1;\n \t\t}\n \t}\n\n\tufs_error(sb, \"ufs_bitmap_search\", \"block not in map on cg %u\\n\",\n\t\t  ucpi->c_cgx);\n\tUFSD(\"EXIT (FAILED)\\n\");\n\treturn INVBLOCK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "cgno"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubh_setbit",
          "args": [
            "UCPI_UBH(ucpi)",
            "ucpi->c_freeoff",
            "goal + i"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_dtogd",
          "args": [
            "uspi",
            "result"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_alloccg_block",
          "args": [
            "inode",
            "ucpi",
            "goal",
            "err"
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_alloccg_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/balloc.c",
          "lines": "679-735",
          "snippet": "static u64 ufs_alloccg_block(struct inode *inode,\n\t\t\t     struct ufs_cg_private_info *ucpi,\n\t\t\t     u64 goal, int *err)\n{\n\tstruct super_block * sb;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cylinder_group * ucg;\n\tu64 result, blkno;\n\n\tUFSD(\"ENTER, goal %llu\\n\", (unsigned long long)goal);\n\n\tsb = inode->i_sb;\n\tuspi = UFS_SB(sb)->s_uspi;\n\tucg = ubh_get_ucg(UCPI_UBH(ucpi));\n\n\tif (goal == 0) {\n\t\tgoal = ucpi->c_rotor;\n\t\tgoto norot;\n\t}\n\tgoal = ufs_blknum (goal);\n\tgoal = ufs_dtogd(uspi, goal);\n\t\n\t/*\n\t * If the requested block is available, use it.\n\t */\n\tif (ubh_isblockset(UCPI_UBH(ucpi), ucpi->c_freeoff, ufs_fragstoblks(goal))) {\n\t\tresult = goal;\n\t\tgoto gotit;\n\t}\n\t\nnorot:\t\n\tresult = ufs_bitmap_search (sb, ucpi, goal, uspi->s_fpb);\n\tif (result == INVBLOCK)\n\t\treturn INVBLOCK;\n\tucpi->c_rotor = result;\ngotit:\n\tblkno = ufs_fragstoblks(result);\n\tubh_clrblock (UCPI_UBH(ucpi), ucpi->c_freeoff, blkno);\n\tif ((UFS_SB(sb)->s_flags & UFS_CG_MASK) == UFS_CG_44BSD)\n\t\tufs_clusteracct (sb, ucpi, blkno, -1);\n\n\tfs32_sub(sb, &ucg->cg_cs.cs_nbfree, 1);\n\tuspi->cs_total.cs_nbfree--;\n\tfs32_sub(sb, &UFS_SB(sb)->fs_cs(ucpi->c_cgx).cs_nbfree, 1);\n\n\tif (uspi->fs_magic != UFS2_MAGIC) {\n\t\tunsigned cylno = ufs_cbtocylno((unsigned)result);\n\n\t\tfs16_sub(sb, &ubh_cg_blks(ucpi, cylno,\n\t\t\t\t\t  ufs_cbtorpos((unsigned)result)), 1);\n\t\tfs32_sub(sb, &ubh_cg_blktot(ucpi, cylno), 1);\n\t}\n\t\n\tUFSD(\"EXIT, result %llu\\n\", (unsigned long long)result);\n\n\treturn result;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/bitops.h>",
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define INVBLOCK ((u64)-1L)"
          ],
          "globals_used": [
            "static u64 ufs_add_fragments(struct inode *, u64, unsigned, unsigned);",
            "static u64 ufs_alloc_fragments(struct inode *, unsigned, u64, unsigned, int *);",
            "static u64 ufs_alloccg_block(struct inode *, struct ufs_cg_private_info *, u64, int *);",
            "static u64 ufs_bitmap_search (struct super_block *, struct ufs_cg_private_info *, u64, unsigned);",
            "static void ufs_clusteracct(struct super_block *, struct ufs_cg_private_info *, unsigned, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <asm/byteorder.h>\n#include <linux/bitops.h>\n#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\n#define INVBLOCK ((u64)-1L)\n\nstatic u64 ufs_add_fragments(struct inode *, u64, unsigned, unsigned);\nstatic u64 ufs_alloc_fragments(struct inode *, unsigned, u64, unsigned, int *);\nstatic u64 ufs_alloccg_block(struct inode *, struct ufs_cg_private_info *, u64, int *);\nstatic u64 ufs_bitmap_search (struct super_block *, struct ufs_cg_private_info *, u64, unsigned);\nstatic void ufs_clusteracct(struct super_block *, struct ufs_cg_private_info *, unsigned, int);\n\nstatic u64 ufs_alloccg_block(struct inode *inode,\n\t\t\t     struct ufs_cg_private_info *ucpi,\n\t\t\t     u64 goal, int *err)\n{\n\tstruct super_block * sb;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cylinder_group * ucg;\n\tu64 result, blkno;\n\n\tUFSD(\"ENTER, goal %llu\\n\", (unsigned long long)goal);\n\n\tsb = inode->i_sb;\n\tuspi = UFS_SB(sb)->s_uspi;\n\tucg = ubh_get_ucg(UCPI_UBH(ucpi));\n\n\tif (goal == 0) {\n\t\tgoal = ucpi->c_rotor;\n\t\tgoto norot;\n\t}\n\tgoal = ufs_blknum (goal);\n\tgoal = ufs_dtogd(uspi, goal);\n\t\n\t/*\n\t * If the requested block is available, use it.\n\t */\n\tif (ubh_isblockset(UCPI_UBH(ucpi), ucpi->c_freeoff, ufs_fragstoblks(goal))) {\n\t\tresult = goal;\n\t\tgoto gotit;\n\t}\n\t\nnorot:\t\n\tresult = ufs_bitmap_search (sb, ucpi, goal, uspi->s_fpb);\n\tif (result == INVBLOCK)\n\t\treturn INVBLOCK;\n\tucpi->c_rotor = result;\ngotit:\n\tblkno = ufs_fragstoblks(result);\n\tubh_clrblock (UCPI_UBH(ucpi), ucpi->c_freeoff, blkno);\n\tif ((UFS_SB(sb)->s_flags & UFS_CG_MASK) == UFS_CG_44BSD)\n\t\tufs_clusteracct (sb, ucpi, blkno, -1);\n\n\tfs32_sub(sb, &ucg->cg_cs.cs_nbfree, 1);\n\tuspi->cs_total.cs_nbfree--;\n\tfs32_sub(sb, &UFS_SB(sb)->fs_cs(ucpi->c_cgx).cs_nbfree, 1);\n\n\tif (uspi->fs_magic != UFS2_MAGIC) {\n\t\tunsigned cylno = ufs_cbtocylno((unsigned)result);\n\n\t\tfs16_sub(sb, &ubh_cg_blks(ucpi, cylno,\n\t\t\t\t\t  ufs_cbtorpos((unsigned)result)), 1);\n\t\tfs32_sub(sb, &ubh_cg_blktot(ucpi, cylno), 1);\n\t}\n\t\n\tUFSD(\"EXIT, result %llu\\n\", (unsigned long long)result);\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs32_to_cpu",
          "args": [
            "sb",
            "ucg->cg_frsum[allocsize]"
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "fs32_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "43-50",
          "snippet": "static inline u32\nfs32_to_cpu(struct super_block *sbp, __fs32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u32\nfs32_to_cpu(struct super_block *sbp, __fs32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_fs32",
          "args": [
            "sb",
            "get_seconds()"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_to_fs32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "52-59",
          "snippet": "static inline __fs32\ncpu_to_fs32(struct super_block *sbp, u32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn (__force __fs32)cpu_to_le32(n);\n\telse\n\t\treturn (__force __fs32)cpu_to_be32(n);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline __fs32\ncpu_to_fs32(struct super_block *sbp, u32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn (__force __fs32)cpu_to_le32(n);\n\telse\n\t\treturn (__force __fs32)cpu_to_be32(n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_panic",
          "args": [
            "sb",
            "\"ufs_alloc_fragments\"",
            "\"internal error, bad magic number on cg %u\"",
            "cgno"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "319-342",
          "snippet": "void ufs_panic (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct va_format vaf;\n\tva_list args;\n\t\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\t\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tusb1->fs_clean = UFS_FSBAD;\n\t\tubh_mark_buffer_dirty(USPI_UBH(uspi));\n\t\tufs_mark_sb_dirty(sb);\n\t}\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tsb->s_flags |= MS_RDONLY;\n\tpr_crit(\"panic (device %s): %s: %pV\\n\",\n\t\tsb->s_id, function, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid ufs_panic (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct va_format vaf;\n\tva_list args;\n\t\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\t\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tusb1->fs_clean = UFS_FSBAD;\n\t\tubh_mark_buffer_dirty(USPI_UBH(uspi));\n\t\tufs_mark_sb_dirty(sb);\n\t}\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tsb->s_flags |= MS_RDONLY;\n\tpr_crit(\"panic (device %s): %s: %pV\\n\",\n\t\tsb->s_id, function, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_cg_chkmagic",
          "args": [
            "sb",
            "ucg"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubh_get_ucg",
          "args": [
            "UCPI_UBH(ucpi)"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_load_cylinder",
          "args": [
            "sb",
            "cgno"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_load_cylinder",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/cylinder.c",
          "lines": "126-201",
          "snippet": "struct ufs_cg_private_info * ufs_load_cylinder (\n\tstruct super_block * sb, unsigned cgno)\n{\n\tstruct ufs_sb_info * sbi = UFS_SB(sb);\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cg_private_info * ucpi;\n\tunsigned cg, i, j;\n\n\tUFSD(\"ENTER, cgno %u\\n\", cgno);\n\n\tuspi = sbi->s_uspi;\n\tif (cgno >= uspi->s_ncg) {\n\t\tufs_panic (sb, \"ufs_load_cylinder\", \"internal error, high number of cg\");\n\t\treturn NULL;\n\t}\n\t/*\n\t * Cylinder group number cg it in cache and it was last used\n\t */\n\tif (sbi->s_cgno[0] == cgno) {\n\t\tUFSD(\"EXIT\\n\");\n\t\treturn sbi->s_ucpi[0];\n\t}\n\t/*\n\t * Number of cylinder groups is not higher than UFS_MAX_GROUP_LOADED\n\t */\n\tif (uspi->s_ncg <= UFS_MAX_GROUP_LOADED) {\n\t\tif (sbi->s_cgno[cgno] != UFS_CGNO_EMPTY) {\n\t\t\tif (sbi->s_cgno[cgno] != cgno) {\n\t\t\t\tufs_panic (sb, \"ufs_load_cylinder\", \"internal error, wrong number of cg in cache\");\n\t\t\t\tUFSD(\"EXIT (FAILED)\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tUFSD(\"EXIT\\n\");\n\t\t\t\treturn sbi->s_ucpi[cgno];\n\t\t\t}\n\t\t} else {\n\t\t\tufs_read_cylinder (sb, cgno, cgno);\n\t\t\tUFSD(\"EXIT\\n\");\n\t\t\treturn sbi->s_ucpi[cgno];\n\t\t}\n\t}\n\t/*\n\t * Cylinder group number cg is in cache but it was not last used, \n\t * we will move to the first position\n\t */\n\tfor (i = 0; i < sbi->s_cg_loaded && sbi->s_cgno[i] != cgno; i++);\n\tif (i < sbi->s_cg_loaded && sbi->s_cgno[i] == cgno) {\n\t\tcg = sbi->s_cgno[i];\n\t\tucpi = sbi->s_ucpi[i];\n\t\tfor (j = i; j > 0; j--) {\n\t\t\tsbi->s_cgno[j] = sbi->s_cgno[j-1];\n\t\t\tsbi->s_ucpi[j] = sbi->s_ucpi[j-1];\n\t\t}\n\t\tsbi->s_cgno[0] = cg;\n\t\tsbi->s_ucpi[0] = ucpi;\n\t/*\n\t * Cylinder group number cg is not in cache, we will read it from disk\n\t * and put it to the first position\n\t */\n\t} else {\n\t\tif (sbi->s_cg_loaded < UFS_MAX_GROUP_LOADED)\n\t\t\tsbi->s_cg_loaded++;\n\t\telse\n\t\t\tufs_put_cylinder (sb, UFS_MAX_GROUP_LOADED-1);\n\t\tucpi = sbi->s_ucpi[sbi->s_cg_loaded - 1];\n\t\tfor (j = sbi->s_cg_loaded - 1; j > 0; j--) {\n\t\t\tsbi->s_cgno[j] = sbi->s_cgno[j-1];\n\t\t\tsbi->s_ucpi[j] = sbi->s_ucpi[j-1];\n\t\t}\n\t\tsbi->s_ucpi[0] = ucpi;\n\t\tufs_read_cylinder (sb, cgno, 0);\n\t}\n\tUFSD(\"EXIT\\n\");\n\treturn sbi->s_ucpi[0];\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/bitops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <asm/byteorder.h>\n#include <linux/bitops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstruct ufs_cg_private_info * ufs_load_cylinder (\n\tstruct super_block * sb, unsigned cgno)\n{\n\tstruct ufs_sb_info * sbi = UFS_SB(sb);\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cg_private_info * ucpi;\n\tunsigned cg, i, j;\n\n\tUFSD(\"ENTER, cgno %u\\n\", cgno);\n\n\tuspi = sbi->s_uspi;\n\tif (cgno >= uspi->s_ncg) {\n\t\tufs_panic (sb, \"ufs_load_cylinder\", \"internal error, high number of cg\");\n\t\treturn NULL;\n\t}\n\t/*\n\t * Cylinder group number cg it in cache and it was last used\n\t */\n\tif (sbi->s_cgno[0] == cgno) {\n\t\tUFSD(\"EXIT\\n\");\n\t\treturn sbi->s_ucpi[0];\n\t}\n\t/*\n\t * Number of cylinder groups is not higher than UFS_MAX_GROUP_LOADED\n\t */\n\tif (uspi->s_ncg <= UFS_MAX_GROUP_LOADED) {\n\t\tif (sbi->s_cgno[cgno] != UFS_CGNO_EMPTY) {\n\t\t\tif (sbi->s_cgno[cgno] != cgno) {\n\t\t\t\tufs_panic (sb, \"ufs_load_cylinder\", \"internal error, wrong number of cg in cache\");\n\t\t\t\tUFSD(\"EXIT (FAILED)\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tUFSD(\"EXIT\\n\");\n\t\t\t\treturn sbi->s_ucpi[cgno];\n\t\t\t}\n\t\t} else {\n\t\t\tufs_read_cylinder (sb, cgno, cgno);\n\t\t\tUFSD(\"EXIT\\n\");\n\t\t\treturn sbi->s_ucpi[cgno];\n\t\t}\n\t}\n\t/*\n\t * Cylinder group number cg is in cache but it was not last used, \n\t * we will move to the first position\n\t */\n\tfor (i = 0; i < sbi->s_cg_loaded && sbi->s_cgno[i] != cgno; i++);\n\tif (i < sbi->s_cg_loaded && sbi->s_cgno[i] == cgno) {\n\t\tcg = sbi->s_cgno[i];\n\t\tucpi = sbi->s_ucpi[i];\n\t\tfor (j = i; j > 0; j--) {\n\t\t\tsbi->s_cgno[j] = sbi->s_cgno[j-1];\n\t\t\tsbi->s_ucpi[j] = sbi->s_ucpi[j-1];\n\t\t}\n\t\tsbi->s_cgno[0] = cg;\n\t\tsbi->s_ucpi[0] = ucpi;\n\t/*\n\t * Cylinder group number cg is not in cache, we will read it from disk\n\t * and put it to the first position\n\t */\n\t} else {\n\t\tif (sbi->s_cg_loaded < UFS_MAX_GROUP_LOADED)\n\t\t\tsbi->s_cg_loaded++;\n\t\telse\n\t\t\tufs_put_cylinder (sb, UFS_MAX_GROUP_LOADED-1);\n\t\tucpi = sbi->s_ucpi[sbi->s_cg_loaded - 1];\n\t\tfor (j = sbi->s_cg_loaded - 1; j > 0; j--) {\n\t\t\tsbi->s_cgno[j] = sbi->s_cgno[j-1];\n\t\t\tsbi->s_ucpi[j] = sbi->s_ucpi[j-1];\n\t\t}\n\t\tsbi->s_ucpi[0] = ucpi;\n\t\tufs_read_cylinder (sb, cgno, 0);\n\t}\n\tUFSD(\"EXIT\\n\");\n\treturn sbi->s_ucpi[0];\n}"
        }
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"EXIT (FAILED)\\n\""
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"ENTER, ino %lu, cgno %u, goal %llu, count %u\\n\"",
            "inode->i_ino",
            "cgno",
            "(unsigned long long)goal",
            "count"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <asm/byteorder.h>\n#include <linux/bitops.h>\n#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\n#define UFS_TEST_FREE_SPACE_CG \\\n\tucg = (struct ufs_cylinder_group *) UFS_SB(sb)->s_ucg[cgno]->b_data; \\\n\tif (fs32_to_cpu(sb, ucg->cg_cs.cs_nbfree)) \\\n\t\tgoto cg_found; \\\n\tfor (k = count; k < uspi->s_fpb; k++) \\\n\t\tif (fs32_to_cpu(sb, ucg->cg_frsum[k])) \\\n\t\t\tgoto cg_found;\n#define INVBLOCK ((u64)-1L)\n\nstatic u64 ufs_add_fragments(struct inode *, u64, unsigned, unsigned);\nstatic u64 ufs_alloc_fragments(struct inode *, unsigned, u64, unsigned, int *);\nstatic u64 ufs_alloccg_block(struct inode *, struct ufs_cg_private_info *, u64, int *);\nstatic u64 ufs_bitmap_search (struct super_block *, struct ufs_cg_private_info *, u64, unsigned);\nstatic void ufs_clusteracct(struct super_block *, struct ufs_cg_private_info *, unsigned, int);\n\nstatic u64 ufs_alloc_fragments(struct inode *inode, unsigned cgno,\n\t\t\t       u64 goal, unsigned count, int *err)\n{\n\tstruct super_block * sb;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cg_private_info * ucpi;\n\tstruct ufs_cylinder_group * ucg;\n\tunsigned oldcg, i, j, k, allocsize;\n\tu64 result;\n\t\n\tUFSD(\"ENTER, ino %lu, cgno %u, goal %llu, count %u\\n\",\n\t     inode->i_ino, cgno, (unsigned long long)goal, count);\n\n\tsb = inode->i_sb;\n\tuspi = UFS_SB(sb)->s_uspi;\n\toldcg = cgno;\n\t\n\t/*\n\t * 1. searching on preferred cylinder group\n\t */\n\tUFS_TEST_FREE_SPACE_CG\n\n\t/*\n\t * 2. quadratic rehash\n\t */\n\tfor (j = 1; j < uspi->s_ncg; j *= 2) {\n\t\tcgno += j;\n\t\tif (cgno >= uspi->s_ncg) \n\t\t\tcgno -= uspi->s_ncg;\n\t\tUFS_TEST_FREE_SPACE_CG\n\t}\n\n\t/*\n\t * 3. brute force search\n\t * We start at i = 2 ( 0 is checked at 1.step, 1 at 2.step )\n\t */\n\tcgno = (oldcg + 1) % uspi->s_ncg;\n\tfor (j = 2; j < uspi->s_ncg; j++) {\n\t\tcgno++;\n\t\tif (cgno >= uspi->s_ncg)\n\t\t\tcgno = 0;\n\t\tUFS_TEST_FREE_SPACE_CG\n\t}\n\t\n\tUFSD(\"EXIT (FAILED)\\n\");\n\treturn 0;\n\ncg_found:\n\tucpi = ufs_load_cylinder (sb, cgno);\n\tif (!ucpi)\n\t\treturn 0;\n\tucg = ubh_get_ucg (UCPI_UBH(ucpi));\n\tif (!ufs_cg_chkmagic(sb, ucg)) \n\t\tufs_panic (sb, \"ufs_alloc_fragments\",\n\t\t\t\"internal error, bad magic number on cg %u\", cgno);\n\tucg->cg_time = cpu_to_fs32(sb, get_seconds());\n\n\tif (count == uspi->s_fpb) {\n\t\tresult = ufs_alloccg_block (inode, ucpi, goal, err);\n\t\tif (result == INVBLOCK)\n\t\t\treturn 0;\n\t\tgoto succed;\n\t}\n\n\tfor (allocsize = count; allocsize < uspi->s_fpb; allocsize++)\n\t\tif (fs32_to_cpu(sb, ucg->cg_frsum[allocsize]) != 0)\n\t\t\tbreak;\n\t\n\tif (allocsize == uspi->s_fpb) {\n\t\tresult = ufs_alloccg_block (inode, ucpi, goal, err);\n\t\tif (result == INVBLOCK)\n\t\t\treturn 0;\n\t\tgoal = ufs_dtogd(uspi, result);\n\t\tfor (i = count; i < uspi->s_fpb; i++)\n\t\t\tubh_setbit (UCPI_UBH(ucpi), ucpi->c_freeoff, goal + i);\n\t\ti = uspi->s_fpb - count;\n\n\t\tfs32_add(sb, &ucg->cg_cs.cs_nffree, i);\n\t\tuspi->cs_total.cs_nffree += i;\n\t\tfs32_add(sb, &UFS_SB(sb)->fs_cs(cgno).cs_nffree, i);\n\t\tfs32_add(sb, &ucg->cg_frsum[i], 1);\n\t\tgoto succed;\n\t}\n\n\tresult = ufs_bitmap_search (sb, ucpi, goal, allocsize);\n\tif (result == INVBLOCK)\n\t\treturn 0;\n\tfor (i = 0; i < count; i++)\n\t\tubh_clrbit (UCPI_UBH(ucpi), ucpi->c_freeoff, result + i);\n\t\n\tfs32_sub(sb, &ucg->cg_cs.cs_nffree, count);\n\tuspi->cs_total.cs_nffree -= count;\n\tfs32_sub(sb, &UFS_SB(sb)->fs_cs(cgno).cs_nffree, count);\n\tfs32_sub(sb, &ucg->cg_frsum[allocsize], 1);\n\n\tif (count != allocsize)\n\t\tfs32_add(sb, &ucg->cg_frsum[allocsize - count], 1);\n\nsucced:\n\tubh_mark_buffer_dirty (USPI_UBH(uspi));\n\tubh_mark_buffer_dirty (UCPI_UBH(ucpi));\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tubh_sync_block(UCPI_UBH(ucpi));\n\tufs_mark_sb_dirty(sb);\n\n\tresult += cgno * uspi->s_fpg;\n\tUFSD(\"EXIT3, result %llu\\n\", (unsigned long long)result);\n\treturn result;\n}"
  },
  {
    "function_name": "ufs_add_fragments",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/balloc.c",
    "lines": "493-559",
    "snippet": "static u64 ufs_add_fragments(struct inode *inode, u64 fragment,\n\t\t\t     unsigned oldcount, unsigned newcount)\n{\n\tstruct super_block * sb;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cg_private_info * ucpi;\n\tstruct ufs_cylinder_group * ucg;\n\tunsigned cgno, fragno, fragoff, count, fragsize, i;\n\t\n\tUFSD(\"ENTER, fragment %llu, oldcount %u, newcount %u\\n\",\n\t     (unsigned long long)fragment, oldcount, newcount);\n\t\n\tsb = inode->i_sb;\n\tuspi = UFS_SB(sb)->s_uspi;\n\tcount = newcount - oldcount;\n\t\n\tcgno = ufs_dtog(uspi, fragment);\n\tif (fs32_to_cpu(sb, UFS_SB(sb)->fs_cs(cgno).cs_nffree) < count)\n\t\treturn 0;\n\tif ((ufs_fragnum (fragment) + newcount) > uspi->s_fpb)\n\t\treturn 0;\n\tucpi = ufs_load_cylinder (sb, cgno);\n\tif (!ucpi)\n\t\treturn 0;\n\tucg = ubh_get_ucg (UCPI_UBH(ucpi));\n\tif (!ufs_cg_chkmagic(sb, ucg)) {\n\t\tufs_panic (sb, \"ufs_add_fragments\",\n\t\t\t\"internal error, bad magic number on cg %u\", cgno);\n\t\treturn 0;\n\t}\n\n\tfragno = ufs_dtogd(uspi, fragment);\n\tfragoff = ufs_fragnum (fragno);\n\tfor (i = oldcount; i < newcount; i++)\n\t\tif (ubh_isclr (UCPI_UBH(ucpi), ucpi->c_freeoff, fragno + i))\n\t\t\treturn 0;\n\t/*\n\t * Block can be extended\n\t */\n\tucg->cg_time = cpu_to_fs32(sb, get_seconds());\n\tfor (i = newcount; i < (uspi->s_fpb - fragoff); i++)\n\t\tif (ubh_isclr (UCPI_UBH(ucpi), ucpi->c_freeoff, fragno + i))\n\t\t\tbreak;\n\tfragsize = i - oldcount;\n\tif (!fs32_to_cpu(sb, ucg->cg_frsum[fragsize]))\n\t\tufs_panic (sb, \"ufs_add_fragments\",\n\t\t\t\"internal error or corrupted bitmap on cg %u\", cgno);\n\tfs32_sub(sb, &ucg->cg_frsum[fragsize], 1);\n\tif (fragsize != count)\n\t\tfs32_add(sb, &ucg->cg_frsum[fragsize - count], 1);\n\tfor (i = oldcount; i < newcount; i++)\n\t\tubh_clrbit (UCPI_UBH(ucpi), ucpi->c_freeoff, fragno + i);\n\n\tfs32_sub(sb, &ucg->cg_cs.cs_nffree, count);\n\tfs32_sub(sb, &UFS_SB(sb)->fs_cs(cgno).cs_nffree, count);\n\tuspi->cs_total.cs_nffree -= count;\n\t\n\tubh_mark_buffer_dirty (USPI_UBH(uspi));\n\tubh_mark_buffer_dirty (UCPI_UBH(ucpi));\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tubh_sync_block(UCPI_UBH(ucpi));\n\tufs_mark_sb_dirty(sb);\n\n\tUFSD(\"EXIT, fragment %llu\\n\", (unsigned long long)fragment);\n\t\n\treturn fragment;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/bitops.h>",
      "#include <linux/capability.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ufs_add_fragments(struct inode *, u64, unsigned, unsigned);",
      "static u64 ufs_alloc_fragments(struct inode *, unsigned, u64, unsigned, int *);",
      "static u64 ufs_alloccg_block(struct inode *, struct ufs_cg_private_info *, u64, int *);",
      "static u64 ufs_bitmap_search (struct super_block *, struct ufs_cg_private_info *, u64, unsigned);",
      "static void ufs_clusteracct(struct super_block *, struct ufs_cg_private_info *, unsigned, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"EXIT, fragment %llu\\n\"",
            "(unsigned long long)fragment"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_mark_sb_dirty",
          "args": [
            "sb"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_mark_sb_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "732-744",
          "snippet": "void ufs_mark_sb_dirty(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\tunsigned long delay;\n\n\tspin_lock(&sbi->work_lock);\n\tif (!sbi->work_queued) {\n\t\tdelay = msecs_to_jiffies(dirty_writeback_interval * 10);\n\t\tqueue_delayed_work(system_long_wq, &sbi->sync_work, delay);\n\t\tsbi->work_queued = 1;\n\t}\n\tspin_unlock(&sbi->work_lock);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid ufs_mark_sb_dirty(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\tunsigned long delay;\n\n\tspin_lock(&sbi->work_lock);\n\tif (!sbi->work_queued) {\n\t\tdelay = msecs_to_jiffies(dirty_writeback_interval * 10);\n\t\tqueue_delayed_work(system_long_wq, &sbi->sync_work, delay);\n\t\tsbi->work_queued = 1;\n\t}\n\tspin_unlock(&sbi->work_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubh_sync_block",
          "args": [
            "UCPI_UBH(ucpi)"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "ubh_sync_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.c",
          "lines": "115-126",
          "snippet": "void ubh_sync_block(struct ufs_buffer_head *ubh)\n{\n\tif (ubh) {\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < ubh->count; i++)\n\t\t\twrite_dirty_buffer(ubh->bh[i], WRITE);\n\n\t\tfor (i = 0; i < ubh->count; i++)\n\t\t\twait_on_buffer(ubh->bh[i]);\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid ubh_sync_block(struct ufs_buffer_head *ubh)\n{\n\tif (ubh) {\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < ubh->count; i++)\n\t\t\twrite_dirty_buffer(ubh->bh[i], WRITE);\n\n\t\tfor (i = 0; i < ubh->count; i++)\n\t\t\twait_on_buffer(ubh->bh[i]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "UCPI_UBH",
          "args": [
            "ucpi"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "UCPI_UBH",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "22-25",
          "snippet": "static inline struct ufs_buffer_head *UCPI_UBH(struct ufs_cg_private_info *cpi)\n{\n\treturn &cpi->c_ubh;\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ubh_brelse (struct ufs_buffer_head *);",
            "extern void ubh_mark_buffer_dirty (struct ufs_buffer_head *);",
            "extern void ubh_mark_buffer_uptodate (struct ufs_buffer_head *, int);",
            "extern void ubh_sync_block(struct ufs_buffer_head *);",
            "extern void ubh_bforget (struct ufs_buffer_head *);",
            "extern int  ubh_buffer_dirty (struct ufs_buffer_head *);",
            "extern void _ubh_ubhcpymem_(struct ufs_sb_private_info *, unsigned char *, struct ufs_buffer_head *, unsigned);",
            "extern void _ubh_memcpyubh_(struct ufs_sb_private_info *, struct ufs_buffer_head *, unsigned char *, unsigned);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nextern void ubh_brelse (struct ufs_buffer_head *);\nextern void ubh_mark_buffer_dirty (struct ufs_buffer_head *);\nextern void ubh_mark_buffer_uptodate (struct ufs_buffer_head *, int);\nextern void ubh_sync_block(struct ufs_buffer_head *);\nextern void ubh_bforget (struct ufs_buffer_head *);\nextern int  ubh_buffer_dirty (struct ufs_buffer_head *);\nextern void _ubh_ubhcpymem_(struct ufs_sb_private_info *, unsigned char *, struct ufs_buffer_head *, unsigned);\nextern void _ubh_memcpyubh_(struct ufs_sb_private_info *, struct ufs_buffer_head *, unsigned char *, unsigned);\n\nstatic inline struct ufs_buffer_head *UCPI_UBH(struct ufs_cg_private_info *cpi)\n{\n\treturn &cpi->c_ubh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubh_mark_buffer_dirty",
          "args": [
            "UCPI_UBH(ucpi)"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "ubh_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.c",
          "lines": "92-99",
          "snippet": "void ubh_mark_buffer_dirty (struct ufs_buffer_head * ubh)\n{\n\tunsigned i;\n\tif (!ubh)\n\t\treturn;\n\tfor ( i = 0; i < ubh->count; i++ )\n\t\tmark_buffer_dirty (ubh->bh[i]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid ubh_mark_buffer_dirty (struct ufs_buffer_head * ubh)\n{\n\tunsigned i;\n\tif (!ubh)\n\t\treturn;\n\tfor ( i = 0; i < ubh->count; i++ )\n\t\tmark_buffer_dirty (ubh->bh[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "USPI_UBH",
          "args": [
            "uspi"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "USPI_UBH",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "26-29",
          "snippet": "static inline struct ufs_buffer_head *USPI_UBH(struct ufs_sb_private_info *spi)\n{\n\treturn &spi->s_ubh;\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ubh_brelse (struct ufs_buffer_head *);",
            "extern void ubh_brelse_uspi (struct ufs_sb_private_info *);",
            "extern void ubh_mark_buffer_dirty (struct ufs_buffer_head *);",
            "extern void ubh_mark_buffer_uptodate (struct ufs_buffer_head *, int);",
            "extern void ubh_sync_block(struct ufs_buffer_head *);",
            "extern void ubh_bforget (struct ufs_buffer_head *);",
            "extern int  ubh_buffer_dirty (struct ufs_buffer_head *);",
            "extern void _ubh_ubhcpymem_(struct ufs_sb_private_info *, unsigned char *, struct ufs_buffer_head *, unsigned);",
            "extern void _ubh_memcpyubh_(struct ufs_sb_private_info *, struct ufs_buffer_head *, unsigned char *, unsigned);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nextern void ubh_brelse (struct ufs_buffer_head *);\nextern void ubh_brelse_uspi (struct ufs_sb_private_info *);\nextern void ubh_mark_buffer_dirty (struct ufs_buffer_head *);\nextern void ubh_mark_buffer_uptodate (struct ufs_buffer_head *, int);\nextern void ubh_sync_block(struct ufs_buffer_head *);\nextern void ubh_bforget (struct ufs_buffer_head *);\nextern int  ubh_buffer_dirty (struct ufs_buffer_head *);\nextern void _ubh_ubhcpymem_(struct ufs_sb_private_info *, unsigned char *, struct ufs_buffer_head *, unsigned);\nextern void _ubh_memcpyubh_(struct ufs_sb_private_info *, struct ufs_buffer_head *, unsigned char *, unsigned);\n\nstatic inline struct ufs_buffer_head *USPI_UBH(struct ufs_sb_private_info *spi)\n{\n\treturn &spi->s_ubh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs32_sub",
          "args": [
            "sb",
            "&UFS_SB(sb)->fs_cs(cgno).cs_nffree",
            "count"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "fs32_sub",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "70-77",
          "snippet": "static inline void\nfs32_sub(struct super_block *sbp, __fs32 *n, int d)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\tle32_add_cpu((__le32 *)n, -d);\n\telse\n\t\tbe32_add_cpu((__be32 *)n, -d);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nfs32_sub(struct super_block *sbp, __fs32 *n, int d)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\tle32_add_cpu((__le32 *)n, -d);\n\telse\n\t\tbe32_add_cpu((__be32 *)n, -d);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "cgno"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubh_clrbit",
          "args": [
            "UCPI_UBH(ucpi)",
            "ucpi->c_freeoff",
            "fragno + i"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs32_add",
          "args": [
            "sb",
            "&ucg->cg_frsum[fragsize - count]",
            "1"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "fs32_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "61-68",
          "snippet": "static inline void\nfs32_add(struct super_block *sbp, __fs32 *n, int d)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\tle32_add_cpu((__le32 *)n, d);\n\telse\n\t\tbe32_add_cpu((__be32 *)n, d);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nfs32_add(struct super_block *sbp, __fs32 *n, int d)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\tle32_add_cpu((__le32 *)n, d);\n\telse\n\t\tbe32_add_cpu((__be32 *)n, d);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_panic",
          "args": [
            "sb",
            "\"ufs_add_fragments\"",
            "\"internal error or corrupted bitmap on cg %u\"",
            "cgno"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "319-342",
          "snippet": "void ufs_panic (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct va_format vaf;\n\tva_list args;\n\t\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\t\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tusb1->fs_clean = UFS_FSBAD;\n\t\tubh_mark_buffer_dirty(USPI_UBH(uspi));\n\t\tufs_mark_sb_dirty(sb);\n\t}\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tsb->s_flags |= MS_RDONLY;\n\tpr_crit(\"panic (device %s): %s: %pV\\n\",\n\t\tsb->s_id, function, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid ufs_panic (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct va_format vaf;\n\tva_list args;\n\t\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\t\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tusb1->fs_clean = UFS_FSBAD;\n\t\tubh_mark_buffer_dirty(USPI_UBH(uspi));\n\t\tufs_mark_sb_dirty(sb);\n\t}\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tsb->s_flags |= MS_RDONLY;\n\tpr_crit(\"panic (device %s): %s: %pV\\n\",\n\t\tsb->s_id, function, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs32_to_cpu",
          "args": [
            "sb",
            "ucg->cg_frsum[fragsize]"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "fs32_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "43-50",
          "snippet": "static inline u32\nfs32_to_cpu(struct super_block *sbp, __fs32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u32\nfs32_to_cpu(struct super_block *sbp, __fs32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubh_isclr",
          "args": [
            "UCPI_UBH(ucpi)",
            "ucpi->c_freeoff",
            "fragno + i"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_fs32",
          "args": [
            "sb",
            "get_seconds()"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_to_fs32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "52-59",
          "snippet": "static inline __fs32\ncpu_to_fs32(struct super_block *sbp, u32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn (__force __fs32)cpu_to_le32(n);\n\telse\n\t\treturn (__force __fs32)cpu_to_be32(n);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline __fs32\ncpu_to_fs32(struct super_block *sbp, u32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn (__force __fs32)cpu_to_le32(n);\n\telse\n\t\treturn (__force __fs32)cpu_to_be32(n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_seconds",
          "args": [],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubh_isclr",
          "args": [
            "UCPI_UBH(ucpi)",
            "ucpi->c_freeoff",
            "fragno + i"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_fragnum",
          "args": [
            "fragno"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_dtogd",
          "args": [
            "uspi",
            "fragment"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_cg_chkmagic",
          "args": [
            "sb",
            "ucg"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubh_get_ucg",
          "args": [
            "UCPI_UBH(ucpi)"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_load_cylinder",
          "args": [
            "sb",
            "cgno"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_load_cylinder",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/cylinder.c",
          "lines": "126-201",
          "snippet": "struct ufs_cg_private_info * ufs_load_cylinder (\n\tstruct super_block * sb, unsigned cgno)\n{\n\tstruct ufs_sb_info * sbi = UFS_SB(sb);\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cg_private_info * ucpi;\n\tunsigned cg, i, j;\n\n\tUFSD(\"ENTER, cgno %u\\n\", cgno);\n\n\tuspi = sbi->s_uspi;\n\tif (cgno >= uspi->s_ncg) {\n\t\tufs_panic (sb, \"ufs_load_cylinder\", \"internal error, high number of cg\");\n\t\treturn NULL;\n\t}\n\t/*\n\t * Cylinder group number cg it in cache and it was last used\n\t */\n\tif (sbi->s_cgno[0] == cgno) {\n\t\tUFSD(\"EXIT\\n\");\n\t\treturn sbi->s_ucpi[0];\n\t}\n\t/*\n\t * Number of cylinder groups is not higher than UFS_MAX_GROUP_LOADED\n\t */\n\tif (uspi->s_ncg <= UFS_MAX_GROUP_LOADED) {\n\t\tif (sbi->s_cgno[cgno] != UFS_CGNO_EMPTY) {\n\t\t\tif (sbi->s_cgno[cgno] != cgno) {\n\t\t\t\tufs_panic (sb, \"ufs_load_cylinder\", \"internal error, wrong number of cg in cache\");\n\t\t\t\tUFSD(\"EXIT (FAILED)\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tUFSD(\"EXIT\\n\");\n\t\t\t\treturn sbi->s_ucpi[cgno];\n\t\t\t}\n\t\t} else {\n\t\t\tufs_read_cylinder (sb, cgno, cgno);\n\t\t\tUFSD(\"EXIT\\n\");\n\t\t\treturn sbi->s_ucpi[cgno];\n\t\t}\n\t}\n\t/*\n\t * Cylinder group number cg is in cache but it was not last used, \n\t * we will move to the first position\n\t */\n\tfor (i = 0; i < sbi->s_cg_loaded && sbi->s_cgno[i] != cgno; i++);\n\tif (i < sbi->s_cg_loaded && sbi->s_cgno[i] == cgno) {\n\t\tcg = sbi->s_cgno[i];\n\t\tucpi = sbi->s_ucpi[i];\n\t\tfor (j = i; j > 0; j--) {\n\t\t\tsbi->s_cgno[j] = sbi->s_cgno[j-1];\n\t\t\tsbi->s_ucpi[j] = sbi->s_ucpi[j-1];\n\t\t}\n\t\tsbi->s_cgno[0] = cg;\n\t\tsbi->s_ucpi[0] = ucpi;\n\t/*\n\t * Cylinder group number cg is not in cache, we will read it from disk\n\t * and put it to the first position\n\t */\n\t} else {\n\t\tif (sbi->s_cg_loaded < UFS_MAX_GROUP_LOADED)\n\t\t\tsbi->s_cg_loaded++;\n\t\telse\n\t\t\tufs_put_cylinder (sb, UFS_MAX_GROUP_LOADED-1);\n\t\tucpi = sbi->s_ucpi[sbi->s_cg_loaded - 1];\n\t\tfor (j = sbi->s_cg_loaded - 1; j > 0; j--) {\n\t\t\tsbi->s_cgno[j] = sbi->s_cgno[j-1];\n\t\t\tsbi->s_ucpi[j] = sbi->s_ucpi[j-1];\n\t\t}\n\t\tsbi->s_ucpi[0] = ucpi;\n\t\tufs_read_cylinder (sb, cgno, 0);\n\t}\n\tUFSD(\"EXIT\\n\");\n\treturn sbi->s_ucpi[0];\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/bitops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <asm/byteorder.h>\n#include <linux/bitops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstruct ufs_cg_private_info * ufs_load_cylinder (\n\tstruct super_block * sb, unsigned cgno)\n{\n\tstruct ufs_sb_info * sbi = UFS_SB(sb);\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cg_private_info * ucpi;\n\tunsigned cg, i, j;\n\n\tUFSD(\"ENTER, cgno %u\\n\", cgno);\n\n\tuspi = sbi->s_uspi;\n\tif (cgno >= uspi->s_ncg) {\n\t\tufs_panic (sb, \"ufs_load_cylinder\", \"internal error, high number of cg\");\n\t\treturn NULL;\n\t}\n\t/*\n\t * Cylinder group number cg it in cache and it was last used\n\t */\n\tif (sbi->s_cgno[0] == cgno) {\n\t\tUFSD(\"EXIT\\n\");\n\t\treturn sbi->s_ucpi[0];\n\t}\n\t/*\n\t * Number of cylinder groups is not higher than UFS_MAX_GROUP_LOADED\n\t */\n\tif (uspi->s_ncg <= UFS_MAX_GROUP_LOADED) {\n\t\tif (sbi->s_cgno[cgno] != UFS_CGNO_EMPTY) {\n\t\t\tif (sbi->s_cgno[cgno] != cgno) {\n\t\t\t\tufs_panic (sb, \"ufs_load_cylinder\", \"internal error, wrong number of cg in cache\");\n\t\t\t\tUFSD(\"EXIT (FAILED)\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tUFSD(\"EXIT\\n\");\n\t\t\t\treturn sbi->s_ucpi[cgno];\n\t\t\t}\n\t\t} else {\n\t\t\tufs_read_cylinder (sb, cgno, cgno);\n\t\t\tUFSD(\"EXIT\\n\");\n\t\t\treturn sbi->s_ucpi[cgno];\n\t\t}\n\t}\n\t/*\n\t * Cylinder group number cg is in cache but it was not last used, \n\t * we will move to the first position\n\t */\n\tfor (i = 0; i < sbi->s_cg_loaded && sbi->s_cgno[i] != cgno; i++);\n\tif (i < sbi->s_cg_loaded && sbi->s_cgno[i] == cgno) {\n\t\tcg = sbi->s_cgno[i];\n\t\tucpi = sbi->s_ucpi[i];\n\t\tfor (j = i; j > 0; j--) {\n\t\t\tsbi->s_cgno[j] = sbi->s_cgno[j-1];\n\t\t\tsbi->s_ucpi[j] = sbi->s_ucpi[j-1];\n\t\t}\n\t\tsbi->s_cgno[0] = cg;\n\t\tsbi->s_ucpi[0] = ucpi;\n\t/*\n\t * Cylinder group number cg is not in cache, we will read it from disk\n\t * and put it to the first position\n\t */\n\t} else {\n\t\tif (sbi->s_cg_loaded < UFS_MAX_GROUP_LOADED)\n\t\t\tsbi->s_cg_loaded++;\n\t\telse\n\t\t\tufs_put_cylinder (sb, UFS_MAX_GROUP_LOADED-1);\n\t\tucpi = sbi->s_ucpi[sbi->s_cg_loaded - 1];\n\t\tfor (j = sbi->s_cg_loaded - 1; j > 0; j--) {\n\t\t\tsbi->s_cgno[j] = sbi->s_cgno[j-1];\n\t\t\tsbi->s_ucpi[j] = sbi->s_ucpi[j-1];\n\t\t}\n\t\tsbi->s_ucpi[0] = ucpi;\n\t\tufs_read_cylinder (sb, cgno, 0);\n\t}\n\tUFSD(\"EXIT\\n\");\n\treturn sbi->s_ucpi[0];\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_fragnum",
          "args": [
            "fragment"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "cgno"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_dtog",
          "args": [
            "uspi",
            "fragment"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"ENTER, fragment %llu, oldcount %u, newcount %u\\n\"",
            "(unsigned long long)fragment",
            "oldcount",
            "newcount"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <asm/byteorder.h>\n#include <linux/bitops.h>\n#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nstatic u64 ufs_add_fragments(struct inode *, u64, unsigned, unsigned);\nstatic u64 ufs_alloc_fragments(struct inode *, unsigned, u64, unsigned, int *);\nstatic u64 ufs_alloccg_block(struct inode *, struct ufs_cg_private_info *, u64, int *);\nstatic u64 ufs_bitmap_search (struct super_block *, struct ufs_cg_private_info *, u64, unsigned);\nstatic void ufs_clusteracct(struct super_block *, struct ufs_cg_private_info *, unsigned, int);\n\nstatic u64 ufs_add_fragments(struct inode *inode, u64 fragment,\n\t\t\t     unsigned oldcount, unsigned newcount)\n{\n\tstruct super_block * sb;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cg_private_info * ucpi;\n\tstruct ufs_cylinder_group * ucg;\n\tunsigned cgno, fragno, fragoff, count, fragsize, i;\n\t\n\tUFSD(\"ENTER, fragment %llu, oldcount %u, newcount %u\\n\",\n\t     (unsigned long long)fragment, oldcount, newcount);\n\t\n\tsb = inode->i_sb;\n\tuspi = UFS_SB(sb)->s_uspi;\n\tcount = newcount - oldcount;\n\t\n\tcgno = ufs_dtog(uspi, fragment);\n\tif (fs32_to_cpu(sb, UFS_SB(sb)->fs_cs(cgno).cs_nffree) < count)\n\t\treturn 0;\n\tif ((ufs_fragnum (fragment) + newcount) > uspi->s_fpb)\n\t\treturn 0;\n\tucpi = ufs_load_cylinder (sb, cgno);\n\tif (!ucpi)\n\t\treturn 0;\n\tucg = ubh_get_ucg (UCPI_UBH(ucpi));\n\tif (!ufs_cg_chkmagic(sb, ucg)) {\n\t\tufs_panic (sb, \"ufs_add_fragments\",\n\t\t\t\"internal error, bad magic number on cg %u\", cgno);\n\t\treturn 0;\n\t}\n\n\tfragno = ufs_dtogd(uspi, fragment);\n\tfragoff = ufs_fragnum (fragno);\n\tfor (i = oldcount; i < newcount; i++)\n\t\tif (ubh_isclr (UCPI_UBH(ucpi), ucpi->c_freeoff, fragno + i))\n\t\t\treturn 0;\n\t/*\n\t * Block can be extended\n\t */\n\tucg->cg_time = cpu_to_fs32(sb, get_seconds());\n\tfor (i = newcount; i < (uspi->s_fpb - fragoff); i++)\n\t\tif (ubh_isclr (UCPI_UBH(ucpi), ucpi->c_freeoff, fragno + i))\n\t\t\tbreak;\n\tfragsize = i - oldcount;\n\tif (!fs32_to_cpu(sb, ucg->cg_frsum[fragsize]))\n\t\tufs_panic (sb, \"ufs_add_fragments\",\n\t\t\t\"internal error or corrupted bitmap on cg %u\", cgno);\n\tfs32_sub(sb, &ucg->cg_frsum[fragsize], 1);\n\tif (fragsize != count)\n\t\tfs32_add(sb, &ucg->cg_frsum[fragsize - count], 1);\n\tfor (i = oldcount; i < newcount; i++)\n\t\tubh_clrbit (UCPI_UBH(ucpi), ucpi->c_freeoff, fragno + i);\n\n\tfs32_sub(sb, &ucg->cg_cs.cs_nffree, count);\n\tfs32_sub(sb, &UFS_SB(sb)->fs_cs(cgno).cs_nffree, count);\n\tuspi->cs_total.cs_nffree -= count;\n\t\n\tubh_mark_buffer_dirty (USPI_UBH(uspi));\n\tubh_mark_buffer_dirty (UCPI_UBH(ucpi));\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tubh_sync_block(UCPI_UBH(ucpi));\n\tufs_mark_sb_dirty(sb);\n\n\tUFSD(\"EXIT, fragment %llu\\n\", (unsigned long long)fragment);\n\t\n\treturn fragment;\n}"
  },
  {
    "function_name": "ufs_new_fragments",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/balloc.c",
    "lines": "341-491",
    "snippet": "u64 ufs_new_fragments(struct inode *inode, void *p, u64 fragment,\n\t\t\t   u64 goal, unsigned count, int *err,\n\t\t\t   struct page *locked_page)\n{\n\tstruct super_block * sb;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tunsigned cgno, oldcount, newcount;\n\tu64 tmp, request, result;\n\t\n\tUFSD(\"ENTER, ino %lu, fragment %llu, goal %llu, count %u\\n\",\n\t     inode->i_ino, (unsigned long long)fragment,\n\t     (unsigned long long)goal, count);\n\t\n\tsb = inode->i_sb;\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\t*err = -ENOSPC;\n\n\tlock_ufs(sb);\n\ttmp = ufs_data_ptr_to_cpu(sb, p);\n\n\tif (count + ufs_fragnum(fragment) > uspi->s_fpb) {\n\t\tufs_warning(sb, \"ufs_new_fragments\", \"internal warning\"\n\t\t\t    \" fragment %llu, count %u\",\n\t\t\t    (unsigned long long)fragment, count);\n\t\tcount = uspi->s_fpb - ufs_fragnum(fragment); \n\t}\n\toldcount = ufs_fragnum (fragment);\n\tnewcount = oldcount + count;\n\n\t/*\n\t * Somebody else has just allocated our fragments\n\t */\n\tif (oldcount) {\n\t\tif (!tmp) {\n\t\t\tufs_error(sb, \"ufs_new_fragments\", \"internal error, \"\n\t\t\t\t  \"fragment %llu, tmp %llu\\n\",\n\t\t\t\t  (unsigned long long)fragment,\n\t\t\t\t  (unsigned long long)tmp);\n\t\t\tunlock_ufs(sb);\n\t\t\treturn INVBLOCK;\n\t\t}\n\t\tif (fragment < UFS_I(inode)->i_lastfrag) {\n\t\t\tUFSD(\"EXIT (ALREADY ALLOCATED)\\n\");\n\t\t\tunlock_ufs(sb);\n\t\t\treturn 0;\n\t\t}\n\t}\n\telse {\n\t\tif (tmp) {\n\t\t\tUFSD(\"EXIT (ALREADY ALLOCATED)\\n\");\n\t\t\tunlock_ufs(sb);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * There is not enough space for user on the device\n\t */\n\tif (!capable(CAP_SYS_RESOURCE) && ufs_freespace(uspi, UFS_MINFREE) <= 0) {\n\t\tunlock_ufs(sb);\n\t\tUFSD(\"EXIT (FAILED)\\n\");\n\t\treturn 0;\n\t}\n\n\tif (goal >= uspi->s_size) \n\t\tgoal = 0;\n\tif (goal == 0) \n\t\tcgno = ufs_inotocg (inode->i_ino);\n\telse\n\t\tcgno = ufs_dtog(uspi, goal);\n\t \n\t/*\n\t * allocate new fragment\n\t */\n\tif (oldcount == 0) {\n\t\tresult = ufs_alloc_fragments (inode, cgno, goal, count, err);\n\t\tif (result) {\n\t\t\tufs_cpu_to_data_ptr(sb, p, result);\n\t\t\t*err = 0;\n\t\t\tUFS_I(inode)->i_lastfrag =\n\t\t\t\tmax(UFS_I(inode)->i_lastfrag, fragment + count);\n\t\t\tufs_clear_frags(inode, result + oldcount,\n\t\t\t\t\tnewcount - oldcount, locked_page != NULL);\n\t\t}\n\t\tunlock_ufs(sb);\n\t\tUFSD(\"EXIT, result %llu\\n\", (unsigned long long)result);\n\t\treturn result;\n\t}\n\n\t/*\n\t * resize block\n\t */\n\tresult = ufs_add_fragments(inode, tmp, oldcount, newcount);\n\tif (result) {\n\t\t*err = 0;\n\t\tUFS_I(inode)->i_lastfrag = max(UFS_I(inode)->i_lastfrag,\n\t\t\t\t\t\tfragment + count);\n\t\tufs_clear_frags(inode, result + oldcount, newcount - oldcount,\n\t\t\t\tlocked_page != NULL);\n\t\tunlock_ufs(sb);\n\t\tUFSD(\"EXIT, result %llu\\n\", (unsigned long long)result);\n\t\treturn result;\n\t}\n\n\t/*\n\t * allocate new block and move data\n\t */\n\tswitch (fs32_to_cpu(sb, usb1->fs_optim)) {\n\t    case UFS_OPTSPACE:\n\t\trequest = newcount;\n\t\tif (uspi->s_minfree < 5 || uspi->cs_total.cs_nffree\n\t\t    > uspi->s_dsize * uspi->s_minfree / (2 * 100))\n\t\t\tbreak;\n\t\tusb1->fs_optim = cpu_to_fs32(sb, UFS_OPTTIME);\n\t\tbreak;\n\t    default:\n\t\tusb1->fs_optim = cpu_to_fs32(sb, UFS_OPTTIME);\n\t\n\t    case UFS_OPTTIME:\n\t\trequest = uspi->s_fpb;\n\t\tif (uspi->cs_total.cs_nffree < uspi->s_dsize *\n\t\t    (uspi->s_minfree - 2) / 100)\n\t\t\tbreak;\n\t\tusb1->fs_optim = cpu_to_fs32(sb, UFS_OPTTIME);\n\t\tbreak;\n\t}\n\tresult = ufs_alloc_fragments (inode, cgno, goal, request, err);\n\tif (result) {\n\t\tufs_clear_frags(inode, result + oldcount, newcount - oldcount,\n\t\t\t\tlocked_page != NULL);\n\t\tufs_change_blocknr(inode, fragment - oldcount, oldcount,\n\t\t\t\t   uspi->s_sbbase + tmp,\n\t\t\t\t   uspi->s_sbbase + result, locked_page);\n\t\tufs_cpu_to_data_ptr(sb, p, result);\n\t\t*err = 0;\n\t\tUFS_I(inode)->i_lastfrag = max(UFS_I(inode)->i_lastfrag,\n\t\t\t\t\t\tfragment + count);\n\t\tunlock_ufs(sb);\n\t\tif (newcount < request)\n\t\t\tufs_free_fragments (inode, result + newcount, request - newcount);\n\t\tufs_free_fragments (inode, tmp, oldcount);\n\t\tUFSD(\"EXIT, result %llu\\n\", (unsigned long long)result);\n\t\treturn result;\n\t}\n\n\tunlock_ufs(sb);\n\tUFSD(\"EXIT (FAILED)\\n\");\n\treturn 0;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/bitops.h>",
      "#include <linux/capability.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define INVBLOCK ((u64)-1L)"
    ],
    "globals_used": [
      "static u64 ufs_add_fragments(struct inode *, u64, unsigned, unsigned);",
      "static u64 ufs_alloc_fragments(struct inode *, unsigned, u64, unsigned, int *);",
      "static u64 ufs_alloccg_block(struct inode *, struct ufs_cg_private_info *, u64, int *);",
      "static u64 ufs_bitmap_search (struct super_block *, struct ufs_cg_private_info *, u64, unsigned);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"EXIT (FAILED)\\n\""
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_ufs",
          "args": [
            "sb"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_ufs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "104-110",
          "snippet": "void unlock_ufs(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\n\tsbi->mutex_owner = NULL;\n\tmutex_unlock(&sbi->mutex);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid unlock_ufs(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\n\tsbi->mutex_owner = NULL;\n\tmutex_unlock(&sbi->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"EXIT, result %llu\\n\"",
            "(unsigned long long)result"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_free_fragments",
          "args": [
            "inode",
            "tmp",
            "oldcount"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_free_fragments",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/balloc.c",
          "lines": "37-127",
          "snippet": "void ufs_free_fragments(struct inode *inode, u64 fragment, unsigned count)\n{\n\tstruct super_block * sb;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cg_private_info * ucpi;\n\tstruct ufs_cylinder_group * ucg;\n\tunsigned cgno, bit, end_bit, bbase, blkmap, i;\n\tu64 blkno;\n\t\n\tsb = inode->i_sb;\n\tuspi = UFS_SB(sb)->s_uspi;\n\t\n\tUFSD(\"ENTER, fragment %llu, count %u\\n\",\n\t     (unsigned long long)fragment, count);\n\t\n\tif (ufs_fragnum(fragment) + count > uspi->s_fpg)\n\t\tufs_error (sb, \"ufs_free_fragments\", \"internal error\");\n\t\n\tlock_ufs(sb);\n\t\n\tcgno = ufs_dtog(uspi, fragment);\n\tbit = ufs_dtogd(uspi, fragment);\n\tif (cgno >= uspi->s_ncg) {\n\t\tufs_panic (sb, \"ufs_free_fragments\", \"freeing blocks are outside device\");\n\t\tgoto failed;\n\t}\n\t\t\n\tucpi = ufs_load_cylinder (sb, cgno);\n\tif (!ucpi) \n\t\tgoto failed;\n\tucg = ubh_get_ucg (UCPI_UBH(ucpi));\n\tif (!ufs_cg_chkmagic(sb, ucg)) {\n\t\tufs_panic (sb, \"ufs_free_fragments\", \"internal error, bad magic number on cg %u\", cgno);\n\t\tgoto failed;\n\t}\n\n\tend_bit = bit + count;\n\tbbase = ufs_blknum (bit);\n\tblkmap = ubh_blkmap (UCPI_UBH(ucpi), ucpi->c_freeoff, bbase);\n\tufs_fragacct (sb, blkmap, ucg->cg_frsum, -1);\n\tfor (i = bit; i < end_bit; i++) {\n\t\tif (ubh_isclr (UCPI_UBH(ucpi), ucpi->c_freeoff, i))\n\t\t\tubh_setbit (UCPI_UBH(ucpi), ucpi->c_freeoff, i);\n\t\telse \n\t\t\tufs_error (sb, \"ufs_free_fragments\",\n\t\t\t\t   \"bit already cleared for fragment %u\", i);\n\t}\n\t\n\tfs32_add(sb, &ucg->cg_cs.cs_nffree, count);\n\tuspi->cs_total.cs_nffree += count;\n\tfs32_add(sb, &UFS_SB(sb)->fs_cs(cgno).cs_nffree, count);\n\tblkmap = ubh_blkmap (UCPI_UBH(ucpi), ucpi->c_freeoff, bbase);\n\tufs_fragacct(sb, blkmap, ucg->cg_frsum, 1);\n\n\t/*\n\t * Trying to reassemble free fragments into block\n\t */\n\tblkno = ufs_fragstoblks (bbase);\n\tif (ubh_isblockset(UCPI_UBH(ucpi), ucpi->c_freeoff, blkno)) {\n\t\tfs32_sub(sb, &ucg->cg_cs.cs_nffree, uspi->s_fpb);\n\t\tuspi->cs_total.cs_nffree -= uspi->s_fpb;\n\t\tfs32_sub(sb, &UFS_SB(sb)->fs_cs(cgno).cs_nffree, uspi->s_fpb);\n\t\tif ((UFS_SB(sb)->s_flags & UFS_CG_MASK) == UFS_CG_44BSD)\n\t\t\tufs_clusteracct (sb, ucpi, blkno, 1);\n\t\tfs32_add(sb, &ucg->cg_cs.cs_nbfree, 1);\n\t\tuspi->cs_total.cs_nbfree++;\n\t\tfs32_add(sb, &UFS_SB(sb)->fs_cs(cgno).cs_nbfree, 1);\n\t\tif (uspi->fs_magic != UFS2_MAGIC) {\n\t\t\tunsigned cylno = ufs_cbtocylno (bbase);\n\n\t\t\tfs16_add(sb, &ubh_cg_blks(ucpi, cylno,\n\t\t\t\t\t\t  ufs_cbtorpos(bbase)), 1);\n\t\t\tfs32_add(sb, &ubh_cg_blktot(ucpi, cylno), 1);\n\t\t}\n\t}\n\t\n\tubh_mark_buffer_dirty (USPI_UBH(uspi));\n\tubh_mark_buffer_dirty (UCPI_UBH(ucpi));\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tubh_sync_block(UCPI_UBH(ucpi));\n\tufs_mark_sb_dirty(sb);\n\t\n\tunlock_ufs(sb);\n\tUFSD(\"EXIT\\n\");\n\treturn;\n\nfailed:\n\tunlock_ufs(sb);\n\tUFSD(\"EXIT (FAILED)\\n\");\n\treturn;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/bitops.h>",
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ufs_add_fragments(struct inode *, u64, unsigned, unsigned);",
            "static u64 ufs_alloc_fragments(struct inode *, unsigned, u64, unsigned, int *);",
            "static u64 ufs_alloccg_block(struct inode *, struct ufs_cg_private_info *, u64, int *);",
            "static u64 ufs_bitmap_search (struct super_block *, struct ufs_cg_private_info *, u64, unsigned);",
            "static void ufs_clusteracct(struct super_block *, struct ufs_cg_private_info *, unsigned, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <asm/byteorder.h>\n#include <linux/bitops.h>\n#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nstatic u64 ufs_add_fragments(struct inode *, u64, unsigned, unsigned);\nstatic u64 ufs_alloc_fragments(struct inode *, unsigned, u64, unsigned, int *);\nstatic u64 ufs_alloccg_block(struct inode *, struct ufs_cg_private_info *, u64, int *);\nstatic u64 ufs_bitmap_search (struct super_block *, struct ufs_cg_private_info *, u64, unsigned);\nstatic void ufs_clusteracct(struct super_block *, struct ufs_cg_private_info *, unsigned, int);\n\nvoid ufs_free_fragments(struct inode *inode, u64 fragment, unsigned count)\n{\n\tstruct super_block * sb;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cg_private_info * ucpi;\n\tstruct ufs_cylinder_group * ucg;\n\tunsigned cgno, bit, end_bit, bbase, blkmap, i;\n\tu64 blkno;\n\t\n\tsb = inode->i_sb;\n\tuspi = UFS_SB(sb)->s_uspi;\n\t\n\tUFSD(\"ENTER, fragment %llu, count %u\\n\",\n\t     (unsigned long long)fragment, count);\n\t\n\tif (ufs_fragnum(fragment) + count > uspi->s_fpg)\n\t\tufs_error (sb, \"ufs_free_fragments\", \"internal error\");\n\t\n\tlock_ufs(sb);\n\t\n\tcgno = ufs_dtog(uspi, fragment);\n\tbit = ufs_dtogd(uspi, fragment);\n\tif (cgno >= uspi->s_ncg) {\n\t\tufs_panic (sb, \"ufs_free_fragments\", \"freeing blocks are outside device\");\n\t\tgoto failed;\n\t}\n\t\t\n\tucpi = ufs_load_cylinder (sb, cgno);\n\tif (!ucpi) \n\t\tgoto failed;\n\tucg = ubh_get_ucg (UCPI_UBH(ucpi));\n\tif (!ufs_cg_chkmagic(sb, ucg)) {\n\t\tufs_panic (sb, \"ufs_free_fragments\", \"internal error, bad magic number on cg %u\", cgno);\n\t\tgoto failed;\n\t}\n\n\tend_bit = bit + count;\n\tbbase = ufs_blknum (bit);\n\tblkmap = ubh_blkmap (UCPI_UBH(ucpi), ucpi->c_freeoff, bbase);\n\tufs_fragacct (sb, blkmap, ucg->cg_frsum, -1);\n\tfor (i = bit; i < end_bit; i++) {\n\t\tif (ubh_isclr (UCPI_UBH(ucpi), ucpi->c_freeoff, i))\n\t\t\tubh_setbit (UCPI_UBH(ucpi), ucpi->c_freeoff, i);\n\t\telse \n\t\t\tufs_error (sb, \"ufs_free_fragments\",\n\t\t\t\t   \"bit already cleared for fragment %u\", i);\n\t}\n\t\n\tfs32_add(sb, &ucg->cg_cs.cs_nffree, count);\n\tuspi->cs_total.cs_nffree += count;\n\tfs32_add(sb, &UFS_SB(sb)->fs_cs(cgno).cs_nffree, count);\n\tblkmap = ubh_blkmap (UCPI_UBH(ucpi), ucpi->c_freeoff, bbase);\n\tufs_fragacct(sb, blkmap, ucg->cg_frsum, 1);\n\n\t/*\n\t * Trying to reassemble free fragments into block\n\t */\n\tblkno = ufs_fragstoblks (bbase);\n\tif (ubh_isblockset(UCPI_UBH(ucpi), ucpi->c_freeoff, blkno)) {\n\t\tfs32_sub(sb, &ucg->cg_cs.cs_nffree, uspi->s_fpb);\n\t\tuspi->cs_total.cs_nffree -= uspi->s_fpb;\n\t\tfs32_sub(sb, &UFS_SB(sb)->fs_cs(cgno).cs_nffree, uspi->s_fpb);\n\t\tif ((UFS_SB(sb)->s_flags & UFS_CG_MASK) == UFS_CG_44BSD)\n\t\t\tufs_clusteracct (sb, ucpi, blkno, 1);\n\t\tfs32_add(sb, &ucg->cg_cs.cs_nbfree, 1);\n\t\tuspi->cs_total.cs_nbfree++;\n\t\tfs32_add(sb, &UFS_SB(sb)->fs_cs(cgno).cs_nbfree, 1);\n\t\tif (uspi->fs_magic != UFS2_MAGIC) {\n\t\t\tunsigned cylno = ufs_cbtocylno (bbase);\n\n\t\t\tfs16_add(sb, &ubh_cg_blks(ucpi, cylno,\n\t\t\t\t\t\t  ufs_cbtorpos(bbase)), 1);\n\t\t\tfs32_add(sb, &ubh_cg_blktot(ucpi, cylno), 1);\n\t\t}\n\t}\n\t\n\tubh_mark_buffer_dirty (USPI_UBH(uspi));\n\tubh_mark_buffer_dirty (UCPI_UBH(ucpi));\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tubh_sync_block(UCPI_UBH(ucpi));\n\tufs_mark_sb_dirty(sb);\n\t\n\tunlock_ufs(sb);\n\tUFSD(\"EXIT\\n\");\n\treturn;\n\nfailed:\n\tunlock_ufs(sb);\n\tUFSD(\"EXIT (FAILED)\\n\");\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "UFS_I(inode)->i_lastfrag",
            "fragment + count"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "max_select_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/select.c",
          "lines": "342-382",
          "snippet": "static int max_select_fd(unsigned long n, fd_set_bits *fds)\n{\n\tunsigned long *open_fds;\n\tunsigned long set;\n\tint max;\n\tstruct fdtable *fdt;\n\n\t/* handle last in-complete long-word first */\n\tset = ~(~0UL << (n & (BITS_PER_LONG-1)));\n\tn /= BITS_PER_LONG;\n\tfdt = files_fdtable(current->files);\n\topen_fds = fdt->open_fds + n;\n\tmax = 0;\n\tif (set) {\n\t\tset &= BITS(fds, n);\n\t\tif (set) {\n\t\t\tif (!(set & ~*open_fds))\n\t\t\t\tgoto get_max;\n\t\t\treturn -EBADF;\n\t\t}\n\t}\n\twhile (n) {\n\t\topen_fds--;\n\t\tn--;\n\t\tset = BITS(fds, n);\n\t\tif (!set)\n\t\t\tcontinue;\n\t\tif (set & ~*open_fds)\n\t\t\treturn -EBADF;\n\t\tif (max)\n\t\t\tcontinue;\nget_max:\n\t\tdo {\n\t\t\tmax++;\n\t\t\tset >>= 1;\n\t\t} while (set);\n\t\tmax += n * BITS_PER_LONG;\n\t}\n\n\treturn max;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/sched/rt.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic int max_select_fd(unsigned long n, fd_set_bits *fds)\n{\n\tunsigned long *open_fds;\n\tunsigned long set;\n\tint max;\n\tstruct fdtable *fdt;\n\n\t/* handle last in-complete long-word first */\n\tset = ~(~0UL << (n & (BITS_PER_LONG-1)));\n\tn /= BITS_PER_LONG;\n\tfdt = files_fdtable(current->files);\n\topen_fds = fdt->open_fds + n;\n\tmax = 0;\n\tif (set) {\n\t\tset &= BITS(fds, n);\n\t\tif (set) {\n\t\t\tif (!(set & ~*open_fds))\n\t\t\t\tgoto get_max;\n\t\t\treturn -EBADF;\n\t\t}\n\t}\n\twhile (n) {\n\t\topen_fds--;\n\t\tn--;\n\t\tset = BITS(fds, n);\n\t\tif (!set)\n\t\t\tcontinue;\n\t\tif (set & ~*open_fds)\n\t\t\treturn -EBADF;\n\t\tif (max)\n\t\t\tcontinue;\nget_max:\n\t\tdo {\n\t\t\tmax++;\n\t\t\tset >>= 1;\n\t\t} while (set);\n\t\tmax += n * BITS_PER_LONG;\n\t}\n\n\treturn max;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UFS_I",
          "args": [
            "inode"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_I",
          "args": [
            "inode"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_cpu_to_data_ptr",
          "args": [
            "sb",
            "p",
            "result"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_cpu_to_data_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "568-574",
          "snippet": "static inline void ufs_cpu_to_data_ptr(struct super_block *sb, void *p, u64 val)\n{\n\tif (UFS_SB(sb)->s_uspi->fs_magic == UFS2_MAGIC)\n\t\t*(__fs64 *)p = cpu_to_fs64(sb, val);\n\telse\n\t\t*(__fs32 *)p = cpu_to_fs32(sb, val);\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct ufs_buffer_head * _ubh_bread_(struct ufs_sb_private_info *, struct super_block *, u64 , u64);",
            "extern struct ufs_buffer_head * ubh_bread_uspi(struct ufs_sb_private_info *, struct super_block *, u64, u64);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nextern struct ufs_buffer_head * _ubh_bread_(struct ufs_sb_private_info *, struct super_block *, u64 , u64);\nextern struct ufs_buffer_head * ubh_bread_uspi(struct ufs_sb_private_info *, struct super_block *, u64, u64);\n\nstatic inline void ufs_cpu_to_data_ptr(struct super_block *sb, void *p, u64 val)\n{\n\tif (UFS_SB(sb)->s_uspi->fs_magic == UFS2_MAGIC)\n\t\t*(__fs64 *)p = cpu_to_fs64(sb, val);\n\telse\n\t\t*(__fs32 *)p = cpu_to_fs32(sb, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_change_blocknr",
          "args": [
            "inode",
            "fragment - oldcount",
            "oldcount",
            "uspi->s_sbbase + tmp",
            "uspi->s_sbbase + result",
            "locked_page"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_change_blocknr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/balloc.c",
          "lines": "235-320",
          "snippet": "static void ufs_change_blocknr(struct inode *inode, sector_t beg,\n\t\t\t       unsigned int count, sector_t oldb,\n\t\t\t       sector_t newb, struct page *locked_page)\n{\n\tconst unsigned blks_per_page =\n\t\t1 << (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\tconst unsigned mask = blks_per_page - 1;\n\tstruct address_space * const mapping = inode->i_mapping;\n\tpgoff_t index, cur_index, last_index;\n\tunsigned pos, j, lblock;\n\tsector_t end, i;\n\tstruct page *page;\n\tstruct buffer_head *head, *bh;\n\n\tUFSD(\"ENTER, ino %lu, count %u, oldb %llu, newb %llu\\n\",\n\t      inode->i_ino, count,\n\t     (unsigned long long)oldb, (unsigned long long)newb);\n\n\tBUG_ON(!locked_page);\n\tBUG_ON(!PageLocked(locked_page));\n\n\tcur_index = locked_page->index;\n\tend = count + beg;\n\tlast_index = end >> (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\tfor (i = beg; i < end; i = (i | mask) + 1) {\n\t\tindex = i >> (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\n\t\tif (likely(cur_index != index)) {\n\t\t\tpage = ufs_get_locked_page(mapping, index);\n\t\t\tif (!page)/* it was truncated */\n\t\t\t\tcontinue;\n\t\t\tif (IS_ERR(page)) {/* or EIO */\n\t\t\t\tufs_error(inode->i_sb, __func__,\n\t\t\t\t\t  \"read of page %llu failed\\n\",\n\t\t\t\t\t  (unsigned long long)index);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else\n\t\t\tpage = locked_page;\n\n\t\thead = page_buffers(page);\n\t\tbh = head;\n\t\tpos = i & mask;\n\t\tfor (j = 0; j < pos; ++j)\n\t\t\tbh = bh->b_this_page;\n\n\n\t\tif (unlikely(index == last_index))\n\t\t\tlblock = end & mask;\n\t\telse\n\t\t\tlblock = blks_per_page;\n\n\t\tdo {\n\t\t\tif (j >= lblock)\n\t\t\t\tbreak;\n\t\t\tpos = (i - beg) + j;\n\n\t\t\tif (!buffer_mapped(bh))\n\t\t\t\t\tmap_bh(bh, inode->i_sb, oldb + pos);\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tll_rw_block(READ, 1, &bh);\n\t\t\t\twait_on_buffer(bh);\n\t\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\t\tufs_error(inode->i_sb, __func__,\n\t\t\t\t\t\t  \"read of block failed\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tUFSD(\" change from %llu to %llu, pos %u\\n\",\n\t\t\t     (unsigned long long)(pos + oldb),\n\t\t\t     (unsigned long long)(pos + newb), pos);\n\n\t\t\tbh->b_blocknr = newb + pos;\n\t\t\tunmap_underlying_metadata(bh->b_bdev,\n\t\t\t\t\t\t  bh->b_blocknr);\n\t\t\tmark_buffer_dirty(bh);\n\t\t\t++j;\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\n\t\tif (likely(cur_index != index))\n\t\t\tufs_put_locked_page(page);\n \t}\n\tUFSD(\"EXIT\\n\");\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/bitops.h>",
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <asm/byteorder.h>\n#include <linux/bitops.h>\n#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nstatic void ufs_change_blocknr(struct inode *inode, sector_t beg,\n\t\t\t       unsigned int count, sector_t oldb,\n\t\t\t       sector_t newb, struct page *locked_page)\n{\n\tconst unsigned blks_per_page =\n\t\t1 << (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\tconst unsigned mask = blks_per_page - 1;\n\tstruct address_space * const mapping = inode->i_mapping;\n\tpgoff_t index, cur_index, last_index;\n\tunsigned pos, j, lblock;\n\tsector_t end, i;\n\tstruct page *page;\n\tstruct buffer_head *head, *bh;\n\n\tUFSD(\"ENTER, ino %lu, count %u, oldb %llu, newb %llu\\n\",\n\t      inode->i_ino, count,\n\t     (unsigned long long)oldb, (unsigned long long)newb);\n\n\tBUG_ON(!locked_page);\n\tBUG_ON(!PageLocked(locked_page));\n\n\tcur_index = locked_page->index;\n\tend = count + beg;\n\tlast_index = end >> (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\tfor (i = beg; i < end; i = (i | mask) + 1) {\n\t\tindex = i >> (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\n\t\tif (likely(cur_index != index)) {\n\t\t\tpage = ufs_get_locked_page(mapping, index);\n\t\t\tif (!page)/* it was truncated */\n\t\t\t\tcontinue;\n\t\t\tif (IS_ERR(page)) {/* or EIO */\n\t\t\t\tufs_error(inode->i_sb, __func__,\n\t\t\t\t\t  \"read of page %llu failed\\n\",\n\t\t\t\t\t  (unsigned long long)index);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else\n\t\t\tpage = locked_page;\n\n\t\thead = page_buffers(page);\n\t\tbh = head;\n\t\tpos = i & mask;\n\t\tfor (j = 0; j < pos; ++j)\n\t\t\tbh = bh->b_this_page;\n\n\n\t\tif (unlikely(index == last_index))\n\t\t\tlblock = end & mask;\n\t\telse\n\t\t\tlblock = blks_per_page;\n\n\t\tdo {\n\t\t\tif (j >= lblock)\n\t\t\t\tbreak;\n\t\t\tpos = (i - beg) + j;\n\n\t\t\tif (!buffer_mapped(bh))\n\t\t\t\t\tmap_bh(bh, inode->i_sb, oldb + pos);\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tll_rw_block(READ, 1, &bh);\n\t\t\t\twait_on_buffer(bh);\n\t\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\t\tufs_error(inode->i_sb, __func__,\n\t\t\t\t\t\t  \"read of block failed\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tUFSD(\" change from %llu to %llu, pos %u\\n\",\n\t\t\t     (unsigned long long)(pos + oldb),\n\t\t\t     (unsigned long long)(pos + newb), pos);\n\n\t\t\tbh->b_blocknr = newb + pos;\n\t\t\tunmap_underlying_metadata(bh->b_bdev,\n\t\t\t\t\t\t  bh->b_blocknr);\n\t\t\tmark_buffer_dirty(bh);\n\t\t\t++j;\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\n\t\tif (likely(cur_index != index))\n\t\t\tufs_put_locked_page(page);\n \t}\n\tUFSD(\"EXIT\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_clear_frags",
          "args": [
            "inode",
            "result + oldcount",
            "newcount - oldcount",
            "locked_page != NULL"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_clear_frags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/balloc.c",
          "lines": "322-339",
          "snippet": "static void ufs_clear_frags(struct inode *inode, sector_t beg, unsigned int n,\n\t\t\t    int sync)\n{\n\tstruct buffer_head *bh;\n\tsector_t end = beg + n;\n\n\tfor (; beg < end; ++beg) {\n\t\tbh = sb_getblk(inode->i_sb, beg);\n\t\tlock_buffer(bh);\n\t\tmemset(bh->b_data, 0, inode->i_sb->s_blocksize);\n\t\tset_buffer_uptodate(bh);\n\t\tmark_buffer_dirty(bh);\n\t\tunlock_buffer(bh);\n\t\tif (IS_SYNC(inode) || sync)\n\t\t\tsync_dirty_buffer(bh);\n\t\tbrelse(bh);\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/bitops.h>",
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <asm/byteorder.h>\n#include <linux/bitops.h>\n#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nstatic void ufs_clear_frags(struct inode *inode, sector_t beg, unsigned int n,\n\t\t\t    int sync)\n{\n\tstruct buffer_head *bh;\n\tsector_t end = beg + n;\n\n\tfor (; beg < end; ++beg) {\n\t\tbh = sb_getblk(inode->i_sb, beg);\n\t\tlock_buffer(bh);\n\t\tmemset(bh->b_data, 0, inode->i_sb->s_blocksize);\n\t\tset_buffer_uptodate(bh);\n\t\tmark_buffer_dirty(bh);\n\t\tunlock_buffer(bh);\n\t\tif (IS_SYNC(inode) || sync)\n\t\t\tsync_dirty_buffer(bh);\n\t\tbrelse(bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_alloc_fragments",
          "args": [
            "inode",
            "cgno",
            "goal",
            "request",
            "err"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_alloc_fragments",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/balloc.c",
          "lines": "569-677",
          "snippet": "static u64 ufs_alloc_fragments(struct inode *inode, unsigned cgno,\n\t\t\t       u64 goal, unsigned count, int *err)\n{\n\tstruct super_block * sb;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cg_private_info * ucpi;\n\tstruct ufs_cylinder_group * ucg;\n\tunsigned oldcg, i, j, k, allocsize;\n\tu64 result;\n\t\n\tUFSD(\"ENTER, ino %lu, cgno %u, goal %llu, count %u\\n\",\n\t     inode->i_ino, cgno, (unsigned long long)goal, count);\n\n\tsb = inode->i_sb;\n\tuspi = UFS_SB(sb)->s_uspi;\n\toldcg = cgno;\n\t\n\t/*\n\t * 1. searching on preferred cylinder group\n\t */\n\tUFS_TEST_FREE_SPACE_CG\n\n\t/*\n\t * 2. quadratic rehash\n\t */\n\tfor (j = 1; j < uspi->s_ncg; j *= 2) {\n\t\tcgno += j;\n\t\tif (cgno >= uspi->s_ncg) \n\t\t\tcgno -= uspi->s_ncg;\n\t\tUFS_TEST_FREE_SPACE_CG\n\t}\n\n\t/*\n\t * 3. brute force search\n\t * We start at i = 2 ( 0 is checked at 1.step, 1 at 2.step )\n\t */\n\tcgno = (oldcg + 1) % uspi->s_ncg;\n\tfor (j = 2; j < uspi->s_ncg; j++) {\n\t\tcgno++;\n\t\tif (cgno >= uspi->s_ncg)\n\t\t\tcgno = 0;\n\t\tUFS_TEST_FREE_SPACE_CG\n\t}\n\t\n\tUFSD(\"EXIT (FAILED)\\n\");\n\treturn 0;\n\ncg_found:\n\tucpi = ufs_load_cylinder (sb, cgno);\n\tif (!ucpi)\n\t\treturn 0;\n\tucg = ubh_get_ucg (UCPI_UBH(ucpi));\n\tif (!ufs_cg_chkmagic(sb, ucg)) \n\t\tufs_panic (sb, \"ufs_alloc_fragments\",\n\t\t\t\"internal error, bad magic number on cg %u\", cgno);\n\tucg->cg_time = cpu_to_fs32(sb, get_seconds());\n\n\tif (count == uspi->s_fpb) {\n\t\tresult = ufs_alloccg_block (inode, ucpi, goal, err);\n\t\tif (result == INVBLOCK)\n\t\t\treturn 0;\n\t\tgoto succed;\n\t}\n\n\tfor (allocsize = count; allocsize < uspi->s_fpb; allocsize++)\n\t\tif (fs32_to_cpu(sb, ucg->cg_frsum[allocsize]) != 0)\n\t\t\tbreak;\n\t\n\tif (allocsize == uspi->s_fpb) {\n\t\tresult = ufs_alloccg_block (inode, ucpi, goal, err);\n\t\tif (result == INVBLOCK)\n\t\t\treturn 0;\n\t\tgoal = ufs_dtogd(uspi, result);\n\t\tfor (i = count; i < uspi->s_fpb; i++)\n\t\t\tubh_setbit (UCPI_UBH(ucpi), ucpi->c_freeoff, goal + i);\n\t\ti = uspi->s_fpb - count;\n\n\t\tfs32_add(sb, &ucg->cg_cs.cs_nffree, i);\n\t\tuspi->cs_total.cs_nffree += i;\n\t\tfs32_add(sb, &UFS_SB(sb)->fs_cs(cgno).cs_nffree, i);\n\t\tfs32_add(sb, &ucg->cg_frsum[i], 1);\n\t\tgoto succed;\n\t}\n\n\tresult = ufs_bitmap_search (sb, ucpi, goal, allocsize);\n\tif (result == INVBLOCK)\n\t\treturn 0;\n\tfor (i = 0; i < count; i++)\n\t\tubh_clrbit (UCPI_UBH(ucpi), ucpi->c_freeoff, result + i);\n\t\n\tfs32_sub(sb, &ucg->cg_cs.cs_nffree, count);\n\tuspi->cs_total.cs_nffree -= count;\n\tfs32_sub(sb, &UFS_SB(sb)->fs_cs(cgno).cs_nffree, count);\n\tfs32_sub(sb, &ucg->cg_frsum[allocsize], 1);\n\n\tif (count != allocsize)\n\t\tfs32_add(sb, &ucg->cg_frsum[allocsize - count], 1);\n\nsucced:\n\tubh_mark_buffer_dirty (USPI_UBH(uspi));\n\tubh_mark_buffer_dirty (UCPI_UBH(ucpi));\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tubh_sync_block(UCPI_UBH(ucpi));\n\tufs_mark_sb_dirty(sb);\n\n\tresult += cgno * uspi->s_fpg;\n\tUFSD(\"EXIT3, result %llu\\n\", (unsigned long long)result);\n\treturn result;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/bitops.h>",
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define UFS_TEST_FREE_SPACE_CG \\\n\tucg = (struct ufs_cylinder_group *) UFS_SB(sb)->s_ucg[cgno]->b_data; \\\n\tif (fs32_to_cpu(sb, ucg->cg_cs.cs_nbfree)) \\\n\t\tgoto cg_found; \\\n\tfor (k = count; k < uspi->s_fpb; k++) \\\n\t\tif (fs32_to_cpu(sb, ucg->cg_frsum[k])) \\\n\t\t\tgoto cg_found;",
            "#define INVBLOCK ((u64)-1L)"
          ],
          "globals_used": [
            "static u64 ufs_add_fragments(struct inode *, u64, unsigned, unsigned);",
            "static u64 ufs_alloc_fragments(struct inode *, unsigned, u64, unsigned, int *);",
            "static u64 ufs_alloccg_block(struct inode *, struct ufs_cg_private_info *, u64, int *);",
            "static u64 ufs_bitmap_search (struct super_block *, struct ufs_cg_private_info *, u64, unsigned);",
            "static void ufs_clusteracct(struct super_block *, struct ufs_cg_private_info *, unsigned, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <asm/byteorder.h>\n#include <linux/bitops.h>\n#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\n#define UFS_TEST_FREE_SPACE_CG \\\n\tucg = (struct ufs_cylinder_group *) UFS_SB(sb)->s_ucg[cgno]->b_data; \\\n\tif (fs32_to_cpu(sb, ucg->cg_cs.cs_nbfree)) \\\n\t\tgoto cg_found; \\\n\tfor (k = count; k < uspi->s_fpb; k++) \\\n\t\tif (fs32_to_cpu(sb, ucg->cg_frsum[k])) \\\n\t\t\tgoto cg_found;\n#define INVBLOCK ((u64)-1L)\n\nstatic u64 ufs_add_fragments(struct inode *, u64, unsigned, unsigned);\nstatic u64 ufs_alloc_fragments(struct inode *, unsigned, u64, unsigned, int *);\nstatic u64 ufs_alloccg_block(struct inode *, struct ufs_cg_private_info *, u64, int *);\nstatic u64 ufs_bitmap_search (struct super_block *, struct ufs_cg_private_info *, u64, unsigned);\nstatic void ufs_clusteracct(struct super_block *, struct ufs_cg_private_info *, unsigned, int);\n\nstatic u64 ufs_alloc_fragments(struct inode *inode, unsigned cgno,\n\t\t\t       u64 goal, unsigned count, int *err)\n{\n\tstruct super_block * sb;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cg_private_info * ucpi;\n\tstruct ufs_cylinder_group * ucg;\n\tunsigned oldcg, i, j, k, allocsize;\n\tu64 result;\n\t\n\tUFSD(\"ENTER, ino %lu, cgno %u, goal %llu, count %u\\n\",\n\t     inode->i_ino, cgno, (unsigned long long)goal, count);\n\n\tsb = inode->i_sb;\n\tuspi = UFS_SB(sb)->s_uspi;\n\toldcg = cgno;\n\t\n\t/*\n\t * 1. searching on preferred cylinder group\n\t */\n\tUFS_TEST_FREE_SPACE_CG\n\n\t/*\n\t * 2. quadratic rehash\n\t */\n\tfor (j = 1; j < uspi->s_ncg; j *= 2) {\n\t\tcgno += j;\n\t\tif (cgno >= uspi->s_ncg) \n\t\t\tcgno -= uspi->s_ncg;\n\t\tUFS_TEST_FREE_SPACE_CG\n\t}\n\n\t/*\n\t * 3. brute force search\n\t * We start at i = 2 ( 0 is checked at 1.step, 1 at 2.step )\n\t */\n\tcgno = (oldcg + 1) % uspi->s_ncg;\n\tfor (j = 2; j < uspi->s_ncg; j++) {\n\t\tcgno++;\n\t\tif (cgno >= uspi->s_ncg)\n\t\t\tcgno = 0;\n\t\tUFS_TEST_FREE_SPACE_CG\n\t}\n\t\n\tUFSD(\"EXIT (FAILED)\\n\");\n\treturn 0;\n\ncg_found:\n\tucpi = ufs_load_cylinder (sb, cgno);\n\tif (!ucpi)\n\t\treturn 0;\n\tucg = ubh_get_ucg (UCPI_UBH(ucpi));\n\tif (!ufs_cg_chkmagic(sb, ucg)) \n\t\tufs_panic (sb, \"ufs_alloc_fragments\",\n\t\t\t\"internal error, bad magic number on cg %u\", cgno);\n\tucg->cg_time = cpu_to_fs32(sb, get_seconds());\n\n\tif (count == uspi->s_fpb) {\n\t\tresult = ufs_alloccg_block (inode, ucpi, goal, err);\n\t\tif (result == INVBLOCK)\n\t\t\treturn 0;\n\t\tgoto succed;\n\t}\n\n\tfor (allocsize = count; allocsize < uspi->s_fpb; allocsize++)\n\t\tif (fs32_to_cpu(sb, ucg->cg_frsum[allocsize]) != 0)\n\t\t\tbreak;\n\t\n\tif (allocsize == uspi->s_fpb) {\n\t\tresult = ufs_alloccg_block (inode, ucpi, goal, err);\n\t\tif (result == INVBLOCK)\n\t\t\treturn 0;\n\t\tgoal = ufs_dtogd(uspi, result);\n\t\tfor (i = count; i < uspi->s_fpb; i++)\n\t\t\tubh_setbit (UCPI_UBH(ucpi), ucpi->c_freeoff, goal + i);\n\t\ti = uspi->s_fpb - count;\n\n\t\tfs32_add(sb, &ucg->cg_cs.cs_nffree, i);\n\t\tuspi->cs_total.cs_nffree += i;\n\t\tfs32_add(sb, &UFS_SB(sb)->fs_cs(cgno).cs_nffree, i);\n\t\tfs32_add(sb, &ucg->cg_frsum[i], 1);\n\t\tgoto succed;\n\t}\n\n\tresult = ufs_bitmap_search (sb, ucpi, goal, allocsize);\n\tif (result == INVBLOCK)\n\t\treturn 0;\n\tfor (i = 0; i < count; i++)\n\t\tubh_clrbit (UCPI_UBH(ucpi), ucpi->c_freeoff, result + i);\n\t\n\tfs32_sub(sb, &ucg->cg_cs.cs_nffree, count);\n\tuspi->cs_total.cs_nffree -= count;\n\tfs32_sub(sb, &UFS_SB(sb)->fs_cs(cgno).cs_nffree, count);\n\tfs32_sub(sb, &ucg->cg_frsum[allocsize], 1);\n\n\tif (count != allocsize)\n\t\tfs32_add(sb, &ucg->cg_frsum[allocsize - count], 1);\n\nsucced:\n\tubh_mark_buffer_dirty (USPI_UBH(uspi));\n\tubh_mark_buffer_dirty (UCPI_UBH(ucpi));\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tubh_sync_block(UCPI_UBH(ucpi));\n\tufs_mark_sb_dirty(sb);\n\n\tresult += cgno * uspi->s_fpg;\n\tUFSD(\"EXIT3, result %llu\\n\", (unsigned long long)result);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_fs32",
          "args": [
            "sb",
            "UFS_OPTTIME"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_to_fs32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "52-59",
          "snippet": "static inline __fs32\ncpu_to_fs32(struct super_block *sbp, u32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn (__force __fs32)cpu_to_le32(n);\n\telse\n\t\treturn (__force __fs32)cpu_to_be32(n);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline __fs32\ncpu_to_fs32(struct super_block *sbp, u32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn (__force __fs32)cpu_to_le32(n);\n\telse\n\t\treturn (__force __fs32)cpu_to_be32(n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs32_to_cpu",
          "args": [
            "sb",
            "usb1->fs_optim"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "fs32_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "43-50",
          "snippet": "static inline u32\nfs32_to_cpu(struct super_block *sbp, __fs32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u32\nfs32_to_cpu(struct super_block *sbp, __fs32 n)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\treturn le32_to_cpu((__force __le32)n);\n\telse\n\t\treturn be32_to_cpu((__force __be32)n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"EXIT, result %llu\\n\"",
            "(unsigned long long)result"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_I",
          "args": [
            "inode"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_I",
          "args": [
            "inode"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_add_fragments",
          "args": [
            "inode",
            "tmp",
            "oldcount",
            "newcount"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_add_fragments",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/balloc.c",
          "lines": "493-559",
          "snippet": "static u64 ufs_add_fragments(struct inode *inode, u64 fragment,\n\t\t\t     unsigned oldcount, unsigned newcount)\n{\n\tstruct super_block * sb;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cg_private_info * ucpi;\n\tstruct ufs_cylinder_group * ucg;\n\tunsigned cgno, fragno, fragoff, count, fragsize, i;\n\t\n\tUFSD(\"ENTER, fragment %llu, oldcount %u, newcount %u\\n\",\n\t     (unsigned long long)fragment, oldcount, newcount);\n\t\n\tsb = inode->i_sb;\n\tuspi = UFS_SB(sb)->s_uspi;\n\tcount = newcount - oldcount;\n\t\n\tcgno = ufs_dtog(uspi, fragment);\n\tif (fs32_to_cpu(sb, UFS_SB(sb)->fs_cs(cgno).cs_nffree) < count)\n\t\treturn 0;\n\tif ((ufs_fragnum (fragment) + newcount) > uspi->s_fpb)\n\t\treturn 0;\n\tucpi = ufs_load_cylinder (sb, cgno);\n\tif (!ucpi)\n\t\treturn 0;\n\tucg = ubh_get_ucg (UCPI_UBH(ucpi));\n\tif (!ufs_cg_chkmagic(sb, ucg)) {\n\t\tufs_panic (sb, \"ufs_add_fragments\",\n\t\t\t\"internal error, bad magic number on cg %u\", cgno);\n\t\treturn 0;\n\t}\n\n\tfragno = ufs_dtogd(uspi, fragment);\n\tfragoff = ufs_fragnum (fragno);\n\tfor (i = oldcount; i < newcount; i++)\n\t\tif (ubh_isclr (UCPI_UBH(ucpi), ucpi->c_freeoff, fragno + i))\n\t\t\treturn 0;\n\t/*\n\t * Block can be extended\n\t */\n\tucg->cg_time = cpu_to_fs32(sb, get_seconds());\n\tfor (i = newcount; i < (uspi->s_fpb - fragoff); i++)\n\t\tif (ubh_isclr (UCPI_UBH(ucpi), ucpi->c_freeoff, fragno + i))\n\t\t\tbreak;\n\tfragsize = i - oldcount;\n\tif (!fs32_to_cpu(sb, ucg->cg_frsum[fragsize]))\n\t\tufs_panic (sb, \"ufs_add_fragments\",\n\t\t\t\"internal error or corrupted bitmap on cg %u\", cgno);\n\tfs32_sub(sb, &ucg->cg_frsum[fragsize], 1);\n\tif (fragsize != count)\n\t\tfs32_add(sb, &ucg->cg_frsum[fragsize - count], 1);\n\tfor (i = oldcount; i < newcount; i++)\n\t\tubh_clrbit (UCPI_UBH(ucpi), ucpi->c_freeoff, fragno + i);\n\n\tfs32_sub(sb, &ucg->cg_cs.cs_nffree, count);\n\tfs32_sub(sb, &UFS_SB(sb)->fs_cs(cgno).cs_nffree, count);\n\tuspi->cs_total.cs_nffree -= count;\n\t\n\tubh_mark_buffer_dirty (USPI_UBH(uspi));\n\tubh_mark_buffer_dirty (UCPI_UBH(ucpi));\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tubh_sync_block(UCPI_UBH(ucpi));\n\tufs_mark_sb_dirty(sb);\n\n\tUFSD(\"EXIT, fragment %llu\\n\", (unsigned long long)fragment);\n\t\n\treturn fragment;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/bitops.h>",
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ufs_add_fragments(struct inode *, u64, unsigned, unsigned);",
            "static u64 ufs_alloc_fragments(struct inode *, unsigned, u64, unsigned, int *);",
            "static u64 ufs_alloccg_block(struct inode *, struct ufs_cg_private_info *, u64, int *);",
            "static u64 ufs_bitmap_search (struct super_block *, struct ufs_cg_private_info *, u64, unsigned);",
            "static void ufs_clusteracct(struct super_block *, struct ufs_cg_private_info *, unsigned, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <asm/byteorder.h>\n#include <linux/bitops.h>\n#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nstatic u64 ufs_add_fragments(struct inode *, u64, unsigned, unsigned);\nstatic u64 ufs_alloc_fragments(struct inode *, unsigned, u64, unsigned, int *);\nstatic u64 ufs_alloccg_block(struct inode *, struct ufs_cg_private_info *, u64, int *);\nstatic u64 ufs_bitmap_search (struct super_block *, struct ufs_cg_private_info *, u64, unsigned);\nstatic void ufs_clusteracct(struct super_block *, struct ufs_cg_private_info *, unsigned, int);\n\nstatic u64 ufs_add_fragments(struct inode *inode, u64 fragment,\n\t\t\t     unsigned oldcount, unsigned newcount)\n{\n\tstruct super_block * sb;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cg_private_info * ucpi;\n\tstruct ufs_cylinder_group * ucg;\n\tunsigned cgno, fragno, fragoff, count, fragsize, i;\n\t\n\tUFSD(\"ENTER, fragment %llu, oldcount %u, newcount %u\\n\",\n\t     (unsigned long long)fragment, oldcount, newcount);\n\t\n\tsb = inode->i_sb;\n\tuspi = UFS_SB(sb)->s_uspi;\n\tcount = newcount - oldcount;\n\t\n\tcgno = ufs_dtog(uspi, fragment);\n\tif (fs32_to_cpu(sb, UFS_SB(sb)->fs_cs(cgno).cs_nffree) < count)\n\t\treturn 0;\n\tif ((ufs_fragnum (fragment) + newcount) > uspi->s_fpb)\n\t\treturn 0;\n\tucpi = ufs_load_cylinder (sb, cgno);\n\tif (!ucpi)\n\t\treturn 0;\n\tucg = ubh_get_ucg (UCPI_UBH(ucpi));\n\tif (!ufs_cg_chkmagic(sb, ucg)) {\n\t\tufs_panic (sb, \"ufs_add_fragments\",\n\t\t\t\"internal error, bad magic number on cg %u\", cgno);\n\t\treturn 0;\n\t}\n\n\tfragno = ufs_dtogd(uspi, fragment);\n\tfragoff = ufs_fragnum (fragno);\n\tfor (i = oldcount; i < newcount; i++)\n\t\tif (ubh_isclr (UCPI_UBH(ucpi), ucpi->c_freeoff, fragno + i))\n\t\t\treturn 0;\n\t/*\n\t * Block can be extended\n\t */\n\tucg->cg_time = cpu_to_fs32(sb, get_seconds());\n\tfor (i = newcount; i < (uspi->s_fpb - fragoff); i++)\n\t\tif (ubh_isclr (UCPI_UBH(ucpi), ucpi->c_freeoff, fragno + i))\n\t\t\tbreak;\n\tfragsize = i - oldcount;\n\tif (!fs32_to_cpu(sb, ucg->cg_frsum[fragsize]))\n\t\tufs_panic (sb, \"ufs_add_fragments\",\n\t\t\t\"internal error or corrupted bitmap on cg %u\", cgno);\n\tfs32_sub(sb, &ucg->cg_frsum[fragsize], 1);\n\tif (fragsize != count)\n\t\tfs32_add(sb, &ucg->cg_frsum[fragsize - count], 1);\n\tfor (i = oldcount; i < newcount; i++)\n\t\tubh_clrbit (UCPI_UBH(ucpi), ucpi->c_freeoff, fragno + i);\n\n\tfs32_sub(sb, &ucg->cg_cs.cs_nffree, count);\n\tfs32_sub(sb, &UFS_SB(sb)->fs_cs(cgno).cs_nffree, count);\n\tuspi->cs_total.cs_nffree -= count;\n\t\n\tubh_mark_buffer_dirty (USPI_UBH(uspi));\n\tubh_mark_buffer_dirty (UCPI_UBH(ucpi));\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tubh_sync_block(UCPI_UBH(ucpi));\n\tufs_mark_sb_dirty(sb);\n\n\tUFSD(\"EXIT, fragment %llu\\n\", (unsigned long long)fragment);\n\t\n\treturn fragment;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"EXIT, result %llu\\n\"",
            "(unsigned long long)result"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_I",
          "args": [
            "inode"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_I",
          "args": [
            "inode"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_dtog",
          "args": [
            "uspi",
            "goal"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_inotocg",
          "args": [
            "inode->i_ino"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"EXIT (FAILED)\\n\""
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_freespace",
          "args": [
            "uspi",
            "UFS_MINFREE"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_freespace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "357-363",
          "snippet": "static inline u64\nufs_freespace(struct ufs_sb_private_info *uspi, int percentreserved)\n{\n\treturn ufs_blkstofrags(uspi->cs_total.cs_nbfree) +\n\t\tuspi->cs_total.cs_nffree -\n\t\t(uspi->s_dsize * (percentreserved) / 100);\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct ufs_buffer_head * _ubh_bread_(struct ufs_sb_private_info *, struct super_block *, u64 , u64);",
            "extern struct ufs_buffer_head * ubh_bread_uspi(struct ufs_sb_private_info *, struct super_block *, u64, u64);",
            "extern void ubh_brelse_uspi (struct ufs_sb_private_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nextern struct ufs_buffer_head * _ubh_bread_(struct ufs_sb_private_info *, struct super_block *, u64 , u64);\nextern struct ufs_buffer_head * ubh_bread_uspi(struct ufs_sb_private_info *, struct super_block *, u64, u64);\nextern void ubh_brelse_uspi (struct ufs_sb_private_info *);\n\nstatic inline u64\nufs_freespace(struct ufs_sb_private_info *uspi, int percentreserved)\n{\n\treturn ufs_blkstofrags(uspi->cs_total.cs_nbfree) +\n\t\tuspi->cs_total.cs_nffree -\n\t\t(uspi->s_dsize * (percentreserved) / 100);\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_RESOURCE"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"EXIT (ALREADY ALLOCATED)\\n\""
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"EXIT (ALREADY ALLOCATED)\\n\""
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_I",
          "args": [
            "inode"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_error",
          "args": [
            "sb",
            "\"ufs_new_fragments\"",
            "\"internal error, \"\n\t\t\t\t  \"fragment %llu, tmp %llu\\n\"",
            "(unsigned long long)fragment",
            "(unsigned long long)tmp"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "285-317",
          "snippet": "void ufs_error (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct va_format vaf;\n\tva_list args;\n\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\t\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tusb1->fs_clean = UFS_FSBAD;\n\t\tubh_mark_buffer_dirty(USPI_UBH(uspi));\n\t\tufs_mark_sb_dirty(sb);\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tswitch (UFS_SB(sb)->s_mount_opt & UFS_MOUNT_ONERROR) {\n\tcase UFS_MOUNT_ONERROR_PANIC:\n\t\tpanic(\"panic (device %s): %s: %pV\\n\",\n\t\t      sb->s_id, function, &vaf);\n\n\tcase UFS_MOUNT_ONERROR_LOCK:\n\tcase UFS_MOUNT_ONERROR_UMOUNT:\n\tcase UFS_MOUNT_ONERROR_REPAIR:\n\t\tpr_crit(\"error (device %s): %s: %pV\\n\",\n\t\t\tsb->s_id, function, &vaf);\n\t}\n\tva_end(args);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid ufs_error (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct va_format vaf;\n\tva_list args;\n\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\t\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tusb1->fs_clean = UFS_FSBAD;\n\t\tubh_mark_buffer_dirty(USPI_UBH(uspi));\n\t\tufs_mark_sb_dirty(sb);\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tswitch (UFS_SB(sb)->s_mount_opt & UFS_MOUNT_ONERROR) {\n\tcase UFS_MOUNT_ONERROR_PANIC:\n\t\tpanic(\"panic (device %s): %s: %pV\\n\",\n\t\t      sb->s_id, function, &vaf);\n\n\tcase UFS_MOUNT_ONERROR_LOCK:\n\tcase UFS_MOUNT_ONERROR_UMOUNT:\n\tcase UFS_MOUNT_ONERROR_REPAIR:\n\t\tpr_crit(\"error (device %s): %s: %pV\\n\",\n\t\t\tsb->s_id, function, &vaf);\n\t}\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_fragnum",
          "args": [
            "fragment"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_fragnum",
          "args": [
            "fragment"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_warning",
          "args": [
            "sb",
            "\"ufs_new_fragments\"",
            "\"internal warning\"\n\t\t\t    \" fragment %llu, count %u\"",
            "(unsigned long long)fragment",
            "count"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_warning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "344-356",
          "snippet": "void ufs_warning (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"(device %s): %s: %pV\\n\",\n\t\tsb->s_id, function, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid ufs_warning (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_warn(\"(device %s): %s: %pV\\n\",\n\t\tsb->s_id, function, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_fragnum",
          "args": [
            "fragment"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_data_ptr_to_cpu",
          "args": [
            "sb",
            "p"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_data_ptr_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "561-566",
          "snippet": "static inline u64 ufs_data_ptr_to_cpu(struct super_block *sb, void *p)\n{\n\treturn UFS_SB(sb)->s_uspi->fs_magic == UFS2_MAGIC ?\n\t\tfs64_to_cpu(sb, *(__fs64 *)p) :\n\t\tfs32_to_cpu(sb, *(__fs32 *)p);\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct ufs_buffer_head * _ubh_bread_(struct ufs_sb_private_info *, struct super_block *, u64 , u64);",
            "extern struct ufs_buffer_head * ubh_bread_uspi(struct ufs_sb_private_info *, struct super_block *, u64, u64);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nextern struct ufs_buffer_head * _ubh_bread_(struct ufs_sb_private_info *, struct super_block *, u64 , u64);\nextern struct ufs_buffer_head * ubh_bread_uspi(struct ufs_sb_private_info *, struct super_block *, u64, u64);\n\nstatic inline u64 ufs_data_ptr_to_cpu(struct super_block *sb, void *p)\n{\n\treturn UFS_SB(sb)->s_uspi->fs_magic == UFS2_MAGIC ?\n\t\tfs64_to_cpu(sb, *(__fs64 *)p) :\n\t\tfs32_to_cpu(sb, *(__fs32 *)p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubh_get_usb_first",
          "args": [
            "uspi"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"ENTER, ino %lu, fragment %llu, goal %llu, count %u\\n\"",
            "inode->i_ino",
            "(unsigned long long)fragment",
            "(unsigned long long)goal",
            "count"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <asm/byteorder.h>\n#include <linux/bitops.h>\n#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\n#define INVBLOCK ((u64)-1L)\n\nstatic u64 ufs_add_fragments(struct inode *, u64, unsigned, unsigned);\nstatic u64 ufs_alloc_fragments(struct inode *, unsigned, u64, unsigned, int *);\nstatic u64 ufs_alloccg_block(struct inode *, struct ufs_cg_private_info *, u64, int *);\nstatic u64 ufs_bitmap_search (struct super_block *, struct ufs_cg_private_info *, u64, unsigned);\n\nu64 ufs_new_fragments(struct inode *inode, void *p, u64 fragment,\n\t\t\t   u64 goal, unsigned count, int *err,\n\t\t\t   struct page *locked_page)\n{\n\tstruct super_block * sb;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tunsigned cgno, oldcount, newcount;\n\tu64 tmp, request, result;\n\t\n\tUFSD(\"ENTER, ino %lu, fragment %llu, goal %llu, count %u\\n\",\n\t     inode->i_ino, (unsigned long long)fragment,\n\t     (unsigned long long)goal, count);\n\t\n\tsb = inode->i_sb;\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\t*err = -ENOSPC;\n\n\tlock_ufs(sb);\n\ttmp = ufs_data_ptr_to_cpu(sb, p);\n\n\tif (count + ufs_fragnum(fragment) > uspi->s_fpb) {\n\t\tufs_warning(sb, \"ufs_new_fragments\", \"internal warning\"\n\t\t\t    \" fragment %llu, count %u\",\n\t\t\t    (unsigned long long)fragment, count);\n\t\tcount = uspi->s_fpb - ufs_fragnum(fragment); \n\t}\n\toldcount = ufs_fragnum (fragment);\n\tnewcount = oldcount + count;\n\n\t/*\n\t * Somebody else has just allocated our fragments\n\t */\n\tif (oldcount) {\n\t\tif (!tmp) {\n\t\t\tufs_error(sb, \"ufs_new_fragments\", \"internal error, \"\n\t\t\t\t  \"fragment %llu, tmp %llu\\n\",\n\t\t\t\t  (unsigned long long)fragment,\n\t\t\t\t  (unsigned long long)tmp);\n\t\t\tunlock_ufs(sb);\n\t\t\treturn INVBLOCK;\n\t\t}\n\t\tif (fragment < UFS_I(inode)->i_lastfrag) {\n\t\t\tUFSD(\"EXIT (ALREADY ALLOCATED)\\n\");\n\t\t\tunlock_ufs(sb);\n\t\t\treturn 0;\n\t\t}\n\t}\n\telse {\n\t\tif (tmp) {\n\t\t\tUFSD(\"EXIT (ALREADY ALLOCATED)\\n\");\n\t\t\tunlock_ufs(sb);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * There is not enough space for user on the device\n\t */\n\tif (!capable(CAP_SYS_RESOURCE) && ufs_freespace(uspi, UFS_MINFREE) <= 0) {\n\t\tunlock_ufs(sb);\n\t\tUFSD(\"EXIT (FAILED)\\n\");\n\t\treturn 0;\n\t}\n\n\tif (goal >= uspi->s_size) \n\t\tgoal = 0;\n\tif (goal == 0) \n\t\tcgno = ufs_inotocg (inode->i_ino);\n\telse\n\t\tcgno = ufs_dtog(uspi, goal);\n\t \n\t/*\n\t * allocate new fragment\n\t */\n\tif (oldcount == 0) {\n\t\tresult = ufs_alloc_fragments (inode, cgno, goal, count, err);\n\t\tif (result) {\n\t\t\tufs_cpu_to_data_ptr(sb, p, result);\n\t\t\t*err = 0;\n\t\t\tUFS_I(inode)->i_lastfrag =\n\t\t\t\tmax(UFS_I(inode)->i_lastfrag, fragment + count);\n\t\t\tufs_clear_frags(inode, result + oldcount,\n\t\t\t\t\tnewcount - oldcount, locked_page != NULL);\n\t\t}\n\t\tunlock_ufs(sb);\n\t\tUFSD(\"EXIT, result %llu\\n\", (unsigned long long)result);\n\t\treturn result;\n\t}\n\n\t/*\n\t * resize block\n\t */\n\tresult = ufs_add_fragments(inode, tmp, oldcount, newcount);\n\tif (result) {\n\t\t*err = 0;\n\t\tUFS_I(inode)->i_lastfrag = max(UFS_I(inode)->i_lastfrag,\n\t\t\t\t\t\tfragment + count);\n\t\tufs_clear_frags(inode, result + oldcount, newcount - oldcount,\n\t\t\t\tlocked_page != NULL);\n\t\tunlock_ufs(sb);\n\t\tUFSD(\"EXIT, result %llu\\n\", (unsigned long long)result);\n\t\treturn result;\n\t}\n\n\t/*\n\t * allocate new block and move data\n\t */\n\tswitch (fs32_to_cpu(sb, usb1->fs_optim)) {\n\t    case UFS_OPTSPACE:\n\t\trequest = newcount;\n\t\tif (uspi->s_minfree < 5 || uspi->cs_total.cs_nffree\n\t\t    > uspi->s_dsize * uspi->s_minfree / (2 * 100))\n\t\t\tbreak;\n\t\tusb1->fs_optim = cpu_to_fs32(sb, UFS_OPTTIME);\n\t\tbreak;\n\t    default:\n\t\tusb1->fs_optim = cpu_to_fs32(sb, UFS_OPTTIME);\n\t\n\t    case UFS_OPTTIME:\n\t\trequest = uspi->s_fpb;\n\t\tif (uspi->cs_total.cs_nffree < uspi->s_dsize *\n\t\t    (uspi->s_minfree - 2) / 100)\n\t\t\tbreak;\n\t\tusb1->fs_optim = cpu_to_fs32(sb, UFS_OPTTIME);\n\t\tbreak;\n\t}\n\tresult = ufs_alloc_fragments (inode, cgno, goal, request, err);\n\tif (result) {\n\t\tufs_clear_frags(inode, result + oldcount, newcount - oldcount,\n\t\t\t\tlocked_page != NULL);\n\t\tufs_change_blocknr(inode, fragment - oldcount, oldcount,\n\t\t\t\t   uspi->s_sbbase + tmp,\n\t\t\t\t   uspi->s_sbbase + result, locked_page);\n\t\tufs_cpu_to_data_ptr(sb, p, result);\n\t\t*err = 0;\n\t\tUFS_I(inode)->i_lastfrag = max(UFS_I(inode)->i_lastfrag,\n\t\t\t\t\t\tfragment + count);\n\t\tunlock_ufs(sb);\n\t\tif (newcount < request)\n\t\t\tufs_free_fragments (inode, result + newcount, request - newcount);\n\t\tufs_free_fragments (inode, tmp, oldcount);\n\t\tUFSD(\"EXIT, result %llu\\n\", (unsigned long long)result);\n\t\treturn result;\n\t}\n\n\tunlock_ufs(sb);\n\tUFSD(\"EXIT (FAILED)\\n\");\n\treturn 0;\n}"
  },
  {
    "function_name": "ufs_clear_frags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/balloc.c",
    "lines": "322-339",
    "snippet": "static void ufs_clear_frags(struct inode *inode, sector_t beg, unsigned int n,\n\t\t\t    int sync)\n{\n\tstruct buffer_head *bh;\n\tsector_t end = beg + n;\n\n\tfor (; beg < end; ++beg) {\n\t\tbh = sb_getblk(inode->i_sb, beg);\n\t\tlock_buffer(bh);\n\t\tmemset(bh->b_data, 0, inode->i_sb->s_blocksize);\n\t\tset_buffer_uptodate(bh);\n\t\tmark_buffer_dirty(bh);\n\t\tunlock_buffer(bh);\n\t\tif (IS_SYNC(inode) || sync)\n\t\t\tsync_dirty_buffer(bh);\n\t\tbrelse(bh);\n\t}\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/bitops.h>",
      "#include <linux/capability.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "ubh_brelse_uspi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.c",
          "lines": "81-90",
          "snippet": "void ubh_brelse_uspi (struct ufs_sb_private_info * uspi)\n{\n\tunsigned i;\n\tif (!USPI_UBH(uspi))\n\t\treturn;\n\tfor ( i = 0; i < USPI_UBH(uspi)->count; i++ ) {\n\t\tbrelse (USPI_UBH(uspi)->bh[i]);\n\t\tUSPI_UBH(uspi)->bh[i] = NULL;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid ubh_brelse_uspi (struct ufs_sb_private_info * uspi)\n{\n\tunsigned i;\n\tif (!USPI_UBH(uspi))\n\t\treturn;\n\tfor ( i = 0; i < USPI_UBH(uspi)->count; i++ ) {\n\t\tbrelse (USPI_UBH(uspi)->bh[i]);\n\t\tUSPI_UBH(uspi)->bh[i] = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_dirty_buffer",
          "args": [
            "bh"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "sync_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3153-3156",
          "snippet": "int sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_SYNC",
          "args": [
            "inode"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_buffer",
          "args": [
            "bh"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "70-75",
          "snippet": "void unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unlock_buffer(struct buffer_head *bh)\n{\n\tclear_bit_unlock(BH_Lock, &bh->b_state);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&bh->b_state, BH_Lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "ubh_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.c",
          "lines": "92-99",
          "snippet": "void ubh_mark_buffer_dirty (struct ufs_buffer_head * ubh)\n{\n\tunsigned i;\n\tif (!ubh)\n\t\treturn;\n\tfor ( i = 0; i < ubh->count; i++ )\n\t\tmark_buffer_dirty (ubh->bh[i]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid ubh_mark_buffer_dirty (struct ufs_buffer_head * ubh)\n{\n\tunsigned i;\n\tif (!ubh)\n\t\treturn;\n\tfor ( i = 0; i < ubh->count; i++ )\n\t\tmark_buffer_dirty (ubh->bh[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bh->b_data",
            "0",
            "inode->i_sb->s_blocksize"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "inode->i_sb",
            "beg"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <asm/byteorder.h>\n#include <linux/bitops.h>\n#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nstatic void ufs_clear_frags(struct inode *inode, sector_t beg, unsigned int n,\n\t\t\t    int sync)\n{\n\tstruct buffer_head *bh;\n\tsector_t end = beg + n;\n\n\tfor (; beg < end; ++beg) {\n\t\tbh = sb_getblk(inode->i_sb, beg);\n\t\tlock_buffer(bh);\n\t\tmemset(bh->b_data, 0, inode->i_sb->s_blocksize);\n\t\tset_buffer_uptodate(bh);\n\t\tmark_buffer_dirty(bh);\n\t\tunlock_buffer(bh);\n\t\tif (IS_SYNC(inode) || sync)\n\t\t\tsync_dirty_buffer(bh);\n\t\tbrelse(bh);\n\t}\n}"
  },
  {
    "function_name": "ufs_change_blocknr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/balloc.c",
    "lines": "235-320",
    "snippet": "static void ufs_change_blocknr(struct inode *inode, sector_t beg,\n\t\t\t       unsigned int count, sector_t oldb,\n\t\t\t       sector_t newb, struct page *locked_page)\n{\n\tconst unsigned blks_per_page =\n\t\t1 << (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\tconst unsigned mask = blks_per_page - 1;\n\tstruct address_space * const mapping = inode->i_mapping;\n\tpgoff_t index, cur_index, last_index;\n\tunsigned pos, j, lblock;\n\tsector_t end, i;\n\tstruct page *page;\n\tstruct buffer_head *head, *bh;\n\n\tUFSD(\"ENTER, ino %lu, count %u, oldb %llu, newb %llu\\n\",\n\t      inode->i_ino, count,\n\t     (unsigned long long)oldb, (unsigned long long)newb);\n\n\tBUG_ON(!locked_page);\n\tBUG_ON(!PageLocked(locked_page));\n\n\tcur_index = locked_page->index;\n\tend = count + beg;\n\tlast_index = end >> (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\tfor (i = beg; i < end; i = (i | mask) + 1) {\n\t\tindex = i >> (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\n\t\tif (likely(cur_index != index)) {\n\t\t\tpage = ufs_get_locked_page(mapping, index);\n\t\t\tif (!page)/* it was truncated */\n\t\t\t\tcontinue;\n\t\t\tif (IS_ERR(page)) {/* or EIO */\n\t\t\t\tufs_error(inode->i_sb, __func__,\n\t\t\t\t\t  \"read of page %llu failed\\n\",\n\t\t\t\t\t  (unsigned long long)index);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else\n\t\t\tpage = locked_page;\n\n\t\thead = page_buffers(page);\n\t\tbh = head;\n\t\tpos = i & mask;\n\t\tfor (j = 0; j < pos; ++j)\n\t\t\tbh = bh->b_this_page;\n\n\n\t\tif (unlikely(index == last_index))\n\t\t\tlblock = end & mask;\n\t\telse\n\t\t\tlblock = blks_per_page;\n\n\t\tdo {\n\t\t\tif (j >= lblock)\n\t\t\t\tbreak;\n\t\t\tpos = (i - beg) + j;\n\n\t\t\tif (!buffer_mapped(bh))\n\t\t\t\t\tmap_bh(bh, inode->i_sb, oldb + pos);\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tll_rw_block(READ, 1, &bh);\n\t\t\t\twait_on_buffer(bh);\n\t\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\t\tufs_error(inode->i_sb, __func__,\n\t\t\t\t\t\t  \"read of block failed\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tUFSD(\" change from %llu to %llu, pos %u\\n\",\n\t\t\t     (unsigned long long)(pos + oldb),\n\t\t\t     (unsigned long long)(pos + newb), pos);\n\n\t\t\tbh->b_blocknr = newb + pos;\n\t\t\tunmap_underlying_metadata(bh->b_bdev,\n\t\t\t\t\t\t  bh->b_blocknr);\n\t\t\tmark_buffer_dirty(bh);\n\t\t\t++j;\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\n\t\tif (likely(cur_index != index))\n\t\t\tufs_put_locked_page(page);\n \t}\n\tUFSD(\"EXIT\\n\");\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/bitops.h>",
      "#include <linux/capability.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"EXIT\\n\""
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_put_locked_page",
          "args": [
            "page"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_put_locked_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "283-287",
          "snippet": "static inline void ufs_put_locked_page(struct page *page)\n{\n       unlock_page(page);\n       page_cache_release(page);\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic inline void ufs_put_locked_page(struct page *page)\n{\n       unlock_page(page);\n       page_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "cur_index != index"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "ubh_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.c",
          "lines": "92-99",
          "snippet": "void ubh_mark_buffer_dirty (struct ufs_buffer_head * ubh)\n{\n\tunsigned i;\n\tif (!ubh)\n\t\treturn;\n\tfor ( i = 0; i < ubh->count; i++ )\n\t\tmark_buffer_dirty (ubh->bh[i]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid ubh_mark_buffer_dirty (struct ufs_buffer_head * ubh)\n{\n\tunsigned i;\n\tif (!ubh)\n\t\treturn;\n\tfor ( i = 0; i < ubh->count; i++ )\n\t\tmark_buffer_dirty (ubh->bh[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unmap_underlying_metadata",
          "args": [
            "bh->b_bdev",
            "bh->b_blocknr"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "unmap_underlying_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1610-1623",
          "snippet": "void unmap_underlying_metadata(struct block_device *bdev, sector_t block)\n{\n\tstruct buffer_head *old_bh;\n\n\tmight_sleep();\n\n\told_bh = __find_get_block_slow(bdev, block);\n\tif (old_bh) {\n\t\tclear_buffer_dirty(old_bh);\n\t\twait_on_buffer(old_bh);\n\t\tclear_buffer_req(old_bh);\n\t\t__brelse(old_bh);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid unmap_underlying_metadata(struct block_device *bdev, sector_t block)\n{\n\tstruct buffer_head *old_bh;\n\n\tmight_sleep();\n\n\told_bh = __find_get_block_slow(bdev, block);\n\tif (old_bh) {\n\t\tclear_buffer_dirty(old_bh);\n\t\twait_on_buffer(old_bh);\n\t\tclear_buffer_req(old_bh);\n\t\t__brelse(old_bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\" change from %llu to %llu, pos %u\\n\"",
            "(unsigned long long)(pos + oldb)",
            "(unsigned long long)(pos + newb)",
            "pos"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_error",
          "args": [
            "inode->i_sb",
            "__func__",
            "\"read of block failed\\n\""
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "285-317",
          "snippet": "void ufs_error (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct va_format vaf;\n\tva_list args;\n\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\t\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tusb1->fs_clean = UFS_FSBAD;\n\t\tubh_mark_buffer_dirty(USPI_UBH(uspi));\n\t\tufs_mark_sb_dirty(sb);\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tswitch (UFS_SB(sb)->s_mount_opt & UFS_MOUNT_ONERROR) {\n\tcase UFS_MOUNT_ONERROR_PANIC:\n\t\tpanic(\"panic (device %s): %s: %pV\\n\",\n\t\t      sb->s_id, function, &vaf);\n\n\tcase UFS_MOUNT_ONERROR_LOCK:\n\tcase UFS_MOUNT_ONERROR_UMOUNT:\n\tcase UFS_MOUNT_ONERROR_REPAIR:\n\t\tpr_crit(\"error (device %s): %s: %pV\\n\",\n\t\t\tsb->s_id, function, &vaf);\n\t}\n\tva_end(args);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid ufs_error (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct va_format vaf;\n\tva_list args;\n\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\t\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tusb1->fs_clean = UFS_FSBAD;\n\t\tubh_mark_buffer_dirty(USPI_UBH(uspi));\n\t\tufs_mark_sb_dirty(sb);\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tswitch (UFS_SB(sb)->s_mount_opt & UFS_MOUNT_ONERROR) {\n\tcase UFS_MOUNT_ONERROR_PANIC:\n\t\tpanic(\"panic (device %s): %s: %pV\\n\",\n\t\t      sb->s_id, function, &vaf);\n\n\tcase UFS_MOUNT_ONERROR_LOCK:\n\tcase UFS_MOUNT_ONERROR_UMOUNT:\n\tcase UFS_MOUNT_ONERROR_REPAIR:\n\t\tpr_crit(\"error (device %s): %s: %pV\\n\",\n\t\t\tsb->s_id, function, &vaf);\n\t}\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_buffer",
          "args": [
            "bh"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "__wait_on_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "117-120",
          "snippet": "void __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __wait_on_buffer(struct buffer_head * bh)\n{\n\twait_on_bit_io(&bh->b_state, BH_Lock, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ll_rw_block",
          "args": [
            "READ",
            "1",
            "&bh"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "ll_rw_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3086-3112",
          "snippet": "void ll_rw_block(int rw, int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (rw == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(WRITE, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(rw, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid ll_rw_block(int rw, int nr, struct buffer_head *bhs[])\n{\n\tint i;\n\n\tfor (i = 0; i < nr; i++) {\n\t\tstruct buffer_head *bh = bhs[i];\n\n\t\tif (!trylock_buffer(bh))\n\t\t\tcontinue;\n\t\tif (rw == WRITE) {\n\t\t\tif (test_clear_buffer_dirty(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_write_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(WRITE, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\t\tget_bh(bh);\n\t\t\t\tsubmit_bh(rw, bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tunlock_buffer(bh);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_bh",
          "args": [
            "bh",
            "inode->i_sb",
            "oldb + pos"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "index == last_index"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_get_locked_page",
          "args": [
            "mapping",
            "index"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_get_locked_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.c",
          "lines": "243-282",
          "snippet": "struct page *ufs_get_locked_page(struct address_space *mapping,\n\t\t\t\t pgoff_t index)\n{\n\tstruct page *page;\n\n\tpage = find_lock_page(mapping, index);\n\tif (!page) {\n\t\tpage = read_mapping_page(mapping, index, NULL);\n\n\t\tif (IS_ERR(page)) {\n\t\t\tprintk(KERN_ERR \"ufs_change_blocknr: \"\n\t\t\t       \"read_mapping_page error: ino %lu, index: %lu\\n\",\n\t\t\t       mapping->host->i_ino, index);\n\t\t\tgoto out;\n\t\t}\n\n\t\tlock_page(page);\n\n\t\tif (unlikely(page->mapping == NULL)) {\n\t\t\t/* Truncate got there first */\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\tpage = NULL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!PageUptodate(page) || PageError(page)) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\n\t\t\tprintk(KERN_ERR \"ufs_change_blocknr: \"\n\t\t\t       \"can not read page: ino %lu, index: %lu\\n\",\n\t\t\t       mapping->host->i_ino, index);\n\n\t\t\tpage = ERR_PTR(-EIO);\n\t\t}\n\t}\nout:\n\treturn page;\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nstruct page *ufs_get_locked_page(struct address_space *mapping,\n\t\t\t\t pgoff_t index)\n{\n\tstruct page *page;\n\n\tpage = find_lock_page(mapping, index);\n\tif (!page) {\n\t\tpage = read_mapping_page(mapping, index, NULL);\n\n\t\tif (IS_ERR(page)) {\n\t\t\tprintk(KERN_ERR \"ufs_change_blocknr: \"\n\t\t\t       \"read_mapping_page error: ino %lu, index: %lu\\n\",\n\t\t\t       mapping->host->i_ino, index);\n\t\t\tgoto out;\n\t\t}\n\n\t\tlock_page(page);\n\n\t\tif (unlikely(page->mapping == NULL)) {\n\t\t\t/* Truncate got there first */\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\t\t\tpage = NULL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!PageUptodate(page) || PageError(page)) {\n\t\t\tunlock_page(page);\n\t\t\tpage_cache_release(page);\n\n\t\t\tprintk(KERN_ERR \"ufs_change_blocknr: \"\n\t\t\t       \"can not read page: ino %lu, index: %lu\\n\",\n\t\t\t       mapping->host->i_ino, index);\n\n\t\t\tpage = ERR_PTR(-EIO);\n\t\t}\n\t}\nout:\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "cur_index != index"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!PageLocked(locked_page)"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageLocked",
          "args": [
            "locked_page"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!locked_page"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"ENTER, ino %lu, count %u, oldb %llu, newb %llu\\n\"",
            "inode->i_ino",
            "count",
            "(unsigned long long)oldb",
            "(unsigned long long)newb"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <asm/byteorder.h>\n#include <linux/bitops.h>\n#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nstatic void ufs_change_blocknr(struct inode *inode, sector_t beg,\n\t\t\t       unsigned int count, sector_t oldb,\n\t\t\t       sector_t newb, struct page *locked_page)\n{\n\tconst unsigned blks_per_page =\n\t\t1 << (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\tconst unsigned mask = blks_per_page - 1;\n\tstruct address_space * const mapping = inode->i_mapping;\n\tpgoff_t index, cur_index, last_index;\n\tunsigned pos, j, lblock;\n\tsector_t end, i;\n\tstruct page *page;\n\tstruct buffer_head *head, *bh;\n\n\tUFSD(\"ENTER, ino %lu, count %u, oldb %llu, newb %llu\\n\",\n\t      inode->i_ino, count,\n\t     (unsigned long long)oldb, (unsigned long long)newb);\n\n\tBUG_ON(!locked_page);\n\tBUG_ON(!PageLocked(locked_page));\n\n\tcur_index = locked_page->index;\n\tend = count + beg;\n\tlast_index = end >> (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\tfor (i = beg; i < end; i = (i | mask) + 1) {\n\t\tindex = i >> (PAGE_CACHE_SHIFT - inode->i_blkbits);\n\n\t\tif (likely(cur_index != index)) {\n\t\t\tpage = ufs_get_locked_page(mapping, index);\n\t\t\tif (!page)/* it was truncated */\n\t\t\t\tcontinue;\n\t\t\tif (IS_ERR(page)) {/* or EIO */\n\t\t\t\tufs_error(inode->i_sb, __func__,\n\t\t\t\t\t  \"read of page %llu failed\\n\",\n\t\t\t\t\t  (unsigned long long)index);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else\n\t\t\tpage = locked_page;\n\n\t\thead = page_buffers(page);\n\t\tbh = head;\n\t\tpos = i & mask;\n\t\tfor (j = 0; j < pos; ++j)\n\t\t\tbh = bh->b_this_page;\n\n\n\t\tif (unlikely(index == last_index))\n\t\t\tlblock = end & mask;\n\t\telse\n\t\t\tlblock = blks_per_page;\n\n\t\tdo {\n\t\t\tif (j >= lblock)\n\t\t\t\tbreak;\n\t\t\tpos = (i - beg) + j;\n\n\t\t\tif (!buffer_mapped(bh))\n\t\t\t\t\tmap_bh(bh, inode->i_sb, oldb + pos);\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\tll_rw_block(READ, 1, &bh);\n\t\t\t\twait_on_buffer(bh);\n\t\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\t\tufs_error(inode->i_sb, __func__,\n\t\t\t\t\t\t  \"read of block failed\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tUFSD(\" change from %llu to %llu, pos %u\\n\",\n\t\t\t     (unsigned long long)(pos + oldb),\n\t\t\t     (unsigned long long)(pos + newb), pos);\n\n\t\t\tbh->b_blocknr = newb + pos;\n\t\t\tunmap_underlying_metadata(bh->b_bdev,\n\t\t\t\t\t\t  bh->b_blocknr);\n\t\t\tmark_buffer_dirty(bh);\n\t\t\t++j;\n\t\t\tbh = bh->b_this_page;\n\t\t} while (bh != head);\n\n\t\tif (likely(cur_index != index))\n\t\t\tufs_put_locked_page(page);\n \t}\n\tUFSD(\"EXIT\\n\");\n}"
  },
  {
    "function_name": "ufs_free_blocks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/balloc.c",
    "lines": "132-223",
    "snippet": "void ufs_free_blocks(struct inode *inode, u64 fragment, unsigned count)\n{\n\tstruct super_block * sb;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cg_private_info * ucpi;\n\tstruct ufs_cylinder_group * ucg;\n\tunsigned overflow, cgno, bit, end_bit, i;\n\tu64 blkno;\n\t\n\tsb = inode->i_sb;\n\tuspi = UFS_SB(sb)->s_uspi;\n\n\tUFSD(\"ENTER, fragment %llu, count %u\\n\",\n\t     (unsigned long long)fragment, count);\n\t\n\tif ((fragment & uspi->s_fpbmask) || (count & uspi->s_fpbmask)) {\n\t\tufs_error (sb, \"ufs_free_blocks\", \"internal error, \"\n\t\t\t   \"fragment %llu, count %u\\n\",\n\t\t\t   (unsigned long long)fragment, count);\n\t\tgoto failed;\n\t}\n\n\tlock_ufs(sb);\n\t\ndo_more:\n\toverflow = 0;\n\tcgno = ufs_dtog(uspi, fragment);\n\tbit = ufs_dtogd(uspi, fragment);\n\tif (cgno >= uspi->s_ncg) {\n\t\tufs_panic (sb, \"ufs_free_blocks\", \"freeing blocks are outside device\");\n\t\tgoto failed_unlock;\n\t}\n\tend_bit = bit + count;\n\tif (end_bit > uspi->s_fpg) {\n\t\toverflow = bit + count - uspi->s_fpg;\n\t\tcount -= overflow;\n\t\tend_bit -= overflow;\n\t}\n\n\tucpi = ufs_load_cylinder (sb, cgno);\n\tif (!ucpi) \n\t\tgoto failed_unlock;\n\tucg = ubh_get_ucg (UCPI_UBH(ucpi));\n\tif (!ufs_cg_chkmagic(sb, ucg)) {\n\t\tufs_panic (sb, \"ufs_free_blocks\", \"internal error, bad magic number on cg %u\", cgno);\n\t\tgoto failed_unlock;\n\t}\n\n\tfor (i = bit; i < end_bit; i += uspi->s_fpb) {\n\t\tblkno = ufs_fragstoblks(i);\n\t\tif (ubh_isblockset(UCPI_UBH(ucpi), ucpi->c_freeoff, blkno)) {\n\t\t\tufs_error(sb, \"ufs_free_blocks\", \"freeing free fragment\");\n\t\t}\n\t\tubh_setblock(UCPI_UBH(ucpi), ucpi->c_freeoff, blkno);\n\t\tif ((UFS_SB(sb)->s_flags & UFS_CG_MASK) == UFS_CG_44BSD)\n\t\t\tufs_clusteracct (sb, ucpi, blkno, 1);\n\n\t\tfs32_add(sb, &ucg->cg_cs.cs_nbfree, 1);\n\t\tuspi->cs_total.cs_nbfree++;\n\t\tfs32_add(sb, &UFS_SB(sb)->fs_cs(cgno).cs_nbfree, 1);\n\n\t\tif (uspi->fs_magic != UFS2_MAGIC) {\n\t\t\tunsigned cylno = ufs_cbtocylno(i);\n\n\t\t\tfs16_add(sb, &ubh_cg_blks(ucpi, cylno,\n\t\t\t\t\t\t  ufs_cbtorpos(i)), 1);\n\t\t\tfs32_add(sb, &ubh_cg_blktot(ucpi, cylno), 1);\n\t\t}\n\t}\n\n\tubh_mark_buffer_dirty (USPI_UBH(uspi));\n\tubh_mark_buffer_dirty (UCPI_UBH(ucpi));\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tubh_sync_block(UCPI_UBH(ucpi));\n\n\tif (overflow) {\n\t\tfragment += count;\n\t\tcount = overflow;\n\t\tgoto do_more;\n\t}\n\n\tufs_mark_sb_dirty(sb);\n\tunlock_ufs(sb);\n\tUFSD(\"EXIT\\n\");\n\treturn;\n\nfailed_unlock:\n\tunlock_ufs(sb);\nfailed:\n\tUFSD(\"EXIT (FAILED)\\n\");\n\treturn;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/bitops.h>",
      "#include <linux/capability.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ufs_add_fragments(struct inode *, u64, unsigned, unsigned);",
      "static u64 ufs_alloc_fragments(struct inode *, unsigned, u64, unsigned, int *);",
      "static u64 ufs_alloccg_block(struct inode *, struct ufs_cg_private_info *, u64, int *);",
      "static u64 ufs_bitmap_search (struct super_block *, struct ufs_cg_private_info *, u64, unsigned);",
      "static void ufs_clusteracct(struct super_block *, struct ufs_cg_private_info *, unsigned, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"EXIT (FAILED)\\n\""
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_ufs",
          "args": [
            "sb"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_ufs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "104-110",
          "snippet": "void unlock_ufs(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\n\tsbi->mutex_owner = NULL;\n\tmutex_unlock(&sbi->mutex);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid unlock_ufs(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\n\tsbi->mutex_owner = NULL;\n\tmutex_unlock(&sbi->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"EXIT\\n\""
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_mark_sb_dirty",
          "args": [
            "sb"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_mark_sb_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "732-744",
          "snippet": "void ufs_mark_sb_dirty(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\tunsigned long delay;\n\n\tspin_lock(&sbi->work_lock);\n\tif (!sbi->work_queued) {\n\t\tdelay = msecs_to_jiffies(dirty_writeback_interval * 10);\n\t\tqueue_delayed_work(system_long_wq, &sbi->sync_work, delay);\n\t\tsbi->work_queued = 1;\n\t}\n\tspin_unlock(&sbi->work_lock);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid ufs_mark_sb_dirty(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\tunsigned long delay;\n\n\tspin_lock(&sbi->work_lock);\n\tif (!sbi->work_queued) {\n\t\tdelay = msecs_to_jiffies(dirty_writeback_interval * 10);\n\t\tqueue_delayed_work(system_long_wq, &sbi->sync_work, delay);\n\t\tsbi->work_queued = 1;\n\t}\n\tspin_unlock(&sbi->work_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubh_sync_block",
          "args": [
            "UCPI_UBH(ucpi)"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "ubh_sync_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.c",
          "lines": "115-126",
          "snippet": "void ubh_sync_block(struct ufs_buffer_head *ubh)\n{\n\tif (ubh) {\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < ubh->count; i++)\n\t\t\twrite_dirty_buffer(ubh->bh[i], WRITE);\n\n\t\tfor (i = 0; i < ubh->count; i++)\n\t\t\twait_on_buffer(ubh->bh[i]);\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid ubh_sync_block(struct ufs_buffer_head *ubh)\n{\n\tif (ubh) {\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < ubh->count; i++)\n\t\t\twrite_dirty_buffer(ubh->bh[i], WRITE);\n\n\t\tfor (i = 0; i < ubh->count; i++)\n\t\t\twait_on_buffer(ubh->bh[i]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "UCPI_UBH",
          "args": [
            "ucpi"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "UCPI_UBH",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "22-25",
          "snippet": "static inline struct ufs_buffer_head *UCPI_UBH(struct ufs_cg_private_info *cpi)\n{\n\treturn &cpi->c_ubh;\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ubh_brelse (struct ufs_buffer_head *);",
            "extern void ubh_mark_buffer_dirty (struct ufs_buffer_head *);",
            "extern void ubh_mark_buffer_uptodate (struct ufs_buffer_head *, int);",
            "extern void ubh_sync_block(struct ufs_buffer_head *);",
            "extern void ubh_bforget (struct ufs_buffer_head *);",
            "extern int  ubh_buffer_dirty (struct ufs_buffer_head *);",
            "extern void _ubh_ubhcpymem_(struct ufs_sb_private_info *, unsigned char *, struct ufs_buffer_head *, unsigned);",
            "extern void _ubh_memcpyubh_(struct ufs_sb_private_info *, struct ufs_buffer_head *, unsigned char *, unsigned);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nextern void ubh_brelse (struct ufs_buffer_head *);\nextern void ubh_mark_buffer_dirty (struct ufs_buffer_head *);\nextern void ubh_mark_buffer_uptodate (struct ufs_buffer_head *, int);\nextern void ubh_sync_block(struct ufs_buffer_head *);\nextern void ubh_bforget (struct ufs_buffer_head *);\nextern int  ubh_buffer_dirty (struct ufs_buffer_head *);\nextern void _ubh_ubhcpymem_(struct ufs_sb_private_info *, unsigned char *, struct ufs_buffer_head *, unsigned);\nextern void _ubh_memcpyubh_(struct ufs_sb_private_info *, struct ufs_buffer_head *, unsigned char *, unsigned);\n\nstatic inline struct ufs_buffer_head *UCPI_UBH(struct ufs_cg_private_info *cpi)\n{\n\treturn &cpi->c_ubh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubh_mark_buffer_dirty",
          "args": [
            "UCPI_UBH(ucpi)"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "ubh_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.c",
          "lines": "92-99",
          "snippet": "void ubh_mark_buffer_dirty (struct ufs_buffer_head * ubh)\n{\n\tunsigned i;\n\tif (!ubh)\n\t\treturn;\n\tfor ( i = 0; i < ubh->count; i++ )\n\t\tmark_buffer_dirty (ubh->bh[i]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid ubh_mark_buffer_dirty (struct ufs_buffer_head * ubh)\n{\n\tunsigned i;\n\tif (!ubh)\n\t\treturn;\n\tfor ( i = 0; i < ubh->count; i++ )\n\t\tmark_buffer_dirty (ubh->bh[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "USPI_UBH",
          "args": [
            "uspi"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "USPI_UBH",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "26-29",
          "snippet": "static inline struct ufs_buffer_head *USPI_UBH(struct ufs_sb_private_info *spi)\n{\n\treturn &spi->s_ubh;\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ubh_brelse (struct ufs_buffer_head *);",
            "extern void ubh_brelse_uspi (struct ufs_sb_private_info *);",
            "extern void ubh_mark_buffer_dirty (struct ufs_buffer_head *);",
            "extern void ubh_mark_buffer_uptodate (struct ufs_buffer_head *, int);",
            "extern void ubh_sync_block(struct ufs_buffer_head *);",
            "extern void ubh_bforget (struct ufs_buffer_head *);",
            "extern int  ubh_buffer_dirty (struct ufs_buffer_head *);",
            "extern void _ubh_ubhcpymem_(struct ufs_sb_private_info *, unsigned char *, struct ufs_buffer_head *, unsigned);",
            "extern void _ubh_memcpyubh_(struct ufs_sb_private_info *, struct ufs_buffer_head *, unsigned char *, unsigned);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nextern void ubh_brelse (struct ufs_buffer_head *);\nextern void ubh_brelse_uspi (struct ufs_sb_private_info *);\nextern void ubh_mark_buffer_dirty (struct ufs_buffer_head *);\nextern void ubh_mark_buffer_uptodate (struct ufs_buffer_head *, int);\nextern void ubh_sync_block(struct ufs_buffer_head *);\nextern void ubh_bforget (struct ufs_buffer_head *);\nextern int  ubh_buffer_dirty (struct ufs_buffer_head *);\nextern void _ubh_ubhcpymem_(struct ufs_sb_private_info *, unsigned char *, struct ufs_buffer_head *, unsigned);\nextern void _ubh_memcpyubh_(struct ufs_sb_private_info *, struct ufs_buffer_head *, unsigned char *, unsigned);\n\nstatic inline struct ufs_buffer_head *USPI_UBH(struct ufs_sb_private_info *spi)\n{\n\treturn &spi->s_ubh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs32_add",
          "args": [
            "sb",
            "&ubh_cg_blktot(ucpi, cylno)",
            "1"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "fs32_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "61-68",
          "snippet": "static inline void\nfs32_add(struct super_block *sbp, __fs32 *n, int d)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\tle32_add_cpu((__le32 *)n, d);\n\telse\n\t\tbe32_add_cpu((__be32 *)n, d);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nfs32_add(struct super_block *sbp, __fs32 *n, int d)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\tle32_add_cpu((__le32 *)n, d);\n\telse\n\t\tbe32_add_cpu((__be32 *)n, d);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubh_cg_blktot",
          "args": [
            "ucpi",
            "cylno"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs16_add",
          "args": [
            "sb",
            "&ubh_cg_blks(ucpi, cylno,\n\t\t\t\t\t\t  ufs_cbtorpos(i))",
            "1"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "fs16_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "97-104",
          "snippet": "static inline void\nfs16_add(struct super_block *sbp, __fs16 *n, int d)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\tle16_add_cpu((__le16 *)n, d);\n\telse\n\t\tbe16_add_cpu((__be16 *)n, d);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nfs16_add(struct super_block *sbp, __fs16 *n, int d)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\tle16_add_cpu((__le16 *)n, d);\n\telse\n\t\tbe16_add_cpu((__be16 *)n, d);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubh_cg_blks",
          "args": [
            "ucpi",
            "cylno",
            "ufs_cbtorpos(i)"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_cbtorpos",
          "args": [
            "i"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_cbtocylno",
          "args": [
            "i"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "cgno"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_clusteracct",
          "args": [
            "sb",
            "ucpi",
            "blkno",
            "1"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_clusteracct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/balloc.c",
          "lines": "848-899",
          "snippet": "static void ufs_clusteracct(struct super_block * sb,\n\tstruct ufs_cg_private_info * ucpi, unsigned blkno, int cnt)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tint i, start, end, forw, back;\n\t\n\tuspi = UFS_SB(sb)->s_uspi;\n\tif (uspi->s_contigsumsize <= 0)\n\t\treturn;\n\n\tif (cnt > 0)\n\t\tubh_setbit(UCPI_UBH(ucpi), ucpi->c_clusteroff, blkno);\n\telse\n\t\tubh_clrbit(UCPI_UBH(ucpi), ucpi->c_clusteroff, blkno);\n\n\t/*\n\t * Find the size of the cluster going forward.\n\t */\n\tstart = blkno + 1;\n\tend = start + uspi->s_contigsumsize;\n\tif ( end >= ucpi->c_nclusterblks)\n\t\tend = ucpi->c_nclusterblks;\n\ti = ubh_find_next_zero_bit (UCPI_UBH(ucpi), ucpi->c_clusteroff, end, start);\n\tif (i > end)\n\t\ti = end;\n\tforw = i - start;\n\t\n\t/*\n\t * Find the size of the cluster going backward.\n\t */\n\tstart = blkno - 1;\n\tend = start - uspi->s_contigsumsize;\n\tif (end < 0 ) \n\t\tend = -1;\n\ti = ubh_find_last_zero_bit (UCPI_UBH(ucpi), ucpi->c_clusteroff, start, end);\n\tif ( i < end) \n\t\ti = end;\n\tback = start - i;\n\t\n\t/*\n\t * Account for old cluster and the possibly new forward and\n\t * back clusters.\n\t */\n\ti = back + forw + 1;\n\tif (i > uspi->s_contigsumsize)\n\t\ti = uspi->s_contigsumsize;\n\tfs32_add(sb, (__fs32*)ubh_get_addr(UCPI_UBH(ucpi), ucpi->c_clustersumoff + (i << 2)), cnt);\n\tif (back > 0)\n\t\tfs32_sub(sb, (__fs32*)ubh_get_addr(UCPI_UBH(ucpi), ucpi->c_clustersumoff + (back << 2)), cnt);\n\tif (forw > 0)\n\t\tfs32_sub(sb, (__fs32*)ubh_get_addr(UCPI_UBH(ucpi), ucpi->c_clustersumoff + (forw << 2)), cnt);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/bitops.h>",
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ufs_clusteracct(struct super_block *, struct ufs_cg_private_info *, unsigned, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <asm/byteorder.h>\n#include <linux/bitops.h>\n#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nstatic void ufs_clusteracct(struct super_block *, struct ufs_cg_private_info *, unsigned, int);\n\nstatic void ufs_clusteracct(struct super_block * sb,\n\tstruct ufs_cg_private_info * ucpi, unsigned blkno, int cnt)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tint i, start, end, forw, back;\n\t\n\tuspi = UFS_SB(sb)->s_uspi;\n\tif (uspi->s_contigsumsize <= 0)\n\t\treturn;\n\n\tif (cnt > 0)\n\t\tubh_setbit(UCPI_UBH(ucpi), ucpi->c_clusteroff, blkno);\n\telse\n\t\tubh_clrbit(UCPI_UBH(ucpi), ucpi->c_clusteroff, blkno);\n\n\t/*\n\t * Find the size of the cluster going forward.\n\t */\n\tstart = blkno + 1;\n\tend = start + uspi->s_contigsumsize;\n\tif ( end >= ucpi->c_nclusterblks)\n\t\tend = ucpi->c_nclusterblks;\n\ti = ubh_find_next_zero_bit (UCPI_UBH(ucpi), ucpi->c_clusteroff, end, start);\n\tif (i > end)\n\t\ti = end;\n\tforw = i - start;\n\t\n\t/*\n\t * Find the size of the cluster going backward.\n\t */\n\tstart = blkno - 1;\n\tend = start - uspi->s_contigsumsize;\n\tif (end < 0 ) \n\t\tend = -1;\n\ti = ubh_find_last_zero_bit (UCPI_UBH(ucpi), ucpi->c_clusteroff, start, end);\n\tif ( i < end) \n\t\ti = end;\n\tback = start - i;\n\t\n\t/*\n\t * Account for old cluster and the possibly new forward and\n\t * back clusters.\n\t */\n\ti = back + forw + 1;\n\tif (i > uspi->s_contigsumsize)\n\t\ti = uspi->s_contigsumsize;\n\tfs32_add(sb, (__fs32*)ubh_get_addr(UCPI_UBH(ucpi), ucpi->c_clustersumoff + (i << 2)), cnt);\n\tif (back > 0)\n\t\tfs32_sub(sb, (__fs32*)ubh_get_addr(UCPI_UBH(ucpi), ucpi->c_clustersumoff + (back << 2)), cnt);\n\tif (forw > 0)\n\t\tfs32_sub(sb, (__fs32*)ubh_get_addr(UCPI_UBH(ucpi), ucpi->c_clustersumoff + (forw << 2)), cnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubh_setblock",
          "args": [
            "UCPI_UBH(ucpi)",
            "ucpi->c_freeoff",
            "blkno"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_error",
          "args": [
            "sb",
            "\"ufs_free_blocks\"",
            "\"freeing free fragment\""
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "285-317",
          "snippet": "void ufs_error (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct va_format vaf;\n\tva_list args;\n\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\t\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tusb1->fs_clean = UFS_FSBAD;\n\t\tubh_mark_buffer_dirty(USPI_UBH(uspi));\n\t\tufs_mark_sb_dirty(sb);\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tswitch (UFS_SB(sb)->s_mount_opt & UFS_MOUNT_ONERROR) {\n\tcase UFS_MOUNT_ONERROR_PANIC:\n\t\tpanic(\"panic (device %s): %s: %pV\\n\",\n\t\t      sb->s_id, function, &vaf);\n\n\tcase UFS_MOUNT_ONERROR_LOCK:\n\tcase UFS_MOUNT_ONERROR_UMOUNT:\n\tcase UFS_MOUNT_ONERROR_REPAIR:\n\t\tpr_crit(\"error (device %s): %s: %pV\\n\",\n\t\t\tsb->s_id, function, &vaf);\n\t}\n\tva_end(args);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid ufs_error (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct va_format vaf;\n\tva_list args;\n\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\t\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tusb1->fs_clean = UFS_FSBAD;\n\t\tubh_mark_buffer_dirty(USPI_UBH(uspi));\n\t\tufs_mark_sb_dirty(sb);\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tswitch (UFS_SB(sb)->s_mount_opt & UFS_MOUNT_ONERROR) {\n\tcase UFS_MOUNT_ONERROR_PANIC:\n\t\tpanic(\"panic (device %s): %s: %pV\\n\",\n\t\t      sb->s_id, function, &vaf);\n\n\tcase UFS_MOUNT_ONERROR_LOCK:\n\tcase UFS_MOUNT_ONERROR_UMOUNT:\n\tcase UFS_MOUNT_ONERROR_REPAIR:\n\t\tpr_crit(\"error (device %s): %s: %pV\\n\",\n\t\t\tsb->s_id, function, &vaf);\n\t}\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubh_isblockset",
          "args": [
            "UCPI_UBH(ucpi)",
            "ucpi->c_freeoff",
            "blkno"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_fragstoblks",
          "args": [
            "i"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_panic",
          "args": [
            "sb",
            "\"ufs_free_blocks\"",
            "\"internal error, bad magic number on cg %u\"",
            "cgno"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "319-342",
          "snippet": "void ufs_panic (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct va_format vaf;\n\tva_list args;\n\t\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\t\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tusb1->fs_clean = UFS_FSBAD;\n\t\tubh_mark_buffer_dirty(USPI_UBH(uspi));\n\t\tufs_mark_sb_dirty(sb);\n\t}\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tsb->s_flags |= MS_RDONLY;\n\tpr_crit(\"panic (device %s): %s: %pV\\n\",\n\t\tsb->s_id, function, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid ufs_panic (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct va_format vaf;\n\tva_list args;\n\t\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\t\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tusb1->fs_clean = UFS_FSBAD;\n\t\tubh_mark_buffer_dirty(USPI_UBH(uspi));\n\t\tufs_mark_sb_dirty(sb);\n\t}\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tsb->s_flags |= MS_RDONLY;\n\tpr_crit(\"panic (device %s): %s: %pV\\n\",\n\t\tsb->s_id, function, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_cg_chkmagic",
          "args": [
            "sb",
            "ucg"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubh_get_ucg",
          "args": [
            "UCPI_UBH(ucpi)"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_load_cylinder",
          "args": [
            "sb",
            "cgno"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_load_cylinder",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/cylinder.c",
          "lines": "126-201",
          "snippet": "struct ufs_cg_private_info * ufs_load_cylinder (\n\tstruct super_block * sb, unsigned cgno)\n{\n\tstruct ufs_sb_info * sbi = UFS_SB(sb);\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cg_private_info * ucpi;\n\tunsigned cg, i, j;\n\n\tUFSD(\"ENTER, cgno %u\\n\", cgno);\n\n\tuspi = sbi->s_uspi;\n\tif (cgno >= uspi->s_ncg) {\n\t\tufs_panic (sb, \"ufs_load_cylinder\", \"internal error, high number of cg\");\n\t\treturn NULL;\n\t}\n\t/*\n\t * Cylinder group number cg it in cache and it was last used\n\t */\n\tif (sbi->s_cgno[0] == cgno) {\n\t\tUFSD(\"EXIT\\n\");\n\t\treturn sbi->s_ucpi[0];\n\t}\n\t/*\n\t * Number of cylinder groups is not higher than UFS_MAX_GROUP_LOADED\n\t */\n\tif (uspi->s_ncg <= UFS_MAX_GROUP_LOADED) {\n\t\tif (sbi->s_cgno[cgno] != UFS_CGNO_EMPTY) {\n\t\t\tif (sbi->s_cgno[cgno] != cgno) {\n\t\t\t\tufs_panic (sb, \"ufs_load_cylinder\", \"internal error, wrong number of cg in cache\");\n\t\t\t\tUFSD(\"EXIT (FAILED)\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tUFSD(\"EXIT\\n\");\n\t\t\t\treturn sbi->s_ucpi[cgno];\n\t\t\t}\n\t\t} else {\n\t\t\tufs_read_cylinder (sb, cgno, cgno);\n\t\t\tUFSD(\"EXIT\\n\");\n\t\t\treturn sbi->s_ucpi[cgno];\n\t\t}\n\t}\n\t/*\n\t * Cylinder group number cg is in cache but it was not last used, \n\t * we will move to the first position\n\t */\n\tfor (i = 0; i < sbi->s_cg_loaded && sbi->s_cgno[i] != cgno; i++);\n\tif (i < sbi->s_cg_loaded && sbi->s_cgno[i] == cgno) {\n\t\tcg = sbi->s_cgno[i];\n\t\tucpi = sbi->s_ucpi[i];\n\t\tfor (j = i; j > 0; j--) {\n\t\t\tsbi->s_cgno[j] = sbi->s_cgno[j-1];\n\t\t\tsbi->s_ucpi[j] = sbi->s_ucpi[j-1];\n\t\t}\n\t\tsbi->s_cgno[0] = cg;\n\t\tsbi->s_ucpi[0] = ucpi;\n\t/*\n\t * Cylinder group number cg is not in cache, we will read it from disk\n\t * and put it to the first position\n\t */\n\t} else {\n\t\tif (sbi->s_cg_loaded < UFS_MAX_GROUP_LOADED)\n\t\t\tsbi->s_cg_loaded++;\n\t\telse\n\t\t\tufs_put_cylinder (sb, UFS_MAX_GROUP_LOADED-1);\n\t\tucpi = sbi->s_ucpi[sbi->s_cg_loaded - 1];\n\t\tfor (j = sbi->s_cg_loaded - 1; j > 0; j--) {\n\t\t\tsbi->s_cgno[j] = sbi->s_cgno[j-1];\n\t\t\tsbi->s_ucpi[j] = sbi->s_ucpi[j-1];\n\t\t}\n\t\tsbi->s_ucpi[0] = ucpi;\n\t\tufs_read_cylinder (sb, cgno, 0);\n\t}\n\tUFSD(\"EXIT\\n\");\n\treturn sbi->s_ucpi[0];\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/bitops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <asm/byteorder.h>\n#include <linux/bitops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstruct ufs_cg_private_info * ufs_load_cylinder (\n\tstruct super_block * sb, unsigned cgno)\n{\n\tstruct ufs_sb_info * sbi = UFS_SB(sb);\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cg_private_info * ucpi;\n\tunsigned cg, i, j;\n\n\tUFSD(\"ENTER, cgno %u\\n\", cgno);\n\n\tuspi = sbi->s_uspi;\n\tif (cgno >= uspi->s_ncg) {\n\t\tufs_panic (sb, \"ufs_load_cylinder\", \"internal error, high number of cg\");\n\t\treturn NULL;\n\t}\n\t/*\n\t * Cylinder group number cg it in cache and it was last used\n\t */\n\tif (sbi->s_cgno[0] == cgno) {\n\t\tUFSD(\"EXIT\\n\");\n\t\treturn sbi->s_ucpi[0];\n\t}\n\t/*\n\t * Number of cylinder groups is not higher than UFS_MAX_GROUP_LOADED\n\t */\n\tif (uspi->s_ncg <= UFS_MAX_GROUP_LOADED) {\n\t\tif (sbi->s_cgno[cgno] != UFS_CGNO_EMPTY) {\n\t\t\tif (sbi->s_cgno[cgno] != cgno) {\n\t\t\t\tufs_panic (sb, \"ufs_load_cylinder\", \"internal error, wrong number of cg in cache\");\n\t\t\t\tUFSD(\"EXIT (FAILED)\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tUFSD(\"EXIT\\n\");\n\t\t\t\treturn sbi->s_ucpi[cgno];\n\t\t\t}\n\t\t} else {\n\t\t\tufs_read_cylinder (sb, cgno, cgno);\n\t\t\tUFSD(\"EXIT\\n\");\n\t\t\treturn sbi->s_ucpi[cgno];\n\t\t}\n\t}\n\t/*\n\t * Cylinder group number cg is in cache but it was not last used, \n\t * we will move to the first position\n\t */\n\tfor (i = 0; i < sbi->s_cg_loaded && sbi->s_cgno[i] != cgno; i++);\n\tif (i < sbi->s_cg_loaded && sbi->s_cgno[i] == cgno) {\n\t\tcg = sbi->s_cgno[i];\n\t\tucpi = sbi->s_ucpi[i];\n\t\tfor (j = i; j > 0; j--) {\n\t\t\tsbi->s_cgno[j] = sbi->s_cgno[j-1];\n\t\t\tsbi->s_ucpi[j] = sbi->s_ucpi[j-1];\n\t\t}\n\t\tsbi->s_cgno[0] = cg;\n\t\tsbi->s_ucpi[0] = ucpi;\n\t/*\n\t * Cylinder group number cg is not in cache, we will read it from disk\n\t * and put it to the first position\n\t */\n\t} else {\n\t\tif (sbi->s_cg_loaded < UFS_MAX_GROUP_LOADED)\n\t\t\tsbi->s_cg_loaded++;\n\t\telse\n\t\t\tufs_put_cylinder (sb, UFS_MAX_GROUP_LOADED-1);\n\t\tucpi = sbi->s_ucpi[sbi->s_cg_loaded - 1];\n\t\tfor (j = sbi->s_cg_loaded - 1; j > 0; j--) {\n\t\t\tsbi->s_cgno[j] = sbi->s_cgno[j-1];\n\t\t\tsbi->s_ucpi[j] = sbi->s_ucpi[j-1];\n\t\t}\n\t\tsbi->s_ucpi[0] = ucpi;\n\t\tufs_read_cylinder (sb, cgno, 0);\n\t}\n\tUFSD(\"EXIT\\n\");\n\treturn sbi->s_ucpi[0];\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_dtogd",
          "args": [
            "uspi",
            "fragment"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_dtog",
          "args": [
            "uspi",
            "fragment"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"ENTER, fragment %llu, count %u\\n\"",
            "(unsigned long long)fragment",
            "count"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <asm/byteorder.h>\n#include <linux/bitops.h>\n#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nstatic u64 ufs_add_fragments(struct inode *, u64, unsigned, unsigned);\nstatic u64 ufs_alloc_fragments(struct inode *, unsigned, u64, unsigned, int *);\nstatic u64 ufs_alloccg_block(struct inode *, struct ufs_cg_private_info *, u64, int *);\nstatic u64 ufs_bitmap_search (struct super_block *, struct ufs_cg_private_info *, u64, unsigned);\nstatic void ufs_clusteracct(struct super_block *, struct ufs_cg_private_info *, unsigned, int);\n\nvoid ufs_free_blocks(struct inode *inode, u64 fragment, unsigned count)\n{\n\tstruct super_block * sb;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cg_private_info * ucpi;\n\tstruct ufs_cylinder_group * ucg;\n\tunsigned overflow, cgno, bit, end_bit, i;\n\tu64 blkno;\n\t\n\tsb = inode->i_sb;\n\tuspi = UFS_SB(sb)->s_uspi;\n\n\tUFSD(\"ENTER, fragment %llu, count %u\\n\",\n\t     (unsigned long long)fragment, count);\n\t\n\tif ((fragment & uspi->s_fpbmask) || (count & uspi->s_fpbmask)) {\n\t\tufs_error (sb, \"ufs_free_blocks\", \"internal error, \"\n\t\t\t   \"fragment %llu, count %u\\n\",\n\t\t\t   (unsigned long long)fragment, count);\n\t\tgoto failed;\n\t}\n\n\tlock_ufs(sb);\n\t\ndo_more:\n\toverflow = 0;\n\tcgno = ufs_dtog(uspi, fragment);\n\tbit = ufs_dtogd(uspi, fragment);\n\tif (cgno >= uspi->s_ncg) {\n\t\tufs_panic (sb, \"ufs_free_blocks\", \"freeing blocks are outside device\");\n\t\tgoto failed_unlock;\n\t}\n\tend_bit = bit + count;\n\tif (end_bit > uspi->s_fpg) {\n\t\toverflow = bit + count - uspi->s_fpg;\n\t\tcount -= overflow;\n\t\tend_bit -= overflow;\n\t}\n\n\tucpi = ufs_load_cylinder (sb, cgno);\n\tif (!ucpi) \n\t\tgoto failed_unlock;\n\tucg = ubh_get_ucg (UCPI_UBH(ucpi));\n\tif (!ufs_cg_chkmagic(sb, ucg)) {\n\t\tufs_panic (sb, \"ufs_free_blocks\", \"internal error, bad magic number on cg %u\", cgno);\n\t\tgoto failed_unlock;\n\t}\n\n\tfor (i = bit; i < end_bit; i += uspi->s_fpb) {\n\t\tblkno = ufs_fragstoblks(i);\n\t\tif (ubh_isblockset(UCPI_UBH(ucpi), ucpi->c_freeoff, blkno)) {\n\t\t\tufs_error(sb, \"ufs_free_blocks\", \"freeing free fragment\");\n\t\t}\n\t\tubh_setblock(UCPI_UBH(ucpi), ucpi->c_freeoff, blkno);\n\t\tif ((UFS_SB(sb)->s_flags & UFS_CG_MASK) == UFS_CG_44BSD)\n\t\t\tufs_clusteracct (sb, ucpi, blkno, 1);\n\n\t\tfs32_add(sb, &ucg->cg_cs.cs_nbfree, 1);\n\t\tuspi->cs_total.cs_nbfree++;\n\t\tfs32_add(sb, &UFS_SB(sb)->fs_cs(cgno).cs_nbfree, 1);\n\n\t\tif (uspi->fs_magic != UFS2_MAGIC) {\n\t\t\tunsigned cylno = ufs_cbtocylno(i);\n\n\t\t\tfs16_add(sb, &ubh_cg_blks(ucpi, cylno,\n\t\t\t\t\t\t  ufs_cbtorpos(i)), 1);\n\t\t\tfs32_add(sb, &ubh_cg_blktot(ucpi, cylno), 1);\n\t\t}\n\t}\n\n\tubh_mark_buffer_dirty (USPI_UBH(uspi));\n\tubh_mark_buffer_dirty (UCPI_UBH(ucpi));\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tubh_sync_block(UCPI_UBH(ucpi));\n\n\tif (overflow) {\n\t\tfragment += count;\n\t\tcount = overflow;\n\t\tgoto do_more;\n\t}\n\n\tufs_mark_sb_dirty(sb);\n\tunlock_ufs(sb);\n\tUFSD(\"EXIT\\n\");\n\treturn;\n\nfailed_unlock:\n\tunlock_ufs(sb);\nfailed:\n\tUFSD(\"EXIT (FAILED)\\n\");\n\treturn;\n}"
  },
  {
    "function_name": "ufs_free_fragments",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/balloc.c",
    "lines": "37-127",
    "snippet": "void ufs_free_fragments(struct inode *inode, u64 fragment, unsigned count)\n{\n\tstruct super_block * sb;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cg_private_info * ucpi;\n\tstruct ufs_cylinder_group * ucg;\n\tunsigned cgno, bit, end_bit, bbase, blkmap, i;\n\tu64 blkno;\n\t\n\tsb = inode->i_sb;\n\tuspi = UFS_SB(sb)->s_uspi;\n\t\n\tUFSD(\"ENTER, fragment %llu, count %u\\n\",\n\t     (unsigned long long)fragment, count);\n\t\n\tif (ufs_fragnum(fragment) + count > uspi->s_fpg)\n\t\tufs_error (sb, \"ufs_free_fragments\", \"internal error\");\n\t\n\tlock_ufs(sb);\n\t\n\tcgno = ufs_dtog(uspi, fragment);\n\tbit = ufs_dtogd(uspi, fragment);\n\tif (cgno >= uspi->s_ncg) {\n\t\tufs_panic (sb, \"ufs_free_fragments\", \"freeing blocks are outside device\");\n\t\tgoto failed;\n\t}\n\t\t\n\tucpi = ufs_load_cylinder (sb, cgno);\n\tif (!ucpi) \n\t\tgoto failed;\n\tucg = ubh_get_ucg (UCPI_UBH(ucpi));\n\tif (!ufs_cg_chkmagic(sb, ucg)) {\n\t\tufs_panic (sb, \"ufs_free_fragments\", \"internal error, bad magic number on cg %u\", cgno);\n\t\tgoto failed;\n\t}\n\n\tend_bit = bit + count;\n\tbbase = ufs_blknum (bit);\n\tblkmap = ubh_blkmap (UCPI_UBH(ucpi), ucpi->c_freeoff, bbase);\n\tufs_fragacct (sb, blkmap, ucg->cg_frsum, -1);\n\tfor (i = bit; i < end_bit; i++) {\n\t\tif (ubh_isclr (UCPI_UBH(ucpi), ucpi->c_freeoff, i))\n\t\t\tubh_setbit (UCPI_UBH(ucpi), ucpi->c_freeoff, i);\n\t\telse \n\t\t\tufs_error (sb, \"ufs_free_fragments\",\n\t\t\t\t   \"bit already cleared for fragment %u\", i);\n\t}\n\t\n\tfs32_add(sb, &ucg->cg_cs.cs_nffree, count);\n\tuspi->cs_total.cs_nffree += count;\n\tfs32_add(sb, &UFS_SB(sb)->fs_cs(cgno).cs_nffree, count);\n\tblkmap = ubh_blkmap (UCPI_UBH(ucpi), ucpi->c_freeoff, bbase);\n\tufs_fragacct(sb, blkmap, ucg->cg_frsum, 1);\n\n\t/*\n\t * Trying to reassemble free fragments into block\n\t */\n\tblkno = ufs_fragstoblks (bbase);\n\tif (ubh_isblockset(UCPI_UBH(ucpi), ucpi->c_freeoff, blkno)) {\n\t\tfs32_sub(sb, &ucg->cg_cs.cs_nffree, uspi->s_fpb);\n\t\tuspi->cs_total.cs_nffree -= uspi->s_fpb;\n\t\tfs32_sub(sb, &UFS_SB(sb)->fs_cs(cgno).cs_nffree, uspi->s_fpb);\n\t\tif ((UFS_SB(sb)->s_flags & UFS_CG_MASK) == UFS_CG_44BSD)\n\t\t\tufs_clusteracct (sb, ucpi, blkno, 1);\n\t\tfs32_add(sb, &ucg->cg_cs.cs_nbfree, 1);\n\t\tuspi->cs_total.cs_nbfree++;\n\t\tfs32_add(sb, &UFS_SB(sb)->fs_cs(cgno).cs_nbfree, 1);\n\t\tif (uspi->fs_magic != UFS2_MAGIC) {\n\t\t\tunsigned cylno = ufs_cbtocylno (bbase);\n\n\t\t\tfs16_add(sb, &ubh_cg_blks(ucpi, cylno,\n\t\t\t\t\t\t  ufs_cbtorpos(bbase)), 1);\n\t\t\tfs32_add(sb, &ubh_cg_blktot(ucpi, cylno), 1);\n\t\t}\n\t}\n\t\n\tubh_mark_buffer_dirty (USPI_UBH(uspi));\n\tubh_mark_buffer_dirty (UCPI_UBH(ucpi));\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tubh_sync_block(UCPI_UBH(ucpi));\n\tufs_mark_sb_dirty(sb);\n\t\n\tunlock_ufs(sb);\n\tUFSD(\"EXIT\\n\");\n\treturn;\n\nfailed:\n\tunlock_ufs(sb);\n\tUFSD(\"EXIT (FAILED)\\n\");\n\treturn;\n}",
    "includes": [
      "#include \"util.h\"",
      "#include \"swab.h\"",
      "#include \"ufs.h\"",
      "#include \"ufs_fs.h\"",
      "#include <asm/byteorder.h>",
      "#include <linux/bitops.h>",
      "#include <linux/capability.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/string.h>",
      "#include <linux/time.h>",
      "#include <linux/stat.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64 ufs_add_fragments(struct inode *, u64, unsigned, unsigned);",
      "static u64 ufs_alloc_fragments(struct inode *, unsigned, u64, unsigned, int *);",
      "static u64 ufs_alloccg_block(struct inode *, struct ufs_cg_private_info *, u64, int *);",
      "static u64 ufs_bitmap_search (struct super_block *, struct ufs_cg_private_info *, u64, unsigned);",
      "static void ufs_clusteracct(struct super_block *, struct ufs_cg_private_info *, unsigned, int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"EXIT (FAILED)\\n\""
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_ufs",
          "args": [
            "sb"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_ufs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "104-110",
          "snippet": "void unlock_ufs(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\n\tsbi->mutex_owner = NULL;\n\tmutex_unlock(&sbi->mutex);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid unlock_ufs(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\n\tsbi->mutex_owner = NULL;\n\tmutex_unlock(&sbi->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"EXIT\\n\""
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_mark_sb_dirty",
          "args": [
            "sb"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_mark_sb_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "732-744",
          "snippet": "void ufs_mark_sb_dirty(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\tunsigned long delay;\n\n\tspin_lock(&sbi->work_lock);\n\tif (!sbi->work_queued) {\n\t\tdelay = msecs_to_jiffies(dirty_writeback_interval * 10);\n\t\tqueue_delayed_work(system_long_wq, &sbi->sync_work, delay);\n\t\tsbi->work_queued = 1;\n\t}\n\tspin_unlock(&sbi->work_lock);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid ufs_mark_sb_dirty(struct super_block *sb)\n{\n\tstruct ufs_sb_info *sbi = UFS_SB(sb);\n\tunsigned long delay;\n\n\tspin_lock(&sbi->work_lock);\n\tif (!sbi->work_queued) {\n\t\tdelay = msecs_to_jiffies(dirty_writeback_interval * 10);\n\t\tqueue_delayed_work(system_long_wq, &sbi->sync_work, delay);\n\t\tsbi->work_queued = 1;\n\t}\n\tspin_unlock(&sbi->work_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubh_sync_block",
          "args": [
            "UCPI_UBH(ucpi)"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "ubh_sync_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.c",
          "lines": "115-126",
          "snippet": "void ubh_sync_block(struct ufs_buffer_head *ubh)\n{\n\tif (ubh) {\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < ubh->count; i++)\n\t\t\twrite_dirty_buffer(ubh->bh[i], WRITE);\n\n\t\tfor (i = 0; i < ubh->count; i++)\n\t\t\twait_on_buffer(ubh->bh[i]);\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid ubh_sync_block(struct ufs_buffer_head *ubh)\n{\n\tif (ubh) {\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < ubh->count; i++)\n\t\t\twrite_dirty_buffer(ubh->bh[i], WRITE);\n\n\t\tfor (i = 0; i < ubh->count; i++)\n\t\t\twait_on_buffer(ubh->bh[i]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "UCPI_UBH",
          "args": [
            "ucpi"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "UCPI_UBH",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "22-25",
          "snippet": "static inline struct ufs_buffer_head *UCPI_UBH(struct ufs_cg_private_info *cpi)\n{\n\treturn &cpi->c_ubh;\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ubh_brelse (struct ufs_buffer_head *);",
            "extern void ubh_mark_buffer_dirty (struct ufs_buffer_head *);",
            "extern void ubh_mark_buffer_uptodate (struct ufs_buffer_head *, int);",
            "extern void ubh_sync_block(struct ufs_buffer_head *);",
            "extern void ubh_bforget (struct ufs_buffer_head *);",
            "extern int  ubh_buffer_dirty (struct ufs_buffer_head *);",
            "extern void _ubh_ubhcpymem_(struct ufs_sb_private_info *, unsigned char *, struct ufs_buffer_head *, unsigned);",
            "extern void _ubh_memcpyubh_(struct ufs_sb_private_info *, struct ufs_buffer_head *, unsigned char *, unsigned);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nextern void ubh_brelse (struct ufs_buffer_head *);\nextern void ubh_mark_buffer_dirty (struct ufs_buffer_head *);\nextern void ubh_mark_buffer_uptodate (struct ufs_buffer_head *, int);\nextern void ubh_sync_block(struct ufs_buffer_head *);\nextern void ubh_bforget (struct ufs_buffer_head *);\nextern int  ubh_buffer_dirty (struct ufs_buffer_head *);\nextern void _ubh_ubhcpymem_(struct ufs_sb_private_info *, unsigned char *, struct ufs_buffer_head *, unsigned);\nextern void _ubh_memcpyubh_(struct ufs_sb_private_info *, struct ufs_buffer_head *, unsigned char *, unsigned);\n\nstatic inline struct ufs_buffer_head *UCPI_UBH(struct ufs_cg_private_info *cpi)\n{\n\treturn &cpi->c_ubh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubh_mark_buffer_dirty",
          "args": [
            "UCPI_UBH(ucpi)"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "ubh_mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.c",
          "lines": "92-99",
          "snippet": "void ubh_mark_buffer_dirty (struct ufs_buffer_head * ubh)\n{\n\tunsigned i;\n\tif (!ubh)\n\t\treturn;\n\tfor ( i = 0; i < ubh->count; i++ )\n\t\tmark_buffer_dirty (ubh->bh[i]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n\nvoid ubh_mark_buffer_dirty (struct ufs_buffer_head * ubh)\n{\n\tunsigned i;\n\tif (!ubh)\n\t\treturn;\n\tfor ( i = 0; i < ubh->count; i++ )\n\t\tmark_buffer_dirty (ubh->bh[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "USPI_UBH",
          "args": [
            "uspi"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "USPI_UBH",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "26-29",
          "snippet": "static inline struct ufs_buffer_head *USPI_UBH(struct ufs_sb_private_info *spi)\n{\n\treturn &spi->s_ubh;\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ubh_brelse (struct ufs_buffer_head *);",
            "extern void ubh_brelse_uspi (struct ufs_sb_private_info *);",
            "extern void ubh_mark_buffer_dirty (struct ufs_buffer_head *);",
            "extern void ubh_mark_buffer_uptodate (struct ufs_buffer_head *, int);",
            "extern void ubh_sync_block(struct ufs_buffer_head *);",
            "extern void ubh_bforget (struct ufs_buffer_head *);",
            "extern int  ubh_buffer_dirty (struct ufs_buffer_head *);",
            "extern void _ubh_ubhcpymem_(struct ufs_sb_private_info *, unsigned char *, struct ufs_buffer_head *, unsigned);",
            "extern void _ubh_memcpyubh_(struct ufs_sb_private_info *, struct ufs_buffer_head *, unsigned char *, unsigned);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nextern void ubh_brelse (struct ufs_buffer_head *);\nextern void ubh_brelse_uspi (struct ufs_sb_private_info *);\nextern void ubh_mark_buffer_dirty (struct ufs_buffer_head *);\nextern void ubh_mark_buffer_uptodate (struct ufs_buffer_head *, int);\nextern void ubh_sync_block(struct ufs_buffer_head *);\nextern void ubh_bforget (struct ufs_buffer_head *);\nextern int  ubh_buffer_dirty (struct ufs_buffer_head *);\nextern void _ubh_ubhcpymem_(struct ufs_sb_private_info *, unsigned char *, struct ufs_buffer_head *, unsigned);\nextern void _ubh_memcpyubh_(struct ufs_sb_private_info *, struct ufs_buffer_head *, unsigned char *, unsigned);\n\nstatic inline struct ufs_buffer_head *USPI_UBH(struct ufs_sb_private_info *spi)\n{\n\treturn &spi->s_ubh;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs32_add",
          "args": [
            "sb",
            "&ubh_cg_blktot(ucpi, cylno)",
            "1"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "fs32_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "61-68",
          "snippet": "static inline void\nfs32_add(struct super_block *sbp, __fs32 *n, int d)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\tle32_add_cpu((__le32 *)n, d);\n\telse\n\t\tbe32_add_cpu((__be32 *)n, d);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nfs32_add(struct super_block *sbp, __fs32 *n, int d)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\tle32_add_cpu((__le32 *)n, d);\n\telse\n\t\tbe32_add_cpu((__be32 *)n, d);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubh_cg_blktot",
          "args": [
            "ucpi",
            "cylno"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs16_add",
          "args": [
            "sb",
            "&ubh_cg_blks(ucpi, cylno,\n\t\t\t\t\t\t  ufs_cbtorpos(bbase))",
            "1"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "fs16_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "97-104",
          "snippet": "static inline void\nfs16_add(struct super_block *sbp, __fs16 *n, int d)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\tle16_add_cpu((__le16 *)n, d);\n\telse\n\t\tbe16_add_cpu((__be16 *)n, d);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nfs16_add(struct super_block *sbp, __fs16 *n, int d)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\tle16_add_cpu((__le16 *)n, d);\n\telse\n\t\tbe16_add_cpu((__be16 *)n, d);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubh_cg_blks",
          "args": [
            "ucpi",
            "cylno",
            "ufs_cbtorpos(bbase)"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_cbtorpos",
          "args": [
            "bbase"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_cbtocylno",
          "args": [
            "bbase"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "cgno"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_clusteracct",
          "args": [
            "sb",
            "ucpi",
            "blkno",
            "1"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_clusteracct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/balloc.c",
          "lines": "848-899",
          "snippet": "static void ufs_clusteracct(struct super_block * sb,\n\tstruct ufs_cg_private_info * ucpi, unsigned blkno, int cnt)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tint i, start, end, forw, back;\n\t\n\tuspi = UFS_SB(sb)->s_uspi;\n\tif (uspi->s_contigsumsize <= 0)\n\t\treturn;\n\n\tif (cnt > 0)\n\t\tubh_setbit(UCPI_UBH(ucpi), ucpi->c_clusteroff, blkno);\n\telse\n\t\tubh_clrbit(UCPI_UBH(ucpi), ucpi->c_clusteroff, blkno);\n\n\t/*\n\t * Find the size of the cluster going forward.\n\t */\n\tstart = blkno + 1;\n\tend = start + uspi->s_contigsumsize;\n\tif ( end >= ucpi->c_nclusterblks)\n\t\tend = ucpi->c_nclusterblks;\n\ti = ubh_find_next_zero_bit (UCPI_UBH(ucpi), ucpi->c_clusteroff, end, start);\n\tif (i > end)\n\t\ti = end;\n\tforw = i - start;\n\t\n\t/*\n\t * Find the size of the cluster going backward.\n\t */\n\tstart = blkno - 1;\n\tend = start - uspi->s_contigsumsize;\n\tif (end < 0 ) \n\t\tend = -1;\n\ti = ubh_find_last_zero_bit (UCPI_UBH(ucpi), ucpi->c_clusteroff, start, end);\n\tif ( i < end) \n\t\ti = end;\n\tback = start - i;\n\t\n\t/*\n\t * Account for old cluster and the possibly new forward and\n\t * back clusters.\n\t */\n\ti = back + forw + 1;\n\tif (i > uspi->s_contigsumsize)\n\t\ti = uspi->s_contigsumsize;\n\tfs32_add(sb, (__fs32*)ubh_get_addr(UCPI_UBH(ucpi), ucpi->c_clustersumoff + (i << 2)), cnt);\n\tif (back > 0)\n\t\tfs32_sub(sb, (__fs32*)ubh_get_addr(UCPI_UBH(ucpi), ucpi->c_clustersumoff + (back << 2)), cnt);\n\tif (forw > 0)\n\t\tfs32_sub(sb, (__fs32*)ubh_get_addr(UCPI_UBH(ucpi), ucpi->c_clustersumoff + (forw << 2)), cnt);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/bitops.h>",
            "#include <linux/capability.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ufs_clusteracct(struct super_block *, struct ufs_cg_private_info *, unsigned, int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <asm/byteorder.h>\n#include <linux/bitops.h>\n#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nstatic void ufs_clusteracct(struct super_block *, struct ufs_cg_private_info *, unsigned, int);\n\nstatic void ufs_clusteracct(struct super_block * sb,\n\tstruct ufs_cg_private_info * ucpi, unsigned blkno, int cnt)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tint i, start, end, forw, back;\n\t\n\tuspi = UFS_SB(sb)->s_uspi;\n\tif (uspi->s_contigsumsize <= 0)\n\t\treturn;\n\n\tif (cnt > 0)\n\t\tubh_setbit(UCPI_UBH(ucpi), ucpi->c_clusteroff, blkno);\n\telse\n\t\tubh_clrbit(UCPI_UBH(ucpi), ucpi->c_clusteroff, blkno);\n\n\t/*\n\t * Find the size of the cluster going forward.\n\t */\n\tstart = blkno + 1;\n\tend = start + uspi->s_contigsumsize;\n\tif ( end >= ucpi->c_nclusterblks)\n\t\tend = ucpi->c_nclusterblks;\n\ti = ubh_find_next_zero_bit (UCPI_UBH(ucpi), ucpi->c_clusteroff, end, start);\n\tif (i > end)\n\t\ti = end;\n\tforw = i - start;\n\t\n\t/*\n\t * Find the size of the cluster going backward.\n\t */\n\tstart = blkno - 1;\n\tend = start - uspi->s_contigsumsize;\n\tif (end < 0 ) \n\t\tend = -1;\n\ti = ubh_find_last_zero_bit (UCPI_UBH(ucpi), ucpi->c_clusteroff, start, end);\n\tif ( i < end) \n\t\ti = end;\n\tback = start - i;\n\t\n\t/*\n\t * Account for old cluster and the possibly new forward and\n\t * back clusters.\n\t */\n\ti = back + forw + 1;\n\tif (i > uspi->s_contigsumsize)\n\t\ti = uspi->s_contigsumsize;\n\tfs32_add(sb, (__fs32*)ubh_get_addr(UCPI_UBH(ucpi), ucpi->c_clustersumoff + (i << 2)), cnt);\n\tif (back > 0)\n\t\tfs32_sub(sb, (__fs32*)ubh_get_addr(UCPI_UBH(ucpi), ucpi->c_clustersumoff + (back << 2)), cnt);\n\tif (forw > 0)\n\t\tfs32_sub(sb, (__fs32*)ubh_get_addr(UCPI_UBH(ucpi), ucpi->c_clustersumoff + (forw << 2)), cnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs32_sub",
          "args": [
            "sb",
            "&UFS_SB(sb)->fs_cs(cgno).cs_nffree",
            "uspi->s_fpb"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "fs32_sub",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/swab.h",
          "lines": "70-77",
          "snippet": "static inline void\nfs32_sub(struct super_block *sbp, __fs32 *n, int d)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\tle32_add_cpu((__le32 *)n, -d);\n\telse\n\t\tbe32_add_cpu((__be32 *)n, -d);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void\nfs32_sub(struct super_block *sbp, __fs32 *n, int d)\n{\n\tif (UFS_SB(sbp)->s_bytesex == BYTESEX_LE)\n\t\tle32_add_cpu((__le32 *)n, -d);\n\telse\n\t\tbe32_add_cpu((__be32 *)n, -d);\n}"
        }
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "cgno"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubh_isblockset",
          "args": [
            "UCPI_UBH(ucpi)",
            "ucpi->c_freeoff",
            "blkno"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_fragstoblks",
          "args": [
            "bbase"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_fragacct",
          "args": [
            "sb",
            "blkmap",
            "ucg->cg_frsum",
            "1"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_fragacct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/util.h",
          "lines": "529-549",
          "snippet": "static inline void ufs_fragacct (struct super_block * sb, unsigned blockmap,\n\t__fs32 * fraglist, int cnt)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tunsigned fragsize, pos;\n\t\n\tuspi = UFS_SB(sb)->s_uspi;\n\t\n\tfragsize = 0;\n\tfor (pos = 0; pos < uspi->s_fpb; pos++) {\n\t\tif (blockmap & (1 << pos)) {\n\t\t\tfragsize++;\n\t\t}\n\t\telse if (fragsize > 0) {\n\t\t\tfs32_add(sb, &fraglist[fragsize], cnt);\n\t\t\tfragsize = 0;\n\t\t}\n\t}\n\tif (fragsize > 0 && fragsize < uspi->s_fpb)\n\t\tfs32_add(sb, &fraglist[fragsize], cnt);\n}",
          "includes": [
            "#include \"swab.h\"",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void ubh_brelse_uspi (struct ufs_sb_private_info *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"swab.h\"\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nextern void ubh_brelse_uspi (struct ufs_sb_private_info *);\n\nstatic inline void ufs_fragacct (struct super_block * sb, unsigned blockmap,\n\t__fs32 * fraglist, int cnt)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tunsigned fragsize, pos;\n\t\n\tuspi = UFS_SB(sb)->s_uspi;\n\t\n\tfragsize = 0;\n\tfor (pos = 0; pos < uspi->s_fpb; pos++) {\n\t\tif (blockmap & (1 << pos)) {\n\t\t\tfragsize++;\n\t\t}\n\t\telse if (fragsize > 0) {\n\t\t\tfs32_add(sb, &fraglist[fragsize], cnt);\n\t\t\tfragsize = 0;\n\t\t}\n\t}\n\tif (fragsize > 0 && fragsize < uspi->s_fpb)\n\t\tfs32_add(sb, &fraglist[fragsize], cnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubh_blkmap",
          "args": [
            "UCPI_UBH(ucpi)",
            "ucpi->c_freeoff",
            "bbase"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "cgno"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_error",
          "args": [
            "sb",
            "\"ufs_free_fragments\"",
            "\"bit already cleared for fragment %u\"",
            "i"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "285-317",
          "snippet": "void ufs_error (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct va_format vaf;\n\tva_list args;\n\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\t\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tusb1->fs_clean = UFS_FSBAD;\n\t\tubh_mark_buffer_dirty(USPI_UBH(uspi));\n\t\tufs_mark_sb_dirty(sb);\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tswitch (UFS_SB(sb)->s_mount_opt & UFS_MOUNT_ONERROR) {\n\tcase UFS_MOUNT_ONERROR_PANIC:\n\t\tpanic(\"panic (device %s): %s: %pV\\n\",\n\t\t      sb->s_id, function, &vaf);\n\n\tcase UFS_MOUNT_ONERROR_LOCK:\n\tcase UFS_MOUNT_ONERROR_UMOUNT:\n\tcase UFS_MOUNT_ONERROR_REPAIR:\n\t\tpr_crit(\"error (device %s): %s: %pV\\n\",\n\t\t\tsb->s_id, function, &vaf);\n\t}\n\tva_end(args);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid ufs_error (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct va_format vaf;\n\tva_list args;\n\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\t\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tusb1->fs_clean = UFS_FSBAD;\n\t\tubh_mark_buffer_dirty(USPI_UBH(uspi));\n\t\tufs_mark_sb_dirty(sb);\n\t\tsb->s_flags |= MS_RDONLY;\n\t}\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tswitch (UFS_SB(sb)->s_mount_opt & UFS_MOUNT_ONERROR) {\n\tcase UFS_MOUNT_ONERROR_PANIC:\n\t\tpanic(\"panic (device %s): %s: %pV\\n\",\n\t\t      sb->s_id, function, &vaf);\n\n\tcase UFS_MOUNT_ONERROR_LOCK:\n\tcase UFS_MOUNT_ONERROR_UMOUNT:\n\tcase UFS_MOUNT_ONERROR_REPAIR:\n\t\tpr_crit(\"error (device %s): %s: %pV\\n\",\n\t\t\tsb->s_id, function, &vaf);\n\t}\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ubh_setbit",
          "args": [
            "UCPI_UBH(ucpi)",
            "ucpi->c_freeoff",
            "i"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubh_isclr",
          "args": [
            "UCPI_UBH(ucpi)",
            "ucpi->c_freeoff",
            "i"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubh_blkmap",
          "args": [
            "UCPI_UBH(ucpi)",
            "ucpi->c_freeoff",
            "bbase"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_blknum",
          "args": [
            "bit"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_panic",
          "args": [
            "sb",
            "\"ufs_free_fragments\"",
            "\"internal error, bad magic number on cg %u\"",
            "cgno"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/super.c",
          "lines": "319-342",
          "snippet": "void ufs_panic (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct va_format vaf;\n\tva_list args;\n\t\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\t\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tusb1->fs_clean = UFS_FSBAD;\n\t\tubh_mark_buffer_dirty(USPI_UBH(uspi));\n\t\tufs_mark_sb_dirty(sb);\n\t}\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tsb->s_flags |= MS_RDONLY;\n\tpr_crit(\"panic (device %s): %s: %pV\\n\",\n\t\tsb->s_id, function, &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/log2.h>",
            "#include <linux/vfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/init.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <asm/uaccess.h>",
            "#include <stdarg.h>",
            "#include <linux/bitops.h>",
            "#include <linux/module.h>",
            "#include <linux/exportfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/log2.h>\n#include <linux/vfs.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/init.h>\n#include <linux/blkdev.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <asm/uaccess.h>\n#include <stdarg.h>\n#include <linux/bitops.h>\n#include <linux/module.h>\n#include <linux/exportfs.h>\n\nvoid ufs_panic (struct super_block * sb, const char * function,\n\tconst char * fmt, ...)\n{\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_super_block_first * usb1;\n\tstruct va_format vaf;\n\tva_list args;\n\t\n\tuspi = UFS_SB(sb)->s_uspi;\n\tusb1 = ubh_get_usb_first(uspi);\n\t\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tusb1->fs_clean = UFS_FSBAD;\n\t\tubh_mark_buffer_dirty(USPI_UBH(uspi));\n\t\tufs_mark_sb_dirty(sb);\n\t}\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tsb->s_flags |= MS_RDONLY;\n\tpr_crit(\"panic (device %s): %s: %pV\\n\",\n\t\tsb->s_id, function, &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_cg_chkmagic",
          "args": [
            "sb",
            "ucg"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ubh_get_ucg",
          "args": [
            "UCPI_UBH(ucpi)"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_load_cylinder",
          "args": [
            "sb",
            "cgno"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "ufs_load_cylinder",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ufs/cylinder.c",
          "lines": "126-201",
          "snippet": "struct ufs_cg_private_info * ufs_load_cylinder (\n\tstruct super_block * sb, unsigned cgno)\n{\n\tstruct ufs_sb_info * sbi = UFS_SB(sb);\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cg_private_info * ucpi;\n\tunsigned cg, i, j;\n\n\tUFSD(\"ENTER, cgno %u\\n\", cgno);\n\n\tuspi = sbi->s_uspi;\n\tif (cgno >= uspi->s_ncg) {\n\t\tufs_panic (sb, \"ufs_load_cylinder\", \"internal error, high number of cg\");\n\t\treturn NULL;\n\t}\n\t/*\n\t * Cylinder group number cg it in cache and it was last used\n\t */\n\tif (sbi->s_cgno[0] == cgno) {\n\t\tUFSD(\"EXIT\\n\");\n\t\treturn sbi->s_ucpi[0];\n\t}\n\t/*\n\t * Number of cylinder groups is not higher than UFS_MAX_GROUP_LOADED\n\t */\n\tif (uspi->s_ncg <= UFS_MAX_GROUP_LOADED) {\n\t\tif (sbi->s_cgno[cgno] != UFS_CGNO_EMPTY) {\n\t\t\tif (sbi->s_cgno[cgno] != cgno) {\n\t\t\t\tufs_panic (sb, \"ufs_load_cylinder\", \"internal error, wrong number of cg in cache\");\n\t\t\t\tUFSD(\"EXIT (FAILED)\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tUFSD(\"EXIT\\n\");\n\t\t\t\treturn sbi->s_ucpi[cgno];\n\t\t\t}\n\t\t} else {\n\t\t\tufs_read_cylinder (sb, cgno, cgno);\n\t\t\tUFSD(\"EXIT\\n\");\n\t\t\treturn sbi->s_ucpi[cgno];\n\t\t}\n\t}\n\t/*\n\t * Cylinder group number cg is in cache but it was not last used, \n\t * we will move to the first position\n\t */\n\tfor (i = 0; i < sbi->s_cg_loaded && sbi->s_cgno[i] != cgno; i++);\n\tif (i < sbi->s_cg_loaded && sbi->s_cgno[i] == cgno) {\n\t\tcg = sbi->s_cgno[i];\n\t\tucpi = sbi->s_ucpi[i];\n\t\tfor (j = i; j > 0; j--) {\n\t\t\tsbi->s_cgno[j] = sbi->s_cgno[j-1];\n\t\t\tsbi->s_ucpi[j] = sbi->s_ucpi[j-1];\n\t\t}\n\t\tsbi->s_cgno[0] = cg;\n\t\tsbi->s_ucpi[0] = ucpi;\n\t/*\n\t * Cylinder group number cg is not in cache, we will read it from disk\n\t * and put it to the first position\n\t */\n\t} else {\n\t\tif (sbi->s_cg_loaded < UFS_MAX_GROUP_LOADED)\n\t\t\tsbi->s_cg_loaded++;\n\t\telse\n\t\t\tufs_put_cylinder (sb, UFS_MAX_GROUP_LOADED-1);\n\t\tucpi = sbi->s_ucpi[sbi->s_cg_loaded - 1];\n\t\tfor (j = sbi->s_cg_loaded - 1; j > 0; j--) {\n\t\t\tsbi->s_cgno[j] = sbi->s_cgno[j-1];\n\t\t\tsbi->s_ucpi[j] = sbi->s_ucpi[j-1];\n\t\t}\n\t\tsbi->s_ucpi[0] = ucpi;\n\t\tufs_read_cylinder (sb, cgno, 0);\n\t}\n\tUFSD(\"EXIT\\n\");\n\treturn sbi->s_ucpi[0];\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"swab.h\"",
            "#include \"ufs.h\"",
            "#include \"ufs_fs.h\"",
            "#include <asm/byteorder.h>",
            "#include <linux/bitops.h>",
            "#include <linux/string.h>",
            "#include <linux/stat.h>",
            "#include <linux/time.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <asm/byteorder.h>\n#include <linux/bitops.h>\n#include <linux/string.h>\n#include <linux/stat.h>\n#include <linux/time.h>\n#include <linux/fs.h>\n\nstruct ufs_cg_private_info * ufs_load_cylinder (\n\tstruct super_block * sb, unsigned cgno)\n{\n\tstruct ufs_sb_info * sbi = UFS_SB(sb);\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cg_private_info * ucpi;\n\tunsigned cg, i, j;\n\n\tUFSD(\"ENTER, cgno %u\\n\", cgno);\n\n\tuspi = sbi->s_uspi;\n\tif (cgno >= uspi->s_ncg) {\n\t\tufs_panic (sb, \"ufs_load_cylinder\", \"internal error, high number of cg\");\n\t\treturn NULL;\n\t}\n\t/*\n\t * Cylinder group number cg it in cache and it was last used\n\t */\n\tif (sbi->s_cgno[0] == cgno) {\n\t\tUFSD(\"EXIT\\n\");\n\t\treturn sbi->s_ucpi[0];\n\t}\n\t/*\n\t * Number of cylinder groups is not higher than UFS_MAX_GROUP_LOADED\n\t */\n\tif (uspi->s_ncg <= UFS_MAX_GROUP_LOADED) {\n\t\tif (sbi->s_cgno[cgno] != UFS_CGNO_EMPTY) {\n\t\t\tif (sbi->s_cgno[cgno] != cgno) {\n\t\t\t\tufs_panic (sb, \"ufs_load_cylinder\", \"internal error, wrong number of cg in cache\");\n\t\t\t\tUFSD(\"EXIT (FAILED)\\n\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tUFSD(\"EXIT\\n\");\n\t\t\t\treturn sbi->s_ucpi[cgno];\n\t\t\t}\n\t\t} else {\n\t\t\tufs_read_cylinder (sb, cgno, cgno);\n\t\t\tUFSD(\"EXIT\\n\");\n\t\t\treturn sbi->s_ucpi[cgno];\n\t\t}\n\t}\n\t/*\n\t * Cylinder group number cg is in cache but it was not last used, \n\t * we will move to the first position\n\t */\n\tfor (i = 0; i < sbi->s_cg_loaded && sbi->s_cgno[i] != cgno; i++);\n\tif (i < sbi->s_cg_loaded && sbi->s_cgno[i] == cgno) {\n\t\tcg = sbi->s_cgno[i];\n\t\tucpi = sbi->s_ucpi[i];\n\t\tfor (j = i; j > 0; j--) {\n\t\t\tsbi->s_cgno[j] = sbi->s_cgno[j-1];\n\t\t\tsbi->s_ucpi[j] = sbi->s_ucpi[j-1];\n\t\t}\n\t\tsbi->s_cgno[0] = cg;\n\t\tsbi->s_ucpi[0] = ucpi;\n\t/*\n\t * Cylinder group number cg is not in cache, we will read it from disk\n\t * and put it to the first position\n\t */\n\t} else {\n\t\tif (sbi->s_cg_loaded < UFS_MAX_GROUP_LOADED)\n\t\t\tsbi->s_cg_loaded++;\n\t\telse\n\t\t\tufs_put_cylinder (sb, UFS_MAX_GROUP_LOADED-1);\n\t\tucpi = sbi->s_ucpi[sbi->s_cg_loaded - 1];\n\t\tfor (j = sbi->s_cg_loaded - 1; j > 0; j--) {\n\t\t\tsbi->s_cgno[j] = sbi->s_cgno[j-1];\n\t\t\tsbi->s_ucpi[j] = sbi->s_ucpi[j-1];\n\t\t}\n\t\tsbi->s_ucpi[0] = ucpi;\n\t\tufs_read_cylinder (sb, cgno, 0);\n\t}\n\tUFSD(\"EXIT\\n\");\n\treturn sbi->s_ucpi[0];\n}"
        }
      },
      {
        "call_info": {
          "callee": "ufs_dtogd",
          "args": [
            "uspi",
            "fragment"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_dtog",
          "args": [
            "uspi",
            "fragment"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ufs_fragnum",
          "args": [
            "fragment"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFSD",
          "args": [
            "\"ENTER, fragment %llu, count %u\\n\"",
            "(unsigned long long)fragment",
            "count"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UFS_SB",
          "args": [
            "sb"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"util.h\"\n#include \"swab.h\"\n#include \"ufs.h\"\n#include \"ufs_fs.h\"\n#include <asm/byteorder.h>\n#include <linux/bitops.h>\n#include <linux/capability.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n\nstatic u64 ufs_add_fragments(struct inode *, u64, unsigned, unsigned);\nstatic u64 ufs_alloc_fragments(struct inode *, unsigned, u64, unsigned, int *);\nstatic u64 ufs_alloccg_block(struct inode *, struct ufs_cg_private_info *, u64, int *);\nstatic u64 ufs_bitmap_search (struct super_block *, struct ufs_cg_private_info *, u64, unsigned);\nstatic void ufs_clusteracct(struct super_block *, struct ufs_cg_private_info *, unsigned, int);\n\nvoid ufs_free_fragments(struct inode *inode, u64 fragment, unsigned count)\n{\n\tstruct super_block * sb;\n\tstruct ufs_sb_private_info * uspi;\n\tstruct ufs_cg_private_info * ucpi;\n\tstruct ufs_cylinder_group * ucg;\n\tunsigned cgno, bit, end_bit, bbase, blkmap, i;\n\tu64 blkno;\n\t\n\tsb = inode->i_sb;\n\tuspi = UFS_SB(sb)->s_uspi;\n\t\n\tUFSD(\"ENTER, fragment %llu, count %u\\n\",\n\t     (unsigned long long)fragment, count);\n\t\n\tif (ufs_fragnum(fragment) + count > uspi->s_fpg)\n\t\tufs_error (sb, \"ufs_free_fragments\", \"internal error\");\n\t\n\tlock_ufs(sb);\n\t\n\tcgno = ufs_dtog(uspi, fragment);\n\tbit = ufs_dtogd(uspi, fragment);\n\tif (cgno >= uspi->s_ncg) {\n\t\tufs_panic (sb, \"ufs_free_fragments\", \"freeing blocks are outside device\");\n\t\tgoto failed;\n\t}\n\t\t\n\tucpi = ufs_load_cylinder (sb, cgno);\n\tif (!ucpi) \n\t\tgoto failed;\n\tucg = ubh_get_ucg (UCPI_UBH(ucpi));\n\tif (!ufs_cg_chkmagic(sb, ucg)) {\n\t\tufs_panic (sb, \"ufs_free_fragments\", \"internal error, bad magic number on cg %u\", cgno);\n\t\tgoto failed;\n\t}\n\n\tend_bit = bit + count;\n\tbbase = ufs_blknum (bit);\n\tblkmap = ubh_blkmap (UCPI_UBH(ucpi), ucpi->c_freeoff, bbase);\n\tufs_fragacct (sb, blkmap, ucg->cg_frsum, -1);\n\tfor (i = bit; i < end_bit; i++) {\n\t\tif (ubh_isclr (UCPI_UBH(ucpi), ucpi->c_freeoff, i))\n\t\t\tubh_setbit (UCPI_UBH(ucpi), ucpi->c_freeoff, i);\n\t\telse \n\t\t\tufs_error (sb, \"ufs_free_fragments\",\n\t\t\t\t   \"bit already cleared for fragment %u\", i);\n\t}\n\t\n\tfs32_add(sb, &ucg->cg_cs.cs_nffree, count);\n\tuspi->cs_total.cs_nffree += count;\n\tfs32_add(sb, &UFS_SB(sb)->fs_cs(cgno).cs_nffree, count);\n\tblkmap = ubh_blkmap (UCPI_UBH(ucpi), ucpi->c_freeoff, bbase);\n\tufs_fragacct(sb, blkmap, ucg->cg_frsum, 1);\n\n\t/*\n\t * Trying to reassemble free fragments into block\n\t */\n\tblkno = ufs_fragstoblks (bbase);\n\tif (ubh_isblockset(UCPI_UBH(ucpi), ucpi->c_freeoff, blkno)) {\n\t\tfs32_sub(sb, &ucg->cg_cs.cs_nffree, uspi->s_fpb);\n\t\tuspi->cs_total.cs_nffree -= uspi->s_fpb;\n\t\tfs32_sub(sb, &UFS_SB(sb)->fs_cs(cgno).cs_nffree, uspi->s_fpb);\n\t\tif ((UFS_SB(sb)->s_flags & UFS_CG_MASK) == UFS_CG_44BSD)\n\t\t\tufs_clusteracct (sb, ucpi, blkno, 1);\n\t\tfs32_add(sb, &ucg->cg_cs.cs_nbfree, 1);\n\t\tuspi->cs_total.cs_nbfree++;\n\t\tfs32_add(sb, &UFS_SB(sb)->fs_cs(cgno).cs_nbfree, 1);\n\t\tif (uspi->fs_magic != UFS2_MAGIC) {\n\t\t\tunsigned cylno = ufs_cbtocylno (bbase);\n\n\t\t\tfs16_add(sb, &ubh_cg_blks(ucpi, cylno,\n\t\t\t\t\t\t  ufs_cbtorpos(bbase)), 1);\n\t\t\tfs32_add(sb, &ubh_cg_blktot(ucpi, cylno), 1);\n\t\t}\n\t}\n\t\n\tubh_mark_buffer_dirty (USPI_UBH(uspi));\n\tubh_mark_buffer_dirty (UCPI_UBH(ucpi));\n\tif (sb->s_flags & MS_SYNCHRONOUS)\n\t\tubh_sync_block(UCPI_UBH(ucpi));\n\tufs_mark_sb_dirty(sb);\n\t\n\tunlock_ufs(sb);\n\tUFSD(\"EXIT\\n\");\n\treturn;\n\nfailed:\n\tunlock_ufs(sb);\n\tUFSD(\"EXIT (FAILED)\\n\");\n\treturn;\n}"
  }
]