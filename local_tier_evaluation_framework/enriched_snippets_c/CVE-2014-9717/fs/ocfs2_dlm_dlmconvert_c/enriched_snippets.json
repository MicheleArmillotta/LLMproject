[
  {
    "function_name": "dlm_convert_lock_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmconvert.c",
    "lines": "418-544",
    "snippet": "int dlm_convert_lock_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t     void **ret_data)\n{\n\tstruct dlm_ctxt *dlm = data;\n\tstruct dlm_convert_lock *cnv = (struct dlm_convert_lock *)msg->buf;\n\tstruct dlm_lock_resource *res = NULL;\n\tstruct dlm_lock *lock = NULL;\n\tstruct dlm_lock *tmp_lock;\n\tstruct dlm_lockstatus *lksb;\n\tenum dlm_status status = DLM_NORMAL;\n\tu32 flags;\n\tint call_ast = 0, kick_thread = 0, ast_reserved = 0, wake = 0;\n\n\tif (!dlm_grab(dlm)) {\n\t\tdlm_error(DLM_REJECTED);\n\t\treturn DLM_REJECTED;\n\t}\n\n\tmlog_bug_on_msg(!dlm_domain_fully_joined(dlm),\n\t\t\t\"Domain %s not fully joined!\\n\", dlm->name);\n\n\tif (cnv->namelen > DLM_LOCKID_NAME_MAX) {\n\t\tstatus = DLM_IVBUFLEN;\n\t\tdlm_error(status);\n\t\tgoto leave;\n\t}\n\n\tflags = be32_to_cpu(cnv->flags);\n\n\tif ((flags & (LKM_PUT_LVB|LKM_GET_LVB)) ==\n\t     (LKM_PUT_LVB|LKM_GET_LVB)) {\n\t\tmlog(ML_ERROR, \"both PUT and GET lvb specified\\n\");\n\t\tstatus = DLM_BADARGS;\n\t\tgoto leave;\n\t}\n\n\tmlog(0, \"lvb: %s\\n\", flags & LKM_PUT_LVB ? \"put lvb\" :\n\t     (flags & LKM_GET_LVB ? \"get lvb\" : \"none\"));\n\n\tstatus = DLM_IVLOCKID;\n\tres = dlm_lookup_lockres(dlm, cnv->name, cnv->namelen);\n\tif (!res) {\n\t\tdlm_error(status);\n\t\tgoto leave;\n\t}\n\n\tspin_lock(&res->spinlock);\n\tstatus = __dlm_lockres_state_to_status(res);\n\tif (status != DLM_NORMAL) {\n\t\tspin_unlock(&res->spinlock);\n\t\tdlm_error(status);\n\t\tgoto leave;\n\t}\n\tlist_for_each_entry(tmp_lock, &res->granted, list) {\n\t\tif (tmp_lock->ml.cookie == cnv->cookie &&\n\t\t    tmp_lock->ml.node == cnv->node_idx) {\n\t\t\tlock = tmp_lock;\n\t\t\tdlm_lock_get(lock);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&res->spinlock);\n\tif (!lock) {\n\t\tstatus = DLM_IVLOCKID;\n\t\tmlog(ML_ERROR, \"did not find lock to convert on grant queue! \"\n\t\t\t       \"cookie=%u:%llu\\n\",\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(cnv->cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(cnv->cookie)));\n\t\tdlm_print_one_lock_resource(res);\n\t\tgoto leave;\n\t}\n\n\t/* found the lock */\n\tlksb = lock->lksb;\n\n\t/* see if caller needed to get/put lvb */\n\tif (flags & LKM_PUT_LVB) {\n\t\tBUG_ON(lksb->flags & (DLM_LKSB_PUT_LVB|DLM_LKSB_GET_LVB));\n\t\tlksb->flags |= DLM_LKSB_PUT_LVB;\n\t\tmemcpy(&lksb->lvb[0], &cnv->lvb[0], DLM_LVB_LEN);\n\t} else if (flags & LKM_GET_LVB) {\n\t\tBUG_ON(lksb->flags & (DLM_LKSB_PUT_LVB|DLM_LKSB_GET_LVB));\n\t\tlksb->flags |= DLM_LKSB_GET_LVB;\n\t}\n\n\tspin_lock(&res->spinlock);\n\tstatus = __dlm_lockres_state_to_status(res);\n\tif (status == DLM_NORMAL) {\n\t\t__dlm_lockres_reserve_ast(res);\n\t\tast_reserved = 1;\n\t\tres->state |= DLM_LOCK_RES_IN_PROGRESS;\n\t\tstatus = __dlmconvert_master(dlm, res, lock, flags,\n\t\t\t\t\t     cnv->requested_type,\n\t\t\t\t\t     &call_ast, &kick_thread);\n\t\tres->state &= ~DLM_LOCK_RES_IN_PROGRESS;\n\t\twake = 1;\n\t}\n\tspin_unlock(&res->spinlock);\n\tif (wake)\n\t\twake_up(&res->wq);\n\n\tif (status != DLM_NORMAL) {\n\t\tif (status != DLM_NOTQUEUED)\n\t\t\tdlm_error(status);\n\t\tlksb->flags &= ~(DLM_LKSB_GET_LVB|DLM_LKSB_PUT_LVB);\n\t}\n\nleave:\n\tif (lock)\n\t\tdlm_lock_put(lock);\n\n\t/* either queue the ast or release it, if reserved */\n\tif (call_ast)\n\t\tdlm_queue_ast(dlm, lock);\n\telse if (ast_reserved)\n\t\tdlm_lockres_release_ast(dlm, res);\n\n\tif (kick_thread)\n\t\tdlm_kick_thread(dlm, res);\n\n\tif (res)\n\t\tdlm_lockres_put(res);\n\n\tdlm_put(dlm);\n\n\treturn status;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmconvert.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static enum dlm_status __dlmconvert_master(struct dlm_ctxt *dlm,\n\t\t\t\t\t   struct dlm_lock_resource *res,\n\t\t\t\t\t   struct dlm_lock *lock, int flags,\n\t\t\t\t\t   int type, int *call_ast,\n\t\t\t\t\t   int *kick_thread);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_put",
          "args": [
            "dlm"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_put_mle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "248-258",
          "snippet": "static void dlm_put_mle(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&dlm->master_lock);\n\t__dlm_put_mle(mle);\n\tspin_unlock(&dlm->master_lock);\n\tspin_unlock(&dlm->spinlock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_put_mle(struct dlm_master_list_entry *mle);",
            "static void __dlm_put_mle(struct dlm_master_list_entry *mle);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle);\nstatic void __dlm_put_mle(struct dlm_master_list_entry *mle);\n\nstatic void dlm_put_mle(struct dlm_master_list_entry *mle)\n{\n\tstruct dlm_ctxt *dlm;\n\tdlm = mle->dlm;\n\n\tspin_lock(&dlm->spinlock);\n\tspin_lock(&dlm->master_lock);\n\t__dlm_put_mle(mle);\n\tspin_unlock(&dlm->master_lock);\n\tspin_unlock(&dlm->spinlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lockres_put",
          "args": [
            "res"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "550-553",
          "snippet": "void dlm_lockres_put(struct dlm_lock_resource *res)\n{\n\tkref_put(&res->refs, dlm_lockres_release);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid dlm_lockres_put(struct dlm_lock_resource *res)\n{\n\tkref_put(&res->refs, dlm_lockres_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_kick_thread",
          "args": [
            "dlm",
            "res"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_kick_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "445-455",
          "snippet": "void dlm_kick_thread(struct dlm_ctxt *dlm, struct dlm_lock_resource *res)\n{\n\tif (res) {\n\t\tspin_lock(&dlm->spinlock);\n\t\tspin_lock(&res->spinlock);\n\t\t__dlm_dirty_lockres(dlm, res);\n\t\tspin_unlock(&res->spinlock);\n\t\tspin_unlock(&dlm->spinlock);\n\t}\n\twake_up(&dlm->dlm_thread_wq);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nvoid dlm_kick_thread(struct dlm_ctxt *dlm, struct dlm_lock_resource *res)\n{\n\tif (res) {\n\t\tspin_lock(&dlm->spinlock);\n\t\tspin_lock(&res->spinlock);\n\t\t__dlm_dirty_lockres(dlm, res);\n\t\tspin_unlock(&res->spinlock);\n\t\tspin_unlock(&dlm->spinlock);\n\t}\n\twake_up(&dlm->dlm_thread_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lockres_release_ast",
          "args": [
            "dlm",
            "res"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_release_ast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "3419-3436",
          "snippet": "void dlm_lockres_release_ast(struct dlm_ctxt *dlm,\n\t\t\t     struct dlm_lock_resource *res)\n{\n\tif (!atomic_dec_and_lock(&res->asts_reserved, &res->spinlock))\n\t\treturn;\n\n\tif (!res->migration_pending) {\n\t\tspin_unlock(&res->spinlock);\n\t\treturn;\n\t}\n\n\tBUG_ON(res->state & DLM_LOCK_RES_MIGRATING);\n\tres->migration_pending = 0;\n\tres->state |= DLM_LOCK_RES_MIGRATING;\n\tspin_unlock(&res->spinlock);\n\twake_up(&res->wq);\n\twake_up(&dlm->migration_wq);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid dlm_lockres_release_ast(struct dlm_ctxt *dlm,\n\t\t\t     struct dlm_lock_resource *res)\n{\n\tif (!atomic_dec_and_lock(&res->asts_reserved, &res->spinlock))\n\t\treturn;\n\n\tif (!res->migration_pending) {\n\t\tspin_unlock(&res->spinlock);\n\t\treturn;\n\t}\n\n\tBUG_ON(res->state & DLM_LOCK_RES_MIGRATING);\n\tres->migration_pending = 0;\n\tres->state |= DLM_LOCK_RES_MIGRATING;\n\tspin_unlock(&res->spinlock);\n\twake_up(&res->wq);\n\twake_up(&dlm->migration_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_queue_ast",
          "args": [
            "dlm",
            "lock"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_queue_ast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmast.c",
          "lines": "146-154",
          "snippet": "void dlm_queue_ast(struct dlm_ctxt *dlm, struct dlm_lock *lock)\n{\n\tBUG_ON(!dlm);\n\tBUG_ON(!lock);\n\n\tspin_lock(&dlm->ast_lock);\n\t__dlm_queue_ast(dlm, lock);\n\tspin_unlock(&dlm->ast_lock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_update_lvb(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock);",
            "static int dlm_should_cancel_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_update_lvb(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock);\nstatic int dlm_should_cancel_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock);\n\nvoid dlm_queue_ast(struct dlm_ctxt *dlm, struct dlm_lock *lock)\n{\n\tBUG_ON(!dlm);\n\tBUG_ON(!lock);\n\n\tspin_lock(&dlm->ast_lock);\n\t__dlm_queue_ast(dlm, lock);\n\tspin_unlock(&dlm->ast_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lock_put",
          "args": [
            "lock"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lock_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmlock.c",
          "lines": "347-350",
          "snippet": "void dlm_lock_put(struct dlm_lock *lock)\n{\n\tkref_put(&lock->lock_refs, dlm_lock_release);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmconvert.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_lock_detach_lockres(struct dlm_lock *lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_lock_detach_lockres(struct dlm_lock *lock);\n\nvoid dlm_lock_put(struct dlm_lock *lock)\n{\n\tkref_put(&lock->lock_refs, dlm_lock_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_error",
          "args": [
            "status"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "user_recover_from_dlm_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
          "lines": "99-104",
          "snippet": "static inline void user_recover_from_dlm_error(struct user_lock_res *lockres)\n{\n\tspin_lock(&lockres->l_lock);\n\tlockres->l_flags &= ~USER_LOCK_BUSY;\n\tspin_unlock(&lockres->l_lock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"userdlm.h\"",
            "#include \"stackglue.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nstatic inline void user_recover_from_dlm_error(struct user_lock_res *lockres)\n{\n\tspin_lock(&lockres->l_lock);\n\tlockres->l_flags &= ~USER_LOCK_BUSY;\n\tspin_unlock(&lockres->l_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&res->wq"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&res->spinlock"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlmconvert_master",
          "args": [
            "dlm",
            "res",
            "lock",
            "flags",
            "cnv->requested_type",
            "&call_ast",
            "&kick_thread"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "__dlmconvert_master",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmconvert.c",
          "lines": "119-242",
          "snippet": "static enum dlm_status __dlmconvert_master(struct dlm_ctxt *dlm,\n\t\t\t\t\t   struct dlm_lock_resource *res,\n\t\t\t\t\t   struct dlm_lock *lock, int flags,\n\t\t\t\t\t   int type, int *call_ast,\n\t\t\t\t\t   int *kick_thread)\n{\n\tenum dlm_status status = DLM_NORMAL;\n\tstruct dlm_lock *tmplock=NULL;\n\n\tassert_spin_locked(&res->spinlock);\n\n\tmlog(0, \"type=%d, convert_type=%d, new convert_type=%d\\n\",\n\t     lock->ml.type, lock->ml.convert_type, type);\n\n\tspin_lock(&lock->spinlock);\n\n\t/* already converting? */\n\tif (lock->ml.convert_type != LKM_IVMODE) {\n\t\tmlog(ML_ERROR, \"attempted to convert a lock with a lock \"\n\t\t     \"conversion pending\\n\");\n\t\tstatus = DLM_DENIED;\n\t\tgoto unlock_exit;\n\t}\n\n\t/* must be on grant queue to convert */\n\tif (!dlm_lock_on_list(&res->granted, lock)) {\n\t\tmlog(ML_ERROR, \"attempted to convert a lock not on grant \"\n\t\t     \"queue\\n\");\n\t\tstatus = DLM_DENIED;\n\t\tgoto unlock_exit;\n\t}\n\n\tif (flags & LKM_VALBLK) {\n\t\tswitch (lock->ml.type) {\n\t\t\tcase LKM_EXMODE:\n\t\t\t\t/* EX + LKM_VALBLK + convert == set lvb */\n\t\t\t\tmlog(0, \"will set lvb: converting %s->%s\\n\",\n\t\t\t\t     dlm_lock_mode_name(lock->ml.type),\n\t\t\t\t     dlm_lock_mode_name(type));\n\t\t\t\tlock->lksb->flags |= DLM_LKSB_PUT_LVB;\n\t\t\t\tbreak;\n\t\t\tcase LKM_PRMODE:\n\t\t\tcase LKM_NLMODE:\n\t\t\t\t/* refetch if new level is not NL */\n\t\t\t\tif (type > LKM_NLMODE) {\n\t\t\t\t\tmlog(0, \"will fetch new value into \"\n\t\t\t\t\t     \"lvb: converting %s->%s\\n\",\n\t\t\t\t\t     dlm_lock_mode_name(lock->ml.type),\n\t\t\t\t\t     dlm_lock_mode_name(type));\n\t\t\t\t\tlock->lksb->flags |= DLM_LKSB_GET_LVB;\n\t\t\t\t} else {\n\t\t\t\t\tmlog(0, \"will NOT fetch new value \"\n\t\t\t\t\t     \"into lvb: converting %s->%s\\n\",\n\t\t\t\t\t     dlm_lock_mode_name(lock->ml.type),\n\t\t\t\t\t     dlm_lock_mode_name(type));\n\t\t\t\t\tflags &= ~(LKM_VALBLK);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\n\t/* in-place downconvert? */\n\tif (type <= lock->ml.type)\n\t\tgoto grant;\n\n\t/* upconvert from here on */\n\tstatus = DLM_NORMAL;\n\tlist_for_each_entry(tmplock, &res->granted, list) {\n\t\tif (tmplock == lock)\n\t\t\tcontinue;\n\t\tif (!dlm_lock_compatible(tmplock->ml.type, type))\n\t\t\tgoto switch_queues;\n\t}\n\n\tlist_for_each_entry(tmplock, &res->converting, list) {\n\t\tif (!dlm_lock_compatible(tmplock->ml.type, type))\n\t\t\tgoto switch_queues;\n\t\t/* existing conversion requests take precedence */\n\t\tif (!dlm_lock_compatible(tmplock->ml.convert_type, type))\n\t\t\tgoto switch_queues;\n\t}\n\n\t/* fall thru to grant */\n\ngrant:\n\tmlog(0, \"res %.*s, granting %s lock\\n\", res->lockname.len,\n\t     res->lockname.name, dlm_lock_mode_name(type));\n\t/* immediately grant the new lock type */\n\tlock->lksb->status = DLM_NORMAL;\n\tif (lock->ml.node == dlm->node_num)\n\t\tmlog(0, \"doing in-place convert for nonlocal lock\\n\");\n\tlock->ml.type = type;\n\tif (lock->lksb->flags & DLM_LKSB_PUT_LVB)\n\t\tmemcpy(res->lvb, lock->lksb->lvb, DLM_LVB_LEN);\n\n\tstatus = DLM_NORMAL;\n\t*call_ast = 1;\n\tgoto unlock_exit;\n\nswitch_queues:\n\tif (flags & LKM_NOQUEUE) {\n\t\tmlog(0, \"failed to convert NOQUEUE lock %.*s from \"\n\t\t     \"%d to %d...\\n\", res->lockname.len, res->lockname.name,\n\t\t     lock->ml.type, type);\n\t\tstatus = DLM_NOTQUEUED;\n\t\tgoto unlock_exit;\n\t}\n\tmlog(0, \"res %.*s, queueing...\\n\", res->lockname.len,\n\t     res->lockname.name);\n\n\tlock->ml.convert_type = type;\n\t/* do not alter lock refcount.  switching lists. */\n\tlist_move_tail(&lock->list, &res->converting);\n\nunlock_exit:\n\tspin_unlock(&lock->spinlock);\n\tif (status == DLM_DENIED) {\n\t\t__dlm_print_one_lock_resource(res);\n\t}\n\tif (status == DLM_NORMAL)\n\t\t*kick_thread = 1;\n\treturn status;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmconvert.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static enum dlm_status __dlmconvert_master(struct dlm_ctxt *dlm,\n\t\t\t\t\t   struct dlm_lock_resource *res,\n\t\t\t\t\t   struct dlm_lock *lock, int flags,\n\t\t\t\t\t   int type, int *call_ast,\n\t\t\t\t\t   int *kick_thread);",
            "static enum dlm_status dlm_send_remote_convert_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t   struct dlm_lock_resource *res,\n\t\t\t\t\t   struct dlm_lock *lock, int flags, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic enum dlm_status __dlmconvert_master(struct dlm_ctxt *dlm,\n\t\t\t\t\t   struct dlm_lock_resource *res,\n\t\t\t\t\t   struct dlm_lock *lock, int flags,\n\t\t\t\t\t   int type, int *call_ast,\n\t\t\t\t\t   int *kick_thread);\nstatic enum dlm_status dlm_send_remote_convert_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t   struct dlm_lock_resource *res,\n\t\t\t\t\t   struct dlm_lock *lock, int flags, int type);\n\nstatic enum dlm_status __dlmconvert_master(struct dlm_ctxt *dlm,\n\t\t\t\t\t   struct dlm_lock_resource *res,\n\t\t\t\t\t   struct dlm_lock *lock, int flags,\n\t\t\t\t\t   int type, int *call_ast,\n\t\t\t\t\t   int *kick_thread)\n{\n\tenum dlm_status status = DLM_NORMAL;\n\tstruct dlm_lock *tmplock=NULL;\n\n\tassert_spin_locked(&res->spinlock);\n\n\tmlog(0, \"type=%d, convert_type=%d, new convert_type=%d\\n\",\n\t     lock->ml.type, lock->ml.convert_type, type);\n\n\tspin_lock(&lock->spinlock);\n\n\t/* already converting? */\n\tif (lock->ml.convert_type != LKM_IVMODE) {\n\t\tmlog(ML_ERROR, \"attempted to convert a lock with a lock \"\n\t\t     \"conversion pending\\n\");\n\t\tstatus = DLM_DENIED;\n\t\tgoto unlock_exit;\n\t}\n\n\t/* must be on grant queue to convert */\n\tif (!dlm_lock_on_list(&res->granted, lock)) {\n\t\tmlog(ML_ERROR, \"attempted to convert a lock not on grant \"\n\t\t     \"queue\\n\");\n\t\tstatus = DLM_DENIED;\n\t\tgoto unlock_exit;\n\t}\n\n\tif (flags & LKM_VALBLK) {\n\t\tswitch (lock->ml.type) {\n\t\t\tcase LKM_EXMODE:\n\t\t\t\t/* EX + LKM_VALBLK + convert == set lvb */\n\t\t\t\tmlog(0, \"will set lvb: converting %s->%s\\n\",\n\t\t\t\t     dlm_lock_mode_name(lock->ml.type),\n\t\t\t\t     dlm_lock_mode_name(type));\n\t\t\t\tlock->lksb->flags |= DLM_LKSB_PUT_LVB;\n\t\t\t\tbreak;\n\t\t\tcase LKM_PRMODE:\n\t\t\tcase LKM_NLMODE:\n\t\t\t\t/* refetch if new level is not NL */\n\t\t\t\tif (type > LKM_NLMODE) {\n\t\t\t\t\tmlog(0, \"will fetch new value into \"\n\t\t\t\t\t     \"lvb: converting %s->%s\\n\",\n\t\t\t\t\t     dlm_lock_mode_name(lock->ml.type),\n\t\t\t\t\t     dlm_lock_mode_name(type));\n\t\t\t\t\tlock->lksb->flags |= DLM_LKSB_GET_LVB;\n\t\t\t\t} else {\n\t\t\t\t\tmlog(0, \"will NOT fetch new value \"\n\t\t\t\t\t     \"into lvb: converting %s->%s\\n\",\n\t\t\t\t\t     dlm_lock_mode_name(lock->ml.type),\n\t\t\t\t\t     dlm_lock_mode_name(type));\n\t\t\t\t\tflags &= ~(LKM_VALBLK);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\n\t/* in-place downconvert? */\n\tif (type <= lock->ml.type)\n\t\tgoto grant;\n\n\t/* upconvert from here on */\n\tstatus = DLM_NORMAL;\n\tlist_for_each_entry(tmplock, &res->granted, list) {\n\t\tif (tmplock == lock)\n\t\t\tcontinue;\n\t\tif (!dlm_lock_compatible(tmplock->ml.type, type))\n\t\t\tgoto switch_queues;\n\t}\n\n\tlist_for_each_entry(tmplock, &res->converting, list) {\n\t\tif (!dlm_lock_compatible(tmplock->ml.type, type))\n\t\t\tgoto switch_queues;\n\t\t/* existing conversion requests take precedence */\n\t\tif (!dlm_lock_compatible(tmplock->ml.convert_type, type))\n\t\t\tgoto switch_queues;\n\t}\n\n\t/* fall thru to grant */\n\ngrant:\n\tmlog(0, \"res %.*s, granting %s lock\\n\", res->lockname.len,\n\t     res->lockname.name, dlm_lock_mode_name(type));\n\t/* immediately grant the new lock type */\n\tlock->lksb->status = DLM_NORMAL;\n\tif (lock->ml.node == dlm->node_num)\n\t\tmlog(0, \"doing in-place convert for nonlocal lock\\n\");\n\tlock->ml.type = type;\n\tif (lock->lksb->flags & DLM_LKSB_PUT_LVB)\n\t\tmemcpy(res->lvb, lock->lksb->lvb, DLM_LVB_LEN);\n\n\tstatus = DLM_NORMAL;\n\t*call_ast = 1;\n\tgoto unlock_exit;\n\nswitch_queues:\n\tif (flags & LKM_NOQUEUE) {\n\t\tmlog(0, \"failed to convert NOQUEUE lock %.*s from \"\n\t\t     \"%d to %d...\\n\", res->lockname.len, res->lockname.name,\n\t\t     lock->ml.type, type);\n\t\tstatus = DLM_NOTQUEUED;\n\t\tgoto unlock_exit;\n\t}\n\tmlog(0, \"res %.*s, queueing...\\n\", res->lockname.len,\n\t     res->lockname.name);\n\n\tlock->ml.convert_type = type;\n\t/* do not alter lock refcount.  switching lists. */\n\tlist_move_tail(&lock->list, &res->converting);\n\nunlock_exit:\n\tspin_unlock(&lock->spinlock);\n\tif (status == DLM_DENIED) {\n\t\t__dlm_print_one_lock_resource(res);\n\t}\n\tif (status == DLM_NORMAL)\n\t\t*kick_thread = 1;\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_lockres_reserve_ast",
          "args": [
            "res"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_lockres_reserve_ast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "3395-3404",
          "snippet": "void __dlm_lockres_reserve_ast(struct dlm_lock_resource *res)\n{\n\tassert_spin_locked(&res->spinlock);\n\tif (res->state & DLM_LOCK_RES_MIGRATING) {\n\t\t__dlm_print_one_lock_resource(res);\n\t}\n\tBUG_ON(res->state & DLM_LOCK_RES_MIGRATING);\n\n\tatomic_inc(&res->asts_reserved);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid __dlm_lockres_reserve_ast(struct dlm_lock_resource *res)\n{\n\tassert_spin_locked(&res->spinlock);\n\tif (res->state & DLM_LOCK_RES_MIGRATING) {\n\t\t__dlm_print_one_lock_resource(res);\n\t}\n\tBUG_ON(res->state & DLM_LOCK_RES_MIGRATING);\n\n\tatomic_inc(&res->asts_reserved);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_lockres_state_to_status",
          "args": [
            "res"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_lockres_state_to_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "796-811",
          "snippet": "static inline enum dlm_status\n__dlm_lockres_state_to_status(struct dlm_lock_resource *res)\n{\n\tenum dlm_status status = DLM_NORMAL;\n\n\tassert_spin_locked(&res->spinlock);\n\n\tif (res->state & DLM_LOCK_RES_RECOVERING)\n\t\tstatus = DLM_RECOVERING;\n\telse if (res->state & DLM_LOCK_RES_MIGRATING)\n\t\tstatus = DLM_MIGRATING;\n\telse if (res->state & DLM_LOCK_RES_IN_PROGRESS)\n\t\tstatus = DLM_FORWARD;\n\n\treturn status;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [
            "#define DLM_LOCK_RES_MIGRATING            0x00000020",
            "#define DLM_LOCK_RES_IN_PROGRESS          0x00000010",
            "#define DLM_LOCK_RES_RECOVERING           0x00000002"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\n#define DLM_LOCK_RES_MIGRATING            0x00000020\n#define DLM_LOCK_RES_IN_PROGRESS          0x00000010\n#define DLM_LOCK_RES_RECOVERING           0x00000002\n\nstatic inline enum dlm_status\n__dlm_lockres_state_to_status(struct dlm_lock_resource *res)\n{\n\tenum dlm_status status = DLM_NORMAL;\n\n\tassert_spin_locked(&res->spinlock);\n\n\tif (res->state & DLM_LOCK_RES_RECOVERING)\n\t\tstatus = DLM_RECOVERING;\n\telse if (res->state & DLM_LOCK_RES_MIGRATING)\n\t\tstatus = DLM_MIGRATING;\n\telse if (res->state & DLM_LOCK_RES_IN_PROGRESS)\n\t\tstatus = DLM_FORWARD;\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&res->spinlock"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "lksb->flags & (DLM_LKSB_PUT_LVB|DLM_LKSB_GET_LVB)"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&lksb->lvb[0]",
            "&cnv->lvb[0]",
            "DLM_LVB_LEN"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "lksb->flags & (DLM_LKSB_PUT_LVB|DLM_LKSB_GET_LVB)"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_print_one_lock_resource",
          "args": [
            "res"
          ],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_print_one_lock_resource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdebug.c",
          "lines": "97-131",
          "snippet": "void __dlm_print_one_lock_resource(struct dlm_lock_resource *res)\n{\n\tstruct dlm_lock *lock;\n\tchar buf[DLM_LOCKID_NAME_MAX];\n\n\tassert_spin_locked(&res->spinlock);\n\n\tstringify_lockname(res->lockname.name, res->lockname.len,\n\t\t\t   buf, sizeof(buf));\n\tprintk(\"lockres: %s, owner=%u, state=%u\\n\",\n\t       buf, res->owner, res->state);\n\tprintk(\"  last used: %lu, refcnt: %u, on purge list: %s\\n\",\n\t       res->last_used, atomic_read(&res->refs.refcount),\n\t       list_empty(&res->purge) ? \"no\" : \"yes\");\n\tprintk(\"  on dirty list: %s, on reco list: %s, \"\n\t       \"migrating pending: %s\\n\",\n\t       list_empty(&res->dirty) ? \"no\" : \"yes\",\n\t       list_empty(&res->recovering) ? \"no\" : \"yes\",\n\t       res->migration_pending ? \"yes\" : \"no\");\n\tprintk(\"  inflight locks: %d, asts reserved: %d\\n\",\n\t       res->inflight_locks, atomic_read(&res->asts_reserved));\n\tdlm_print_lockres_refmap(res);\n\tprintk(\"  granted queue:\\n\");\n\tlist_for_each_entry(lock, &res->granted, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  converting queue:\\n\");\n\tlist_for_each_entry(lock, &res->converting, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  blocked queue:\\n\");\n\tlist_for_each_entry(lock, &res->blocked, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int stringify_lockname(const char *lockname, int locklen, char *buf,\n\t\t\t      int len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/spinlock.h>\n#include <linux/sysctl.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int stringify_lockname(const char *lockname, int locklen, char *buf,\n\t\t\t      int len);\n\nvoid __dlm_print_one_lock_resource(struct dlm_lock_resource *res)\n{\n\tstruct dlm_lock *lock;\n\tchar buf[DLM_LOCKID_NAME_MAX];\n\n\tassert_spin_locked(&res->spinlock);\n\n\tstringify_lockname(res->lockname.name, res->lockname.len,\n\t\t\t   buf, sizeof(buf));\n\tprintk(\"lockres: %s, owner=%u, state=%u\\n\",\n\t       buf, res->owner, res->state);\n\tprintk(\"  last used: %lu, refcnt: %u, on purge list: %s\\n\",\n\t       res->last_used, atomic_read(&res->refs.refcount),\n\t       list_empty(&res->purge) ? \"no\" : \"yes\");\n\tprintk(\"  on dirty list: %s, on reco list: %s, \"\n\t       \"migrating pending: %s\\n\",\n\t       list_empty(&res->dirty) ? \"no\" : \"yes\",\n\t       list_empty(&res->recovering) ? \"no\" : \"yes\",\n\t       res->migration_pending ? \"yes\" : \"no\");\n\tprintk(\"  inflight locks: %d, asts reserved: %d\\n\",\n\t       res->inflight_locks, atomic_read(&res->asts_reserved));\n\tdlm_print_lockres_refmap(res);\n\tprintk(\"  granted queue:\\n\");\n\tlist_for_each_entry(lock, &res->granted, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  converting queue:\\n\");\n\tlist_for_each_entry(lock, &res->converting, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  blocked queue:\\n\");\n\tlist_for_each_entry(lock, &res->blocked, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"did not find lock to convert on grant queue! \"\n\t\t\t       \"cookie=%u:%llu\\n\"",
            "dlm_get_lock_cookie_node(be64_to_cpu(cnv->cookie))",
            "dlm_get_lock_cookie_seq(be64_to_cpu(cnv->cookie))"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_get_lock_cookie_seq",
          "args": [
            "be64_to_cpu(cnv->cookie)"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_get_lock_cookie_seq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "821-826",
          "snippet": "static inline unsigned long long dlm_get_lock_cookie_seq(u64 cookie)\n{\n\tunsigned long long ret;\n\tret = ((unsigned long long)cookie) & 0x00ffffffffffffffULL;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline unsigned long long dlm_get_lock_cookie_seq(u64 cookie)\n{\n\tunsigned long long ret;\n\tret = ((unsigned long long)cookie) & 0x00ffffffffffffffULL;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "cnv->cookie"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_get_lock_cookie_node",
          "args": [
            "be64_to_cpu(cnv->cookie)"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_get_lock_cookie_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "813-819",
          "snippet": "static inline u8 dlm_get_lock_cookie_node(u64 cookie)\n{\n\tu8 ret;\n\tcookie >>= 56;\n\tret = (u8)(cookie & 0xffULL);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline u8 dlm_get_lock_cookie_node(u64 cookie)\n{\n\tu8 ret;\n\tcookie >>= 56;\n\tret = (u8)(cookie & 0xffULL);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "cnv->cookie"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_lock_get",
          "args": [
            "lock"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lock_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmlock.c",
          "lines": "342-345",
          "snippet": "void dlm_lock_get(struct dlm_lock *lock)\n{\n\tkref_get(&lock->lock_refs);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmconvert.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_lock_detach_lockres(struct dlm_lock *lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_lock_detach_lockres(struct dlm_lock *lock);\n\nvoid dlm_lock_get(struct dlm_lock *lock)\n{\n\tkref_get(&lock->lock_refs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tmp_lock",
            "&res->granted",
            "list"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_lookup_lockres",
          "args": [
            "dlm",
            "cnv->name",
            "cnv->namelen"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lookup_lockres",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "246-257",
          "snippet": "struct dlm_lock_resource * dlm_lookup_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t    const char *name,\n\t\t\t\t    unsigned int len)\n{\n\tstruct dlm_lock_resource *res;\n\tunsigned int hash = dlm_lockid_hash(name, len);\n\n\tspin_lock(&dlm->spinlock);\n\tres = __dlm_lookup_lockres(dlm, name, len, hash);\n\tspin_unlock(&dlm->spinlock);\n\treturn res;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstruct dlm_lock_resource * dlm_lookup_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t    const char *name,\n\t\t\t\t    unsigned int len)\n{\n\tstruct dlm_lock_resource *res;\n\tunsigned int hash = dlm_lockid_hash(name, len);\n\n\tspin_lock(&dlm->spinlock);\n\tres = __dlm_lookup_lockres(dlm, name, len, hash);\n\tspin_unlock(&dlm->spinlock);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"lvb: %s\\n\"",
            "flags & LKM_PUT_LVB ? \"put lvb\" :\n\t     (flags & LKM_GET_LVB ? \"get lvb\" : \"none\")"
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"both PUT and GET lvb specified\\n\""
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "cnv->flags"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_bug_on_msg",
          "args": [
            "!dlm_domain_fully_joined(dlm)",
            "\"Domain %s not fully joined!\\n\"",
            "dlm->name"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_domain_fully_joined",
          "args": [
            "dlm"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_domain_fully_joined",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "380-390",
          "snippet": "int dlm_domain_fully_joined(struct dlm_ctxt *dlm)\n{\n\tint ret;\n\n\tspin_lock(&dlm_domain_lock);\n\tret = (dlm->dlm_state == DLM_CTXT_JOINED) ||\n\t\t(dlm->dlm_state == DLM_CTXT_IN_SHUTDOWN);\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nint dlm_domain_fully_joined(struct dlm_ctxt *dlm)\n{\n\tint ret;\n\n\tspin_lock(&dlm_domain_lock);\n\tret = (dlm->dlm_state == DLM_CTXT_JOINED) ||\n\t\t(dlm->dlm_state == DLM_CTXT_IN_SHUTDOWN);\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_grab",
          "args": [
            "dlm"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_grab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdomain.c",
          "lines": "360-378",
          "snippet": "struct dlm_ctxt *dlm_grab(struct dlm_ctxt *dlm)\n{\n\tstruct dlm_ctxt *target;\n\tstruct dlm_ctxt *ret = NULL;\n\n\tspin_lock(&dlm_domain_lock);\n\n\tlist_for_each_entry(target, &dlm_domains, list) {\n\t\tif (target == dlm) {\n\t\t\t__dlm_get(target);\n\t\t\tret = target;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/err.h>",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/debugfs.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nstatic void dlm_unregister_domain_handlers(struct dlm_ctxt *dlm);\n\nstruct dlm_ctxt *dlm_grab(struct dlm_ctxt *dlm)\n{\n\tstruct dlm_ctxt *target;\n\tstruct dlm_ctxt *ret = NULL;\n\n\tspin_lock(&dlm_domain_lock);\n\n\tlist_for_each_entry(target, &dlm_domains, list) {\n\t\tif (target == dlm) {\n\t\t\t__dlm_get(target);\n\t\t\tret = target;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&dlm_domain_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic enum dlm_status __dlmconvert_master(struct dlm_ctxt *dlm,\n\t\t\t\t\t   struct dlm_lock_resource *res,\n\t\t\t\t\t   struct dlm_lock *lock, int flags,\n\t\t\t\t\t   int type, int *call_ast,\n\t\t\t\t\t   int *kick_thread);\n\nint dlm_convert_lock_handler(struct o2net_msg *msg, u32 len, void *data,\n\t\t\t     void **ret_data)\n{\n\tstruct dlm_ctxt *dlm = data;\n\tstruct dlm_convert_lock *cnv = (struct dlm_convert_lock *)msg->buf;\n\tstruct dlm_lock_resource *res = NULL;\n\tstruct dlm_lock *lock = NULL;\n\tstruct dlm_lock *tmp_lock;\n\tstruct dlm_lockstatus *lksb;\n\tenum dlm_status status = DLM_NORMAL;\n\tu32 flags;\n\tint call_ast = 0, kick_thread = 0, ast_reserved = 0, wake = 0;\n\n\tif (!dlm_grab(dlm)) {\n\t\tdlm_error(DLM_REJECTED);\n\t\treturn DLM_REJECTED;\n\t}\n\n\tmlog_bug_on_msg(!dlm_domain_fully_joined(dlm),\n\t\t\t\"Domain %s not fully joined!\\n\", dlm->name);\n\n\tif (cnv->namelen > DLM_LOCKID_NAME_MAX) {\n\t\tstatus = DLM_IVBUFLEN;\n\t\tdlm_error(status);\n\t\tgoto leave;\n\t}\n\n\tflags = be32_to_cpu(cnv->flags);\n\n\tif ((flags & (LKM_PUT_LVB|LKM_GET_LVB)) ==\n\t     (LKM_PUT_LVB|LKM_GET_LVB)) {\n\t\tmlog(ML_ERROR, \"both PUT and GET lvb specified\\n\");\n\t\tstatus = DLM_BADARGS;\n\t\tgoto leave;\n\t}\n\n\tmlog(0, \"lvb: %s\\n\", flags & LKM_PUT_LVB ? \"put lvb\" :\n\t     (flags & LKM_GET_LVB ? \"get lvb\" : \"none\"));\n\n\tstatus = DLM_IVLOCKID;\n\tres = dlm_lookup_lockres(dlm, cnv->name, cnv->namelen);\n\tif (!res) {\n\t\tdlm_error(status);\n\t\tgoto leave;\n\t}\n\n\tspin_lock(&res->spinlock);\n\tstatus = __dlm_lockres_state_to_status(res);\n\tif (status != DLM_NORMAL) {\n\t\tspin_unlock(&res->spinlock);\n\t\tdlm_error(status);\n\t\tgoto leave;\n\t}\n\tlist_for_each_entry(tmp_lock, &res->granted, list) {\n\t\tif (tmp_lock->ml.cookie == cnv->cookie &&\n\t\t    tmp_lock->ml.node == cnv->node_idx) {\n\t\t\tlock = tmp_lock;\n\t\t\tdlm_lock_get(lock);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&res->spinlock);\n\tif (!lock) {\n\t\tstatus = DLM_IVLOCKID;\n\t\tmlog(ML_ERROR, \"did not find lock to convert on grant queue! \"\n\t\t\t       \"cookie=%u:%llu\\n\",\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(cnv->cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(cnv->cookie)));\n\t\tdlm_print_one_lock_resource(res);\n\t\tgoto leave;\n\t}\n\n\t/* found the lock */\n\tlksb = lock->lksb;\n\n\t/* see if caller needed to get/put lvb */\n\tif (flags & LKM_PUT_LVB) {\n\t\tBUG_ON(lksb->flags & (DLM_LKSB_PUT_LVB|DLM_LKSB_GET_LVB));\n\t\tlksb->flags |= DLM_LKSB_PUT_LVB;\n\t\tmemcpy(&lksb->lvb[0], &cnv->lvb[0], DLM_LVB_LEN);\n\t} else if (flags & LKM_GET_LVB) {\n\t\tBUG_ON(lksb->flags & (DLM_LKSB_PUT_LVB|DLM_LKSB_GET_LVB));\n\t\tlksb->flags |= DLM_LKSB_GET_LVB;\n\t}\n\n\tspin_lock(&res->spinlock);\n\tstatus = __dlm_lockres_state_to_status(res);\n\tif (status == DLM_NORMAL) {\n\t\t__dlm_lockres_reserve_ast(res);\n\t\tast_reserved = 1;\n\t\tres->state |= DLM_LOCK_RES_IN_PROGRESS;\n\t\tstatus = __dlmconvert_master(dlm, res, lock, flags,\n\t\t\t\t\t     cnv->requested_type,\n\t\t\t\t\t     &call_ast, &kick_thread);\n\t\tres->state &= ~DLM_LOCK_RES_IN_PROGRESS;\n\t\twake = 1;\n\t}\n\tspin_unlock(&res->spinlock);\n\tif (wake)\n\t\twake_up(&res->wq);\n\n\tif (status != DLM_NORMAL) {\n\t\tif (status != DLM_NOTQUEUED)\n\t\t\tdlm_error(status);\n\t\tlksb->flags &= ~(DLM_LKSB_GET_LVB|DLM_LKSB_PUT_LVB);\n\t}\n\nleave:\n\tif (lock)\n\t\tdlm_lock_put(lock);\n\n\t/* either queue the ast or release it, if reserved */\n\tif (call_ast)\n\t\tdlm_queue_ast(dlm, lock);\n\telse if (ast_reserved)\n\t\tdlm_lockres_release_ast(dlm, res);\n\n\tif (kick_thread)\n\t\tdlm_kick_thread(dlm, res);\n\n\tif (res)\n\t\tdlm_lockres_put(res);\n\n\tdlm_put(dlm);\n\n\treturn status;\n}"
  },
  {
    "function_name": "dlm_send_remote_convert_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmconvert.c",
    "lines": "342-408",
    "snippet": "static enum dlm_status dlm_send_remote_convert_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t   struct dlm_lock_resource *res,\n\t\t\t\t\t   struct dlm_lock *lock, int flags, int type)\n{\n\tstruct dlm_convert_lock convert;\n\tint tmpret;\n\tenum dlm_status ret;\n\tint status = 0;\n\tstruct kvec vec[2];\n\tsize_t veclen = 1;\n\n\tmlog(0, \"%.*s\\n\", res->lockname.len, res->lockname.name);\n\n\tmemset(&convert, 0, sizeof(struct dlm_convert_lock));\n\tconvert.node_idx = dlm->node_num;\n\tconvert.requested_type = type;\n\tconvert.cookie = lock->ml.cookie;\n\tconvert.namelen = res->lockname.len;\n\tconvert.flags = cpu_to_be32(flags);\n\tmemcpy(convert.name, res->lockname.name, convert.namelen);\n\n\tvec[0].iov_len = sizeof(struct dlm_convert_lock);\n\tvec[0].iov_base = &convert;\n\n\tif (flags & LKM_PUT_LVB) {\n\t\t/* extra data to send if we are updating lvb */\n\t\tvec[1].iov_len = DLM_LVB_LEN;\n\t\tvec[1].iov_base = lock->lksb->lvb;\n\t\tveclen++;\n\t}\n\n\ttmpret = o2net_send_message_vec(DLM_CONVERT_LOCK_MSG, dlm->key,\n\t\t\t\t\tvec, veclen, res->owner, &status);\n\tif (tmpret >= 0) {\n\t\t// successfully sent and received\n\t\tret = status;  // this is already a dlm_status\n\t\tif (ret == DLM_RECOVERING) {\n\t\t\tmlog(0, \"node %u returned DLM_RECOVERING from convert \"\n\t\t\t     \"message!\\n\", res->owner);\n\t\t} else if (ret == DLM_MIGRATING) {\n\t\t\tmlog(0, \"node %u returned DLM_MIGRATING from convert \"\n\t\t\t     \"message!\\n\", res->owner);\n\t\t} else if (ret == DLM_FORWARD) {\n\t\t\tmlog(0, \"node %u returned DLM_FORWARD from convert \"\n\t\t\t     \"message!\\n\", res->owner);\n\t\t} else if (ret != DLM_NORMAL && ret != DLM_NOTQUEUED)\n\t\t\tdlm_error(ret);\n\t} else {\n\t\tmlog(ML_ERROR, \"Error %d when sending message %u (key 0x%x) to \"\n\t\t     \"node %u\\n\", tmpret, DLM_CONVERT_LOCK_MSG, dlm->key,\n\t\t     res->owner);\n\t\tif (dlm_is_host_down(tmpret)) {\n\t\t\t/* instead of logging the same network error over\n\t\t\t * and over, sleep here and wait for the heartbeat\n\t\t\t * to notice the node is dead.  times out after 5s. */\n\t\t\tdlm_wait_for_node_death(dlm, res->owner,\n\t\t\t\t\t\tDLM_NODE_DEATH_WAIT_MAX);\n\t\t\tret = DLM_RECOVERING;\n\t\t\tmlog(0, \"node %u died so returning DLM_RECOVERING \"\n\t\t\t     \"from convert message!\\n\", res->owner);\n\t\t} else {\n\t\t\tret = dlm_err_to_dlm_status(tmpret);\n\t\t}\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmconvert.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static enum dlm_status dlm_send_remote_convert_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t   struct dlm_lock_resource *res,\n\t\t\t\t\t   struct dlm_lock *lock, int flags, int type);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_err_to_dlm_status",
          "args": [
            "tmpret"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_err_to_dlm_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "1095-1109",
          "snippet": "static inline enum dlm_status dlm_err_to_dlm_status(int err)\n{\n\tenum dlm_status ret;\n\tif (err == -ENOMEM)\n\t\tret = DLM_SYSERR;\n\telse if (err == -ETIMEDOUT || o2net_link_down(err, NULL))\n\t\tret = DLM_NOLOCKMGR;\n\telse if (err == -EINVAL)\n\t\tret = DLM_BADPARAM;\n\telse if (err == -ENAMETOOLONG)\n\t\tret = DLM_IVBUFLEN;\n\telse\n\t\tret = DLM_BADARGS;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline enum dlm_status dlm_err_to_dlm_status(int err)\n{\n\tenum dlm_status ret;\n\tif (err == -ENOMEM)\n\t\tret = DLM_SYSERR;\n\telse if (err == -ETIMEDOUT || o2net_link_down(err, NULL))\n\t\tret = DLM_NOLOCKMGR;\n\telse if (err == -EINVAL)\n\t\tret = DLM_BADPARAM;\n\telse if (err == -ENAMETOOLONG)\n\t\tret = DLM_IVBUFLEN;\n\telse\n\t\tret = DLM_BADARGS;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"node %u died so returning DLM_RECOVERING \"\n\t\t\t     \"from convert message!\\n\"",
            "res->owner"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_wait_for_node_death",
          "args": [
            "dlm",
            "res->owner",
            "DLM_NODE_DEATH_WAIT_MAX"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_wait_for_node_death",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmrecovery.c",
          "lines": "362-377",
          "snippet": "void dlm_wait_for_node_death(struct dlm_ctxt *dlm, u8 node, int timeout)\n{\n\tif (dlm_is_node_dead(dlm, node))\n\t\treturn;\n\n\tprintk(KERN_NOTICE \"o2dlm: Waiting on the death of node %u in \"\n\t       \"domain %s\\n\", node, dlm->name);\n\n\tif (timeout)\n\t\twait_event_timeout(dlm->dlm_reco_thread_wq,\n\t\t\t\t   dlm_is_node_dead(dlm, node),\n\t\t\t\t   msecs_to_jiffies(timeout));\n\telse\n\t\twait_event(dlm->dlm_reco_thread_wq,\n\t\t\t   dlm_is_node_dead(dlm, node));\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int dlm_do_recovery(struct dlm_ctxt *dlm);",
            "static int dlm_pick_recovery_master(struct dlm_ctxt *dlm);",
            "static int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int dlm_do_recovery(struct dlm_ctxt *dlm);\nstatic int dlm_pick_recovery_master(struct dlm_ctxt *dlm);\nstatic int dlm_send_finalize_reco_message(struct dlm_ctxt *dlm);\n\nvoid dlm_wait_for_node_death(struct dlm_ctxt *dlm, u8 node, int timeout)\n{\n\tif (dlm_is_node_dead(dlm, node))\n\t\treturn;\n\n\tprintk(KERN_NOTICE \"o2dlm: Waiting on the death of node %u in \"\n\t       \"domain %s\\n\", node, dlm->name);\n\n\tif (timeout)\n\t\twait_event_timeout(dlm->dlm_reco_thread_wq,\n\t\t\t\t   dlm_is_node_dead(dlm, node),\n\t\t\t\t   msecs_to_jiffies(timeout));\n\telse\n\t\twait_event(dlm->dlm_reco_thread_wq,\n\t\t\t   dlm_is_node_dead(dlm, node));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_is_host_down",
          "args": [
            "tmpret"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_is_host_down",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "132-154",
          "snippet": "int dlm_is_host_down(int errno)\n{\n\tswitch (errno) {\n\t\tcase -EBADF:\n\t\tcase -ECONNREFUSED:\n\t\tcase -ENOTCONN:\n\t\tcase -ECONNRESET:\n\t\tcase -EPIPE:\n\t\tcase -EHOSTDOWN:\n\t\tcase -EHOSTUNREACH:\n\t\tcase -ETIMEDOUT:\n\t\tcase -ECONNABORTED:\n\t\tcase -ENETDOWN:\n\t\tcase -ENETUNREACH:\n\t\tcase -ENETRESET:\n\t\tcase -ESHUTDOWN:\n\t\tcase -ENOPROTOOPT:\n\t\tcase -EINVAL:   /* if returned from our tcp code,\n\t\t\t\t   this means there is no socket */\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint dlm_is_host_down(int errno)\n{\n\tswitch (errno) {\n\t\tcase -EBADF:\n\t\tcase -ECONNREFUSED:\n\t\tcase -ENOTCONN:\n\t\tcase -ECONNRESET:\n\t\tcase -EPIPE:\n\t\tcase -EHOSTDOWN:\n\t\tcase -EHOSTUNREACH:\n\t\tcase -ETIMEDOUT:\n\t\tcase -ECONNABORTED:\n\t\tcase -ENETDOWN:\n\t\tcase -ENETUNREACH:\n\t\tcase -ENETRESET:\n\t\tcase -ESHUTDOWN:\n\t\tcase -ENOPROTOOPT:\n\t\tcase -EINVAL:   /* if returned from our tcp code,\n\t\t\t\t   this means there is no socket */\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Error %d when sending message %u (key 0x%x) to \"\n\t\t     \"node %u\\n\"",
            "tmpret",
            "DLM_CONVERT_LOCK_MSG",
            "dlm->key",
            "res->owner"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_error",
          "args": [
            "ret"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "user_recover_from_dlm_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
          "lines": "99-104",
          "snippet": "static inline void user_recover_from_dlm_error(struct user_lock_res *lockres)\n{\n\tspin_lock(&lockres->l_lock);\n\tlockres->l_flags &= ~USER_LOCK_BUSY;\n\tspin_unlock(&lockres->l_lock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"userdlm.h\"",
            "#include \"stackglue.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nstatic inline void user_recover_from_dlm_error(struct user_lock_res *lockres)\n{\n\tspin_lock(&lockres->l_lock);\n\tlockres->l_flags &= ~USER_LOCK_BUSY;\n\tspin_unlock(&lockres->l_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_send_message_vec",
          "args": [
            "DLM_CONVERT_LOCK_MSG",
            "dlm->key",
            "vec",
            "veclen",
            "res->owner",
            "&status"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_send_message_vec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "1029-1144",
          "snippet": "int o2net_send_message_vec(u32 msg_type, u32 key, struct kvec *caller_vec,\n\t\t\t   size_t caller_veclen, u8 target_node, int *status)\n{\n\tint ret = 0;\n\tstruct o2net_msg *msg = NULL;\n\tsize_t veclen, caller_bytes = 0;\n\tstruct kvec *vec = NULL;\n\tstruct o2net_sock_container *sc = NULL;\n\tstruct o2net_node *nn = o2net_nn_from_num(target_node);\n\tstruct o2net_status_wait nsw = {\n\t\t.ns_node_item = LIST_HEAD_INIT(nsw.ns_node_item),\n\t};\n\tstruct o2net_send_tracking nst;\n\n\to2net_init_nst(&nst, msg_type, key, current, target_node);\n\n\tif (o2net_wq == NULL) {\n\t\tmlog(0, \"attempt to tx without o2netd running\\n\");\n\t\tret = -ESRCH;\n\t\tgoto out;\n\t}\n\n\tif (caller_veclen == 0) {\n\t\tmlog(0, \"bad kvec array length\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tcaller_bytes = iov_length((struct iovec *)caller_vec, caller_veclen);\n\tif (caller_bytes > O2NET_MAX_PAYLOAD_BYTES) {\n\t\tmlog(0, \"total payload len %zu too large\\n\", caller_bytes);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (target_node == o2nm_this_node()) {\n\t\tret = -ELOOP;\n\t\tgoto out;\n\t}\n\n\to2net_debug_add_nst(&nst);\n\n\to2net_set_nst_sock_time(&nst);\n\n\twait_event(nn->nn_sc_wq, o2net_tx_can_proceed(nn, &sc, &ret));\n\tif (ret)\n\t\tgoto out;\n\n\to2net_set_nst_sock_container(&nst, sc);\n\n\tveclen = caller_veclen + 1;\n\tvec = kmalloc(sizeof(struct kvec) * veclen, GFP_ATOMIC);\n\tif (vec == NULL) {\n\t\tmlog(0, \"failed to %zu element kvec!\\n\", veclen);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmsg = kmalloc(sizeof(struct o2net_msg), GFP_ATOMIC);\n\tif (!msg) {\n\t\tmlog(0, \"failed to allocate a o2net_msg!\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\to2net_init_msg(msg, caller_bytes, msg_type, key);\n\n\tvec[0].iov_len = sizeof(struct o2net_msg);\n\tvec[0].iov_base = msg;\n\tmemcpy(&vec[1], caller_vec, caller_veclen * sizeof(struct kvec));\n\n\tret = o2net_prep_nsw(nn, &nsw);\n\tif (ret)\n\t\tgoto out;\n\n\tmsg->msg_num = cpu_to_be32(nsw.ns_id);\n\to2net_set_nst_msg_id(&nst, nsw.ns_id);\n\n\to2net_set_nst_send_time(&nst);\n\n\t/* finally, convert the message header to network byte-order\n\t * and send */\n\tmutex_lock(&sc->sc_send_lock);\n\tret = o2net_send_tcp_msg(sc->sc_sock, vec, veclen,\n\t\t\t\t sizeof(struct o2net_msg) + caller_bytes);\n\tmutex_unlock(&sc->sc_send_lock);\n\tmsglog(msg, \"sending returned %d\\n\", ret);\n\tif (ret < 0) {\n\t\tmlog(0, \"error returned from o2net_send_tcp_msg=%d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\t/* wait on other node's handler */\n\to2net_set_nst_status_time(&nst);\n\twait_event(nsw.ns_wq, o2net_nsw_completed(nn, &nsw));\n\n\to2net_update_send_stats(&nst, sc);\n\n\t/* Note that we avoid overwriting the callers status return\n\t * variable if a system error was reported on the other\n\t * side. Callers beware. */\n\tret = o2net_sys_err_to_errno(nsw.ns_sys_status);\n\tif (status && !ret)\n\t\t*status = nsw.ns_status;\n\n\tmlog(0, \"woken, returning system status %d, user status %d\\n\",\n\t     ret, nsw.ns_status);\nout:\n\to2net_debug_del_nst(&nst); /* must be before dropping sc and node */\n\tif (sc)\n\t\tsc_put(sc);\n\tkfree(vec);\n\tkfree(msg);\n\to2net_complete_nsw(nn, &nsw, 0, 0, 0);\n\treturn ret;\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *o2net_wq;",
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct workqueue_struct *o2net_wq;\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nint o2net_send_message_vec(u32 msg_type, u32 key, struct kvec *caller_vec,\n\t\t\t   size_t caller_veclen, u8 target_node, int *status)\n{\n\tint ret = 0;\n\tstruct o2net_msg *msg = NULL;\n\tsize_t veclen, caller_bytes = 0;\n\tstruct kvec *vec = NULL;\n\tstruct o2net_sock_container *sc = NULL;\n\tstruct o2net_node *nn = o2net_nn_from_num(target_node);\n\tstruct o2net_status_wait nsw = {\n\t\t.ns_node_item = LIST_HEAD_INIT(nsw.ns_node_item),\n\t};\n\tstruct o2net_send_tracking nst;\n\n\to2net_init_nst(&nst, msg_type, key, current, target_node);\n\n\tif (o2net_wq == NULL) {\n\t\tmlog(0, \"attempt to tx without o2netd running\\n\");\n\t\tret = -ESRCH;\n\t\tgoto out;\n\t}\n\n\tif (caller_veclen == 0) {\n\t\tmlog(0, \"bad kvec array length\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tcaller_bytes = iov_length((struct iovec *)caller_vec, caller_veclen);\n\tif (caller_bytes > O2NET_MAX_PAYLOAD_BYTES) {\n\t\tmlog(0, \"total payload len %zu too large\\n\", caller_bytes);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (target_node == o2nm_this_node()) {\n\t\tret = -ELOOP;\n\t\tgoto out;\n\t}\n\n\to2net_debug_add_nst(&nst);\n\n\to2net_set_nst_sock_time(&nst);\n\n\twait_event(nn->nn_sc_wq, o2net_tx_can_proceed(nn, &sc, &ret));\n\tif (ret)\n\t\tgoto out;\n\n\to2net_set_nst_sock_container(&nst, sc);\n\n\tveclen = caller_veclen + 1;\n\tvec = kmalloc(sizeof(struct kvec) * veclen, GFP_ATOMIC);\n\tif (vec == NULL) {\n\t\tmlog(0, \"failed to %zu element kvec!\\n\", veclen);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmsg = kmalloc(sizeof(struct o2net_msg), GFP_ATOMIC);\n\tif (!msg) {\n\t\tmlog(0, \"failed to allocate a o2net_msg!\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\to2net_init_msg(msg, caller_bytes, msg_type, key);\n\n\tvec[0].iov_len = sizeof(struct o2net_msg);\n\tvec[0].iov_base = msg;\n\tmemcpy(&vec[1], caller_vec, caller_veclen * sizeof(struct kvec));\n\n\tret = o2net_prep_nsw(nn, &nsw);\n\tif (ret)\n\t\tgoto out;\n\n\tmsg->msg_num = cpu_to_be32(nsw.ns_id);\n\to2net_set_nst_msg_id(&nst, nsw.ns_id);\n\n\to2net_set_nst_send_time(&nst);\n\n\t/* finally, convert the message header to network byte-order\n\t * and send */\n\tmutex_lock(&sc->sc_send_lock);\n\tret = o2net_send_tcp_msg(sc->sc_sock, vec, veclen,\n\t\t\t\t sizeof(struct o2net_msg) + caller_bytes);\n\tmutex_unlock(&sc->sc_send_lock);\n\tmsglog(msg, \"sending returned %d\\n\", ret);\n\tif (ret < 0) {\n\t\tmlog(0, \"error returned from o2net_send_tcp_msg=%d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\t/* wait on other node's handler */\n\to2net_set_nst_status_time(&nst);\n\twait_event(nsw.ns_wq, o2net_nsw_completed(nn, &nsw));\n\n\to2net_update_send_stats(&nst, sc);\n\n\t/* Note that we avoid overwriting the callers status return\n\t * variable if a system error was reported on the other\n\t * side. Callers beware. */\n\tret = o2net_sys_err_to_errno(nsw.ns_sys_status);\n\tif (status && !ret)\n\t\t*status = nsw.ns_status;\n\n\tmlog(0, \"woken, returning system status %d, user status %d\\n\",\n\t     ret, nsw.ns_status);\nout:\n\to2net_debug_del_nst(&nst); /* must be before dropping sc and node */\n\tif (sc)\n\t\tsc_put(sc);\n\tkfree(vec);\n\tkfree(msg);\n\to2net_complete_nsw(nn, &nsw, 0, 0, 0);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "convert.name",
            "res->lockname.name",
            "convert.namelen"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "flags"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&convert",
            "0",
            "sizeof(struct dlm_convert_lock)"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"%.*s\\n\"",
            "res->lockname.len",
            "res->lockname.name"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic enum dlm_status dlm_send_remote_convert_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t   struct dlm_lock_resource *res,\n\t\t\t\t\t   struct dlm_lock *lock, int flags, int type);\n\nstatic enum dlm_status dlm_send_remote_convert_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t   struct dlm_lock_resource *res,\n\t\t\t\t\t   struct dlm_lock *lock, int flags, int type)\n{\n\tstruct dlm_convert_lock convert;\n\tint tmpret;\n\tenum dlm_status ret;\n\tint status = 0;\n\tstruct kvec vec[2];\n\tsize_t veclen = 1;\n\n\tmlog(0, \"%.*s\\n\", res->lockname.len, res->lockname.name);\n\n\tmemset(&convert, 0, sizeof(struct dlm_convert_lock));\n\tconvert.node_idx = dlm->node_num;\n\tconvert.requested_type = type;\n\tconvert.cookie = lock->ml.cookie;\n\tconvert.namelen = res->lockname.len;\n\tconvert.flags = cpu_to_be32(flags);\n\tmemcpy(convert.name, res->lockname.name, convert.namelen);\n\n\tvec[0].iov_len = sizeof(struct dlm_convert_lock);\n\tvec[0].iov_base = &convert;\n\n\tif (flags & LKM_PUT_LVB) {\n\t\t/* extra data to send if we are updating lvb */\n\t\tvec[1].iov_len = DLM_LVB_LEN;\n\t\tvec[1].iov_base = lock->lksb->lvb;\n\t\tveclen++;\n\t}\n\n\ttmpret = o2net_send_message_vec(DLM_CONVERT_LOCK_MSG, dlm->key,\n\t\t\t\t\tvec, veclen, res->owner, &status);\n\tif (tmpret >= 0) {\n\t\t// successfully sent and received\n\t\tret = status;  // this is already a dlm_status\n\t\tif (ret == DLM_RECOVERING) {\n\t\t\tmlog(0, \"node %u returned DLM_RECOVERING from convert \"\n\t\t\t     \"message!\\n\", res->owner);\n\t\t} else if (ret == DLM_MIGRATING) {\n\t\t\tmlog(0, \"node %u returned DLM_MIGRATING from convert \"\n\t\t\t     \"message!\\n\", res->owner);\n\t\t} else if (ret == DLM_FORWARD) {\n\t\t\tmlog(0, \"node %u returned DLM_FORWARD from convert \"\n\t\t\t     \"message!\\n\", res->owner);\n\t\t} else if (ret != DLM_NORMAL && ret != DLM_NOTQUEUED)\n\t\t\tdlm_error(ret);\n\t} else {\n\t\tmlog(ML_ERROR, \"Error %d when sending message %u (key 0x%x) to \"\n\t\t     \"node %u\\n\", tmpret, DLM_CONVERT_LOCK_MSG, dlm->key,\n\t\t     res->owner);\n\t\tif (dlm_is_host_down(tmpret)) {\n\t\t\t/* instead of logging the same network error over\n\t\t\t * and over, sleep here and wait for the heartbeat\n\t\t\t * to notice the node is dead.  times out after 5s. */\n\t\t\tdlm_wait_for_node_death(dlm, res->owner,\n\t\t\t\t\t\tDLM_NODE_DEATH_WAIT_MAX);\n\t\t\tret = DLM_RECOVERING;\n\t\t\tmlog(0, \"node %u died so returning DLM_RECOVERING \"\n\t\t\t     \"from convert message!\\n\", res->owner);\n\t\t} else {\n\t\t\tret = dlm_err_to_dlm_status(tmpret);\n\t\t}\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "dlmconvert_remote",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmconvert.c",
    "lines": "260-333",
    "snippet": "enum dlm_status dlmconvert_remote(struct dlm_ctxt *dlm,\n\t\t\t\t  struct dlm_lock_resource *res,\n\t\t\t\t  struct dlm_lock *lock, int flags, int type)\n{\n\tenum dlm_status status;\n\n\tmlog(0, \"type=%d, convert_type=%d, busy=%d\\n\", lock->ml.type,\n\t     lock->ml.convert_type, res->state & DLM_LOCK_RES_IN_PROGRESS);\n\n\tspin_lock(&res->spinlock);\n\tif (res->state & DLM_LOCK_RES_RECOVERING) {\n\t\tmlog(0, \"bailing out early since res is RECOVERING \"\n\t\t     \"on secondary queue\\n\");\n\t\t/* __dlm_print_one_lock_resource(res); */\n\t\tstatus = DLM_RECOVERING;\n\t\tgoto bail;\n\t}\n\t/* will exit this call with spinlock held */\n\t__dlm_wait_on_lockres(res);\n\n\tif (lock->ml.convert_type != LKM_IVMODE) {\n\t\t__dlm_print_one_lock_resource(res);\n\t\tmlog(ML_ERROR, \"converting a remote lock that is already \"\n\t\t     \"converting! (cookie=%u:%llu, conv=%d)\\n\",\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)),\n\t\t     lock->ml.convert_type);\n\t\tstatus = DLM_DENIED;\n\t\tgoto bail;\n\t}\n\tres->state |= DLM_LOCK_RES_IN_PROGRESS;\n\t/* move lock to local convert queue */\n\t/* do not alter lock refcount.  switching lists. */\n\tlist_move_tail(&lock->list, &res->converting);\n\tlock->convert_pending = 1;\n\tlock->ml.convert_type = type;\n\n\tif (flags & LKM_VALBLK) {\n\t\tif (lock->ml.type == LKM_EXMODE) {\n\t\t\tflags |= LKM_PUT_LVB;\n\t\t\tlock->lksb->flags |= DLM_LKSB_PUT_LVB;\n\t\t} else {\n\t\t\tif (lock->ml.convert_type == LKM_NLMODE)\n\t\t\t\tflags &= ~LKM_VALBLK;\n\t\t\telse {\n\t\t\t\tflags |= LKM_GET_LVB;\n\t\t\t\tlock->lksb->flags |= DLM_LKSB_GET_LVB;\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock(&res->spinlock);\n\n\t/* no locks held here.\n\t * need to wait for a reply as to whether it got queued or not. */\n\tstatus = dlm_send_remote_convert_request(dlm, res, lock, flags, type);\n\n\tspin_lock(&res->spinlock);\n\tres->state &= ~DLM_LOCK_RES_IN_PROGRESS;\n\tlock->convert_pending = 0;\n\t/* if it failed, move it back to granted queue */\n\tif (status != DLM_NORMAL) {\n\t\tif (status != DLM_NOTQUEUED)\n\t\t\tdlm_error(status);\n\t\tdlm_revert_pending_convert(res, lock);\n\t}\nbail:\n\tspin_unlock(&res->spinlock);\n\n\t/* TODO: should this be a wake_one? */\n\t/* wake up any IN_PROGRESS waiters */\n\twake_up(&res->wq);\n\n\treturn status;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmconvert.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static enum dlm_status dlm_send_remote_convert_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t   struct dlm_lock_resource *res,\n\t\t\t\t\t   struct dlm_lock *lock, int flags, int type);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&res->wq"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&res->spinlock"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_revert_pending_convert",
          "args": [
            "res",
            "lock"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_revert_pending_convert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmconvert.c",
          "lines": "244-251",
          "snippet": "void dlm_revert_pending_convert(struct dlm_lock_resource *res,\n\t\t\t\tstruct dlm_lock *lock)\n{\n\t/* do not alter lock refcount.  switching lists. */\n\tlist_move_tail(&lock->list, &res->granted);\n\tlock->ml.convert_type = LKM_IVMODE;\n\tlock->lksb->flags &= ~(DLM_LKSB_GET_LVB|DLM_LKSB_PUT_LVB);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmconvert.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nvoid dlm_revert_pending_convert(struct dlm_lock_resource *res,\n\t\t\t\tstruct dlm_lock *lock)\n{\n\t/* do not alter lock refcount.  switching lists. */\n\tlist_move_tail(&lock->list, &res->granted);\n\tlock->ml.convert_type = LKM_IVMODE;\n\tlock->lksb->flags &= ~(DLM_LKSB_GET_LVB|DLM_LKSB_PUT_LVB);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_error",
          "args": [
            "status"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "user_recover_from_dlm_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
          "lines": "99-104",
          "snippet": "static inline void user_recover_from_dlm_error(struct user_lock_res *lockres)\n{\n\tspin_lock(&lockres->l_lock);\n\tlockres->l_flags &= ~USER_LOCK_BUSY;\n\tspin_unlock(&lockres->l_lock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"userdlm.h\"",
            "#include \"stackglue.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nstatic inline void user_recover_from_dlm_error(struct user_lock_res *lockres)\n{\n\tspin_lock(&lockres->l_lock);\n\tlockres->l_flags &= ~USER_LOCK_BUSY;\n\tspin_unlock(&lockres->l_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&res->spinlock"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_send_remote_convert_request",
          "args": [
            "dlm",
            "res",
            "lock",
            "flags",
            "type"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_send_remote_convert_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmconvert.c",
          "lines": "342-408",
          "snippet": "static enum dlm_status dlm_send_remote_convert_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t   struct dlm_lock_resource *res,\n\t\t\t\t\t   struct dlm_lock *lock, int flags, int type)\n{\n\tstruct dlm_convert_lock convert;\n\tint tmpret;\n\tenum dlm_status ret;\n\tint status = 0;\n\tstruct kvec vec[2];\n\tsize_t veclen = 1;\n\n\tmlog(0, \"%.*s\\n\", res->lockname.len, res->lockname.name);\n\n\tmemset(&convert, 0, sizeof(struct dlm_convert_lock));\n\tconvert.node_idx = dlm->node_num;\n\tconvert.requested_type = type;\n\tconvert.cookie = lock->ml.cookie;\n\tconvert.namelen = res->lockname.len;\n\tconvert.flags = cpu_to_be32(flags);\n\tmemcpy(convert.name, res->lockname.name, convert.namelen);\n\n\tvec[0].iov_len = sizeof(struct dlm_convert_lock);\n\tvec[0].iov_base = &convert;\n\n\tif (flags & LKM_PUT_LVB) {\n\t\t/* extra data to send if we are updating lvb */\n\t\tvec[1].iov_len = DLM_LVB_LEN;\n\t\tvec[1].iov_base = lock->lksb->lvb;\n\t\tveclen++;\n\t}\n\n\ttmpret = o2net_send_message_vec(DLM_CONVERT_LOCK_MSG, dlm->key,\n\t\t\t\t\tvec, veclen, res->owner, &status);\n\tif (tmpret >= 0) {\n\t\t// successfully sent and received\n\t\tret = status;  // this is already a dlm_status\n\t\tif (ret == DLM_RECOVERING) {\n\t\t\tmlog(0, \"node %u returned DLM_RECOVERING from convert \"\n\t\t\t     \"message!\\n\", res->owner);\n\t\t} else if (ret == DLM_MIGRATING) {\n\t\t\tmlog(0, \"node %u returned DLM_MIGRATING from convert \"\n\t\t\t     \"message!\\n\", res->owner);\n\t\t} else if (ret == DLM_FORWARD) {\n\t\t\tmlog(0, \"node %u returned DLM_FORWARD from convert \"\n\t\t\t     \"message!\\n\", res->owner);\n\t\t} else if (ret != DLM_NORMAL && ret != DLM_NOTQUEUED)\n\t\t\tdlm_error(ret);\n\t} else {\n\t\tmlog(ML_ERROR, \"Error %d when sending message %u (key 0x%x) to \"\n\t\t     \"node %u\\n\", tmpret, DLM_CONVERT_LOCK_MSG, dlm->key,\n\t\t     res->owner);\n\t\tif (dlm_is_host_down(tmpret)) {\n\t\t\t/* instead of logging the same network error over\n\t\t\t * and over, sleep here and wait for the heartbeat\n\t\t\t * to notice the node is dead.  times out after 5s. */\n\t\t\tdlm_wait_for_node_death(dlm, res->owner,\n\t\t\t\t\t\tDLM_NODE_DEATH_WAIT_MAX);\n\t\t\tret = DLM_RECOVERING;\n\t\t\tmlog(0, \"node %u died so returning DLM_RECOVERING \"\n\t\t\t     \"from convert message!\\n\", res->owner);\n\t\t} else {\n\t\t\tret = dlm_err_to_dlm_status(tmpret);\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmconvert.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static enum dlm_status dlm_send_remote_convert_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t   struct dlm_lock_resource *res,\n\t\t\t\t\t   struct dlm_lock *lock, int flags, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic enum dlm_status dlm_send_remote_convert_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t   struct dlm_lock_resource *res,\n\t\t\t\t\t   struct dlm_lock *lock, int flags, int type);\n\nstatic enum dlm_status dlm_send_remote_convert_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t   struct dlm_lock_resource *res,\n\t\t\t\t\t   struct dlm_lock *lock, int flags, int type)\n{\n\tstruct dlm_convert_lock convert;\n\tint tmpret;\n\tenum dlm_status ret;\n\tint status = 0;\n\tstruct kvec vec[2];\n\tsize_t veclen = 1;\n\n\tmlog(0, \"%.*s\\n\", res->lockname.len, res->lockname.name);\n\n\tmemset(&convert, 0, sizeof(struct dlm_convert_lock));\n\tconvert.node_idx = dlm->node_num;\n\tconvert.requested_type = type;\n\tconvert.cookie = lock->ml.cookie;\n\tconvert.namelen = res->lockname.len;\n\tconvert.flags = cpu_to_be32(flags);\n\tmemcpy(convert.name, res->lockname.name, convert.namelen);\n\n\tvec[0].iov_len = sizeof(struct dlm_convert_lock);\n\tvec[0].iov_base = &convert;\n\n\tif (flags & LKM_PUT_LVB) {\n\t\t/* extra data to send if we are updating lvb */\n\t\tvec[1].iov_len = DLM_LVB_LEN;\n\t\tvec[1].iov_base = lock->lksb->lvb;\n\t\tveclen++;\n\t}\n\n\ttmpret = o2net_send_message_vec(DLM_CONVERT_LOCK_MSG, dlm->key,\n\t\t\t\t\tvec, veclen, res->owner, &status);\n\tif (tmpret >= 0) {\n\t\t// successfully sent and received\n\t\tret = status;  // this is already a dlm_status\n\t\tif (ret == DLM_RECOVERING) {\n\t\t\tmlog(0, \"node %u returned DLM_RECOVERING from convert \"\n\t\t\t     \"message!\\n\", res->owner);\n\t\t} else if (ret == DLM_MIGRATING) {\n\t\t\tmlog(0, \"node %u returned DLM_MIGRATING from convert \"\n\t\t\t     \"message!\\n\", res->owner);\n\t\t} else if (ret == DLM_FORWARD) {\n\t\t\tmlog(0, \"node %u returned DLM_FORWARD from convert \"\n\t\t\t     \"message!\\n\", res->owner);\n\t\t} else if (ret != DLM_NORMAL && ret != DLM_NOTQUEUED)\n\t\t\tdlm_error(ret);\n\t} else {\n\t\tmlog(ML_ERROR, \"Error %d when sending message %u (key 0x%x) to \"\n\t\t     \"node %u\\n\", tmpret, DLM_CONVERT_LOCK_MSG, dlm->key,\n\t\t     res->owner);\n\t\tif (dlm_is_host_down(tmpret)) {\n\t\t\t/* instead of logging the same network error over\n\t\t\t * and over, sleep here and wait for the heartbeat\n\t\t\t * to notice the node is dead.  times out after 5s. */\n\t\t\tdlm_wait_for_node_death(dlm, res->owner,\n\t\t\t\t\t\tDLM_NODE_DEATH_WAIT_MAX);\n\t\t\tret = DLM_RECOVERING;\n\t\t\tmlog(0, \"node %u died so returning DLM_RECOVERING \"\n\t\t\t     \"from convert message!\\n\", res->owner);\n\t\t} else {\n\t\t\tret = dlm_err_to_dlm_status(tmpret);\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&lock->list",
            "&res->converting"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"converting a remote lock that is already \"\n\t\t     \"converting! (cookie=%u:%llu, conv=%d)\\n\"",
            "dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie))",
            "dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie))",
            "lock->ml.convert_type"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_get_lock_cookie_seq",
          "args": [
            "be64_to_cpu(lock->ml.cookie)"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_get_lock_cookie_seq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "821-826",
          "snippet": "static inline unsigned long long dlm_get_lock_cookie_seq(u64 cookie)\n{\n\tunsigned long long ret;\n\tret = ((unsigned long long)cookie) & 0x00ffffffffffffffULL;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline unsigned long long dlm_get_lock_cookie_seq(u64 cookie)\n{\n\tunsigned long long ret;\n\tret = ((unsigned long long)cookie) & 0x00ffffffffffffffULL;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "lock->ml.cookie"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_get_lock_cookie_node",
          "args": [
            "be64_to_cpu(lock->ml.cookie)"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_get_lock_cookie_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "813-819",
          "snippet": "static inline u8 dlm_get_lock_cookie_node(u64 cookie)\n{\n\tu8 ret;\n\tcookie >>= 56;\n\tret = (u8)(cookie & 0xffULL);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline u8 dlm_get_lock_cookie_node(u64 cookie)\n{\n\tu8 ret;\n\tcookie >>= 56;\n\tret = (u8)(cookie & 0xffULL);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "lock->ml.cookie"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__dlm_print_one_lock_resource",
          "args": [
            "res"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_print_one_lock_resource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdebug.c",
          "lines": "97-131",
          "snippet": "void __dlm_print_one_lock_resource(struct dlm_lock_resource *res)\n{\n\tstruct dlm_lock *lock;\n\tchar buf[DLM_LOCKID_NAME_MAX];\n\n\tassert_spin_locked(&res->spinlock);\n\n\tstringify_lockname(res->lockname.name, res->lockname.len,\n\t\t\t   buf, sizeof(buf));\n\tprintk(\"lockres: %s, owner=%u, state=%u\\n\",\n\t       buf, res->owner, res->state);\n\tprintk(\"  last used: %lu, refcnt: %u, on purge list: %s\\n\",\n\t       res->last_used, atomic_read(&res->refs.refcount),\n\t       list_empty(&res->purge) ? \"no\" : \"yes\");\n\tprintk(\"  on dirty list: %s, on reco list: %s, \"\n\t       \"migrating pending: %s\\n\",\n\t       list_empty(&res->dirty) ? \"no\" : \"yes\",\n\t       list_empty(&res->recovering) ? \"no\" : \"yes\",\n\t       res->migration_pending ? \"yes\" : \"no\");\n\tprintk(\"  inflight locks: %d, asts reserved: %d\\n\",\n\t       res->inflight_locks, atomic_read(&res->asts_reserved));\n\tdlm_print_lockres_refmap(res);\n\tprintk(\"  granted queue:\\n\");\n\tlist_for_each_entry(lock, &res->granted, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  converting queue:\\n\");\n\tlist_for_each_entry(lock, &res->converting, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  blocked queue:\\n\");\n\tlist_for_each_entry(lock, &res->blocked, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int stringify_lockname(const char *lockname, int locklen, char *buf,\n\t\t\t      int len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/spinlock.h>\n#include <linux/sysctl.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int stringify_lockname(const char *lockname, int locklen, char *buf,\n\t\t\t      int len);\n\nvoid __dlm_print_one_lock_resource(struct dlm_lock_resource *res)\n{\n\tstruct dlm_lock *lock;\n\tchar buf[DLM_LOCKID_NAME_MAX];\n\n\tassert_spin_locked(&res->spinlock);\n\n\tstringify_lockname(res->lockname.name, res->lockname.len,\n\t\t\t   buf, sizeof(buf));\n\tprintk(\"lockres: %s, owner=%u, state=%u\\n\",\n\t       buf, res->owner, res->state);\n\tprintk(\"  last used: %lu, refcnt: %u, on purge list: %s\\n\",\n\t       res->last_used, atomic_read(&res->refs.refcount),\n\t       list_empty(&res->purge) ? \"no\" : \"yes\");\n\tprintk(\"  on dirty list: %s, on reco list: %s, \"\n\t       \"migrating pending: %s\\n\",\n\t       list_empty(&res->dirty) ? \"no\" : \"yes\",\n\t       list_empty(&res->recovering) ? \"no\" : \"yes\",\n\t       res->migration_pending ? \"yes\" : \"no\");\n\tprintk(\"  inflight locks: %d, asts reserved: %d\\n\",\n\t       res->inflight_locks, atomic_read(&res->asts_reserved));\n\tdlm_print_lockres_refmap(res);\n\tprintk(\"  granted queue:\\n\");\n\tlist_for_each_entry(lock, &res->granted, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  converting queue:\\n\");\n\tlist_for_each_entry(lock, &res->converting, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  blocked queue:\\n\");\n\tlist_for_each_entry(lock, &res->blocked, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_wait_on_lockres",
          "args": [
            "res"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_wait_on_lockres",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "1020-1025",
          "snippet": "static inline void __dlm_wait_on_lockres(struct dlm_lock_resource *res)\n{\n\t__dlm_wait_on_lockres_flags(res, (DLM_LOCK_RES_IN_PROGRESS|\n\t\t\t\t    \t  DLM_LOCK_RES_RECOVERING|\n\t\t\t\t\t  DLM_LOCK_RES_MIGRATING));\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [
            "#define DLM_LOCK_RES_MIGRATING            0x00000020",
            "#define DLM_LOCK_RES_IN_PROGRESS          0x00000010",
            "#define DLM_LOCK_RES_RECOVERING           0x00000002"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\n#define DLM_LOCK_RES_MIGRATING            0x00000020\n#define DLM_LOCK_RES_IN_PROGRESS          0x00000010\n#define DLM_LOCK_RES_RECOVERING           0x00000002\n\nstatic inline void __dlm_wait_on_lockres(struct dlm_lock_resource *res)\n{\n\t__dlm_wait_on_lockres_flags(res, (DLM_LOCK_RES_IN_PROGRESS|\n\t\t\t\t    \t  DLM_LOCK_RES_RECOVERING|\n\t\t\t\t\t  DLM_LOCK_RES_MIGRATING));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"bailing out early since res is RECOVERING \"\n\t\t     \"on secondary queue\\n\""
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"type=%d, convert_type=%d, busy=%d\\n\"",
            "lock->ml.type",
            "lock->ml.convert_type",
            "res->state & DLM_LOCK_RES_IN_PROGRESS"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic enum dlm_status dlm_send_remote_convert_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t   struct dlm_lock_resource *res,\n\t\t\t\t\t   struct dlm_lock *lock, int flags, int type);\n\nenum dlm_status dlmconvert_remote(struct dlm_ctxt *dlm,\n\t\t\t\t  struct dlm_lock_resource *res,\n\t\t\t\t  struct dlm_lock *lock, int flags, int type)\n{\n\tenum dlm_status status;\n\n\tmlog(0, \"type=%d, convert_type=%d, busy=%d\\n\", lock->ml.type,\n\t     lock->ml.convert_type, res->state & DLM_LOCK_RES_IN_PROGRESS);\n\n\tspin_lock(&res->spinlock);\n\tif (res->state & DLM_LOCK_RES_RECOVERING) {\n\t\tmlog(0, \"bailing out early since res is RECOVERING \"\n\t\t     \"on secondary queue\\n\");\n\t\t/* __dlm_print_one_lock_resource(res); */\n\t\tstatus = DLM_RECOVERING;\n\t\tgoto bail;\n\t}\n\t/* will exit this call with spinlock held */\n\t__dlm_wait_on_lockres(res);\n\n\tif (lock->ml.convert_type != LKM_IVMODE) {\n\t\t__dlm_print_one_lock_resource(res);\n\t\tmlog(ML_ERROR, \"converting a remote lock that is already \"\n\t\t     \"converting! (cookie=%u:%llu, conv=%d)\\n\",\n\t\t     dlm_get_lock_cookie_node(be64_to_cpu(lock->ml.cookie)),\n\t\t     dlm_get_lock_cookie_seq(be64_to_cpu(lock->ml.cookie)),\n\t\t     lock->ml.convert_type);\n\t\tstatus = DLM_DENIED;\n\t\tgoto bail;\n\t}\n\tres->state |= DLM_LOCK_RES_IN_PROGRESS;\n\t/* move lock to local convert queue */\n\t/* do not alter lock refcount.  switching lists. */\n\tlist_move_tail(&lock->list, &res->converting);\n\tlock->convert_pending = 1;\n\tlock->ml.convert_type = type;\n\n\tif (flags & LKM_VALBLK) {\n\t\tif (lock->ml.type == LKM_EXMODE) {\n\t\t\tflags |= LKM_PUT_LVB;\n\t\t\tlock->lksb->flags |= DLM_LKSB_PUT_LVB;\n\t\t} else {\n\t\t\tif (lock->ml.convert_type == LKM_NLMODE)\n\t\t\t\tflags &= ~LKM_VALBLK;\n\t\t\telse {\n\t\t\t\tflags |= LKM_GET_LVB;\n\t\t\t\tlock->lksb->flags |= DLM_LKSB_GET_LVB;\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock(&res->spinlock);\n\n\t/* no locks held here.\n\t * need to wait for a reply as to whether it got queued or not. */\n\tstatus = dlm_send_remote_convert_request(dlm, res, lock, flags, type);\n\n\tspin_lock(&res->spinlock);\n\tres->state &= ~DLM_LOCK_RES_IN_PROGRESS;\n\tlock->convert_pending = 0;\n\t/* if it failed, move it back to granted queue */\n\tif (status != DLM_NORMAL) {\n\t\tif (status != DLM_NOTQUEUED)\n\t\t\tdlm_error(status);\n\t\tdlm_revert_pending_convert(res, lock);\n\t}\nbail:\n\tspin_unlock(&res->spinlock);\n\n\t/* TODO: should this be a wake_one? */\n\t/* wake up any IN_PROGRESS waiters */\n\twake_up(&res->wq);\n\n\treturn status;\n}"
  },
  {
    "function_name": "dlm_revert_pending_convert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmconvert.c",
    "lines": "244-251",
    "snippet": "void dlm_revert_pending_convert(struct dlm_lock_resource *res,\n\t\t\t\tstruct dlm_lock *lock)\n{\n\t/* do not alter lock refcount.  switching lists. */\n\tlist_move_tail(&lock->list, &res->granted);\n\tlock->ml.convert_type = LKM_IVMODE;\n\tlock->lksb->flags &= ~(DLM_LKSB_GET_LVB|DLM_LKSB_PUT_LVB);\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmconvert.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&lock->list",
            "&res->granted"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nvoid dlm_revert_pending_convert(struct dlm_lock_resource *res,\n\t\t\t\tstruct dlm_lock *lock)\n{\n\t/* do not alter lock refcount.  switching lists. */\n\tlist_move_tail(&lock->list, &res->granted);\n\tlock->ml.convert_type = LKM_IVMODE;\n\tlock->lksb->flags &= ~(DLM_LKSB_GET_LVB|DLM_LKSB_PUT_LVB);\n}"
  },
  {
    "function_name": "__dlmconvert_master",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmconvert.c",
    "lines": "119-242",
    "snippet": "static enum dlm_status __dlmconvert_master(struct dlm_ctxt *dlm,\n\t\t\t\t\t   struct dlm_lock_resource *res,\n\t\t\t\t\t   struct dlm_lock *lock, int flags,\n\t\t\t\t\t   int type, int *call_ast,\n\t\t\t\t\t   int *kick_thread)\n{\n\tenum dlm_status status = DLM_NORMAL;\n\tstruct dlm_lock *tmplock=NULL;\n\n\tassert_spin_locked(&res->spinlock);\n\n\tmlog(0, \"type=%d, convert_type=%d, new convert_type=%d\\n\",\n\t     lock->ml.type, lock->ml.convert_type, type);\n\n\tspin_lock(&lock->spinlock);\n\n\t/* already converting? */\n\tif (lock->ml.convert_type != LKM_IVMODE) {\n\t\tmlog(ML_ERROR, \"attempted to convert a lock with a lock \"\n\t\t     \"conversion pending\\n\");\n\t\tstatus = DLM_DENIED;\n\t\tgoto unlock_exit;\n\t}\n\n\t/* must be on grant queue to convert */\n\tif (!dlm_lock_on_list(&res->granted, lock)) {\n\t\tmlog(ML_ERROR, \"attempted to convert a lock not on grant \"\n\t\t     \"queue\\n\");\n\t\tstatus = DLM_DENIED;\n\t\tgoto unlock_exit;\n\t}\n\n\tif (flags & LKM_VALBLK) {\n\t\tswitch (lock->ml.type) {\n\t\t\tcase LKM_EXMODE:\n\t\t\t\t/* EX + LKM_VALBLK + convert == set lvb */\n\t\t\t\tmlog(0, \"will set lvb: converting %s->%s\\n\",\n\t\t\t\t     dlm_lock_mode_name(lock->ml.type),\n\t\t\t\t     dlm_lock_mode_name(type));\n\t\t\t\tlock->lksb->flags |= DLM_LKSB_PUT_LVB;\n\t\t\t\tbreak;\n\t\t\tcase LKM_PRMODE:\n\t\t\tcase LKM_NLMODE:\n\t\t\t\t/* refetch if new level is not NL */\n\t\t\t\tif (type > LKM_NLMODE) {\n\t\t\t\t\tmlog(0, \"will fetch new value into \"\n\t\t\t\t\t     \"lvb: converting %s->%s\\n\",\n\t\t\t\t\t     dlm_lock_mode_name(lock->ml.type),\n\t\t\t\t\t     dlm_lock_mode_name(type));\n\t\t\t\t\tlock->lksb->flags |= DLM_LKSB_GET_LVB;\n\t\t\t\t} else {\n\t\t\t\t\tmlog(0, \"will NOT fetch new value \"\n\t\t\t\t\t     \"into lvb: converting %s->%s\\n\",\n\t\t\t\t\t     dlm_lock_mode_name(lock->ml.type),\n\t\t\t\t\t     dlm_lock_mode_name(type));\n\t\t\t\t\tflags &= ~(LKM_VALBLK);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\n\t/* in-place downconvert? */\n\tif (type <= lock->ml.type)\n\t\tgoto grant;\n\n\t/* upconvert from here on */\n\tstatus = DLM_NORMAL;\n\tlist_for_each_entry(tmplock, &res->granted, list) {\n\t\tif (tmplock == lock)\n\t\t\tcontinue;\n\t\tif (!dlm_lock_compatible(tmplock->ml.type, type))\n\t\t\tgoto switch_queues;\n\t}\n\n\tlist_for_each_entry(tmplock, &res->converting, list) {\n\t\tif (!dlm_lock_compatible(tmplock->ml.type, type))\n\t\t\tgoto switch_queues;\n\t\t/* existing conversion requests take precedence */\n\t\tif (!dlm_lock_compatible(tmplock->ml.convert_type, type))\n\t\t\tgoto switch_queues;\n\t}\n\n\t/* fall thru to grant */\n\ngrant:\n\tmlog(0, \"res %.*s, granting %s lock\\n\", res->lockname.len,\n\t     res->lockname.name, dlm_lock_mode_name(type));\n\t/* immediately grant the new lock type */\n\tlock->lksb->status = DLM_NORMAL;\n\tif (lock->ml.node == dlm->node_num)\n\t\tmlog(0, \"doing in-place convert for nonlocal lock\\n\");\n\tlock->ml.type = type;\n\tif (lock->lksb->flags & DLM_LKSB_PUT_LVB)\n\t\tmemcpy(res->lvb, lock->lksb->lvb, DLM_LVB_LEN);\n\n\tstatus = DLM_NORMAL;\n\t*call_ast = 1;\n\tgoto unlock_exit;\n\nswitch_queues:\n\tif (flags & LKM_NOQUEUE) {\n\t\tmlog(0, \"failed to convert NOQUEUE lock %.*s from \"\n\t\t     \"%d to %d...\\n\", res->lockname.len, res->lockname.name,\n\t\t     lock->ml.type, type);\n\t\tstatus = DLM_NOTQUEUED;\n\t\tgoto unlock_exit;\n\t}\n\tmlog(0, \"res %.*s, queueing...\\n\", res->lockname.len,\n\t     res->lockname.name);\n\n\tlock->ml.convert_type = type;\n\t/* do not alter lock refcount.  switching lists. */\n\tlist_move_tail(&lock->list, &res->converting);\n\nunlock_exit:\n\tspin_unlock(&lock->spinlock);\n\tif (status == DLM_DENIED) {\n\t\t__dlm_print_one_lock_resource(res);\n\t}\n\tif (status == DLM_NORMAL)\n\t\t*kick_thread = 1;\n\treturn status;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmconvert.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static enum dlm_status __dlmconvert_master(struct dlm_ctxt *dlm,\n\t\t\t\t\t   struct dlm_lock_resource *res,\n\t\t\t\t\t   struct dlm_lock *lock, int flags,\n\t\t\t\t\t   int type, int *call_ast,\n\t\t\t\t\t   int *kick_thread);",
      "static enum dlm_status dlm_send_remote_convert_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t   struct dlm_lock_resource *res,\n\t\t\t\t\t   struct dlm_lock *lock, int flags, int type);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__dlm_print_one_lock_resource",
          "args": [
            "res"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_print_one_lock_resource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmdebug.c",
          "lines": "97-131",
          "snippet": "void __dlm_print_one_lock_resource(struct dlm_lock_resource *res)\n{\n\tstruct dlm_lock *lock;\n\tchar buf[DLM_LOCKID_NAME_MAX];\n\n\tassert_spin_locked(&res->spinlock);\n\n\tstringify_lockname(res->lockname.name, res->lockname.len,\n\t\t\t   buf, sizeof(buf));\n\tprintk(\"lockres: %s, owner=%u, state=%u\\n\",\n\t       buf, res->owner, res->state);\n\tprintk(\"  last used: %lu, refcnt: %u, on purge list: %s\\n\",\n\t       res->last_used, atomic_read(&res->refs.refcount),\n\t       list_empty(&res->purge) ? \"no\" : \"yes\");\n\tprintk(\"  on dirty list: %s, on reco list: %s, \"\n\t       \"migrating pending: %s\\n\",\n\t       list_empty(&res->dirty) ? \"no\" : \"yes\",\n\t       list_empty(&res->recovering) ? \"no\" : \"yes\",\n\t       res->migration_pending ? \"yes\" : \"no\");\n\tprintk(\"  inflight locks: %d, asts reserved: %d\\n\",\n\t       res->inflight_locks, atomic_read(&res->asts_reserved));\n\tdlm_print_lockres_refmap(res);\n\tprintk(\"  granted queue:\\n\");\n\tlist_for_each_entry(lock, &res->granted, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  converting queue:\\n\");\n\tlist_for_each_entry(lock, &res->converting, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  blocked queue:\\n\");\n\tlist_for_each_entry(lock, &res->blocked, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/export.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int stringify_lockname(const char *lockname, int locklen, char *buf,\n\t\t\t      int len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/spinlock.h>\n#include <linux/sysctl.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int stringify_lockname(const char *lockname, int locklen, char *buf,\n\t\t\t      int len);\n\nvoid __dlm_print_one_lock_resource(struct dlm_lock_resource *res)\n{\n\tstruct dlm_lock *lock;\n\tchar buf[DLM_LOCKID_NAME_MAX];\n\n\tassert_spin_locked(&res->spinlock);\n\n\tstringify_lockname(res->lockname.name, res->lockname.len,\n\t\t\t   buf, sizeof(buf));\n\tprintk(\"lockres: %s, owner=%u, state=%u\\n\",\n\t       buf, res->owner, res->state);\n\tprintk(\"  last used: %lu, refcnt: %u, on purge list: %s\\n\",\n\t       res->last_used, atomic_read(&res->refs.refcount),\n\t       list_empty(&res->purge) ? \"no\" : \"yes\");\n\tprintk(\"  on dirty list: %s, on reco list: %s, \"\n\t       \"migrating pending: %s\\n\",\n\t       list_empty(&res->dirty) ? \"no\" : \"yes\",\n\t       list_empty(&res->recovering) ? \"no\" : \"yes\",\n\t       res->migration_pending ? \"yes\" : \"no\");\n\tprintk(\"  inflight locks: %d, asts reserved: %d\\n\",\n\t       res->inflight_locks, atomic_read(&res->asts_reserved));\n\tdlm_print_lockres_refmap(res);\n\tprintk(\"  granted queue:\\n\");\n\tlist_for_each_entry(lock, &res->granted, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  converting queue:\\n\");\n\tlist_for_each_entry(lock, &res->converting, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n\tprintk(\"  blocked queue:\\n\");\n\tlist_for_each_entry(lock, &res->blocked, list) {\n\t\t__dlm_print_lock(lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&lock->spinlock"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&lock->list",
            "&res->converting"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"res %.*s, queueing...\\n\"",
            "res->lockname.len",
            "res->lockname.name"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"failed to convert NOQUEUE lock %.*s from \"\n\t\t     \"%d to %d...\\n\"",
            "res->lockname.len",
            "res->lockname.name",
            "lock->ml.type",
            "type"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "res->lvb",
            "lock->lksb->lvb",
            "DLM_LVB_LEN"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"doing in-place convert for nonlocal lock\\n\""
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"res %.*s, granting %s lock\\n\"",
            "res->lockname.len",
            "res->lockname.name",
            "dlm_lock_mode_name(type)"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_lock_mode_name",
          "args": [
            "type"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lock_mode_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "1050-1061",
          "snippet": "static inline const char * dlm_lock_mode_name(int mode)\n{\n\tswitch (mode) {\n\t\tcase LKM_EXMODE:\n\t\t\treturn \"EX\";\n\t\tcase LKM_PRMODE:\n\t\t\treturn \"PR\";\n\t\tcase LKM_NLMODE:\n\t\t\treturn \"NL\";\n\t}\n\treturn \"UNKNOWN\";\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline const char * dlm_lock_mode_name(int mode)\n{\n\tswitch (mode) {\n\t\tcase LKM_EXMODE:\n\t\t\treturn \"EX\";\n\t\tcase LKM_PRMODE:\n\t\t\treturn \"PR\";\n\t\tcase LKM_NLMODE:\n\t\t\treturn \"NL\";\n\t}\n\treturn \"UNKNOWN\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lock_compatible",
          "args": [
            "tmplock->ml.convert_type",
            "type"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lock_compatible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "1064-1080",
          "snippet": "static inline int dlm_lock_compatible(int existing, int request)\n{\n\t/* NO_LOCK compatible with all */\n\tif (request == LKM_NLMODE ||\n\t    existing == LKM_NLMODE)\n\t\treturn 1;\n\n\t/* EX incompatible with all non-NO_LOCK */\n\tif (request == LKM_EXMODE)\n\t\treturn 0;\n\n\t/* request must be PR, which is compatible with PR */\n\tif (existing == LKM_PRMODE)\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline int dlm_lock_compatible(int existing, int request)\n{\n\t/* NO_LOCK compatible with all */\n\tif (request == LKM_NLMODE ||\n\t    existing == LKM_NLMODE)\n\t\treturn 1;\n\n\t/* EX incompatible with all non-NO_LOCK */\n\tif (request == LKM_EXMODE)\n\t\treturn 0;\n\n\t/* request must be PR, which is compatible with PR */\n\tif (existing == LKM_PRMODE)\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tmplock",
            "&res->converting",
            "list"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tmplock",
            "&res->granted",
            "list"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_lock_on_list",
          "args": [
            "&res->granted",
            "lock"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lock_on_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "1082-1092",
          "snippet": "static inline int dlm_lock_on_list(struct list_head *head,\n\t\t\t\t   struct dlm_lock *lock)\n{\n\tstruct dlm_lock *tmplock;\n\n\tlist_for_each_entry(tmplock, head, list) {\n\t\tif (tmplock == lock)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\nstatic inline int dlm_lock_on_list(struct list_head *head,\n\t\t\t\t   struct dlm_lock *lock)\n{\n\tstruct dlm_lock *tmplock;\n\n\tlist_for_each_entry(tmplock, head, list) {\n\t\tif (tmplock == lock)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&lock->spinlock"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "0",
            "\"type=%d, convert_type=%d, new convert_type=%d\\n\"",
            "lock->ml.type",
            "lock->ml.convert_type",
            "type"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&res->spinlock"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic enum dlm_status __dlmconvert_master(struct dlm_ctxt *dlm,\n\t\t\t\t\t   struct dlm_lock_resource *res,\n\t\t\t\t\t   struct dlm_lock *lock, int flags,\n\t\t\t\t\t   int type, int *call_ast,\n\t\t\t\t\t   int *kick_thread);\nstatic enum dlm_status dlm_send_remote_convert_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t   struct dlm_lock_resource *res,\n\t\t\t\t\t   struct dlm_lock *lock, int flags, int type);\n\nstatic enum dlm_status __dlmconvert_master(struct dlm_ctxt *dlm,\n\t\t\t\t\t   struct dlm_lock_resource *res,\n\t\t\t\t\t   struct dlm_lock *lock, int flags,\n\t\t\t\t\t   int type, int *call_ast,\n\t\t\t\t\t   int *kick_thread)\n{\n\tenum dlm_status status = DLM_NORMAL;\n\tstruct dlm_lock *tmplock=NULL;\n\n\tassert_spin_locked(&res->spinlock);\n\n\tmlog(0, \"type=%d, convert_type=%d, new convert_type=%d\\n\",\n\t     lock->ml.type, lock->ml.convert_type, type);\n\n\tspin_lock(&lock->spinlock);\n\n\t/* already converting? */\n\tif (lock->ml.convert_type != LKM_IVMODE) {\n\t\tmlog(ML_ERROR, \"attempted to convert a lock with a lock \"\n\t\t     \"conversion pending\\n\");\n\t\tstatus = DLM_DENIED;\n\t\tgoto unlock_exit;\n\t}\n\n\t/* must be on grant queue to convert */\n\tif (!dlm_lock_on_list(&res->granted, lock)) {\n\t\tmlog(ML_ERROR, \"attempted to convert a lock not on grant \"\n\t\t     \"queue\\n\");\n\t\tstatus = DLM_DENIED;\n\t\tgoto unlock_exit;\n\t}\n\n\tif (flags & LKM_VALBLK) {\n\t\tswitch (lock->ml.type) {\n\t\t\tcase LKM_EXMODE:\n\t\t\t\t/* EX + LKM_VALBLK + convert == set lvb */\n\t\t\t\tmlog(0, \"will set lvb: converting %s->%s\\n\",\n\t\t\t\t     dlm_lock_mode_name(lock->ml.type),\n\t\t\t\t     dlm_lock_mode_name(type));\n\t\t\t\tlock->lksb->flags |= DLM_LKSB_PUT_LVB;\n\t\t\t\tbreak;\n\t\t\tcase LKM_PRMODE:\n\t\t\tcase LKM_NLMODE:\n\t\t\t\t/* refetch if new level is not NL */\n\t\t\t\tif (type > LKM_NLMODE) {\n\t\t\t\t\tmlog(0, \"will fetch new value into \"\n\t\t\t\t\t     \"lvb: converting %s->%s\\n\",\n\t\t\t\t\t     dlm_lock_mode_name(lock->ml.type),\n\t\t\t\t\t     dlm_lock_mode_name(type));\n\t\t\t\t\tlock->lksb->flags |= DLM_LKSB_GET_LVB;\n\t\t\t\t} else {\n\t\t\t\t\tmlog(0, \"will NOT fetch new value \"\n\t\t\t\t\t     \"into lvb: converting %s->%s\\n\",\n\t\t\t\t\t     dlm_lock_mode_name(lock->ml.type),\n\t\t\t\t\t     dlm_lock_mode_name(type));\n\t\t\t\t\tflags &= ~(LKM_VALBLK);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\n\t/* in-place downconvert? */\n\tif (type <= lock->ml.type)\n\t\tgoto grant;\n\n\t/* upconvert from here on */\n\tstatus = DLM_NORMAL;\n\tlist_for_each_entry(tmplock, &res->granted, list) {\n\t\tif (tmplock == lock)\n\t\t\tcontinue;\n\t\tif (!dlm_lock_compatible(tmplock->ml.type, type))\n\t\t\tgoto switch_queues;\n\t}\n\n\tlist_for_each_entry(tmplock, &res->converting, list) {\n\t\tif (!dlm_lock_compatible(tmplock->ml.type, type))\n\t\t\tgoto switch_queues;\n\t\t/* existing conversion requests take precedence */\n\t\tif (!dlm_lock_compatible(tmplock->ml.convert_type, type))\n\t\t\tgoto switch_queues;\n\t}\n\n\t/* fall thru to grant */\n\ngrant:\n\tmlog(0, \"res %.*s, granting %s lock\\n\", res->lockname.len,\n\t     res->lockname.name, dlm_lock_mode_name(type));\n\t/* immediately grant the new lock type */\n\tlock->lksb->status = DLM_NORMAL;\n\tif (lock->ml.node == dlm->node_num)\n\t\tmlog(0, \"doing in-place convert for nonlocal lock\\n\");\n\tlock->ml.type = type;\n\tif (lock->lksb->flags & DLM_LKSB_PUT_LVB)\n\t\tmemcpy(res->lvb, lock->lksb->lvb, DLM_LVB_LEN);\n\n\tstatus = DLM_NORMAL;\n\t*call_ast = 1;\n\tgoto unlock_exit;\n\nswitch_queues:\n\tif (flags & LKM_NOQUEUE) {\n\t\tmlog(0, \"failed to convert NOQUEUE lock %.*s from \"\n\t\t     \"%d to %d...\\n\", res->lockname.len, res->lockname.name,\n\t\t     lock->ml.type, type);\n\t\tstatus = DLM_NOTQUEUED;\n\t\tgoto unlock_exit;\n\t}\n\tmlog(0, \"res %.*s, queueing...\\n\", res->lockname.len,\n\t     res->lockname.name);\n\n\tlock->ml.convert_type = type;\n\t/* do not alter lock refcount.  switching lists. */\n\tlist_move_tail(&lock->list, &res->converting);\n\nunlock_exit:\n\tspin_unlock(&lock->spinlock);\n\tif (status == DLM_DENIED) {\n\t\t__dlm_print_one_lock_resource(res);\n\t}\n\tif (status == DLM_NORMAL)\n\t\t*kick_thread = 1;\n\treturn status;\n}"
  },
  {
    "function_name": "dlmconvert_master",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmconvert.c",
    "lines": "76-108",
    "snippet": "enum dlm_status dlmconvert_master(struct dlm_ctxt *dlm,\n\t\t\t\t  struct dlm_lock_resource *res,\n\t\t\t\t  struct dlm_lock *lock, int flags, int type)\n{\n\tint call_ast = 0, kick_thread = 0;\n\tenum dlm_status status;\n\n\tspin_lock(&res->spinlock);\n\t/* we are not in a network handler, this is fine */\n\t__dlm_wait_on_lockres(res);\n\t__dlm_lockres_reserve_ast(res);\n\tres->state |= DLM_LOCK_RES_IN_PROGRESS;\n\n\tstatus = __dlmconvert_master(dlm, res, lock, flags, type,\n\t\t\t\t     &call_ast, &kick_thread);\n\n\tres->state &= ~DLM_LOCK_RES_IN_PROGRESS;\n\tspin_unlock(&res->spinlock);\n\twake_up(&res->wq);\n\tif (status != DLM_NORMAL && status != DLM_NOTQUEUED)\n\t\tdlm_error(status);\n\n\t/* either queue the ast or release it */\n\tif (call_ast)\n\t\tdlm_queue_ast(dlm, lock);\n\telse\n\t\tdlm_lockres_release_ast(dlm, res);\n\n\tif (kick_thread)\n\t\tdlm_kick_thread(dlm, res);\n\n\treturn status;\n}",
    "includes": [
      "#include \"cluster/masklog.h\"",
      "#include \"dlmconvert.h\"",
      "#include \"dlmcommon.h\"",
      "#include \"dlmapi.h\"",
      "#include \"cluster/tcp.h\"",
      "#include \"cluster/nodemanager.h\"",
      "#include \"cluster/heartbeat.h\"",
      "#include <linux/spinlock.h>",
      "#include <linux/inet.h>",
      "#include <linux/socket.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/random.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/init.h>",
      "#include <linux/highmem.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static enum dlm_status __dlmconvert_master(struct dlm_ctxt *dlm,\n\t\t\t\t\t   struct dlm_lock_resource *res,\n\t\t\t\t\t   struct dlm_lock *lock, int flags,\n\t\t\t\t\t   int type, int *call_ast,\n\t\t\t\t\t   int *kick_thread);",
      "static enum dlm_status dlm_send_remote_convert_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t   struct dlm_lock_resource *res,\n\t\t\t\t\t   struct dlm_lock *lock, int flags, int type);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_kick_thread",
          "args": [
            "dlm",
            "res"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_kick_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "445-455",
          "snippet": "void dlm_kick_thread(struct dlm_ctxt *dlm, struct dlm_lock_resource *res)\n{\n\tif (res) {\n\t\tspin_lock(&dlm->spinlock);\n\t\tspin_lock(&res->spinlock);\n\t\t__dlm_dirty_lockres(dlm, res);\n\t\tspin_unlock(&res->spinlock);\n\t\tspin_unlock(&dlm->spinlock);\n\t}\n\twake_up(&dlm->dlm_thread_wq);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nvoid dlm_kick_thread(struct dlm_ctxt *dlm, struct dlm_lock_resource *res)\n{\n\tif (res) {\n\t\tspin_lock(&dlm->spinlock);\n\t\tspin_lock(&res->spinlock);\n\t\t__dlm_dirty_lockres(dlm, res);\n\t\tspin_unlock(&res->spinlock);\n\t\tspin_unlock(&dlm->spinlock);\n\t}\n\twake_up(&dlm->dlm_thread_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lockres_release_ast",
          "args": [
            "dlm",
            "res"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lockres_release_ast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "3419-3436",
          "snippet": "void dlm_lockres_release_ast(struct dlm_ctxt *dlm,\n\t\t\t     struct dlm_lock_resource *res)\n{\n\tif (!atomic_dec_and_lock(&res->asts_reserved, &res->spinlock))\n\t\treturn;\n\n\tif (!res->migration_pending) {\n\t\tspin_unlock(&res->spinlock);\n\t\treturn;\n\t}\n\n\tBUG_ON(res->state & DLM_LOCK_RES_MIGRATING);\n\tres->migration_pending = 0;\n\tres->state |= DLM_LOCK_RES_MIGRATING;\n\tspin_unlock(&res->spinlock);\n\twake_up(&res->wq);\n\twake_up(&dlm->migration_wq);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid dlm_lockres_release_ast(struct dlm_ctxt *dlm,\n\t\t\t     struct dlm_lock_resource *res)\n{\n\tif (!atomic_dec_and_lock(&res->asts_reserved, &res->spinlock))\n\t\treturn;\n\n\tif (!res->migration_pending) {\n\t\tspin_unlock(&res->spinlock);\n\t\treturn;\n\t}\n\n\tBUG_ON(res->state & DLM_LOCK_RES_MIGRATING);\n\tres->migration_pending = 0;\n\tres->state |= DLM_LOCK_RES_MIGRATING;\n\tspin_unlock(&res->spinlock);\n\twake_up(&res->wq);\n\twake_up(&dlm->migration_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_queue_ast",
          "args": [
            "dlm",
            "lock"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_queue_ast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmast.c",
          "lines": "146-154",
          "snippet": "void dlm_queue_ast(struct dlm_ctxt *dlm, struct dlm_lock *lock)\n{\n\tBUG_ON(!dlm);\n\tBUG_ON(!lock);\n\n\tspin_lock(&dlm->ast_lock);\n\t__dlm_queue_ast(dlm, lock);\n\tspin_unlock(&dlm->ast_lock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_update_lvb(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock);",
            "static int dlm_should_cancel_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_update_lvb(struct dlm_ctxt *dlm, struct dlm_lock_resource *res,\n\t\t\t   struct dlm_lock *lock);\nstatic int dlm_should_cancel_bast(struct dlm_ctxt *dlm, struct dlm_lock *lock);\n\nvoid dlm_queue_ast(struct dlm_ctxt *dlm, struct dlm_lock *lock)\n{\n\tBUG_ON(!dlm);\n\tBUG_ON(!lock);\n\n\tspin_lock(&dlm->ast_lock);\n\t__dlm_queue_ast(dlm, lock);\n\tspin_unlock(&dlm->ast_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_error",
          "args": [
            "status"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "user_recover_from_dlm_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmfs/userdlm.c",
          "lines": "99-104",
          "snippet": "static inline void user_recover_from_dlm_error(struct user_lock_res *lockres)\n{\n\tspin_lock(&lockres->l_lock);\n\tlockres->l_flags &= ~USER_LOCK_BUSY;\n\tspin_unlock(&lockres->l_lock);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"userdlm.h\"",
            "#include \"stackglue.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"userdlm.h\"\n#include \"stackglue.h\"\n#include \"ocfs2_lockingver.h\"\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/signal.h>\n\nstatic inline void user_recover_from_dlm_error(struct user_lock_res *lockres)\n{\n\tspin_lock(&lockres->l_lock);\n\tlockres->l_flags &= ~USER_LOCK_BUSY;\n\tspin_unlock(&lockres->l_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&res->wq"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&res->spinlock"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlmconvert_master",
          "args": [
            "dlm",
            "res",
            "lock",
            "flags",
            "type",
            "&call_ast",
            "&kick_thread"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "__dlmconvert_master",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmconvert.c",
          "lines": "119-242",
          "snippet": "static enum dlm_status __dlmconvert_master(struct dlm_ctxt *dlm,\n\t\t\t\t\t   struct dlm_lock_resource *res,\n\t\t\t\t\t   struct dlm_lock *lock, int flags,\n\t\t\t\t\t   int type, int *call_ast,\n\t\t\t\t\t   int *kick_thread)\n{\n\tenum dlm_status status = DLM_NORMAL;\n\tstruct dlm_lock *tmplock=NULL;\n\n\tassert_spin_locked(&res->spinlock);\n\n\tmlog(0, \"type=%d, convert_type=%d, new convert_type=%d\\n\",\n\t     lock->ml.type, lock->ml.convert_type, type);\n\n\tspin_lock(&lock->spinlock);\n\n\t/* already converting? */\n\tif (lock->ml.convert_type != LKM_IVMODE) {\n\t\tmlog(ML_ERROR, \"attempted to convert a lock with a lock \"\n\t\t     \"conversion pending\\n\");\n\t\tstatus = DLM_DENIED;\n\t\tgoto unlock_exit;\n\t}\n\n\t/* must be on grant queue to convert */\n\tif (!dlm_lock_on_list(&res->granted, lock)) {\n\t\tmlog(ML_ERROR, \"attempted to convert a lock not on grant \"\n\t\t     \"queue\\n\");\n\t\tstatus = DLM_DENIED;\n\t\tgoto unlock_exit;\n\t}\n\n\tif (flags & LKM_VALBLK) {\n\t\tswitch (lock->ml.type) {\n\t\t\tcase LKM_EXMODE:\n\t\t\t\t/* EX + LKM_VALBLK + convert == set lvb */\n\t\t\t\tmlog(0, \"will set lvb: converting %s->%s\\n\",\n\t\t\t\t     dlm_lock_mode_name(lock->ml.type),\n\t\t\t\t     dlm_lock_mode_name(type));\n\t\t\t\tlock->lksb->flags |= DLM_LKSB_PUT_LVB;\n\t\t\t\tbreak;\n\t\t\tcase LKM_PRMODE:\n\t\t\tcase LKM_NLMODE:\n\t\t\t\t/* refetch if new level is not NL */\n\t\t\t\tif (type > LKM_NLMODE) {\n\t\t\t\t\tmlog(0, \"will fetch new value into \"\n\t\t\t\t\t     \"lvb: converting %s->%s\\n\",\n\t\t\t\t\t     dlm_lock_mode_name(lock->ml.type),\n\t\t\t\t\t     dlm_lock_mode_name(type));\n\t\t\t\t\tlock->lksb->flags |= DLM_LKSB_GET_LVB;\n\t\t\t\t} else {\n\t\t\t\t\tmlog(0, \"will NOT fetch new value \"\n\t\t\t\t\t     \"into lvb: converting %s->%s\\n\",\n\t\t\t\t\t     dlm_lock_mode_name(lock->ml.type),\n\t\t\t\t\t     dlm_lock_mode_name(type));\n\t\t\t\t\tflags &= ~(LKM_VALBLK);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\n\t/* in-place downconvert? */\n\tif (type <= lock->ml.type)\n\t\tgoto grant;\n\n\t/* upconvert from here on */\n\tstatus = DLM_NORMAL;\n\tlist_for_each_entry(tmplock, &res->granted, list) {\n\t\tif (tmplock == lock)\n\t\t\tcontinue;\n\t\tif (!dlm_lock_compatible(tmplock->ml.type, type))\n\t\t\tgoto switch_queues;\n\t}\n\n\tlist_for_each_entry(tmplock, &res->converting, list) {\n\t\tif (!dlm_lock_compatible(tmplock->ml.type, type))\n\t\t\tgoto switch_queues;\n\t\t/* existing conversion requests take precedence */\n\t\tif (!dlm_lock_compatible(tmplock->ml.convert_type, type))\n\t\t\tgoto switch_queues;\n\t}\n\n\t/* fall thru to grant */\n\ngrant:\n\tmlog(0, \"res %.*s, granting %s lock\\n\", res->lockname.len,\n\t     res->lockname.name, dlm_lock_mode_name(type));\n\t/* immediately grant the new lock type */\n\tlock->lksb->status = DLM_NORMAL;\n\tif (lock->ml.node == dlm->node_num)\n\t\tmlog(0, \"doing in-place convert for nonlocal lock\\n\");\n\tlock->ml.type = type;\n\tif (lock->lksb->flags & DLM_LKSB_PUT_LVB)\n\t\tmemcpy(res->lvb, lock->lksb->lvb, DLM_LVB_LEN);\n\n\tstatus = DLM_NORMAL;\n\t*call_ast = 1;\n\tgoto unlock_exit;\n\nswitch_queues:\n\tif (flags & LKM_NOQUEUE) {\n\t\tmlog(0, \"failed to convert NOQUEUE lock %.*s from \"\n\t\t     \"%d to %d...\\n\", res->lockname.len, res->lockname.name,\n\t\t     lock->ml.type, type);\n\t\tstatus = DLM_NOTQUEUED;\n\t\tgoto unlock_exit;\n\t}\n\tmlog(0, \"res %.*s, queueing...\\n\", res->lockname.len,\n\t     res->lockname.name);\n\n\tlock->ml.convert_type = type;\n\t/* do not alter lock refcount.  switching lists. */\n\tlist_move_tail(&lock->list, &res->converting);\n\nunlock_exit:\n\tspin_unlock(&lock->spinlock);\n\tif (status == DLM_DENIED) {\n\t\t__dlm_print_one_lock_resource(res);\n\t}\n\tif (status == DLM_NORMAL)\n\t\t*kick_thread = 1;\n\treturn status;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmconvert.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static enum dlm_status __dlmconvert_master(struct dlm_ctxt *dlm,\n\t\t\t\t\t   struct dlm_lock_resource *res,\n\t\t\t\t\t   struct dlm_lock *lock, int flags,\n\t\t\t\t\t   int type, int *call_ast,\n\t\t\t\t\t   int *kick_thread);",
            "static enum dlm_status dlm_send_remote_convert_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t   struct dlm_lock_resource *res,\n\t\t\t\t\t   struct dlm_lock *lock, int flags, int type);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic enum dlm_status __dlmconvert_master(struct dlm_ctxt *dlm,\n\t\t\t\t\t   struct dlm_lock_resource *res,\n\t\t\t\t\t   struct dlm_lock *lock, int flags,\n\t\t\t\t\t   int type, int *call_ast,\n\t\t\t\t\t   int *kick_thread);\nstatic enum dlm_status dlm_send_remote_convert_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t   struct dlm_lock_resource *res,\n\t\t\t\t\t   struct dlm_lock *lock, int flags, int type);\n\nstatic enum dlm_status __dlmconvert_master(struct dlm_ctxt *dlm,\n\t\t\t\t\t   struct dlm_lock_resource *res,\n\t\t\t\t\t   struct dlm_lock *lock, int flags,\n\t\t\t\t\t   int type, int *call_ast,\n\t\t\t\t\t   int *kick_thread)\n{\n\tenum dlm_status status = DLM_NORMAL;\n\tstruct dlm_lock *tmplock=NULL;\n\n\tassert_spin_locked(&res->spinlock);\n\n\tmlog(0, \"type=%d, convert_type=%d, new convert_type=%d\\n\",\n\t     lock->ml.type, lock->ml.convert_type, type);\n\n\tspin_lock(&lock->spinlock);\n\n\t/* already converting? */\n\tif (lock->ml.convert_type != LKM_IVMODE) {\n\t\tmlog(ML_ERROR, \"attempted to convert a lock with a lock \"\n\t\t     \"conversion pending\\n\");\n\t\tstatus = DLM_DENIED;\n\t\tgoto unlock_exit;\n\t}\n\n\t/* must be on grant queue to convert */\n\tif (!dlm_lock_on_list(&res->granted, lock)) {\n\t\tmlog(ML_ERROR, \"attempted to convert a lock not on grant \"\n\t\t     \"queue\\n\");\n\t\tstatus = DLM_DENIED;\n\t\tgoto unlock_exit;\n\t}\n\n\tif (flags & LKM_VALBLK) {\n\t\tswitch (lock->ml.type) {\n\t\t\tcase LKM_EXMODE:\n\t\t\t\t/* EX + LKM_VALBLK + convert == set lvb */\n\t\t\t\tmlog(0, \"will set lvb: converting %s->%s\\n\",\n\t\t\t\t     dlm_lock_mode_name(lock->ml.type),\n\t\t\t\t     dlm_lock_mode_name(type));\n\t\t\t\tlock->lksb->flags |= DLM_LKSB_PUT_LVB;\n\t\t\t\tbreak;\n\t\t\tcase LKM_PRMODE:\n\t\t\tcase LKM_NLMODE:\n\t\t\t\t/* refetch if new level is not NL */\n\t\t\t\tif (type > LKM_NLMODE) {\n\t\t\t\t\tmlog(0, \"will fetch new value into \"\n\t\t\t\t\t     \"lvb: converting %s->%s\\n\",\n\t\t\t\t\t     dlm_lock_mode_name(lock->ml.type),\n\t\t\t\t\t     dlm_lock_mode_name(type));\n\t\t\t\t\tlock->lksb->flags |= DLM_LKSB_GET_LVB;\n\t\t\t\t} else {\n\t\t\t\t\tmlog(0, \"will NOT fetch new value \"\n\t\t\t\t\t     \"into lvb: converting %s->%s\\n\",\n\t\t\t\t\t     dlm_lock_mode_name(lock->ml.type),\n\t\t\t\t\t     dlm_lock_mode_name(type));\n\t\t\t\t\tflags &= ~(LKM_VALBLK);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\n\t/* in-place downconvert? */\n\tif (type <= lock->ml.type)\n\t\tgoto grant;\n\n\t/* upconvert from here on */\n\tstatus = DLM_NORMAL;\n\tlist_for_each_entry(tmplock, &res->granted, list) {\n\t\tif (tmplock == lock)\n\t\t\tcontinue;\n\t\tif (!dlm_lock_compatible(tmplock->ml.type, type))\n\t\t\tgoto switch_queues;\n\t}\n\n\tlist_for_each_entry(tmplock, &res->converting, list) {\n\t\tif (!dlm_lock_compatible(tmplock->ml.type, type))\n\t\t\tgoto switch_queues;\n\t\t/* existing conversion requests take precedence */\n\t\tif (!dlm_lock_compatible(tmplock->ml.convert_type, type))\n\t\t\tgoto switch_queues;\n\t}\n\n\t/* fall thru to grant */\n\ngrant:\n\tmlog(0, \"res %.*s, granting %s lock\\n\", res->lockname.len,\n\t     res->lockname.name, dlm_lock_mode_name(type));\n\t/* immediately grant the new lock type */\n\tlock->lksb->status = DLM_NORMAL;\n\tif (lock->ml.node == dlm->node_num)\n\t\tmlog(0, \"doing in-place convert for nonlocal lock\\n\");\n\tlock->ml.type = type;\n\tif (lock->lksb->flags & DLM_LKSB_PUT_LVB)\n\t\tmemcpy(res->lvb, lock->lksb->lvb, DLM_LVB_LEN);\n\n\tstatus = DLM_NORMAL;\n\t*call_ast = 1;\n\tgoto unlock_exit;\n\nswitch_queues:\n\tif (flags & LKM_NOQUEUE) {\n\t\tmlog(0, \"failed to convert NOQUEUE lock %.*s from \"\n\t\t     \"%d to %d...\\n\", res->lockname.len, res->lockname.name,\n\t\t     lock->ml.type, type);\n\t\tstatus = DLM_NOTQUEUED;\n\t\tgoto unlock_exit;\n\t}\n\tmlog(0, \"res %.*s, queueing...\\n\", res->lockname.len,\n\t     res->lockname.name);\n\n\tlock->ml.convert_type = type;\n\t/* do not alter lock refcount.  switching lists. */\n\tlist_move_tail(&lock->list, &res->converting);\n\nunlock_exit:\n\tspin_unlock(&lock->spinlock);\n\tif (status == DLM_DENIED) {\n\t\t__dlm_print_one_lock_resource(res);\n\t}\n\tif (status == DLM_NORMAL)\n\t\t*kick_thread = 1;\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_lockres_reserve_ast",
          "args": [
            "res"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_lockres_reserve_ast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmmaster.c",
          "lines": "3395-3404",
          "snippet": "void __dlm_lockres_reserve_ast(struct dlm_lock_resource *res)\n{\n\tassert_spin_locked(&res->spinlock);\n\tif (res->state & DLM_LOCK_RES_MIGRATING) {\n\t\t__dlm_print_one_lock_resource(res);\n\t}\n\tBUG_ON(res->state & DLM_LOCK_RES_MIGRATING);\n\n\tatomic_inc(&res->asts_reserved);\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdebug.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);",
            "static void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);",
            "static int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdebug.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic u8 dlm_pick_migration_target(struct dlm_ctxt *dlm,\n\t\t\t\t    struct dlm_lock_resource *res);\nstatic void dlm_remove_nonlocal_locks(struct dlm_ctxt *dlm,\n\t\t\t\t      struct dlm_lock_resource *res);\nstatic int dlm_pre_master_reco_lockres(struct dlm_ctxt *dlm,\n\t\t\t\t       struct dlm_lock_resource *res);\n\nvoid __dlm_lockres_reserve_ast(struct dlm_lock_resource *res)\n{\n\tassert_spin_locked(&res->spinlock);\n\tif (res->state & DLM_LOCK_RES_MIGRATING) {\n\t\t__dlm_print_one_lock_resource(res);\n\t}\n\tBUG_ON(res->state & DLM_LOCK_RES_MIGRATING);\n\n\tatomic_inc(&res->asts_reserved);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dlm_wait_on_lockres",
          "args": [
            "res"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "__dlm_wait_on_lockres",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmcommon.h",
          "lines": "1020-1025",
          "snippet": "static inline void __dlm_wait_on_lockres(struct dlm_lock_resource *res)\n{\n\t__dlm_wait_on_lockres_flags(res, (DLM_LOCK_RES_IN_PROGRESS|\n\t\t\t\t    \t  DLM_LOCK_RES_RECOVERING|\n\t\t\t\t\t  DLM_LOCK_RES_MIGRATING));\n}",
          "includes": [
            "#include <linux/kref.h>"
          ],
          "macros_used": [
            "#define DLM_LOCK_RES_MIGRATING            0x00000020",
            "#define DLM_LOCK_RES_IN_PROGRESS          0x00000010",
            "#define DLM_LOCK_RES_RECOVERING           0x00000002"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kref.h>\n\n#define DLM_LOCK_RES_MIGRATING            0x00000020\n#define DLM_LOCK_RES_IN_PROGRESS          0x00000010\n#define DLM_LOCK_RES_RECOVERING           0x00000002\n\nstatic inline void __dlm_wait_on_lockres(struct dlm_lock_resource *res)\n{\n\t__dlm_wait_on_lockres_flags(res, (DLM_LOCK_RES_IN_PROGRESS|\n\t\t\t\t    \t  DLM_LOCK_RES_RECOVERING|\n\t\t\t\t\t  DLM_LOCK_RES_MIGRATING));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&res->spinlock"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmconvert.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/spinlock.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic enum dlm_status __dlmconvert_master(struct dlm_ctxt *dlm,\n\t\t\t\t\t   struct dlm_lock_resource *res,\n\t\t\t\t\t   struct dlm_lock *lock, int flags,\n\t\t\t\t\t   int type, int *call_ast,\n\t\t\t\t\t   int *kick_thread);\nstatic enum dlm_status dlm_send_remote_convert_request(struct dlm_ctxt *dlm,\n\t\t\t\t\t   struct dlm_lock_resource *res,\n\t\t\t\t\t   struct dlm_lock *lock, int flags, int type);\n\nenum dlm_status dlmconvert_master(struct dlm_ctxt *dlm,\n\t\t\t\t  struct dlm_lock_resource *res,\n\t\t\t\t  struct dlm_lock *lock, int flags, int type)\n{\n\tint call_ast = 0, kick_thread = 0;\n\tenum dlm_status status;\n\n\tspin_lock(&res->spinlock);\n\t/* we are not in a network handler, this is fine */\n\t__dlm_wait_on_lockres(res);\n\t__dlm_lockres_reserve_ast(res);\n\tres->state |= DLM_LOCK_RES_IN_PROGRESS;\n\n\tstatus = __dlmconvert_master(dlm, res, lock, flags, type,\n\t\t\t\t     &call_ast, &kick_thread);\n\n\tres->state &= ~DLM_LOCK_RES_IN_PROGRESS;\n\tspin_unlock(&res->spinlock);\n\twake_up(&res->wq);\n\tif (status != DLM_NORMAL && status != DLM_NOTQUEUED)\n\t\tdlm_error(status);\n\n\t/* either queue the ast or release it */\n\tif (call_ast)\n\t\tdlm_queue_ast(dlm, lock);\n\telse\n\t\tdlm_lockres_release_ast(dlm, res);\n\n\tif (kick_thread)\n\t\tdlm_kick_thread(dlm, res);\n\n\treturn status;\n}"
  }
]