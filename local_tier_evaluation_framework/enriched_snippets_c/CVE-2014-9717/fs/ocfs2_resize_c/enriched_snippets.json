[
  {
    "function_name": "ocfs2_group_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/resize.c",
    "lines": "453-589",
    "snippet": "int ocfs2_group_add(struct inode *inode, struct ocfs2_new_group_input *input)\n{\n\tint ret;\n\thandle_t *handle;\n\tstruct buffer_head *main_bm_bh = NULL;\n\tstruct inode *main_bm_inode = NULL;\n\tstruct ocfs2_dinode *fe = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct buffer_head *group_bh = NULL;\n\tstruct ocfs2_group_desc *group = NULL;\n\tstruct ocfs2_chain_list *cl;\n\tstruct ocfs2_chain_rec *cr;\n\tu16 cl_bpc;\n\tu64 bg_ptr;\n\n\tif (ocfs2_is_hard_readonly(osb) || ocfs2_is_soft_readonly(osb))\n\t\treturn -EROFS;\n\n\tmain_bm_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t    GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t\t    OCFS2_INVALID_SLOT);\n\tif (!main_bm_inode) {\n\t\tret = -EINVAL;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&main_bm_inode->i_mutex);\n\n\tret = ocfs2_inode_lock(main_bm_inode, &main_bm_bh, 1);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out_mutex;\n\t}\n\n\tfe = (struct ocfs2_dinode *)main_bm_bh->b_data;\n\n\tif (le16_to_cpu(fe->id2.i_chain.cl_cpg) !=\n\t\tocfs2_group_bitmap_size(osb->sb, 0,\n\t\t\t\t\tosb->s_feature_incompat) * 8) {\n\t\tmlog(ML_ERROR, \"The disk is too old and small.\"\n\t\t     \" Force to do offline resize.\");\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tret = ocfs2_read_blocks_sync(osb, input->group, 1, &group_bh);\n\tif (ret < 0) {\n\t\tmlog(ML_ERROR, \"Can't read the group descriptor # %llu \"\n\t\t     \"from the device.\", (unsigned long long)input->group);\n\t\tgoto out_unlock;\n\t}\n\n\tocfs2_set_new_buffer_uptodate(INODE_CACHE(inode), group_bh);\n\n\tret = ocfs2_verify_group_and_input(main_bm_inode, fe, input, group_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_free_group_bh;\n\t}\n\n\ttrace_ocfs2_group_add((unsigned long long)input->group,\n\t\t\t       input->chain, input->clusters, input->frees);\n\n\thandle = ocfs2_start_trans(osb, OCFS2_GROUP_ADD_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tmlog_errno(PTR_ERR(handle));\n\t\tret = -EINVAL;\n\t\tgoto out_free_group_bh;\n\t}\n\n\tcl_bpc = le16_to_cpu(fe->id2.i_chain.cl_bpc);\n\tcl = &fe->id2.i_chain;\n\tcr = &cl->cl_recs[input->chain];\n\n\tret = ocfs2_journal_access_gd(handle, INODE_CACHE(main_bm_inode),\n\t\t\t\t      group_bh, OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tgroup = (struct ocfs2_group_desc *)group_bh->b_data;\n\tbg_ptr = le64_to_cpu(group->bg_next_group);\n\tgroup->bg_next_group = cr->c_blkno;\n\tocfs2_journal_dirty(handle, group_bh);\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(main_bm_inode),\n\t\t\t\t      main_bm_bh, OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret < 0) {\n\t\tgroup->bg_next_group = cpu_to_le64(bg_ptr);\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tif (input->chain == le16_to_cpu(cl->cl_next_free_rec)) {\n\t\tle16_add_cpu(&cl->cl_next_free_rec, 1);\n\t\tmemset(cr, 0, sizeof(struct ocfs2_chain_rec));\n\t}\n\n\tcr->c_blkno = cpu_to_le64(input->group);\n\tle32_add_cpu(&cr->c_total, input->clusters * cl_bpc);\n\tle32_add_cpu(&cr->c_free, input->frees * cl_bpc);\n\n\tle32_add_cpu(&fe->id1.bitmap1.i_total, input->clusters *cl_bpc);\n\tle32_add_cpu(&fe->id1.bitmap1.i_used,\n\t\t     (input->clusters - input->frees) * cl_bpc);\n\tle32_add_cpu(&fe->i_clusters, input->clusters);\n\n\tocfs2_journal_dirty(handle, main_bm_bh);\n\n\tspin_lock(&OCFS2_I(main_bm_inode)->ip_lock);\n\tOCFS2_I(main_bm_inode)->ip_clusters = le32_to_cpu(fe->i_clusters);\n\tle64_add_cpu(&fe->i_size, (u64)input->clusters << osb->s_clustersize_bits);\n\tspin_unlock(&OCFS2_I(main_bm_inode)->ip_lock);\n\ti_size_write(main_bm_inode, le64_to_cpu(fe->i_size));\n\n\tocfs2_update_super_and_backups(main_bm_inode, input->clusters);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\n\nout_free_group_bh:\n\tbrelse(group_bh);\n\nout_unlock:\n\tbrelse(main_bm_bh);\n\n\tocfs2_inode_unlock(main_bm_inode, 1);\n\nout_mutex:\n\tmutex_unlock(&main_bm_inode->i_mutex);\n\tiput(main_bm_inode);\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"resize.h\"",
      "#include \"suballoc.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "main_bm_inode"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&main_bm_inode->i_mutex"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "main_bm_inode",
            "1"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "main_bm_bh"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "handle"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_update_super_and_backups",
          "args": [
            "main_bm_inode",
            "input->clusters"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_update_super_and_backups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/resize.c",
          "lines": "216-257",
          "snippet": "static void ocfs2_update_super_and_backups(struct inode *inode,\n\t\t\t\t\t   int new_clusters)\n{\n\tint ret;\n\tu32 clusters = 0;\n\tstruct buffer_head *super_bh = NULL;\n\tstruct ocfs2_dinode *super_di = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\t/*\n\t * update the superblock last.\n\t * It doesn't matter if the write failed.\n\t */\n\tret = ocfs2_read_blocks_sync(osb, OCFS2_SUPER_BLOCK_BLKNO, 1,\n\t\t\t\t     &super_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tsuper_di = (struct ocfs2_dinode *)super_bh->b_data;\n\tle32_add_cpu(&super_di->i_clusters, new_clusters);\n\tclusters = le32_to_cpu(super_di->i_clusters);\n\n\tret = ocfs2_write_super_or_backup(osb, super_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (OCFS2_HAS_COMPAT_FEATURE(osb->sb, OCFS2_FEATURE_COMPAT_BACKUP_SB))\n\t\tret = update_backups(inode, clusters, super_bh->b_data);\n\nout:\n\tbrelse(super_bh);\n\tif (ret)\n\t\tprintk(KERN_WARNING \"ocfs2: Failed to update super blocks on %s\"\n\t\t\t\" during fs resize. This condition is not fatal,\"\n\t\t\t\" but fsck.ocfs2 should be run to fix it\\n\",\n\t\t\tosb->dev_str);\n\treturn;\n}",
          "includes": [
            "#include \"resize.h\"",
            "#include \"suballoc.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"resize.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_update_super_and_backups(struct inode *inode,\n\t\t\t\t\t   int new_clusters)\n{\n\tint ret;\n\tu32 clusters = 0;\n\tstruct buffer_head *super_bh = NULL;\n\tstruct ocfs2_dinode *super_di = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\t/*\n\t * update the superblock last.\n\t * It doesn't matter if the write failed.\n\t */\n\tret = ocfs2_read_blocks_sync(osb, OCFS2_SUPER_BLOCK_BLKNO, 1,\n\t\t\t\t     &super_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tsuper_di = (struct ocfs2_dinode *)super_bh->b_data;\n\tle32_add_cpu(&super_di->i_clusters, new_clusters);\n\tclusters = le32_to_cpu(super_di->i_clusters);\n\n\tret = ocfs2_write_super_or_backup(osb, super_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (OCFS2_HAS_COMPAT_FEATURE(osb->sb, OCFS2_FEATURE_COMPAT_BACKUP_SB))\n\t\tret = update_backups(inode, clusters, super_bh->b_data);\n\nout:\n\tbrelse(super_bh);\n\tif (ret)\n\t\tprintk(KERN_WARNING \"ocfs2: Failed to update super blocks on %s\"\n\t\t\t\" during fs resize. This condition is not fatal,\"\n\t\t\t\" but fsck.ocfs2 should be run to fix it\\n\",\n\t\t\tosb->dev_str);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "main_bm_inode",
            "le64_to_cpu(fe->i_size)"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "fe->i_size"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&OCFS2_I(main_bm_inode)->ip_lock"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "main_bm_inode"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_add_cpu",
          "args": [
            "&fe->i_size",
            "(u64)input->clusters << osb->s_clustersize_bits"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "fe->i_clusters"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&OCFS2_I(main_bm_inode)->ip_lock"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "main_bm_bh"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&fe->i_clusters",
            "input->clusters"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&fe->id1.bitmap1.i_used",
            "(input->clusters - input->frees) * cl_bpc"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&fe->id1.bitmap1.i_total",
            "input->clusters *cl_bpc"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&cr->c_free",
            "input->frees * cl_bpc"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&cr->c_total",
            "input->clusters * cl_bpc"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "input->group"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "cr",
            "0",
            "sizeof(struct ocfs2_chain_rec)"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&cl->cl_next_free_rec",
            "1"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "cl->cl_next_free_rec"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "bg_ptr"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_di",
          "args": [
            "handle",
            "INODE_CACHE(main_bm_inode)",
            "main_bm_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_di",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "710-714",
          "snippet": "int ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};\n\nint ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "main_bm_inode"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_gd",
          "args": [
            "handle",
            "INODE_CACHE(main_bm_inode)",
            "group_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_gd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "729-733",
          "snippet": "int ocfs2_journal_access_gd(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &gd_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers gd_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_group_desc, bg_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers gd_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_group_desc, bg_check),\n};\n\nint ocfs2_journal_access_gd(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &gd_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "PTR_ERR(handle)"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "OCFS2_GROUP_ADD_CREDITS"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_group_add",
          "args": [
            "(unsigned long long)input->group",
            "input->chain",
            "input->clusters",
            "input->frees"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_verify_group_and_input",
          "args": [
            "main_bm_inode",
            "fe",
            "input",
            "group_bh"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_verify_group_and_input",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/resize.c",
          "lines": "414-450",
          "snippet": "static int ocfs2_verify_group_and_input(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_new_group_input *input,\n\t\t\t\t\tstruct buffer_head *group_bh)\n{\n\tu16 cl_count = le16_to_cpu(di->id2.i_chain.cl_count);\n\tu16 cl_cpg = le16_to_cpu(di->id2.i_chain.cl_cpg);\n\tu16 next_free = le16_to_cpu(di->id2.i_chain.cl_next_free_rec);\n\tu32 cluster = ocfs2_blocks_to_clusters(inode->i_sb, input->group);\n\tu32 total_clusters = le32_to_cpu(di->i_clusters);\n\tint ret = -EINVAL;\n\n\tif (cluster < total_clusters)\n\t\tmlog(ML_ERROR, \"add a group which is in the current volume.\\n\");\n\telse if (input->chain >= cl_count)\n\t\tmlog(ML_ERROR, \"input chain exceeds the limit.\\n\");\n\telse if (next_free != cl_count && next_free != input->chain)\n\t\tmlog(ML_ERROR,\n\t\t     \"the add group should be in chain %u\\n\", next_free);\n\telse if (total_clusters + input->clusters < total_clusters)\n\t\tmlog(ML_ERROR, \"add group's clusters overflow.\\n\");\n\telse if (input->clusters > cl_cpg)\n\t\tmlog(ML_ERROR, \"the cluster exceeds the maximum of a group\\n\");\n\telse if (input->frees > input->clusters)\n\t\tmlog(ML_ERROR, \"the free cluster exceeds the total clusters\\n\");\n\telse if (total_clusters % cl_cpg != 0)\n\t\tmlog(ML_ERROR,\n\t\t     \"the last group isn't full. Use group extend first.\\n\");\n\telse if (input->group != ocfs2_which_cluster_group(inode, cluster))\n\t\tmlog(ML_ERROR, \"group blkno is invalid\\n\");\n\telse if ((ret = ocfs2_check_new_group(inode, di, input, group_bh)))\n\t\tmlog(ML_ERROR, \"group descriptor check failed.\\n\");\n\telse\n\t\tret = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"resize.h\"",
            "#include \"suballoc.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"resize.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_verify_group_and_input(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_new_group_input *input,\n\t\t\t\t\tstruct buffer_head *group_bh)\n{\n\tu16 cl_count = le16_to_cpu(di->id2.i_chain.cl_count);\n\tu16 cl_cpg = le16_to_cpu(di->id2.i_chain.cl_cpg);\n\tu16 next_free = le16_to_cpu(di->id2.i_chain.cl_next_free_rec);\n\tu32 cluster = ocfs2_blocks_to_clusters(inode->i_sb, input->group);\n\tu32 total_clusters = le32_to_cpu(di->i_clusters);\n\tint ret = -EINVAL;\n\n\tif (cluster < total_clusters)\n\t\tmlog(ML_ERROR, \"add a group which is in the current volume.\\n\");\n\telse if (input->chain >= cl_count)\n\t\tmlog(ML_ERROR, \"input chain exceeds the limit.\\n\");\n\telse if (next_free != cl_count && next_free != input->chain)\n\t\tmlog(ML_ERROR,\n\t\t     \"the add group should be in chain %u\\n\", next_free);\n\telse if (total_clusters + input->clusters < total_clusters)\n\t\tmlog(ML_ERROR, \"add group's clusters overflow.\\n\");\n\telse if (input->clusters > cl_cpg)\n\t\tmlog(ML_ERROR, \"the cluster exceeds the maximum of a group\\n\");\n\telse if (input->frees > input->clusters)\n\t\tmlog(ML_ERROR, \"the free cluster exceeds the total clusters\\n\");\n\telse if (total_clusters % cl_cpg != 0)\n\t\tmlog(ML_ERROR,\n\t\t     \"the last group isn't full. Use group extend first.\\n\");\n\telse if (input->group != ocfs2_which_cluster_group(inode, cluster))\n\t\tmlog(ML_ERROR, \"group blkno is invalid\\n\");\n\telse if ((ret = ocfs2_check_new_group(inode, di, input, group_bh)))\n\t\tmlog(ML_ERROR, \"group descriptor check failed.\\n\");\n\telse\n\t\tret = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_set_new_buffer_uptodate",
          "args": [
            "INODE_CACHE(inode)",
            "group_bh"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_new_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "521-532",
          "snippet": "void ocfs2_set_new_buffer_uptodate(struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t/* This should definitely *not* exist in our cache */\n\tBUG_ON(ocfs2_buffer_cached(ci, bh));\n\n\tset_buffer_uptodate(bh);\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tocfs2_set_buffer_uptodate(ci, bh);\n\tocfs2_metadata_cache_io_unlock(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_set_new_buffer_uptodate(struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t/* This should definitely *not* exist in our cache */\n\tBUG_ON(ocfs2_buffer_cached(ci, bh));\n\n\tset_buffer_uptodate(bh);\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tocfs2_set_buffer_uptodate(ci, bh);\n\tocfs2_metadata_cache_io_unlock(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Can't read the group descriptor # %llu \"\n\t\t     \"from the device.\"",
            "(unsigned long long)input->group"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_read_blocks_sync",
          "args": [
            "osb",
            "input->group",
            "1",
            "&group_bh"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_blocks_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/buffer_head_io.c",
          "lines": "101-174",
          "snippet": "int ocfs2_read_blocks_sync(struct ocfs2_super *osb, u64 block,\n\t\t\t   unsigned int nr, struct buffer_head *bhs[])\n{\n\tint status = 0;\n\tunsigned int i;\n\tstruct buffer_head *bh;\n\n\ttrace_ocfs2_read_blocks_sync((unsigned long long)block, nr);\n\n\tif (!nr)\n\t\tgoto bail;\n\n\tfor (i = 0 ; i < nr ; i++) {\n\t\tif (bhs[i] == NULL) {\n\t\t\tbhs[i] = sb_getblk(osb->sb, block++);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tbh = bhs[i];\n\n\t\tif (buffer_jbd(bh)) {\n\t\t\ttrace_ocfs2_read_blocks_sync_jbd(\n\t\t\t\t\t(unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (buffer_dirty(bh)) {\n\t\t\t/* This should probably be a BUG, or\n\t\t\t * at least return an error. */\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"trying to sync read a dirty \"\n\t\t\t     \"buffer! (blocknr = %llu), skipping\\n\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlock_buffer(bh);\n\t\tif (buffer_jbd(bh)) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"block %llu had the JBD bit set \"\n\t\t\t     \"while I was in lock_buffer!\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tBUG();\n\t\t}\n\n\t\tclear_buffer_uptodate(bh);\n\t\tget_bh(bh); /* for end_buffer_read_sync() */\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(READ, bh);\n\t}\n\n\tfor (i = nr; i > 0; i--) {\n\t\tbh = bhs[i - 1];\n\n\t\t/* No need to wait on the buffer if it's managed by JBD. */\n\t\tif (!buffer_jbd(bh))\n\t\t\twait_on_buffer(bh);\n\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* Status won't be cleared from here on out,\n\t\t\t * so we can safely record this and loop back\n\t\t\t * to cleanup the other buffers. */\n\t\t\tstatus = -EIO;\n\t\t\tput_bh(bh);\n\t\t\tbhs[i - 1] = NULL;\n\t\t}\n\t}\n\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_blocks_sync(struct ocfs2_super *osb, u64 block,\n\t\t\t   unsigned int nr, struct buffer_head *bhs[])\n{\n\tint status = 0;\n\tunsigned int i;\n\tstruct buffer_head *bh;\n\n\ttrace_ocfs2_read_blocks_sync((unsigned long long)block, nr);\n\n\tif (!nr)\n\t\tgoto bail;\n\n\tfor (i = 0 ; i < nr ; i++) {\n\t\tif (bhs[i] == NULL) {\n\t\t\tbhs[i] = sb_getblk(osb->sb, block++);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tbh = bhs[i];\n\n\t\tif (buffer_jbd(bh)) {\n\t\t\ttrace_ocfs2_read_blocks_sync_jbd(\n\t\t\t\t\t(unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (buffer_dirty(bh)) {\n\t\t\t/* This should probably be a BUG, or\n\t\t\t * at least return an error. */\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"trying to sync read a dirty \"\n\t\t\t     \"buffer! (blocknr = %llu), skipping\\n\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlock_buffer(bh);\n\t\tif (buffer_jbd(bh)) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"block %llu had the JBD bit set \"\n\t\t\t     \"while I was in lock_buffer!\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tBUG();\n\t\t}\n\n\t\tclear_buffer_uptodate(bh);\n\t\tget_bh(bh); /* for end_buffer_read_sync() */\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(READ, bh);\n\t}\n\n\tfor (i = nr; i > 0; i--) {\n\t\tbh = bhs[i - 1];\n\n\t\t/* No need to wait on the buffer if it's managed by JBD. */\n\t\tif (!buffer_jbd(bh))\n\t\t\twait_on_buffer(bh);\n\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* Status won't be cleared from here on out,\n\t\t\t * so we can safely record this and loop back\n\t\t\t * to cleanup the other buffers. */\n\t\t\tstatus = -EIO;\n\t\t\tput_bh(bh);\n\t\t\tbhs[i - 1] = NULL;\n\t\t}\n\t}\n\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"The disk is too old and small.\"\n\t\t     \" Force to do offline resize.\""
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_group_bitmap_size",
          "args": [
            "osb->sb",
            "0",
            "osb->s_feature_incompat"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_group_bitmap_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1547-1565",
          "snippet": "static inline int ocfs2_group_bitmap_size(int blocksize,\n\t\t\t\t\t  int suballocator,\n\t\t\t\t\t  uint32_t feature_incompat)\n{\n\tint size = sb->s_blocksize -\n\t\toffsetof(struct ocfs2_group_desc, bg_bitmap);\n\n\t/*\n\t * The cluster allocator uses the entire block.  Suballocators have\n\t * never used more than OCFS2_MAX_BG_BITMAP_SIZE.  Unfortunately, older\n\t * code expects bg_size set to the maximum.  Thus we must keep\n\t * bg_size as-is unless discontig_bg is enabled.\n\t */\n\tif (suballocator &&\n\t    (feature_incompat & OCFS2_FEATURE_INCOMPAT_DISCONTIG_BG))\n\t\tsize = OCFS2_MAX_BG_BITMAP_SIZE;\n\n\treturn size;\n}",
          "includes": [],
          "macros_used": [
            "#define OCFS2_MAX_BG_BITMAP_SIZE\t256",
            "#define OCFS2_FEATURE_INCOMPAT_DISCONTIG_BG\t0x2000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define OCFS2_MAX_BG_BITMAP_SIZE\t256\n#define OCFS2_FEATURE_INCOMPAT_DISCONTIG_BG\t0x2000\n\nstatic inline int ocfs2_group_bitmap_size(int blocksize,\n\t\t\t\t\t  int suballocator,\n\t\t\t\t\t  uint32_t feature_incompat)\n{\n\tint size = sb->s_blocksize -\n\t\toffsetof(struct ocfs2_group_desc, bg_bitmap);\n\n\t/*\n\t * The cluster allocator uses the entire block.  Suballocators have\n\t * never used more than OCFS2_MAX_BG_BITMAP_SIZE.  Unfortunately, older\n\t * code expects bg_size set to the maximum.  Thus we must keep\n\t * bg_size as-is unless discontig_bg is enabled.\n\t */\n\tif (suballocator &&\n\t    (feature_incompat & OCFS2_FEATURE_INCOMPAT_DISCONTIG_BG))\n\t\tsize = OCFS2_MAX_BG_BITMAP_SIZE;\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock",
          "args": [
            "main_bm_inode",
            "&main_bm_bh",
            "1"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_lock_atime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2455-2489",
          "snippet": "int ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);",
            "static inline int ocfs2_highest_compat_lock_level(int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\n\nint ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&main_bm_inode->i_mutex"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_system_file_inode",
          "args": [
            "osb",
            "GLOBAL_BITMAP_SYSTEM_INODE",
            "OCFS2_INVALID_SLOT"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "_ocfs2_get_system_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/sysfile.c",
          "lines": "138-181",
          "snippet": "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_is_soft_readonly",
          "args": [
            "osb"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_soft_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "626-635",
          "snippet": "static inline int ocfs2_is_soft_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_SOFT_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define OCFS2_OSB_SOFT_RO\t0x0001"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define OCFS2_OSB_SOFT_RO\t0x0001\n\nstatic inline int ocfs2_is_soft_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_SOFT_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_is_hard_readonly",
          "args": [
            "osb"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_hard_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "615-624",
          "snippet": "static inline int ocfs2_is_hard_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_HARD_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define OCFS2_OSB_HARD_RO\t0x0002"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define OCFS2_OSB_HARD_RO\t0x0002\n\nstatic inline int ocfs2_is_hard_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_HARD_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"resize.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_group_add(struct inode *inode, struct ocfs2_new_group_input *input)\n{\n\tint ret;\n\thandle_t *handle;\n\tstruct buffer_head *main_bm_bh = NULL;\n\tstruct inode *main_bm_inode = NULL;\n\tstruct ocfs2_dinode *fe = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct buffer_head *group_bh = NULL;\n\tstruct ocfs2_group_desc *group = NULL;\n\tstruct ocfs2_chain_list *cl;\n\tstruct ocfs2_chain_rec *cr;\n\tu16 cl_bpc;\n\tu64 bg_ptr;\n\n\tif (ocfs2_is_hard_readonly(osb) || ocfs2_is_soft_readonly(osb))\n\t\treturn -EROFS;\n\n\tmain_bm_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t    GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t\t    OCFS2_INVALID_SLOT);\n\tif (!main_bm_inode) {\n\t\tret = -EINVAL;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&main_bm_inode->i_mutex);\n\n\tret = ocfs2_inode_lock(main_bm_inode, &main_bm_bh, 1);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out_mutex;\n\t}\n\n\tfe = (struct ocfs2_dinode *)main_bm_bh->b_data;\n\n\tif (le16_to_cpu(fe->id2.i_chain.cl_cpg) !=\n\t\tocfs2_group_bitmap_size(osb->sb, 0,\n\t\t\t\t\tosb->s_feature_incompat) * 8) {\n\t\tmlog(ML_ERROR, \"The disk is too old and small.\"\n\t\t     \" Force to do offline resize.\");\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tret = ocfs2_read_blocks_sync(osb, input->group, 1, &group_bh);\n\tif (ret < 0) {\n\t\tmlog(ML_ERROR, \"Can't read the group descriptor # %llu \"\n\t\t     \"from the device.\", (unsigned long long)input->group);\n\t\tgoto out_unlock;\n\t}\n\n\tocfs2_set_new_buffer_uptodate(INODE_CACHE(inode), group_bh);\n\n\tret = ocfs2_verify_group_and_input(main_bm_inode, fe, input, group_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_free_group_bh;\n\t}\n\n\ttrace_ocfs2_group_add((unsigned long long)input->group,\n\t\t\t       input->chain, input->clusters, input->frees);\n\n\thandle = ocfs2_start_trans(osb, OCFS2_GROUP_ADD_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tmlog_errno(PTR_ERR(handle));\n\t\tret = -EINVAL;\n\t\tgoto out_free_group_bh;\n\t}\n\n\tcl_bpc = le16_to_cpu(fe->id2.i_chain.cl_bpc);\n\tcl = &fe->id2.i_chain;\n\tcr = &cl->cl_recs[input->chain];\n\n\tret = ocfs2_journal_access_gd(handle, INODE_CACHE(main_bm_inode),\n\t\t\t\t      group_bh, OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tgroup = (struct ocfs2_group_desc *)group_bh->b_data;\n\tbg_ptr = le64_to_cpu(group->bg_next_group);\n\tgroup->bg_next_group = cr->c_blkno;\n\tocfs2_journal_dirty(handle, group_bh);\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(main_bm_inode),\n\t\t\t\t      main_bm_bh, OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret < 0) {\n\t\tgroup->bg_next_group = cpu_to_le64(bg_ptr);\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tif (input->chain == le16_to_cpu(cl->cl_next_free_rec)) {\n\t\tle16_add_cpu(&cl->cl_next_free_rec, 1);\n\t\tmemset(cr, 0, sizeof(struct ocfs2_chain_rec));\n\t}\n\n\tcr->c_blkno = cpu_to_le64(input->group);\n\tle32_add_cpu(&cr->c_total, input->clusters * cl_bpc);\n\tle32_add_cpu(&cr->c_free, input->frees * cl_bpc);\n\n\tle32_add_cpu(&fe->id1.bitmap1.i_total, input->clusters *cl_bpc);\n\tle32_add_cpu(&fe->id1.bitmap1.i_used,\n\t\t     (input->clusters - input->frees) * cl_bpc);\n\tle32_add_cpu(&fe->i_clusters, input->clusters);\n\n\tocfs2_journal_dirty(handle, main_bm_bh);\n\n\tspin_lock(&OCFS2_I(main_bm_inode)->ip_lock);\n\tOCFS2_I(main_bm_inode)->ip_clusters = le32_to_cpu(fe->i_clusters);\n\tle64_add_cpu(&fe->i_size, (u64)input->clusters << osb->s_clustersize_bits);\n\tspin_unlock(&OCFS2_I(main_bm_inode)->ip_lock);\n\ti_size_write(main_bm_inode, le64_to_cpu(fe->i_size));\n\n\tocfs2_update_super_and_backups(main_bm_inode, input->clusters);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\n\nout_free_group_bh:\n\tbrelse(group_bh);\n\nout_unlock:\n\tbrelse(main_bm_bh);\n\n\tocfs2_inode_unlock(main_bm_inode, 1);\n\nout_mutex:\n\tmutex_unlock(&main_bm_inode->i_mutex);\n\tiput(main_bm_inode);\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_verify_group_and_input",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/resize.c",
    "lines": "414-450",
    "snippet": "static int ocfs2_verify_group_and_input(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_new_group_input *input,\n\t\t\t\t\tstruct buffer_head *group_bh)\n{\n\tu16 cl_count = le16_to_cpu(di->id2.i_chain.cl_count);\n\tu16 cl_cpg = le16_to_cpu(di->id2.i_chain.cl_cpg);\n\tu16 next_free = le16_to_cpu(di->id2.i_chain.cl_next_free_rec);\n\tu32 cluster = ocfs2_blocks_to_clusters(inode->i_sb, input->group);\n\tu32 total_clusters = le32_to_cpu(di->i_clusters);\n\tint ret = -EINVAL;\n\n\tif (cluster < total_clusters)\n\t\tmlog(ML_ERROR, \"add a group which is in the current volume.\\n\");\n\telse if (input->chain >= cl_count)\n\t\tmlog(ML_ERROR, \"input chain exceeds the limit.\\n\");\n\telse if (next_free != cl_count && next_free != input->chain)\n\t\tmlog(ML_ERROR,\n\t\t     \"the add group should be in chain %u\\n\", next_free);\n\telse if (total_clusters + input->clusters < total_clusters)\n\t\tmlog(ML_ERROR, \"add group's clusters overflow.\\n\");\n\telse if (input->clusters > cl_cpg)\n\t\tmlog(ML_ERROR, \"the cluster exceeds the maximum of a group\\n\");\n\telse if (input->frees > input->clusters)\n\t\tmlog(ML_ERROR, \"the free cluster exceeds the total clusters\\n\");\n\telse if (total_clusters % cl_cpg != 0)\n\t\tmlog(ML_ERROR,\n\t\t     \"the last group isn't full. Use group extend first.\\n\");\n\telse if (input->group != ocfs2_which_cluster_group(inode, cluster))\n\t\tmlog(ML_ERROR, \"group blkno is invalid\\n\");\n\telse if ((ret = ocfs2_check_new_group(inode, di, input, group_bh)))\n\t\tmlog(ML_ERROR, \"group descriptor check failed.\\n\");\n\telse\n\t\tret = 0;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"resize.h\"",
      "#include \"suballoc.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"group descriptor check failed.\\n\""
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_check_new_group",
          "args": [
            "inode",
            "di",
            "input",
            "group_bh"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_check_new_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/resize.c",
          "lines": "376-412",
          "snippet": "static int ocfs2_check_new_group(struct inode *inode,\n\t\t\t\t struct ocfs2_dinode *di,\n\t\t\t\t struct ocfs2_new_group_input *input,\n\t\t\t\t struct buffer_head *group_bh)\n{\n\tint ret;\n\tstruct ocfs2_group_desc *gd =\n\t\t(struct ocfs2_group_desc *)group_bh->b_data;\n\tu16 cl_bpc = le16_to_cpu(di->id2.i_chain.cl_bpc);\n\n\tret = ocfs2_check_group_descriptor(inode->i_sb, di, group_bh);\n\tif (ret)\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tif (le16_to_cpu(gd->bg_chain) != input->chain)\n\t\tmlog(ML_ERROR, \"Group descriptor # %llu has bad chain %u \"\n\t\t     \"while input has %u set.\\n\",\n\t\t     (unsigned long long)le64_to_cpu(gd->bg_blkno),\n\t\t     le16_to_cpu(gd->bg_chain), input->chain);\n\telse if (le16_to_cpu(gd->bg_bits) != input->clusters * cl_bpc)\n\t\tmlog(ML_ERROR, \"Group descriptor # %llu has bit count %u but \"\n\t\t     \"input has %u clusters set\\n\",\n\t\t     (unsigned long long)le64_to_cpu(gd->bg_blkno),\n\t\t     le16_to_cpu(gd->bg_bits), input->clusters);\n\telse if (le16_to_cpu(gd->bg_free_bits_count) != input->frees * cl_bpc)\n\t\tmlog(ML_ERROR, \"Group descriptor # %llu has free bit count %u \"\n\t\t     \"but it should have %u set\\n\",\n\t\t     (unsigned long long)le64_to_cpu(gd->bg_blkno),\n\t\t     le16_to_cpu(gd->bg_bits),\n\t\t     input->frees * cl_bpc);\n\telse\n\t\tret = 0;\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"resize.h\"",
            "#include \"suballoc.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"resize.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_check_new_group(struct inode *inode,\n\t\t\t\t struct ocfs2_dinode *di,\n\t\t\t\t struct ocfs2_new_group_input *input,\n\t\t\t\t struct buffer_head *group_bh)\n{\n\tint ret;\n\tstruct ocfs2_group_desc *gd =\n\t\t(struct ocfs2_group_desc *)group_bh->b_data;\n\tu16 cl_bpc = le16_to_cpu(di->id2.i_chain.cl_bpc);\n\n\tret = ocfs2_check_group_descriptor(inode->i_sb, di, group_bh);\n\tif (ret)\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tif (le16_to_cpu(gd->bg_chain) != input->chain)\n\t\tmlog(ML_ERROR, \"Group descriptor # %llu has bad chain %u \"\n\t\t     \"while input has %u set.\\n\",\n\t\t     (unsigned long long)le64_to_cpu(gd->bg_blkno),\n\t\t     le16_to_cpu(gd->bg_chain), input->chain);\n\telse if (le16_to_cpu(gd->bg_bits) != input->clusters * cl_bpc)\n\t\tmlog(ML_ERROR, \"Group descriptor # %llu has bit count %u but \"\n\t\t     \"input has %u clusters set\\n\",\n\t\t     (unsigned long long)le64_to_cpu(gd->bg_blkno),\n\t\t     le16_to_cpu(gd->bg_bits), input->clusters);\n\telse if (le16_to_cpu(gd->bg_free_bits_count) != input->frees * cl_bpc)\n\t\tmlog(ML_ERROR, \"Group descriptor # %llu has free bit count %u \"\n\t\t     \"but it should have %u set\\n\",\n\t\t     (unsigned long long)le64_to_cpu(gd->bg_blkno),\n\t\t     le16_to_cpu(gd->bg_bits),\n\t\t     input->frees * cl_bpc);\n\telse\n\t\tret = 0;\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_which_cluster_group",
          "args": [
            "inode",
            "cluster"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_which_cluster_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2260-2272",
          "snippet": "u64 ocfs2_which_cluster_group(struct inode *inode, u32 cluster)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tu32 group_no;\n\n\tBUG_ON(!ocfs2_is_cluster_bitmap(inode));\n\n\tgroup_no = cluster / osb->bitmap_cpg;\n\tif (!group_no)\n\t\treturn osb->first_cluster_group_blkno;\n\treturn ocfs2_clusters_to_blocks(inode->i_sb,\n\t\t\t\t\tgroup_no * osb->bitmap_cpg);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nu64 ocfs2_which_cluster_group(struct inode *inode, u32 cluster)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tu32 group_no;\n\n\tBUG_ON(!ocfs2_is_cluster_bitmap(inode));\n\n\tgroup_no = cluster / osb->bitmap_cpg;\n\tif (!group_no)\n\t\treturn osb->first_cluster_group_blkno;\n\treturn ocfs2_clusters_to_blocks(inode->i_sb,\n\t\t\t\t\tgroup_no * osb->bitmap_cpg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"the add group should be in chain %u\\n\"",
            "next_free"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "di->i_clusters"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_blocks_to_clusters",
          "args": [
            "inode->i_sb",
            "input->group"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_blocks_to_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "720-727",
          "snippet": "static inline u32 ocfs2_blocks_to_clusters(struct super_block *sb,\n\t\t\t\t\t   u64 blocks)\n{\n\tint b_to_c_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u32)(blocks >> b_to_c_bits);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u32 ocfs2_blocks_to_clusters(struct super_block *sb,\n\t\t\t\t\t   u64 blocks)\n{\n\tint b_to_c_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u32)(blocks >> b_to_c_bits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "di->id2.i_chain.cl_next_free_rec"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"resize.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_verify_group_and_input(struct inode *inode,\n\t\t\t\t\tstruct ocfs2_dinode *di,\n\t\t\t\t\tstruct ocfs2_new_group_input *input,\n\t\t\t\t\tstruct buffer_head *group_bh)\n{\n\tu16 cl_count = le16_to_cpu(di->id2.i_chain.cl_count);\n\tu16 cl_cpg = le16_to_cpu(di->id2.i_chain.cl_cpg);\n\tu16 next_free = le16_to_cpu(di->id2.i_chain.cl_next_free_rec);\n\tu32 cluster = ocfs2_blocks_to_clusters(inode->i_sb, input->group);\n\tu32 total_clusters = le32_to_cpu(di->i_clusters);\n\tint ret = -EINVAL;\n\n\tif (cluster < total_clusters)\n\t\tmlog(ML_ERROR, \"add a group which is in the current volume.\\n\");\n\telse if (input->chain >= cl_count)\n\t\tmlog(ML_ERROR, \"input chain exceeds the limit.\\n\");\n\telse if (next_free != cl_count && next_free != input->chain)\n\t\tmlog(ML_ERROR,\n\t\t     \"the add group should be in chain %u\\n\", next_free);\n\telse if (total_clusters + input->clusters < total_clusters)\n\t\tmlog(ML_ERROR, \"add group's clusters overflow.\\n\");\n\telse if (input->clusters > cl_cpg)\n\t\tmlog(ML_ERROR, \"the cluster exceeds the maximum of a group\\n\");\n\telse if (input->frees > input->clusters)\n\t\tmlog(ML_ERROR, \"the free cluster exceeds the total clusters\\n\");\n\telse if (total_clusters % cl_cpg != 0)\n\t\tmlog(ML_ERROR,\n\t\t     \"the last group isn't full. Use group extend first.\\n\");\n\telse if (input->group != ocfs2_which_cluster_group(inode, cluster))\n\t\tmlog(ML_ERROR, \"group blkno is invalid\\n\");\n\telse if ((ret = ocfs2_check_new_group(inode, di, input, group_bh)))\n\t\tmlog(ML_ERROR, \"group descriptor check failed.\\n\");\n\telse\n\t\tret = 0;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_check_new_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/resize.c",
    "lines": "376-412",
    "snippet": "static int ocfs2_check_new_group(struct inode *inode,\n\t\t\t\t struct ocfs2_dinode *di,\n\t\t\t\t struct ocfs2_new_group_input *input,\n\t\t\t\t struct buffer_head *group_bh)\n{\n\tint ret;\n\tstruct ocfs2_group_desc *gd =\n\t\t(struct ocfs2_group_desc *)group_bh->b_data;\n\tu16 cl_bpc = le16_to_cpu(di->id2.i_chain.cl_bpc);\n\n\tret = ocfs2_check_group_descriptor(inode->i_sb, di, group_bh);\n\tif (ret)\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tif (le16_to_cpu(gd->bg_chain) != input->chain)\n\t\tmlog(ML_ERROR, \"Group descriptor # %llu has bad chain %u \"\n\t\t     \"while input has %u set.\\n\",\n\t\t     (unsigned long long)le64_to_cpu(gd->bg_blkno),\n\t\t     le16_to_cpu(gd->bg_chain), input->chain);\n\telse if (le16_to_cpu(gd->bg_bits) != input->clusters * cl_bpc)\n\t\tmlog(ML_ERROR, \"Group descriptor # %llu has bit count %u but \"\n\t\t     \"input has %u clusters set\\n\",\n\t\t     (unsigned long long)le64_to_cpu(gd->bg_blkno),\n\t\t     le16_to_cpu(gd->bg_bits), input->clusters);\n\telse if (le16_to_cpu(gd->bg_free_bits_count) != input->frees * cl_bpc)\n\t\tmlog(ML_ERROR, \"Group descriptor # %llu has free bit count %u \"\n\t\t     \"but it should have %u set\\n\",\n\t\t     (unsigned long long)le64_to_cpu(gd->bg_blkno),\n\t\t     le16_to_cpu(gd->bg_bits),\n\t\t     input->frees * cl_bpc);\n\telse\n\t\tret = 0;\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"resize.h\"",
      "#include \"suballoc.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Group descriptor # %llu has free bit count %u \"\n\t\t     \"but it should have %u set\\n\"",
            "(unsigned long long)le64_to_cpu(gd->bg_blkno)",
            "le16_to_cpu(gd->bg_bits)",
            "input->frees * cl_bpc"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "gd->bg_bits"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "gd->bg_blkno"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Group descriptor # %llu has bit count %u but \"\n\t\t     \"input has %u clusters set\\n\"",
            "(unsigned long long)le64_to_cpu(gd->bg_blkno)",
            "le16_to_cpu(gd->bg_bits)",
            "input->clusters"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Group descriptor # %llu has bad chain %u \"\n\t\t     \"while input has %u set.\\n\"",
            "(unsigned long long)le64_to_cpu(gd->bg_blkno)",
            "le16_to_cpu(gd->bg_chain)",
            "input->chain"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_check_group_descriptor",
          "args": [
            "inode->i_sb",
            "di",
            "group_bh"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_check_group_descriptor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "272-297",
          "snippet": "int ocfs2_check_group_descriptor(struct super_block *sb,\n\t\t\t\t struct ocfs2_dinode *di,\n\t\t\t\t struct buffer_head *bh)\n{\n\tint rc;\n\tstruct ocfs2_group_desc *gd = (struct ocfs2_group_desc *)bh->b_data;\n\n\tBUG_ON(!buffer_uptodate(bh));\n\n\t/*\n\t * If the ecc fails, we return the error but otherwise\n\t * leave the filesystem running.  We know any error is\n\t * local to this block.\n\t */\n\trc = ocfs2_validate_meta_ecc(sb, bh->b_data, &gd->bg_check);\n\tif (rc) {\n\t\tmlog(ML_ERROR,\n\t\t     \"Checksum failed for group descriptor %llu\\n\",\n\t\t     (unsigned long long)bh->b_blocknr);\n\t} else\n\t\trc = ocfs2_validate_gd_self(sb, bh, 1);\n\tif (!rc)\n\t\trc = ocfs2_validate_gd_parent(sb, di, bh, 1);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_check_group_descriptor(struct super_block *sb,\n\t\t\t\t struct ocfs2_dinode *di,\n\t\t\t\t struct buffer_head *bh)\n{\n\tint rc;\n\tstruct ocfs2_group_desc *gd = (struct ocfs2_group_desc *)bh->b_data;\n\n\tBUG_ON(!buffer_uptodate(bh));\n\n\t/*\n\t * If the ecc fails, we return the error but otherwise\n\t * leave the filesystem running.  We know any error is\n\t * local to this block.\n\t */\n\trc = ocfs2_validate_meta_ecc(sb, bh->b_data, &gd->bg_check);\n\tif (rc) {\n\t\tmlog(ML_ERROR,\n\t\t     \"Checksum failed for group descriptor %llu\\n\",\n\t\t     (unsigned long long)bh->b_blocknr);\n\t} else\n\t\trc = ocfs2_validate_gd_self(sb, bh, 1);\n\tif (!rc)\n\t\trc = ocfs2_validate_gd_parent(sb, di, bh, 1);\n\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"resize.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_check_new_group(struct inode *inode,\n\t\t\t\t struct ocfs2_dinode *di,\n\t\t\t\t struct ocfs2_new_group_input *input,\n\t\t\t\t struct buffer_head *group_bh)\n{\n\tint ret;\n\tstruct ocfs2_group_desc *gd =\n\t\t(struct ocfs2_group_desc *)group_bh->b_data;\n\tu16 cl_bpc = le16_to_cpu(di->id2.i_chain.cl_bpc);\n\n\tret = ocfs2_check_group_descriptor(inode->i_sb, di, group_bh);\n\tif (ret)\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tif (le16_to_cpu(gd->bg_chain) != input->chain)\n\t\tmlog(ML_ERROR, \"Group descriptor # %llu has bad chain %u \"\n\t\t     \"while input has %u set.\\n\",\n\t\t     (unsigned long long)le64_to_cpu(gd->bg_blkno),\n\t\t     le16_to_cpu(gd->bg_chain), input->chain);\n\telse if (le16_to_cpu(gd->bg_bits) != input->clusters * cl_bpc)\n\t\tmlog(ML_ERROR, \"Group descriptor # %llu has bit count %u but \"\n\t\t     \"input has %u clusters set\\n\",\n\t\t     (unsigned long long)le64_to_cpu(gd->bg_blkno),\n\t\t     le16_to_cpu(gd->bg_bits), input->clusters);\n\telse if (le16_to_cpu(gd->bg_free_bits_count) != input->frees * cl_bpc)\n\t\tmlog(ML_ERROR, \"Group descriptor # %llu has free bit count %u \"\n\t\t     \"but it should have %u set\\n\",\n\t\t     (unsigned long long)le64_to_cpu(gd->bg_blkno),\n\t\t     le16_to_cpu(gd->bg_bits),\n\t\t     input->frees * cl_bpc);\n\telse\n\t\tret = 0;\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_group_extend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/resize.c",
    "lines": "264-374",
    "snippet": "int ocfs2_group_extend(struct inode * inode, int new_clusters)\n{\n\tint ret;\n\thandle_t *handle;\n\tstruct buffer_head *main_bm_bh = NULL;\n\tstruct buffer_head *group_bh = NULL;\n\tstruct inode *main_bm_inode = NULL;\n\tstruct ocfs2_dinode *fe = NULL;\n\tstruct ocfs2_group_desc *group = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tu16 cl_bpc;\n\tu32 first_new_cluster;\n\tu64 lgd_blkno;\n\n\tif (ocfs2_is_hard_readonly(osb) || ocfs2_is_soft_readonly(osb))\n\t\treturn -EROFS;\n\n\tif (new_clusters < 0)\n\t\treturn -EINVAL;\n\telse if (new_clusters == 0)\n\t\treturn 0;\n\n\tmain_bm_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t    GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t\t    OCFS2_INVALID_SLOT);\n\tif (!main_bm_inode) {\n\t\tret = -EINVAL;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&main_bm_inode->i_mutex);\n\n\tret = ocfs2_inode_lock(main_bm_inode, &main_bm_bh, 1);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out_mutex;\n\t}\n\n\tfe = (struct ocfs2_dinode *)main_bm_bh->b_data;\n\n\t/* main_bm_bh is validated by inode read inside ocfs2_inode_lock(),\n\t * so any corruption is a code bug. */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(fe));\n\n\tif (le16_to_cpu(fe->id2.i_chain.cl_cpg) !=\n\t\tocfs2_group_bitmap_size(osb->sb, 0,\n\t\t\t\t\tosb->s_feature_incompat) * 8) {\n\t\tmlog(ML_ERROR, \"The disk is too old and small. \"\n\t\t     \"Force to do offline resize.\");\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tfirst_new_cluster = le32_to_cpu(fe->i_clusters);\n\tlgd_blkno = ocfs2_which_cluster_group(main_bm_inode,\n\t\t\t\t\t      first_new_cluster - 1);\n\n\tret = ocfs2_read_group_descriptor(main_bm_inode, fe, lgd_blkno,\n\t\t\t\t\t  &group_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out_unlock;\n\t}\n\tgroup = (struct ocfs2_group_desc *)group_bh->b_data;\n\n\tcl_bpc = le16_to_cpu(fe->id2.i_chain.cl_bpc);\n\tif (le16_to_cpu(group->bg_bits) / cl_bpc + new_clusters >\n\t\tle16_to_cpu(fe->id2.i_chain.cl_cpg)) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\n\ttrace_ocfs2_group_extend(\n\t     (unsigned long long)le64_to_cpu(group->bg_blkno), new_clusters);\n\n\thandle = ocfs2_start_trans(osb, OCFS2_GROUP_EXTEND_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tmlog_errno(PTR_ERR(handle));\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\t/* update the last group descriptor and inode. */\n\tret = ocfs2_update_last_group_and_inode(handle, main_bm_inode,\n\t\t\t\t\t\tmain_bm_bh, group_bh,\n\t\t\t\t\t\tfirst_new_cluster,\n\t\t\t\t\t\tnew_clusters);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tocfs2_update_super_and_backups(main_bm_inode, new_clusters);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\nout_unlock:\n\tbrelse(group_bh);\n\tbrelse(main_bm_bh);\n\n\tocfs2_inode_unlock(main_bm_inode, 1);\n\nout_mutex:\n\tmutex_unlock(&main_bm_inode->i_mutex);\n\tiput(main_bm_inode);\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"resize.h\"",
      "#include \"suballoc.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "main_bm_inode"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&main_bm_inode->i_mutex"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "main_bm_inode",
            "1"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "main_bm_bh"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "handle"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_update_super_and_backups",
          "args": [
            "main_bm_inode",
            "new_clusters"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_update_super_and_backups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/resize.c",
          "lines": "216-257",
          "snippet": "static void ocfs2_update_super_and_backups(struct inode *inode,\n\t\t\t\t\t   int new_clusters)\n{\n\tint ret;\n\tu32 clusters = 0;\n\tstruct buffer_head *super_bh = NULL;\n\tstruct ocfs2_dinode *super_di = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\t/*\n\t * update the superblock last.\n\t * It doesn't matter if the write failed.\n\t */\n\tret = ocfs2_read_blocks_sync(osb, OCFS2_SUPER_BLOCK_BLKNO, 1,\n\t\t\t\t     &super_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tsuper_di = (struct ocfs2_dinode *)super_bh->b_data;\n\tle32_add_cpu(&super_di->i_clusters, new_clusters);\n\tclusters = le32_to_cpu(super_di->i_clusters);\n\n\tret = ocfs2_write_super_or_backup(osb, super_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (OCFS2_HAS_COMPAT_FEATURE(osb->sb, OCFS2_FEATURE_COMPAT_BACKUP_SB))\n\t\tret = update_backups(inode, clusters, super_bh->b_data);\n\nout:\n\tbrelse(super_bh);\n\tif (ret)\n\t\tprintk(KERN_WARNING \"ocfs2: Failed to update super blocks on %s\"\n\t\t\t\" during fs resize. This condition is not fatal,\"\n\t\t\t\" but fsck.ocfs2 should be run to fix it\\n\",\n\t\t\tosb->dev_str);\n\treturn;\n}",
          "includes": [
            "#include \"resize.h\"",
            "#include \"suballoc.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"resize.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_update_super_and_backups(struct inode *inode,\n\t\t\t\t\t   int new_clusters)\n{\n\tint ret;\n\tu32 clusters = 0;\n\tstruct buffer_head *super_bh = NULL;\n\tstruct ocfs2_dinode *super_di = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\t/*\n\t * update the superblock last.\n\t * It doesn't matter if the write failed.\n\t */\n\tret = ocfs2_read_blocks_sync(osb, OCFS2_SUPER_BLOCK_BLKNO, 1,\n\t\t\t\t     &super_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tsuper_di = (struct ocfs2_dinode *)super_bh->b_data;\n\tle32_add_cpu(&super_di->i_clusters, new_clusters);\n\tclusters = le32_to_cpu(super_di->i_clusters);\n\n\tret = ocfs2_write_super_or_backup(osb, super_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (OCFS2_HAS_COMPAT_FEATURE(osb->sb, OCFS2_FEATURE_COMPAT_BACKUP_SB))\n\t\tret = update_backups(inode, clusters, super_bh->b_data);\n\nout:\n\tbrelse(super_bh);\n\tif (ret)\n\t\tprintk(KERN_WARNING \"ocfs2: Failed to update super blocks on %s\"\n\t\t\t\" during fs resize. This condition is not fatal,\"\n\t\t\t\" but fsck.ocfs2 should be run to fix it\\n\",\n\t\t\tosb->dev_str);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_update_last_group_and_inode",
          "args": [
            "handle",
            "main_bm_inode",
            "main_bm_bh",
            "group_bh",
            "first_new_cluster",
            "new_clusters"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_update_last_group_and_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/resize.c",
          "lines": "86-175",
          "snippet": "static int ocfs2_update_last_group_and_inode(handle_t *handle,\n\t\t\t\t\t     struct inode *bm_inode,\n\t\t\t\t\t     struct buffer_head *bm_bh,\n\t\t\t\t\t     struct buffer_head *group_bh,\n\t\t\t\t\t     u32 first_new_cluster,\n\t\t\t\t\t     int new_clusters)\n{\n\tint ret = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(bm_inode->i_sb);\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) bm_bh->b_data;\n\tstruct ocfs2_chain_list *cl = &fe->id2.i_chain;\n\tstruct ocfs2_chain_rec *cr;\n\tstruct ocfs2_group_desc *group;\n\tu16 chain, num_bits, backups = 0;\n\tu16 cl_bpc = le16_to_cpu(cl->cl_bpc);\n\tu16 cl_cpg = le16_to_cpu(cl->cl_cpg);\n\n\ttrace_ocfs2_update_last_group_and_inode(new_clusters,\n\t\t\t\t\t\tfirst_new_cluster);\n\n\tret = ocfs2_journal_access_gd(handle, INODE_CACHE(bm_inode),\n\t\t\t\t      group_bh, OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tgroup = (struct ocfs2_group_desc *)group_bh->b_data;\n\n\t/* update the group first. */\n\tnum_bits = new_clusters * cl_bpc;\n\tle16_add_cpu(&group->bg_bits, num_bits);\n\tle16_add_cpu(&group->bg_free_bits_count, num_bits);\n\n\t/*\n\t * check whether there are some new backup superblocks exist in\n\t * this group and update the group bitmap accordingly.\n\t */\n\tif (OCFS2_HAS_COMPAT_FEATURE(osb->sb,\n\t\t\t\t     OCFS2_FEATURE_COMPAT_BACKUP_SB)) {\n\t\tbackups = ocfs2_calc_new_backup_super(bm_inode,\n\t\t\t\t\t\t     group,\n\t\t\t\t\t\t     cl_cpg, 1);\n\t\tle16_add_cpu(&group->bg_free_bits_count, -1 * backups);\n\t}\n\n\tocfs2_journal_dirty(handle, group_bh);\n\n\t/* update the inode accordingly. */\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(bm_inode), bm_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out_rollback;\n\t}\n\n\tchain = le16_to_cpu(group->bg_chain);\n\tcr = (&cl->cl_recs[chain]);\n\tle32_add_cpu(&cr->c_total, num_bits);\n\tle32_add_cpu(&cr->c_free, num_bits);\n\tle32_add_cpu(&fe->id1.bitmap1.i_total, num_bits);\n\tle32_add_cpu(&fe->i_clusters, new_clusters);\n\n\tif (backups) {\n\t\tle32_add_cpu(&cr->c_free, -1 * backups);\n\t\tle32_add_cpu(&fe->id1.bitmap1.i_used, backups);\n\t}\n\n\tspin_lock(&OCFS2_I(bm_inode)->ip_lock);\n\tOCFS2_I(bm_inode)->ip_clusters = le32_to_cpu(fe->i_clusters);\n\tle64_add_cpu(&fe->i_size, (u64)new_clusters << osb->s_clustersize_bits);\n\tspin_unlock(&OCFS2_I(bm_inode)->ip_lock);\n\ti_size_write(bm_inode, le64_to_cpu(fe->i_size));\n\n\tocfs2_journal_dirty(handle, bm_bh);\n\nout_rollback:\n\tif (ret < 0) {\n\t\tocfs2_calc_new_backup_super(bm_inode,\n\t\t\t\t\t    group,\n\t\t\t\t\t    cl_cpg, 0);\n\t\tle16_add_cpu(&group->bg_free_bits_count, backups);\n\t\tle16_add_cpu(&group->bg_bits, -1 * num_bits);\n\t\tle16_add_cpu(&group->bg_free_bits_count, -1 * num_bits);\n\t}\nout:\n\tif (ret)\n\t\tmlog_errno(ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"resize.h\"",
            "#include \"suballoc.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"resize.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_update_last_group_and_inode(handle_t *handle,\n\t\t\t\t\t     struct inode *bm_inode,\n\t\t\t\t\t     struct buffer_head *bm_bh,\n\t\t\t\t\t     struct buffer_head *group_bh,\n\t\t\t\t\t     u32 first_new_cluster,\n\t\t\t\t\t     int new_clusters)\n{\n\tint ret = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(bm_inode->i_sb);\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) bm_bh->b_data;\n\tstruct ocfs2_chain_list *cl = &fe->id2.i_chain;\n\tstruct ocfs2_chain_rec *cr;\n\tstruct ocfs2_group_desc *group;\n\tu16 chain, num_bits, backups = 0;\n\tu16 cl_bpc = le16_to_cpu(cl->cl_bpc);\n\tu16 cl_cpg = le16_to_cpu(cl->cl_cpg);\n\n\ttrace_ocfs2_update_last_group_and_inode(new_clusters,\n\t\t\t\t\t\tfirst_new_cluster);\n\n\tret = ocfs2_journal_access_gd(handle, INODE_CACHE(bm_inode),\n\t\t\t\t      group_bh, OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tgroup = (struct ocfs2_group_desc *)group_bh->b_data;\n\n\t/* update the group first. */\n\tnum_bits = new_clusters * cl_bpc;\n\tle16_add_cpu(&group->bg_bits, num_bits);\n\tle16_add_cpu(&group->bg_free_bits_count, num_bits);\n\n\t/*\n\t * check whether there are some new backup superblocks exist in\n\t * this group and update the group bitmap accordingly.\n\t */\n\tif (OCFS2_HAS_COMPAT_FEATURE(osb->sb,\n\t\t\t\t     OCFS2_FEATURE_COMPAT_BACKUP_SB)) {\n\t\tbackups = ocfs2_calc_new_backup_super(bm_inode,\n\t\t\t\t\t\t     group,\n\t\t\t\t\t\t     cl_cpg, 1);\n\t\tle16_add_cpu(&group->bg_free_bits_count, -1 * backups);\n\t}\n\n\tocfs2_journal_dirty(handle, group_bh);\n\n\t/* update the inode accordingly. */\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(bm_inode), bm_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out_rollback;\n\t}\n\n\tchain = le16_to_cpu(group->bg_chain);\n\tcr = (&cl->cl_recs[chain]);\n\tle32_add_cpu(&cr->c_total, num_bits);\n\tle32_add_cpu(&cr->c_free, num_bits);\n\tle32_add_cpu(&fe->id1.bitmap1.i_total, num_bits);\n\tle32_add_cpu(&fe->i_clusters, new_clusters);\n\n\tif (backups) {\n\t\tle32_add_cpu(&cr->c_free, -1 * backups);\n\t\tle32_add_cpu(&fe->id1.bitmap1.i_used, backups);\n\t}\n\n\tspin_lock(&OCFS2_I(bm_inode)->ip_lock);\n\tOCFS2_I(bm_inode)->ip_clusters = le32_to_cpu(fe->i_clusters);\n\tle64_add_cpu(&fe->i_size, (u64)new_clusters << osb->s_clustersize_bits);\n\tspin_unlock(&OCFS2_I(bm_inode)->ip_lock);\n\ti_size_write(bm_inode, le64_to_cpu(fe->i_size));\n\n\tocfs2_journal_dirty(handle, bm_bh);\n\nout_rollback:\n\tif (ret < 0) {\n\t\tocfs2_calc_new_backup_super(bm_inode,\n\t\t\t\t\t    group,\n\t\t\t\t\t    cl_cpg, 0);\n\t\tle16_add_cpu(&group->bg_free_bits_count, backups);\n\t\tle16_add_cpu(&group->bg_bits, -1 * num_bits);\n\t\tle16_add_cpu(&group->bg_free_bits_count, -1 * num_bits);\n\t}\nout:\n\tif (ret)\n\t\tmlog_errno(ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "PTR_ERR(handle)"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "OCFS2_GROUP_EXTEND_CREDITS"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_group_extend",
          "args": [
            "(unsigned long long)le64_to_cpu(group->bg_blkno)",
            "new_clusters"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "group->bg_blkno"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "fe->id2.i_chain.cl_cpg"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_group_descriptor",
          "args": [
            "main_bm_inode",
            "fe",
            "lgd_blkno",
            "&group_bh"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_group_descriptor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "326-349",
          "snippet": "int ocfs2_read_group_descriptor(struct inode *inode, struct ocfs2_dinode *di,\n\t\t\t\tu64 gd_blkno, struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(INODE_CACHE(inode), gd_blkno, &tmp,\n\t\t\t      ocfs2_validate_group_descriptor);\n\tif (rc)\n\t\tgoto out;\n\n\trc = ocfs2_validate_gd_parent(inode->i_sb, di, tmp, 0);\n\tif (rc) {\n\t\tbrelse(tmp);\n\t\tgoto out;\n\t}\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!*bh)\n\t\t*bh = tmp;\n\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_group_descriptor(struct inode *inode, struct ocfs2_dinode *di,\n\t\t\t\tu64 gd_blkno, struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(INODE_CACHE(inode), gd_blkno, &tmp,\n\t\t\t      ocfs2_validate_group_descriptor);\n\tif (rc)\n\t\tgoto out;\n\n\trc = ocfs2_validate_gd_parent(inode->i_sb, di, tmp, 0);\n\tif (rc) {\n\t\tbrelse(tmp);\n\t\tgoto out;\n\t}\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!*bh)\n\t\t*bh = tmp;\n\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_which_cluster_group",
          "args": [
            "main_bm_inode",
            "first_new_cluster - 1"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_which_cluster_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2260-2272",
          "snippet": "u64 ocfs2_which_cluster_group(struct inode *inode, u32 cluster)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tu32 group_no;\n\n\tBUG_ON(!ocfs2_is_cluster_bitmap(inode));\n\n\tgroup_no = cluster / osb->bitmap_cpg;\n\tif (!group_no)\n\t\treturn osb->first_cluster_group_blkno;\n\treturn ocfs2_clusters_to_blocks(inode->i_sb,\n\t\t\t\t\tgroup_no * osb->bitmap_cpg);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nu64 ocfs2_which_cluster_group(struct inode *inode, u32 cluster)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tu32 group_no;\n\n\tBUG_ON(!ocfs2_is_cluster_bitmap(inode));\n\n\tgroup_no = cluster / osb->bitmap_cpg;\n\tif (!group_no)\n\t\treturn osb->first_cluster_group_blkno;\n\treturn ocfs2_clusters_to_blocks(inode->i_sb,\n\t\t\t\t\tgroup_no * osb->bitmap_cpg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "fe->i_clusters"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"The disk is too old and small. \"\n\t\t     \"Force to do offline resize.\""
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_group_bitmap_size",
          "args": [
            "osb->sb",
            "0",
            "osb->s_feature_incompat"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_group_bitmap_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1547-1565",
          "snippet": "static inline int ocfs2_group_bitmap_size(int blocksize,\n\t\t\t\t\t  int suballocator,\n\t\t\t\t\t  uint32_t feature_incompat)\n{\n\tint size = sb->s_blocksize -\n\t\toffsetof(struct ocfs2_group_desc, bg_bitmap);\n\n\t/*\n\t * The cluster allocator uses the entire block.  Suballocators have\n\t * never used more than OCFS2_MAX_BG_BITMAP_SIZE.  Unfortunately, older\n\t * code expects bg_size set to the maximum.  Thus we must keep\n\t * bg_size as-is unless discontig_bg is enabled.\n\t */\n\tif (suballocator &&\n\t    (feature_incompat & OCFS2_FEATURE_INCOMPAT_DISCONTIG_BG))\n\t\tsize = OCFS2_MAX_BG_BITMAP_SIZE;\n\n\treturn size;\n}",
          "includes": [],
          "macros_used": [
            "#define OCFS2_MAX_BG_BITMAP_SIZE\t256",
            "#define OCFS2_FEATURE_INCOMPAT_DISCONTIG_BG\t0x2000"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define OCFS2_MAX_BG_BITMAP_SIZE\t256\n#define OCFS2_FEATURE_INCOMPAT_DISCONTIG_BG\t0x2000\n\nstatic inline int ocfs2_group_bitmap_size(int blocksize,\n\t\t\t\t\t  int suballocator,\n\t\t\t\t\t  uint32_t feature_incompat)\n{\n\tint size = sb->s_blocksize -\n\t\toffsetof(struct ocfs2_group_desc, bg_bitmap);\n\n\t/*\n\t * The cluster allocator uses the entire block.  Suballocators have\n\t * never used more than OCFS2_MAX_BG_BITMAP_SIZE.  Unfortunately, older\n\t * code expects bg_size set to the maximum.  Thus we must keep\n\t * bg_size as-is unless discontig_bg is enabled.\n\t */\n\tif (suballocator &&\n\t    (feature_incompat & OCFS2_FEATURE_INCOMPAT_DISCONTIG_BG))\n\t\tsize = OCFS2_MAX_BG_BITMAP_SIZE;\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!OCFS2_IS_VALID_DINODE(fe)"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_IS_VALID_DINODE",
          "args": [
            "fe"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock",
          "args": [
            "main_bm_inode",
            "&main_bm_bh",
            "1"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_lock_atime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2455-2489",
          "snippet": "int ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);",
            "static inline int ocfs2_highest_compat_lock_level(int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\n\nint ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&main_bm_inode->i_mutex"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_system_file_inode",
          "args": [
            "osb",
            "GLOBAL_BITMAP_SYSTEM_INODE",
            "OCFS2_INVALID_SLOT"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "_ocfs2_get_system_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/sysfile.c",
          "lines": "138-181",
          "snippet": "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_is_soft_readonly",
          "args": [
            "osb"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_soft_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "626-635",
          "snippet": "static inline int ocfs2_is_soft_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_SOFT_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define OCFS2_OSB_SOFT_RO\t0x0001"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define OCFS2_OSB_SOFT_RO\t0x0001\n\nstatic inline int ocfs2_is_soft_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_SOFT_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_is_hard_readonly",
          "args": [
            "osb"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_hard_readonly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "615-624",
          "snippet": "static inline int ocfs2_is_hard_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_HARD_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define OCFS2_OSB_HARD_RO\t0x0002"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define OCFS2_OSB_HARD_RO\t0x0002\n\nstatic inline int ocfs2_is_hard_readonly(struct ocfs2_super *osb)\n{\n\tint ret;\n\n\tspin_lock(&osb->osb_lock);\n\tret = osb->osb_flags & OCFS2_OSB_HARD_RO;\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"resize.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_group_extend(struct inode * inode, int new_clusters)\n{\n\tint ret;\n\thandle_t *handle;\n\tstruct buffer_head *main_bm_bh = NULL;\n\tstruct buffer_head *group_bh = NULL;\n\tstruct inode *main_bm_inode = NULL;\n\tstruct ocfs2_dinode *fe = NULL;\n\tstruct ocfs2_group_desc *group = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tu16 cl_bpc;\n\tu32 first_new_cluster;\n\tu64 lgd_blkno;\n\n\tif (ocfs2_is_hard_readonly(osb) || ocfs2_is_soft_readonly(osb))\n\t\treturn -EROFS;\n\n\tif (new_clusters < 0)\n\t\treturn -EINVAL;\n\telse if (new_clusters == 0)\n\t\treturn 0;\n\n\tmain_bm_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t    GLOBAL_BITMAP_SYSTEM_INODE,\n\t\t\t\t\t\t    OCFS2_INVALID_SLOT);\n\tif (!main_bm_inode) {\n\t\tret = -EINVAL;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&main_bm_inode->i_mutex);\n\n\tret = ocfs2_inode_lock(main_bm_inode, &main_bm_bh, 1);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out_mutex;\n\t}\n\n\tfe = (struct ocfs2_dinode *)main_bm_bh->b_data;\n\n\t/* main_bm_bh is validated by inode read inside ocfs2_inode_lock(),\n\t * so any corruption is a code bug. */\n\tBUG_ON(!OCFS2_IS_VALID_DINODE(fe));\n\n\tif (le16_to_cpu(fe->id2.i_chain.cl_cpg) !=\n\t\tocfs2_group_bitmap_size(osb->sb, 0,\n\t\t\t\t\tosb->s_feature_incompat) * 8) {\n\t\tmlog(ML_ERROR, \"The disk is too old and small. \"\n\t\t     \"Force to do offline resize.\");\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tfirst_new_cluster = le32_to_cpu(fe->i_clusters);\n\tlgd_blkno = ocfs2_which_cluster_group(main_bm_inode,\n\t\t\t\t\t      first_new_cluster - 1);\n\n\tret = ocfs2_read_group_descriptor(main_bm_inode, fe, lgd_blkno,\n\t\t\t\t\t  &group_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out_unlock;\n\t}\n\tgroup = (struct ocfs2_group_desc *)group_bh->b_data;\n\n\tcl_bpc = le16_to_cpu(fe->id2.i_chain.cl_bpc);\n\tif (le16_to_cpu(group->bg_bits) / cl_bpc + new_clusters >\n\t\tle16_to_cpu(fe->id2.i_chain.cl_cpg)) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\n\ttrace_ocfs2_group_extend(\n\t     (unsigned long long)le64_to_cpu(group->bg_blkno), new_clusters);\n\n\thandle = ocfs2_start_trans(osb, OCFS2_GROUP_EXTEND_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tmlog_errno(PTR_ERR(handle));\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\t/* update the last group descriptor and inode. */\n\tret = ocfs2_update_last_group_and_inode(handle, main_bm_inode,\n\t\t\t\t\t\tmain_bm_bh, group_bh,\n\t\t\t\t\t\tfirst_new_cluster,\n\t\t\t\t\t\tnew_clusters);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tocfs2_update_super_and_backups(main_bm_inode, new_clusters);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\nout_unlock:\n\tbrelse(group_bh);\n\tbrelse(main_bm_bh);\n\n\tocfs2_inode_unlock(main_bm_inode, 1);\n\nout_mutex:\n\tmutex_unlock(&main_bm_inode->i_mutex);\n\tiput(main_bm_inode);\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_update_super_and_backups",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/resize.c",
    "lines": "216-257",
    "snippet": "static void ocfs2_update_super_and_backups(struct inode *inode,\n\t\t\t\t\t   int new_clusters)\n{\n\tint ret;\n\tu32 clusters = 0;\n\tstruct buffer_head *super_bh = NULL;\n\tstruct ocfs2_dinode *super_di = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\t/*\n\t * update the superblock last.\n\t * It doesn't matter if the write failed.\n\t */\n\tret = ocfs2_read_blocks_sync(osb, OCFS2_SUPER_BLOCK_BLKNO, 1,\n\t\t\t\t     &super_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tsuper_di = (struct ocfs2_dinode *)super_bh->b_data;\n\tle32_add_cpu(&super_di->i_clusters, new_clusters);\n\tclusters = le32_to_cpu(super_di->i_clusters);\n\n\tret = ocfs2_write_super_or_backup(osb, super_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (OCFS2_HAS_COMPAT_FEATURE(osb->sb, OCFS2_FEATURE_COMPAT_BACKUP_SB))\n\t\tret = update_backups(inode, clusters, super_bh->b_data);\n\nout:\n\tbrelse(super_bh);\n\tif (ret)\n\t\tprintk(KERN_WARNING \"ocfs2: Failed to update super blocks on %s\"\n\t\t\t\" during fs resize. This condition is not fatal,\"\n\t\t\t\" but fsck.ocfs2 should be run to fix it\\n\",\n\t\t\tosb->dev_str);\n\treturn;\n}",
    "includes": [
      "#include \"resize.h\"",
      "#include \"suballoc.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"ocfs2: Failed to update super blocks on %s\"\n\t\t\t\" during fs resize. This condition is not fatal,\"\n\t\t\t\" but fsck.ocfs2 should be run to fix it\\n\"",
            "osb->dev_str"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "super_bh"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_backups",
          "args": [
            "inode",
            "clusters",
            "super_bh->b_data"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "update_backups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/resize.c",
          "lines": "177-214",
          "snippet": "static int update_backups(struct inode * inode, u32 clusters, char *data)\n{\n\tint i, ret = 0;\n\tu32 cluster;\n\tu64 blkno;\n\tstruct buffer_head *backup = NULL;\n\tstruct ocfs2_dinode *backup_di = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\t/* calculate the real backups we need to update. */\n\tfor (i = 0; i < OCFS2_MAX_BACKUP_SUPERBLOCKS; i++) {\n\t\tblkno = ocfs2_backup_super_blkno(inode->i_sb, i);\n\t\tcluster = ocfs2_blocks_to_clusters(inode->i_sb, blkno);\n\t\tif (cluster > clusters)\n\t\t\tbreak;\n\n\t\tret = ocfs2_read_blocks_sync(osb, blkno, 1, &backup);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tmemcpy(backup->b_data, data, inode->i_sb->s_blocksize);\n\n\t\tbackup_di = (struct ocfs2_dinode *)backup->b_data;\n\t\tbackup_di->i_blkno = cpu_to_le64(blkno);\n\n\t\tret = ocfs2_write_super_or_backup(osb, backup);\n\t\tbrelse(backup);\n\t\tbackup = NULL;\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"resize.h\"",
            "#include \"suballoc.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"resize.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int update_backups(struct inode * inode, u32 clusters, char *data)\n{\n\tint i, ret = 0;\n\tu32 cluster;\n\tu64 blkno;\n\tstruct buffer_head *backup = NULL;\n\tstruct ocfs2_dinode *backup_di = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\t/* calculate the real backups we need to update. */\n\tfor (i = 0; i < OCFS2_MAX_BACKUP_SUPERBLOCKS; i++) {\n\t\tblkno = ocfs2_backup_super_blkno(inode->i_sb, i);\n\t\tcluster = ocfs2_blocks_to_clusters(inode->i_sb, blkno);\n\t\tif (cluster > clusters)\n\t\t\tbreak;\n\n\t\tret = ocfs2_read_blocks_sync(osb, blkno, 1, &backup);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tmemcpy(backup->b_data, data, inode->i_sb->s_blocksize);\n\n\t\tbackup_di = (struct ocfs2_dinode *)backup->b_data;\n\t\tbackup_di->i_blkno = cpu_to_le64(blkno);\n\n\t\tret = ocfs2_write_super_or_backup(osb, backup);\n\t\tbrelse(backup);\n\t\tbackup = NULL;\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_HAS_COMPAT_FEATURE",
          "args": [
            "osb->sb",
            "OCFS2_FEATURE_COMPAT_BACKUP_SB"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_write_super_or_backup",
          "args": [
            "osb",
            "super_bh"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_write_super_or_backup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/buffer_head_io.c",
          "lines": "392-427",
          "snippet": "int ocfs2_write_super_or_backup(struct ocfs2_super *osb,\n\t\t\t\tstruct buffer_head *bh)\n{\n\tint ret = 0;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)bh->b_data;\n\n\tBUG_ON(buffer_jbd(bh));\n\tocfs2_check_super_or_backup(osb->sb, bh->b_blocknr);\n\n\tif (ocfs2_is_hard_readonly(osb) || ocfs2_is_soft_readonly(osb)) {\n\t\tret = -EROFS;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tlock_buffer(bh);\n\tset_buffer_uptodate(bh);\n\n\t/* remove from dirty list before I/O. */\n\tclear_buffer_dirty(bh);\n\n\tget_bh(bh); /* for end_buffer_write_sync() */\n\tbh->b_end_io = end_buffer_write_sync;\n\tocfs2_compute_meta_ecc(osb->sb, bh->b_data, &di->i_check);\n\tsubmit_bh(WRITE, bh);\n\n\twait_on_buffer(bh);\n\n\tif (!buffer_uptodate(bh)) {\n\t\tret = -EIO;\n\t\tmlog_errno(ret);\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_write_super_or_backup(struct ocfs2_super *osb,\n\t\t\t\tstruct buffer_head *bh)\n{\n\tint ret = 0;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)bh->b_data;\n\n\tBUG_ON(buffer_jbd(bh));\n\tocfs2_check_super_or_backup(osb->sb, bh->b_blocknr);\n\n\tif (ocfs2_is_hard_readonly(osb) || ocfs2_is_soft_readonly(osb)) {\n\t\tret = -EROFS;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tlock_buffer(bh);\n\tset_buffer_uptodate(bh);\n\n\t/* remove from dirty list before I/O. */\n\tclear_buffer_dirty(bh);\n\n\tget_bh(bh); /* for end_buffer_write_sync() */\n\tbh->b_end_io = end_buffer_write_sync;\n\tocfs2_compute_meta_ecc(osb->sb, bh->b_data, &di->i_check);\n\tsubmit_bh(WRITE, bh);\n\n\twait_on_buffer(bh);\n\n\tif (!buffer_uptodate(bh)) {\n\t\tret = -EIO;\n\t\tmlog_errno(ret);\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "super_di->i_clusters"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&super_di->i_clusters",
            "new_clusters"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_blocks_sync",
          "args": [
            "osb",
            "OCFS2_SUPER_BLOCK_BLKNO",
            "1",
            "&super_bh"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_blocks_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/buffer_head_io.c",
          "lines": "101-174",
          "snippet": "int ocfs2_read_blocks_sync(struct ocfs2_super *osb, u64 block,\n\t\t\t   unsigned int nr, struct buffer_head *bhs[])\n{\n\tint status = 0;\n\tunsigned int i;\n\tstruct buffer_head *bh;\n\n\ttrace_ocfs2_read_blocks_sync((unsigned long long)block, nr);\n\n\tif (!nr)\n\t\tgoto bail;\n\n\tfor (i = 0 ; i < nr ; i++) {\n\t\tif (bhs[i] == NULL) {\n\t\t\tbhs[i] = sb_getblk(osb->sb, block++);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tbh = bhs[i];\n\n\t\tif (buffer_jbd(bh)) {\n\t\t\ttrace_ocfs2_read_blocks_sync_jbd(\n\t\t\t\t\t(unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (buffer_dirty(bh)) {\n\t\t\t/* This should probably be a BUG, or\n\t\t\t * at least return an error. */\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"trying to sync read a dirty \"\n\t\t\t     \"buffer! (blocknr = %llu), skipping\\n\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlock_buffer(bh);\n\t\tif (buffer_jbd(bh)) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"block %llu had the JBD bit set \"\n\t\t\t     \"while I was in lock_buffer!\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tBUG();\n\t\t}\n\n\t\tclear_buffer_uptodate(bh);\n\t\tget_bh(bh); /* for end_buffer_read_sync() */\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(READ, bh);\n\t}\n\n\tfor (i = nr; i > 0; i--) {\n\t\tbh = bhs[i - 1];\n\n\t\t/* No need to wait on the buffer if it's managed by JBD. */\n\t\tif (!buffer_jbd(bh))\n\t\t\twait_on_buffer(bh);\n\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* Status won't be cleared from here on out,\n\t\t\t * so we can safely record this and loop back\n\t\t\t * to cleanup the other buffers. */\n\t\t\tstatus = -EIO;\n\t\t\tput_bh(bh);\n\t\t\tbhs[i - 1] = NULL;\n\t\t}\n\t}\n\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_blocks_sync(struct ocfs2_super *osb, u64 block,\n\t\t\t   unsigned int nr, struct buffer_head *bhs[])\n{\n\tint status = 0;\n\tunsigned int i;\n\tstruct buffer_head *bh;\n\n\ttrace_ocfs2_read_blocks_sync((unsigned long long)block, nr);\n\n\tif (!nr)\n\t\tgoto bail;\n\n\tfor (i = 0 ; i < nr ; i++) {\n\t\tif (bhs[i] == NULL) {\n\t\t\tbhs[i] = sb_getblk(osb->sb, block++);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tbh = bhs[i];\n\n\t\tif (buffer_jbd(bh)) {\n\t\t\ttrace_ocfs2_read_blocks_sync_jbd(\n\t\t\t\t\t(unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (buffer_dirty(bh)) {\n\t\t\t/* This should probably be a BUG, or\n\t\t\t * at least return an error. */\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"trying to sync read a dirty \"\n\t\t\t     \"buffer! (blocknr = %llu), skipping\\n\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlock_buffer(bh);\n\t\tif (buffer_jbd(bh)) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"block %llu had the JBD bit set \"\n\t\t\t     \"while I was in lock_buffer!\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tBUG();\n\t\t}\n\n\t\tclear_buffer_uptodate(bh);\n\t\tget_bh(bh); /* for end_buffer_read_sync() */\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(READ, bh);\n\t}\n\n\tfor (i = nr; i > 0; i--) {\n\t\tbh = bhs[i - 1];\n\n\t\t/* No need to wait on the buffer if it's managed by JBD. */\n\t\tif (!buffer_jbd(bh))\n\t\t\twait_on_buffer(bh);\n\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* Status won't be cleared from here on out,\n\t\t\t * so we can safely record this and loop back\n\t\t\t * to cleanup the other buffers. */\n\t\t\tstatus = -EIO;\n\t\t\tput_bh(bh);\n\t\t\tbhs[i - 1] = NULL;\n\t\t}\n\t}\n\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"resize.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_update_super_and_backups(struct inode *inode,\n\t\t\t\t\t   int new_clusters)\n{\n\tint ret;\n\tu32 clusters = 0;\n\tstruct buffer_head *super_bh = NULL;\n\tstruct ocfs2_dinode *super_di = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\t/*\n\t * update the superblock last.\n\t * It doesn't matter if the write failed.\n\t */\n\tret = ocfs2_read_blocks_sync(osb, OCFS2_SUPER_BLOCK_BLKNO, 1,\n\t\t\t\t     &super_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tsuper_di = (struct ocfs2_dinode *)super_bh->b_data;\n\tle32_add_cpu(&super_di->i_clusters, new_clusters);\n\tclusters = le32_to_cpu(super_di->i_clusters);\n\n\tret = ocfs2_write_super_or_backup(osb, super_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (OCFS2_HAS_COMPAT_FEATURE(osb->sb, OCFS2_FEATURE_COMPAT_BACKUP_SB))\n\t\tret = update_backups(inode, clusters, super_bh->b_data);\n\nout:\n\tbrelse(super_bh);\n\tif (ret)\n\t\tprintk(KERN_WARNING \"ocfs2: Failed to update super blocks on %s\"\n\t\t\t\" during fs resize. This condition is not fatal,\"\n\t\t\t\" but fsck.ocfs2 should be run to fix it\\n\",\n\t\t\tosb->dev_str);\n\treturn;\n}"
  },
  {
    "function_name": "update_backups",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/resize.c",
    "lines": "177-214",
    "snippet": "static int update_backups(struct inode * inode, u32 clusters, char *data)\n{\n\tint i, ret = 0;\n\tu32 cluster;\n\tu64 blkno;\n\tstruct buffer_head *backup = NULL;\n\tstruct ocfs2_dinode *backup_di = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\t/* calculate the real backups we need to update. */\n\tfor (i = 0; i < OCFS2_MAX_BACKUP_SUPERBLOCKS; i++) {\n\t\tblkno = ocfs2_backup_super_blkno(inode->i_sb, i);\n\t\tcluster = ocfs2_blocks_to_clusters(inode->i_sb, blkno);\n\t\tif (cluster > clusters)\n\t\t\tbreak;\n\n\t\tret = ocfs2_read_blocks_sync(osb, blkno, 1, &backup);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tmemcpy(backup->b_data, data, inode->i_sb->s_blocksize);\n\n\t\tbackup_di = (struct ocfs2_dinode *)backup->b_data;\n\t\tbackup_di->i_blkno = cpu_to_le64(blkno);\n\n\t\tret = ocfs2_write_super_or_backup(osb, backup);\n\t\tbrelse(backup);\n\t\tbackup = NULL;\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"resize.h\"",
      "#include \"suballoc.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "backup"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_write_super_or_backup",
          "args": [
            "osb",
            "backup"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_write_super_or_backup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/buffer_head_io.c",
          "lines": "392-427",
          "snippet": "int ocfs2_write_super_or_backup(struct ocfs2_super *osb,\n\t\t\t\tstruct buffer_head *bh)\n{\n\tint ret = 0;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)bh->b_data;\n\n\tBUG_ON(buffer_jbd(bh));\n\tocfs2_check_super_or_backup(osb->sb, bh->b_blocknr);\n\n\tif (ocfs2_is_hard_readonly(osb) || ocfs2_is_soft_readonly(osb)) {\n\t\tret = -EROFS;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tlock_buffer(bh);\n\tset_buffer_uptodate(bh);\n\n\t/* remove from dirty list before I/O. */\n\tclear_buffer_dirty(bh);\n\n\tget_bh(bh); /* for end_buffer_write_sync() */\n\tbh->b_end_io = end_buffer_write_sync;\n\tocfs2_compute_meta_ecc(osb->sb, bh->b_data, &di->i_check);\n\tsubmit_bh(WRITE, bh);\n\n\twait_on_buffer(bh);\n\n\tif (!buffer_uptodate(bh)) {\n\t\tret = -EIO;\n\t\tmlog_errno(ret);\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_write_super_or_backup(struct ocfs2_super *osb,\n\t\t\t\tstruct buffer_head *bh)\n{\n\tint ret = 0;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)bh->b_data;\n\n\tBUG_ON(buffer_jbd(bh));\n\tocfs2_check_super_or_backup(osb->sb, bh->b_blocknr);\n\n\tif (ocfs2_is_hard_readonly(osb) || ocfs2_is_soft_readonly(osb)) {\n\t\tret = -EROFS;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tlock_buffer(bh);\n\tset_buffer_uptodate(bh);\n\n\t/* remove from dirty list before I/O. */\n\tclear_buffer_dirty(bh);\n\n\tget_bh(bh); /* for end_buffer_write_sync() */\n\tbh->b_end_io = end_buffer_write_sync;\n\tocfs2_compute_meta_ecc(osb->sb, bh->b_data, &di->i_check);\n\tsubmit_bh(WRITE, bh);\n\n\twait_on_buffer(bh);\n\n\tif (!buffer_uptodate(bh)) {\n\t\tret = -EIO;\n\t\tmlog_errno(ret);\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "blkno"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "backup->b_data",
            "data",
            "inode->i_sb->s_blocksize"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_blocks_sync",
          "args": [
            "osb",
            "blkno",
            "1",
            "&backup"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_blocks_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/buffer_head_io.c",
          "lines": "101-174",
          "snippet": "int ocfs2_read_blocks_sync(struct ocfs2_super *osb, u64 block,\n\t\t\t   unsigned int nr, struct buffer_head *bhs[])\n{\n\tint status = 0;\n\tunsigned int i;\n\tstruct buffer_head *bh;\n\n\ttrace_ocfs2_read_blocks_sync((unsigned long long)block, nr);\n\n\tif (!nr)\n\t\tgoto bail;\n\n\tfor (i = 0 ; i < nr ; i++) {\n\t\tif (bhs[i] == NULL) {\n\t\t\tbhs[i] = sb_getblk(osb->sb, block++);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tbh = bhs[i];\n\n\t\tif (buffer_jbd(bh)) {\n\t\t\ttrace_ocfs2_read_blocks_sync_jbd(\n\t\t\t\t\t(unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (buffer_dirty(bh)) {\n\t\t\t/* This should probably be a BUG, or\n\t\t\t * at least return an error. */\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"trying to sync read a dirty \"\n\t\t\t     \"buffer! (blocknr = %llu), skipping\\n\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlock_buffer(bh);\n\t\tif (buffer_jbd(bh)) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"block %llu had the JBD bit set \"\n\t\t\t     \"while I was in lock_buffer!\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tBUG();\n\t\t}\n\n\t\tclear_buffer_uptodate(bh);\n\t\tget_bh(bh); /* for end_buffer_read_sync() */\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(READ, bh);\n\t}\n\n\tfor (i = nr; i > 0; i--) {\n\t\tbh = bhs[i - 1];\n\n\t\t/* No need to wait on the buffer if it's managed by JBD. */\n\t\tif (!buffer_jbd(bh))\n\t\t\twait_on_buffer(bh);\n\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* Status won't be cleared from here on out,\n\t\t\t * so we can safely record this and loop back\n\t\t\t * to cleanup the other buffers. */\n\t\t\tstatus = -EIO;\n\t\t\tput_bh(bh);\n\t\t\tbhs[i - 1] = NULL;\n\t\t}\n\t}\n\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_blocks_sync(struct ocfs2_super *osb, u64 block,\n\t\t\t   unsigned int nr, struct buffer_head *bhs[])\n{\n\tint status = 0;\n\tunsigned int i;\n\tstruct buffer_head *bh;\n\n\ttrace_ocfs2_read_blocks_sync((unsigned long long)block, nr);\n\n\tif (!nr)\n\t\tgoto bail;\n\n\tfor (i = 0 ; i < nr ; i++) {\n\t\tif (bhs[i] == NULL) {\n\t\t\tbhs[i] = sb_getblk(osb->sb, block++);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tbh = bhs[i];\n\n\t\tif (buffer_jbd(bh)) {\n\t\t\ttrace_ocfs2_read_blocks_sync_jbd(\n\t\t\t\t\t(unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (buffer_dirty(bh)) {\n\t\t\t/* This should probably be a BUG, or\n\t\t\t * at least return an error. */\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"trying to sync read a dirty \"\n\t\t\t     \"buffer! (blocknr = %llu), skipping\\n\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlock_buffer(bh);\n\t\tif (buffer_jbd(bh)) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"block %llu had the JBD bit set \"\n\t\t\t     \"while I was in lock_buffer!\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tBUG();\n\t\t}\n\n\t\tclear_buffer_uptodate(bh);\n\t\tget_bh(bh); /* for end_buffer_read_sync() */\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(READ, bh);\n\t}\n\n\tfor (i = nr; i > 0; i--) {\n\t\tbh = bhs[i - 1];\n\n\t\t/* No need to wait on the buffer if it's managed by JBD. */\n\t\tif (!buffer_jbd(bh))\n\t\t\twait_on_buffer(bh);\n\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* Status won't be cleared from here on out,\n\t\t\t * so we can safely record this and loop back\n\t\t\t * to cleanup the other buffers. */\n\t\t\tstatus = -EIO;\n\t\t\tput_bh(bh);\n\t\t\tbhs[i - 1] = NULL;\n\t\t}\n\t}\n\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_blocks_to_clusters",
          "args": [
            "inode->i_sb",
            "blkno"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_blocks_to_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "720-727",
          "snippet": "static inline u32 ocfs2_blocks_to_clusters(struct super_block *sb,\n\t\t\t\t\t   u64 blocks)\n{\n\tint b_to_c_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u32)(blocks >> b_to_c_bits);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u32 ocfs2_blocks_to_clusters(struct super_block *sb,\n\t\t\t\t\t   u64 blocks)\n{\n\tint b_to_c_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u32)(blocks >> b_to_c_bits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_backup_super_blkno",
          "args": [
            "inode->i_sb",
            "i"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_backup_super_blkno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1577-1588",
          "snippet": "static inline uint64_t ocfs2_backup_super_blkno(int blocksize, int index)\n{\n\tuint64_t offset = OCFS2_BACKUP_SB_START;\n\n\tif (index >= 0 && index < OCFS2_MAX_BACKUP_SUPERBLOCKS) {\n\t\toffset <<= (2 * index);\n\t\toffset /= blocksize;\n\t\treturn offset;\n\t}\n\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [
            "#define OCFS2_MAX_BACKUP_SUPERBLOCKS\t6",
            "#define OCFS2_BACKUP_SB_START\t\t\t1 << 30"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define OCFS2_MAX_BACKUP_SUPERBLOCKS\t6\n#define OCFS2_BACKUP_SB_START\t\t\t1 << 30\n\nstatic inline uint64_t ocfs2_backup_super_blkno(int blocksize, int index)\n{\n\tuint64_t offset = OCFS2_BACKUP_SB_START;\n\n\tif (index >= 0 && index < OCFS2_MAX_BACKUP_SUPERBLOCKS) {\n\t\toffset <<= (2 * index);\n\t\toffset /= blocksize;\n\t\treturn offset;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"resize.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int update_backups(struct inode * inode, u32 clusters, char *data)\n{\n\tint i, ret = 0;\n\tu32 cluster;\n\tu64 blkno;\n\tstruct buffer_head *backup = NULL;\n\tstruct ocfs2_dinode *backup_di = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\t/* calculate the real backups we need to update. */\n\tfor (i = 0; i < OCFS2_MAX_BACKUP_SUPERBLOCKS; i++) {\n\t\tblkno = ocfs2_backup_super_blkno(inode->i_sb, i);\n\t\tcluster = ocfs2_blocks_to_clusters(inode->i_sb, blkno);\n\t\tif (cluster > clusters)\n\t\t\tbreak;\n\n\t\tret = ocfs2_read_blocks_sync(osb, blkno, 1, &backup);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tmemcpy(backup->b_data, data, inode->i_sb->s_blocksize);\n\n\t\tbackup_di = (struct ocfs2_dinode *)backup->b_data;\n\t\tbackup_di->i_blkno = cpu_to_le64(blkno);\n\n\t\tret = ocfs2_write_super_or_backup(osb, backup);\n\t\tbrelse(backup);\n\t\tbackup = NULL;\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_update_last_group_and_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/resize.c",
    "lines": "86-175",
    "snippet": "static int ocfs2_update_last_group_and_inode(handle_t *handle,\n\t\t\t\t\t     struct inode *bm_inode,\n\t\t\t\t\t     struct buffer_head *bm_bh,\n\t\t\t\t\t     struct buffer_head *group_bh,\n\t\t\t\t\t     u32 first_new_cluster,\n\t\t\t\t\t     int new_clusters)\n{\n\tint ret = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(bm_inode->i_sb);\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) bm_bh->b_data;\n\tstruct ocfs2_chain_list *cl = &fe->id2.i_chain;\n\tstruct ocfs2_chain_rec *cr;\n\tstruct ocfs2_group_desc *group;\n\tu16 chain, num_bits, backups = 0;\n\tu16 cl_bpc = le16_to_cpu(cl->cl_bpc);\n\tu16 cl_cpg = le16_to_cpu(cl->cl_cpg);\n\n\ttrace_ocfs2_update_last_group_and_inode(new_clusters,\n\t\t\t\t\t\tfirst_new_cluster);\n\n\tret = ocfs2_journal_access_gd(handle, INODE_CACHE(bm_inode),\n\t\t\t\t      group_bh, OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tgroup = (struct ocfs2_group_desc *)group_bh->b_data;\n\n\t/* update the group first. */\n\tnum_bits = new_clusters * cl_bpc;\n\tle16_add_cpu(&group->bg_bits, num_bits);\n\tle16_add_cpu(&group->bg_free_bits_count, num_bits);\n\n\t/*\n\t * check whether there are some new backup superblocks exist in\n\t * this group and update the group bitmap accordingly.\n\t */\n\tif (OCFS2_HAS_COMPAT_FEATURE(osb->sb,\n\t\t\t\t     OCFS2_FEATURE_COMPAT_BACKUP_SB)) {\n\t\tbackups = ocfs2_calc_new_backup_super(bm_inode,\n\t\t\t\t\t\t     group,\n\t\t\t\t\t\t     cl_cpg, 1);\n\t\tle16_add_cpu(&group->bg_free_bits_count, -1 * backups);\n\t}\n\n\tocfs2_journal_dirty(handle, group_bh);\n\n\t/* update the inode accordingly. */\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(bm_inode), bm_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out_rollback;\n\t}\n\n\tchain = le16_to_cpu(group->bg_chain);\n\tcr = (&cl->cl_recs[chain]);\n\tle32_add_cpu(&cr->c_total, num_bits);\n\tle32_add_cpu(&cr->c_free, num_bits);\n\tle32_add_cpu(&fe->id1.bitmap1.i_total, num_bits);\n\tle32_add_cpu(&fe->i_clusters, new_clusters);\n\n\tif (backups) {\n\t\tle32_add_cpu(&cr->c_free, -1 * backups);\n\t\tle32_add_cpu(&fe->id1.bitmap1.i_used, backups);\n\t}\n\n\tspin_lock(&OCFS2_I(bm_inode)->ip_lock);\n\tOCFS2_I(bm_inode)->ip_clusters = le32_to_cpu(fe->i_clusters);\n\tle64_add_cpu(&fe->i_size, (u64)new_clusters << osb->s_clustersize_bits);\n\tspin_unlock(&OCFS2_I(bm_inode)->ip_lock);\n\ti_size_write(bm_inode, le64_to_cpu(fe->i_size));\n\n\tocfs2_journal_dirty(handle, bm_bh);\n\nout_rollback:\n\tif (ret < 0) {\n\t\tocfs2_calc_new_backup_super(bm_inode,\n\t\t\t\t\t    group,\n\t\t\t\t\t    cl_cpg, 0);\n\t\tle16_add_cpu(&group->bg_free_bits_count, backups);\n\t\tle16_add_cpu(&group->bg_bits, -1 * num_bits);\n\t\tle16_add_cpu(&group->bg_free_bits_count, -1 * num_bits);\n\t}\nout:\n\tif (ret)\n\t\tmlog_errno(ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"resize.h\"",
      "#include \"suballoc.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&group->bg_free_bits_count",
            "-1 * num_bits"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&group->bg_bits",
            "-1 * num_bits"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&group->bg_free_bits_count",
            "backups"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_calc_new_backup_super",
          "args": [
            "bm_inode",
            "group",
            "cl_cpg",
            "0"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_calc_new_backup_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/resize.c",
          "lines": "54-84",
          "snippet": "static u16 ocfs2_calc_new_backup_super(struct inode *inode,\n\t\t\t\t       struct ocfs2_group_desc *gd,\n\t\t\t\t       u16 cl_cpg,\n\t\t\t\t       int set)\n{\n\tint i;\n\tu16 backups = 0;\n\tu32 cluster;\n\tu64 blkno, gd_blkno, lgd_blkno = le64_to_cpu(gd->bg_blkno);\n\n\tfor (i = 0; i < OCFS2_MAX_BACKUP_SUPERBLOCKS; i++) {\n\t\tblkno = ocfs2_backup_super_blkno(inode->i_sb, i);\n\t\tcluster = ocfs2_blocks_to_clusters(inode->i_sb, blkno);\n\n\t\tgd_blkno = ocfs2_which_cluster_group(inode, cluster);\n\t\tif (gd_blkno < lgd_blkno)\n\t\t\tcontinue;\n\t\telse if (gd_blkno > lgd_blkno)\n\t\t\tbreak;\n\n\t\tif (set)\n\t\t\tocfs2_set_bit(cluster % cl_cpg,\n\t\t\t\t      (unsigned long *)gd->bg_bitmap);\n\t\telse\n\t\t\tocfs2_clear_bit(cluster % cl_cpg,\n\t\t\t\t\t(unsigned long *)gd->bg_bitmap);\n\t\tbackups++;\n\t}\n\n\treturn backups;\n}",
          "includes": [
            "#include \"resize.h\"",
            "#include \"suballoc.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"resize.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u16 ocfs2_calc_new_backup_super(struct inode *inode,\n\t\t\t\t       struct ocfs2_group_desc *gd,\n\t\t\t\t       u16 cl_cpg,\n\t\t\t\t       int set)\n{\n\tint i;\n\tu16 backups = 0;\n\tu32 cluster;\n\tu64 blkno, gd_blkno, lgd_blkno = le64_to_cpu(gd->bg_blkno);\n\n\tfor (i = 0; i < OCFS2_MAX_BACKUP_SUPERBLOCKS; i++) {\n\t\tblkno = ocfs2_backup_super_blkno(inode->i_sb, i);\n\t\tcluster = ocfs2_blocks_to_clusters(inode->i_sb, blkno);\n\n\t\tgd_blkno = ocfs2_which_cluster_group(inode, cluster);\n\t\tif (gd_blkno < lgd_blkno)\n\t\t\tcontinue;\n\t\telse if (gd_blkno > lgd_blkno)\n\t\t\tbreak;\n\n\t\tif (set)\n\t\t\tocfs2_set_bit(cluster % cl_cpg,\n\t\t\t\t      (unsigned long *)gd->bg_bitmap);\n\t\telse\n\t\t\tocfs2_clear_bit(cluster % cl_cpg,\n\t\t\t\t\t(unsigned long *)gd->bg_bitmap);\n\t\tbackups++;\n\t}\n\n\treturn backups;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "bm_bh"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "bm_inode",
            "le64_to_cpu(fe->i_size)"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "fe->i_size"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&OCFS2_I(bm_inode)->ip_lock"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "bm_inode"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_add_cpu",
          "args": [
            "&fe->i_size",
            "(u64)new_clusters << osb->s_clustersize_bits"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "fe->i_clusters"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&OCFS2_I(bm_inode)->ip_lock"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&fe->id1.bitmap1.i_used",
            "backups"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&cr->c_free",
            "-1 * backups"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&fe->i_clusters",
            "new_clusters"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&fe->id1.bitmap1.i_total",
            "num_bits"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&cr->c_free",
            "num_bits"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&cr->c_total",
            "num_bits"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "group->bg_chain"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_di",
          "args": [
            "handle",
            "INODE_CACHE(bm_inode)",
            "bm_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_di",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "710-714",
          "snippet": "int ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};\n\nint ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "bm_inode"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&group->bg_free_bits_count",
            "-1 * backups"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_HAS_COMPAT_FEATURE",
          "args": [
            "osb->sb",
            "OCFS2_FEATURE_COMPAT_BACKUP_SB"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&group->bg_free_bits_count",
            "num_bits"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&group->bg_bits",
            "num_bits"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_gd",
          "args": [
            "handle",
            "INODE_CACHE(bm_inode)",
            "group_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_gd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "729-733",
          "snippet": "int ocfs2_journal_access_gd(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &gd_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers gd_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_group_desc, bg_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers gd_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_group_desc, bg_check),\n};\n\nint ocfs2_journal_access_gd(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &gd_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_update_last_group_and_inode",
          "args": [
            "new_clusters",
            "first_new_cluster"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "bm_inode->i_sb"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"resize.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_update_last_group_and_inode(handle_t *handle,\n\t\t\t\t\t     struct inode *bm_inode,\n\t\t\t\t\t     struct buffer_head *bm_bh,\n\t\t\t\t\t     struct buffer_head *group_bh,\n\t\t\t\t\t     u32 first_new_cluster,\n\t\t\t\t\t     int new_clusters)\n{\n\tint ret = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(bm_inode->i_sb);\n\tstruct ocfs2_dinode *fe = (struct ocfs2_dinode *) bm_bh->b_data;\n\tstruct ocfs2_chain_list *cl = &fe->id2.i_chain;\n\tstruct ocfs2_chain_rec *cr;\n\tstruct ocfs2_group_desc *group;\n\tu16 chain, num_bits, backups = 0;\n\tu16 cl_bpc = le16_to_cpu(cl->cl_bpc);\n\tu16 cl_cpg = le16_to_cpu(cl->cl_cpg);\n\n\ttrace_ocfs2_update_last_group_and_inode(new_clusters,\n\t\t\t\t\t\tfirst_new_cluster);\n\n\tret = ocfs2_journal_access_gd(handle, INODE_CACHE(bm_inode),\n\t\t\t\t      group_bh, OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tgroup = (struct ocfs2_group_desc *)group_bh->b_data;\n\n\t/* update the group first. */\n\tnum_bits = new_clusters * cl_bpc;\n\tle16_add_cpu(&group->bg_bits, num_bits);\n\tle16_add_cpu(&group->bg_free_bits_count, num_bits);\n\n\t/*\n\t * check whether there are some new backup superblocks exist in\n\t * this group and update the group bitmap accordingly.\n\t */\n\tif (OCFS2_HAS_COMPAT_FEATURE(osb->sb,\n\t\t\t\t     OCFS2_FEATURE_COMPAT_BACKUP_SB)) {\n\t\tbackups = ocfs2_calc_new_backup_super(bm_inode,\n\t\t\t\t\t\t     group,\n\t\t\t\t\t\t     cl_cpg, 1);\n\t\tle16_add_cpu(&group->bg_free_bits_count, -1 * backups);\n\t}\n\n\tocfs2_journal_dirty(handle, group_bh);\n\n\t/* update the inode accordingly. */\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(bm_inode), bm_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out_rollback;\n\t}\n\n\tchain = le16_to_cpu(group->bg_chain);\n\tcr = (&cl->cl_recs[chain]);\n\tle32_add_cpu(&cr->c_total, num_bits);\n\tle32_add_cpu(&cr->c_free, num_bits);\n\tle32_add_cpu(&fe->id1.bitmap1.i_total, num_bits);\n\tle32_add_cpu(&fe->i_clusters, new_clusters);\n\n\tif (backups) {\n\t\tle32_add_cpu(&cr->c_free, -1 * backups);\n\t\tle32_add_cpu(&fe->id1.bitmap1.i_used, backups);\n\t}\n\n\tspin_lock(&OCFS2_I(bm_inode)->ip_lock);\n\tOCFS2_I(bm_inode)->ip_clusters = le32_to_cpu(fe->i_clusters);\n\tle64_add_cpu(&fe->i_size, (u64)new_clusters << osb->s_clustersize_bits);\n\tspin_unlock(&OCFS2_I(bm_inode)->ip_lock);\n\ti_size_write(bm_inode, le64_to_cpu(fe->i_size));\n\n\tocfs2_journal_dirty(handle, bm_bh);\n\nout_rollback:\n\tif (ret < 0) {\n\t\tocfs2_calc_new_backup_super(bm_inode,\n\t\t\t\t\t    group,\n\t\t\t\t\t    cl_cpg, 0);\n\t\tle16_add_cpu(&group->bg_free_bits_count, backups);\n\t\tle16_add_cpu(&group->bg_bits, -1 * num_bits);\n\t\tle16_add_cpu(&group->bg_free_bits_count, -1 * num_bits);\n\t}\nout:\n\tif (ret)\n\t\tmlog_errno(ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_calc_new_backup_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/resize.c",
    "lines": "54-84",
    "snippet": "static u16 ocfs2_calc_new_backup_super(struct inode *inode,\n\t\t\t\t       struct ocfs2_group_desc *gd,\n\t\t\t\t       u16 cl_cpg,\n\t\t\t\t       int set)\n{\n\tint i;\n\tu16 backups = 0;\n\tu32 cluster;\n\tu64 blkno, gd_blkno, lgd_blkno = le64_to_cpu(gd->bg_blkno);\n\n\tfor (i = 0; i < OCFS2_MAX_BACKUP_SUPERBLOCKS; i++) {\n\t\tblkno = ocfs2_backup_super_blkno(inode->i_sb, i);\n\t\tcluster = ocfs2_blocks_to_clusters(inode->i_sb, blkno);\n\n\t\tgd_blkno = ocfs2_which_cluster_group(inode, cluster);\n\t\tif (gd_blkno < lgd_blkno)\n\t\t\tcontinue;\n\t\telse if (gd_blkno > lgd_blkno)\n\t\t\tbreak;\n\n\t\tif (set)\n\t\t\tocfs2_set_bit(cluster % cl_cpg,\n\t\t\t\t      (unsigned long *)gd->bg_bitmap);\n\t\telse\n\t\t\tocfs2_clear_bit(cluster % cl_cpg,\n\t\t\t\t\t(unsigned long *)gd->bg_bitmap);\n\t\tbackups++;\n\t}\n\n\treturn backups;\n}",
    "includes": [
      "#include \"resize.h\"",
      "#include \"suballoc.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"uptodate.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"journal.h\"",
      "#include \"inode.h\"",
      "#include \"dlmglue.h\"",
      "#include \"alloc.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/types.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_clear_bit",
          "args": [
            "cluster % cl_cpg",
            "(unsigned long *)gd->bg_bitmap"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_set_bit",
          "args": [
            "cluster % cl_cpg",
            "(unsigned long *)gd->bg_bitmap"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_which_cluster_group",
          "args": [
            "inode",
            "cluster"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_which_cluster_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2260-2272",
          "snippet": "u64 ocfs2_which_cluster_group(struct inode *inode, u32 cluster)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tu32 group_no;\n\n\tBUG_ON(!ocfs2_is_cluster_bitmap(inode));\n\n\tgroup_no = cluster / osb->bitmap_cpg;\n\tif (!group_no)\n\t\treturn osb->first_cluster_group_blkno;\n\treturn ocfs2_clusters_to_blocks(inode->i_sb,\n\t\t\t\t\tgroup_no * osb->bitmap_cpg);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nu64 ocfs2_which_cluster_group(struct inode *inode, u32 cluster)\n{\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tu32 group_no;\n\n\tBUG_ON(!ocfs2_is_cluster_bitmap(inode));\n\n\tgroup_no = cluster / osb->bitmap_cpg;\n\tif (!group_no)\n\t\treturn osb->first_cluster_group_blkno;\n\treturn ocfs2_clusters_to_blocks(inode->i_sb,\n\t\t\t\t\tgroup_no * osb->bitmap_cpg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_blocks_to_clusters",
          "args": [
            "inode->i_sb",
            "blkno"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_blocks_to_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "720-727",
          "snippet": "static inline u32 ocfs2_blocks_to_clusters(struct super_block *sb,\n\t\t\t\t\t   u64 blocks)\n{\n\tint b_to_c_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u32)(blocks >> b_to_c_bits);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u32 ocfs2_blocks_to_clusters(struct super_block *sb,\n\t\t\t\t\t   u64 blocks)\n{\n\tint b_to_c_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u32)(blocks >> b_to_c_bits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_backup_super_blkno",
          "args": [
            "inode->i_sb",
            "i"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_backup_super_blkno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1577-1588",
          "snippet": "static inline uint64_t ocfs2_backup_super_blkno(int blocksize, int index)\n{\n\tuint64_t offset = OCFS2_BACKUP_SB_START;\n\n\tif (index >= 0 && index < OCFS2_MAX_BACKUP_SUPERBLOCKS) {\n\t\toffset <<= (2 * index);\n\t\toffset /= blocksize;\n\t\treturn offset;\n\t}\n\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [
            "#define OCFS2_MAX_BACKUP_SUPERBLOCKS\t6",
            "#define OCFS2_BACKUP_SB_START\t\t\t1 << 30"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define OCFS2_MAX_BACKUP_SUPERBLOCKS\t6\n#define OCFS2_BACKUP_SB_START\t\t\t1 << 30\n\nstatic inline uint64_t ocfs2_backup_super_blkno(int blocksize, int index)\n{\n\tuint64_t offset = OCFS2_BACKUP_SB_START;\n\n\tif (index >= 0 && index < OCFS2_MAX_BACKUP_SUPERBLOCKS) {\n\t\toffset <<= (2 * index);\n\t\toffset /= blocksize;\n\t\treturn offset;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "gd->bg_blkno"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"resize.h\"\n#include \"suballoc.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u16 ocfs2_calc_new_backup_super(struct inode *inode,\n\t\t\t\t       struct ocfs2_group_desc *gd,\n\t\t\t\t       u16 cl_cpg,\n\t\t\t\t       int set)\n{\n\tint i;\n\tu16 backups = 0;\n\tu32 cluster;\n\tu64 blkno, gd_blkno, lgd_blkno = le64_to_cpu(gd->bg_blkno);\n\n\tfor (i = 0; i < OCFS2_MAX_BACKUP_SUPERBLOCKS; i++) {\n\t\tblkno = ocfs2_backup_super_blkno(inode->i_sb, i);\n\t\tcluster = ocfs2_blocks_to_clusters(inode->i_sb, blkno);\n\n\t\tgd_blkno = ocfs2_which_cluster_group(inode, cluster);\n\t\tif (gd_blkno < lgd_blkno)\n\t\t\tcontinue;\n\t\telse if (gd_blkno > lgd_blkno)\n\t\t\tbreak;\n\n\t\tif (set)\n\t\t\tocfs2_set_bit(cluster % cl_cpg,\n\t\t\t\t      (unsigned long *)gd->bg_bitmap);\n\t\telse\n\t\t\tocfs2_clear_bit(cluster % cl_cpg,\n\t\t\t\t\t(unsigned long *)gd->bg_bitmap);\n\t\tbackups++;\n\t}\n\n\treturn backups;\n}"
  }
]