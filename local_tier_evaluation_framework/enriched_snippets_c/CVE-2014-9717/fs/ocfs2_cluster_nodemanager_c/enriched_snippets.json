[
  {
    "function_name": "init_o2nm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
    "lines": "943-980",
    "snippet": "static int __init init_o2nm(void)\n{\n\tint ret = -1;\n\n\tret = o2hb_init();\n\tif (ret)\n\t\tgoto out;\n\n\tret = o2net_init();\n\tif (ret)\n\t\tgoto out_o2hb;\n\n\tret = o2net_register_hb_callbacks();\n\tif (ret)\n\t\tgoto out_o2net;\n\n\tconfig_group_init(&o2nm_cluster_group.cs_subsys.su_group);\n\tmutex_init(&o2nm_cluster_group.cs_subsys.su_mutex);\n\tret = configfs_register_subsystem(&o2nm_cluster_group.cs_subsys);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"nodemanager: Registration returned %d\\n\", ret);\n\t\tgoto out_callbacks;\n\t}\n\n\tret = o2cb_sys_init();\n\tif (!ret)\n\t\tgoto out;\n\n\tconfigfs_unregister_subsystem(&o2nm_cluster_group.cs_subsys);\nout_callbacks:\n\to2net_unregister_hb_callbacks();\nout_o2net:\n\to2net_exit();\nout_o2hb:\n\to2hb_exit();\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"sys.h\"",
      "#include \"masklog.h\"",
      "#include \"heartbeat.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct o2nm_cluster_group o2nm_cluster_group = {\n\t.cs_subsys = {\n\t\t.su_group = {\n\t\t\t.cg_item = {\n\t\t\t\t.ci_namebuf = \"cluster\",\n\t\t\t\t.ci_type = &o2nm_cluster_group_type,\n\t\t\t},\n\t\t},\n\t},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "o2hb_exit",
          "args": [],
          "line": 977
        },
        "resolved": true,
        "details": {
          "function_name": "o2hb_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/heartbeat.c",
          "lines": "1280-1291",
          "snippet": "void o2hb_exit(void)\n{\n\tkfree(o2hb_db_livenodes);\n\tkfree(o2hb_db_liveregions);\n\tkfree(o2hb_db_quorumregions);\n\tkfree(o2hb_db_failedregions);\n\tdebugfs_remove(o2hb_debug_failedregions);\n\tdebugfs_remove(o2hb_debug_quorumregions);\n\tdebugfs_remove(o2hb_debug_liveregions);\n\tdebugfs_remove(o2hb_debug_livenodes);\n\tdebugfs_remove(o2hb_debug_dir);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include \"quorum.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <linux/bitmap.h>",
            "#include <linux/slab.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/time.h>",
            "#include <linux/crc32.h>",
            "#include <linux/random.h>",
            "#include <linux/configfs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/file.h>",
            "#include <linux/delay.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct o2hb_debug_buf *o2hb_db_livenodes;",
            "static struct o2hb_debug_buf *o2hb_db_liveregions;",
            "static struct o2hb_debug_buf *o2hb_db_quorumregions;",
            "static struct o2hb_debug_buf *o2hb_db_failedregions;",
            "static struct dentry *o2hb_debug_dir;",
            "static struct dentry *o2hb_debug_livenodes;",
            "static struct dentry *o2hb_debug_liveregions;",
            "static struct dentry *o2hb_debug_quorumregions;",
            "static struct dentry *o2hb_debug_failedregions;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include \"quorum.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <linux/bitmap.h>\n#include <linux/slab.h>\n#include <linux/debugfs.h>\n#include <linux/time.h>\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/configfs.h>\n#include <linux/kthread.h>\n#include <linux/file.h>\n#include <linux/delay.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/jiffies.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic struct o2hb_debug_buf *o2hb_db_livenodes;\nstatic struct o2hb_debug_buf *o2hb_db_liveregions;\nstatic struct o2hb_debug_buf *o2hb_db_quorumregions;\nstatic struct o2hb_debug_buf *o2hb_db_failedregions;\nstatic struct dentry *o2hb_debug_dir;\nstatic struct dentry *o2hb_debug_livenodes;\nstatic struct dentry *o2hb_debug_liveregions;\nstatic struct dentry *o2hb_debug_quorumregions;\nstatic struct dentry *o2hb_debug_failedregions;\n\nvoid o2hb_exit(void)\n{\n\tkfree(o2hb_db_livenodes);\n\tkfree(o2hb_db_liveregions);\n\tkfree(o2hb_db_quorumregions);\n\tkfree(o2hb_db_failedregions);\n\tdebugfs_remove(o2hb_debug_failedregions);\n\tdebugfs_remove(o2hb_debug_quorumregions);\n\tdebugfs_remove(o2hb_debug_liveregions);\n\tdebugfs_remove(o2hb_debug_livenodes);\n\tdebugfs_remove(o2hb_debug_dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_exit",
          "args": [],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "2212-2219",
          "snippet": "void o2net_exit(void)\n{\n\to2quo_exit();\n\tkfree(o2net_hand);\n\tkfree(o2net_keep_req);\n\tkfree(o2net_keep_resp);\n\to2net_debugfs_exit();\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct o2net_handshake *o2net_hand;",
            "static struct o2net_msg *o2net_keep_req, *o2net_keep_resp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct o2net_handshake *o2net_hand;\nstatic struct o2net_msg *o2net_keep_req, *o2net_keep_resp;\n\nvoid o2net_exit(void)\n{\n\to2quo_exit();\n\tkfree(o2net_hand);\n\tkfree(o2net_keep_req);\n\tkfree(o2net_keep_resp);\n\to2net_debugfs_exit();\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_unregister_hb_callbacks",
          "args": [],
          "line": 973
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_unregister_hb_callbacks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "1813-1817",
          "snippet": "void o2net_unregister_hb_callbacks(void)\n{\n\to2hb_unregister_callback(NULL, &o2net_hb_up);\n\to2hb_unregister_callback(NULL, &o2net_hb_down);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct o2hb_callback_func o2net_hb_up, o2net_hb_down;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct o2hb_callback_func o2net_hb_up, o2net_hb_down;\n\nvoid o2net_unregister_hb_callbacks(void)\n{\n\to2hb_unregister_callback(NULL, &o2net_hb_up);\n\to2hb_unregister_callback(NULL, &o2net_hb_down);\n}"
        }
      },
      {
        "call_info": {
          "callee": "configfs_unregister_subsystem",
          "args": [
            "&o2nm_cluster_group.cs_subsys"
          ],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_unregister_subsystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "1687-1721",
          "snippet": "void configfs_unregister_subsystem(struct configfs_subsystem *subsys)\n{\n\tstruct config_group *group = &subsys->su_group;\n\tstruct dentry *dentry = group->cg_item.ci_dentry;\n\tstruct dentry *root = dentry->d_sb->s_root;\n\n\tif (dentry->d_parent != root) {\n\t\tpr_err(\"Tried to unregister non-subsystem!\\n\");\n\t\treturn;\n\t}\n\n\tmutex_lock_nested(&root->d_inode->i_mutex,\n\t\t\t  I_MUTEX_PARENT);\n\tmutex_lock_nested(&dentry->d_inode->i_mutex, I_MUTEX_CHILD);\n\tmutex_lock(&configfs_symlink_mutex);\n\tspin_lock(&configfs_dirent_lock);\n\tif (configfs_detach_prep(dentry, NULL)) {\n\t\tpr_err(\"Tried to unregister non-empty subsystem!\\n\");\n\t}\n\tspin_unlock(&configfs_dirent_lock);\n\tmutex_unlock(&configfs_symlink_mutex);\n\tconfigfs_detach_group(&group->cg_item);\n\tdentry->d_inode->i_flags |= S_DEAD;\n\tdont_mount(dentry);\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n\n\td_delete(dentry);\n\n\tmutex_unlock(&root->d_inode->i_mutex);\n\n\tdput(dentry);\n\n\tunlink_group(group);\n\tconfigfs_release_fs();\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);\n\nvoid configfs_unregister_subsystem(struct configfs_subsystem *subsys)\n{\n\tstruct config_group *group = &subsys->su_group;\n\tstruct dentry *dentry = group->cg_item.ci_dentry;\n\tstruct dentry *root = dentry->d_sb->s_root;\n\n\tif (dentry->d_parent != root) {\n\t\tpr_err(\"Tried to unregister non-subsystem!\\n\");\n\t\treturn;\n\t}\n\n\tmutex_lock_nested(&root->d_inode->i_mutex,\n\t\t\t  I_MUTEX_PARENT);\n\tmutex_lock_nested(&dentry->d_inode->i_mutex, I_MUTEX_CHILD);\n\tmutex_lock(&configfs_symlink_mutex);\n\tspin_lock(&configfs_dirent_lock);\n\tif (configfs_detach_prep(dentry, NULL)) {\n\t\tpr_err(\"Tried to unregister non-empty subsystem!\\n\");\n\t}\n\tspin_unlock(&configfs_dirent_lock);\n\tmutex_unlock(&configfs_symlink_mutex);\n\tconfigfs_detach_group(&group->cg_item);\n\tdentry->d_inode->i_flags |= S_DEAD;\n\tdont_mount(dentry);\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n\n\td_delete(dentry);\n\n\tmutex_unlock(&root->d_inode->i_mutex);\n\n\tdput(dentry);\n\n\tunlink_group(group);\n\tconfigfs_release_fs();\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2cb_sys_init",
          "args": [],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "o2cb_sys_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/sys.c",
          "lines": "63-82",
          "snippet": "int o2cb_sys_init(void)\n{\n\tint ret;\n\n\to2cb_kset = kset_create_and_add(\"o2cb\", NULL, fs_kobj);\n\tif (!o2cb_kset)\n\t\treturn -ENOMEM;\n\n\tret = sysfs_create_group(&o2cb_kset->kobj, &o2cb_attr_group);\n\tif (ret)\n\t\tgoto error;\n\n\tret = mlog_sys_init(o2cb_kset);\n\tif (ret)\n\t\tgoto error;\n\treturn 0;\nerror:\n\tkset_unregister(o2cb_kset);\n\treturn ret;\n}",
          "includes": [
            "#include \"sys.h\"",
            "#include \"masklog.h\"",
            "#include \"ocfs2_nodemanager.h\"",
            "#include <linux/fs.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct attribute_group o2cb_attr_group = {\n\t.attrs = o2cb_attrs,\n};",
            "static struct kset *o2cb_kset;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"ocfs2_nodemanager.h\"\n#include <linux/fs.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct attribute_group o2cb_attr_group = {\n\t.attrs = o2cb_attrs,\n};\nstatic struct kset *o2cb_kset;\n\nint o2cb_sys_init(void)\n{\n\tint ret;\n\n\to2cb_kset = kset_create_and_add(\"o2cb\", NULL, fs_kobj);\n\tif (!o2cb_kset)\n\t\treturn -ENOMEM;\n\n\tret = sysfs_create_group(&o2cb_kset->kobj, &o2cb_attr_group);\n\tif (ret)\n\t\tgoto error;\n\n\tret = mlog_sys_init(o2cb_kset);\n\tif (ret)\n\t\tgoto error;\n\treturn 0;\nerror:\n\tkset_unregister(o2cb_kset);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"nodemanager: Registration returned %d\\n\"",
            "ret"
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "configfs_register_subsystem",
          "args": [
            "&o2nm_cluster_group.cs_subsys"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_register_subsystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "1639-1685",
          "snippet": "int configfs_register_subsystem(struct configfs_subsystem *subsys)\n{\n\tint err;\n\tstruct config_group *group = &subsys->su_group;\n\tstruct dentry *dentry;\n\tstruct dentry *root;\n\tstruct configfs_dirent *sd;\n\n\troot = configfs_pin_fs();\n\tif (IS_ERR(root))\n\t\treturn PTR_ERR(root);\n\n\tif (!group->cg_item.ci_name)\n\t\tgroup->cg_item.ci_name = group->cg_item.ci_namebuf;\n\n\tsd = root->d_fsdata;\n\tlink_group(to_config_group(sd->s_element), group);\n\n\tmutex_lock_nested(&root->d_inode->i_mutex, I_MUTEX_PARENT);\n\n\terr = -ENOMEM;\n\tdentry = d_alloc_name(root, group->cg_item.ci_name);\n\tif (dentry) {\n\t\td_add(dentry, NULL);\n\n\t\terr = configfs_attach_group(sd->s_element, &group->cg_item,\n\t\t\t\t\t    dentry);\n\t\tif (err) {\n\t\t\tBUG_ON(dentry->d_inode);\n\t\t\td_drop(dentry);\n\t\t\tdput(dentry);\n\t\t} else {\n\t\t\tspin_lock(&configfs_dirent_lock);\n\t\t\tconfigfs_dir_set_ready(dentry->d_fsdata);\n\t\t\tspin_unlock(&configfs_dirent_lock);\n\t\t}\n\t}\n\n\tmutex_unlock(&root->d_inode->i_mutex);\n\n\tif (err) {\n\t\tunlink_group(group);\n\t\tconfigfs_release_fs();\n\t}\n\n\treturn err;\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);\n\nint configfs_register_subsystem(struct configfs_subsystem *subsys)\n{\n\tint err;\n\tstruct config_group *group = &subsys->su_group;\n\tstruct dentry *dentry;\n\tstruct dentry *root;\n\tstruct configfs_dirent *sd;\n\n\troot = configfs_pin_fs();\n\tif (IS_ERR(root))\n\t\treturn PTR_ERR(root);\n\n\tif (!group->cg_item.ci_name)\n\t\tgroup->cg_item.ci_name = group->cg_item.ci_namebuf;\n\n\tsd = root->d_fsdata;\n\tlink_group(to_config_group(sd->s_element), group);\n\n\tmutex_lock_nested(&root->d_inode->i_mutex, I_MUTEX_PARENT);\n\n\terr = -ENOMEM;\n\tdentry = d_alloc_name(root, group->cg_item.ci_name);\n\tif (dentry) {\n\t\td_add(dentry, NULL);\n\n\t\terr = configfs_attach_group(sd->s_element, &group->cg_item,\n\t\t\t\t\t    dentry);\n\t\tif (err) {\n\t\t\tBUG_ON(dentry->d_inode);\n\t\t\td_drop(dentry);\n\t\t\tdput(dentry);\n\t\t} else {\n\t\t\tspin_lock(&configfs_dirent_lock);\n\t\t\tconfigfs_dir_set_ready(dentry->d_fsdata);\n\t\t\tspin_unlock(&configfs_dirent_lock);\n\t\t}\n\t}\n\n\tmutex_unlock(&root->d_inode->i_mutex);\n\n\tif (err) {\n\t\tunlink_group(group);\n\t\tconfigfs_release_fs();\n\t}\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&o2nm_cluster_group.cs_subsys.su_mutex"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "config_group_init",
          "args": [
            "&o2nm_cluster_group.cs_subsys.su_group"
          ],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "config_group_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/item.c",
          "lines": "182-186",
          "snippet": "void config_group_init(struct config_group *group)\n{\n\tconfig_item_init(&group->cg_item);\n\tINIT_LIST_HEAD(&group->cg_children);\n}",
          "includes": [
            "#include <linux/configfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/module.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/configfs.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/module.h>\n#include <linux/string.h>\n\nvoid config_group_init(struct config_group *group)\n{\n\tconfig_item_init(&group->cg_item);\n\tINIT_LIST_HEAD(&group->cg_children);\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_register_hb_callbacks",
          "args": [],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_register_hb_callbacks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "1819-1836",
          "snippet": "int o2net_register_hb_callbacks(void)\n{\n\tint ret;\n\n\to2hb_setup_callback(&o2net_hb_down, O2HB_NODE_DOWN_CB,\n\t\t\t    o2net_hb_node_down_cb, NULL, O2NET_HB_PRI);\n\to2hb_setup_callback(&o2net_hb_up, O2HB_NODE_UP_CB,\n\t\t\t    o2net_hb_node_up_cb, NULL, O2NET_HB_PRI);\n\n\tret = o2hb_register_callback(NULL, &o2net_hb_up);\n\tif (ret == 0)\n\t\tret = o2hb_register_callback(NULL, &o2net_hb_down);\n\n\tif (ret)\n\t\to2net_unregister_hb_callbacks();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define O2NET_HB_PRI 0x1"
          ],
          "globals_used": [
            "static struct o2hb_callback_func o2net_hb_up, o2net_hb_down;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\n#define O2NET_HB_PRI 0x1\n\nstatic struct o2hb_callback_func o2net_hb_up, o2net_hb_down;\n\nint o2net_register_hb_callbacks(void)\n{\n\tint ret;\n\n\to2hb_setup_callback(&o2net_hb_down, O2HB_NODE_DOWN_CB,\n\t\t\t    o2net_hb_node_down_cb, NULL, O2NET_HB_PRI);\n\to2hb_setup_callback(&o2net_hb_up, O2HB_NODE_UP_CB,\n\t\t\t    o2net_hb_node_up_cb, NULL, O2NET_HB_PRI);\n\n\tret = o2hb_register_callback(NULL, &o2net_hb_up);\n\tif (ret == 0)\n\t\tret = o2hb_register_callback(NULL, &o2net_hb_down);\n\n\tif (ret)\n\t\to2net_unregister_hb_callbacks();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_init",
          "args": [],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "2164-2210",
          "snippet": "int o2net_init(void)\n{\n\tunsigned long i;\n\n\to2quo_init();\n\n\tif (o2net_debugfs_init())\n\t\tgoto out;\n\n\to2net_hand = kzalloc(sizeof(struct o2net_handshake), GFP_KERNEL);\n\to2net_keep_req = kzalloc(sizeof(struct o2net_msg), GFP_KERNEL);\n\to2net_keep_resp = kzalloc(sizeof(struct o2net_msg), GFP_KERNEL);\n\tif (!o2net_hand || !o2net_keep_req || !o2net_keep_resp)\n\t\tgoto out;\n\n\to2net_hand->protocol_version = cpu_to_be64(O2NET_PROTOCOL_VERSION);\n\to2net_hand->connector_id = cpu_to_be64(1);\n\n\to2net_keep_req->magic = cpu_to_be16(O2NET_MSG_KEEP_REQ_MAGIC);\n\to2net_keep_resp->magic = cpu_to_be16(O2NET_MSG_KEEP_RESP_MAGIC);\n\n\tfor (i = 0; i < ARRAY_SIZE(o2net_nodes); i++) {\n\t\tstruct o2net_node *nn = o2net_nn_from_num(i);\n\n\t\tatomic_set(&nn->nn_timeout, 0);\n\t\tspin_lock_init(&nn->nn_lock);\n\t\tINIT_DELAYED_WORK(&nn->nn_connect_work, o2net_start_connect);\n\t\tINIT_DELAYED_WORK(&nn->nn_connect_expired,\n\t\t\t\t  o2net_connect_expired);\n\t\tINIT_DELAYED_WORK(&nn->nn_still_up, o2net_still_up);\n\t\t/* until we see hb from a node we'll return einval */\n\t\tnn->nn_persistent_error = -ENOTCONN;\n\t\tinit_waitqueue_head(&nn->nn_sc_wq);\n\t\tidr_init(&nn->nn_status_idr);\n\t\tINIT_LIST_HEAD(&nn->nn_status_list);\n\t}\n\n\treturn 0;\n\nout:\n\tkfree(o2net_hand);\n\tkfree(o2net_keep_req);\n\tkfree(o2net_keep_resp);\n\n\to2quo_exit();\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct o2net_node o2net_nodes[O2NM_MAX_NODES];",
            "static struct o2net_handshake *o2net_hand;",
            "static struct o2net_msg *o2net_keep_req, *o2net_keep_resp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct o2net_node o2net_nodes[O2NM_MAX_NODES];\nstatic struct o2net_handshake *o2net_hand;\nstatic struct o2net_msg *o2net_keep_req, *o2net_keep_resp;\n\nint o2net_init(void)\n{\n\tunsigned long i;\n\n\to2quo_init();\n\n\tif (o2net_debugfs_init())\n\t\tgoto out;\n\n\to2net_hand = kzalloc(sizeof(struct o2net_handshake), GFP_KERNEL);\n\to2net_keep_req = kzalloc(sizeof(struct o2net_msg), GFP_KERNEL);\n\to2net_keep_resp = kzalloc(sizeof(struct o2net_msg), GFP_KERNEL);\n\tif (!o2net_hand || !o2net_keep_req || !o2net_keep_resp)\n\t\tgoto out;\n\n\to2net_hand->protocol_version = cpu_to_be64(O2NET_PROTOCOL_VERSION);\n\to2net_hand->connector_id = cpu_to_be64(1);\n\n\to2net_keep_req->magic = cpu_to_be16(O2NET_MSG_KEEP_REQ_MAGIC);\n\to2net_keep_resp->magic = cpu_to_be16(O2NET_MSG_KEEP_RESP_MAGIC);\n\n\tfor (i = 0; i < ARRAY_SIZE(o2net_nodes); i++) {\n\t\tstruct o2net_node *nn = o2net_nn_from_num(i);\n\n\t\tatomic_set(&nn->nn_timeout, 0);\n\t\tspin_lock_init(&nn->nn_lock);\n\t\tINIT_DELAYED_WORK(&nn->nn_connect_work, o2net_start_connect);\n\t\tINIT_DELAYED_WORK(&nn->nn_connect_expired,\n\t\t\t\t  o2net_connect_expired);\n\t\tINIT_DELAYED_WORK(&nn->nn_still_up, o2net_still_up);\n\t\t/* until we see hb from a node we'll return einval */\n\t\tnn->nn_persistent_error = -ENOTCONN;\n\t\tinit_waitqueue_head(&nn->nn_sc_wq);\n\t\tidr_init(&nn->nn_status_idr);\n\t\tINIT_LIST_HEAD(&nn->nn_status_list);\n\t}\n\n\treturn 0;\n\nout:\n\tkfree(o2net_hand);\n\tkfree(o2net_keep_req);\n\tkfree(o2net_keep_resp);\n\n\to2quo_exit();\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2hb_init",
          "args": [],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "o2hb_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/heartbeat.c",
          "lines": "1382-1403",
          "snippet": "int o2hb_init(void)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(o2hb_callbacks); i++)\n\t\tINIT_LIST_HEAD(&o2hb_callbacks[i].list);\n\n\tfor (i = 0; i < ARRAY_SIZE(o2hb_live_slots); i++)\n\t\tINIT_LIST_HEAD(&o2hb_live_slots[i]);\n\n\tINIT_LIST_HEAD(&o2hb_node_events);\n\n\tmemset(o2hb_live_node_bitmap, 0, sizeof(o2hb_live_node_bitmap));\n\tmemset(o2hb_region_bitmap, 0, sizeof(o2hb_region_bitmap));\n\tmemset(o2hb_live_region_bitmap, 0, sizeof(o2hb_live_region_bitmap));\n\tmemset(o2hb_quorum_region_bitmap, 0, sizeof(o2hb_quorum_region_bitmap));\n\tmemset(o2hb_failed_region_bitmap, 0, sizeof(o2hb_failed_region_bitmap));\n\n\to2hb_dependent_users = 0;\n\n\treturn o2hb_debug_init();\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include \"quorum.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <linux/bitmap.h>",
            "#include <linux/slab.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/time.h>",
            "#include <linux/crc32.h>",
            "#include <linux/random.h>",
            "#include <linux/configfs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/file.h>",
            "#include <linux/delay.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct list_head o2hb_live_slots[O2NM_MAX_NODES];",
            "static unsigned long o2hb_live_node_bitmap[BITS_TO_LONGS(O2NM_MAX_NODES)];",
            "static LIST_HEAD(o2hb_node_events);",
            "static unsigned long o2hb_region_bitmap[BITS_TO_LONGS(O2NM_MAX_REGIONS)];",
            "static unsigned long o2hb_live_region_bitmap[BITS_TO_LONGS(O2NM_MAX_REGIONS)];",
            "static unsigned long o2hb_quorum_region_bitmap[BITS_TO_LONGS(O2NM_MAX_REGIONS)];",
            "static unsigned long o2hb_failed_region_bitmap[BITS_TO_LONGS(O2NM_MAX_REGIONS)];",
            "static struct o2hb_callback {\n\tstruct list_head list;\n} o2hb_callbacks[O2HB_NUM_CB];",
            "unsigned int o2hb_dependent_users;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include \"quorum.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <linux/bitmap.h>\n#include <linux/slab.h>\n#include <linux/debugfs.h>\n#include <linux/time.h>\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/configfs.h>\n#include <linux/kthread.h>\n#include <linux/file.h>\n#include <linux/delay.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/jiffies.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic struct list_head o2hb_live_slots[O2NM_MAX_NODES];\nstatic unsigned long o2hb_live_node_bitmap[BITS_TO_LONGS(O2NM_MAX_NODES)];\nstatic LIST_HEAD(o2hb_node_events);\nstatic unsigned long o2hb_region_bitmap[BITS_TO_LONGS(O2NM_MAX_REGIONS)];\nstatic unsigned long o2hb_live_region_bitmap[BITS_TO_LONGS(O2NM_MAX_REGIONS)];\nstatic unsigned long o2hb_quorum_region_bitmap[BITS_TO_LONGS(O2NM_MAX_REGIONS)];\nstatic unsigned long o2hb_failed_region_bitmap[BITS_TO_LONGS(O2NM_MAX_REGIONS)];\nstatic struct o2hb_callback {\n\tstruct list_head list;\n} o2hb_callbacks[O2HB_NUM_CB];\nunsigned int o2hb_dependent_users;\n\nint o2hb_init(void)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(o2hb_callbacks); i++)\n\t\tINIT_LIST_HEAD(&o2hb_callbacks[i].list);\n\n\tfor (i = 0; i < ARRAY_SIZE(o2hb_live_slots); i++)\n\t\tINIT_LIST_HEAD(&o2hb_live_slots[i]);\n\n\tINIT_LIST_HEAD(&o2hb_node_events);\n\n\tmemset(o2hb_live_node_bitmap, 0, sizeof(o2hb_live_node_bitmap));\n\tmemset(o2hb_region_bitmap, 0, sizeof(o2hb_region_bitmap));\n\tmemset(o2hb_live_region_bitmap, 0, sizeof(o2hb_live_region_bitmap));\n\tmemset(o2hb_quorum_region_bitmap, 0, sizeof(o2hb_quorum_region_bitmap));\n\tmemset(o2hb_failed_region_bitmap, 0, sizeof(o2hb_failed_region_bitmap));\n\n\to2hb_dependent_users = 0;\n\n\treturn o2hb_debug_init();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstatic struct o2nm_cluster_group o2nm_cluster_group = {\n\t.cs_subsys = {\n\t\t.su_group = {\n\t\t\t.cg_item = {\n\t\t\t\t.ci_namebuf = \"cluster\",\n\t\t\t\t.ci_type = &o2nm_cluster_group_type,\n\t\t\t},\n\t\t},\n\t},\n};\n\nstatic int __init init_o2nm(void)\n{\n\tint ret = -1;\n\n\tret = o2hb_init();\n\tif (ret)\n\t\tgoto out;\n\n\tret = o2net_init();\n\tif (ret)\n\t\tgoto out_o2hb;\n\n\tret = o2net_register_hb_callbacks();\n\tif (ret)\n\t\tgoto out_o2net;\n\n\tconfig_group_init(&o2nm_cluster_group.cs_subsys.su_group);\n\tmutex_init(&o2nm_cluster_group.cs_subsys.su_mutex);\n\tret = configfs_register_subsystem(&o2nm_cluster_group.cs_subsys);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"nodemanager: Registration returned %d\\n\", ret);\n\t\tgoto out_callbacks;\n\t}\n\n\tret = o2cb_sys_init();\n\tif (!ret)\n\t\tgoto out;\n\n\tconfigfs_unregister_subsystem(&o2nm_cluster_group.cs_subsys);\nout_callbacks:\n\to2net_unregister_hb_callbacks();\nout_o2net:\n\to2net_exit();\nout_o2hb:\n\to2hb_exit();\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "exit_o2nm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
    "lines": "932-941",
    "snippet": "static void __exit exit_o2nm(void)\n{\n\t/* XXX sync with hb callbacks and shut down hb? */\n\to2net_unregister_hb_callbacks();\n\tconfigfs_unregister_subsystem(&o2nm_cluster_group.cs_subsys);\n\to2cb_sys_shutdown();\n\n\to2net_exit();\n\to2hb_exit();\n}",
    "includes": [
      "#include \"sys.h\"",
      "#include \"masklog.h\"",
      "#include \"heartbeat.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct o2nm_cluster_group o2nm_cluster_group = {\n\t.cs_subsys = {\n\t\t.su_group = {\n\t\t\t.cg_item = {\n\t\t\t\t.ci_namebuf = \"cluster\",\n\t\t\t\t.ci_type = &o2nm_cluster_group_type,\n\t\t\t},\n\t\t},\n\t},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "o2hb_exit",
          "args": [],
          "line": 940
        },
        "resolved": true,
        "details": {
          "function_name": "o2hb_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/heartbeat.c",
          "lines": "1280-1291",
          "snippet": "void o2hb_exit(void)\n{\n\tkfree(o2hb_db_livenodes);\n\tkfree(o2hb_db_liveregions);\n\tkfree(o2hb_db_quorumregions);\n\tkfree(o2hb_db_failedregions);\n\tdebugfs_remove(o2hb_debug_failedregions);\n\tdebugfs_remove(o2hb_debug_quorumregions);\n\tdebugfs_remove(o2hb_debug_liveregions);\n\tdebugfs_remove(o2hb_debug_livenodes);\n\tdebugfs_remove(o2hb_debug_dir);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include \"quorum.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <linux/bitmap.h>",
            "#include <linux/slab.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/time.h>",
            "#include <linux/crc32.h>",
            "#include <linux/random.h>",
            "#include <linux/configfs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/file.h>",
            "#include <linux/delay.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct o2hb_debug_buf *o2hb_db_livenodes;",
            "static struct o2hb_debug_buf *o2hb_db_liveregions;",
            "static struct o2hb_debug_buf *o2hb_db_quorumregions;",
            "static struct o2hb_debug_buf *o2hb_db_failedregions;",
            "static struct dentry *o2hb_debug_dir;",
            "static struct dentry *o2hb_debug_livenodes;",
            "static struct dentry *o2hb_debug_liveregions;",
            "static struct dentry *o2hb_debug_quorumregions;",
            "static struct dentry *o2hb_debug_failedregions;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include \"quorum.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <linux/bitmap.h>\n#include <linux/slab.h>\n#include <linux/debugfs.h>\n#include <linux/time.h>\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/configfs.h>\n#include <linux/kthread.h>\n#include <linux/file.h>\n#include <linux/delay.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/jiffies.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic struct o2hb_debug_buf *o2hb_db_livenodes;\nstatic struct o2hb_debug_buf *o2hb_db_liveregions;\nstatic struct o2hb_debug_buf *o2hb_db_quorumregions;\nstatic struct o2hb_debug_buf *o2hb_db_failedregions;\nstatic struct dentry *o2hb_debug_dir;\nstatic struct dentry *o2hb_debug_livenodes;\nstatic struct dentry *o2hb_debug_liveregions;\nstatic struct dentry *o2hb_debug_quorumregions;\nstatic struct dentry *o2hb_debug_failedregions;\n\nvoid o2hb_exit(void)\n{\n\tkfree(o2hb_db_livenodes);\n\tkfree(o2hb_db_liveregions);\n\tkfree(o2hb_db_quorumregions);\n\tkfree(o2hb_db_failedregions);\n\tdebugfs_remove(o2hb_debug_failedregions);\n\tdebugfs_remove(o2hb_debug_quorumregions);\n\tdebugfs_remove(o2hb_debug_liveregions);\n\tdebugfs_remove(o2hb_debug_livenodes);\n\tdebugfs_remove(o2hb_debug_dir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_exit",
          "args": [],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "2212-2219",
          "snippet": "void o2net_exit(void)\n{\n\to2quo_exit();\n\tkfree(o2net_hand);\n\tkfree(o2net_keep_req);\n\tkfree(o2net_keep_resp);\n\to2net_debugfs_exit();\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct o2net_handshake *o2net_hand;",
            "static struct o2net_msg *o2net_keep_req, *o2net_keep_resp;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct o2net_handshake *o2net_hand;\nstatic struct o2net_msg *o2net_keep_req, *o2net_keep_resp;\n\nvoid o2net_exit(void)\n{\n\to2quo_exit();\n\tkfree(o2net_hand);\n\tkfree(o2net_keep_req);\n\tkfree(o2net_keep_resp);\n\to2net_debugfs_exit();\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2cb_sys_shutdown",
          "args": [],
          "line": 937
        },
        "resolved": true,
        "details": {
          "function_name": "o2cb_sys_shutdown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/sys.c",
          "lines": "57-61",
          "snippet": "void o2cb_sys_shutdown(void)\n{\n\tmlog_sys_shutdown();\n\tkset_unregister(o2cb_kset);\n}",
          "includes": [
            "#include \"sys.h\"",
            "#include \"masklog.h\"",
            "#include \"ocfs2_nodemanager.h\"",
            "#include <linux/fs.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kset *o2cb_kset;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"ocfs2_nodemanager.h\"\n#include <linux/fs.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct kset *o2cb_kset;\n\nvoid o2cb_sys_shutdown(void)\n{\n\tmlog_sys_shutdown();\n\tkset_unregister(o2cb_kset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "configfs_unregister_subsystem",
          "args": [
            "&o2nm_cluster_group.cs_subsys"
          ],
          "line": 936
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_unregister_subsystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "1687-1721",
          "snippet": "void configfs_unregister_subsystem(struct configfs_subsystem *subsys)\n{\n\tstruct config_group *group = &subsys->su_group;\n\tstruct dentry *dentry = group->cg_item.ci_dentry;\n\tstruct dentry *root = dentry->d_sb->s_root;\n\n\tif (dentry->d_parent != root) {\n\t\tpr_err(\"Tried to unregister non-subsystem!\\n\");\n\t\treturn;\n\t}\n\n\tmutex_lock_nested(&root->d_inode->i_mutex,\n\t\t\t  I_MUTEX_PARENT);\n\tmutex_lock_nested(&dentry->d_inode->i_mutex, I_MUTEX_CHILD);\n\tmutex_lock(&configfs_symlink_mutex);\n\tspin_lock(&configfs_dirent_lock);\n\tif (configfs_detach_prep(dentry, NULL)) {\n\t\tpr_err(\"Tried to unregister non-empty subsystem!\\n\");\n\t}\n\tspin_unlock(&configfs_dirent_lock);\n\tmutex_unlock(&configfs_symlink_mutex);\n\tconfigfs_detach_group(&group->cg_item);\n\tdentry->d_inode->i_flags |= S_DEAD;\n\tdont_mount(dentry);\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n\n\td_delete(dentry);\n\n\tmutex_unlock(&root->d_inode->i_mutex);\n\n\tdput(dentry);\n\n\tunlink_group(group);\n\tconfigfs_release_fs();\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);\n\nvoid configfs_unregister_subsystem(struct configfs_subsystem *subsys)\n{\n\tstruct config_group *group = &subsys->su_group;\n\tstruct dentry *dentry = group->cg_item.ci_dentry;\n\tstruct dentry *root = dentry->d_sb->s_root;\n\n\tif (dentry->d_parent != root) {\n\t\tpr_err(\"Tried to unregister non-subsystem!\\n\");\n\t\treturn;\n\t}\n\n\tmutex_lock_nested(&root->d_inode->i_mutex,\n\t\t\t  I_MUTEX_PARENT);\n\tmutex_lock_nested(&dentry->d_inode->i_mutex, I_MUTEX_CHILD);\n\tmutex_lock(&configfs_symlink_mutex);\n\tspin_lock(&configfs_dirent_lock);\n\tif (configfs_detach_prep(dentry, NULL)) {\n\t\tpr_err(\"Tried to unregister non-empty subsystem!\\n\");\n\t}\n\tspin_unlock(&configfs_dirent_lock);\n\tmutex_unlock(&configfs_symlink_mutex);\n\tconfigfs_detach_group(&group->cg_item);\n\tdentry->d_inode->i_flags |= S_DEAD;\n\tdont_mount(dentry);\n\tmutex_unlock(&dentry->d_inode->i_mutex);\n\n\td_delete(dentry);\n\n\tmutex_unlock(&root->d_inode->i_mutex);\n\n\tdput(dentry);\n\n\tunlink_group(group);\n\tconfigfs_release_fs();\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_unregister_hb_callbacks",
          "args": [],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_unregister_hb_callbacks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "1813-1817",
          "snippet": "void o2net_unregister_hb_callbacks(void)\n{\n\to2hb_unregister_callback(NULL, &o2net_hb_up);\n\to2hb_unregister_callback(NULL, &o2net_hb_down);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct o2hb_callback_func o2net_hb_up, o2net_hb_down;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct o2hb_callback_func o2net_hb_up, o2net_hb_down;\n\nvoid o2net_unregister_hb_callbacks(void)\n{\n\to2hb_unregister_callback(NULL, &o2net_hb_up);\n\to2hb_unregister_callback(NULL, &o2net_hb_down);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstatic struct o2nm_cluster_group o2nm_cluster_group = {\n\t.cs_subsys = {\n\t\t.su_group = {\n\t\t\t.cg_item = {\n\t\t\t\t.ci_namebuf = \"cluster\",\n\t\t\t\t.ci_type = &o2nm_cluster_group_type,\n\t\t\t},\n\t\t},\n\t},\n};\n\nstatic void __exit exit_o2nm(void)\n{\n\t/* XXX sync with hb callbacks and shut down hb? */\n\to2net_unregister_hb_callbacks();\n\tconfigfs_unregister_subsystem(&o2nm_cluster_group.cs_subsys);\n\to2cb_sys_shutdown();\n\n\to2net_exit();\n\to2hb_exit();\n}"
  },
  {
    "function_name": "o2nm_undepend_this_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
    "lines": "920-929",
    "snippet": "void o2nm_undepend_this_node(void)\n{\n\tstruct o2nm_node *local_node;\n\n\tlocal_node = o2nm_get_node_by_num(o2nm_this_node());\n\tBUG_ON(!local_node);\n\n\to2nm_undepend_item(&local_node->nd_item);\n\to2nm_node_put(local_node);\n}",
    "includes": [
      "#include \"sys.h\"",
      "#include \"masklog.h\"",
      "#include \"heartbeat.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "o2nm_node_put",
          "args": [
            "local_node"
          ],
          "line": 928
        },
        "resolved": true,
        "details": {
          "function_name": "o2nm_node_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
          "lines": "131-134",
          "snippet": "void o2nm_node_put(struct o2nm_node *node)\n{\n\tconfig_item_put(&node->nd_item);\n}",
          "includes": [
            "#include \"sys.h\"",
            "#include \"masklog.h\"",
            "#include \"heartbeat.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nvoid o2nm_node_put(struct o2nm_node *node)\n{\n\tconfig_item_put(&node->nd_item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2nm_undepend_item",
          "args": [
            "&local_node->nd_item"
          ],
          "line": 927
        },
        "resolved": true,
        "details": {
          "function_name": "o2nm_undepend_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
          "lines": "897-900",
          "snippet": "void o2nm_undepend_item(struct config_item *item)\n{\n\tconfigfs_undepend_item(&o2nm_cluster_group.cs_subsys, item);\n}",
          "includes": [
            "#include \"sys.h\"",
            "#include \"masklog.h\"",
            "#include \"heartbeat.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct o2nm_cluster_group o2nm_cluster_group = {\n\t.cs_subsys = {\n\t\t.su_group = {\n\t\t\t.cg_item = {\n\t\t\t\t.ci_namebuf = \"cluster\",\n\t\t\t\t.ci_type = &o2nm_cluster_group_type,\n\t\t\t},\n\t\t},\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstatic struct o2nm_cluster_group o2nm_cluster_group = {\n\t.cs_subsys = {\n\t\t.su_group = {\n\t\t\t.cg_item = {\n\t\t\t\t.ci_namebuf = \"cluster\",\n\t\t\t\t.ci_type = &o2nm_cluster_group_type,\n\t\t\t},\n\t\t},\n\t},\n};\n\nvoid o2nm_undepend_item(struct config_item *item)\n{\n\tconfigfs_undepend_item(&o2nm_cluster_group.cs_subsys, item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!local_node"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2nm_get_node_by_num",
          "args": [
            "o2nm_this_node()"
          ],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "o2nm_get_node_by_num",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
          "lines": "43-57",
          "snippet": "struct o2nm_node *o2nm_get_node_by_num(u8 node_num)\n{\n\tstruct o2nm_node *node = NULL;\n\n\tif (node_num >= O2NM_MAX_NODES || o2nm_single_cluster == NULL)\n\t\tgoto out;\n\n\tread_lock(&o2nm_single_cluster->cl_nodes_lock);\n\tnode = o2nm_single_cluster->cl_nodes[node_num];\n\tif (node)\n\t\tconfig_item_get(&node->nd_item);\n\tread_unlock(&o2nm_single_cluster->cl_nodes_lock);\nout:\n\treturn node;\n}",
          "includes": [
            "#include \"sys.h\"",
            "#include \"masklog.h\"",
            "#include \"heartbeat.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct o2nm_cluster *o2nm_single_cluster = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstruct o2nm_cluster *o2nm_single_cluster = NULL;\n\nstruct o2nm_node *o2nm_get_node_by_num(u8 node_num)\n{\n\tstruct o2nm_node *node = NULL;\n\n\tif (node_num >= O2NM_MAX_NODES || o2nm_single_cluster == NULL)\n\t\tgoto out;\n\n\tread_lock(&o2nm_single_cluster->cl_nodes_lock);\n\tnode = o2nm_single_cluster->cl_nodes[node_num];\n\tif (node)\n\t\tconfig_item_get(&node->nd_item);\n\tread_unlock(&o2nm_single_cluster->cl_nodes_lock);\nout:\n\treturn node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2nm_this_node",
          "args": [],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "o2nm_this_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
          "lines": "143-151",
          "snippet": "u8 o2nm_this_node(void)\n{\n\tu8 node_num = O2NM_MAX_NODES;\n\n\tif (o2nm_single_cluster && o2nm_single_cluster->cl_has_local)\n\t\tnode_num = o2nm_single_cluster->cl_local_node;\n\n\treturn node_num;\n}",
          "includes": [
            "#include \"sys.h\"",
            "#include \"masklog.h\"",
            "#include \"heartbeat.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct o2nm_cluster *o2nm_single_cluster = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstruct o2nm_cluster *o2nm_single_cluster = NULL;\n\nu8 o2nm_this_node(void)\n{\n\tu8 node_num = O2NM_MAX_NODES;\n\n\tif (o2nm_single_cluster && o2nm_single_cluster->cl_has_local)\n\t\tnode_num = o2nm_single_cluster->cl_local_node;\n\n\treturn node_num;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nvoid o2nm_undepend_this_node(void)\n{\n\tstruct o2nm_node *local_node;\n\n\tlocal_node = o2nm_get_node_by_num(o2nm_this_node());\n\tBUG_ON(!local_node);\n\n\to2nm_undepend_item(&local_node->nd_item);\n\to2nm_node_put(local_node);\n}"
  },
  {
    "function_name": "o2nm_depend_this_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
    "lines": "902-918",
    "snippet": "int o2nm_depend_this_node(void)\n{\n\tint ret = 0;\n\tstruct o2nm_node *local_node;\n\n\tlocal_node = o2nm_get_node_by_num(o2nm_this_node());\n\tif (!local_node) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = o2nm_depend_item(&local_node->nd_item);\n\to2nm_node_put(local_node);\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"sys.h\"",
      "#include \"masklog.h\"",
      "#include \"heartbeat.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "o2nm_node_put",
          "args": [
            "local_node"
          ],
          "line": 914
        },
        "resolved": true,
        "details": {
          "function_name": "o2nm_node_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
          "lines": "131-134",
          "snippet": "void o2nm_node_put(struct o2nm_node *node)\n{\n\tconfig_item_put(&node->nd_item);\n}",
          "includes": [
            "#include \"sys.h\"",
            "#include \"masklog.h\"",
            "#include \"heartbeat.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nvoid o2nm_node_put(struct o2nm_node *node)\n{\n\tconfig_item_put(&node->nd_item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2nm_depend_item",
          "args": [
            "&local_node->nd_item"
          ],
          "line": 913
        },
        "resolved": true,
        "details": {
          "function_name": "o2nm_depend_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
          "lines": "892-895",
          "snippet": "int o2nm_depend_item(struct config_item *item)\n{\n\treturn configfs_depend_item(&o2nm_cluster_group.cs_subsys, item);\n}",
          "includes": [
            "#include \"sys.h\"",
            "#include \"masklog.h\"",
            "#include \"heartbeat.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct o2nm_cluster_group o2nm_cluster_group = {\n\t.cs_subsys = {\n\t\t.su_group = {\n\t\t\t.cg_item = {\n\t\t\t\t.ci_namebuf = \"cluster\",\n\t\t\t\t.ci_type = &o2nm_cluster_group_type,\n\t\t\t},\n\t\t},\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstatic struct o2nm_cluster_group o2nm_cluster_group = {\n\t.cs_subsys = {\n\t\t.su_group = {\n\t\t\t.cg_item = {\n\t\t\t\t.ci_namebuf = \"cluster\",\n\t\t\t\t.ci_type = &o2nm_cluster_group_type,\n\t\t\t},\n\t\t},\n\t},\n};\n\nint o2nm_depend_item(struct config_item *item)\n{\n\treturn configfs_depend_item(&o2nm_cluster_group.cs_subsys, item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2nm_get_node_by_num",
          "args": [
            "o2nm_this_node()"
          ],
          "line": 907
        },
        "resolved": true,
        "details": {
          "function_name": "o2nm_get_node_by_num",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
          "lines": "43-57",
          "snippet": "struct o2nm_node *o2nm_get_node_by_num(u8 node_num)\n{\n\tstruct o2nm_node *node = NULL;\n\n\tif (node_num >= O2NM_MAX_NODES || o2nm_single_cluster == NULL)\n\t\tgoto out;\n\n\tread_lock(&o2nm_single_cluster->cl_nodes_lock);\n\tnode = o2nm_single_cluster->cl_nodes[node_num];\n\tif (node)\n\t\tconfig_item_get(&node->nd_item);\n\tread_unlock(&o2nm_single_cluster->cl_nodes_lock);\nout:\n\treturn node;\n}",
          "includes": [
            "#include \"sys.h\"",
            "#include \"masklog.h\"",
            "#include \"heartbeat.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct o2nm_cluster *o2nm_single_cluster = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstruct o2nm_cluster *o2nm_single_cluster = NULL;\n\nstruct o2nm_node *o2nm_get_node_by_num(u8 node_num)\n{\n\tstruct o2nm_node *node = NULL;\n\n\tif (node_num >= O2NM_MAX_NODES || o2nm_single_cluster == NULL)\n\t\tgoto out;\n\n\tread_lock(&o2nm_single_cluster->cl_nodes_lock);\n\tnode = o2nm_single_cluster->cl_nodes[node_num];\n\tif (node)\n\t\tconfig_item_get(&node->nd_item);\n\tread_unlock(&o2nm_single_cluster->cl_nodes_lock);\nout:\n\treturn node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2nm_this_node",
          "args": [],
          "line": 907
        },
        "resolved": true,
        "details": {
          "function_name": "o2nm_this_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
          "lines": "143-151",
          "snippet": "u8 o2nm_this_node(void)\n{\n\tu8 node_num = O2NM_MAX_NODES;\n\n\tif (o2nm_single_cluster && o2nm_single_cluster->cl_has_local)\n\t\tnode_num = o2nm_single_cluster->cl_local_node;\n\n\treturn node_num;\n}",
          "includes": [
            "#include \"sys.h\"",
            "#include \"masklog.h\"",
            "#include \"heartbeat.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct o2nm_cluster *o2nm_single_cluster = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstruct o2nm_cluster *o2nm_single_cluster = NULL;\n\nu8 o2nm_this_node(void)\n{\n\tu8 node_num = O2NM_MAX_NODES;\n\n\tif (o2nm_single_cluster && o2nm_single_cluster->cl_has_local)\n\t\tnode_num = o2nm_single_cluster->cl_local_node;\n\n\treturn node_num;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nint o2nm_depend_this_node(void)\n{\n\tint ret = 0;\n\tstruct o2nm_node *local_node;\n\n\tlocal_node = o2nm_get_node_by_num(o2nm_this_node());\n\tif (!local_node) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = o2nm_depend_item(&local_node->nd_item);\n\to2nm_node_put(local_node);\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "o2nm_undepend_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
    "lines": "897-900",
    "snippet": "void o2nm_undepend_item(struct config_item *item)\n{\n\tconfigfs_undepend_item(&o2nm_cluster_group.cs_subsys, item);\n}",
    "includes": [
      "#include \"sys.h\"",
      "#include \"masklog.h\"",
      "#include \"heartbeat.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct o2nm_cluster_group o2nm_cluster_group = {\n\t.cs_subsys = {\n\t\t.su_group = {\n\t\t\t.cg_item = {\n\t\t\t\t.ci_namebuf = \"cluster\",\n\t\t\t\t.ci_type = &o2nm_cluster_group_type,\n\t\t\t},\n\t\t},\n\t},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "configfs_undepend_item",
          "args": [
            "&o2nm_cluster_group.cs_subsys",
            "item"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_undepend_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "1131-1152",
          "snippet": "void configfs_undepend_item(struct configfs_subsystem *subsys,\n\t\t\t    struct config_item *target)\n{\n\tstruct configfs_dirent *sd;\n\n\t/*\n\t * Since we can trust everything is pinned, we just need\n\t * configfs_dirent_lock.\n\t */\n\tspin_lock(&configfs_dirent_lock);\n\n\tsd = target->ci_dentry->d_fsdata;\n\tBUG_ON(sd->s_dependent_count < 1);\n\n\tsd->s_dependent_count -= 1;\n\n\t/*\n\t * After this unlock, we cannot trust the item to stay alive!\n\t * DO NOT REFERENCE item after this unlock.\n\t */\n\tspin_unlock(&configfs_dirent_lock);\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void configfs_detach_group(struct config_item *item);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void configfs_detach_group(struct config_item *item);\n\nvoid configfs_undepend_item(struct configfs_subsystem *subsys,\n\t\t\t    struct config_item *target)\n{\n\tstruct configfs_dirent *sd;\n\n\t/*\n\t * Since we can trust everything is pinned, we just need\n\t * configfs_dirent_lock.\n\t */\n\tspin_lock(&configfs_dirent_lock);\n\n\tsd = target->ci_dentry->d_fsdata;\n\tBUG_ON(sd->s_dependent_count < 1);\n\n\tsd->s_dependent_count -= 1;\n\n\t/*\n\t * After this unlock, we cannot trust the item to stay alive!\n\t * DO NOT REFERENCE item after this unlock.\n\t */\n\tspin_unlock(&configfs_dirent_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstatic struct o2nm_cluster_group o2nm_cluster_group = {\n\t.cs_subsys = {\n\t\t.su_group = {\n\t\t\t.cg_item = {\n\t\t\t\t.ci_namebuf = \"cluster\",\n\t\t\t\t.ci_type = &o2nm_cluster_group_type,\n\t\t\t},\n\t\t},\n\t},\n};\n\nvoid o2nm_undepend_item(struct config_item *item)\n{\n\tconfigfs_undepend_item(&o2nm_cluster_group.cs_subsys, item);\n}"
  },
  {
    "function_name": "o2nm_depend_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
    "lines": "892-895",
    "snippet": "int o2nm_depend_item(struct config_item *item)\n{\n\treturn configfs_depend_item(&o2nm_cluster_group.cs_subsys, item);\n}",
    "includes": [
      "#include \"sys.h\"",
      "#include \"masklog.h\"",
      "#include \"heartbeat.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct o2nm_cluster_group o2nm_cluster_group = {\n\t.cs_subsys = {\n\t\t.su_group = {\n\t\t\t.cg_item = {\n\t\t\t\t.ci_namebuf = \"cluster\",\n\t\t\t\t.ci_type = &o2nm_cluster_group_type,\n\t\t\t},\n\t\t},\n\t},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "configfs_depend_item",
          "args": [
            "&o2nm_cluster_group.cs_subsys",
            "item"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "configfs_depend_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/dir.c",
          "lines": "1057-1123",
          "snippet": "int configfs_depend_item(struct configfs_subsystem *subsys,\n\t\t\t struct config_item *target)\n{\n\tint ret;\n\tstruct configfs_dirent *p, *root_sd, *subsys_sd = NULL;\n\tstruct config_item *s_item = &subsys->su_group.cg_item;\n\tstruct dentry *root;\n\n\t/*\n\t * Pin the configfs filesystem.  This means we can safely access\n\t * the root of the configfs filesystem.\n\t */\n\troot = configfs_pin_fs();\n\tif (IS_ERR(root))\n\t\treturn PTR_ERR(root);\n\n\t/*\n\t * Next, lock the root directory.  We're going to check that the\n\t * subsystem is really registered, and so we need to lock out\n\t * configfs_[un]register_subsystem().\n\t */\n\tmutex_lock(&root->d_inode->i_mutex);\n\n\troot_sd = root->d_fsdata;\n\n\tlist_for_each_entry(p, &root_sd->s_children, s_sibling) {\n\t\tif (p->s_type & CONFIGFS_DIR) {\n\t\t\tif (p->s_element == s_item) {\n\t\t\t\tsubsys_sd = p;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!subsys_sd) {\n\t\tret = -ENOENT;\n\t\tgoto out_unlock_fs;\n\t}\n\n\t/* Ok, now we can trust subsys/s_item */\n\n\tspin_lock(&configfs_dirent_lock);\n\t/* Scan the tree, return 0 if found */\n\tret = configfs_depend_prep(subsys_sd->s_dentry, target);\n\tif (ret)\n\t\tgoto out_unlock_dirent_lock;\n\n\t/*\n\t * We are sure that the item is not about to be removed by rmdir(), and\n\t * not in the middle of attachment by mkdir().\n\t */\n\tp = target->ci_dentry->d_fsdata;\n\tp->s_dependent_count += 1;\n\nout_unlock_dirent_lock:\n\tspin_unlock(&configfs_dirent_lock);\nout_unlock_fs:\n\tmutex_unlock(&root->d_inode->i_mutex);\n\n\t/*\n\t * If we succeeded, the fs is pinned via other methods.  If not,\n\t * we're done with it anyway.  So release_fs() is always right.\n\t */\n\tconfigfs_release_fs();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"configfs_internal.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);",
            "static void configfs_detach_group(struct config_item *item);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configfs_internal.h\"\n#include <linux/configfs.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int configfs_attach_group(struct config_item *parent_item,\n\t\t\t\t struct config_item *item,\n\t\t\t\t struct dentry *dentry);\nstatic void configfs_detach_group(struct config_item *item);\n\nint configfs_depend_item(struct configfs_subsystem *subsys,\n\t\t\t struct config_item *target)\n{\n\tint ret;\n\tstruct configfs_dirent *p, *root_sd, *subsys_sd = NULL;\n\tstruct config_item *s_item = &subsys->su_group.cg_item;\n\tstruct dentry *root;\n\n\t/*\n\t * Pin the configfs filesystem.  This means we can safely access\n\t * the root of the configfs filesystem.\n\t */\n\troot = configfs_pin_fs();\n\tif (IS_ERR(root))\n\t\treturn PTR_ERR(root);\n\n\t/*\n\t * Next, lock the root directory.  We're going to check that the\n\t * subsystem is really registered, and so we need to lock out\n\t * configfs_[un]register_subsystem().\n\t */\n\tmutex_lock(&root->d_inode->i_mutex);\n\n\troot_sd = root->d_fsdata;\n\n\tlist_for_each_entry(p, &root_sd->s_children, s_sibling) {\n\t\tif (p->s_type & CONFIGFS_DIR) {\n\t\t\tif (p->s_element == s_item) {\n\t\t\t\tsubsys_sd = p;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!subsys_sd) {\n\t\tret = -ENOENT;\n\t\tgoto out_unlock_fs;\n\t}\n\n\t/* Ok, now we can trust subsys/s_item */\n\n\tspin_lock(&configfs_dirent_lock);\n\t/* Scan the tree, return 0 if found */\n\tret = configfs_depend_prep(subsys_sd->s_dentry, target);\n\tif (ret)\n\t\tgoto out_unlock_dirent_lock;\n\n\t/*\n\t * We are sure that the item is not about to be removed by rmdir(), and\n\t * not in the middle of attachment by mkdir().\n\t */\n\tp = target->ci_dentry->d_fsdata;\n\tp->s_dependent_count += 1;\n\nout_unlock_dirent_lock:\n\tspin_unlock(&configfs_dirent_lock);\nout_unlock_fs:\n\tmutex_unlock(&root->d_inode->i_mutex);\n\n\t/*\n\t * If we succeeded, the fs is pinned via other methods.  If not,\n\t * we're done with it anyway.  So release_fs() is always right.\n\t */\n\tconfigfs_release_fs();\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstatic struct o2nm_cluster_group o2nm_cluster_group = {\n\t.cs_subsys = {\n\t\t.su_group = {\n\t\t\t.cg_item = {\n\t\t\t\t.ci_namebuf = \"cluster\",\n\t\t\t\t.ci_type = &o2nm_cluster_group_type,\n\t\t\t},\n\t\t},\n\t},\n};\n\nint o2nm_depend_item(struct config_item *item)\n{\n\treturn configfs_depend_item(&o2nm_cluster_group.cs_subsys, item);\n}"
  },
  {
    "function_name": "o2nm_cluster_group_drop_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
    "lines": "853-869",
    "snippet": "static void o2nm_cluster_group_drop_item(struct config_group *group, struct config_item *item)\n{\n\tstruct o2nm_cluster *cluster = to_o2nm_cluster(item);\n\tint i;\n\tstruct config_item *killme;\n\n\tBUG_ON(o2nm_single_cluster != cluster);\n\to2nm_single_cluster = NULL;\n\n\tfor (i = 0; cluster->cl_group.default_groups[i]; i++) {\n\t\tkillme = &cluster->cl_group.default_groups[i]->cg_item;\n\t\tcluster->cl_group.default_groups[i] = NULL;\n\t\tconfig_item_put(killme);\n\t}\n\n\tconfig_item_put(item);\n}",
    "includes": [
      "#include \"sys.h\"",
      "#include \"masklog.h\"",
      "#include \"heartbeat.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct o2nm_cluster *o2nm_single_cluster = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "config_item_put",
          "args": [
            "item"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "config_item_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/item.c",
          "lines": "171-175",
          "snippet": "void config_item_put(struct config_item *item)\n{\n\tif (item)\n\t\tkref_put(&item->ci_kref, config_item_release);\n}",
          "includes": [
            "#include <linux/configfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/module.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/configfs.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/module.h>\n#include <linux/string.h>\n\nvoid config_item_put(struct config_item *item)\n{\n\tif (item)\n\t\tkref_put(&item->ci_kref, config_item_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "o2nm_single_cluster != cluster"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_o2nm_cluster",
          "args": [
            "item"
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "to_o2nm_cluster_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
          "lines": "794-799",
          "snippet": "static struct o2nm_cluster_group *to_o2nm_cluster_group(struct config_group *group)\n{\n\treturn group ?\n\t\tcontainer_of(to_configfs_subsystem(group), struct o2nm_cluster_group, cs_subsys)\n\t       : NULL;\n}",
          "includes": [
            "#include \"sys.h\"",
            "#include \"masklog.h\"",
            "#include \"heartbeat.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct o2nm_cluster_group o2nm_cluster_group = {\n\t.cs_subsys = {\n\t\t.su_group = {\n\t\t\t.cg_item = {\n\t\t\t\t.ci_namebuf = \"cluster\",\n\t\t\t\t.ci_type = &o2nm_cluster_group_type,\n\t\t\t},\n\t\t},\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstatic struct o2nm_cluster_group o2nm_cluster_group = {\n\t.cs_subsys = {\n\t\t.su_group = {\n\t\t\t.cg_item = {\n\t\t\t\t.ci_namebuf = \"cluster\",\n\t\t\t\t.ci_type = &o2nm_cluster_group_type,\n\t\t\t},\n\t\t},\n\t},\n};\n\nstatic struct o2nm_cluster_group *to_o2nm_cluster_group(struct config_group *group)\n{\n\treturn group ?\n\t\tcontainer_of(to_configfs_subsystem(group), struct o2nm_cluster_group, cs_subsys)\n\t       : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstruct o2nm_cluster *o2nm_single_cluster = NULL;\n\nstatic void o2nm_cluster_group_drop_item(struct config_group *group, struct config_item *item)\n{\n\tstruct o2nm_cluster *cluster = to_o2nm_cluster(item);\n\tint i;\n\tstruct config_item *killme;\n\n\tBUG_ON(o2nm_single_cluster != cluster);\n\to2nm_single_cluster = NULL;\n\n\tfor (i = 0; cluster->cl_group.default_groups[i]; i++) {\n\t\tkillme = &cluster->cl_group.default_groups[i]->cg_item;\n\t\tcluster->cl_group.default_groups[i] = NULL;\n\t\tconfig_item_put(killme);\n\t}\n\n\tconfig_item_put(item);\n}"
  },
  {
    "function_name": "o2nm_cluster_group_make_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
    "lines": "802-851",
    "snippet": "static struct config_group *o2nm_cluster_group_make_group(struct config_group *group,\n\t\t\t\t\t\t\t  const char *name)\n{\n\tstruct o2nm_cluster *cluster = NULL;\n\tstruct o2nm_node_group *ns = NULL;\n\tstruct config_group *o2hb_group = NULL, *ret = NULL;\n\tvoid *defs = NULL;\n\n\t/* this runs under the parent dir's i_mutex; there can be only\n\t * one caller in here at a time */\n\tif (o2nm_single_cluster)\n\t\treturn ERR_PTR(-ENOSPC);\n\n\tcluster = kzalloc(sizeof(struct o2nm_cluster), GFP_KERNEL);\n\tns = kzalloc(sizeof(struct o2nm_node_group), GFP_KERNEL);\n\tdefs = kcalloc(3, sizeof(struct config_group *), GFP_KERNEL);\n\to2hb_group = o2hb_alloc_hb_set();\n\tif (cluster == NULL || ns == NULL || o2hb_group == NULL || defs == NULL)\n\t\tgoto out;\n\n\tconfig_group_init_type_name(&cluster->cl_group, name,\n\t\t\t\t    &o2nm_cluster_type);\n\tconfig_group_init_type_name(&ns->ns_group, \"node\",\n\t\t\t\t    &o2nm_node_group_type);\n\n\tcluster->cl_group.default_groups = defs;\n\tcluster->cl_group.default_groups[0] = &ns->ns_group;\n\tcluster->cl_group.default_groups[1] = o2hb_group;\n\tcluster->cl_group.default_groups[2] = NULL;\n\trwlock_init(&cluster->cl_nodes_lock);\n\tcluster->cl_node_ip_tree = RB_ROOT;\n\tcluster->cl_reconnect_delay_ms = O2NET_RECONNECT_DELAY_MS_DEFAULT;\n\tcluster->cl_idle_timeout_ms    = O2NET_IDLE_TIMEOUT_MS_DEFAULT;\n\tcluster->cl_keepalive_delay_ms = O2NET_KEEPALIVE_DELAY_MS_DEFAULT;\n\tcluster->cl_fence_method       = O2NM_FENCE_RESET;\n\n\tret = &cluster->cl_group;\n\to2nm_single_cluster = cluster;\n\nout:\n\tif (ret == NULL) {\n\t\tkfree(cluster);\n\t\tkfree(ns);\n\t\to2hb_free_hb_set(o2hb_group);\n\t\tkfree(defs);\n\t\tret = ERR_PTR(-ENOMEM);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"sys.h\"",
      "#include \"masklog.h\"",
      "#include \"heartbeat.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct o2nm_cluster *o2nm_single_cluster = NULL;",
      "static struct config_item_type o2nm_node_group_type = {\n\t.ct_group_ops\t= &o2nm_node_group_group_ops,\n\t.ct_owner\t= THIS_MODULE,\n};",
      "static struct config_item_type o2nm_cluster_type = {\n\t.ct_item_ops\t= &o2nm_cluster_item_ops,\n\t.ct_attrs\t= o2nm_cluster_attrs,\n\t.ct_owner\t= THIS_MODULE,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "defs"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2hb_free_hb_set",
          "args": [
            "o2hb_group"
          ],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "o2hb_free_hb_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/heartbeat.c",
          "lines": "2321-2325",
          "snippet": "void o2hb_free_hb_set(struct config_group *group)\n{\n\tstruct o2hb_heartbeat_group *hs = to_o2hb_heartbeat_group(group);\n\tkfree(hs);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include \"quorum.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <linux/bitmap.h>",
            "#include <linux/slab.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/time.h>",
            "#include <linux/crc32.h>",
            "#include <linux/random.h>",
            "#include <linux/configfs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/file.h>",
            "#include <linux/delay.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include \"quorum.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <linux/bitmap.h>\n#include <linux/slab.h>\n#include <linux/debugfs.h>\n#include <linux/time.h>\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/configfs.h>\n#include <linux/kthread.h>\n#include <linux/file.h>\n#include <linux/delay.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/jiffies.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nvoid o2hb_free_hb_set(struct config_group *group)\n{\n\tstruct o2hb_heartbeat_group *hs = to_o2hb_heartbeat_group(group);\n\tkfree(hs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ns"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cluster"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rwlock_init",
          "args": [
            "&cluster->cl_nodes_lock"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "config_group_init_type_name",
          "args": [
            "&ns->ns_group",
            "\"node\"",
            "&o2nm_node_group_type"
          ],
          "line": 824
        },
        "resolved": true,
        "details": {
          "function_name": "config_group_init_type_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/item.c",
          "lines": "125-131",
          "snippet": "void config_group_init_type_name(struct config_group *group, const char *name,\n\t\t\t struct config_item_type *type)\n{\n\tconfig_item_set_name(&group->cg_item, name);\n\tgroup->cg_item.ci_type = type;\n\tconfig_group_init(group);\n}",
          "includes": [
            "#include <linux/configfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/module.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/configfs.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/module.h>\n#include <linux/string.h>\n\nvoid config_group_init_type_name(struct config_group *group, const char *name,\n\t\t\t struct config_item_type *type)\n{\n\tconfig_item_set_name(&group->cg_item, name);\n\tgroup->cg_item.ci_type = type;\n\tconfig_group_init(group);\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2hb_alloc_hb_set",
          "args": [],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "o2hb_alloc_hb_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/heartbeat.c",
          "lines": "2302-2319",
          "snippet": "struct config_group *o2hb_alloc_hb_set(void)\n{\n\tstruct o2hb_heartbeat_group *hs = NULL;\n\tstruct config_group *ret = NULL;\n\n\ths = kzalloc(sizeof(struct o2hb_heartbeat_group), GFP_KERNEL);\n\tif (hs == NULL)\n\t\tgoto out;\n\n\tconfig_group_init_type_name(&hs->hs_group, \"heartbeat\",\n\t\t\t\t    &o2hb_heartbeat_group_type);\n\n\tret = &hs->hs_group;\nout:\n\tif (ret == NULL)\n\t\tkfree(hs);\n\treturn ret;\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include \"quorum.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <linux/bitmap.h>",
            "#include <linux/slab.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/time.h>",
            "#include <linux/crc32.h>",
            "#include <linux/random.h>",
            "#include <linux/configfs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/file.h>",
            "#include <linux/delay.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct config_item_type o2hb_heartbeat_group_type = {\n\t.ct_group_ops\t= &o2hb_heartbeat_group_group_ops,\n\t.ct_item_ops\t= &o2hb_heartbeat_group_item_ops,\n\t.ct_attrs\t= o2hb_heartbeat_group_attrs,\n\t.ct_owner\t= THIS_MODULE,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include \"quorum.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <linux/bitmap.h>\n#include <linux/slab.h>\n#include <linux/debugfs.h>\n#include <linux/time.h>\n#include <linux/crc32.h>\n#include <linux/random.h>\n#include <linux/configfs.h>\n#include <linux/kthread.h>\n#include <linux/file.h>\n#include <linux/delay.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/jiffies.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nstatic struct config_item_type o2hb_heartbeat_group_type = {\n\t.ct_group_ops\t= &o2hb_heartbeat_group_group_ops,\n\t.ct_item_ops\t= &o2hb_heartbeat_group_item_ops,\n\t.ct_attrs\t= o2hb_heartbeat_group_attrs,\n\t.ct_owner\t= THIS_MODULE,\n};\n\nstruct config_group *o2hb_alloc_hb_set(void)\n{\n\tstruct o2hb_heartbeat_group *hs = NULL;\n\tstruct config_group *ret = NULL;\n\n\ths = kzalloc(sizeof(struct o2hb_heartbeat_group), GFP_KERNEL);\n\tif (hs == NULL)\n\t\tgoto out;\n\n\tconfig_group_init_type_name(&hs->hs_group, \"heartbeat\",\n\t\t\t\t    &o2hb_heartbeat_group_type);\n\n\tret = &hs->hs_group;\nout:\n\tif (ret == NULL)\n\t\tkfree(hs);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "3",
            "sizeof(struct config_group *)",
            "GFP_KERNEL"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct o2nm_node_group)",
            "GFP_KERNEL"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct o2nm_cluster)",
            "GFP_KERNEL"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOSPC"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstruct o2nm_cluster *o2nm_single_cluster = NULL;\nstatic struct config_item_type o2nm_node_group_type = {\n\t.ct_group_ops\t= &o2nm_node_group_group_ops,\n\t.ct_owner\t= THIS_MODULE,\n};\nstatic struct config_item_type o2nm_cluster_type = {\n\t.ct_item_ops\t= &o2nm_cluster_item_ops,\n\t.ct_attrs\t= o2nm_cluster_attrs,\n\t.ct_owner\t= THIS_MODULE,\n};\n\nstatic struct config_group *o2nm_cluster_group_make_group(struct config_group *group,\n\t\t\t\t\t\t\t  const char *name)\n{\n\tstruct o2nm_cluster *cluster = NULL;\n\tstruct o2nm_node_group *ns = NULL;\n\tstruct config_group *o2hb_group = NULL, *ret = NULL;\n\tvoid *defs = NULL;\n\n\t/* this runs under the parent dir's i_mutex; there can be only\n\t * one caller in here at a time */\n\tif (o2nm_single_cluster)\n\t\treturn ERR_PTR(-ENOSPC);\n\n\tcluster = kzalloc(sizeof(struct o2nm_cluster), GFP_KERNEL);\n\tns = kzalloc(sizeof(struct o2nm_node_group), GFP_KERNEL);\n\tdefs = kcalloc(3, sizeof(struct config_group *), GFP_KERNEL);\n\to2hb_group = o2hb_alloc_hb_set();\n\tif (cluster == NULL || ns == NULL || o2hb_group == NULL || defs == NULL)\n\t\tgoto out;\n\n\tconfig_group_init_type_name(&cluster->cl_group, name,\n\t\t\t\t    &o2nm_cluster_type);\n\tconfig_group_init_type_name(&ns->ns_group, \"node\",\n\t\t\t\t    &o2nm_node_group_type);\n\n\tcluster->cl_group.default_groups = defs;\n\tcluster->cl_group.default_groups[0] = &ns->ns_group;\n\tcluster->cl_group.default_groups[1] = o2hb_group;\n\tcluster->cl_group.default_groups[2] = NULL;\n\trwlock_init(&cluster->cl_nodes_lock);\n\tcluster->cl_node_ip_tree = RB_ROOT;\n\tcluster->cl_reconnect_delay_ms = O2NET_RECONNECT_DELAY_MS_DEFAULT;\n\tcluster->cl_idle_timeout_ms    = O2NET_IDLE_TIMEOUT_MS_DEFAULT;\n\tcluster->cl_keepalive_delay_ms = O2NET_KEEPALIVE_DELAY_MS_DEFAULT;\n\tcluster->cl_fence_method       = O2NM_FENCE_RESET;\n\n\tret = &cluster->cl_group;\n\to2nm_single_cluster = cluster;\n\nout:\n\tif (ret == NULL) {\n\t\tkfree(cluster);\n\t\tkfree(ns);\n\t\to2hb_free_hb_set(o2hb_group);\n\t\tkfree(defs);\n\t\tret = ERR_PTR(-ENOMEM);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "to_o2nm_cluster_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
    "lines": "794-799",
    "snippet": "static struct o2nm_cluster_group *to_o2nm_cluster_group(struct config_group *group)\n{\n\treturn group ?\n\t\tcontainer_of(to_configfs_subsystem(group), struct o2nm_cluster_group, cs_subsys)\n\t       : NULL;\n}",
    "includes": [
      "#include \"sys.h\"",
      "#include \"masklog.h\"",
      "#include \"heartbeat.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct o2nm_cluster_group o2nm_cluster_group = {\n\t.cs_subsys = {\n\t\t.su_group = {\n\t\t\t.cg_item = {\n\t\t\t\t.ci_namebuf = \"cluster\",\n\t\t\t\t.ci_type = &o2nm_cluster_group_type,\n\t\t\t},\n\t\t},\n\t},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "to_configfs_subsystem(group)",
            "structo2nm_cluster_group",
            "cs_subsys"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_configfs_subsystem",
          "args": [
            "group"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstatic struct o2nm_cluster_group o2nm_cluster_group = {\n\t.cs_subsys = {\n\t\t.su_group = {\n\t\t\t.cg_item = {\n\t\t\t\t.ci_namebuf = \"cluster\",\n\t\t\t\t.ci_type = &o2nm_cluster_group_type,\n\t\t\t},\n\t\t},\n\t},\n};\n\nstatic struct o2nm_cluster_group *to_o2nm_cluster_group(struct config_group *group)\n{\n\treturn group ?\n\t\tcontainer_of(to_configfs_subsystem(group), struct o2nm_cluster_group, cs_subsys)\n\t       : NULL;\n}"
  },
  {
    "function_name": "o2nm_cluster_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
    "lines": "766-772",
    "snippet": "static void o2nm_cluster_release(struct config_item *item)\n{\n\tstruct o2nm_cluster *cluster = to_o2nm_cluster(item);\n\n\tkfree(cluster->cl_group.default_groups);\n\tkfree(cluster);\n}",
    "includes": [
      "#include \"sys.h\"",
      "#include \"masklog.h\"",
      "#include \"heartbeat.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cluster"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cluster->cl_group.default_groups"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_o2nm_cluster",
          "args": [
            "item"
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "to_o2nm_cluster_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
          "lines": "794-799",
          "snippet": "static struct o2nm_cluster_group *to_o2nm_cluster_group(struct config_group *group)\n{\n\treturn group ?\n\t\tcontainer_of(to_configfs_subsystem(group), struct o2nm_cluster_group, cs_subsys)\n\t       : NULL;\n}",
          "includes": [
            "#include \"sys.h\"",
            "#include \"masklog.h\"",
            "#include \"heartbeat.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct o2nm_cluster_group o2nm_cluster_group = {\n\t.cs_subsys = {\n\t\t.su_group = {\n\t\t\t.cg_item = {\n\t\t\t\t.ci_namebuf = \"cluster\",\n\t\t\t\t.ci_type = &o2nm_cluster_group_type,\n\t\t\t},\n\t\t},\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstatic struct o2nm_cluster_group o2nm_cluster_group = {\n\t.cs_subsys = {\n\t\t.su_group = {\n\t\t\t.cg_item = {\n\t\t\t\t.ci_namebuf = \"cluster\",\n\t\t\t\t.ci_type = &o2nm_cluster_group_type,\n\t\t\t},\n\t\t},\n\t},\n};\n\nstatic struct o2nm_cluster_group *to_o2nm_cluster_group(struct config_group *group)\n{\n\treturn group ?\n\t\tcontainer_of(to_configfs_subsystem(group), struct o2nm_cluster_group, cs_subsys)\n\t       : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstatic void o2nm_cluster_release(struct config_item *item)\n{\n\tstruct o2nm_cluster *cluster = to_o2nm_cluster(item);\n\n\tkfree(cluster->cl_group.default_groups);\n\tkfree(cluster);\n}"
  },
  {
    "function_name": "o2nm_node_group_drop_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
    "lines": "718-752",
    "snippet": "static void o2nm_node_group_drop_item(struct config_group *group,\n\t\t\t\t      struct config_item *item)\n{\n\tstruct o2nm_node *node = to_o2nm_node(item);\n\tstruct o2nm_cluster *cluster = to_o2nm_cluster(group->cg_item.ci_parent);\n\n\to2net_disconnect_node(node);\n\n\tif (cluster->cl_has_local &&\n\t    (cluster->cl_local_node == node->nd_num)) {\n\t\tcluster->cl_has_local = 0;\n\t\tcluster->cl_local_node = O2NM_INVALID_NODE_NUM;\n\t\to2net_stop_listening(node);\n\t}\n\n\t/* XXX call into net to stop this node from trading messages */\n\n\twrite_lock(&cluster->cl_nodes_lock);\n\n\t/* XXX sloppy */\n\tif (node->nd_ipv4_address)\n\t\trb_erase(&node->nd_ip_node, &cluster->cl_node_ip_tree);\n\n\t/* nd_num might be 0 if the node number hasn't been set.. */\n\tif (cluster->cl_nodes[node->nd_num] == node) {\n\t\tcluster->cl_nodes[node->nd_num] = NULL;\n\t\tclear_bit(node->nd_num, cluster->cl_nodes_bitmap);\n\t}\n\twrite_unlock(&cluster->cl_nodes_lock);\n\n\tmlog(ML_CLUSTER, \"o2nm: Unregistered node %s\\n\",\n\t     config_item_name(&node->nd_item));\n\n\tconfig_item_put(item);\n}",
    "includes": [
      "#include \"sys.h\"",
      "#include \"masklog.h\"",
      "#include \"heartbeat.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "config_item_put",
          "args": [
            "item"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "config_item_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/item.c",
          "lines": "171-175",
          "snippet": "void config_item_put(struct config_item *item)\n{\n\tif (item)\n\t\tkref_put(&item->ci_kref, config_item_release);\n}",
          "includes": [
            "#include <linux/configfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/module.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/configfs.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/module.h>\n#include <linux/string.h>\n\nvoid config_item_put(struct config_item *item)\n{\n\tif (item)\n\t\tkref_put(&item->ci_kref, config_item_release);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_CLUSTER",
            "\"o2nm: Unregistered node %s\\n\"",
            "config_item_name(&node->nd_item)"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "config_item_name",
          "args": [
            "&node->nd_item"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&cluster->cl_nodes_lock"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "node->nd_num",
            "cluster->cl_nodes_bitmap"
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&node->nd_ip_node",
            "&cluster->cl_node_ip_tree"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&cluster->cl_nodes_lock"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_stop_listening",
          "args": [
            "node"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_stop_listening",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "2129-2160",
          "snippet": "void o2net_stop_listening(struct o2nm_node *node)\n{\n\tstruct socket *sock = o2net_listen_sock;\n\tsize_t i;\n\n\tBUG_ON(o2net_wq == NULL);\n\tBUG_ON(o2net_listen_sock == NULL);\n\n\t/* stop the listening socket from generating work */\n\twrite_lock_bh(&sock->sk->sk_callback_lock);\n\tsock->sk->sk_data_ready = sock->sk->sk_user_data;\n\tsock->sk->sk_user_data = NULL;\n\twrite_unlock_bh(&sock->sk->sk_callback_lock);\n\n\tfor (i = 0; i < ARRAY_SIZE(o2net_nodes); i++) {\n\t\tstruct o2nm_node *node = o2nm_get_node_by_num(i);\n\t\tif (node) {\n\t\t\to2net_disconnect_node(node);\n\t\t\to2nm_node_put(node);\n\t\t}\n\t}\n\n\t/* finish all work and tear down the work queue */\n\tmlog(ML_KTHREAD, \"waiting for o2net thread to exit....\\n\");\n\tdestroy_workqueue(o2net_wq);\n\to2net_wq = NULL;\n\n\tsock_release(o2net_listen_sock);\n\to2net_listen_sock = NULL;\n\n\to2quo_conn_err(node->nd_num);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct o2net_node o2net_nodes[O2NM_MAX_NODES];",
            "static struct socket *o2net_listen_sock;",
            "static struct workqueue_struct *o2net_wq;",
            "static void o2net_sc_connect_completed(struct work_struct *work);",
            "static void o2net_rx_until_empty(struct work_struct *work);",
            "static void o2net_shutdown_sc(struct work_struct *work);",
            "static void o2net_listen_data_ready(struct sock *sk);",
            "static void o2net_sc_send_keep_req(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct o2net_node o2net_nodes[O2NM_MAX_NODES];\nstatic struct socket *o2net_listen_sock;\nstatic struct workqueue_struct *o2net_wq;\nstatic void o2net_sc_connect_completed(struct work_struct *work);\nstatic void o2net_rx_until_empty(struct work_struct *work);\nstatic void o2net_shutdown_sc(struct work_struct *work);\nstatic void o2net_listen_data_ready(struct sock *sk);\nstatic void o2net_sc_send_keep_req(struct work_struct *work);\n\nvoid o2net_stop_listening(struct o2nm_node *node)\n{\n\tstruct socket *sock = o2net_listen_sock;\n\tsize_t i;\n\n\tBUG_ON(o2net_wq == NULL);\n\tBUG_ON(o2net_listen_sock == NULL);\n\n\t/* stop the listening socket from generating work */\n\twrite_lock_bh(&sock->sk->sk_callback_lock);\n\tsock->sk->sk_data_ready = sock->sk->sk_user_data;\n\tsock->sk->sk_user_data = NULL;\n\twrite_unlock_bh(&sock->sk->sk_callback_lock);\n\n\tfor (i = 0; i < ARRAY_SIZE(o2net_nodes); i++) {\n\t\tstruct o2nm_node *node = o2nm_get_node_by_num(i);\n\t\tif (node) {\n\t\t\to2net_disconnect_node(node);\n\t\t\to2nm_node_put(node);\n\t\t}\n\t}\n\n\t/* finish all work and tear down the work queue */\n\tmlog(ML_KTHREAD, \"waiting for o2net thread to exit....\\n\");\n\tdestroy_workqueue(o2net_wq);\n\to2net_wq = NULL;\n\n\tsock_release(o2net_listen_sock);\n\to2net_listen_sock = NULL;\n\n\to2quo_conn_err(node->nd_num);\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_disconnect_node",
          "args": [
            "node"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_disconnect_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "1755-1771",
          "snippet": "void o2net_disconnect_node(struct o2nm_node *node)\n{\n\tstruct o2net_node *nn = o2net_nn_from_num(node->nd_num);\n\n\t/* don't reconnect until it's heartbeating again */\n\tspin_lock(&nn->nn_lock);\n\tatomic_set(&nn->nn_timeout, 0);\n\to2net_set_nn_state(nn, NULL, 0, -ENOTCONN);\n\tspin_unlock(&nn->nn_lock);\n\n\tif (o2net_wq) {\n\t\tcancel_delayed_work(&nn->nn_connect_expired);\n\t\tcancel_delayed_work(&nn->nn_connect_work);\n\t\tcancel_delayed_work(&nn->nn_still_up);\n\t\tflush_workqueue(o2net_wq);\n\t}\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *o2net_wq;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct workqueue_struct *o2net_wq;\n\nvoid o2net_disconnect_node(struct o2nm_node *node)\n{\n\tstruct o2net_node *nn = o2net_nn_from_num(node->nd_num);\n\n\t/* don't reconnect until it's heartbeating again */\n\tspin_lock(&nn->nn_lock);\n\tatomic_set(&nn->nn_timeout, 0);\n\to2net_set_nn_state(nn, NULL, 0, -ENOTCONN);\n\tspin_unlock(&nn->nn_lock);\n\n\tif (o2net_wq) {\n\t\tcancel_delayed_work(&nn->nn_connect_expired);\n\t\tcancel_delayed_work(&nn->nn_connect_work);\n\t\tcancel_delayed_work(&nn->nn_still_up);\n\t\tflush_workqueue(o2net_wq);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_o2nm_cluster",
          "args": [
            "group->cg_item.ci_parent"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "to_o2nm_cluster_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
          "lines": "794-799",
          "snippet": "static struct o2nm_cluster_group *to_o2nm_cluster_group(struct config_group *group)\n{\n\treturn group ?\n\t\tcontainer_of(to_configfs_subsystem(group), struct o2nm_cluster_group, cs_subsys)\n\t       : NULL;\n}",
          "includes": [
            "#include \"sys.h\"",
            "#include \"masklog.h\"",
            "#include \"heartbeat.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct o2nm_cluster_group o2nm_cluster_group = {\n\t.cs_subsys = {\n\t\t.su_group = {\n\t\t\t.cg_item = {\n\t\t\t\t.ci_namebuf = \"cluster\",\n\t\t\t\t.ci_type = &o2nm_cluster_group_type,\n\t\t\t},\n\t\t},\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstatic struct o2nm_cluster_group o2nm_cluster_group = {\n\t.cs_subsys = {\n\t\t.su_group = {\n\t\t\t.cg_item = {\n\t\t\t\t.ci_namebuf = \"cluster\",\n\t\t\t\t.ci_type = &o2nm_cluster_group_type,\n\t\t\t},\n\t\t},\n\t},\n};\n\nstatic struct o2nm_cluster_group *to_o2nm_cluster_group(struct config_group *group)\n{\n\treturn group ?\n\t\tcontainer_of(to_configfs_subsystem(group), struct o2nm_cluster_group, cs_subsys)\n\t       : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_o2nm_node",
          "args": [
            "item"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "to_o2nm_node_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
          "lines": "470-475",
          "snippet": "static struct o2nm_node_group *to_o2nm_node_group(struct config_group *group)\n{\n\treturn group ?\n\t\tcontainer_of(group, struct o2nm_node_group, ns_group)\n\t\t: NULL;\n}",
          "includes": [
            "#include \"sys.h\"",
            "#include \"masklog.h\"",
            "#include \"heartbeat.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstatic struct o2nm_node_group *to_o2nm_node_group(struct config_group *group)\n{\n\treturn group ?\n\t\tcontainer_of(group, struct o2nm_node_group, ns_group)\n\t\t: NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstatic void o2nm_node_group_drop_item(struct config_group *group,\n\t\t\t\t      struct config_item *item)\n{\n\tstruct o2nm_node *node = to_o2nm_node(item);\n\tstruct o2nm_cluster *cluster = to_o2nm_cluster(group->cg_item.ci_parent);\n\n\to2net_disconnect_node(node);\n\n\tif (cluster->cl_has_local &&\n\t    (cluster->cl_local_node == node->nd_num)) {\n\t\tcluster->cl_has_local = 0;\n\t\tcluster->cl_local_node = O2NM_INVALID_NODE_NUM;\n\t\to2net_stop_listening(node);\n\t}\n\n\t/* XXX call into net to stop this node from trading messages */\n\n\twrite_lock(&cluster->cl_nodes_lock);\n\n\t/* XXX sloppy */\n\tif (node->nd_ipv4_address)\n\t\trb_erase(&node->nd_ip_node, &cluster->cl_node_ip_tree);\n\n\t/* nd_num might be 0 if the node number hasn't been set.. */\n\tif (cluster->cl_nodes[node->nd_num] == node) {\n\t\tcluster->cl_nodes[node->nd_num] = NULL;\n\t\tclear_bit(node->nd_num, cluster->cl_nodes_bitmap);\n\t}\n\twrite_unlock(&cluster->cl_nodes_lock);\n\n\tmlog(ML_CLUSTER, \"o2nm: Unregistered node %s\\n\",\n\t     config_item_name(&node->nd_item));\n\n\tconfig_item_put(item);\n}"
  },
  {
    "function_name": "o2nm_node_group_make_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
    "lines": "697-716",
    "snippet": "static struct config_item *o2nm_node_group_make_item(struct config_group *group,\n\t\t\t\t\t\t     const char *name)\n{\n\tstruct o2nm_node *node = NULL;\n\n\tif (strlen(name) > O2NM_MAX_NAME_LEN)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tnode = kzalloc(sizeof(struct o2nm_node), GFP_KERNEL);\n\tif (node == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstrcpy(node->nd_name, name); /* use item.ci_namebuf instead? */\n\tconfig_item_init_type_name(&node->nd_item, name, &o2nm_node_type);\n\tspin_lock_init(&node->nd_lock);\n\n\tmlog(ML_CLUSTER, \"o2nm: Registering node %s\\n\", name);\n\n\treturn &node->nd_item;\n}",
    "includes": [
      "#include \"sys.h\"",
      "#include \"masklog.h\"",
      "#include \"heartbeat.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct config_item_type o2nm_node_type = {\n\t.ct_item_ops\t= &o2nm_node_item_ops,\n\t.ct_attrs\t= o2nm_node_attrs,\n\t.ct_owner\t= THIS_MODULE,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_CLUSTER",
            "\"o2nm: Registering node %s\\n\"",
            "name"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&node->nd_lock"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "config_item_init_type_name",
          "args": [
            "&node->nd_item",
            "name",
            "&o2nm_node_type"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "config_item_init_type_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/item.c",
          "lines": "115-122",
          "snippet": "void config_item_init_type_name(struct config_item *item,\n\t\t\t\tconst char *name,\n\t\t\t\tstruct config_item_type *type)\n{\n\tconfig_item_set_name(item, name);\n\titem->ci_type = type;\n\tconfig_item_init(item);\n}",
          "includes": [
            "#include <linux/configfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/module.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/configfs.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/module.h>\n#include <linux/string.h>\n\nvoid config_item_init_type_name(struct config_item *item,\n\t\t\t\tconst char *name,\n\t\t\t\tstruct config_item_type *type)\n{\n\tconfig_item_set_name(item, name);\n\titem->ci_type = type;\n\tconfig_item_init(item);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "node->nd_name",
            "name"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct o2nm_node)",
            "GFP_KERNEL"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENAMETOOLONG"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstatic struct config_item_type o2nm_node_type = {\n\t.ct_item_ops\t= &o2nm_node_item_ops,\n\t.ct_attrs\t= o2nm_node_attrs,\n\t.ct_owner\t= THIS_MODULE,\n};\n\nstatic struct config_item *o2nm_node_group_make_item(struct config_group *group,\n\t\t\t\t\t\t     const char *name)\n{\n\tstruct o2nm_node *node = NULL;\n\n\tif (strlen(name) > O2NM_MAX_NAME_LEN)\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\n\tnode = kzalloc(sizeof(struct o2nm_node), GFP_KERNEL);\n\tif (node == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstrcpy(node->nd_name, name); /* use item.ci_namebuf instead? */\n\tconfig_item_init_type_name(&node->nd_item, name, &o2nm_node_type);\n\tspin_lock_init(&node->nd_lock);\n\n\tmlog(ML_CLUSTER, \"o2nm: Registering node %s\\n\", name);\n\n\treturn &node->nd_item;\n}"
  },
  {
    "function_name": "o2nm_cluster_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
    "lines": "676-695",
    "snippet": "static ssize_t o2nm_cluster_store(struct config_item *item,\n                                  struct configfs_attribute *attr,\n                                  const char *page, size_t count)\n{\n\tstruct o2nm_cluster *cluster = to_o2nm_cluster(item);\n\tstruct o2nm_cluster_attribute *o2nm_cluster_attr =\n\t\tcontainer_of(attr, struct o2nm_cluster_attribute, attr);\n\tssize_t ret;\n\n\tif (o2nm_cluster_attr->store == NULL) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = o2nm_cluster_attr->store(cluster, page, count);\n\tif (ret < count)\n\t\tgoto out;\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"sys.h\"",
      "#include \"masklog.h\"",
      "#include \"heartbeat.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "o2nm_cluster_attr->store",
          "args": [
            "cluster",
            "page",
            "count"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "attr",
            "structo2nm_cluster_attribute",
            "attr"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_o2nm_cluster",
          "args": [
            "item"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "to_o2nm_cluster_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
          "lines": "794-799",
          "snippet": "static struct o2nm_cluster_group *to_o2nm_cluster_group(struct config_group *group)\n{\n\treturn group ?\n\t\tcontainer_of(to_configfs_subsystem(group), struct o2nm_cluster_group, cs_subsys)\n\t       : NULL;\n}",
          "includes": [
            "#include \"sys.h\"",
            "#include \"masklog.h\"",
            "#include \"heartbeat.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct o2nm_cluster_group o2nm_cluster_group = {\n\t.cs_subsys = {\n\t\t.su_group = {\n\t\t\t.cg_item = {\n\t\t\t\t.ci_namebuf = \"cluster\",\n\t\t\t\t.ci_type = &o2nm_cluster_group_type,\n\t\t\t},\n\t\t},\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstatic struct o2nm_cluster_group o2nm_cluster_group = {\n\t.cs_subsys = {\n\t\t.su_group = {\n\t\t\t.cg_item = {\n\t\t\t\t.ci_namebuf = \"cluster\",\n\t\t\t\t.ci_type = &o2nm_cluster_group_type,\n\t\t\t},\n\t\t},\n\t},\n};\n\nstatic struct o2nm_cluster_group *to_o2nm_cluster_group(struct config_group *group)\n{\n\treturn group ?\n\t\tcontainer_of(to_configfs_subsystem(group), struct o2nm_cluster_group, cs_subsys)\n\t       : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstatic ssize_t o2nm_cluster_store(struct config_item *item,\n                                  struct configfs_attribute *attr,\n                                  const char *page, size_t count)\n{\n\tstruct o2nm_cluster *cluster = to_o2nm_cluster(item);\n\tstruct o2nm_cluster_attribute *o2nm_cluster_attr =\n\t\tcontainer_of(attr, struct o2nm_cluster_attribute, attr);\n\tssize_t ret;\n\n\tif (o2nm_cluster_attr->store == NULL) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = o2nm_cluster_attr->store(cluster, page, count);\n\tif (ret < count)\n\t\tgoto out;\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "o2nm_cluster_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
    "lines": "662-674",
    "snippet": "static ssize_t o2nm_cluster_show(struct config_item *item,\n                                 struct configfs_attribute *attr,\n                                 char *page)\n{\n\tstruct o2nm_cluster *cluster = to_o2nm_cluster(item);\n\tstruct o2nm_cluster_attribute *o2nm_cluster_attr =\n\t\tcontainer_of(attr, struct o2nm_cluster_attribute, attr);\n\tssize_t ret = 0;\n\n\tif (o2nm_cluster_attr->show)\n\t\tret = o2nm_cluster_attr->show(cluster, page);\n\treturn ret;\n}",
    "includes": [
      "#include \"sys.h\"",
      "#include \"masklog.h\"",
      "#include \"heartbeat.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "o2nm_cluster_attr->show",
          "args": [
            "cluster",
            "page"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "attr",
            "structo2nm_cluster_attribute",
            "attr"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_o2nm_cluster",
          "args": [
            "item"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "to_o2nm_cluster_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
          "lines": "794-799",
          "snippet": "static struct o2nm_cluster_group *to_o2nm_cluster_group(struct config_group *group)\n{\n\treturn group ?\n\t\tcontainer_of(to_configfs_subsystem(group), struct o2nm_cluster_group, cs_subsys)\n\t       : NULL;\n}",
          "includes": [
            "#include \"sys.h\"",
            "#include \"masklog.h\"",
            "#include \"heartbeat.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct o2nm_cluster_group o2nm_cluster_group = {\n\t.cs_subsys = {\n\t\t.su_group = {\n\t\t\t.cg_item = {\n\t\t\t\t.ci_namebuf = \"cluster\",\n\t\t\t\t.ci_type = &o2nm_cluster_group_type,\n\t\t\t},\n\t\t},\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstatic struct o2nm_cluster_group o2nm_cluster_group = {\n\t.cs_subsys = {\n\t\t.su_group = {\n\t\t\t.cg_item = {\n\t\t\t\t.ci_namebuf = \"cluster\",\n\t\t\t\t.ci_type = &o2nm_cluster_group_type,\n\t\t\t},\n\t\t},\n\t},\n};\n\nstatic struct o2nm_cluster_group *to_o2nm_cluster_group(struct config_group *group)\n{\n\treturn group ?\n\t\tcontainer_of(to_configfs_subsystem(group), struct o2nm_cluster_group, cs_subsys)\n\t       : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstatic ssize_t o2nm_cluster_show(struct config_item *item,\n                                 struct configfs_attribute *attr,\n                                 char *page)\n{\n\tstruct o2nm_cluster *cluster = to_o2nm_cluster(item);\n\tstruct o2nm_cluster_attribute *o2nm_cluster_attr =\n\t\tcontainer_of(attr, struct o2nm_cluster_attribute, attr);\n\tssize_t ret = 0;\n\n\tif (o2nm_cluster_attr->show)\n\t\tret = o2nm_cluster_attr->show(cluster, page);\n\treturn ret;\n}"
  },
  {
    "function_name": "o2nm_cluster_attr_fence_method_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
    "lines": "598-621",
    "snippet": "static ssize_t o2nm_cluster_attr_fence_method_write(\n\tstruct o2nm_cluster *cluster, const char *page, size_t count)\n{\n\tunsigned int i;\n\n\tif (page[count - 1] != '\\n')\n\t\tgoto bail;\n\n\tfor (i = 0; i < O2NM_FENCE_METHODS; ++i) {\n\t\tif (count != strlen(o2nm_fence_method_desc[i]) + 1)\n\t\t\tcontinue;\n\t\tif (strncasecmp(page, o2nm_fence_method_desc[i], count - 1))\n\t\t\tcontinue;\n\t\tif (cluster->cl_fence_method != i) {\n\t\t\tprintk(KERN_INFO \"ocfs2: Changing fence method to %s\\n\",\n\t\t\t       o2nm_fence_method_desc[i]);\n\t\t\tcluster->cl_fence_method = i;\n\t\t}\n\t\treturn count;\n\t}\n\nbail:\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"sys.h\"",
      "#include \"masklog.h\"",
      "#include \"heartbeat.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "char *o2nm_fence_method_desc[O2NM_FENCE_METHODS] = {\n\t\t\"reset\",\t/* O2NM_FENCE_RESET */\n\t\t\"panic\",\t/* O2NM_FENCE_PANIC */\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"ocfs2: Changing fence method to %s\\n\"",
            "o2nm_fence_method_desc[i]"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncasecmp",
          "args": [
            "page",
            "o2nm_fence_method_desc[i]",
            "count - 1"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "o2nm_fence_method_desc[i]"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nchar *o2nm_fence_method_desc[O2NM_FENCE_METHODS] = {\n\t\t\"reset\",\t/* O2NM_FENCE_RESET */\n\t\t\"panic\",\t/* O2NM_FENCE_PANIC */\n};\n\nstatic ssize_t o2nm_cluster_attr_fence_method_write(\n\tstruct o2nm_cluster *cluster, const char *page, size_t count)\n{\n\tunsigned int i;\n\n\tif (page[count - 1] != '\\n')\n\t\tgoto bail;\n\n\tfor (i = 0; i < O2NM_FENCE_METHODS; ++i) {\n\t\tif (count != strlen(o2nm_fence_method_desc[i]) + 1)\n\t\t\tcontinue;\n\t\tif (strncasecmp(page, o2nm_fence_method_desc[i], count - 1))\n\t\t\tcontinue;\n\t\tif (cluster->cl_fence_method != i) {\n\t\t\tprintk(KERN_INFO \"ocfs2: Changing fence method to %s\\n\",\n\t\t\t       o2nm_fence_method_desc[i]);\n\t\t\tcluster->cl_fence_method = i;\n\t\t}\n\t\treturn count;\n\t}\n\nbail:\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "o2nm_cluster_attr_fence_method_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
    "lines": "587-596",
    "snippet": "static ssize_t o2nm_cluster_attr_fence_method_read(\n\tstruct o2nm_cluster *cluster, char *page)\n{\n\tssize_t ret = 0;\n\n\tif (cluster)\n\t\tret = sprintf(page, \"%s\\n\",\n\t\t\t      o2nm_fence_method_desc[cluster->cl_fence_method]);\n\treturn ret;\n}",
    "includes": [
      "#include \"sys.h\"",
      "#include \"masklog.h\"",
      "#include \"heartbeat.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "char *o2nm_fence_method_desc[O2NM_FENCE_METHODS] = {\n\t\t\"reset\",\t/* O2NM_FENCE_RESET */\n\t\t\"panic\",\t/* O2NM_FENCE_PANIC */\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "page",
            "\"%s\\n\"",
            "o2nm_fence_method_desc[cluster->cl_fence_method]"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nchar *o2nm_fence_method_desc[O2NM_FENCE_METHODS] = {\n\t\t\"reset\",\t/* O2NM_FENCE_RESET */\n\t\t\"panic\",\t/* O2NM_FENCE_PANIC */\n};\n\nstatic ssize_t o2nm_cluster_attr_fence_method_read(\n\tstruct o2nm_cluster *cluster, char *page)\n{\n\tssize_t ret = 0;\n\n\tif (cluster)\n\t\tret = sprintf(page, \"%s\\n\",\n\t\t\t      o2nm_fence_method_desc[cluster->cl_fence_method]);\n\treturn ret;\n}"
  },
  {
    "function_name": "o2nm_cluster_attr_reconnect_delay_ms_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
    "lines": "580-585",
    "snippet": "static ssize_t o2nm_cluster_attr_reconnect_delay_ms_write(\n\tstruct o2nm_cluster *cluster, const char *page, size_t count)\n{\n\treturn o2nm_cluster_attr_write(page, count,\n\t                               &cluster->cl_reconnect_delay_ms);\n}",
    "includes": [
      "#include \"sys.h\"",
      "#include \"masklog.h\"",
      "#include \"heartbeat.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "o2nm_cluster_attr_write",
          "args": [
            "page",
            "count",
            "&cluster->cl_reconnect_delay_ms"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "o2nm_cluster_attr_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
          "lines": "484-502",
          "snippet": "static ssize_t o2nm_cluster_attr_write(const char *page, ssize_t count,\n                                       unsigned int *val)\n{\n\tunsigned long tmp;\n\tchar *p = (char *)page;\n\n\ttmp = simple_strtoul(p, &p, 0);\n\tif (!p || (*p && (*p != '\\n')))\n\t\treturn -EINVAL;\n\n\tif (tmp == 0)\n\t\treturn -EINVAL;\n\tif (tmp >= (u32)-1)\n\t\treturn -ERANGE;\n\n\t*val = tmp;\n\n\treturn count;\n}",
          "includes": [
            "#include \"sys.h\"",
            "#include \"masklog.h\"",
            "#include \"heartbeat.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstatic ssize_t o2nm_cluster_attr_write(const char *page, ssize_t count,\n                                       unsigned int *val)\n{\n\tunsigned long tmp;\n\tchar *p = (char *)page;\n\n\ttmp = simple_strtoul(p, &p, 0);\n\tif (!p || (*p && (*p != '\\n')))\n\t\treturn -EINVAL;\n\n\tif (tmp == 0)\n\t\treturn -EINVAL;\n\tif (tmp >= (u32)-1)\n\t\treturn -ERANGE;\n\n\t*val = tmp;\n\n\treturn count;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstatic ssize_t o2nm_cluster_attr_reconnect_delay_ms_write(\n\tstruct o2nm_cluster *cluster, const char *page, size_t count)\n{\n\treturn o2nm_cluster_attr_write(page, count,\n\t                               &cluster->cl_reconnect_delay_ms);\n}"
  },
  {
    "function_name": "o2nm_cluster_attr_reconnect_delay_ms_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
    "lines": "574-578",
    "snippet": "static ssize_t o2nm_cluster_attr_reconnect_delay_ms_read(\n\tstruct o2nm_cluster *cluster, char *page)\n{\n\treturn sprintf(page, \"%u\\n\", cluster->cl_reconnect_delay_ms);\n}",
    "includes": [
      "#include \"sys.h\"",
      "#include \"masklog.h\"",
      "#include \"heartbeat.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "page",
            "\"%u\\n\"",
            "cluster->cl_reconnect_delay_ms"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstatic ssize_t o2nm_cluster_attr_reconnect_delay_ms_read(\n\tstruct o2nm_cluster *cluster, char *page)\n{\n\treturn sprintf(page, \"%u\\n\", cluster->cl_reconnect_delay_ms);\n}"
  },
  {
    "function_name": "o2nm_cluster_attr_keepalive_delay_ms_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
    "lines": "545-572",
    "snippet": "static ssize_t o2nm_cluster_attr_keepalive_delay_ms_write(\n\tstruct o2nm_cluster *cluster, const char *page, size_t count)\n{\n\tssize_t ret;\n\tunsigned int val;\n\n\tret =  o2nm_cluster_attr_write(page, count, &val);\n\n\tif (ret > 0) {\n\t\tif (cluster->cl_keepalive_delay_ms != val\n\t\t    && o2net_num_connected_peers()) {\n\t\t\tmlog(ML_NOTICE,\n\t\t\t     \"o2net: cannot change keepalive delay after\"\n\t\t\t     \" the first peer has agreed to it.\"\n\t\t\t     \"  %d connected peers\\n\",\n\t\t\t     o2net_num_connected_peers());\n\t\t\tret = -EINVAL;\n\t\t} else if (val >= cluster->cl_idle_timeout_ms) {\n\t\t\tmlog(ML_NOTICE, \"o2net: keepalive delay must be \"\n\t\t\t     \"smaller than idle timeout\\n\");\n\t\t\tret = -EINVAL;\n\t\t} else {\n\t\t\tcluster->cl_keepalive_delay_ms = val;\n\t\t}\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"sys.h\"",
      "#include \"masklog.h\"",
      "#include \"heartbeat.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_NOTICE",
            "\"o2net: keepalive delay must be \"\n\t\t\t     \"smaller than idle timeout\\n\""
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_NOTICE",
            "\"o2net: cannot change keepalive delay after\"\n\t\t\t     \" the first peer has agreed to it.\"\n\t\t\t     \"  %d connected peers\\n\"",
            "o2net_num_connected_peers()"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_num_connected_peers",
          "args": [],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_num_connected_peers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "498-501",
          "snippet": "int o2net_num_connected_peers(void)\n{\n\treturn atomic_read(&o2net_connected_peers);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t o2net_connected_peers = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic atomic_t o2net_connected_peers = ATOMIC_INIT(0);\n\nint o2net_num_connected_peers(void)\n{\n\treturn atomic_read(&o2net_connected_peers);\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2nm_cluster_attr_write",
          "args": [
            "page",
            "count",
            "&val"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "o2nm_cluster_attr_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
          "lines": "484-502",
          "snippet": "static ssize_t o2nm_cluster_attr_write(const char *page, ssize_t count,\n                                       unsigned int *val)\n{\n\tunsigned long tmp;\n\tchar *p = (char *)page;\n\n\ttmp = simple_strtoul(p, &p, 0);\n\tif (!p || (*p && (*p != '\\n')))\n\t\treturn -EINVAL;\n\n\tif (tmp == 0)\n\t\treturn -EINVAL;\n\tif (tmp >= (u32)-1)\n\t\treturn -ERANGE;\n\n\t*val = tmp;\n\n\treturn count;\n}",
          "includes": [
            "#include \"sys.h\"",
            "#include \"masklog.h\"",
            "#include \"heartbeat.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstatic ssize_t o2nm_cluster_attr_write(const char *page, ssize_t count,\n                                       unsigned int *val)\n{\n\tunsigned long tmp;\n\tchar *p = (char *)page;\n\n\ttmp = simple_strtoul(p, &p, 0);\n\tif (!p || (*p && (*p != '\\n')))\n\t\treturn -EINVAL;\n\n\tif (tmp == 0)\n\t\treturn -EINVAL;\n\tif (tmp >= (u32)-1)\n\t\treturn -ERANGE;\n\n\t*val = tmp;\n\n\treturn count;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstatic ssize_t o2nm_cluster_attr_keepalive_delay_ms_write(\n\tstruct o2nm_cluster *cluster, const char *page, size_t count)\n{\n\tssize_t ret;\n\tunsigned int val;\n\n\tret =  o2nm_cluster_attr_write(page, count, &val);\n\n\tif (ret > 0) {\n\t\tif (cluster->cl_keepalive_delay_ms != val\n\t\t    && o2net_num_connected_peers()) {\n\t\t\tmlog(ML_NOTICE,\n\t\t\t     \"o2net: cannot change keepalive delay after\"\n\t\t\t     \" the first peer has agreed to it.\"\n\t\t\t     \"  %d connected peers\\n\",\n\t\t\t     o2net_num_connected_peers());\n\t\t\tret = -EINVAL;\n\t\t} else if (val >= cluster->cl_idle_timeout_ms) {\n\t\t\tmlog(ML_NOTICE, \"o2net: keepalive delay must be \"\n\t\t\t     \"smaller than idle timeout\\n\");\n\t\t\tret = -EINVAL;\n\t\t} else {\n\t\t\tcluster->cl_keepalive_delay_ms = val;\n\t\t}\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "o2nm_cluster_attr_keepalive_delay_ms_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
    "lines": "539-543",
    "snippet": "static ssize_t o2nm_cluster_attr_keepalive_delay_ms_read(\n\tstruct o2nm_cluster *cluster, char *page)\n{\n\treturn sprintf(page, \"%u\\n\", cluster->cl_keepalive_delay_ms);\n}",
    "includes": [
      "#include \"sys.h\"",
      "#include \"masklog.h\"",
      "#include \"heartbeat.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "page",
            "\"%u\\n\"",
            "cluster->cl_keepalive_delay_ms"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstatic ssize_t o2nm_cluster_attr_keepalive_delay_ms_read(\n\tstruct o2nm_cluster *cluster, char *page)\n{\n\treturn sprintf(page, \"%u\\n\", cluster->cl_keepalive_delay_ms);\n}"
  },
  {
    "function_name": "o2nm_cluster_attr_idle_timeout_ms_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
    "lines": "510-537",
    "snippet": "static ssize_t o2nm_cluster_attr_idle_timeout_ms_write(\n\tstruct o2nm_cluster *cluster, const char *page, size_t count)\n{\n\tssize_t ret;\n\tunsigned int val;\n\n\tret =  o2nm_cluster_attr_write(page, count, &val);\n\n\tif (ret > 0) {\n\t\tif (cluster->cl_idle_timeout_ms != val\n\t\t\t&& o2net_num_connected_peers()) {\n\t\t\tmlog(ML_NOTICE,\n\t\t\t     \"o2net: cannot change idle timeout after \"\n\t\t\t     \"the first peer has agreed to it.\"\n\t\t\t     \"  %d connected peers\\n\",\n\t\t\t     o2net_num_connected_peers());\n\t\t\tret = -EINVAL;\n\t\t} else if (val <= cluster->cl_keepalive_delay_ms) {\n\t\t\tmlog(ML_NOTICE, \"o2net: idle timeout must be larger \"\n\t\t\t     \"than keepalive delay\\n\");\n\t\t\tret = -EINVAL;\n\t\t} else {\n\t\t\tcluster->cl_idle_timeout_ms = val;\n\t\t}\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"sys.h\"",
      "#include \"masklog.h\"",
      "#include \"heartbeat.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_NOTICE",
            "\"o2net: idle timeout must be larger \"\n\t\t\t     \"than keepalive delay\\n\""
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_NOTICE",
            "\"o2net: cannot change idle timeout after \"\n\t\t\t     \"the first peer has agreed to it.\"\n\t\t\t     \"  %d connected peers\\n\"",
            "o2net_num_connected_peers()"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_num_connected_peers",
          "args": [],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_num_connected_peers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "498-501",
          "snippet": "int o2net_num_connected_peers(void)\n{\n\treturn atomic_read(&o2net_connected_peers);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t o2net_connected_peers = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic atomic_t o2net_connected_peers = ATOMIC_INIT(0);\n\nint o2net_num_connected_peers(void)\n{\n\treturn atomic_read(&o2net_connected_peers);\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2nm_cluster_attr_write",
          "args": [
            "page",
            "count",
            "&val"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "o2nm_cluster_attr_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
          "lines": "484-502",
          "snippet": "static ssize_t o2nm_cluster_attr_write(const char *page, ssize_t count,\n                                       unsigned int *val)\n{\n\tunsigned long tmp;\n\tchar *p = (char *)page;\n\n\ttmp = simple_strtoul(p, &p, 0);\n\tif (!p || (*p && (*p != '\\n')))\n\t\treturn -EINVAL;\n\n\tif (tmp == 0)\n\t\treturn -EINVAL;\n\tif (tmp >= (u32)-1)\n\t\treturn -ERANGE;\n\n\t*val = tmp;\n\n\treturn count;\n}",
          "includes": [
            "#include \"sys.h\"",
            "#include \"masklog.h\"",
            "#include \"heartbeat.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstatic ssize_t o2nm_cluster_attr_write(const char *page, ssize_t count,\n                                       unsigned int *val)\n{\n\tunsigned long tmp;\n\tchar *p = (char *)page;\n\n\ttmp = simple_strtoul(p, &p, 0);\n\tif (!p || (*p && (*p != '\\n')))\n\t\treturn -EINVAL;\n\n\tif (tmp == 0)\n\t\treturn -EINVAL;\n\tif (tmp >= (u32)-1)\n\t\treturn -ERANGE;\n\n\t*val = tmp;\n\n\treturn count;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstatic ssize_t o2nm_cluster_attr_idle_timeout_ms_write(\n\tstruct o2nm_cluster *cluster, const char *page, size_t count)\n{\n\tssize_t ret;\n\tunsigned int val;\n\n\tret =  o2nm_cluster_attr_write(page, count, &val);\n\n\tif (ret > 0) {\n\t\tif (cluster->cl_idle_timeout_ms != val\n\t\t\t&& o2net_num_connected_peers()) {\n\t\t\tmlog(ML_NOTICE,\n\t\t\t     \"o2net: cannot change idle timeout after \"\n\t\t\t     \"the first peer has agreed to it.\"\n\t\t\t     \"  %d connected peers\\n\",\n\t\t\t     o2net_num_connected_peers());\n\t\t\tret = -EINVAL;\n\t\t} else if (val <= cluster->cl_keepalive_delay_ms) {\n\t\t\tmlog(ML_NOTICE, \"o2net: idle timeout must be larger \"\n\t\t\t     \"than keepalive delay\\n\");\n\t\t\tret = -EINVAL;\n\t\t} else {\n\t\t\tcluster->cl_idle_timeout_ms = val;\n\t\t}\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "o2nm_cluster_attr_idle_timeout_ms_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
    "lines": "504-508",
    "snippet": "static ssize_t o2nm_cluster_attr_idle_timeout_ms_read(\n\tstruct o2nm_cluster *cluster, char *page)\n{\n\treturn sprintf(page, \"%u\\n\", cluster->cl_idle_timeout_ms);\n}",
    "includes": [
      "#include \"sys.h\"",
      "#include \"masklog.h\"",
      "#include \"heartbeat.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "page",
            "\"%u\\n\"",
            "cluster->cl_idle_timeout_ms"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstatic ssize_t o2nm_cluster_attr_idle_timeout_ms_read(\n\tstruct o2nm_cluster *cluster, char *page)\n{\n\treturn sprintf(page, \"%u\\n\", cluster->cl_idle_timeout_ms);\n}"
  },
  {
    "function_name": "o2nm_cluster_attr_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
    "lines": "484-502",
    "snippet": "static ssize_t o2nm_cluster_attr_write(const char *page, ssize_t count,\n                                       unsigned int *val)\n{\n\tunsigned long tmp;\n\tchar *p = (char *)page;\n\n\ttmp = simple_strtoul(p, &p, 0);\n\tif (!p || (*p && (*p != '\\n')))\n\t\treturn -EINVAL;\n\n\tif (tmp == 0)\n\t\treturn -EINVAL;\n\tif (tmp >= (u32)-1)\n\t\treturn -ERANGE;\n\n\t*val = tmp;\n\n\treturn count;\n}",
    "includes": [
      "#include \"sys.h\"",
      "#include \"masklog.h\"",
      "#include \"heartbeat.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "p",
            "&p",
            "0"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstatic ssize_t o2nm_cluster_attr_write(const char *page, ssize_t count,\n                                       unsigned int *val)\n{\n\tunsigned long tmp;\n\tchar *p = (char *)page;\n\n\ttmp = simple_strtoul(p, &p, 0);\n\tif (!p || (*p && (*p != '\\n')))\n\t\treturn -EINVAL;\n\n\tif (tmp == 0)\n\t\treturn -EINVAL;\n\tif (tmp >= (u32)-1)\n\t\treturn -ERANGE;\n\n\t*val = tmp;\n\n\treturn count;\n}"
  },
  {
    "function_name": "to_o2nm_node_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
    "lines": "470-475",
    "snippet": "static struct o2nm_node_group *to_o2nm_node_group(struct config_group *group)\n{\n\treturn group ?\n\t\tcontainer_of(group, struct o2nm_node_group, ns_group)\n\t\t: NULL;\n}",
    "includes": [
      "#include \"sys.h\"",
      "#include \"masklog.h\"",
      "#include \"heartbeat.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "group",
            "structo2nm_node_group",
            "ns_group"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstatic struct o2nm_node_group *to_o2nm_node_group(struct config_group *group)\n{\n\treturn group ?\n\t\tcontainer_of(group, struct o2nm_node_group, ns_group)\n\t\t: NULL;\n}"
  },
  {
    "function_name": "o2nm_node_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
    "lines": "423-448",
    "snippet": "static ssize_t o2nm_node_store(struct config_item *item,\n\t\t\t       struct configfs_attribute *attr,\n\t\t\t       const char *page, size_t count)\n{\n\tstruct o2nm_node *node = to_o2nm_node(item);\n\tstruct o2nm_node_attribute *o2nm_node_attr =\n\t\tcontainer_of(attr, struct o2nm_node_attribute, attr);\n\tssize_t ret;\n\tint attr_index = o2nm_attr_index(attr);\n\n\tif (o2nm_node_attr->store == NULL) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (test_bit(attr_index, &node->nd_set_attributes))\n\t\treturn -EBUSY;\n\n\tret = o2nm_node_attr->store(node, page, count);\n\tif (ret < count)\n\t\tgoto out;\n\n\tset_bit(attr_index, &node->nd_set_attributes);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"sys.h\"",
      "#include \"masklog.h\"",
      "#include \"heartbeat.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "attr_index",
            "&node->nd_set_attributes"
          ],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2nm_node_attr->store",
          "args": [
            "node",
            "page",
            "count"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "attr_index",
            "&node->nd_set_attributes"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2nm_attr_index",
          "args": [
            "attr"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "o2nm_attr_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
          "lines": "398-407",
          "snippet": "static int o2nm_attr_index(struct configfs_attribute *attr)\n{\n\tint i;\n\tfor (i = 0; i < ARRAY_SIZE(o2nm_node_attrs); i++) {\n\t\tif (attr == o2nm_node_attrs[i])\n\t\t\treturn i;\n\t}\n\tBUG();\n\treturn 0;\n}",
          "includes": [
            "#include \"sys.h\"",
            "#include \"masklog.h\"",
            "#include \"heartbeat.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct configfs_attribute *o2nm_node_attrs[] = {\n\t[O2NM_NODE_ATTR_NUM] = &o2nm_node_attr_num.attr,\n\t[O2NM_NODE_ATTR_PORT] = &o2nm_node_attr_ipv4_port.attr,\n\t[O2NM_NODE_ATTR_ADDRESS] = &o2nm_node_attr_ipv4_address.attr,\n\t[O2NM_NODE_ATTR_LOCAL] = &o2nm_node_attr_local.attr,\n\tNULL,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstatic struct configfs_attribute *o2nm_node_attrs[] = {\n\t[O2NM_NODE_ATTR_NUM] = &o2nm_node_attr_num.attr,\n\t[O2NM_NODE_ATTR_PORT] = &o2nm_node_attr_ipv4_port.attr,\n\t[O2NM_NODE_ATTR_ADDRESS] = &o2nm_node_attr_ipv4_address.attr,\n\t[O2NM_NODE_ATTR_LOCAL] = &o2nm_node_attr_local.attr,\n\tNULL,\n};\n\nstatic int o2nm_attr_index(struct configfs_attribute *attr)\n{\n\tint i;\n\tfor (i = 0; i < ARRAY_SIZE(o2nm_node_attrs); i++) {\n\t\tif (attr == o2nm_node_attrs[i])\n\t\t\treturn i;\n\t}\n\tBUG();\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "attr",
            "structo2nm_node_attribute",
            "attr"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_o2nm_node",
          "args": [
            "item"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "to_o2nm_node_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
          "lines": "470-475",
          "snippet": "static struct o2nm_node_group *to_o2nm_node_group(struct config_group *group)\n{\n\treturn group ?\n\t\tcontainer_of(group, struct o2nm_node_group, ns_group)\n\t\t: NULL;\n}",
          "includes": [
            "#include \"sys.h\"",
            "#include \"masklog.h\"",
            "#include \"heartbeat.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstatic struct o2nm_node_group *to_o2nm_node_group(struct config_group *group)\n{\n\treturn group ?\n\t\tcontainer_of(group, struct o2nm_node_group, ns_group)\n\t\t: NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstatic ssize_t o2nm_node_store(struct config_item *item,\n\t\t\t       struct configfs_attribute *attr,\n\t\t\t       const char *page, size_t count)\n{\n\tstruct o2nm_node *node = to_o2nm_node(item);\n\tstruct o2nm_node_attribute *o2nm_node_attr =\n\t\tcontainer_of(attr, struct o2nm_node_attribute, attr);\n\tssize_t ret;\n\tint attr_index = o2nm_attr_index(attr);\n\n\tif (o2nm_node_attr->store == NULL) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (test_bit(attr_index, &node->nd_set_attributes))\n\t\treturn -EBUSY;\n\n\tret = o2nm_node_attr->store(node, page, count);\n\tif (ret < count)\n\t\tgoto out;\n\n\tset_bit(attr_index, &node->nd_set_attributes);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "o2nm_node_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
    "lines": "409-421",
    "snippet": "static ssize_t o2nm_node_show(struct config_item *item,\n\t\t\t      struct configfs_attribute *attr,\n\t\t\t      char *page)\n{\n\tstruct o2nm_node *node = to_o2nm_node(item);\n\tstruct o2nm_node_attribute *o2nm_node_attr =\n\t\tcontainer_of(attr, struct o2nm_node_attribute, attr);\n\tssize_t ret = 0;\n\n\tif (o2nm_node_attr->show)\n\t\tret = o2nm_node_attr->show(node, page);\n\treturn ret;\n}",
    "includes": [
      "#include \"sys.h\"",
      "#include \"masklog.h\"",
      "#include \"heartbeat.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "o2nm_node_attr->show",
          "args": [
            "node",
            "page"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "attr",
            "structo2nm_node_attribute",
            "attr"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_o2nm_node",
          "args": [
            "item"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "to_o2nm_node_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
          "lines": "470-475",
          "snippet": "static struct o2nm_node_group *to_o2nm_node_group(struct config_group *group)\n{\n\treturn group ?\n\t\tcontainer_of(group, struct o2nm_node_group, ns_group)\n\t\t: NULL;\n}",
          "includes": [
            "#include \"sys.h\"",
            "#include \"masklog.h\"",
            "#include \"heartbeat.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstatic struct o2nm_node_group *to_o2nm_node_group(struct config_group *group)\n{\n\treturn group ?\n\t\tcontainer_of(group, struct o2nm_node_group, ns_group)\n\t\t: NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstatic ssize_t o2nm_node_show(struct config_item *item,\n\t\t\t      struct configfs_attribute *attr,\n\t\t\t      char *page)\n{\n\tstruct o2nm_node *node = to_o2nm_node(item);\n\tstruct o2nm_node_attribute *o2nm_node_attr =\n\t\tcontainer_of(attr, struct o2nm_node_attribute, attr);\n\tssize_t ret = 0;\n\n\tif (o2nm_node_attr->show)\n\t\tret = o2nm_node_attr->show(node, page);\n\treturn ret;\n}"
  },
  {
    "function_name": "o2nm_attr_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
    "lines": "398-407",
    "snippet": "static int o2nm_attr_index(struct configfs_attribute *attr)\n{\n\tint i;\n\tfor (i = 0; i < ARRAY_SIZE(o2nm_node_attrs); i++) {\n\t\tif (attr == o2nm_node_attrs[i])\n\t\t\treturn i;\n\t}\n\tBUG();\n\treturn 0;\n}",
    "includes": [
      "#include \"sys.h\"",
      "#include \"masklog.h\"",
      "#include \"heartbeat.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct configfs_attribute *o2nm_node_attrs[] = {\n\t[O2NM_NODE_ATTR_NUM] = &o2nm_node_attr_num.attr,\n\t[O2NM_NODE_ATTR_PORT] = &o2nm_node_attr_ipv4_port.attr,\n\t[O2NM_NODE_ATTR_ADDRESS] = &o2nm_node_attr_ipv4_address.attr,\n\t[O2NM_NODE_ATTR_LOCAL] = &o2nm_node_attr_local.attr,\n\tNULL,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "o2nm_node_attrs"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstatic struct configfs_attribute *o2nm_node_attrs[] = {\n\t[O2NM_NODE_ATTR_NUM] = &o2nm_node_attr_num.attr,\n\t[O2NM_NODE_ATTR_PORT] = &o2nm_node_attr_ipv4_port.attr,\n\t[O2NM_NODE_ATTR_ADDRESS] = &o2nm_node_attr_ipv4_address.attr,\n\t[O2NM_NODE_ATTR_LOCAL] = &o2nm_node_attr_local.attr,\n\tNULL,\n};\n\nstatic int o2nm_attr_index(struct configfs_attribute *attr)\n{\n\tint i;\n\tfor (i = 0; i < ARRAY_SIZE(o2nm_node_attrs); i++) {\n\t\tif (attr == o2nm_node_attrs[i])\n\t\t\treturn i;\n\t}\n\tBUG();\n\treturn 0;\n}"
  },
  {
    "function_name": "o2nm_node_local_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
    "lines": "303-350",
    "snippet": "static ssize_t o2nm_node_local_write(struct o2nm_node *node, const char *page,\n\t\t\t\t     size_t count)\n{\n\tstruct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);\n\tunsigned long tmp;\n\tchar *p = (char *)page;\n\tssize_t ret;\n\n\ttmp = simple_strtoul(p, &p, 0);\n\tif (!p || (*p && (*p != '\\n')))\n\t\treturn -EINVAL;\n\n\ttmp = !!tmp; /* boolean of whether this node wants to be local */\n\n\t/* setting local turns on networking rx for now so we require having\n\t * set everything else first */\n\tif (!test_bit(O2NM_NODE_ATTR_ADDRESS, &node->nd_set_attributes) ||\n\t    !test_bit(O2NM_NODE_ATTR_NUM, &node->nd_set_attributes) ||\n\t    !test_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))\n\t\treturn -EINVAL; /* XXX */\n\n\t/* the only failure case is trying to set a new local node\n\t * when a different one is already set */\n\tif (tmp && tmp == cluster->cl_has_local &&\n\t    cluster->cl_local_node != node->nd_num)\n\t\treturn -EBUSY;\n\n\t/* bring up the rx thread if we're setting the new local node. */\n\tif (tmp && !cluster->cl_has_local) {\n\t\tret = o2net_start_listening(node);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (!tmp && cluster->cl_has_local &&\n\t    cluster->cl_local_node == node->nd_num) {\n\t\to2net_stop_listening(node);\n\t\tcluster->cl_local_node = O2NM_INVALID_NODE_NUM;\n\t}\n\n\tnode->nd_local = tmp;\n\tif (node->nd_local) {\n\t\tcluster->cl_has_local = tmp;\n\t\tcluster->cl_local_node = node->nd_num;\n\t}\n\n\treturn count;\n}",
    "includes": [
      "#include \"sys.h\"",
      "#include \"masklog.h\"",
      "#include \"heartbeat.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "o2net_stop_listening",
          "args": [
            "node"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_stop_listening",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "2129-2160",
          "snippet": "void o2net_stop_listening(struct o2nm_node *node)\n{\n\tstruct socket *sock = o2net_listen_sock;\n\tsize_t i;\n\n\tBUG_ON(o2net_wq == NULL);\n\tBUG_ON(o2net_listen_sock == NULL);\n\n\t/* stop the listening socket from generating work */\n\twrite_lock_bh(&sock->sk->sk_callback_lock);\n\tsock->sk->sk_data_ready = sock->sk->sk_user_data;\n\tsock->sk->sk_user_data = NULL;\n\twrite_unlock_bh(&sock->sk->sk_callback_lock);\n\n\tfor (i = 0; i < ARRAY_SIZE(o2net_nodes); i++) {\n\t\tstruct o2nm_node *node = o2nm_get_node_by_num(i);\n\t\tif (node) {\n\t\t\to2net_disconnect_node(node);\n\t\t\to2nm_node_put(node);\n\t\t}\n\t}\n\n\t/* finish all work and tear down the work queue */\n\tmlog(ML_KTHREAD, \"waiting for o2net thread to exit....\\n\");\n\tdestroy_workqueue(o2net_wq);\n\to2net_wq = NULL;\n\n\tsock_release(o2net_listen_sock);\n\to2net_listen_sock = NULL;\n\n\to2quo_conn_err(node->nd_num);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct o2net_node o2net_nodes[O2NM_MAX_NODES];",
            "static struct socket *o2net_listen_sock;",
            "static struct workqueue_struct *o2net_wq;",
            "static void o2net_sc_connect_completed(struct work_struct *work);",
            "static void o2net_rx_until_empty(struct work_struct *work);",
            "static void o2net_shutdown_sc(struct work_struct *work);",
            "static void o2net_listen_data_ready(struct sock *sk);",
            "static void o2net_sc_send_keep_req(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct o2net_node o2net_nodes[O2NM_MAX_NODES];\nstatic struct socket *o2net_listen_sock;\nstatic struct workqueue_struct *o2net_wq;\nstatic void o2net_sc_connect_completed(struct work_struct *work);\nstatic void o2net_rx_until_empty(struct work_struct *work);\nstatic void o2net_shutdown_sc(struct work_struct *work);\nstatic void o2net_listen_data_ready(struct sock *sk);\nstatic void o2net_sc_send_keep_req(struct work_struct *work);\n\nvoid o2net_stop_listening(struct o2nm_node *node)\n{\n\tstruct socket *sock = o2net_listen_sock;\n\tsize_t i;\n\n\tBUG_ON(o2net_wq == NULL);\n\tBUG_ON(o2net_listen_sock == NULL);\n\n\t/* stop the listening socket from generating work */\n\twrite_lock_bh(&sock->sk->sk_callback_lock);\n\tsock->sk->sk_data_ready = sock->sk->sk_user_data;\n\tsock->sk->sk_user_data = NULL;\n\twrite_unlock_bh(&sock->sk->sk_callback_lock);\n\n\tfor (i = 0; i < ARRAY_SIZE(o2net_nodes); i++) {\n\t\tstruct o2nm_node *node = o2nm_get_node_by_num(i);\n\t\tif (node) {\n\t\t\to2net_disconnect_node(node);\n\t\t\to2nm_node_put(node);\n\t\t}\n\t}\n\n\t/* finish all work and tear down the work queue */\n\tmlog(ML_KTHREAD, \"waiting for o2net thread to exit....\\n\");\n\tdestroy_workqueue(o2net_wq);\n\to2net_wq = NULL;\n\n\tsock_release(o2net_listen_sock);\n\to2net_listen_sock = NULL;\n\n\to2quo_conn_err(node->nd_num);\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2net_start_listening",
          "args": [
            "node"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_start_listening",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "2102-2125",
          "snippet": "int o2net_start_listening(struct o2nm_node *node)\n{\n\tint ret = 0;\n\n\tBUG_ON(o2net_wq != NULL);\n\tBUG_ON(o2net_listen_sock != NULL);\n\n\tmlog(ML_KTHREAD, \"starting o2net thread...\\n\");\n\to2net_wq = create_singlethread_workqueue(\"o2net\");\n\tif (o2net_wq == NULL) {\n\t\tmlog(ML_ERROR, \"unable to launch o2net thread\\n\");\n\t\treturn -ENOMEM; /* ? */\n\t}\n\n\tret = o2net_open_listening_sock(node->nd_ipv4_address,\n\t\t\t\t\tnode->nd_ipv4_port);\n\tif (ret) {\n\t\tdestroy_workqueue(o2net_wq);\n\t\to2net_wq = NULL;\n\t} else\n\t\to2quo_conn_up(node->nd_num);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct socket *o2net_listen_sock;",
            "static struct workqueue_struct *o2net_wq;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct socket *o2net_listen_sock;\nstatic struct workqueue_struct *o2net_wq;\n\nint o2net_start_listening(struct o2nm_node *node)\n{\n\tint ret = 0;\n\n\tBUG_ON(o2net_wq != NULL);\n\tBUG_ON(o2net_listen_sock != NULL);\n\n\tmlog(ML_KTHREAD, \"starting o2net thread...\\n\");\n\to2net_wq = create_singlethread_workqueue(\"o2net\");\n\tif (o2net_wq == NULL) {\n\t\tmlog(ML_ERROR, \"unable to launch o2net thread\\n\");\n\t\treturn -ENOMEM; /* ? */\n\t}\n\n\tret = o2net_open_listening_sock(node->nd_ipv4_address,\n\t\t\t\t\tnode->nd_ipv4_port);\n\tif (ret) {\n\t\tdestroy_workqueue(o2net_wq);\n\t\to2net_wq = NULL;\n\t} else\n\t\to2quo_conn_up(node->nd_num);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "O2NM_NODE_ATTR_PORT",
            "&node->nd_set_attributes"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "p",
            "&p",
            "0"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_o2nm_cluster_from_node",
          "args": [
            "node"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "to_o2nm_cluster_from_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
          "lines": "180-185",
          "snippet": "static struct o2nm_cluster *to_o2nm_cluster_from_node(struct o2nm_node *node)\n{\n\t/* through the first node_set .parent\n\t * mycluster/nodes/mynode == o2nm_cluster->o2nm_node_group->o2nm_node */\n\treturn to_o2nm_cluster(node->nd_item.ci_parent->ci_parent);\n}",
          "includes": [
            "#include \"sys.h\"",
            "#include \"masklog.h\"",
            "#include \"heartbeat.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstatic struct o2nm_cluster *to_o2nm_cluster_from_node(struct o2nm_node *node)\n{\n\t/* through the first node_set .parent\n\t * mycluster/nodes/mynode == o2nm_cluster->o2nm_node_group->o2nm_node */\n\treturn to_o2nm_cluster(node->nd_item.ci_parent->ci_parent);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstatic ssize_t o2nm_node_local_write(struct o2nm_node *node, const char *page,\n\t\t\t\t     size_t count)\n{\n\tstruct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);\n\tunsigned long tmp;\n\tchar *p = (char *)page;\n\tssize_t ret;\n\n\ttmp = simple_strtoul(p, &p, 0);\n\tif (!p || (*p && (*p != '\\n')))\n\t\treturn -EINVAL;\n\n\ttmp = !!tmp; /* boolean of whether this node wants to be local */\n\n\t/* setting local turns on networking rx for now so we require having\n\t * set everything else first */\n\tif (!test_bit(O2NM_NODE_ATTR_ADDRESS, &node->nd_set_attributes) ||\n\t    !test_bit(O2NM_NODE_ATTR_NUM, &node->nd_set_attributes) ||\n\t    !test_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))\n\t\treturn -EINVAL; /* XXX */\n\n\t/* the only failure case is trying to set a new local node\n\t * when a different one is already set */\n\tif (tmp && tmp == cluster->cl_has_local &&\n\t    cluster->cl_local_node != node->nd_num)\n\t\treturn -EBUSY;\n\n\t/* bring up the rx thread if we're setting the new local node. */\n\tif (tmp && !cluster->cl_has_local) {\n\t\tret = o2net_start_listening(node);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (!tmp && cluster->cl_has_local &&\n\t    cluster->cl_local_node == node->nd_num) {\n\t\to2net_stop_listening(node);\n\t\tcluster->cl_local_node = O2NM_INVALID_NODE_NUM;\n\t}\n\n\tnode->nd_local = tmp;\n\tif (node->nd_local) {\n\t\tcluster->cl_has_local = tmp;\n\t\tcluster->cl_local_node = node->nd_num;\n\t}\n\n\treturn count;\n}"
  },
  {
    "function_name": "o2nm_node_local_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
    "lines": "298-301",
    "snippet": "static ssize_t o2nm_node_local_read(struct o2nm_node *node, char *page)\n{\n\treturn sprintf(page, \"%d\\n\", node->nd_local);\n}",
    "includes": [
      "#include \"sys.h\"",
      "#include \"masklog.h\"",
      "#include \"heartbeat.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "page",
            "\"%d\\n\"",
            "node->nd_local"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstatic ssize_t o2nm_node_local_read(struct o2nm_node *node, char *page)\n{\n\treturn sprintf(page, \"%d\\n\", node->nd_local);\n}"
  },
  {
    "function_name": "o2nm_node_ipv4_address_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
    "lines": "260-296",
    "snippet": "static ssize_t o2nm_node_ipv4_address_write(struct o2nm_node *node,\n\t\t\t\t\t    const char *page,\n\t\t\t\t\t    size_t count)\n{\n\tstruct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);\n\tint ret, i;\n\tstruct rb_node **p, *parent;\n\tunsigned int octets[4];\n\t__be32 ipv4_addr = 0;\n\n\tret = sscanf(page, \"%3u.%3u.%3u.%3u\", &octets[3], &octets[2],\n\t\t     &octets[1], &octets[0]);\n\tif (ret != 4)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < ARRAY_SIZE(octets); i++) {\n\t\tif (octets[i] > 255)\n\t\t\treturn -ERANGE;\n\t\tbe32_add_cpu(&ipv4_addr, octets[i] << (i * 8));\n\t}\n\n\tret = 0;\n\twrite_lock(&cluster->cl_nodes_lock);\n\tif (o2nm_node_ip_tree_lookup(cluster, ipv4_addr, &p, &parent))\n\t\tret = -EEXIST;\n\telse {\n\t\trb_link_node(&node->nd_ip_node, parent, p);\n\t\trb_insert_color(&node->nd_ip_node, &cluster->cl_node_ip_tree);\n\t}\n\twrite_unlock(&cluster->cl_nodes_lock);\n\tif (ret)\n\t\treturn ret;\n\n\tmemcpy(&node->nd_ipv4_address, &ipv4_addr, sizeof(ipv4_addr));\n\n\treturn count;\n}",
    "includes": [
      "#include \"sys.h\"",
      "#include \"masklog.h\"",
      "#include \"heartbeat.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&node->nd_ipv4_address",
            "&ipv4_addr",
            "sizeof(ipv4_addr)"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&cluster->cl_nodes_lock"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "&node->nd_ip_node",
            "&cluster->cl_node_ip_tree"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "&node->nd_ip_node",
            "parent",
            "p"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o2nm_node_ip_tree_lookup",
          "args": [
            "cluster",
            "ipv4_addr",
            "&p",
            "&parent"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "o2nm_node_ip_tree_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
          "lines": "77-110",
          "snippet": "static struct o2nm_node *o2nm_node_ip_tree_lookup(struct o2nm_cluster *cluster,\n\t\t\t\t\t\t  __be32 ip_needle,\n\t\t\t\t\t\t  struct rb_node ***ret_p,\n\t\t\t\t\t\t  struct rb_node **ret_parent)\n{\n\tstruct rb_node **p = &cluster->cl_node_ip_tree.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct o2nm_node *node, *ret = NULL;\n\n\twhile (*p) {\n\t\tint cmp;\n\n\t\tparent = *p;\n\t\tnode = rb_entry(parent, struct o2nm_node, nd_ip_node);\n\n\t\tcmp = memcmp(&ip_needle, &node->nd_ipv4_address,\n\t\t\t\tsizeof(ip_needle));\n\t\tif (cmp < 0)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (cmp > 0)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\tret = node;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret_p != NULL)\n\t\t*ret_p = p;\n\tif (ret_parent != NULL)\n\t\t*ret_parent = parent;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"sys.h\"",
            "#include \"masklog.h\"",
            "#include \"heartbeat.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstatic struct o2nm_node *o2nm_node_ip_tree_lookup(struct o2nm_cluster *cluster,\n\t\t\t\t\t\t  __be32 ip_needle,\n\t\t\t\t\t\t  struct rb_node ***ret_p,\n\t\t\t\t\t\t  struct rb_node **ret_parent)\n{\n\tstruct rb_node **p = &cluster->cl_node_ip_tree.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct o2nm_node *node, *ret = NULL;\n\n\twhile (*p) {\n\t\tint cmp;\n\n\t\tparent = *p;\n\t\tnode = rb_entry(parent, struct o2nm_node, nd_ip_node);\n\n\t\tcmp = memcmp(&ip_needle, &node->nd_ipv4_address,\n\t\t\t\tsizeof(ip_needle));\n\t\tif (cmp < 0)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (cmp > 0)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\tret = node;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret_p != NULL)\n\t\t*ret_p = p;\n\tif (ret_parent != NULL)\n\t\t*ret_parent = parent;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&cluster->cl_nodes_lock"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_add_cpu",
          "args": [
            "&ipv4_addr",
            "octets[i] << (i * 8)"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "octets"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "page",
            "\"%3u.%3u.%3u.%3u\"",
            "&octets[3]",
            "&octets[2]",
            "&octets[1]",
            "&octets[0]"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_o2nm_cluster_from_node",
          "args": [
            "node"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "to_o2nm_cluster_from_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
          "lines": "180-185",
          "snippet": "static struct o2nm_cluster *to_o2nm_cluster_from_node(struct o2nm_node *node)\n{\n\t/* through the first node_set .parent\n\t * mycluster/nodes/mynode == o2nm_cluster->o2nm_node_group->o2nm_node */\n\treturn to_o2nm_cluster(node->nd_item.ci_parent->ci_parent);\n}",
          "includes": [
            "#include \"sys.h\"",
            "#include \"masklog.h\"",
            "#include \"heartbeat.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstatic struct o2nm_cluster *to_o2nm_cluster_from_node(struct o2nm_node *node)\n{\n\t/* through the first node_set .parent\n\t * mycluster/nodes/mynode == o2nm_cluster->o2nm_node_group->o2nm_node */\n\treturn to_o2nm_cluster(node->nd_item.ci_parent->ci_parent);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstatic ssize_t o2nm_node_ipv4_address_write(struct o2nm_node *node,\n\t\t\t\t\t    const char *page,\n\t\t\t\t\t    size_t count)\n{\n\tstruct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);\n\tint ret, i;\n\tstruct rb_node **p, *parent;\n\tunsigned int octets[4];\n\t__be32 ipv4_addr = 0;\n\n\tret = sscanf(page, \"%3u.%3u.%3u.%3u\", &octets[3], &octets[2],\n\t\t     &octets[1], &octets[0]);\n\tif (ret != 4)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < ARRAY_SIZE(octets); i++) {\n\t\tif (octets[i] > 255)\n\t\t\treturn -ERANGE;\n\t\tbe32_add_cpu(&ipv4_addr, octets[i] << (i * 8));\n\t}\n\n\tret = 0;\n\twrite_lock(&cluster->cl_nodes_lock);\n\tif (o2nm_node_ip_tree_lookup(cluster, ipv4_addr, &p, &parent))\n\t\tret = -EEXIST;\n\telse {\n\t\trb_link_node(&node->nd_ip_node, parent, p);\n\t\trb_insert_color(&node->nd_ip_node, &cluster->cl_node_ip_tree);\n\t}\n\twrite_unlock(&cluster->cl_nodes_lock);\n\tif (ret)\n\t\treturn ret;\n\n\tmemcpy(&node->nd_ipv4_address, &ipv4_addr, sizeof(ipv4_addr));\n\n\treturn count;\n}"
  },
  {
    "function_name": "o2nm_node_ipv4_address_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
    "lines": "255-258",
    "snippet": "static ssize_t o2nm_node_ipv4_address_read(struct o2nm_node *node, char *page)\n{\n\treturn sprintf(page, \"%pI4\\n\", &node->nd_ipv4_address);\n}",
    "includes": [
      "#include \"sys.h\"",
      "#include \"masklog.h\"",
      "#include \"heartbeat.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "page",
            "\"%pI4\\n\"",
            "&node->nd_ipv4_address"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstatic ssize_t o2nm_node_ipv4_address_read(struct o2nm_node *node, char *page)\n{\n\treturn sprintf(page, \"%pI4\\n\", &node->nd_ipv4_address);\n}"
  },
  {
    "function_name": "o2nm_node_ipv4_port_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
    "lines": "235-253",
    "snippet": "static ssize_t o2nm_node_ipv4_port_write(struct o2nm_node *node,\n\t\t\t\t\t const char *page, size_t count)\n{\n\tunsigned long tmp;\n\tchar *p = (char *)page;\n\n\ttmp = simple_strtoul(p, &p, 0);\n\tif (!p || (*p && (*p != '\\n')))\n\t\treturn -EINVAL;\n\n\tif (tmp == 0)\n\t\treturn -EINVAL;\n\tif (tmp >= (u16)-1)\n\t\treturn -ERANGE;\n\n\tnode->nd_ipv4_port = htons(tmp);\n\n\treturn count;\n}",
    "includes": [
      "#include \"sys.h\"",
      "#include \"masklog.h\"",
      "#include \"heartbeat.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "tmp"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "p",
            "&p",
            "0"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstatic ssize_t o2nm_node_ipv4_port_write(struct o2nm_node *node,\n\t\t\t\t\t const char *page, size_t count)\n{\n\tunsigned long tmp;\n\tchar *p = (char *)page;\n\n\ttmp = simple_strtoul(p, &p, 0);\n\tif (!p || (*p && (*p != '\\n')))\n\t\treturn -EINVAL;\n\n\tif (tmp == 0)\n\t\treturn -EINVAL;\n\tif (tmp >= (u16)-1)\n\t\treturn -ERANGE;\n\n\tnode->nd_ipv4_port = htons(tmp);\n\n\treturn count;\n}"
  },
  {
    "function_name": "o2nm_node_ipv4_port_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
    "lines": "230-233",
    "snippet": "static ssize_t o2nm_node_ipv4_port_read(struct o2nm_node *node, char *page)\n{\n\treturn sprintf(page, \"%u\\n\", ntohs(node->nd_ipv4_port));\n}",
    "includes": [
      "#include \"sys.h\"",
      "#include \"masklog.h\"",
      "#include \"heartbeat.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "page",
            "\"%u\\n\"",
            "ntohs(node->nd_ipv4_port)"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "node->nd_ipv4_port"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstatic ssize_t o2nm_node_ipv4_port_read(struct o2nm_node *node, char *page)\n{\n\treturn sprintf(page, \"%u\\n\", ntohs(node->nd_ipv4_port));\n}"
  },
  {
    "function_name": "o2nm_node_num_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
    "lines": "194-229",
    "snippet": "static ssize_t o2nm_node_num_write(struct o2nm_node *node, const char *page,\n\t\t\t\t   size_t count)\n{\n\tstruct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);\n\tunsigned long tmp;\n\tchar *p = (char *)page;\n\n\ttmp = simple_strtoul(p, &p, 0);\n\tif (!p || (*p && (*p != '\\n')))\n\t\treturn -EINVAL;\n\n\tif (tmp >= O2NM_MAX_NODES)\n\t\treturn -ERANGE;\n\n\t/* once we're in the cl_nodes tree networking can look us up by\n\t * node number and try to use our address and port attributes\n\t * to connect to this node.. make sure that they've been set\n\t * before writing the node attribute? */\n\tif (!test_bit(O2NM_NODE_ATTR_ADDRESS, &node->nd_set_attributes) ||\n\t    !test_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))\n\t\treturn -EINVAL; /* XXX */\n\n\twrite_lock(&cluster->cl_nodes_lock);\n\tif (cluster->cl_nodes[tmp])\n\t\tp = NULL;\n\telse  {\n\t\tcluster->cl_nodes[tmp] = node;\n\t\tnode->nd_num = tmp;\n\t\tset_bit(tmp, cluster->cl_nodes_bitmap);\n\t}\n\twrite_unlock(&cluster->cl_nodes_lock);\n\tif (p == NULL)\n\t\treturn -EEXIST;\n\n\treturn count;\n}",
    "includes": [
      "#include \"sys.h\"",
      "#include \"masklog.h\"",
      "#include \"heartbeat.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&cluster->cl_nodes_lock"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_unlock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "51-67",
          "snippet": "int __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nint __must_check reiserfs_write_unlock_nested(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\tint depth;\n\n\t/* this can happen when the lock isn't always held */\n\tif (sb_i->lock_owner != current)\n\t\treturn -1;\n\n\tdepth = sb_i->lock_depth;\n\n\tsb_i->lock_depth = -1;\n\tsb_i->lock_owner = NULL;\n\tmutex_unlock(&sb_i->lock);\n\n\treturn depth;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "tmp",
            "cluster->cl_nodes_bitmap"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&cluster->cl_nodes_lock"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_write_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/lock.c",
          "lines": "21-32",
          "snippet": "void reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include \"reiserfs.h\"\n\nvoid reiserfs_write_lock(struct super_block *s)\n{\n\tstruct reiserfs_sb_info *sb_i = REISERFS_SB(s);\n\n\tif (sb_i->lock_owner != current) {\n\t\tmutex_lock(&sb_i->lock);\n\t\tsb_i->lock_owner = current;\n\t}\n\n\t/* No need to protect it, only the current task touches it */\n\tsb_i->lock_depth++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "O2NM_NODE_ATTR_PORT",
            "&node->nd_set_attributes"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "p",
            "&p",
            "0"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_o2nm_cluster_from_node",
          "args": [
            "node"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "to_o2nm_cluster_from_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
          "lines": "180-185",
          "snippet": "static struct o2nm_cluster *to_o2nm_cluster_from_node(struct o2nm_node *node)\n{\n\t/* through the first node_set .parent\n\t * mycluster/nodes/mynode == o2nm_cluster->o2nm_node_group->o2nm_node */\n\treturn to_o2nm_cluster(node->nd_item.ci_parent->ci_parent);\n}",
          "includes": [
            "#include \"sys.h\"",
            "#include \"masklog.h\"",
            "#include \"heartbeat.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstatic struct o2nm_cluster *to_o2nm_cluster_from_node(struct o2nm_node *node)\n{\n\t/* through the first node_set .parent\n\t * mycluster/nodes/mynode == o2nm_cluster->o2nm_node_group->o2nm_node */\n\treturn to_o2nm_cluster(node->nd_item.ci_parent->ci_parent);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstatic ssize_t o2nm_node_num_write(struct o2nm_node *node, const char *page,\n\t\t\t\t   size_t count)\n{\n\tstruct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);\n\tunsigned long tmp;\n\tchar *p = (char *)page;\n\n\ttmp = simple_strtoul(p, &p, 0);\n\tif (!p || (*p && (*p != '\\n')))\n\t\treturn -EINVAL;\n\n\tif (tmp >= O2NM_MAX_NODES)\n\t\treturn -ERANGE;\n\n\t/* once we're in the cl_nodes tree networking can look us up by\n\t * node number and try to use our address and port attributes\n\t * to connect to this node.. make sure that they've been set\n\t * before writing the node attribute? */\n\tif (!test_bit(O2NM_NODE_ATTR_ADDRESS, &node->nd_set_attributes) ||\n\t    !test_bit(O2NM_NODE_ATTR_PORT, &node->nd_set_attributes))\n\t\treturn -EINVAL; /* XXX */\n\n\twrite_lock(&cluster->cl_nodes_lock);\n\tif (cluster->cl_nodes[tmp])\n\t\tp = NULL;\n\telse  {\n\t\tcluster->cl_nodes[tmp] = node;\n\t\tnode->nd_num = tmp;\n\t\tset_bit(tmp, cluster->cl_nodes_bitmap);\n\t}\n\twrite_unlock(&cluster->cl_nodes_lock);\n\tif (p == NULL)\n\t\treturn -EEXIST;\n\n\treturn count;\n}"
  },
  {
    "function_name": "to_o2nm_cluster_from_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
    "lines": "180-185",
    "snippet": "static struct o2nm_cluster *to_o2nm_cluster_from_node(struct o2nm_node *node)\n{\n\t/* through the first node_set .parent\n\t * mycluster/nodes/mynode == o2nm_cluster->o2nm_node_group->o2nm_node */\n\treturn to_o2nm_cluster(node->nd_item.ci_parent->ci_parent);\n}",
    "includes": [
      "#include \"sys.h\"",
      "#include \"masklog.h\"",
      "#include \"heartbeat.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "to_o2nm_cluster",
          "args": [
            "node->nd_item.ci_parent->ci_parent"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "to_o2nm_cluster_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
          "lines": "794-799",
          "snippet": "static struct o2nm_cluster_group *to_o2nm_cluster_group(struct config_group *group)\n{\n\treturn group ?\n\t\tcontainer_of(to_configfs_subsystem(group), struct o2nm_cluster_group, cs_subsys)\n\t       : NULL;\n}",
          "includes": [
            "#include \"sys.h\"",
            "#include \"masklog.h\"",
            "#include \"heartbeat.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct o2nm_cluster_group o2nm_cluster_group = {\n\t.cs_subsys = {\n\t\t.su_group = {\n\t\t\t.cg_item = {\n\t\t\t\t.ci_namebuf = \"cluster\",\n\t\t\t\t.ci_type = &o2nm_cluster_group_type,\n\t\t\t},\n\t\t},\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstatic struct o2nm_cluster_group o2nm_cluster_group = {\n\t.cs_subsys = {\n\t\t.su_group = {\n\t\t\t.cg_item = {\n\t\t\t\t.ci_namebuf = \"cluster\",\n\t\t\t\t.ci_type = &o2nm_cluster_group_type,\n\t\t\t},\n\t\t},\n\t},\n};\n\nstatic struct o2nm_cluster_group *to_o2nm_cluster_group(struct config_group *group)\n{\n\treturn group ?\n\t\tcontainer_of(to_configfs_subsystem(group), struct o2nm_cluster_group, cs_subsys)\n\t       : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstatic struct o2nm_cluster *to_o2nm_cluster_from_node(struct o2nm_node *node)\n{\n\t/* through the first node_set .parent\n\t * mycluster/nodes/mynode == o2nm_cluster->o2nm_node_group->o2nm_node */\n\treturn to_o2nm_cluster(node->nd_item.ci_parent->ci_parent);\n}"
  },
  {
    "function_name": "o2nm_node_num_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
    "lines": "175-178",
    "snippet": "static ssize_t o2nm_node_num_read(struct o2nm_node *node, char *page)\n{\n\treturn sprintf(page, \"%d\\n\", node->nd_num);\n}",
    "includes": [
      "#include \"sys.h\"",
      "#include \"masklog.h\"",
      "#include \"heartbeat.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "page",
            "\"%d\\n\"",
            "node->nd_num"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstatic ssize_t o2nm_node_num_read(struct o2nm_node *node, char *page)\n{\n\treturn sprintf(page, \"%d\\n\", node->nd_num);\n}"
  },
  {
    "function_name": "o2nm_node_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
    "lines": "169-173",
    "snippet": "static void o2nm_node_release(struct config_item *item)\n{\n\tstruct o2nm_node *node = to_o2nm_node(item);\n\tkfree(node);\n}",
    "includes": [
      "#include \"sys.h\"",
      "#include \"masklog.h\"",
      "#include \"heartbeat.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "node"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_o2nm_node",
          "args": [
            "item"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "to_o2nm_node_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
          "lines": "470-475",
          "snippet": "static struct o2nm_node_group *to_o2nm_node_group(struct config_group *group)\n{\n\treturn group ?\n\t\tcontainer_of(group, struct o2nm_node_group, ns_group)\n\t\t: NULL;\n}",
          "includes": [
            "#include \"sys.h\"",
            "#include \"masklog.h\"",
            "#include \"heartbeat.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstatic struct o2nm_node_group *to_o2nm_node_group(struct config_group *group)\n{\n\treturn group ?\n\t\tcontainer_of(group, struct o2nm_node_group, ns_group)\n\t\t: NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstatic void o2nm_node_release(struct config_item *item)\n{\n\tstruct o2nm_node *node = to_o2nm_node(item);\n\tkfree(node);\n}"
  },
  {
    "function_name": "to_o2nm_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
    "lines": "164-167",
    "snippet": "static struct o2nm_node *to_o2nm_node(struct config_item *item)\n{\n\treturn item ? container_of(item, struct o2nm_node, nd_item) : NULL;\n}",
    "includes": [
      "#include \"sys.h\"",
      "#include \"masklog.h\"",
      "#include \"heartbeat.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "item",
            "structo2nm_node",
            "nd_item"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstatic struct o2nm_node *to_o2nm_node(struct config_item *item)\n{\n\treturn item ? container_of(item, struct o2nm_node, nd_item) : NULL;\n}"
  },
  {
    "function_name": "to_o2nm_cluster",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
    "lines": "156-162",
    "snippet": "static struct o2nm_cluster *to_o2nm_cluster(struct config_item *item)\n{\n\treturn item ?\n\t\tcontainer_of(to_config_group(item), struct o2nm_cluster,\n\t\t\t     cl_group)\n\t\t: NULL;\n}",
    "includes": [
      "#include \"sys.h\"",
      "#include \"masklog.h\"",
      "#include \"heartbeat.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "to_config_group(item)",
            "structo2nm_cluster",
            "cl_group"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_config_group",
          "args": [
            "item"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstatic struct o2nm_cluster *to_o2nm_cluster(struct config_item *item)\n{\n\treturn item ?\n\t\tcontainer_of(to_config_group(item), struct o2nm_cluster,\n\t\t\t     cl_group)\n\t\t: NULL;\n}"
  },
  {
    "function_name": "o2nm_this_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
    "lines": "143-151",
    "snippet": "u8 o2nm_this_node(void)\n{\n\tu8 node_num = O2NM_MAX_NODES;\n\n\tif (o2nm_single_cluster && o2nm_single_cluster->cl_has_local)\n\t\tnode_num = o2nm_single_cluster->cl_local_node;\n\n\treturn node_num;\n}",
    "includes": [
      "#include \"sys.h\"",
      "#include \"masklog.h\"",
      "#include \"heartbeat.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct o2nm_cluster *o2nm_single_cluster = NULL;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstruct o2nm_cluster *o2nm_single_cluster = NULL;\n\nu8 o2nm_this_node(void)\n{\n\tu8 node_num = O2NM_MAX_NODES;\n\n\tif (o2nm_single_cluster && o2nm_single_cluster->cl_has_local)\n\t\tnode_num = o2nm_single_cluster->cl_local_node;\n\n\treturn node_num;\n}"
  },
  {
    "function_name": "o2nm_node_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
    "lines": "137-140",
    "snippet": "void o2nm_node_get(struct o2nm_node *node)\n{\n\tconfig_item_get(&node->nd_item);\n}",
    "includes": [
      "#include \"sys.h\"",
      "#include \"masklog.h\"",
      "#include \"heartbeat.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "config_item_get",
          "args": [
            "&node->nd_item"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "config_item_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/item.c",
          "lines": "134-139",
          "snippet": "struct config_item *config_item_get(struct config_item *item)\n{\n\tif (item)\n\t\tkref_get(&item->ci_kref);\n\treturn item;\n}",
          "includes": [
            "#include <linux/configfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/module.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/configfs.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/module.h>\n#include <linux/string.h>\n\nstruct config_item *config_item_get(struct config_item *item)\n{\n\tif (item)\n\t\tkref_get(&item->ci_kref);\n\treturn item;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nvoid o2nm_node_get(struct o2nm_node *node)\n{\n\tconfig_item_get(&node->nd_item);\n}"
  },
  {
    "function_name": "o2nm_node_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
    "lines": "131-134",
    "snippet": "void o2nm_node_put(struct o2nm_node *node)\n{\n\tconfig_item_put(&node->nd_item);\n}",
    "includes": [
      "#include \"sys.h\"",
      "#include \"masklog.h\"",
      "#include \"heartbeat.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "config_item_put",
          "args": [
            "&node->nd_item"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "config_item_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/item.c",
          "lines": "171-175",
          "snippet": "void config_item_put(struct config_item *item)\n{\n\tif (item)\n\t\tkref_put(&item->ci_kref, config_item_release);\n}",
          "includes": [
            "#include <linux/configfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/module.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/configfs.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/module.h>\n#include <linux/string.h>\n\nvoid config_item_put(struct config_item *item)\n{\n\tif (item)\n\t\tkref_put(&item->ci_kref, config_item_release);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nvoid o2nm_node_put(struct o2nm_node *node)\n{\n\tconfig_item_put(&node->nd_item);\n}"
  },
  {
    "function_name": "o2nm_get_node_by_ip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
    "lines": "112-128",
    "snippet": "struct o2nm_node *o2nm_get_node_by_ip(__be32 addr)\n{\n\tstruct o2nm_node *node = NULL;\n\tstruct o2nm_cluster *cluster = o2nm_single_cluster;\n\n\tif (cluster == NULL)\n\t\tgoto out;\n\n\tread_lock(&cluster->cl_nodes_lock);\n\tnode = o2nm_node_ip_tree_lookup(cluster, addr, NULL, NULL);\n\tif (node)\n\t\tconfig_item_get(&node->nd_item);\n\tread_unlock(&cluster->cl_nodes_lock);\n\nout:\n\treturn node;\n}",
    "includes": [
      "#include \"sys.h\"",
      "#include \"masklog.h\"",
      "#include \"heartbeat.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct o2nm_cluster *o2nm_single_cluster = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&cluster->cl_nodes_lock"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "340-343",
          "snippet": "static inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "config_item_get",
          "args": [
            "&node->nd_item"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "config_item_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/item.c",
          "lines": "134-139",
          "snippet": "struct config_item *config_item_get(struct config_item *item)\n{\n\tif (item)\n\t\tkref_get(&item->ci_kref);\n\treturn item;\n}",
          "includes": [
            "#include <linux/configfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/module.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/configfs.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/module.h>\n#include <linux/string.h>\n\nstruct config_item *config_item_get(struct config_item *item)\n{\n\tif (item)\n\t\tkref_get(&item->ci_kref);\n\treturn item;\n}"
        }
      },
      {
        "call_info": {
          "callee": "o2nm_node_ip_tree_lookup",
          "args": [
            "cluster",
            "addr",
            "NULL",
            "NULL"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "o2nm_node_ip_tree_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
          "lines": "77-110",
          "snippet": "static struct o2nm_node *o2nm_node_ip_tree_lookup(struct o2nm_cluster *cluster,\n\t\t\t\t\t\t  __be32 ip_needle,\n\t\t\t\t\t\t  struct rb_node ***ret_p,\n\t\t\t\t\t\t  struct rb_node **ret_parent)\n{\n\tstruct rb_node **p = &cluster->cl_node_ip_tree.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct o2nm_node *node, *ret = NULL;\n\n\twhile (*p) {\n\t\tint cmp;\n\n\t\tparent = *p;\n\t\tnode = rb_entry(parent, struct o2nm_node, nd_ip_node);\n\n\t\tcmp = memcmp(&ip_needle, &node->nd_ipv4_address,\n\t\t\t\tsizeof(ip_needle));\n\t\tif (cmp < 0)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (cmp > 0)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\tret = node;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret_p != NULL)\n\t\t*ret_p = p;\n\tif (ret_parent != NULL)\n\t\t*ret_parent = parent;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"sys.h\"",
            "#include \"masklog.h\"",
            "#include \"heartbeat.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include <linux/configfs.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstatic struct o2nm_node *o2nm_node_ip_tree_lookup(struct o2nm_cluster *cluster,\n\t\t\t\t\t\t  __be32 ip_needle,\n\t\t\t\t\t\t  struct rb_node ***ret_p,\n\t\t\t\t\t\t  struct rb_node **ret_parent)\n{\n\tstruct rb_node **p = &cluster->cl_node_ip_tree.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct o2nm_node *node, *ret = NULL;\n\n\twhile (*p) {\n\t\tint cmp;\n\n\t\tparent = *p;\n\t\tnode = rb_entry(parent, struct o2nm_node, nd_ip_node);\n\n\t\tcmp = memcmp(&ip_needle, &node->nd_ipv4_address,\n\t\t\t\tsizeof(ip_needle));\n\t\tif (cmp < 0)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (cmp > 0)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\tret = node;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret_p != NULL)\n\t\t*ret_p = p;\n\tif (ret_parent != NULL)\n\t\t*ret_parent = parent;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&cluster->cl_nodes_lock"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_read_locked_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "550-1203",
          "snippet": "static int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\n\t/*\n\t * This is for checking whether an inode has changed w.r.t. a file so\n\t * that the file can be updated if necessary (compare with f_version).\n\t */\n\tvi->i_version = 1;\n\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_CACHE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/aio.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ntfs_read_locked_inode(struct inode *vi);",
            "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
            "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nstatic int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\n\t/*\n\t * This is for checking whether an inode has changed w.r.t. a file so\n\t * that the file can be updated if necessary (compare with f_version).\n\t */\n\tvi->i_version = 1;\n\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_CACHE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstruct o2nm_cluster *o2nm_single_cluster = NULL;\n\nstruct o2nm_node *o2nm_get_node_by_ip(__be32 addr)\n{\n\tstruct o2nm_node *node = NULL;\n\tstruct o2nm_cluster *cluster = o2nm_single_cluster;\n\n\tif (cluster == NULL)\n\t\tgoto out;\n\n\tread_lock(&cluster->cl_nodes_lock);\n\tnode = o2nm_node_ip_tree_lookup(cluster, addr, NULL, NULL);\n\tif (node)\n\t\tconfig_item_get(&node->nd_item);\n\tread_unlock(&cluster->cl_nodes_lock);\n\nout:\n\treturn node;\n}"
  },
  {
    "function_name": "o2nm_node_ip_tree_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
    "lines": "77-110",
    "snippet": "static struct o2nm_node *o2nm_node_ip_tree_lookup(struct o2nm_cluster *cluster,\n\t\t\t\t\t\t  __be32 ip_needle,\n\t\t\t\t\t\t  struct rb_node ***ret_p,\n\t\t\t\t\t\t  struct rb_node **ret_parent)\n{\n\tstruct rb_node **p = &cluster->cl_node_ip_tree.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct o2nm_node *node, *ret = NULL;\n\n\twhile (*p) {\n\t\tint cmp;\n\n\t\tparent = *p;\n\t\tnode = rb_entry(parent, struct o2nm_node, nd_ip_node);\n\n\t\tcmp = memcmp(&ip_needle, &node->nd_ipv4_address,\n\t\t\t\tsizeof(ip_needle));\n\t\tif (cmp < 0)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (cmp > 0)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\tret = node;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret_p != NULL)\n\t\t*ret_p = p;\n\tif (ret_parent != NULL)\n\t\t*ret_parent = parent;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"sys.h\"",
      "#include \"masklog.h\"",
      "#include \"heartbeat.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "&ip_needle",
            "&node->nd_ipv4_address",
            "sizeof(ip_needle)"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "parent",
            "structo2nm_node",
            "nd_ip_node"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstatic struct o2nm_node *o2nm_node_ip_tree_lookup(struct o2nm_cluster *cluster,\n\t\t\t\t\t\t  __be32 ip_needle,\n\t\t\t\t\t\t  struct rb_node ***ret_p,\n\t\t\t\t\t\t  struct rb_node **ret_parent)\n{\n\tstruct rb_node **p = &cluster->cl_node_ip_tree.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct o2nm_node *node, *ret = NULL;\n\n\twhile (*p) {\n\t\tint cmp;\n\n\t\tparent = *p;\n\t\tnode = rb_entry(parent, struct o2nm_node, nd_ip_node);\n\n\t\tcmp = memcmp(&ip_needle, &node->nd_ipv4_address,\n\t\t\t\tsizeof(ip_needle));\n\t\tif (cmp < 0)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (cmp > 0)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\tret = node;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret_p != NULL)\n\t\t*ret_p = p;\n\tif (ret_parent != NULL)\n\t\t*ret_parent = parent;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "o2nm_configured_node_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
    "lines": "60-74",
    "snippet": "int o2nm_configured_node_map(unsigned long *map, unsigned bytes)\n{\n\tstruct o2nm_cluster *cluster = o2nm_single_cluster;\n\n\tBUG_ON(bytes < (sizeof(cluster->cl_nodes_bitmap)));\n\n\tif (cluster == NULL)\n\t\treturn -EINVAL;\n\n\tread_lock(&cluster->cl_nodes_lock);\n\tmemcpy(map, cluster->cl_nodes_bitmap, sizeof(cluster->cl_nodes_bitmap));\n\tread_unlock(&cluster->cl_nodes_lock);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"sys.h\"",
      "#include \"masklog.h\"",
      "#include \"heartbeat.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct o2nm_cluster *o2nm_single_cluster = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&cluster->cl_nodes_lock"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "340-343",
          "snippet": "static inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "map",
            "cluster->cl_nodes_bitmap",
            "sizeof(cluster->cl_nodes_bitmap)"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&cluster->cl_nodes_lock"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_read_locked_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "550-1203",
          "snippet": "static int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\n\t/*\n\t * This is for checking whether an inode has changed w.r.t. a file so\n\t * that the file can be updated if necessary (compare with f_version).\n\t */\n\tvi->i_version = 1;\n\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_CACHE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/aio.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ntfs_read_locked_inode(struct inode *vi);",
            "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
            "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nstatic int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\n\t/*\n\t * This is for checking whether an inode has changed w.r.t. a file so\n\t * that the file can be updated if necessary (compare with f_version).\n\t */\n\tvi->i_version = 1;\n\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_CACHE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "bytes < (sizeof(cluster->cl_nodes_bitmap))"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstruct o2nm_cluster *o2nm_single_cluster = NULL;\n\nint o2nm_configured_node_map(unsigned long *map, unsigned bytes)\n{\n\tstruct o2nm_cluster *cluster = o2nm_single_cluster;\n\n\tBUG_ON(bytes < (sizeof(cluster->cl_nodes_bitmap)));\n\n\tif (cluster == NULL)\n\t\treturn -EINVAL;\n\n\tread_lock(&cluster->cl_nodes_lock);\n\tmemcpy(map, cluster->cl_nodes_bitmap, sizeof(cluster->cl_nodes_bitmap));\n\tread_unlock(&cluster->cl_nodes_lock);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "o2nm_get_node_by_num",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/nodemanager.c",
    "lines": "43-57",
    "snippet": "struct o2nm_node *o2nm_get_node_by_num(u8 node_num)\n{\n\tstruct o2nm_node *node = NULL;\n\n\tif (node_num >= O2NM_MAX_NODES || o2nm_single_cluster == NULL)\n\t\tgoto out;\n\n\tread_lock(&o2nm_single_cluster->cl_nodes_lock);\n\tnode = o2nm_single_cluster->cl_nodes[node_num];\n\tif (node)\n\t\tconfig_item_get(&node->nd_item);\n\tread_unlock(&o2nm_single_cluster->cl_nodes_lock);\nout:\n\treturn node;\n}",
    "includes": [
      "#include \"sys.h\"",
      "#include \"masklog.h\"",
      "#include \"heartbeat.h\"",
      "#include \"nodemanager.h\"",
      "#include \"tcp.h\"",
      "#include <linux/configfs.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct o2nm_cluster *o2nm_single_cluster = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&o2nm_single_cluster->cl_nodes_lock"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "tree_mod_log_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "340-343",
          "snippet": "static inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstatic inline void tree_mod_log_read_unlock(struct btrfs_fs_info *fs_info)\n{\n\tread_unlock(&fs_info->tree_mod_log_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "config_item_get",
          "args": [
            "&node->nd_item"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "config_item_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/configfs/item.c",
          "lines": "134-139",
          "snippet": "struct config_item *config_item_get(struct config_item *item)\n{\n\tif (item)\n\t\tkref_get(&item->ci_kref);\n\treturn item;\n}",
          "includes": [
            "#include <linux/configfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/module.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/configfs.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/module.h>\n#include <linux/string.h>\n\nstruct config_item *config_item_get(struct config_item *item)\n{\n\tif (item)\n\t\tkref_get(&item->ci_kref);\n\treturn item;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&o2nm_single_cluster->cl_nodes_lock"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_read_locked_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/inode.c",
          "lines": "550-1203",
          "snippet": "static int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\n\t/*\n\t * This is for checking whether an inode has changed w.r.t. a file so\n\t * that the file can be updated if necessary (compare with f_version).\n\t */\n\tvi->i_version = 1;\n\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_CACHE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"time.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"inode.h\"",
            "#include \"debug.h\"",
            "#include \"dir.h\"",
            "#include \"bitmap.h\"",
            "#include \"attrib.h\"",
            "#include \"aops.h\"",
            "#include <linux/aio.h>",
            "#include <linux/log2.h>",
            "#include <linux/slab.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mutex.h>",
            "#include <linux/mount.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ntfs_read_locked_inode(struct inode *vi);",
            "static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);",
            "static int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"time.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"inode.h\"\n#include \"debug.h\"\n#include \"dir.h\"\n#include \"bitmap.h\"\n#include \"attrib.h\"\n#include \"aops.h\"\n#include <linux/aio.h>\n#include <linux/log2.h>\n#include <linux/slab.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n\nstatic int ntfs_read_locked_inode(struct inode *vi);\nstatic int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi);\nstatic int ntfs_read_locked_index_inode(struct inode *base_vi,\n\t\tstruct inode *vi);\n\nstatic int ntfs_read_locked_inode(struct inode *vi)\n{\n\tntfs_volume *vol = NTFS_SB(vi->i_sb);\n\tntfs_inode *ni;\n\tstruct inode *bvi;\n\tMFT_RECORD *m;\n\tATTR_RECORD *a;\n\tSTANDARD_INFORMATION *si;\n\tntfs_attr_search_ctx *ctx;\n\tint err = 0;\n\n\tntfs_debug(\"Entering for i_ino 0x%lx.\", vi->i_ino);\n\n\t/* Setup the generic vfs inode parts now. */\n\n\t/*\n\t * This is for checking whether an inode has changed w.r.t. a file so\n\t * that the file can be updated if necessary (compare with f_version).\n\t */\n\tvi->i_version = 1;\n\n\tvi->i_uid = vol->uid;\n\tvi->i_gid = vol->gid;\n\tvi->i_mode = 0;\n\n\t/*\n\t * Initialize the ntfs specific part of @vi special casing\n\t * FILE_MFT which we need to do at mount time.\n\t */\n\tif (vi->i_ino != FILE_MFT)\n\t\tntfs_init_big_inode(vi);\n\tni = NTFS_I(vi);\n\n\tm = map_mft_record(ni);\n\tif (IS_ERR(m)) {\n\t\terr = PTR_ERR(m);\n\t\tgoto err_out;\n\t}\n\tctx = ntfs_attr_get_search_ctx(ni, m);\n\tif (!ctx) {\n\t\terr = -ENOMEM;\n\t\tgoto unm_err_out;\n\t}\n\n\tif (!(m->flags & MFT_RECORD_IN_USE)) {\n\t\tntfs_error(vi->i_sb, \"Inode is not in use!\");\n\t\tgoto unm_err_out;\n\t}\n\tif (m->base_mft_record) {\n\t\tntfs_error(vi->i_sb, \"Inode is an extent inode!\");\n\t\tgoto unm_err_out;\n\t}\n\n\t/* Transfer information from mft record into vfs and ntfs inodes. */\n\tvi->i_generation = ni->seq_no = le16_to_cpu(m->sequence_number);\n\n\t/*\n\t * FIXME: Keep in mind that link_count is two for files which have both\n\t * a long file name and a short file name as separate entries, so if\n\t * we are hiding short file names this will be too high. Either we need\n\t * to account for the short file names by subtracting them or we need\n\t * to make sure we delete files even though i_nlink is not zero which\n\t * might be tricky due to vfs interactions. Need to think about this\n\t * some more when implementing the unlink command.\n\t */\n\tset_nlink(vi, le16_to_cpu(m->link_count));\n\t/*\n\t * FIXME: Reparse points can have the directory bit set even though\n\t * they would be S_IFLNK. Need to deal with this further below when we\n\t * implement reparse points / symbolic links but it will do for now.\n\t * Also if not a directory, it could be something else, rather than\n\t * a regular file. But again, will do for now.\n\t */\n\t/* Everyone gets all permissions. */\n\tvi->i_mode |= S_IRWXUGO;\n\t/* If read-only, no one gets write permissions. */\n\tif (IS_RDONLY(vi))\n\t\tvi->i_mode &= ~S_IWUGO;\n\tif (m->flags & MFT_RECORD_IS_DIRECTORY) {\n\t\tvi->i_mode |= S_IFDIR;\n\t\t/*\n\t\t * Apply the directory permissions mask set in the mount\n\t\t * options.\n\t\t */\n\t\tvi->i_mode &= ~vol->dmask;\n\t\t/* Things break without this kludge! */\n\t\tif (vi->i_nlink > 1)\n\t\t\tset_nlink(vi, 1);\n\t} else {\n\t\tvi->i_mode |= S_IFREG;\n\t\t/* Apply the file permissions mask set in the mount options. */\n\t\tvi->i_mode &= ~vol->fmask;\n\t}\n\t/*\n\t * Find the standard information attribute in the mft record. At this\n\t * stage we haven't setup the attribute list stuff yet, so this could\n\t * in fact fail if the standard information is in an extent record, but\n\t * I don't think this actually ever happens.\n\t */\n\terr = ntfs_attr_lookup(AT_STANDARD_INFORMATION, NULL, 0, 0, 0, NULL, 0,\n\t\t\tctx);\n\tif (unlikely(err)) {\n\t\tif (err == -ENOENT) {\n\t\t\t/*\n\t\t\t * TODO: We should be performing a hot fix here (if the\n\t\t\t * recover mount option is set) by creating a new\n\t\t\t * attribute.\n\t\t\t */\n\t\t\tntfs_error(vi->i_sb, \"$STANDARD_INFORMATION attribute \"\n\t\t\t\t\t\"is missing.\");\n\t\t}\n\t\tgoto unm_err_out;\n\t}\n\ta = ctx->attr;\n\t/* Get the standard information attribute value. */\n\tsi = (STANDARD_INFORMATION*)((u8*)a +\n\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\n\t/* Transfer information from the standard information into vi. */\n\t/*\n\t * Note: The i_?times do not quite map perfectly onto the NTFS times,\n\t * but they are close enough, and in the end it doesn't really matter\n\t * that much...\n\t */\n\t/*\n\t * mtime is the last change of the data within the file. Not changed\n\t * when only metadata is changed, e.g. a rename doesn't affect mtime.\n\t */\n\tvi->i_mtime = ntfs2utc(si->last_data_change_time);\n\t/*\n\t * ctime is the last change of the metadata of the file. This obviously\n\t * always changes, when mtime is changed. ctime can be changed on its\n\t * own, mtime is then not changed, e.g. when a file is renamed.\n\t */\n\tvi->i_ctime = ntfs2utc(si->last_mft_change_time);\n\t/*\n\t * Last access to the data within the file. Not changed during a rename\n\t * for example but changed whenever the file is written to.\n\t */\n\tvi->i_atime = ntfs2utc(si->last_access_time);\n\n\t/* Find the attribute list attribute if present. */\n\tntfs_attr_reinit_search_ctx(ctx);\n\terr = ntfs_attr_lookup(AT_ATTRIBUTE_LIST, NULL, 0, 0, 0, NULL, 0, ctx);\n\tif (err) {\n\t\tif (unlikely(err != -ENOENT)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to lookup attribute list \"\n\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t} else /* if (!err) */ {\n\t\tif (vi->i_ino == FILE_MFT)\n\t\t\tgoto skip_attr_list_load;\n\t\tntfs_debug(\"Attribute list found in inode 0x%lx.\", vi->i_ino);\n\t\tNInoSetAttrList(ni);\n\t\ta = ctx->attr;\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"Attribute list attribute is \"\n\t\t\t\t\t\"compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED ||\n\t\t\t\ta->flags & ATTR_IS_SPARSE) {\n\t\t\tif (a->non_resident) {\n\t\t\t\tntfs_error(vi->i_sb, \"Non-resident attribute \"\n\t\t\t\t\t\t\"list attribute is encrypted/\"\n\t\t\t\t\t\t\"sparse.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tntfs_warning(vi->i_sb, \"Resident attribute list \"\n\t\t\t\t\t\"attribute in inode 0x%lx is marked \"\n\t\t\t\t\t\"encrypted/sparse which is not true.  \"\n\t\t\t\t\t\"However, Windows allows this and \"\n\t\t\t\t\t\"chkdsk does not detect or correct it \"\n\t\t\t\t\t\"so we will just ignore the invalid \"\n\t\t\t\t\t\"flags and pretend they are not set.\",\n\t\t\t\t\tvi->i_ino);\n\t\t}\n\t\t/* Now allocate memory for the attribute list. */\n\t\tni->attr_list_size = (u32)ntfs_attr_size(a);\n\t\tni->attr_list = ntfs_malloc_nofs(ni->attr_list_size);\n\t\tif (!ni->attr_list) {\n\t\t\tntfs_error(vi->i_sb, \"Not enough memory to allocate \"\n\t\t\t\t\t\"buffer for attribute list.\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetAttrListNonResident(ni);\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"Attribute list has non \"\n\t\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Setup the runlist. No need for locking as we have\n\t\t\t * exclusive access to the inode at this time.\n\t\t\t */\n\t\t\tni->attr_list_rl.rl = ntfs_mapping_pairs_decompress(vol,\n\t\t\t\t\ta, NULL);\n\t\t\tif (IS_ERR(ni->attr_list_rl.rl)) {\n\t\t\t\terr = PTR_ERR(ni->attr_list_rl.rl);\n\t\t\t\tni->attr_list_rl.rl = NULL;\n\t\t\t\tntfs_error(vi->i_sb, \"Mapping pairs \"\n\t\t\t\t\t\t\"decompression failed.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now load the attribute list. */\n\t\t\tif ((err = load_attribute_list(vol, &ni->attr_list_rl,\n\t\t\t\t\tni->attr_list, ni->attr_list_size,\n\t\t\t\t\tsle64_to_cpu(a->data.non_resident.\n\t\t\t\t\tinitialized_size)))) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to load \"\n\t\t\t\t\t\t\"attribute list attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t} else /* if (!a->non_resident) */ {\n\t\t\tif ((u8*)a + le16_to_cpu(a->data.resident.value_offset)\n\t\t\t\t\t+ le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length) >\n\t\t\t\t\t(u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Corrupt attribute list \"\n\t\t\t\t\t\t\"in inode.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/* Now copy the attribute list. */\n\t\t\tmemcpy(ni->attr_list, (u8*)a + le16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset),\n\t\t\t\t\tle32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length));\n\t\t}\n\t}\nskip_attr_list_load:\n\t/*\n\t * If an attribute list is present we now have the attribute list value\n\t * in ntfs_ino->attr_list and it is ntfs_ino->attr_list_size bytes.\n\t */\n\tif (S_ISDIR(vi->i_mode)) {\n\t\tloff_t bvi_size;\n\t\tntfs_inode *bni;\n\t\tINDEX_ROOT *ir;\n\t\tu8 *ir_end, *index_end;\n\n\t\t/* It is a directory, find index root attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ROOT, I30, 4, CASE_SENSITIVE,\n\t\t\t\t0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t// FIXME: File is corrupt! Hot-fix with empty\n\t\t\t\t// index root attribute if recovery option is\n\t\t\t\t// set.\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute \"\n\t\t\t\t\t\t\"is missing.\");\n\t\t\t}\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Set up the state. */\n\t\tif (unlikely(a->non_resident)) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute is not \"\n\t\t\t\t\t\"resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/* Ensure the attribute name is placed before the value. */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ROOT attribute name is \"\n\t\t\t\t\t\"placed after the attribute value.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Compressed/encrypted index root just means that the newly\n\t\t * created files in that directory should be created compressed/\n\t\t * encrypted. However index root cannot be both compressed and\n\t\t * encrypted.\n\t\t */\n\t\tif (a->flags & ATTR_COMPRESSION_MASK)\n\t\t\tNInoSetCompressed(ni);\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\tNInoSetSparse(ni);\n\t\tir = (INDEX_ROOT*)((u8*)a +\n\t\t\t\tle16_to_cpu(a->data.resident.value_offset));\n\t\tir_end = (u8*)ir + le32_to_cpu(a->data.resident.value_length);\n\t\tif (ir_end > (u8*)ctx->mrec + vol->mft_record_size) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ROOT attribute is \"\n\t\t\t\t\t\"corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tindex_end = (u8*)&ir->index +\n\t\t\t\tle32_to_cpu(ir->index.index_length);\n\t\tif (index_end > ir_end) {\n\t\t\tntfs_error(vi->i_sb, \"Directory index is corrupt.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->type != AT_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Indexed attribute is not \"\n\t\t\t\t\t\"$FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ir->collation_rule != COLLATION_FILE_NAME) {\n\t\t\tntfs_error(vi->i_sb, \"Index collation rule is not \"\n\t\t\t\t\t\"COLLATION_FILE_NAME.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.collation_rule = ir->collation_rule;\n\t\tni->itype.index.block_size = le32_to_cpu(ir->index_block_size);\n\t\tif (ni->itype.index.block_size &\n\t\t\t\t(ni->itype.index.block_size - 1)) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) is not a \"\n\t\t\t\t\t\"power of two.\",\n\t\t\t\t\tni->itype.index.block_size);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size > PAGE_CACHE_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) > \"\n\t\t\t\t\t\"PAGE_CACHE_SIZE (%ld) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tPAGE_CACHE_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (ni->itype.index.block_size < NTFS_BLOCK_SIZE) {\n\t\t\tntfs_error(vi->i_sb, \"Index block size (%u) < \"\n\t\t\t\t\t\"NTFS_BLOCK_SIZE (%i) is not \"\n\t\t\t\t\t\"supported.  Sorry.\",\n\t\t\t\t\tni->itype.index.block_size,\n\t\t\t\t\tNTFS_BLOCK_SIZE);\n\t\t\terr = -EOPNOTSUPP;\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tni->itype.index.block_size_bits =\n\t\t\t\tffs(ni->itype.index.block_size) - 1;\n\t\t/* Determine the size of a vcn in the directory index. */\n\t\tif (vol->cluster_size <= ni->itype.index.block_size) {\n\t\t\tni->itype.index.vcn_size = vol->cluster_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->cluster_size_bits;\n\t\t} else {\n\t\t\tni->itype.index.vcn_size = vol->sector_size;\n\t\t\tni->itype.index.vcn_size_bits = vol->sector_size_bits;\n\t\t}\n\n\t\t/* Setup the index allocation attribute, even if not present. */\n\t\tNInoSetMstProtected(ni);\n\t\tni->type = AT_INDEX_ALLOCATION;\n\t\tni->name = I30;\n\t\tni->name_len = 4;\n\n\t\tif (!(ir->index.flags & LARGE_INDEX)) {\n\t\t\t/* No index allocation. */\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\t/* We are done with the mft record, so we release it. */\n\t\t\tntfs_attr_put_search_ctx(ctx);\n\t\t\tunmap_mft_record(ni);\n\t\t\tm = NULL;\n\t\t\tctx = NULL;\n\t\t\tgoto skip_large_dir_stuff;\n\t\t} /* LARGE_INDEX: Index allocation present. Setup state. */\n\t\tNInoSetIndexAllocPresent(ni);\n\t\t/* Find index allocation attribute. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\t\terr = ntfs_attr_lookup(AT_INDEX_ALLOCATION, I30, 4,\n\t\t\t\tCASE_SENSITIVE, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tif (err == -ENOENT)\n\t\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute is not present but \"\n\t\t\t\t\t\t\"$INDEX_ROOT indicated it is.\");\n\t\t\telse\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup \"\n\t\t\t\t\t\t\"$INDEX_ALLOCATION \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\tif (!a->non_resident) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is resident.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\t/*\n\t\t * Ensure the attribute name is placed before the mapping pairs\n\t\t * array.\n\t\t */\n\t\tif (unlikely(a->name_length && (le16_to_cpu(a->name_offset) >=\n\t\t\t\tle16_to_cpu(\n\t\t\t\ta->data.non_resident.mapping_pairs_offset)))) {\n\t\t\tntfs_error(vol->sb, \"$INDEX_ALLOCATION attribute name \"\n\t\t\t\t\t\"is placed after the mapping pairs \"\n\t\t\t\t\t\"array.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is encrypted.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_IS_SPARSE) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is sparse.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\tntfs_error(vi->i_sb, \"$INDEX_ALLOCATION attribute \"\n\t\t\t\t\t\"is compressed.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\tntfs_error(vi->i_sb, \"First extent of \"\n\t\t\t\t\t\"$INDEX_ALLOCATION attribute has non \"\n\t\t\t\t\t\"zero lowest_vcn.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tvi->i_size = sle64_to_cpu(a->data.non_resident.data_size);\n\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.initialized_size);\n\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\ta->data.non_resident.allocated_size);\n\t\t/*\n\t\t * We are done with the mft record, so we release it. Otherwise\n\t\t * we would deadlock in ntfs_attr_iget().\n\t\t */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Get the index bitmap attribute inode. */\n\t\tbvi = ntfs_attr_iget(vi, AT_BITMAP, I30, 4);\n\t\tif (IS_ERR(bvi)) {\n\t\t\tntfs_error(vi->i_sb, \"Failed to get bitmap attribute.\");\n\t\t\terr = PTR_ERR(bvi);\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\tbni = NTFS_I(bvi);\n\t\tif (NInoCompressed(bni) || NInoEncrypted(bni) ||\n\t\t\t\tNInoSparse(bni)) {\n\t\t\tntfs_error(vi->i_sb, \"$BITMAP attribute is compressed \"\n\t\t\t\t\t\"and/or encrypted and/or sparse.\");\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* Consistency check bitmap size vs. index allocation size. */\n\t\tbvi_size = i_size_read(bvi);\n\t\tif ((bvi_size << 3) < (vi->i_size >>\n\t\t\t\tni->itype.index.block_size_bits)) {\n\t\t\tntfs_error(vi->i_sb, \"Index bitmap too small (0x%llx) \"\n\t\t\t\t\t\"for index allocation (0x%llx).\",\n\t\t\t\t\tbvi_size << 3, vi->i_size);\n\t\t\tgoto iput_unm_err_out;\n\t\t}\n\t\t/* No longer need the bitmap attribute inode. */\n\t\tiput(bvi);\nskip_large_dir_stuff:\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_dir_inode_ops;\n\t\tvi->i_fop = &ntfs_dir_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t} else {\n\t\t/* It is a file. */\n\t\tntfs_attr_reinit_search_ctx(ctx);\n\n\t\t/* Setup the data attribute, even if not present. */\n\t\tni->type = AT_DATA;\n\t\tni->name = NULL;\n\t\tni->name_len = 0;\n\n\t\t/* Find first extent of the unnamed data attribute. */\n\t\terr = ntfs_attr_lookup(AT_DATA, NULL, 0, 0, 0, NULL, 0, ctx);\n\t\tif (unlikely(err)) {\n\t\t\tvi->i_size = ni->initialized_size =\n\t\t\t\t\tni->allocated_size = 0;\n\t\t\tif (err != -ENOENT) {\n\t\t\t\tntfs_error(vi->i_sb, \"Failed to lookup $DATA \"\n\t\t\t\t\t\t\"attribute.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\t/*\n\t\t\t * FILE_Secure does not have an unnamed $DATA\n\t\t\t * attribute, so we special case it here.\n\t\t\t */\n\t\t\tif (vi->i_ino == FILE_Secure)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t/*\n\t\t\t * Most if not all the system files in the $Extend\n\t\t\t * system directory do not have unnamed data\n\t\t\t * attributes so we need to check if the parent\n\t\t\t * directory of the file is FILE_Extend and if it is\n\t\t\t * ignore this error. To do this we need to get the\n\t\t\t * name of this inode from the mft record as the name\n\t\t\t * contains the back reference to the parent directory.\n\t\t\t */\n\t\t\tif (ntfs_is_extended_system_file(ctx) > 0)\n\t\t\t\tgoto no_data_attr_special_case;\n\t\t\t// FIXME: File is corrupt! Hot-fix with empty data\n\t\t\t// attribute if recovery option is set.\n\t\t\tntfs_error(vi->i_sb, \"$DATA attribute is missing.\");\n\t\t\tgoto unm_err_out;\n\t\t}\n\t\ta = ctx->attr;\n\t\t/* Setup the state. */\n\t\tif (a->flags & (ATTR_COMPRESSION_MASK | ATTR_IS_SPARSE)) {\n\t\t\tif (a->flags & ATTR_COMPRESSION_MASK) {\n\t\t\t\tNInoSetCompressed(ni);\n\t\t\t\tif (vol->cluster_size > 4096) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"compressed data but \"\n\t\t\t\t\t\t\t\"compression is \"\n\t\t\t\t\t\t\t\"disabled due to \"\n\t\t\t\t\t\t\t\"cluster size (%i) > \"\n\t\t\t\t\t\t\t\"4kiB.\",\n\t\t\t\t\t\t\tvol->cluster_size);\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif ((a->flags & ATTR_COMPRESSION_MASK)\n\t\t\t\t\t\t!= ATTR_IS_COMPRESSED) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found unknown \"\n\t\t\t\t\t\t\t\"compression method \"\n\t\t\t\t\t\t\t\"or corrupt file.\");\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (a->flags & ATTR_IS_SPARSE)\n\t\t\t\tNInoSetSparse(ni);\n\t\t}\n\t\tif (a->flags & ATTR_IS_ENCRYPTED) {\n\t\t\tif (NInoCompressed(ni)) {\n\t\t\t\tntfs_error(vi->i_sb, \"Found encrypted and \"\n\t\t\t\t\t\t\"compressed data.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tNInoSetEncrypted(ni);\n\t\t}\n\t\tif (a->non_resident) {\n\t\t\tNInoSetNonResident(ni);\n\t\t\tif (NInoCompressed(ni) || NInoSparse(ni)) {\n\t\t\t\tif (NInoCompressed(ni) && a->data.non_resident.\n\t\t\t\t\t\tcompression_unit != 4) {\n\t\t\t\t\tntfs_error(vi->i_sb, \"Found \"\n\t\t\t\t\t\t\t\"non-standard \"\n\t\t\t\t\t\t\t\"compression unit (%u \"\n\t\t\t\t\t\t\t\"instead of 4).  \"\n\t\t\t\t\t\t\t\"Cannot handle this.\",\n\t\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit);\n\t\t\t\t\terr = -EOPNOTSUPP;\n\t\t\t\t\tgoto unm_err_out;\n\t\t\t\t}\n\t\t\t\tif (a->data.non_resident.compression_unit) {\n\t\t\t\t\tni->itype.compressed.block_size = 1U <<\n\t\t\t\t\t\t\t(a->data.non_resident.\n\t\t\t\t\t\t\tcompression_unit +\n\t\t\t\t\t\t\tvol->cluster_size_bits);\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\tffs(ni->itype.\n\t\t\t\t\t\t\tcompressed.\n\t\t\t\t\t\t\tblock_size) - 1;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t1U << a->data.\n\t\t\t\t\t\t\tnon_resident.\n\t\t\t\t\t\t\tcompression_unit;\n\t\t\t\t} else {\n\t\t\t\t\tni->itype.compressed.block_size = 0;\n\t\t\t\t\tni->itype.compressed.block_size_bits =\n\t\t\t\t\t\t\t0;\n\t\t\t\t\tni->itype.compressed.block_clusters =\n\t\t\t\t\t\t\t0;\n\t\t\t\t}\n\t\t\t\tni->itype.compressed.size = sle64_to_cpu(\n\t\t\t\t\t\ta->data.non_resident.\n\t\t\t\t\t\tcompressed_size);\n\t\t\t}\n\t\t\tif (a->data.non_resident.lowest_vcn) {\n\t\t\t\tntfs_error(vi->i_sb, \"First extent of $DATA \"\n\t\t\t\t\t\t\"attribute has non zero \"\n\t\t\t\t\t\t\"lowest_vcn.\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t\tvi->i_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.data_size);\n\t\t\tni->initialized_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.initialized_size);\n\t\t\tni->allocated_size = sle64_to_cpu(\n\t\t\t\t\ta->data.non_resident.allocated_size);\n\t\t} else { /* Resident attribute. */\n\t\t\tvi->i_size = ni->initialized_size = le32_to_cpu(\n\t\t\t\t\ta->data.resident.value_length);\n\t\t\tni->allocated_size = le32_to_cpu(a->length) -\n\t\t\t\t\tle16_to_cpu(\n\t\t\t\t\ta->data.resident.value_offset);\n\t\t\tif (vi->i_size > ni->allocated_size) {\n\t\t\t\tntfs_error(vi->i_sb, \"Resident data attribute \"\n\t\t\t\t\t\t\"is corrupt (size exceeds \"\n\t\t\t\t\t\t\"allocation).\");\n\t\t\t\tgoto unm_err_out;\n\t\t\t}\n\t\t}\nno_data_attr_special_case:\n\t\t/* We are done with the mft record, so we release it. */\n\t\tntfs_attr_put_search_ctx(ctx);\n\t\tunmap_mft_record(ni);\n\t\tm = NULL;\n\t\tctx = NULL;\n\t\t/* Setup the operations for this inode. */\n\t\tvi->i_op = &ntfs_file_inode_ops;\n\t\tvi->i_fop = &ntfs_file_ops;\n\t\tvi->i_mapping->a_ops = &ntfs_normal_aops;\n\t\tif (NInoMstProtected(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_mst_aops;\n\t\telse if (NInoCompressed(ni))\n\t\t\tvi->i_mapping->a_ops = &ntfs_compressed_aops;\n\t}\n\t/*\n\t * The number of 512-byte blocks used on disk (for stat). This is in so\n\t * far inaccurate as it doesn't account for any named streams or other\n\t * special non-resident attributes, but that is how Windows works, too,\n\t * so we are at least consistent with Windows, if not entirely\n\t * consistent with the Linux Way. Doing it the Linux Way would cause a\n\t * significant slowdown as it would involve iterating over all\n\t * attributes in the mft record and adding the allocated/compressed\n\t * sizes of all non-resident attributes present to give us the Linux\n\t * correct size that should go into i_blocks (after division by 512).\n\t */\n\tif (S_ISREG(vi->i_mode) && (NInoCompressed(ni) || NInoSparse(ni)))\n\t\tvi->i_blocks = ni->itype.compressed.size >> 9;\n\telse\n\t\tvi->i_blocks = ni->allocated_size >> 9;\n\tntfs_debug(\"Done.\");\n\treturn 0;\niput_unm_err_out:\n\tiput(bvi);\nunm_err_out:\n\tif (!err)\n\t\terr = -EIO;\n\tif (ctx)\n\t\tntfs_attr_put_search_ctx(ctx);\n\tif (m)\n\t\tunmap_mft_record(ni);\nerr_out:\n\tntfs_error(vol->sb, \"Failed with error code %i.  Marking corrupt \"\n\t\t\t\"inode 0x%lx as bad.  Run chkdsk.\", err, vi->i_ino);\n\tmake_bad_inode(vi);\n\tif (err != -EOPNOTSUPP && err != -ENOMEM)\n\t\tNVolSetErrors(vol);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"sys.h\"\n#include \"masklog.h\"\n#include \"heartbeat.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include <linux/configfs.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\nstruct o2nm_cluster *o2nm_single_cluster = NULL;\n\nstruct o2nm_node *o2nm_get_node_by_num(u8 node_num)\n{\n\tstruct o2nm_node *node = NULL;\n\n\tif (node_num >= O2NM_MAX_NODES || o2nm_single_cluster == NULL)\n\t\tgoto out;\n\n\tread_lock(&o2nm_single_cluster->cl_nodes_lock);\n\tnode = o2nm_single_cluster->cl_nodes[node_num];\n\tif (node)\n\t\tconfig_item_get(&node->nd_item);\n\tread_unlock(&o2nm_single_cluster->cl_nodes_lock);\nout:\n\treturn node;\n}"
  }
]