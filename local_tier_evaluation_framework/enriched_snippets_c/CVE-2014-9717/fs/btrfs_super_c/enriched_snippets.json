[
  {
    "function_name": "btrfs_print_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
    "lines": "2038-2199",
    "snippet": "static void btrfs_print_info(void)\n{\n\tprintk(KERN_INFO \"Btrfs loaded\"\n#ifdef CONFIG_BTRFS_DEBUG\n\t\t\t\", debug=on\"\n#endif\n#ifdef CONFIG_BTRFS_ASSERT\n\t\t\t\", assert=on\"\n#endif\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\t\t\t\", integrity-checker=on\"\n#endif\n\t\t\t\"\\n\");\n}\n\nstatic int btrfs_run_sanity_tests(void)\n{\n\tint ret;\n\n\tret = btrfs_init_test_fs();\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_test_free_space_cache();\n\tif (ret)\n\t\tgoto out;\n\tret = btrfs_test_extent_buffer_operations();\n\tif (ret)\n\t\tgoto out;\n\tret = btrfs_test_extent_io();\n\tif (ret)\n\t\tgoto out;\n\tret = btrfs_test_inodes();\n\tif (ret)\n\t\tgoto out;\n\tret = btrfs_test_qgroups();\nout:\n\tbtrfs_destroy_test_fs();\n\treturn ret;\n}\n\nstatic int __init init_btrfs_fs(void)\n{\n\tint err;\n\n\terr = btrfs_hash_init();\n\tif (err)\n\t\treturn err;\n\n\tbtrfs_props_init();\n\n\terr = btrfs_init_sysfs();\n\tif (err)\n\t\tgoto free_hash;\n\n\tbtrfs_init_compress();\n\n\terr = btrfs_init_cachep();\n\tif (err)\n\t\tgoto free_compress;\n\n\terr = extent_io_init();\n\tif (err)\n\t\tgoto free_cachep;\n\n\terr = extent_map_init();\n\tif (err)\n\t\tgoto free_extent_io;\n\n\terr = ordered_data_init();\n\tif (err)\n\t\tgoto free_extent_map;\n\n\terr = btrfs_delayed_inode_init();\n\tif (err)\n\t\tgoto free_ordered_data;\n\n\terr = btrfs_auto_defrag_init();\n\tif (err)\n\t\tgoto free_delayed_inode;\n\n\terr = btrfs_delayed_ref_init();\n\tif (err)\n\t\tgoto free_auto_defrag;\n\n\terr = btrfs_prelim_ref_init();\n\tif (err)\n\t\tgoto free_delayed_ref;\n\n\terr = btrfs_end_io_wq_init();\n\tif (err)\n\t\tgoto free_prelim_ref;\n\n\terr = btrfs_interface_init();\n\tif (err)\n\t\tgoto free_end_io_wq;\n\n\tbtrfs_init_lockdep();\n\n\tbtrfs_print_info();\n\n\terr = btrfs_run_sanity_tests();\n\tif (err)\n\t\tgoto unregister_ioctl;\n\n\terr = register_filesystem(&btrfs_fs_type);\n\tif (err)\n\t\tgoto unregister_ioctl;\n\n\treturn 0;\n\nunregister_ioctl:\n\tbtrfs_interface_exit();\nfree_end_io_wq:\n\tbtrfs_end_io_wq_exit();\nfree_prelim_ref:\n\tbtrfs_prelim_ref_exit();\nfree_delayed_ref:\n\tbtrfs_delayed_ref_exit();\nfree_auto_defrag:\n\tbtrfs_auto_defrag_exit();\nfree_delayed_inode:\n\tbtrfs_delayed_inode_exit();\nfree_ordered_data:\n\tordered_data_exit();\nfree_extent_map:\n\textent_map_exit();\nfree_extent_io:\n\textent_io_exit();\nfree_cachep:\n\tbtrfs_destroy_cachep();\nfree_compress:\n\tbtrfs_exit_compress();\n\tbtrfs_exit_sysfs();\nfree_hash:\n\tbtrfs_hash_exit();\n\treturn err;\n}\n\nstatic void __exit exit_btrfs_fs(void)\n{\n\tbtrfs_destroy_cachep();\n\tbtrfs_delayed_ref_exit();\n\tbtrfs_auto_defrag_exit();\n\tbtrfs_delayed_inode_exit();\n\tbtrfs_prelim_ref_exit();\n\tordered_data_exit();\n\textent_map_exit();\n\textent_io_exit();\n\tbtrfs_interface_exit();\n\tbtrfs_end_io_wq_exit();\n\tunregister_filesystem(&btrfs_fs_type);\n\tbtrfs_exit_sysfs();\n\tbtrfs_cleanup_fs_uuids();\n\tbtrfs_exit_compress();\n\tbtrfs_hash_exit();\n}\n\nlate_initcall(init_btrfs_fs);\nmodule_exit(exit_btrfs_fs)\n\nMODULE_LICENSE(\"GPL\");",
    "includes": [
      "#include <trace/events/btrfs.h>",
      "#include \"qgroup.h\"",
      "#include \"tests/btrfs-tests.h\"",
      "#include \"backref.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"compression.h\"",
      "#include \"export.h\"",
      "#include \"volumes.h\"",
      "#include \"xattr.h\"",
      "#include \"props.h\"",
      "#include \"hash.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/namei.h>",
      "#include <linux/ctype.h>",
      "#include <linux/parser.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type btrfs_fs_type;",
      "static struct file_system_type btrfs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"btrfs\",\n\t.mount\t\t= btrfs_mount,\n\t.kill_sb\t= btrfs_kill_super,\n\t.fs_flags\t= FS_REQUIRES_DEV | FS_BINARY_MOUNTDATA,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "late_initcall",
          "args": [
            "init_btrfs_fs"
          ],
          "line": 2196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_hash_exit",
          "args": [],
          "line": 2193
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_hash_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/hash.c",
          "lines": "27-30",
          "snippet": "void btrfs_hash_exit(void)\n{\n\tcrypto_free_shash(tfm);\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include <linux/err.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct crypto_shash *tfm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include <linux/err.h>\n#include <crypto/hash.h>\n\nstatic struct crypto_shash *tfm;\n\nvoid btrfs_hash_exit(void)\n{\n\tcrypto_free_shash(tfm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_exit_compress",
          "args": [],
          "line": 2192
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_exit_compress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/compression.c",
          "lines": "965-968",
          "snippet": "void btrfs_exit_compress(void)\n{\n\tfree_workspaces();\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include \"compression.h\"",
            "#include \"ordered-data.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include \"compression.h\"\n#include \"ordered-data.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/bit_spinlock.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nvoid btrfs_exit_compress(void)\n{\n\tfree_workspaces();\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_cleanup_fs_uuids",
          "args": [],
          "line": 2191
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_cleanup_fs_uuids",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "126-136",
          "snippet": "void btrfs_cleanup_fs_uuids(void)\n{\n\tstruct btrfs_fs_devices *fs_devices;\n\n\twhile (!list_empty(&fs_uuids)) {\n\t\tfs_devices = list_entry(fs_uuids.next,\n\t\t\t\t\tstruct btrfs_fs_devices, list);\n\t\tlist_del(&fs_devices->list);\n\t\tfree_fs_devices(fs_devices);\n\t}\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(fs_uuids);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic LIST_HEAD(fs_uuids);\nstatic noinline struct;\nstatic noinline struct;\n\nvoid btrfs_cleanup_fs_uuids(void)\n{\n\tstruct btrfs_fs_devices *fs_devices;\n\n\twhile (!list_empty(&fs_uuids)) {\n\t\tfs_devices = list_entry(fs_uuids.next,\n\t\t\t\t\tstruct btrfs_fs_devices, list);\n\t\tlist_del(&fs_devices->list);\n\t\tfree_fs_devices(fs_devices);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_exit_sysfs",
          "args": [],
          "line": 2190
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_exit_sysfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/sysfs.c",
          "lines": "752-757",
          "snippet": "void btrfs_exit_sysfs(void)\n{\n\tsysfs_remove_group(&btrfs_kset->kobj, &btrfs_feature_attr_group);\n\tkset_unregister(btrfs_kset);\n\tdebugfs_remove_recursive(btrfs_debugfs_root_dentry);\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"sysfs.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bug.h>",
            "#include <linux/kobject.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline struct btrfs_fs_info *to_fs_info(struct kobject *kobj);",
            "static const struct attribute_group btrfs_feature_attr_group = {\n\t.name = \"features\",\n\t.is_visible = btrfs_feature_visible,\n\t.attrs = btrfs_supported_feature_attrs,\n};",
            "static struct kset *btrfs_kset;",
            "static struct dentry *btrfs_debugfs_root_dentry;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"sysfs.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/debugfs.h>\n#include <linux/genhd.h>\n#include <linux/bug.h>\n#include <linux/kobject.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic inline struct btrfs_fs_info *to_fs_info(struct kobject *kobj);\nstatic const struct attribute_group btrfs_feature_attr_group = {\n\t.name = \"features\",\n\t.is_visible = btrfs_feature_visible,\n\t.attrs = btrfs_supported_feature_attrs,\n};\nstatic struct kset *btrfs_kset;\nstatic struct dentry *btrfs_debugfs_root_dentry;\n\nvoid btrfs_exit_sysfs(void)\n{\n\tsysfs_remove_group(&btrfs_kset->kobj, &btrfs_feature_attr_group);\n\tkset_unregister(btrfs_kset);\n\tdebugfs_remove_recursive(btrfs_debugfs_root_dentry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_filesystem",
          "args": [
            "&btrfs_fs_type"
          ],
          "line": 2189
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_end_io_wq_exit",
          "args": [],
          "line": 2188
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_end_io_wq_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "104-108",
          "snippet": "void btrfs_end_io_wq_exit(void)\n{\n\tif (btrfs_end_io_wq_cache)\n\t\tkmem_cache_destroy(btrfs_end_io_wq_cache);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *btrfs_end_io_wq_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *btrfs_end_io_wq_cache;\n\nvoid btrfs_end_io_wq_exit(void)\n{\n\tif (btrfs_end_io_wq_cache)\n\t\tkmem_cache_destroy(btrfs_end_io_wq_cache);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_interface_exit",
          "args": [],
          "line": 2187
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_interface_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "2032-2036",
          "snippet": "static void btrfs_interface_exit(void)\n{\n\tif (misc_deregister(&btrfs_misc) < 0)\n\t\tprintk(KERN_INFO \"BTRFS: misc_deregister failed for control device\\n\");\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct miscdevice btrfs_misc = {\n\t.minor\t\t= BTRFS_MINOR,\n\t.name\t\t= \"btrfs-control\",\n\t.fops\t\t= &btrfs_ctl_fops\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nstatic struct miscdevice btrfs_misc = {\n\t.minor\t\t= BTRFS_MINOR,\n\t.name\t\t= \"btrfs-control\",\n\t.fops\t\t= &btrfs_ctl_fops\n};\n\nstatic void btrfs_interface_exit(void)\n{\n\tif (misc_deregister(&btrfs_misc) < 0)\n\t\tprintk(KERN_INFO \"BTRFS: misc_deregister failed for control device\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "extent_io_exit",
          "args": [],
          "line": 2186
        },
        "resolved": true,
        "details": {
          "function_name": "extent_io_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "181-196",
          "snippet": "void extent_io_exit(void)\n{\n\tbtrfs_leak_debug_check();\n\n\t/*\n\t * Make sure all delayed rcu free are flushed before we\n\t * destroy caches.\n\t */\n\trcu_barrier();\n\tif (extent_state_cache)\n\t\tkmem_cache_destroy(extent_state_cache);\n\tif (extent_buffer_cache)\n\t\tkmem_cache_destroy(extent_buffer_cache);\n\tif (btrfs_bioset)\n\t\tbioset_free(btrfs_bioset);\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_state_cache;",
            "static struct kmem_cache *extent_buffer_cache;",
            "static struct bio_set *btrfs_bioset;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct kmem_cache *extent_state_cache;\nstatic struct kmem_cache *extent_buffer_cache;\nstatic struct bio_set *btrfs_bioset;\n\nvoid extent_io_exit(void)\n{\n\tbtrfs_leak_debug_check();\n\n\t/*\n\t * Make sure all delayed rcu free are flushed before we\n\t * destroy caches.\n\t */\n\trcu_barrier();\n\tif (extent_state_cache)\n\t\tkmem_cache_destroy(extent_state_cache);\n\tif (extent_buffer_cache)\n\t\tkmem_cache_destroy(extent_buffer_cache);\n\tif (btrfs_bioset)\n\t\tbioset_free(btrfs_bioset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "extent_map_exit",
          "args": [],
          "line": 2185
        },
        "resolved": true,
        "details": {
          "function_name": "extent_map_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "21-25",
          "snippet": "void extent_map_exit(void)\n{\n\tif (extent_map_cache)\n\t\tkmem_cache_destroy(extent_map_cache);\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_map_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic struct kmem_cache *extent_map_cache;\n\nvoid extent_map_exit(void)\n{\n\tif (extent_map_cache)\n\t\tkmem_cache_destroy(extent_map_cache);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ordered_data_exit",
          "args": [],
          "line": 2184
        },
        "resolved": true,
        "details": {
          "function_name": "ordered_data_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "1041-1045",
          "snippet": "void ordered_data_exit(void)\n{\n\tif (btrfs_ordered_extent_cache)\n\t\tkmem_cache_destroy(btrfs_ordered_extent_cache);\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *btrfs_ordered_extent_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache *btrfs_ordered_extent_cache;\n\nvoid ordered_data_exit(void)\n{\n\tif (btrfs_ordered_extent_cache)\n\t\tkmem_cache_destroy(btrfs_ordered_extent_cache);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_prelim_ref_exit",
          "args": [],
          "line": 2183
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_prelim_ref_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
          "lines": "149-153",
          "snippet": "void btrfs_prelim_ref_exit(void)\n{\n\tif (btrfs_prelim_ref_cache)\n\t\tkmem_cache_destroy(btrfs_prelim_ref_cache);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"transaction.h\"",
            "#include \"ulist.h\"",
            "#include \"backref.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *btrfs_prelim_ref_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nstatic struct kmem_cache *btrfs_prelim_ref_cache;\n\nvoid btrfs_prelim_ref_exit(void)\n{\n\tif (btrfs_prelim_ref_cache)\n\t\tkmem_cache_destroy(btrfs_prelim_ref_cache);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_delayed_inode_exit",
          "args": [],
          "line": 2182
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_delayed_inode_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "44-48",
          "snippet": "void btrfs_delayed_inode_exit(void)\n{\n\tif (delayed_node_cache)\n\t\tkmem_cache_destroy(delayed_node_cache);\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *delayed_node_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic struct kmem_cache *delayed_node_cache;\n\nvoid btrfs_delayed_inode_exit(void)\n{\n\tif (delayed_node_cache)\n\t\tkmem_cache_destroy(delayed_node_cache);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_auto_defrag_exit",
          "args": [],
          "line": 2181
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_auto_defrag_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
          "lines": "2825-2829",
          "snippet": "void btrfs_auto_defrag_exit(void)\n{\n\tif (btrfs_inode_defrag_cachep)\n\t\tkmem_cache_destroy(btrfs_inode_defrag_cachep);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"volumes.h\"",
            "#include \"locking.h\"",
            "#include \"tree-log.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *btrfs_inode_defrag_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *btrfs_inode_defrag_cachep;\n\nvoid btrfs_auto_defrag_exit(void)\n{\n\tif (btrfs_inode_defrag_cachep)\n\t\tkmem_cache_destroy(btrfs_inode_defrag_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_delayed_ref_exit",
          "args": [],
          "line": 2180
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_delayed_ref_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-ref.c",
          "lines": "898-908",
          "snippet": "void btrfs_delayed_ref_exit(void)\n{\n\tif (btrfs_delayed_ref_head_cachep)\n\t\tkmem_cache_destroy(btrfs_delayed_ref_head_cachep);\n\tif (btrfs_delayed_tree_ref_cachep)\n\t\tkmem_cache_destroy(btrfs_delayed_tree_ref_cachep);\n\tif (btrfs_delayed_data_ref_cachep)\n\t\tkmem_cache_destroy(btrfs_delayed_data_ref_cachep);\n\tif (btrfs_delayed_extent_op_cachep)\n\t\tkmem_cache_destroy(btrfs_delayed_extent_op_cachep);\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"ctree.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *btrfs_delayed_ref_head_cachep;",
            "struct kmem_cache *btrfs_delayed_tree_ref_cachep;",
            "struct kmem_cache *btrfs_delayed_data_ref_cachep;",
            "struct kmem_cache *btrfs_delayed_extent_op_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"delayed-ref.h\"\n#include \"ctree.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstruct kmem_cache *btrfs_delayed_ref_head_cachep;\nstruct kmem_cache *btrfs_delayed_tree_ref_cachep;\nstruct kmem_cache *btrfs_delayed_data_ref_cachep;\nstruct kmem_cache *btrfs_delayed_extent_op_cachep;\n\nvoid btrfs_delayed_ref_exit(void)\n{\n\tif (btrfs_delayed_ref_head_cachep)\n\t\tkmem_cache_destroy(btrfs_delayed_ref_head_cachep);\n\tif (btrfs_delayed_tree_ref_cachep)\n\t\tkmem_cache_destroy(btrfs_delayed_tree_ref_cachep);\n\tif (btrfs_delayed_data_ref_cachep)\n\t\tkmem_cache_destroy(btrfs_delayed_data_ref_cachep);\n\tif (btrfs_delayed_extent_op_cachep)\n\t\tkmem_cache_destroy(btrfs_delayed_extent_op_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_destroy_cachep",
          "args": [],
          "line": 2179
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_destroy_cachep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "8808-8827",
          "snippet": "void btrfs_destroy_cachep(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tif (btrfs_inode_cachep)\n\t\tkmem_cache_destroy(btrfs_inode_cachep);\n\tif (btrfs_trans_handle_cachep)\n\t\tkmem_cache_destroy(btrfs_trans_handle_cachep);\n\tif (btrfs_transaction_cachep)\n\t\tkmem_cache_destroy(btrfs_transaction_cachep);\n\tif (btrfs_path_cachep)\n\t\tkmem_cache_destroy(btrfs_path_cachep);\n\tif (btrfs_free_space_cachep)\n\t\tkmem_cache_destroy(btrfs_free_space_cachep);\n\tif (btrfs_delalloc_work_cachep)\n\t\tkmem_cache_destroy(btrfs_delalloc_work_cachep);\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *btrfs_inode_cachep;",
            "static struct kmem_cache *btrfs_delalloc_work_cachep;",
            "struct kmem_cache *btrfs_trans_handle_cachep;",
            "struct kmem_cache *btrfs_transaction_cachep;",
            "struct kmem_cache *btrfs_path_cachep;",
            "struct kmem_cache *btrfs_free_space_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache *btrfs_inode_cachep;\nstatic struct kmem_cache *btrfs_delalloc_work_cachep;\nstruct kmem_cache *btrfs_trans_handle_cachep;\nstruct kmem_cache *btrfs_transaction_cachep;\nstruct kmem_cache *btrfs_path_cachep;\nstruct kmem_cache *btrfs_free_space_cachep;\n\nvoid btrfs_destroy_cachep(void)\n{\n\t/*\n\t * Make sure all delayed rcu free inodes are flushed before we\n\t * destroy cache.\n\t */\n\trcu_barrier();\n\tif (btrfs_inode_cachep)\n\t\tkmem_cache_destroy(btrfs_inode_cachep);\n\tif (btrfs_trans_handle_cachep)\n\t\tkmem_cache_destroy(btrfs_trans_handle_cachep);\n\tif (btrfs_transaction_cachep)\n\t\tkmem_cache_destroy(btrfs_transaction_cachep);\n\tif (btrfs_path_cachep)\n\t\tkmem_cache_destroy(btrfs_path_cachep);\n\tif (btrfs_free_space_cachep)\n\t\tkmem_cache_destroy(btrfs_free_space_cachep);\n\tif (btrfs_delalloc_work_cachep)\n\t\tkmem_cache_destroy(btrfs_delalloc_work_cachep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_run_sanity_tests",
          "args": [],
          "line": 2139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_print_info",
          "args": [],
          "line": 2137
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_print_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "2038-2199",
          "snippet": "static void btrfs_print_info(void)\n{\n\tprintk(KERN_INFO \"Btrfs loaded\"\n#ifdef CONFIG_BTRFS_DEBUG\n\t\t\t\", debug=on\"\n#endif\n#ifdef CONFIG_BTRFS_ASSERT\n\t\t\t\", assert=on\"\n#endif\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\t\t\t\", integrity-checker=on\"\n#endif\n\t\t\t\"\\n\");\n}\n\nstatic int btrfs_run_sanity_tests(void)\n{\n\tint ret;\n\n\tret = btrfs_init_test_fs();\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_test_free_space_cache();\n\tif (ret)\n\t\tgoto out;\n\tret = btrfs_test_extent_buffer_operations();\n\tif (ret)\n\t\tgoto out;\n\tret = btrfs_test_extent_io();\n\tif (ret)\n\t\tgoto out;\n\tret = btrfs_test_inodes();\n\tif (ret)\n\t\tgoto out;\n\tret = btrfs_test_qgroups();\nout:\n\tbtrfs_destroy_test_fs();\n\treturn ret;\n}\n\nstatic int __init init_btrfs_fs(void)\n{\n\tint err;\n\n\terr = btrfs_hash_init();\n\tif (err)\n\t\treturn err;\n\n\tbtrfs_props_init();\n\n\terr = btrfs_init_sysfs();\n\tif (err)\n\t\tgoto free_hash;\n\n\tbtrfs_init_compress();\n\n\terr = btrfs_init_cachep();\n\tif (err)\n\t\tgoto free_compress;\n\n\terr = extent_io_init();\n\tif (err)\n\t\tgoto free_cachep;\n\n\terr = extent_map_init();\n\tif (err)\n\t\tgoto free_extent_io;\n\n\terr = ordered_data_init();\n\tif (err)\n\t\tgoto free_extent_map;\n\n\terr = btrfs_delayed_inode_init();\n\tif (err)\n\t\tgoto free_ordered_data;\n\n\terr = btrfs_auto_defrag_init();\n\tif (err)\n\t\tgoto free_delayed_inode;\n\n\terr = btrfs_delayed_ref_init();\n\tif (err)\n\t\tgoto free_auto_defrag;\n\n\terr = btrfs_prelim_ref_init();\n\tif (err)\n\t\tgoto free_delayed_ref;\n\n\terr = btrfs_end_io_wq_init();\n\tif (err)\n\t\tgoto free_prelim_ref;\n\n\terr = btrfs_interface_init();\n\tif (err)\n\t\tgoto free_end_io_wq;\n\n\tbtrfs_init_lockdep();\n\n\tbtrfs_print_info();\n\n\terr = btrfs_run_sanity_tests();\n\tif (err)\n\t\tgoto unregister_ioctl;\n\n\terr = register_filesystem(&btrfs_fs_type);\n\tif (err)\n\t\tgoto unregister_ioctl;\n\n\treturn 0;\n\nunregister_ioctl:\n\tbtrfs_interface_exit();\nfree_end_io_wq:\n\tbtrfs_end_io_wq_exit();\nfree_prelim_ref:\n\tbtrfs_prelim_ref_exit();\nfree_delayed_ref:\n\tbtrfs_delayed_ref_exit();\nfree_auto_defrag:\n\tbtrfs_auto_defrag_exit();\nfree_delayed_inode:\n\tbtrfs_delayed_inode_exit();\nfree_ordered_data:\n\tordered_data_exit();\nfree_extent_map:\n\textent_map_exit();\nfree_extent_io:\n\textent_io_exit();\nfree_cachep:\n\tbtrfs_destroy_cachep();\nfree_compress:\n\tbtrfs_exit_compress();\n\tbtrfs_exit_sysfs();\nfree_hash:\n\tbtrfs_hash_exit();\n\treturn err;\n}\n\nstatic void __exit exit_btrfs_fs(void)\n{\n\tbtrfs_destroy_cachep();\n\tbtrfs_delayed_ref_exit();\n\tbtrfs_auto_defrag_exit();\n\tbtrfs_delayed_inode_exit();\n\tbtrfs_prelim_ref_exit();\n\tordered_data_exit();\n\textent_map_exit();\n\textent_io_exit();\n\tbtrfs_interface_exit();\n\tbtrfs_end_io_wq_exit();\n\tunregister_filesystem(&btrfs_fs_type);\n\tbtrfs_exit_sysfs();\n\tbtrfs_cleanup_fs_uuids();\n\tbtrfs_exit_compress();\n\tbtrfs_hash_exit();\n}\n\nlate_initcall(init_btrfs_fs);\nmodule_exit(exit_btrfs_fs)\n\nMODULE_LICENSE(\"GPL\");",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_init_lockdep",
          "args": [],
          "line": 2135
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_init_lockdep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.h",
          "lines": "152-153",
          "snippet": "static inline void btrfs_init_lockdep(void)\n{ }",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void btrfs_init_lockdep(void)\n{ }"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_interface_init",
          "args": [],
          "line": 2131
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_interface_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "2027-2030",
          "snippet": "static int btrfs_interface_init(void)\n{\n\treturn misc_register(&btrfs_misc);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct miscdevice btrfs_misc = {\n\t.minor\t\t= BTRFS_MINOR,\n\t.name\t\t= \"btrfs-control\",\n\t.fops\t\t= &btrfs_ctl_fops\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nstatic struct miscdevice btrfs_misc = {\n\t.minor\t\t= BTRFS_MINOR,\n\t.name\t\t= \"btrfs-control\",\n\t.fops\t\t= &btrfs_ctl_fops\n};\n\nstatic int btrfs_interface_init(void)\n{\n\treturn misc_register(&btrfs_misc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_end_io_wq_init",
          "args": [],
          "line": 2127
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_end_io_wq_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "92-102",
          "snippet": "int __init btrfs_end_io_wq_init(void)\n{\n\tbtrfs_end_io_wq_cache = kmem_cache_create(\"btrfs_end_io_wq\",\n\t\t\t\t\tsizeof(struct btrfs_end_io_wq),\n\t\t\t\t\t0,\n\t\t\t\t\tSLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD,\n\t\t\t\t\tNULL);\n\tif (!btrfs_end_io_wq_cache)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *btrfs_end_io_wq_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *btrfs_end_io_wq_cache;\n\nint __init btrfs_end_io_wq_init(void)\n{\n\tbtrfs_end_io_wq_cache = kmem_cache_create(\"btrfs_end_io_wq\",\n\t\t\t\t\tsizeof(struct btrfs_end_io_wq),\n\t\t\t\t\t0,\n\t\t\t\t\tSLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD,\n\t\t\t\t\tNULL);\n\tif (!btrfs_end_io_wq_cache)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_prelim_ref_init",
          "args": [],
          "line": 2123
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_prelim_ref_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/backref.c",
          "lines": "137-147",
          "snippet": "int __init btrfs_prelim_ref_init(void)\n{\n\tbtrfs_prelim_ref_cache = kmem_cache_create(\"btrfs_prelim_ref\",\n\t\t\t\t\tsizeof(struct __prelim_ref),\n\t\t\t\t\t0,\n\t\t\t\t\tSLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD,\n\t\t\t\t\tNULL);\n\tif (!btrfs_prelim_ref_cache)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"transaction.h\"",
            "#include \"ulist.h\"",
            "#include \"backref.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *btrfs_prelim_ref_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"delayed-ref.h\"\n#include \"transaction.h\"\n#include \"ulist.h\"\n#include \"backref.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/vmalloc.h>\n\nstatic struct kmem_cache *btrfs_prelim_ref_cache;\n\nint __init btrfs_prelim_ref_init(void)\n{\n\tbtrfs_prelim_ref_cache = kmem_cache_create(\"btrfs_prelim_ref\",\n\t\t\t\t\tsizeof(struct __prelim_ref),\n\t\t\t\t\t0,\n\t\t\t\t\tSLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD,\n\t\t\t\t\tNULL);\n\tif (!btrfs_prelim_ref_cache)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_delayed_ref_init",
          "args": [],
          "line": 2119
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_delayed_ref_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-ref.c",
          "lines": "910-944",
          "snippet": "int btrfs_delayed_ref_init(void)\n{\n\tbtrfs_delayed_ref_head_cachep = kmem_cache_create(\n\t\t\t\t\"btrfs_delayed_ref_head\",\n\t\t\t\tsizeof(struct btrfs_delayed_ref_head), 0,\n\t\t\t\tSLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD, NULL);\n\tif (!btrfs_delayed_ref_head_cachep)\n\t\tgoto fail;\n\n\tbtrfs_delayed_tree_ref_cachep = kmem_cache_create(\n\t\t\t\t\"btrfs_delayed_tree_ref\",\n\t\t\t\tsizeof(struct btrfs_delayed_tree_ref), 0,\n\t\t\t\tSLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD, NULL);\n\tif (!btrfs_delayed_tree_ref_cachep)\n\t\tgoto fail;\n\n\tbtrfs_delayed_data_ref_cachep = kmem_cache_create(\n\t\t\t\t\"btrfs_delayed_data_ref\",\n\t\t\t\tsizeof(struct btrfs_delayed_data_ref), 0,\n\t\t\t\tSLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD, NULL);\n\tif (!btrfs_delayed_data_ref_cachep)\n\t\tgoto fail;\n\n\tbtrfs_delayed_extent_op_cachep = kmem_cache_create(\n\t\t\t\t\"btrfs_delayed_extent_op\",\n\t\t\t\tsizeof(struct btrfs_delayed_extent_op), 0,\n\t\t\t\tSLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD, NULL);\n\tif (!btrfs_delayed_extent_op_cachep)\n\t\tgoto fail;\n\n\treturn 0;\nfail:\n\tbtrfs_delayed_ref_exit();\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"delayed-ref.h\"",
            "#include \"ctree.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *btrfs_delayed_ref_head_cachep;",
            "struct kmem_cache *btrfs_delayed_tree_ref_cachep;",
            "struct kmem_cache *btrfs_delayed_data_ref_cachep;",
            "struct kmem_cache *btrfs_delayed_extent_op_cachep;",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"delayed-ref.h\"\n#include \"ctree.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstruct kmem_cache *btrfs_delayed_ref_head_cachep;\nstruct kmem_cache *btrfs_delayed_tree_ref_cachep;\nstruct kmem_cache *btrfs_delayed_data_ref_cachep;\nstruct kmem_cache *btrfs_delayed_extent_op_cachep;\nstatic noinline struct;\n\nint btrfs_delayed_ref_init(void)\n{\n\tbtrfs_delayed_ref_head_cachep = kmem_cache_create(\n\t\t\t\t\"btrfs_delayed_ref_head\",\n\t\t\t\tsizeof(struct btrfs_delayed_ref_head), 0,\n\t\t\t\tSLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD, NULL);\n\tif (!btrfs_delayed_ref_head_cachep)\n\t\tgoto fail;\n\n\tbtrfs_delayed_tree_ref_cachep = kmem_cache_create(\n\t\t\t\t\"btrfs_delayed_tree_ref\",\n\t\t\t\tsizeof(struct btrfs_delayed_tree_ref), 0,\n\t\t\t\tSLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD, NULL);\n\tif (!btrfs_delayed_tree_ref_cachep)\n\t\tgoto fail;\n\n\tbtrfs_delayed_data_ref_cachep = kmem_cache_create(\n\t\t\t\t\"btrfs_delayed_data_ref\",\n\t\t\t\tsizeof(struct btrfs_delayed_data_ref), 0,\n\t\t\t\tSLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD, NULL);\n\tif (!btrfs_delayed_data_ref_cachep)\n\t\tgoto fail;\n\n\tbtrfs_delayed_extent_op_cachep = kmem_cache_create(\n\t\t\t\t\"btrfs_delayed_extent_op\",\n\t\t\t\tsizeof(struct btrfs_delayed_extent_op), 0,\n\t\t\t\tSLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD, NULL);\n\tif (!btrfs_delayed_extent_op_cachep)\n\t\tgoto fail;\n\n\treturn 0;\nfail:\n\tbtrfs_delayed_ref_exit();\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_auto_defrag_init",
          "args": [],
          "line": 2115
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_auto_defrag_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
          "lines": "2831-2841",
          "snippet": "int btrfs_auto_defrag_init(void)\n{\n\tbtrfs_inode_defrag_cachep = kmem_cache_create(\"btrfs_inode_defrag\",\n\t\t\t\t\tsizeof(struct inode_defrag), 0,\n\t\t\t\t\tSLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD,\n\t\t\t\t\tNULL);\n\tif (!btrfs_inode_defrag_cachep)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"volumes.h\"",
            "#include \"locking.h\"",
            "#include \"tree-log.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *btrfs_inode_defrag_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *btrfs_inode_defrag_cachep;\n\nint btrfs_auto_defrag_init(void)\n{\n\tbtrfs_inode_defrag_cachep = kmem_cache_create(\"btrfs_inode_defrag\",\n\t\t\t\t\tsizeof(struct inode_defrag), 0,\n\t\t\t\t\tSLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD,\n\t\t\t\t\tNULL);\n\tif (!btrfs_inode_defrag_cachep)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_delayed_inode_init",
          "args": [],
          "line": 2111
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_delayed_inode_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/delayed-inode.c",
          "lines": "32-42",
          "snippet": "int __init btrfs_delayed_inode_init(void)\n{\n\tdelayed_node_cache = kmem_cache_create(\"btrfs_delayed_node\",\n\t\t\t\t\tsizeof(struct btrfs_delayed_node),\n\t\t\t\t\t0,\n\t\t\t\t\tSLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD,\n\t\t\t\t\tNULL);\n\tif (!delayed_node_cache)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *delayed_node_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"delayed-inode.h\"\n#include <linux/slab.h>\n\nstatic struct kmem_cache *delayed_node_cache;\n\nint __init btrfs_delayed_inode_init(void)\n{\n\tdelayed_node_cache = kmem_cache_create(\"btrfs_delayed_node\",\n\t\t\t\t\tsizeof(struct btrfs_delayed_node),\n\t\t\t\t\t0,\n\t\t\t\t\tSLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD,\n\t\t\t\t\tNULL);\n\tif (!delayed_node_cache)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ordered_data_init",
          "args": [],
          "line": 2107
        },
        "resolved": true,
        "details": {
          "function_name": "ordered_data_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "1029-1039",
          "snippet": "int __init ordered_data_init(void)\n{\n\tbtrfs_ordered_extent_cache = kmem_cache_create(\"btrfs_ordered_extent\",\n\t\t\t\t     sizeof(struct btrfs_ordered_extent), 0,\n\t\t\t\t     SLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD,\n\t\t\t\t     NULL);\n\tif (!btrfs_ordered_extent_cache)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *btrfs_ordered_extent_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache *btrfs_ordered_extent_cache;\n\nint __init ordered_data_init(void)\n{\n\tbtrfs_ordered_extent_cache = kmem_cache_create(\"btrfs_ordered_extent\",\n\t\t\t\t     sizeof(struct btrfs_ordered_extent), 0,\n\t\t\t\t     SLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD,\n\t\t\t\t     NULL);\n\tif (!btrfs_ordered_extent_cache)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "extent_map_init",
          "args": [],
          "line": 2103
        },
        "resolved": true,
        "details": {
          "function_name": "extent_map_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_map.c",
          "lines": "11-19",
          "snippet": "int __init extent_map_init(void)\n{\n\textent_map_cache = kmem_cache_create(\"btrfs_extent_map\",\n\t\t\tsizeof(struct extent_map), 0,\n\t\t\tSLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD, NULL);\n\tif (!extent_map_cache)\n\t\treturn -ENOMEM;\n\treturn 0;\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <linux/hardirq.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_map_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <linux/hardirq.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n\nstatic struct kmem_cache *extent_map_cache;\n\nint __init extent_map_init(void)\n{\n\textent_map_cache = kmem_cache_create(\"btrfs_extent_map\",\n\t\t\tsizeof(struct extent_map), 0,\n\t\t\tSLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD, NULL);\n\tif (!extent_map_cache)\n\t\treturn -ENOMEM;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "extent_io_init",
          "args": [],
          "line": 2099
        },
        "resolved": true,
        "details": {
          "function_name": "extent_io_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent_io.c",
          "lines": "143-179",
          "snippet": "int __init extent_io_init(void)\n{\n\textent_state_cache = kmem_cache_create(\"btrfs_extent_state\",\n\t\t\tsizeof(struct extent_state), 0,\n\t\t\tSLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD, NULL);\n\tif (!extent_state_cache)\n\t\treturn -ENOMEM;\n\n\textent_buffer_cache = kmem_cache_create(\"btrfs_extent_buffer\",\n\t\t\tsizeof(struct extent_buffer), 0,\n\t\t\tSLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD, NULL);\n\tif (!extent_buffer_cache)\n\t\tgoto free_state_cache;\n\n\tbtrfs_bioset = bioset_create(BIO_POOL_SIZE,\n\t\t\t\t     offsetof(struct btrfs_io_bio, bio));\n\tif (!btrfs_bioset)\n\t\tgoto free_buffer_cache;\n\n\tif (bioset_integrity_create(btrfs_bioset, BIO_POOL_SIZE))\n\t\tgoto free_bioset;\n\n\treturn 0;\n\nfree_bioset:\n\tbioset_free(btrfs_bioset);\n\tbtrfs_bioset = NULL;\n\nfree_buffer_cache:\n\tkmem_cache_destroy(extent_buffer_cache);\n\textent_buffer_cache = NULL;\n\nfree_state_cache:\n\tkmem_cache_destroy(extent_state_cache);\n\textent_state_cache = NULL;\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"backref.h\"",
            "#include \"rcu-string.h\"",
            "#include \"locking.h\"",
            "#include \"check-integrity.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"ctree.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/bio.h>",
            "#include <linux/slab.h>",
            "#include <linux/bitops.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *extent_state_cache;",
            "static struct kmem_cache *extent_buffer_cache;",
            "static struct bio_set *btrfs_bioset;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"backref.h\"\n#include \"rcu-string.h\"\n#include \"locking.h\"\n#include \"check-integrity.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"ctree.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/cleancache.h>\n#include <linux/prefetch.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/blkdev.h>\n#include <linux/spinlock.h>\n#include <linux/page-flags.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/bio.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\nstatic struct kmem_cache *extent_state_cache;\nstatic struct kmem_cache *extent_buffer_cache;\nstatic struct bio_set *btrfs_bioset;\n\nint __init extent_io_init(void)\n{\n\textent_state_cache = kmem_cache_create(\"btrfs_extent_state\",\n\t\t\tsizeof(struct extent_state), 0,\n\t\t\tSLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD, NULL);\n\tif (!extent_state_cache)\n\t\treturn -ENOMEM;\n\n\textent_buffer_cache = kmem_cache_create(\"btrfs_extent_buffer\",\n\t\t\tsizeof(struct extent_buffer), 0,\n\t\t\tSLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD, NULL);\n\tif (!extent_buffer_cache)\n\t\tgoto free_state_cache;\n\n\tbtrfs_bioset = bioset_create(BIO_POOL_SIZE,\n\t\t\t\t     offsetof(struct btrfs_io_bio, bio));\n\tif (!btrfs_bioset)\n\t\tgoto free_buffer_cache;\n\n\tif (bioset_integrity_create(btrfs_bioset, BIO_POOL_SIZE))\n\t\tgoto free_bioset;\n\n\treturn 0;\n\nfree_bioset:\n\tbioset_free(btrfs_bioset);\n\tbtrfs_bioset = NULL;\n\nfree_buffer_cache:\n\tkmem_cache_destroy(extent_buffer_cache);\n\textent_buffer_cache = NULL;\n\nfree_state_cache:\n\tkmem_cache_destroy(extent_state_cache);\n\textent_state_cache = NULL;\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_init_cachep",
          "args": [],
          "line": 2095
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_init_cachep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "8829-8872",
          "snippet": "int btrfs_init_cachep(void)\n{\n\tbtrfs_inode_cachep = kmem_cache_create(\"btrfs_inode\",\n\t\t\tsizeof(struct btrfs_inode), 0,\n\t\t\tSLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD, init_once);\n\tif (!btrfs_inode_cachep)\n\t\tgoto fail;\n\n\tbtrfs_trans_handle_cachep = kmem_cache_create(\"btrfs_trans_handle\",\n\t\t\tsizeof(struct btrfs_trans_handle), 0,\n\t\t\tSLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD, NULL);\n\tif (!btrfs_trans_handle_cachep)\n\t\tgoto fail;\n\n\tbtrfs_transaction_cachep = kmem_cache_create(\"btrfs_transaction\",\n\t\t\tsizeof(struct btrfs_transaction), 0,\n\t\t\tSLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD, NULL);\n\tif (!btrfs_transaction_cachep)\n\t\tgoto fail;\n\n\tbtrfs_path_cachep = kmem_cache_create(\"btrfs_path\",\n\t\t\tsizeof(struct btrfs_path), 0,\n\t\t\tSLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD, NULL);\n\tif (!btrfs_path_cachep)\n\t\tgoto fail;\n\n\tbtrfs_free_space_cachep = kmem_cache_create(\"btrfs_free_space\",\n\t\t\tsizeof(struct btrfs_free_space), 0,\n\t\t\tSLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD, NULL);\n\tif (!btrfs_free_space_cachep)\n\t\tgoto fail;\n\n\tbtrfs_delalloc_work_cachep = kmem_cache_create(\"btrfs_delalloc_work\",\n\t\t\tsizeof(struct btrfs_delalloc_work), 0,\n\t\t\tSLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD,\n\t\t\tNULL);\n\tif (!btrfs_delalloc_work_cachep)\n\t\tgoto fail;\n\n\treturn 0;\nfail:\n\tbtrfs_destroy_cachep();\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *btrfs_inode_cachep;",
            "static struct kmem_cache *btrfs_delalloc_work_cachep;",
            "struct kmem_cache *btrfs_trans_handle_cachep;",
            "struct kmem_cache *btrfs_transaction_cachep;",
            "struct kmem_cache *btrfs_path_cachep;",
            "struct kmem_cache *btrfs_free_space_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache *btrfs_inode_cachep;\nstatic struct kmem_cache *btrfs_delalloc_work_cachep;\nstruct kmem_cache *btrfs_trans_handle_cachep;\nstruct kmem_cache *btrfs_transaction_cachep;\nstruct kmem_cache *btrfs_path_cachep;\nstruct kmem_cache *btrfs_free_space_cachep;\n\nint btrfs_init_cachep(void)\n{\n\tbtrfs_inode_cachep = kmem_cache_create(\"btrfs_inode\",\n\t\t\tsizeof(struct btrfs_inode), 0,\n\t\t\tSLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD, init_once);\n\tif (!btrfs_inode_cachep)\n\t\tgoto fail;\n\n\tbtrfs_trans_handle_cachep = kmem_cache_create(\"btrfs_trans_handle\",\n\t\t\tsizeof(struct btrfs_trans_handle), 0,\n\t\t\tSLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD, NULL);\n\tif (!btrfs_trans_handle_cachep)\n\t\tgoto fail;\n\n\tbtrfs_transaction_cachep = kmem_cache_create(\"btrfs_transaction\",\n\t\t\tsizeof(struct btrfs_transaction), 0,\n\t\t\tSLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD, NULL);\n\tif (!btrfs_transaction_cachep)\n\t\tgoto fail;\n\n\tbtrfs_path_cachep = kmem_cache_create(\"btrfs_path\",\n\t\t\tsizeof(struct btrfs_path), 0,\n\t\t\tSLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD, NULL);\n\tif (!btrfs_path_cachep)\n\t\tgoto fail;\n\n\tbtrfs_free_space_cachep = kmem_cache_create(\"btrfs_free_space\",\n\t\t\tsizeof(struct btrfs_free_space), 0,\n\t\t\tSLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD, NULL);\n\tif (!btrfs_free_space_cachep)\n\t\tgoto fail;\n\n\tbtrfs_delalloc_work_cachep = kmem_cache_create(\"btrfs_delalloc_work\",\n\t\t\tsizeof(struct btrfs_delalloc_work), 0,\n\t\t\tSLAB_RECLAIM_ACCOUNT | SLAB_MEM_SPREAD,\n\t\t\tNULL);\n\tif (!btrfs_delalloc_work_cachep)\n\t\tgoto fail;\n\n\treturn 0;\nfail:\n\tbtrfs_destroy_cachep();\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_init_compress",
          "args": [],
          "line": 2093
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_init_compress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/compression.c",
          "lines": "758-768",
          "snippet": "void __init btrfs_init_compress(void)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_COMPRESS_TYPES; i++) {\n\t\tINIT_LIST_HEAD(&comp_idle_workspace[i]);\n\t\tspin_lock_init(&comp_workspace_lock[i]);\n\t\tatomic_set(&comp_alloc_workspace[i], 0);\n\t\tinit_waitqueue_head(&comp_workspace_wait[i]);\n\t}\n}",
          "includes": [
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include \"compression.h\"",
            "#include \"ordered-data.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct list_head comp_idle_workspace[BTRFS_COMPRESS_TYPES];",
            "static spinlock_t comp_workspace_lock[BTRFS_COMPRESS_TYPES];",
            "static atomic_t comp_alloc_workspace[BTRFS_COMPRESS_TYPES];",
            "static wait_queue_head_t comp_workspace_wait[BTRFS_COMPRESS_TYPES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include \"compression.h\"\n#include \"ordered-data.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/bit_spinlock.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic struct list_head comp_idle_workspace[BTRFS_COMPRESS_TYPES];\nstatic spinlock_t comp_workspace_lock[BTRFS_COMPRESS_TYPES];\nstatic atomic_t comp_alloc_workspace[BTRFS_COMPRESS_TYPES];\nstatic wait_queue_head_t comp_workspace_wait[BTRFS_COMPRESS_TYPES];\n\nvoid __init btrfs_init_compress(void)\n{\n\tint i;\n\n\tfor (i = 0; i < BTRFS_COMPRESS_TYPES; i++) {\n\t\tINIT_LIST_HEAD(&comp_idle_workspace[i]);\n\t\tspin_lock_init(&comp_workspace_lock[i]);\n\t\tatomic_set(&comp_alloc_workspace[i], 0);\n\t\tinit_waitqueue_head(&comp_workspace_wait[i]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_init_sysfs",
          "args": [],
          "line": 2089
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_init_sysfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/sysfs.c",
          "lines": "726-750",
          "snippet": "int btrfs_init_sysfs(void)\n{\n\tint ret;\n\n\tbtrfs_kset = kset_create_and_add(\"btrfs\", NULL, fs_kobj);\n\tif (!btrfs_kset)\n\t\treturn -ENOMEM;\n\n\tret = btrfs_init_debugfs();\n\tif (ret)\n\t\tgoto out1;\n\n\tinit_feature_attrs();\n\tret = sysfs_create_group(&btrfs_kset->kobj, &btrfs_feature_attr_group);\n\tif (ret)\n\t\tgoto out2;\n\n\treturn 0;\nout2:\n\tdebugfs_remove_recursive(btrfs_debugfs_root_dentry);\nout1:\n\tkset_unregister(btrfs_kset);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"volumes.h\"",
            "#include \"sysfs.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/debugfs.h>",
            "#include <linux/genhd.h>",
            "#include <linux/bug.h>",
            "#include <linux/kobject.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline struct btrfs_fs_info *to_fs_info(struct kobject *kobj);",
            "static const struct attribute_group btrfs_feature_attr_group = {\n\t.name = \"features\",\n\t.is_visible = btrfs_feature_visible,\n\t.attrs = btrfs_supported_feature_attrs,\n};",
            "static struct kset *btrfs_kset;",
            "static struct dentry *btrfs_debugfs_root_dentry;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"volumes.h\"\n#include \"sysfs.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/debugfs.h>\n#include <linux/genhd.h>\n#include <linux/bug.h>\n#include <linux/kobject.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic inline struct btrfs_fs_info *to_fs_info(struct kobject *kobj);\nstatic const struct attribute_group btrfs_feature_attr_group = {\n\t.name = \"features\",\n\t.is_visible = btrfs_feature_visible,\n\t.attrs = btrfs_supported_feature_attrs,\n};\nstatic struct kset *btrfs_kset;\nstatic struct dentry *btrfs_debugfs_root_dentry;\n\nint btrfs_init_sysfs(void)\n{\n\tint ret;\n\n\tbtrfs_kset = kset_create_and_add(\"btrfs\", NULL, fs_kobj);\n\tif (!btrfs_kset)\n\t\treturn -ENOMEM;\n\n\tret = btrfs_init_debugfs();\n\tif (ret)\n\t\tgoto out1;\n\n\tinit_feature_attrs();\n\tret = sysfs_create_group(&btrfs_kset->kobj, &btrfs_feature_attr_group);\n\tif (ret)\n\t\tgoto out2;\n\n\treturn 0;\nout2:\n\tdebugfs_remove_recursive(btrfs_debugfs_root_dentry);\nout1:\n\tkset_unregister(btrfs_kset);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_props_init",
          "args": [],
          "line": 2087
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_props_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/props.c",
          "lines": "57-68",
          "snippet": "void __init btrfs_props_init(void)\n{\n\tstruct prop_handler *p;\n\n\thash_init(prop_handlers_ht);\n\n\tfor (p = &prop_handlers[0]; p->xattr_name; p++) {\n\t\tu64 h = btrfs_name_hash(p->xattr_name, strlen(p->xattr_name));\n\n\t\thash_add(prop_handlers_ht, &p->node, h);\n\t}\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"props.h\"",
            "#include <linux/hashtable.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct prop_handler prop_handlers[] = {\n\t{\n\t\t.xattr_name = XATTR_BTRFS_PREFIX \"compression\",\n\t\t.validate = prop_compression_validate,\n\t\t.apply = prop_compression_apply,\n\t\t.extract = prop_compression_extract,\n\t\t.inheritable = 1\n\t},\n\t{\n\t\t.xattr_name = NULL\n\t}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"btrfs_inode.h\"\n#include \"props.h\"\n#include <linux/hashtable.h>\n\nstatic struct prop_handler prop_handlers[] = {\n\t{\n\t\t.xattr_name = XATTR_BTRFS_PREFIX \"compression\",\n\t\t.validate = prop_compression_validate,\n\t\t.apply = prop_compression_apply,\n\t\t.extract = prop_compression_extract,\n\t\t.inheritable = 1\n\t},\n\t{\n\t\t.xattr_name = NULL\n\t}\n};\n\nvoid __init btrfs_props_init(void)\n{\n\tstruct prop_handler *p;\n\n\thash_init(prop_handlers_ht);\n\n\tfor (p = &prop_handlers[0]; p->xattr_name; p++) {\n\t\tu64 h = btrfs_name_hash(p->xattr_name, strlen(p->xattr_name));\n\n\t\thash_add(prop_handlers_ht, &p->node, h);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_hash_init",
          "args": [],
          "line": 2083
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_hash_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/hash.c",
          "lines": "20-25",
          "snippet": "int __init btrfs_hash_init(void)\n{\n\ttfm = crypto_alloc_shash(\"crc32c\", 0, 0);\n\n\treturn PTR_ERR_OR_ZERO(tfm);\n}",
          "includes": [
            "#include \"hash.h\"",
            "#include <linux/err.h>",
            "#include <crypto/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct crypto_shash *tfm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hash.h\"\n#include <linux/err.h>\n#include <crypto/hash.h>\n\nstatic struct crypto_shash *tfm;\n\nint __init btrfs_hash_init(void)\n{\n\ttfm = crypto_alloc_shash(\"crc32c\", 0, 0);\n\n\treturn PTR_ERR_OR_ZERO(tfm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"Btrfs loaded\"\n#ifdef CONFIG_BTRFS_DEBUG\n\t\t\t\", debug=on\"#endif\n#ifdef CONFIG_BTRFS_ASSERT\n\t\t\t\"",
            "assert=on\"\n#endif\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\t\t\t\"",
            "integrity-checker=on\"\n#endif\n\t\t\t\"\\n\");\n}\n\nstatic int btrfs_run_sanity_tests(void){\n\tint ret;\n\n\tret = btrfs_init_test_fs();\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_test_free_space_cache();\n\tif (ret)\n\t\tgoto out;\n\tret = btrfs_test_extent_buffer_operations();\n\tif (ret)\n\t\tgoto out;\n\tret = btrfs_test_extent_io();\n\tif (ret)\n\t\tgoto out;\n\tret = btrfs_test_inodes();\n\tif (ret)\n\t\tgoto out;\n\tret = btrfs_test_qgroups();\nout:\n\tbtrfs_destroy_test_fs();\n\treturn ret;\n}static int __init init_btrfs_fs(void"
          ],
          "line": 2040
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_destroy_test_fs",
          "args": [],
          "line": 2075
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_destroy_test_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/btrfs-tests.c",
          "lines": "73-77",
          "snippet": "void btrfs_destroy_test_fs(void)\n{\n\tkern_unmount(test_mnt);\n\tunregister_filesystem(&test_type);\n}",
          "includes": [
            "#include \"../qgroup.h\"",
            "#include \"../disk-io.h\"",
            "#include \"../volumes.h\"",
            "#include \"../ctree.h\"",
            "#include \"btrfs-tests.h\"",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct vfsmount *test_mnt = NULL;",
            "static struct file_system_type test_type = {\n\t.name\t\t= \"btrfs_test_fs\",\n\t.mount\t\t= btrfs_test_mount,\n\t.kill_sb\t= kill_anon_super,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../qgroup.h\"\n#include \"../disk-io.h\"\n#include \"../volumes.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic struct vfsmount *test_mnt = NULL;\nstatic struct file_system_type test_type = {\n\t.name\t\t= \"btrfs_test_fs\",\n\t.mount\t\t= btrfs_test_mount,\n\t.kill_sb\t= kill_anon_super,\n};\n\nvoid btrfs_destroy_test_fs(void)\n{\n\tkern_unmount(test_mnt);\n\tunregister_filesystem(&test_type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_test_qgroups",
          "args": [],
          "line": 2073
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_test_qgroups",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/qgroup-tests.c",
          "lines": "389-469",
          "snippet": "int btrfs_test_qgroups(void)\n{\n\tstruct btrfs_root *root;\n\tstruct btrfs_root *tmp_root;\n\tint ret = 0;\n\n\troot = btrfs_alloc_dummy_root();\n\tif (IS_ERR(root)) {\n\t\ttest_msg(\"Couldn't allocate root\\n\");\n\t\treturn PTR_ERR(root);\n\t}\n\n\troot->fs_info = btrfs_alloc_dummy_fs_info();\n\tif (!root->fs_info) {\n\t\ttest_msg(\"Couldn't allocate dummy fs info\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\t/* We are using this root as our extent root */\n\troot->fs_info->extent_root = root;\n\n\t/*\n\t * Some of the paths we test assume we have a filled out fs_info, so we\n\t * just need to add the root in there so we don't panic.\n\t */\n\troot->fs_info->tree_root = root;\n\troot->fs_info->quota_root = root;\n\troot->fs_info->quota_enabled = 1;\n\n\t/*\n\t * Can't use bytenr 0, some things freak out\n\t * *cough*backref walking code*cough*\n\t */\n\troot->node = alloc_test_extent_buffer(root->fs_info, 4096);\n\tif (!root->node) {\n\t\ttest_msg(\"Couldn't allocate dummy buffer\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tbtrfs_set_header_level(root->node, 0);\n\tbtrfs_set_header_nritems(root->node, 0);\n\troot->alloc_bytenr += 8192;\n\n\ttmp_root = btrfs_alloc_dummy_root();\n\tif (IS_ERR(tmp_root)) {\n\t\ttest_msg(\"Couldn't allocate a fs root\\n\");\n\t\tret = PTR_ERR(tmp_root);\n\t\tgoto out;\n\t}\n\n\ttmp_root->root_key.objectid = 5;\n\troot->fs_info->fs_root = tmp_root;\n\tret = btrfs_insert_fs_root(root->fs_info, tmp_root);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't insert fs root %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\ttmp_root = btrfs_alloc_dummy_root();\n\tif (IS_ERR(tmp_root)) {\n\t\ttest_msg(\"Couldn't allocate a fs root\\n\");\n\t\tret = PTR_ERR(tmp_root);\n\t\tgoto out;\n\t}\n\n\ttmp_root->root_key.objectid = 256;\n\tret = btrfs_insert_fs_root(root->fs_info, tmp_root);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't insert fs root %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\ttest_msg(\"Running qgroup tests\\n\");\n\tret = test_no_shared_qgroup(root);\n\tif (ret)\n\t\tgoto out;\n\tret = test_multiple_refs(root);\nout:\n\tbtrfs_free_dummy_root(root);\n\treturn ret;\n}",
          "includes": [
            "#include \"../qgroup.h\"",
            "#include \"../disk-io.h\"",
            "#include \"../transaction.h\"",
            "#include \"../ctree.h\"",
            "#include \"btrfs-tests.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../qgroup.h\"\n#include \"../disk-io.h\"\n#include \"../transaction.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n\nint btrfs_test_qgroups(void)\n{\n\tstruct btrfs_root *root;\n\tstruct btrfs_root *tmp_root;\n\tint ret = 0;\n\n\troot = btrfs_alloc_dummy_root();\n\tif (IS_ERR(root)) {\n\t\ttest_msg(\"Couldn't allocate root\\n\");\n\t\treturn PTR_ERR(root);\n\t}\n\n\troot->fs_info = btrfs_alloc_dummy_fs_info();\n\tif (!root->fs_info) {\n\t\ttest_msg(\"Couldn't allocate dummy fs info\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\t/* We are using this root as our extent root */\n\troot->fs_info->extent_root = root;\n\n\t/*\n\t * Some of the paths we test assume we have a filled out fs_info, so we\n\t * just need to add the root in there so we don't panic.\n\t */\n\troot->fs_info->tree_root = root;\n\troot->fs_info->quota_root = root;\n\troot->fs_info->quota_enabled = 1;\n\n\t/*\n\t * Can't use bytenr 0, some things freak out\n\t * *cough*backref walking code*cough*\n\t */\n\troot->node = alloc_test_extent_buffer(root->fs_info, 4096);\n\tif (!root->node) {\n\t\ttest_msg(\"Couldn't allocate dummy buffer\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tbtrfs_set_header_level(root->node, 0);\n\tbtrfs_set_header_nritems(root->node, 0);\n\troot->alloc_bytenr += 8192;\n\n\ttmp_root = btrfs_alloc_dummy_root();\n\tif (IS_ERR(tmp_root)) {\n\t\ttest_msg(\"Couldn't allocate a fs root\\n\");\n\t\tret = PTR_ERR(tmp_root);\n\t\tgoto out;\n\t}\n\n\ttmp_root->root_key.objectid = 5;\n\troot->fs_info->fs_root = tmp_root;\n\tret = btrfs_insert_fs_root(root->fs_info, tmp_root);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't insert fs root %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\ttmp_root = btrfs_alloc_dummy_root();\n\tif (IS_ERR(tmp_root)) {\n\t\ttest_msg(\"Couldn't allocate a fs root\\n\");\n\t\tret = PTR_ERR(tmp_root);\n\t\tgoto out;\n\t}\n\n\ttmp_root->root_key.objectid = 256;\n\tret = btrfs_insert_fs_root(root->fs_info, tmp_root);\n\tif (ret) {\n\t\ttest_msg(\"Couldn't insert fs root %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\ttest_msg(\"Running qgroup tests\\n\");\n\tret = test_no_shared_qgroup(root);\n\tif (ret)\n\t\tgoto out;\n\tret = test_multiple_refs(root);\nout:\n\tbtrfs_free_dummy_root(root);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_test_inodes",
          "args": [],
          "line": 2070
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_test_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/btrfs-tests.h",
          "lines": "58-61",
          "snippet": "static inline int btrfs_test_inodes(void)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int btrfs_test_inodes(void)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_test_extent_io",
          "args": [],
          "line": 2067
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_test_extent_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/btrfs-tests.h",
          "lines": "54-57",
          "snippet": "static inline int btrfs_test_extent_io(void)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int btrfs_test_extent_io(void)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_test_extent_buffer_operations",
          "args": [],
          "line": 2064
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_test_extent_buffer_operations",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/btrfs-tests.h",
          "lines": "43-46",
          "snippet": "static inline int btrfs_test_extent_buffer_operations(void)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int btrfs_test_extent_buffer_operations(void)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_test_free_space_cache",
          "args": [],
          "line": 2061
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_test_free_space_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/btrfs-tests.h",
          "lines": "39-42",
          "snippet": "static inline int btrfs_test_free_space_cache(void)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int btrfs_test_free_space_cache(void)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_init_test_fs",
          "args": [],
          "line": 2057
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_init_test_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/tests/btrfs-tests.c",
          "lines": "54-71",
          "snippet": "int btrfs_init_test_fs(void)\n{\n\tint ret;\n\n\tret = register_filesystem(&test_type);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"btrfs: cannot register test file system\\n\");\n\t\treturn ret;\n\t}\n\n\ttest_mnt = kern_mount(&test_type);\n\tif (IS_ERR(test_mnt)) {\n\t\tprintk(KERN_ERR \"btrfs: cannot mount test file system\\n\");\n\t\tunregister_filesystem(&test_type);\n\t\treturn ret;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"../qgroup.h\"",
            "#include \"../disk-io.h\"",
            "#include \"../volumes.h\"",
            "#include \"../ctree.h\"",
            "#include \"btrfs-tests.h\"",
            "#include <linux/magic.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct vfsmount *test_mnt = NULL;",
            "static struct file_system_type test_type = {\n\t.name\t\t= \"btrfs_test_fs\",\n\t.mount\t\t= btrfs_test_mount,\n\t.kill_sb\t= kill_anon_super,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"../qgroup.h\"\n#include \"../disk-io.h\"\n#include \"../volumes.h\"\n#include \"../ctree.h\"\n#include \"btrfs-tests.h\"\n#include <linux/magic.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic struct vfsmount *test_mnt = NULL;\nstatic struct file_system_type test_type = {\n\t.name\t\t= \"btrfs_test_fs\",\n\t.mount\t\t= btrfs_test_mount,\n\t.kill_sb\t= kill_anon_super,\n};\n\nint btrfs_init_test_fs(void)\n{\n\tint ret;\n\n\tret = register_filesystem(&test_type);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"btrfs: cannot register test file system\\n\");\n\t\treturn ret;\n\t}\n\n\ttest_mnt = kern_mount(&test_type);\n\tif (IS_ERR(test_mnt)) {\n\t\tprintk(KERN_ERR \"btrfs: cannot mount test file system\\n\");\n\t\tunregister_filesystem(&test_type);\n\t\treturn ret;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "on\"\n#endif\n\t\t\t\"\\n\");\n}\n\nstatic int btrfs_run_sanity_tests",
          "args": [
            "void"
          ],
          "line": 2048
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nstatic struct file_system_type btrfs_fs_type;\nstatic struct file_system_type btrfs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"btrfs\",\n\t.mount\t\t= btrfs_mount,\n\t.kill_sb\t= btrfs_kill_super,\n\t.fs_flags\t= FS_REQUIRES_DEV | FS_BINARY_MOUNTDATA,\n};\n\nstatic void btrfs_print_info(void)\n{\n\tprintk(KERN_INFO \"Btrfs loaded\"\n#ifdef CONFIG_BTRFS_DEBUG\n\t\t\t\", debug=on\"\n#endif\n#ifdef CONFIG_BTRFS_ASSERT\n\t\t\t\", assert=on\"\n#endif\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\t\t\t\", integrity-checker=on\"\n#endif\n\t\t\t\"\\n\");\n}\n\nstatic int btrfs_run_sanity_tests(void)\n{\n\tint ret;\n\n\tret = btrfs_init_test_fs();\n\tif (ret)\n\t\treturn ret;\n\n\tret = btrfs_test_free_space_cache();\n\tif (ret)\n\t\tgoto out;\n\tret = btrfs_test_extent_buffer_operations();\n\tif (ret)\n\t\tgoto out;\n\tret = btrfs_test_extent_io();\n\tif (ret)\n\t\tgoto out;\n\tret = btrfs_test_inodes();\n\tif (ret)\n\t\tgoto out;\n\tret = btrfs_test_qgroups();\nout:\n\tbtrfs_destroy_test_fs();\n\treturn ret;\n}\n\nstatic int __init init_btrfs_fs(void)\n{\n\tint err;\n\n\terr = btrfs_hash_init();\n\tif (err)\n\t\treturn err;\n\n\tbtrfs_props_init();\n\n\terr = btrfs_init_sysfs();\n\tif (err)\n\t\tgoto free_hash;\n\n\tbtrfs_init_compress();\n\n\terr = btrfs_init_cachep();\n\tif (err)\n\t\tgoto free_compress;\n\n\terr = extent_io_init();\n\tif (err)\n\t\tgoto free_cachep;\n\n\terr = extent_map_init();\n\tif (err)\n\t\tgoto free_extent_io;\n\n\terr = ordered_data_init();\n\tif (err)\n\t\tgoto free_extent_map;\n\n\terr = btrfs_delayed_inode_init();\n\tif (err)\n\t\tgoto free_ordered_data;\n\n\terr = btrfs_auto_defrag_init();\n\tif (err)\n\t\tgoto free_delayed_inode;\n\n\terr = btrfs_delayed_ref_init();\n\tif (err)\n\t\tgoto free_auto_defrag;\n\n\terr = btrfs_prelim_ref_init();\n\tif (err)\n\t\tgoto free_delayed_ref;\n\n\terr = btrfs_end_io_wq_init();\n\tif (err)\n\t\tgoto free_prelim_ref;\n\n\terr = btrfs_interface_init();\n\tif (err)\n\t\tgoto free_end_io_wq;\n\n\tbtrfs_init_lockdep();\n\n\tbtrfs_print_info();\n\n\terr = btrfs_run_sanity_tests();\n\tif (err)\n\t\tgoto unregister_ioctl;\n\n\terr = register_filesystem(&btrfs_fs_type);\n\tif (err)\n\t\tgoto unregister_ioctl;\n\n\treturn 0;\n\nunregister_ioctl:\n\tbtrfs_interface_exit();\nfree_end_io_wq:\n\tbtrfs_end_io_wq_exit();\nfree_prelim_ref:\n\tbtrfs_prelim_ref_exit();\nfree_delayed_ref:\n\tbtrfs_delayed_ref_exit();\nfree_auto_defrag:\n\tbtrfs_auto_defrag_exit();\nfree_delayed_inode:\n\tbtrfs_delayed_inode_exit();\nfree_ordered_data:\n\tordered_data_exit();\nfree_extent_map:\n\textent_map_exit();\nfree_extent_io:\n\textent_io_exit();\nfree_cachep:\n\tbtrfs_destroy_cachep();\nfree_compress:\n\tbtrfs_exit_compress();\n\tbtrfs_exit_sysfs();\nfree_hash:\n\tbtrfs_hash_exit();\n\treturn err;\n}\n\nstatic void __exit exit_btrfs_fs(void)\n{\n\tbtrfs_destroy_cachep();\n\tbtrfs_delayed_ref_exit();\n\tbtrfs_auto_defrag_exit();\n\tbtrfs_delayed_inode_exit();\n\tbtrfs_prelim_ref_exit();\n\tordered_data_exit();\n\textent_map_exit();\n\textent_io_exit();\n\tbtrfs_interface_exit();\n\tbtrfs_end_io_wq_exit();\n\tunregister_filesystem(&btrfs_fs_type);\n\tbtrfs_exit_sysfs();\n\tbtrfs_cleanup_fs_uuids();\n\tbtrfs_exit_compress();\n\tbtrfs_hash_exit();\n}\n\nlate_initcall(init_btrfs_fs);\nmodule_exit(exit_btrfs_fs)\n\nMODULE_LICENSE(\"GPL\");"
  },
  {
    "function_name": "btrfs_interface_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
    "lines": "2032-2036",
    "snippet": "static void btrfs_interface_exit(void)\n{\n\tif (misc_deregister(&btrfs_misc) < 0)\n\t\tprintk(KERN_INFO \"BTRFS: misc_deregister failed for control device\\n\");\n}",
    "includes": [
      "#include <trace/events/btrfs.h>",
      "#include \"qgroup.h\"",
      "#include \"tests/btrfs-tests.h\"",
      "#include \"backref.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"compression.h\"",
      "#include \"export.h\"",
      "#include \"volumes.h\"",
      "#include \"xattr.h\"",
      "#include \"props.h\"",
      "#include \"hash.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/namei.h>",
      "#include <linux/ctype.h>",
      "#include <linux/parser.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct miscdevice btrfs_misc = {\n\t.minor\t\t= BTRFS_MINOR,\n\t.name\t\t= \"btrfs-control\",\n\t.fops\t\t= &btrfs_ctl_fops\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"BTRFS: misc_deregister failed for control device\\n\""
          ],
          "line": 2035
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "misc_deregister",
          "args": [
            "&btrfs_misc"
          ],
          "line": 2034
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nstatic struct miscdevice btrfs_misc = {\n\t.minor\t\t= BTRFS_MINOR,\n\t.name\t\t= \"btrfs-control\",\n\t.fops\t\t= &btrfs_ctl_fops\n};\n\nstatic void btrfs_interface_exit(void)\n{\n\tif (misc_deregister(&btrfs_misc) < 0)\n\t\tprintk(KERN_INFO \"BTRFS: misc_deregister failed for control device\\n\");\n}"
  },
  {
    "function_name": "btrfs_interface_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
    "lines": "2027-2030",
    "snippet": "static int btrfs_interface_init(void)\n{\n\treturn misc_register(&btrfs_misc);\n}",
    "includes": [
      "#include <trace/events/btrfs.h>",
      "#include \"qgroup.h\"",
      "#include \"tests/btrfs-tests.h\"",
      "#include \"backref.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"compression.h\"",
      "#include \"export.h\"",
      "#include \"volumes.h\"",
      "#include \"xattr.h\"",
      "#include \"props.h\"",
      "#include \"hash.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/namei.h>",
      "#include <linux/ctype.h>",
      "#include <linux/parser.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct miscdevice btrfs_misc = {\n\t.minor\t\t= BTRFS_MINOR,\n\t.name\t\t= \"btrfs-control\",\n\t.fops\t\t= &btrfs_ctl_fops\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "misc_register",
          "args": [
            "&btrfs_misc"
          ],
          "line": 2029
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nstatic struct miscdevice btrfs_misc = {\n\t.minor\t\t= BTRFS_MINOR,\n\t.name\t\t= \"btrfs-control\",\n\t.fops\t\t= &btrfs_ctl_fops\n};\n\nstatic int btrfs_interface_init(void)\n{\n\treturn misc_register(&btrfs_misc);\n}"
  },
  {
    "function_name": "btrfs_show_devname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
    "lines": "1961-1994",
    "snippet": "static int btrfs_show_devname(struct seq_file *m, struct dentry *root)\n{\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(root->d_sb);\n\tstruct btrfs_fs_devices *cur_devices;\n\tstruct btrfs_device *dev, *first_dev = NULL;\n\tstruct list_head *head;\n\tstruct rcu_string *name;\n\n\tmutex_lock(&fs_info->fs_devices->device_list_mutex);\n\tcur_devices = fs_info->fs_devices;\n\twhile (cur_devices) {\n\t\thead = &cur_devices->devices;\n\t\tlist_for_each_entry(dev, head, dev_list) {\n\t\t\tif (dev->missing)\n\t\t\t\tcontinue;\n\t\t\tif (!dev->name)\n\t\t\t\tcontinue;\n\t\t\tif (!first_dev || dev->devid < first_dev->devid)\n\t\t\t\tfirst_dev = dev;\n\t\t}\n\t\tcur_devices = cur_devices->seed;\n\t}\n\n\tif (first_dev) {\n\t\trcu_read_lock();\n\t\tname = rcu_dereference(first_dev->name);\n\t\tseq_escape(m, name->str, \" \\t\\n\\\\\");\n\t\trcu_read_unlock();\n\t} else {\n\t\tWARN_ON(1);\n\t}\n\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/btrfs.h>",
      "#include \"qgroup.h\"",
      "#include \"tests/btrfs-tests.h\"",
      "#include \"backref.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"compression.h\"",
      "#include \"export.h\"",
      "#include \"volumes.h\"",
      "#include \"xattr.h\"",
      "#include \"props.h\"",
      "#include \"hash.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/namei.h>",
      "#include <linux/ctype.h>",
      "#include <linux/parser.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->fs_devices->device_list_mutex"
          ],
          "line": 1992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 1990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_escape",
          "args": [
            "m",
            "name->str",
            "\" \\t\\n\\\\\""
          ],
          "line": 1987
        },
        "resolved": true,
        "details": {
          "function_name": "seq_escape",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "374-397",
          "snippet": "int seq_escape(struct seq_file *m, const char *s, const char *esc)\n{\n\tchar *end = m->buf + m->size;\n        char *p;\n\tchar c;\n\n        for (p = m->buf + m->count; (c = *s) != '\\0' && p < end; s++) {\n\t\tif (!strchr(esc, c)) {\n\t\t\t*p++ = c;\n\t\t\tcontinue;\n\t\t}\n\t\tif (p + 3 < end) {\n\t\t\t*p++ = '\\\\';\n\t\t\t*p++ = '0' + ((c & 0300) >> 6);\n\t\t\t*p++ = '0' + ((c & 070) >> 3);\n\t\t\t*p++ = '0' + (c & 07);\n\t\t\tcontinue;\n\t\t}\n\t\tseq_set_overflow(m);\n\t\treturn -1;\n        }\n\tm->count = p - m->buf;\n        return 0;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_escape(struct seq_file *m, const char *s, const char *esc)\n{\n\tchar *end = m->buf + m->size;\n        char *p;\n\tchar c;\n\n        for (p = m->buf + m->count; (c = *s) != '\\0' && p < end; s++) {\n\t\tif (!strchr(esc, c)) {\n\t\t\t*p++ = c;\n\t\t\tcontinue;\n\t\t}\n\t\tif (p + 3 < end) {\n\t\t\t*p++ = '\\\\';\n\t\t\t*p++ = '0' + ((c & 0300) >> 6);\n\t\t\t*p++ = '0' + ((c & 070) >> 3);\n\t\t\t*p++ = '0' + (c & 07);\n\t\t\tcontinue;\n\t\t}\n\t\tseq_set_overflow(m);\n\t\treturn -1;\n        }\n\tm->count = p - m->buf;\n        return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "first_dev->name"
          ],
          "line": 1986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "dev",
            "head",
            "dev_list"
          ],
          "line": 1973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fs_info->fs_devices->device_list_mutex"
          ],
          "line": 1969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_sb",
          "args": [
            "root->d_sb"
          ],
          "line": 1963
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3272-3275",
          "snippet": "static inline struct btrfs_fs_info *btrfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline struct btrfs_fs_info *btrfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nstatic int btrfs_show_devname(struct seq_file *m, struct dentry *root)\n{\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(root->d_sb);\n\tstruct btrfs_fs_devices *cur_devices;\n\tstruct btrfs_device *dev, *first_dev = NULL;\n\tstruct list_head *head;\n\tstruct rcu_string *name;\n\n\tmutex_lock(&fs_info->fs_devices->device_list_mutex);\n\tcur_devices = fs_info->fs_devices;\n\twhile (cur_devices) {\n\t\thead = &cur_devices->devices;\n\t\tlist_for_each_entry(dev, head, dev_list) {\n\t\t\tif (dev->missing)\n\t\t\t\tcontinue;\n\t\t\tif (!dev->name)\n\t\t\t\tcontinue;\n\t\t\tif (!first_dev || dev->devid < first_dev->devid)\n\t\t\t\tfirst_dev = dev;\n\t\t}\n\t\tcur_devices = cur_devices->seed;\n\t}\n\n\tif (first_dev) {\n\t\trcu_read_lock();\n\t\tname = rcu_dereference(first_dev->name);\n\t\tseq_escape(m, name->str, \" \\t\\n\\\\\");\n\t\trcu_read_unlock();\n\t} else {\n\t\tWARN_ON(1);\n\t}\n\tmutex_unlock(&fs_info->fs_devices->device_list_mutex);\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_freeze",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
    "lines": "1946-1959",
    "snippet": "static int btrfs_freeze(struct super_block *sb)\n{\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_root *root = btrfs_sb(sb)->tree_root;\n\n\ttrans = btrfs_attach_transaction_barrier(root);\n\tif (IS_ERR(trans)) {\n\t\t/* no transaction, don't bother */\n\t\tif (PTR_ERR(trans) == -ENOENT)\n\t\t\treturn 0;\n\t\treturn PTR_ERR(trans);\n\t}\n\treturn btrfs_commit_transaction(trans, root);\n}",
    "includes": [
      "#include <trace/events/btrfs.h>",
      "#include \"qgroup.h\"",
      "#include \"tests/btrfs-tests.h\"",
      "#include \"backref.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"compression.h\"",
      "#include \"export.h\"",
      "#include \"volumes.h\"",
      "#include \"xattr.h\"",
      "#include \"props.h\"",
      "#include \"hash.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/namei.h>",
      "#include <linux/ctype.h>",
      "#include <linux/parser.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_commit_transaction",
          "args": [
            "trans",
            "root"
          ],
          "line": 1958
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_commit_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "1764-2099",
          "snippet": "int btrfs_commit_transaction(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tint ret;\n\n\t/* Stop the commit early if ->aborted is set */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\t/* make a pass through all the delayed refs we have so far\n\t * any runnings procs may add more while we are here\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tcur_trans = trans->transaction;\n\n\t/*\n\t * set the flushing flag so procs in this transaction have to\n\t * start sending their work down.\n\t */\n\tcur_trans->delayed_refs.flushing = 1;\n\tsmp_wmb();\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tret = btrfs_end_transaction(trans, root);\n\n\t\twait_for_commit(root, cur_trans);\n\n\t\tif (unlikely(cur_trans->aborted))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tif (cur_trans->list.prev != &root->fs_info->trans_list) {\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state != TRANS_STATE_COMPLETED) {\n\t\t\tatomic_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t\twait_for_commit(root, prev_trans);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(root->fs_info);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t/* some pending stuffs might be added after the previous flush. */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tbtrfs_wait_delalloc_flush(root->fs_info);\n\n\tbtrfs_wait_pending_ordered(cur_trans, root->fs_info);\n\n\tbtrfs_scrub_pause(root);\n\t/*\n\t * Ok now we need to make sure to block out any other joins while we\n\t * commit the transaction.  We could have started a join before setting\n\t * COMMIT_DOING so make sure to wait for num_writers to == 1 again.\n\t */\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&root->fs_info->trans_lock);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t/* ->aborted might be set after the previous check, so check it */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tgoto scrub_continue;\n\t}\n\t/*\n\t * the reloc mutex makes sure that we stop\n\t * the balancing code from coming in and moving\n\t * extents around in the middle of the commit\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\n\t/*\n\t * We needn't worry about the delayed items because we will\n\t * deal with them in create_pending_snapshot(), which is the\n\t * core function of the snapshot creation.\n\t */\n\tret = create_pending_snapshots(trans, root->fs_info);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * We insert the dir indexes of the snapshots and update the inode\n\t * of the snapshots' parents after the snapshot creation, so there\n\t * are some delayed items which are not dealt with. Now deal with\n\t * them.\n\t *\n\t * We needn't worry that this operation will corrupt the snapshots,\n\t * because all the tree which are snapshoted will be forced to COW\n\t * the nodes and leaves.\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * make sure none of the code above managed to slip in a\n\t * delayed item\n\t */\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\t/* btrfs_commit_tree_roots is responsible for getting the\n\t * various roots consistent with each other.  Every pointer\n\t * in the tree of tree roots has to point to the most up to date\n\t * root for every subvolume and other tree.  So, we have to keep\n\t * the tree logging code from jumping in and changing any\n\t * of the trees.\n\t *\n\t * At this point in the commit, there can't be any tree-log\n\t * writers, but a little lower down we drop the trans mutex\n\t * and let new people in.  By holding the tree_log_mutex\n\t * from now until after the super is written, we avoid races\n\t * with the tree-log code.\n\t */\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * Since the transaction is done, we can apply the pending changes\n\t * before the next transaction.\n\t */\n\tbtrfs_apply_pending_changes(root->fs_info);\n\n\t/* commit_fs_roots gets rid of all the tree log roots, it is now\n\t * safe to free the root of tree log roots\n\t */\n\tbtrfs_free_log_root_tree(trans, root->fs_info);\n\n\tret = commit_cowonly_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * The tasks which save the space cache and inode cache may also\n\t * update ->aborted, check it.\n\t */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tbtrfs_prepare_extent_commit(trans, root);\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&root->fs_info->tree_root->root_item,\n\t\t\t    root->fs_info->tree_root->node);\n\tlist_add_tail(&root->fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&root->fs_info->chunk_root->root_item,\n\t\t\t    root->fs_info->chunk_root->node);\n\tlist_add_tail(&root->fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tswitch_commit_roots(cur_trans, root->fs_info);\n\n\tassert_qgroups_uptodate(trans);\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tupdate_super_roots(root);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_copy, 0);\n\tmemcpy(root->fs_info->super_for_commit, root->fs_info->super_copy,\n\t       sizeof(*root->fs_info->super_copy));\n\n\tbtrfs_update_commit_device_size(root->fs_info);\n\tbtrfs_update_commit_device_bytes_used(root, cur_trans);\n\n\tclear_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\tclear_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twake_up(&root->fs_info->transaction_wait);\n\n\tret = btrfs_write_and_wait_transaction(trans, root);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Error while writing out transaction\");\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = write_ctree_super(trans, root, 0);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * the super is written, we can safely allow the tree-loggers\n\t * to go about their business\n\t */\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\n\tbtrfs_finish_extent_commit(trans, root);\n\n\tif (cur_trans->have_free_bgs)\n\t\tbtrfs_clear_space_info_full(root->fs_info);\n\n\troot->fs_info->last_trans_committed = cur_trans->transid;\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tbtrfs_scrub_continue(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\tif (current != root->fs_info->transaction_kthread)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\treturn ret;\n\nscrub_continue:\n\tbtrfs_scrub_continue(root);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\tbtrfs_warn(root->fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, root, ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_commit_transaction(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tint ret;\n\n\t/* Stop the commit early if ->aborted is set */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\t/* make a pass through all the delayed refs we have so far\n\t * any runnings procs may add more while we are here\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tcur_trans = trans->transaction;\n\n\t/*\n\t * set the flushing flag so procs in this transaction have to\n\t * start sending their work down.\n\t */\n\tcur_trans->delayed_refs.flushing = 1;\n\tsmp_wmb();\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tret = btrfs_end_transaction(trans, root);\n\n\t\twait_for_commit(root, cur_trans);\n\n\t\tif (unlikely(cur_trans->aborted))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tif (cur_trans->list.prev != &root->fs_info->trans_list) {\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state != TRANS_STATE_COMPLETED) {\n\t\t\tatomic_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t\twait_for_commit(root, prev_trans);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(root->fs_info);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t/* some pending stuffs might be added after the previous flush. */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tbtrfs_wait_delalloc_flush(root->fs_info);\n\n\tbtrfs_wait_pending_ordered(cur_trans, root->fs_info);\n\n\tbtrfs_scrub_pause(root);\n\t/*\n\t * Ok now we need to make sure to block out any other joins while we\n\t * commit the transaction.  We could have started a join before setting\n\t * COMMIT_DOING so make sure to wait for num_writers to == 1 again.\n\t */\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&root->fs_info->trans_lock);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t/* ->aborted might be set after the previous check, so check it */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tgoto scrub_continue;\n\t}\n\t/*\n\t * the reloc mutex makes sure that we stop\n\t * the balancing code from coming in and moving\n\t * extents around in the middle of the commit\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\n\t/*\n\t * We needn't worry about the delayed items because we will\n\t * deal with them in create_pending_snapshot(), which is the\n\t * core function of the snapshot creation.\n\t */\n\tret = create_pending_snapshots(trans, root->fs_info);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * We insert the dir indexes of the snapshots and update the inode\n\t * of the snapshots' parents after the snapshot creation, so there\n\t * are some delayed items which are not dealt with. Now deal with\n\t * them.\n\t *\n\t * We needn't worry that this operation will corrupt the snapshots,\n\t * because all the tree which are snapshoted will be forced to COW\n\t * the nodes and leaves.\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * make sure none of the code above managed to slip in a\n\t * delayed item\n\t */\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\t/* btrfs_commit_tree_roots is responsible for getting the\n\t * various roots consistent with each other.  Every pointer\n\t * in the tree of tree roots has to point to the most up to date\n\t * root for every subvolume and other tree.  So, we have to keep\n\t * the tree logging code from jumping in and changing any\n\t * of the trees.\n\t *\n\t * At this point in the commit, there can't be any tree-log\n\t * writers, but a little lower down we drop the trans mutex\n\t * and let new people in.  By holding the tree_log_mutex\n\t * from now until after the super is written, we avoid races\n\t * with the tree-log code.\n\t */\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * Since the transaction is done, we can apply the pending changes\n\t * before the next transaction.\n\t */\n\tbtrfs_apply_pending_changes(root->fs_info);\n\n\t/* commit_fs_roots gets rid of all the tree log roots, it is now\n\t * safe to free the root of tree log roots\n\t */\n\tbtrfs_free_log_root_tree(trans, root->fs_info);\n\n\tret = commit_cowonly_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * The tasks which save the space cache and inode cache may also\n\t * update ->aborted, check it.\n\t */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tbtrfs_prepare_extent_commit(trans, root);\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&root->fs_info->tree_root->root_item,\n\t\t\t    root->fs_info->tree_root->node);\n\tlist_add_tail(&root->fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&root->fs_info->chunk_root->root_item,\n\t\t\t    root->fs_info->chunk_root->node);\n\tlist_add_tail(&root->fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tswitch_commit_roots(cur_trans, root->fs_info);\n\n\tassert_qgroups_uptodate(trans);\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tupdate_super_roots(root);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_copy, 0);\n\tmemcpy(root->fs_info->super_for_commit, root->fs_info->super_copy,\n\t       sizeof(*root->fs_info->super_copy));\n\n\tbtrfs_update_commit_device_size(root->fs_info);\n\tbtrfs_update_commit_device_bytes_used(root, cur_trans);\n\n\tclear_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\tclear_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twake_up(&root->fs_info->transaction_wait);\n\n\tret = btrfs_write_and_wait_transaction(trans, root);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Error while writing out transaction\");\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = write_ctree_super(trans, root, 0);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * the super is written, we can safely allow the tree-loggers\n\t * to go about their business\n\t */\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\n\tbtrfs_finish_extent_commit(trans, root);\n\n\tif (cur_trans->have_free_bgs)\n\t\tbtrfs_clear_space_info_full(root->fs_info);\n\n\troot->fs_info->last_trans_committed = cur_trans->transid;\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tbtrfs_scrub_continue(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\tif (current != root->fs_info->transaction_kthread)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\treturn ret;\n\nscrub_continue:\n\tbtrfs_scrub_continue(root);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\tbtrfs_warn(root->fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, root, ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "trans"
          ],
          "line": 1956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "trans"
          ],
          "line": 1954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trans"
          ],
          "line": 1952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_attach_transaction_barrier",
          "args": [
            "root"
          ],
          "line": 1951
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_attach_transaction_barrier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "616-626",
          "snippet": "struct btrfs_trans_handle *\nbtrfs_attach_transaction_barrier(struct btrfs_root *root)\n{\n\tstruct btrfs_trans_handle *trans;\n\n\ttrans = start_transaction(root, 0, TRANS_ATTACH, 0);\n\tif (IS_ERR(trans) && PTR_ERR(trans) == -ENOENT)\n\t\tbtrfs_wait_for_commit(root, 0);\n\n\treturn trans;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct btrfs_trans_handle *\nbtrfs_attach_transaction_barrier(struct btrfs_root *root)\n{\n\tstruct btrfs_trans_handle *trans;\n\n\ttrans = start_transaction(root, 0, TRANS_ATTACH, 0);\n\tif (IS_ERR(trans) && PTR_ERR(trans) == -ENOENT)\n\t\tbtrfs_wait_for_commit(root, 0);\n\n\treturn trans;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_sb",
          "args": [
            "sb"
          ],
          "line": 1949
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3272-3275",
          "snippet": "static inline struct btrfs_fs_info *btrfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline struct btrfs_fs_info *btrfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nstatic int btrfs_freeze(struct super_block *sb)\n{\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_root *root = btrfs_sb(sb)->tree_root;\n\n\ttrans = btrfs_attach_transaction_barrier(root);\n\tif (IS_ERR(trans)) {\n\t\t/* no transaction, don't bother */\n\t\tif (PTR_ERR(trans) == -ENOENT)\n\t\t\treturn 0;\n\t\treturn PTR_ERR(trans);\n\t}\n\treturn btrfs_commit_transaction(trans, root);\n}"
  },
  {
    "function_name": "btrfs_control_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
    "lines": "1914-1944",
    "snippet": "static long btrfs_control_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\tunsigned long arg)\n{\n\tstruct btrfs_ioctl_vol_args *vol;\n\tstruct btrfs_fs_devices *fs_devices;\n\tint ret = -ENOTTY;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tvol = memdup_user((void __user *)arg, sizeof(*vol));\n\tif (IS_ERR(vol))\n\t\treturn PTR_ERR(vol);\n\n\tswitch (cmd) {\n\tcase BTRFS_IOC_SCAN_DEV:\n\t\tret = btrfs_scan_one_device(vol->name, FMODE_READ,\n\t\t\t\t\t    &btrfs_fs_type, &fs_devices);\n\t\tbreak;\n\tcase BTRFS_IOC_DEVICES_READY:\n\t\tret = btrfs_scan_one_device(vol->name, FMODE_READ,\n\t\t\t\t\t    &btrfs_fs_type, &fs_devices);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tret = !(fs_devices->num_devices == fs_devices->total_devices);\n\t\tbreak;\n\t}\n\n\tkfree(vol);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/btrfs.h>",
      "#include \"qgroup.h\"",
      "#include \"tests/btrfs-tests.h\"",
      "#include \"backref.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"compression.h\"",
      "#include \"export.h\"",
      "#include \"volumes.h\"",
      "#include \"xattr.h\"",
      "#include \"props.h\"",
      "#include \"hash.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/namei.h>",
      "#include <linux/ctype.h>",
      "#include <linux/parser.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type btrfs_fs_type;",
      "static struct file_system_type btrfs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"btrfs\",\n\t.mount\t\t= btrfs_mount,\n\t.kill_sb\t= btrfs_kill_super,\n\t.fs_flags\t= FS_REQUIRES_DEV | FS_BINARY_MOUNTDATA,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "vol"
          ],
          "line": 1942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_scan_one_device",
          "args": [
            "vol->name",
            "FMODE_READ",
            "&btrfs_fs_type",
            "&fs_devices"
          ],
          "line": 1934
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_scan_one_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "881-970",
          "snippet": "int btrfs_scan_one_device(const char *path, fmode_t flags, void *holder,\n\t\t\t  struct btrfs_fs_devices **fs_devices_ret)\n{\n\tstruct btrfs_super_block *disk_super;\n\tstruct block_device *bdev;\n\tstruct page *page;\n\tvoid *p;\n\tint ret = -EINVAL;\n\tu64 devid;\n\tu64 transid;\n\tu64 total_devices;\n\tu64 bytenr;\n\tpgoff_t index;\n\n\t/*\n\t * we would like to check all the supers, but that would make\n\t * a btrfs mount succeed after a mkfs from a different FS.\n\t * So, we need to add a special mount option to scan for\n\t * later supers, using BTRFS_SUPER_MIRROR_MAX instead\n\t */\n\tbytenr = btrfs_sb_offset(0);\n\tflags |= FMODE_EXCL;\n\tmutex_lock(&uuid_mutex);\n\n\tbdev = blkdev_get_by_path(path, flags, holder);\n\n\tif (IS_ERR(bdev)) {\n\t\tret = PTR_ERR(bdev);\n\t\tgoto error;\n\t}\n\n\t/* make sure our super fits in the device */\n\tif (bytenr + PAGE_CACHE_SIZE >= i_size_read(bdev->bd_inode))\n\t\tgoto error_bdev_put;\n\n\t/* make sure our super fits in the page */\n\tif (sizeof(*disk_super) > PAGE_CACHE_SIZE)\n\t\tgoto error_bdev_put;\n\n\t/* make sure our super doesn't straddle pages on disk */\n\tindex = bytenr >> PAGE_CACHE_SHIFT;\n\tif ((bytenr + sizeof(*disk_super) - 1) >> PAGE_CACHE_SHIFT != index)\n\t\tgoto error_bdev_put;\n\n\t/* pull in the page with our super */\n\tpage = read_cache_page_gfp(bdev->bd_inode->i_mapping,\n\t\t\t\t   index, GFP_NOFS);\n\n\tif (IS_ERR_OR_NULL(page))\n\t\tgoto error_bdev_put;\n\n\tp = kmap(page);\n\n\t/* align our pointer to the offset of the super block */\n\tdisk_super = p + (bytenr & ~PAGE_CACHE_MASK);\n\n\tif (btrfs_super_bytenr(disk_super) != bytenr ||\n\t    btrfs_super_magic(disk_super) != BTRFS_MAGIC)\n\t\tgoto error_unmap;\n\n\tdevid = btrfs_stack_device_id(&disk_super->dev_item);\n\ttransid = btrfs_super_generation(disk_super);\n\ttotal_devices = btrfs_super_num_devices(disk_super);\n\n\tret = device_list_add(path, disk_super, devid, fs_devices_ret);\n\tif (ret > 0) {\n\t\tif (disk_super->label[0]) {\n\t\t\tif (disk_super->label[BTRFS_LABEL_SIZE - 1])\n\t\t\t\tdisk_super->label[BTRFS_LABEL_SIZE - 1] = '\\0';\n\t\t\tprintk(KERN_INFO \"BTRFS: device label %s \", disk_super->label);\n\t\t} else {\n\t\t\tprintk(KERN_INFO \"BTRFS: device fsid %pU \", disk_super->fsid);\n\t\t}\n\n\t\tprintk(KERN_CONT \"devid %llu transid %llu %s\\n\", devid, transid, path);\n\t\tret = 0;\n\t}\n\tif (!ret && fs_devices_ret)\n\t\t(*fs_devices_ret)->total_devices = total_devices;\n\nerror_unmap:\n\tkunmap(page);\n\tpage_cache_release(page);\n\nerror_bdev_put:\n\tblkdev_put(bdev, flags);\nerror:\n\tmutex_unlock(&uuid_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_scan_one_device(const char *path, fmode_t flags, void *holder,\n\t\t\t  struct btrfs_fs_devices **fs_devices_ret)\n{\n\tstruct btrfs_super_block *disk_super;\n\tstruct block_device *bdev;\n\tstruct page *page;\n\tvoid *p;\n\tint ret = -EINVAL;\n\tu64 devid;\n\tu64 transid;\n\tu64 total_devices;\n\tu64 bytenr;\n\tpgoff_t index;\n\n\t/*\n\t * we would like to check all the supers, but that would make\n\t * a btrfs mount succeed after a mkfs from a different FS.\n\t * So, we need to add a special mount option to scan for\n\t * later supers, using BTRFS_SUPER_MIRROR_MAX instead\n\t */\n\tbytenr = btrfs_sb_offset(0);\n\tflags |= FMODE_EXCL;\n\tmutex_lock(&uuid_mutex);\n\n\tbdev = blkdev_get_by_path(path, flags, holder);\n\n\tif (IS_ERR(bdev)) {\n\t\tret = PTR_ERR(bdev);\n\t\tgoto error;\n\t}\n\n\t/* make sure our super fits in the device */\n\tif (bytenr + PAGE_CACHE_SIZE >= i_size_read(bdev->bd_inode))\n\t\tgoto error_bdev_put;\n\n\t/* make sure our super fits in the page */\n\tif (sizeof(*disk_super) > PAGE_CACHE_SIZE)\n\t\tgoto error_bdev_put;\n\n\t/* make sure our super doesn't straddle pages on disk */\n\tindex = bytenr >> PAGE_CACHE_SHIFT;\n\tif ((bytenr + sizeof(*disk_super) - 1) >> PAGE_CACHE_SHIFT != index)\n\t\tgoto error_bdev_put;\n\n\t/* pull in the page with our super */\n\tpage = read_cache_page_gfp(bdev->bd_inode->i_mapping,\n\t\t\t\t   index, GFP_NOFS);\n\n\tif (IS_ERR_OR_NULL(page))\n\t\tgoto error_bdev_put;\n\n\tp = kmap(page);\n\n\t/* align our pointer to the offset of the super block */\n\tdisk_super = p + (bytenr & ~PAGE_CACHE_MASK);\n\n\tif (btrfs_super_bytenr(disk_super) != bytenr ||\n\t    btrfs_super_magic(disk_super) != BTRFS_MAGIC)\n\t\tgoto error_unmap;\n\n\tdevid = btrfs_stack_device_id(&disk_super->dev_item);\n\ttransid = btrfs_super_generation(disk_super);\n\ttotal_devices = btrfs_super_num_devices(disk_super);\n\n\tret = device_list_add(path, disk_super, devid, fs_devices_ret);\n\tif (ret > 0) {\n\t\tif (disk_super->label[0]) {\n\t\t\tif (disk_super->label[BTRFS_LABEL_SIZE - 1])\n\t\t\t\tdisk_super->label[BTRFS_LABEL_SIZE - 1] = '\\0';\n\t\t\tprintk(KERN_INFO \"BTRFS: device label %s \", disk_super->label);\n\t\t} else {\n\t\t\tprintk(KERN_INFO \"BTRFS: device fsid %pU \", disk_super->fsid);\n\t\t}\n\n\t\tprintk(KERN_CONT \"devid %llu transid %llu %s\\n\", devid, transid, path);\n\t\tret = 0;\n\t}\n\tif (!ret && fs_devices_ret)\n\t\t(*fs_devices_ret)->total_devices = total_devices;\n\nerror_unmap:\n\tkunmap(page);\n\tpage_cache_release(page);\n\nerror_bdev_put:\n\tblkdev_put(bdev, flags);\nerror:\n\tmutex_unlock(&uuid_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "vol"
          ],
          "line": 1926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "vol"
          ],
          "line": 1925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user",
          "args": [
            "(void __user *)arg",
            "sizeof(*vol)"
          ],
          "line": 1924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 1921
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nstatic struct file_system_type btrfs_fs_type;\nstatic struct file_system_type btrfs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"btrfs\",\n\t.mount\t\t= btrfs_mount,\n\t.kill_sb\t= btrfs_kill_super,\n\t.fs_flags\t= FS_REQUIRES_DEV | FS_BINARY_MOUNTDATA,\n};\n\nstatic long btrfs_control_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\tunsigned long arg)\n{\n\tstruct btrfs_ioctl_vol_args *vol;\n\tstruct btrfs_fs_devices *fs_devices;\n\tint ret = -ENOTTY;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tvol = memdup_user((void __user *)arg, sizeof(*vol));\n\tif (IS_ERR(vol))\n\t\treturn PTR_ERR(vol);\n\n\tswitch (cmd) {\n\tcase BTRFS_IOC_SCAN_DEV:\n\t\tret = btrfs_scan_one_device(vol->name, FMODE_READ,\n\t\t\t\t\t    &btrfs_fs_type, &fs_devices);\n\t\tbreak;\n\tcase BTRFS_IOC_DEVICES_READY:\n\t\tret = btrfs_scan_one_device(vol->name, FMODE_READ,\n\t\t\t\t\t    &btrfs_fs_type, &fs_devices);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tret = !(fs_devices->num_devices == fs_devices->total_devices);\n\t\tbreak;\n\t}\n\n\tkfree(vol);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_kill_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
    "lines": "1895-1900",
    "snippet": "static void btrfs_kill_super(struct super_block *sb)\n{\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(sb);\n\tkill_anon_super(sb);\n\tfree_fs_info(fs_info);\n}",
    "includes": [
      "#include <trace/events/btrfs.h>",
      "#include \"qgroup.h\"",
      "#include \"tests/btrfs-tests.h\"",
      "#include \"backref.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"compression.h\"",
      "#include \"export.h\"",
      "#include \"volumes.h\"",
      "#include \"xattr.h\"",
      "#include \"props.h\"",
      "#include \"hash.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/namei.h>",
      "#include <linux/ctype.h>",
      "#include <linux/parser.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_fs_info",
          "args": [
            "fs_info"
          ],
          "line": 1899
        },
        "resolved": true,
        "details": {
          "function_name": "free_fs_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3632-3647",
          "snippet": "static inline void free_fs_info(struct btrfs_fs_info *fs_info)\n{\n\tkfree(fs_info->balance_ctl);\n\tkfree(fs_info->delayed_root);\n\tkfree(fs_info->extent_root);\n\tkfree(fs_info->tree_root);\n\tkfree(fs_info->chunk_root);\n\tkfree(fs_info->dev_root);\n\tkfree(fs_info->csum_root);\n\tkfree(fs_info->quota_root);\n\tkfree(fs_info->uuid_root);\n\tkfree(fs_info->super_copy);\n\tkfree(fs_info->super_for_commit);\n\tsecurity_free_mnt_opts(&fs_info->security_opts);\n\tkfree(fs_info);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void free_fs_info(struct btrfs_fs_info *fs_info)\n{\n\tkfree(fs_info->balance_ctl);\n\tkfree(fs_info->delayed_root);\n\tkfree(fs_info->extent_root);\n\tkfree(fs_info->tree_root);\n\tkfree(fs_info->chunk_root);\n\tkfree(fs_info->dev_root);\n\tkfree(fs_info->csum_root);\n\tkfree(fs_info->quota_root);\n\tkfree(fs_info->uuid_root);\n\tkfree(fs_info->super_copy);\n\tkfree(fs_info->super_for_commit);\n\tsecurity_free_mnt_opts(&fs_info->security_opts);\n\tkfree(fs_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill_anon_super",
          "args": [
            "sb"
          ],
          "line": 1898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_sb",
          "args": [
            "sb"
          ],
          "line": 1897
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3272-3275",
          "snippet": "static inline struct btrfs_fs_info *btrfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline struct btrfs_fs_info *btrfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nstatic void btrfs_kill_super(struct super_block *sb)\n{\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(sb);\n\tkill_anon_super(sb);\n\tfree_fs_info(fs_info);\n}"
  },
  {
    "function_name": "btrfs_statfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
    "lines": "1819-1893",
    "snippet": "static int btrfs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(dentry->d_sb);\n\tstruct btrfs_super_block *disk_super = fs_info->super_copy;\n\tstruct list_head *head = &fs_info->space_info;\n\tstruct btrfs_space_info *found;\n\tu64 total_used = 0;\n\tu64 total_free_data = 0;\n\tint bits = dentry->d_sb->s_blocksize_bits;\n\t__be32 *fsid = (__be32 *)fs_info->fsid;\n\tunsigned factor = 1;\n\tstruct btrfs_block_rsv *block_rsv = &fs_info->global_block_rsv;\n\tint ret;\n\n\t/*\n\t * holding chunk_muext to avoid allocating new chunks, holding\n\t * device_list_mutex to avoid the device being removed\n\t */\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(found, head, list) {\n\t\tif (found->flags & BTRFS_BLOCK_GROUP_DATA) {\n\t\t\tint i;\n\n\t\t\ttotal_free_data += found->disk_total - found->disk_used;\n\t\t\ttotal_free_data -=\n\t\t\t\tbtrfs_account_ro_block_groups_free_space(found);\n\n\t\t\tfor (i = 0; i < BTRFS_NR_RAID_TYPES; i++) {\n\t\t\t\tif (!list_empty(&found->block_groups[i])) {\n\t\t\t\t\tswitch (i) {\n\t\t\t\t\tcase BTRFS_RAID_DUP:\n\t\t\t\t\tcase BTRFS_RAID_RAID1:\n\t\t\t\t\tcase BTRFS_RAID_RAID10:\n\t\t\t\t\t\tfactor = 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttotal_used += found->disk_used;\n\t}\n\n\trcu_read_unlock();\n\n\tbuf->f_blocks = div_u64(btrfs_super_total_bytes(disk_super), factor);\n\tbuf->f_blocks >>= bits;\n\tbuf->f_bfree = buf->f_blocks - (div_u64(total_used, factor) >> bits);\n\n\t/* Account global block reserve as used, it's in logical size already */\n\tspin_lock(&block_rsv->lock);\n\tbuf->f_bfree -= block_rsv->size >> bits;\n\tspin_unlock(&block_rsv->lock);\n\n\tbuf->f_bavail = div_u64(total_free_data, factor);\n\tret = btrfs_calc_avail_data_space(fs_info->tree_root, &total_free_data);\n\tif (ret)\n\t\treturn ret;\n\tbuf->f_bavail += div_u64(total_free_data, factor);\n\tbuf->f_bavail = buf->f_bavail >> bits;\n\n\tbuf->f_type = BTRFS_SUPER_MAGIC;\n\tbuf->f_bsize = dentry->d_sb->s_blocksize;\n\tbuf->f_namelen = BTRFS_NAME_LEN;\n\n\t/* We treat it as constant endianness (it doesn't matter _which_)\n\t   because we want the fsid to come out the same whether mounted\n\t   on a big-endian or little-endian host */\n\tbuf->f_fsid.val[0] = be32_to_cpu(fsid[0]) ^ be32_to_cpu(fsid[2]);\n\tbuf->f_fsid.val[1] = be32_to_cpu(fsid[1]) ^ be32_to_cpu(fsid[3]);\n\t/* Mask in the root object ID too, to disambiguate subvols */\n\tbuf->f_fsid.val[0] ^= BTRFS_I(dentry->d_inode)->root->objectid >> 32;\n\tbuf->f_fsid.val[1] ^= BTRFS_I(dentry->d_inode)->root->objectid;\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/btrfs.h>",
      "#include \"qgroup.h\"",
      "#include \"tests/btrfs-tests.h\"",
      "#include \"backref.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"compression.h\"",
      "#include \"export.h\"",
      "#include \"volumes.h\"",
      "#include \"xattr.h\"",
      "#include \"props.h\"",
      "#include \"hash.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/namei.h>",
      "#include <linux/ctype.h>",
      "#include <linux/parser.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BTRFS_I",
          "args": [
            "dentry->d_inode"
          ],
          "line": 1890
        },
        "resolved": true,
        "details": {
          "function_name": "BTRFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "196-199",
          "snippet": "static inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline struct btrfs_inode *BTRFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct btrfs_inode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "fsid[3]"
          ],
          "line": 1887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "fsid[1]"
          ],
          "line": 1887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "fsid[2]"
          ],
          "line": 1886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "fsid[0]"
          ],
          "line": 1886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "total_free_data",
            "factor"
          ],
          "line": 1876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_calc_avail_data_space",
          "args": [
            "fs_info->tree_root",
            "&total_free_data"
          ],
          "line": 1873
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_calc_avail_data_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "1650-1802",
          "snippet": "static int btrfs_calc_avail_data_space(struct btrfs_root *root, u64 *free_bytes)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_device_info *devices_info;\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tstruct btrfs_device *device;\n\tu64 skip_space;\n\tu64 type;\n\tu64 avail_space;\n\tu64 used_space;\n\tu64 min_stripe_size;\n\tint min_stripes = 1, num_stripes = 1;\n\tint i = 0, nr_devices;\n\tint ret;\n\n\t/*\n\t * We aren't under the device list lock, so this is racey-ish, but good\n\t * enough for our purposes.\n\t */\n\tnr_devices = fs_info->fs_devices->open_devices;\n\tif (!nr_devices) {\n\t\tsmp_mb();\n\t\tnr_devices = fs_info->fs_devices->open_devices;\n\t\tASSERT(nr_devices);\n\t\tif (!nr_devices) {\n\t\t\t*free_bytes = 0;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tdevices_info = kmalloc_array(nr_devices, sizeof(*devices_info),\n\t\t\t       GFP_NOFS);\n\tif (!devices_info)\n\t\treturn -ENOMEM;\n\n\t/* calc min stripe number for data space alloction */\n\ttype = btrfs_get_alloc_profile(root, 1);\n\tif (type & BTRFS_BLOCK_GROUP_RAID0) {\n\t\tmin_stripes = 2;\n\t\tnum_stripes = nr_devices;\n\t} else if (type & BTRFS_BLOCK_GROUP_RAID1) {\n\t\tmin_stripes = 2;\n\t\tnum_stripes = 2;\n\t} else if (type & BTRFS_BLOCK_GROUP_RAID10) {\n\t\tmin_stripes = 4;\n\t\tnum_stripes = 4;\n\t}\n\n\tif (type & BTRFS_BLOCK_GROUP_DUP)\n\t\tmin_stripe_size = 2 * BTRFS_STRIPE_LEN;\n\telse\n\t\tmin_stripe_size = BTRFS_STRIPE_LEN;\n\n\tif (fs_info->alloc_start)\n\t\tmutex_lock(&fs_devices->device_list_mutex);\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(device, &fs_devices->devices, dev_list) {\n\t\tif (!device->in_fs_metadata || !device->bdev ||\n\t\t    device->is_tgtdev_for_dev_replace)\n\t\t\tcontinue;\n\n\t\tif (i >= nr_devices)\n\t\t\tbreak;\n\n\t\tavail_space = device->total_bytes - device->bytes_used;\n\n\t\t/* align with stripe_len */\n\t\tdo_div(avail_space, BTRFS_STRIPE_LEN);\n\t\tavail_space *= BTRFS_STRIPE_LEN;\n\n\t\t/*\n\t\t * In order to avoid overwritting the superblock on the drive,\n\t\t * btrfs starts at an offset of at least 1MB when doing chunk\n\t\t * allocation.\n\t\t */\n\t\tskip_space = 1024 * 1024;\n\n\t\t/* user can set the offset in fs_info->alloc_start. */\n\t\tif (fs_info->alloc_start &&\n\t\t    fs_info->alloc_start + BTRFS_STRIPE_LEN <=\n\t\t    device->total_bytes) {\n\t\t\trcu_read_unlock();\n\t\t\tskip_space = max(fs_info->alloc_start, skip_space);\n\n\t\t\t/*\n\t\t\t * btrfs can not use the free space in\n\t\t\t * [0, skip_space - 1], we must subtract it from the\n\t\t\t * total. In order to implement it, we account the used\n\t\t\t * space in this range first.\n\t\t\t */\n\t\t\tret = btrfs_account_dev_extents_size(device, 0,\n\t\t\t\t\t\t\t     skip_space - 1,\n\t\t\t\t\t\t\t     &used_space);\n\t\t\tif (ret) {\n\t\t\t\tkfree(devices_info);\n\t\t\t\tmutex_unlock(&fs_devices->device_list_mutex);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\trcu_read_lock();\n\n\t\t\t/* calc the free space in [0, skip_space - 1] */\n\t\t\tskip_space -= used_space;\n\t\t}\n\n\t\t/*\n\t\t * we can use the free space in [0, skip_space - 1], subtract\n\t\t * it from the total.\n\t\t */\n\t\tif (avail_space && avail_space >= skip_space)\n\t\t\tavail_space -= skip_space;\n\t\telse\n\t\t\tavail_space = 0;\n\n\t\tif (avail_space < min_stripe_size)\n\t\t\tcontinue;\n\n\t\tdevices_info[i].dev = device;\n\t\tdevices_info[i].max_avail = avail_space;\n\n\t\ti++;\n\t}\n\trcu_read_unlock();\n\tif (fs_info->alloc_start)\n\t\tmutex_unlock(&fs_devices->device_list_mutex);\n\n\tnr_devices = i;\n\n\tbtrfs_descending_sort_devices(devices_info, nr_devices);\n\n\ti = nr_devices - 1;\n\tavail_space = 0;\n\twhile (nr_devices >= min_stripes) {\n\t\tif (num_stripes > nr_devices)\n\t\t\tnum_stripes = nr_devices;\n\n\t\tif (devices_info[i].max_avail >= min_stripe_size) {\n\t\t\tint j;\n\t\t\tu64 alloc_size;\n\n\t\t\tavail_space += devices_info[i].max_avail * num_stripes;\n\t\t\talloc_size = devices_info[i].max_avail;\n\t\t\tfor (j = i + 1 - num_stripes; j <= i; j++)\n\t\t\t\tdevices_info[j].max_avail -= alloc_size;\n\t\t}\n\t\ti--;\n\t\tnr_devices--;\n\t}\n\n\tkfree(devices_info);\n\t*free_bytes = avail_space;\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_remount(struct super_block *sb, int *flags, char *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nstatic int btrfs_remount(struct super_block *sb, int *flags, char *data);\n\nstatic int btrfs_calc_avail_data_space(struct btrfs_root *root, u64 *free_bytes)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_device_info *devices_info;\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tstruct btrfs_device *device;\n\tu64 skip_space;\n\tu64 type;\n\tu64 avail_space;\n\tu64 used_space;\n\tu64 min_stripe_size;\n\tint min_stripes = 1, num_stripes = 1;\n\tint i = 0, nr_devices;\n\tint ret;\n\n\t/*\n\t * We aren't under the device list lock, so this is racey-ish, but good\n\t * enough for our purposes.\n\t */\n\tnr_devices = fs_info->fs_devices->open_devices;\n\tif (!nr_devices) {\n\t\tsmp_mb();\n\t\tnr_devices = fs_info->fs_devices->open_devices;\n\t\tASSERT(nr_devices);\n\t\tif (!nr_devices) {\n\t\t\t*free_bytes = 0;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tdevices_info = kmalloc_array(nr_devices, sizeof(*devices_info),\n\t\t\t       GFP_NOFS);\n\tif (!devices_info)\n\t\treturn -ENOMEM;\n\n\t/* calc min stripe number for data space alloction */\n\ttype = btrfs_get_alloc_profile(root, 1);\n\tif (type & BTRFS_BLOCK_GROUP_RAID0) {\n\t\tmin_stripes = 2;\n\t\tnum_stripes = nr_devices;\n\t} else if (type & BTRFS_BLOCK_GROUP_RAID1) {\n\t\tmin_stripes = 2;\n\t\tnum_stripes = 2;\n\t} else if (type & BTRFS_BLOCK_GROUP_RAID10) {\n\t\tmin_stripes = 4;\n\t\tnum_stripes = 4;\n\t}\n\n\tif (type & BTRFS_BLOCK_GROUP_DUP)\n\t\tmin_stripe_size = 2 * BTRFS_STRIPE_LEN;\n\telse\n\t\tmin_stripe_size = BTRFS_STRIPE_LEN;\n\n\tif (fs_info->alloc_start)\n\t\tmutex_lock(&fs_devices->device_list_mutex);\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(device, &fs_devices->devices, dev_list) {\n\t\tif (!device->in_fs_metadata || !device->bdev ||\n\t\t    device->is_tgtdev_for_dev_replace)\n\t\t\tcontinue;\n\n\t\tif (i >= nr_devices)\n\t\t\tbreak;\n\n\t\tavail_space = device->total_bytes - device->bytes_used;\n\n\t\t/* align with stripe_len */\n\t\tdo_div(avail_space, BTRFS_STRIPE_LEN);\n\t\tavail_space *= BTRFS_STRIPE_LEN;\n\n\t\t/*\n\t\t * In order to avoid overwritting the superblock on the drive,\n\t\t * btrfs starts at an offset of at least 1MB when doing chunk\n\t\t * allocation.\n\t\t */\n\t\tskip_space = 1024 * 1024;\n\n\t\t/* user can set the offset in fs_info->alloc_start. */\n\t\tif (fs_info->alloc_start &&\n\t\t    fs_info->alloc_start + BTRFS_STRIPE_LEN <=\n\t\t    device->total_bytes) {\n\t\t\trcu_read_unlock();\n\t\t\tskip_space = max(fs_info->alloc_start, skip_space);\n\n\t\t\t/*\n\t\t\t * btrfs can not use the free space in\n\t\t\t * [0, skip_space - 1], we must subtract it from the\n\t\t\t * total. In order to implement it, we account the used\n\t\t\t * space in this range first.\n\t\t\t */\n\t\t\tret = btrfs_account_dev_extents_size(device, 0,\n\t\t\t\t\t\t\t     skip_space - 1,\n\t\t\t\t\t\t\t     &used_space);\n\t\t\tif (ret) {\n\t\t\t\tkfree(devices_info);\n\t\t\t\tmutex_unlock(&fs_devices->device_list_mutex);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\trcu_read_lock();\n\n\t\t\t/* calc the free space in [0, skip_space - 1] */\n\t\t\tskip_space -= used_space;\n\t\t}\n\n\t\t/*\n\t\t * we can use the free space in [0, skip_space - 1], subtract\n\t\t * it from the total.\n\t\t */\n\t\tif (avail_space && avail_space >= skip_space)\n\t\t\tavail_space -= skip_space;\n\t\telse\n\t\t\tavail_space = 0;\n\n\t\tif (avail_space < min_stripe_size)\n\t\t\tcontinue;\n\n\t\tdevices_info[i].dev = device;\n\t\tdevices_info[i].max_avail = avail_space;\n\n\t\ti++;\n\t}\n\trcu_read_unlock();\n\tif (fs_info->alloc_start)\n\t\tmutex_unlock(&fs_devices->device_list_mutex);\n\n\tnr_devices = i;\n\n\tbtrfs_descending_sort_devices(devices_info, nr_devices);\n\n\ti = nr_devices - 1;\n\tavail_space = 0;\n\twhile (nr_devices >= min_stripes) {\n\t\tif (num_stripes > nr_devices)\n\t\t\tnum_stripes = nr_devices;\n\n\t\tif (devices_info[i].max_avail >= min_stripe_size) {\n\t\t\tint j;\n\t\t\tu64 alloc_size;\n\n\t\t\tavail_space += devices_info[i].max_avail * num_stripes;\n\t\t\talloc_size = devices_info[i].max_avail;\n\t\t\tfor (j = i + 1 - num_stripes; j <= i; j++)\n\t\t\t\tdevices_info[j].max_avail -= alloc_size;\n\t\t}\n\t\ti--;\n\t\tnr_devices--;\n\t}\n\n\tkfree(devices_info);\n\t*free_bytes = avail_space;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "total_free_data",
            "factor"
          ],
          "line": 1872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&block_rsv->lock"
          ],
          "line": 1870
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&block_rsv->lock"
          ],
          "line": 1868
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "total_used",
            "factor"
          ],
          "line": 1865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "btrfs_super_total_bytes(disk_super)",
            "factor"
          ],
          "line": 1863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_total_bytes",
          "args": [
            "disk_super"
          ],
          "line": 1863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&found->block_groups[i]"
          ],
          "line": 1847
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_account_ro_block_groups_free_space",
          "args": [
            "found"
          ],
          "line": 1844
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_account_ro_block_groups_free_space",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "8571-8606",
          "snippet": "u64 btrfs_account_ro_block_groups_free_space(struct btrfs_space_info *sinfo)\n{\n\tstruct btrfs_block_group_cache *block_group;\n\tu64 free_bytes = 0;\n\tint factor;\n\n\t/* It's df, we don't care if it's racey */\n\tif (list_empty(&sinfo->ro_bgs))\n\t\treturn 0;\n\n\tspin_lock(&sinfo->lock);\n\tlist_for_each_entry(block_group, &sinfo->ro_bgs, ro_list) {\n\t\tspin_lock(&block_group->lock);\n\n\t\tif (!block_group->ro) {\n\t\t\tspin_unlock(&block_group->lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (block_group->flags & (BTRFS_BLOCK_GROUP_RAID1 |\n\t\t\t\t\t  BTRFS_BLOCK_GROUP_RAID10 |\n\t\t\t\t\t  BTRFS_BLOCK_GROUP_DUP))\n\t\t\tfactor = 2;\n\t\telse\n\t\t\tfactor = 1;\n\n\t\tfree_bytes += (block_group->key.offset -\n\t\t\t       btrfs_block_group_used(&block_group->item)) *\n\t\t\t       factor;\n\n\t\tspin_unlock(&block_group->lock);\n\t}\n\tspin_unlock(&sinfo->lock);\n\n\treturn free_bytes;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int find_next_key(struct btrfs_path *path, int level,\n\t\t\t struct btrfs_key *key);",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic int find_next_key(struct btrfs_path *path, int level,\n\t\t\t struct btrfs_key *key);\nstatic noinline struct;\n\nu64 btrfs_account_ro_block_groups_free_space(struct btrfs_space_info *sinfo)\n{\n\tstruct btrfs_block_group_cache *block_group;\n\tu64 free_bytes = 0;\n\tint factor;\n\n\t/* It's df, we don't care if it's racey */\n\tif (list_empty(&sinfo->ro_bgs))\n\t\treturn 0;\n\n\tspin_lock(&sinfo->lock);\n\tlist_for_each_entry(block_group, &sinfo->ro_bgs, ro_list) {\n\t\tspin_lock(&block_group->lock);\n\n\t\tif (!block_group->ro) {\n\t\t\tspin_unlock(&block_group->lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (block_group->flags & (BTRFS_BLOCK_GROUP_RAID1 |\n\t\t\t\t\t  BTRFS_BLOCK_GROUP_RAID10 |\n\t\t\t\t\t  BTRFS_BLOCK_GROUP_DUP))\n\t\t\tfactor = 2;\n\t\telse\n\t\t\tfactor = 1;\n\n\t\tfree_bytes += (block_group->key.offset -\n\t\t\t       btrfs_block_group_used(&block_group->item)) *\n\t\t\t       factor;\n\n\t\tspin_unlock(&block_group->lock);\n\t}\n\tspin_unlock(&sinfo->lock);\n\n\treturn free_bytes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "found",
            "head",
            "list"
          ],
          "line": 1838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_sb",
          "args": [
            "dentry->d_sb"
          ],
          "line": 1821
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3272-3275",
          "snippet": "static inline struct btrfs_fs_info *btrfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline struct btrfs_fs_info *btrfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nstatic int btrfs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(dentry->d_sb);\n\tstruct btrfs_super_block *disk_super = fs_info->super_copy;\n\tstruct list_head *head = &fs_info->space_info;\n\tstruct btrfs_space_info *found;\n\tu64 total_used = 0;\n\tu64 total_free_data = 0;\n\tint bits = dentry->d_sb->s_blocksize_bits;\n\t__be32 *fsid = (__be32 *)fs_info->fsid;\n\tunsigned factor = 1;\n\tstruct btrfs_block_rsv *block_rsv = &fs_info->global_block_rsv;\n\tint ret;\n\n\t/*\n\t * holding chunk_muext to avoid allocating new chunks, holding\n\t * device_list_mutex to avoid the device being removed\n\t */\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(found, head, list) {\n\t\tif (found->flags & BTRFS_BLOCK_GROUP_DATA) {\n\t\t\tint i;\n\n\t\t\ttotal_free_data += found->disk_total - found->disk_used;\n\t\t\ttotal_free_data -=\n\t\t\t\tbtrfs_account_ro_block_groups_free_space(found);\n\n\t\t\tfor (i = 0; i < BTRFS_NR_RAID_TYPES; i++) {\n\t\t\t\tif (!list_empty(&found->block_groups[i])) {\n\t\t\t\t\tswitch (i) {\n\t\t\t\t\tcase BTRFS_RAID_DUP:\n\t\t\t\t\tcase BTRFS_RAID_RAID1:\n\t\t\t\t\tcase BTRFS_RAID_RAID10:\n\t\t\t\t\t\tfactor = 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttotal_used += found->disk_used;\n\t}\n\n\trcu_read_unlock();\n\n\tbuf->f_blocks = div_u64(btrfs_super_total_bytes(disk_super), factor);\n\tbuf->f_blocks >>= bits;\n\tbuf->f_bfree = buf->f_blocks - (div_u64(total_used, factor) >> bits);\n\n\t/* Account global block reserve as used, it's in logical size already */\n\tspin_lock(&block_rsv->lock);\n\tbuf->f_bfree -= block_rsv->size >> bits;\n\tspin_unlock(&block_rsv->lock);\n\n\tbuf->f_bavail = div_u64(total_free_data, factor);\n\tret = btrfs_calc_avail_data_space(fs_info->tree_root, &total_free_data);\n\tif (ret)\n\t\treturn ret;\n\tbuf->f_bavail += div_u64(total_free_data, factor);\n\tbuf->f_bavail = buf->f_bavail >> bits;\n\n\tbuf->f_type = BTRFS_SUPER_MAGIC;\n\tbuf->f_bsize = dentry->d_sb->s_blocksize;\n\tbuf->f_namelen = BTRFS_NAME_LEN;\n\n\t/* We treat it as constant endianness (it doesn't matter _which_)\n\t   because we want the fsid to come out the same whether mounted\n\t   on a big-endian or little-endian host */\n\tbuf->f_fsid.val[0] = be32_to_cpu(fsid[0]) ^ be32_to_cpu(fsid[2]);\n\tbuf->f_fsid.val[1] = be32_to_cpu(fsid[1]) ^ be32_to_cpu(fsid[3]);\n\t/* Mask in the root object ID too, to disambiguate subvols */\n\tbuf->f_fsid.val[0] ^= BTRFS_I(dentry->d_inode)->root->objectid >> 32;\n\tbuf->f_fsid.val[1] ^= BTRFS_I(dentry->d_inode)->root->objectid;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_calc_avail_data_space",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
    "lines": "1650-1802",
    "snippet": "static int btrfs_calc_avail_data_space(struct btrfs_root *root, u64 *free_bytes)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_device_info *devices_info;\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tstruct btrfs_device *device;\n\tu64 skip_space;\n\tu64 type;\n\tu64 avail_space;\n\tu64 used_space;\n\tu64 min_stripe_size;\n\tint min_stripes = 1, num_stripes = 1;\n\tint i = 0, nr_devices;\n\tint ret;\n\n\t/*\n\t * We aren't under the device list lock, so this is racey-ish, but good\n\t * enough for our purposes.\n\t */\n\tnr_devices = fs_info->fs_devices->open_devices;\n\tif (!nr_devices) {\n\t\tsmp_mb();\n\t\tnr_devices = fs_info->fs_devices->open_devices;\n\t\tASSERT(nr_devices);\n\t\tif (!nr_devices) {\n\t\t\t*free_bytes = 0;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tdevices_info = kmalloc_array(nr_devices, sizeof(*devices_info),\n\t\t\t       GFP_NOFS);\n\tif (!devices_info)\n\t\treturn -ENOMEM;\n\n\t/* calc min stripe number for data space alloction */\n\ttype = btrfs_get_alloc_profile(root, 1);\n\tif (type & BTRFS_BLOCK_GROUP_RAID0) {\n\t\tmin_stripes = 2;\n\t\tnum_stripes = nr_devices;\n\t} else if (type & BTRFS_BLOCK_GROUP_RAID1) {\n\t\tmin_stripes = 2;\n\t\tnum_stripes = 2;\n\t} else if (type & BTRFS_BLOCK_GROUP_RAID10) {\n\t\tmin_stripes = 4;\n\t\tnum_stripes = 4;\n\t}\n\n\tif (type & BTRFS_BLOCK_GROUP_DUP)\n\t\tmin_stripe_size = 2 * BTRFS_STRIPE_LEN;\n\telse\n\t\tmin_stripe_size = BTRFS_STRIPE_LEN;\n\n\tif (fs_info->alloc_start)\n\t\tmutex_lock(&fs_devices->device_list_mutex);\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(device, &fs_devices->devices, dev_list) {\n\t\tif (!device->in_fs_metadata || !device->bdev ||\n\t\t    device->is_tgtdev_for_dev_replace)\n\t\t\tcontinue;\n\n\t\tif (i >= nr_devices)\n\t\t\tbreak;\n\n\t\tavail_space = device->total_bytes - device->bytes_used;\n\n\t\t/* align with stripe_len */\n\t\tdo_div(avail_space, BTRFS_STRIPE_LEN);\n\t\tavail_space *= BTRFS_STRIPE_LEN;\n\n\t\t/*\n\t\t * In order to avoid overwritting the superblock on the drive,\n\t\t * btrfs starts at an offset of at least 1MB when doing chunk\n\t\t * allocation.\n\t\t */\n\t\tskip_space = 1024 * 1024;\n\n\t\t/* user can set the offset in fs_info->alloc_start. */\n\t\tif (fs_info->alloc_start &&\n\t\t    fs_info->alloc_start + BTRFS_STRIPE_LEN <=\n\t\t    device->total_bytes) {\n\t\t\trcu_read_unlock();\n\t\t\tskip_space = max(fs_info->alloc_start, skip_space);\n\n\t\t\t/*\n\t\t\t * btrfs can not use the free space in\n\t\t\t * [0, skip_space - 1], we must subtract it from the\n\t\t\t * total. In order to implement it, we account the used\n\t\t\t * space in this range first.\n\t\t\t */\n\t\t\tret = btrfs_account_dev_extents_size(device, 0,\n\t\t\t\t\t\t\t     skip_space - 1,\n\t\t\t\t\t\t\t     &used_space);\n\t\t\tif (ret) {\n\t\t\t\tkfree(devices_info);\n\t\t\t\tmutex_unlock(&fs_devices->device_list_mutex);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\trcu_read_lock();\n\n\t\t\t/* calc the free space in [0, skip_space - 1] */\n\t\t\tskip_space -= used_space;\n\t\t}\n\n\t\t/*\n\t\t * we can use the free space in [0, skip_space - 1], subtract\n\t\t * it from the total.\n\t\t */\n\t\tif (avail_space && avail_space >= skip_space)\n\t\t\tavail_space -= skip_space;\n\t\telse\n\t\t\tavail_space = 0;\n\n\t\tif (avail_space < min_stripe_size)\n\t\t\tcontinue;\n\n\t\tdevices_info[i].dev = device;\n\t\tdevices_info[i].max_avail = avail_space;\n\n\t\ti++;\n\t}\n\trcu_read_unlock();\n\tif (fs_info->alloc_start)\n\t\tmutex_unlock(&fs_devices->device_list_mutex);\n\n\tnr_devices = i;\n\n\tbtrfs_descending_sort_devices(devices_info, nr_devices);\n\n\ti = nr_devices - 1;\n\tavail_space = 0;\n\twhile (nr_devices >= min_stripes) {\n\t\tif (num_stripes > nr_devices)\n\t\t\tnum_stripes = nr_devices;\n\n\t\tif (devices_info[i].max_avail >= min_stripe_size) {\n\t\t\tint j;\n\t\t\tu64 alloc_size;\n\n\t\t\tavail_space += devices_info[i].max_avail * num_stripes;\n\t\t\talloc_size = devices_info[i].max_avail;\n\t\t\tfor (j = i + 1 - num_stripes; j <= i; j++)\n\t\t\t\tdevices_info[j].max_avail -= alloc_size;\n\t\t}\n\t\ti--;\n\t\tnr_devices--;\n\t}\n\n\tkfree(devices_info);\n\t*free_bytes = avail_space;\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/btrfs.h>",
      "#include \"qgroup.h\"",
      "#include \"tests/btrfs-tests.h\"",
      "#include \"backref.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"compression.h\"",
      "#include \"export.h\"",
      "#include \"volumes.h\"",
      "#include \"xattr.h\"",
      "#include \"props.h\"",
      "#include \"hash.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/namei.h>",
      "#include <linux/ctype.h>",
      "#include <linux/parser.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btrfs_remount(struct super_block *sb, int *flags, char *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "devices_info"
          ],
          "line": 1799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_descending_sort_devices",
          "args": [
            "devices_info",
            "nr_devices"
          ],
          "line": 1778
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_descending_sort_devices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "1638-1644",
          "snippet": "static inline void btrfs_descending_sort_devices(\n\t\t\t\t\tstruct btrfs_device_info *devices,\n\t\t\t\t\tsize_t nr_devices)\n{\n\tsort(devices, nr_devices, sizeof(struct btrfs_device_info),\n\t     btrfs_cmp_device_free_bytes, NULL);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nstatic inline void btrfs_descending_sort_devices(\n\t\t\t\t\tstruct btrfs_device_info *devices,\n\t\t\t\t\tsize_t nr_devices)\n{\n\tsort(devices, nr_devices, sizeof(struct btrfs_device_info),\n\t     btrfs_cmp_device_free_bytes, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_devices->device_list_mutex"
          ],
          "line": 1774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_devices->device_list_mutex"
          ],
          "line": 1745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "devices_info"
          ],
          "line": 1744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_account_dev_extents_size",
          "args": [
            "device",
            "0",
            "skip_space - 1",
            "&used_space"
          ],
          "line": 1740
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_account_dev_extents_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "973-1054",
          "snippet": "int btrfs_account_dev_extents_size(struct btrfs_device *device, u64 start,\n\t\t\t\t   u64 end, u64 *length)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_root *root = device->dev_root;\n\tstruct btrfs_dev_extent *dev_extent;\n\tstruct btrfs_path *path;\n\tu64 extent_end;\n\tint ret;\n\tint slot;\n\tstruct extent_buffer *l;\n\n\t*length = 0;\n\n\tif (start >= device->total_bytes || device->is_tgtdev_for_dev_replace)\n\t\treturn 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tpath->reada = 2;\n\n\tkey.objectid = device->devid;\n\tkey.offset = start;\n\tkey.type = BTRFS_DEV_EXTENT_KEY;\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret > 0) {\n\t\tret = btrfs_previous_item(root, path, key.objectid, key.type);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\twhile (1) {\n\t\tl = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tif (slot >= btrfs_header_nritems(l)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret == 0)\n\t\t\t\tcontinue;\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\n\t\t\tbreak;\n\t\t}\n\t\tbtrfs_item_key_to_cpu(l, &key, slot);\n\n\t\tif (key.objectid < device->devid)\n\t\t\tgoto next;\n\n\t\tif (key.objectid > device->devid)\n\t\t\tbreak;\n\n\t\tif (key.type != BTRFS_DEV_EXTENT_KEY)\n\t\t\tgoto next;\n\n\t\tdev_extent = btrfs_item_ptr(l, slot, struct btrfs_dev_extent);\n\t\textent_end = key.offset + btrfs_dev_extent_length(l,\n\t\t\t\t\t\t\t\t  dev_extent);\n\t\tif (key.offset <= start && extent_end > end) {\n\t\t\t*length = end - start + 1;\n\t\t\tbreak;\n\t\t} else if (key.offset <= start && extent_end > start)\n\t\t\t*length += extent_end - start;\n\t\telse if (key.offset > start && extent_end <= end)\n\t\t\t*length += extent_end - key.offset;\n\t\telse if (key.offset > start && key.offset <= end) {\n\t\t\t*length += end - key.offset + 1;\n\t\t\tbreak;\n\t\t} else if (key.offset > end)\n\t\t\tbreak;\n\nnext:\n\t\tpath->slots[0]++;\n\t}\n\tret = 0;\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_account_dev_extents_size(struct btrfs_device *device, u64 start,\n\t\t\t\t   u64 end, u64 *length)\n{\n\tstruct btrfs_key key;\n\tstruct btrfs_root *root = device->dev_root;\n\tstruct btrfs_dev_extent *dev_extent;\n\tstruct btrfs_path *path;\n\tu64 extent_end;\n\tint ret;\n\tint slot;\n\tstruct extent_buffer *l;\n\n\t*length = 0;\n\n\tif (start >= device->total_bytes || device->is_tgtdev_for_dev_replace)\n\t\treturn 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tpath->reada = 2;\n\n\tkey.objectid = device->devid;\n\tkey.offset = start;\n\tkey.type = BTRFS_DEV_EXTENT_KEY;\n\n\tret = btrfs_search_slot(NULL, root, &key, path, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (ret > 0) {\n\t\tret = btrfs_previous_item(root, path, key.objectid, key.type);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\twhile (1) {\n\t\tl = path->nodes[0];\n\t\tslot = path->slots[0];\n\t\tif (slot >= btrfs_header_nritems(l)) {\n\t\t\tret = btrfs_next_leaf(root, path);\n\t\t\tif (ret == 0)\n\t\t\t\tcontinue;\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\n\t\t\tbreak;\n\t\t}\n\t\tbtrfs_item_key_to_cpu(l, &key, slot);\n\n\t\tif (key.objectid < device->devid)\n\t\t\tgoto next;\n\n\t\tif (key.objectid > device->devid)\n\t\t\tbreak;\n\n\t\tif (key.type != BTRFS_DEV_EXTENT_KEY)\n\t\t\tgoto next;\n\n\t\tdev_extent = btrfs_item_ptr(l, slot, struct btrfs_dev_extent);\n\t\textent_end = key.offset + btrfs_dev_extent_length(l,\n\t\t\t\t\t\t\t\t  dev_extent);\n\t\tif (key.offset <= start && extent_end > end) {\n\t\t\t*length = end - start + 1;\n\t\t\tbreak;\n\t\t} else if (key.offset <= start && extent_end > start)\n\t\t\t*length += extent_end - start;\n\t\telse if (key.offset > start && extent_end <= end)\n\t\t\t*length += extent_end - key.offset;\n\t\telse if (key.offset > start && key.offset <= end) {\n\t\t\t*length += end - key.offset + 1;\n\t\t\tbreak;\n\t\t} else if (key.offset > end)\n\t\t\tbreak;\n\nnext:\n\t\tpath->slots[0]++;\n\t}\n\tret = 0;\nout:\n\tbtrfs_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "fs_info->alloc_start",
            "skip_space"
          ],
          "line": 1732
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_max_file_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "591-636",
          "snippet": "static unsigned long long ocfs2_max_file_offset(unsigned int bbits,\n\t\t\t\t\t\tunsigned int cbits)\n{\n\tunsigned int bytes = 1 << cbits;\n\tunsigned int trim = bytes;\n\tunsigned int bitshift = 32;\n\n\t/*\n\t * i_size and all block offsets in ocfs2 are always 64 bits\n\t * wide. i_clusters is 32 bits, in cluster-sized units. So on\n\t * 64 bit platforms, cluster size will be the limiting factor.\n\t */\n\n#if BITS_PER_LONG == 32\n# if defined(CONFIG_LBDAF)\n\tBUILD_BUG_ON(sizeof(sector_t) != 8);\n\t/*\n\t * We might be limited by page cache size.\n\t */\n\tif (bytes > PAGE_CACHE_SIZE) {\n\t\tbytes = PAGE_CACHE_SIZE;\n\t\ttrim = 1;\n\t\t/*\n\t\t * Shift by 31 here so that we don't get larger than\n\t\t * MAX_LFS_FILESIZE\n\t\t */\n\t\tbitshift = 31;\n\t}\n# else\n\t/*\n\t * We are limited by the size of sector_t. Use block size, as\n\t * that's what we expose to the VFS.\n\t */\n\tbytes = 1 << bbits;\n\ttrim = 1;\n\tbitshift = 31;\n# endif\n#endif\n\n\t/*\n\t * Trim by a whole cluster when we can actually approach the\n\t * on-disk limits. Otherwise we can overflow i_clusters when\n\t * an extent start is at the max offset.\n\t */\n\treturn (((unsigned long long)bytes) << bitshift) - trim;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic unsigned long long ocfs2_max_file_offset(unsigned int bbits,\n\t\t\t\t\t\tunsigned int cbits)\n{\n\tunsigned int bytes = 1 << cbits;\n\tunsigned int trim = bytes;\n\tunsigned int bitshift = 32;\n\n\t/*\n\t * i_size and all block offsets in ocfs2 are always 64 bits\n\t * wide. i_clusters is 32 bits, in cluster-sized units. So on\n\t * 64 bit platforms, cluster size will be the limiting factor.\n\t */\n\n#if BITS_PER_LONG == 32\n# if defined(CONFIG_LBDAF)\n\tBUILD_BUG_ON(sizeof(sector_t) != 8);\n\t/*\n\t * We might be limited by page cache size.\n\t */\n\tif (bytes > PAGE_CACHE_SIZE) {\n\t\tbytes = PAGE_CACHE_SIZE;\n\t\ttrim = 1;\n\t\t/*\n\t\t * Shift by 31 here so that we don't get larger than\n\t\t * MAX_LFS_FILESIZE\n\t\t */\n\t\tbitshift = 31;\n\t}\n# else\n\t/*\n\t * We are limited by the size of sector_t. Use block size, as\n\t * that's what we expose to the VFS.\n\t */\n\tbytes = 1 << bbits;\n\ttrim = 1;\n\tbitshift = 31;\n# endif\n#endif\n\n\t/*\n\t * Trim by a whole cluster when we can actually approach the\n\t * on-disk limits. Otherwise we can overflow i_clusters when\n\t * an extent start is at the max offset.\n\t */\n\treturn (((unsigned long long)bytes) << bitshift) - trim;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "avail_space",
            "BTRFS_STRIPE_LEN"
          ],
          "line": 1717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "device",
            "&fs_devices->devices",
            "dev_list"
          ],
          "line": 1706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fs_devices->device_list_mutex"
          ],
          "line": 1704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_get_alloc_profile",
          "args": [
            "root",
            "1"
          ],
          "line": 1686
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_get_alloc_profile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/extent-tree.c",
          "lines": "3618-3632",
          "snippet": "u64 btrfs_get_alloc_profile(struct btrfs_root *root, int data)\n{\n\tu64 flags;\n\tu64 ret;\n\n\tif (data)\n\t\tflags = BTRFS_BLOCK_GROUP_DATA;\n\telse if (root == root->fs_info->chunk_root)\n\t\tflags = BTRFS_BLOCK_GROUP_SYSTEM;\n\telse\n\t\tflags = BTRFS_BLOCK_GROUP_METADATA;\n\n\tret = get_alloc_profile(root, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"math.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"disk-io.h\"",
            "#include \"tree-log.h\"",
            "#include \"hash.h\"",
            "#include <linux/percpu_counter.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/sort.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"math.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"disk-io.h\"\n#include \"tree-log.h\"\n#include \"hash.h\"\n#include <linux/percpu_counter.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/rcupdate.h>\n#include <linux/sort.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nu64 btrfs_get_alloc_profile(struct btrfs_root *root, int data)\n{\n\tu64 flags;\n\tu64 ret;\n\n\tif (data)\n\t\tflags = BTRFS_BLOCK_GROUP_DATA;\n\telse if (root == root->fs_info->chunk_root)\n\t\tflags = BTRFS_BLOCK_GROUP_SYSTEM;\n\telse\n\t\tflags = BTRFS_BLOCK_GROUP_METADATA;\n\n\tret = get_alloc_profile(root, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc_array",
          "args": [
            "nr_devices",
            "sizeof(*devices_info)",
            "GFP_NOFS"
          ],
          "line": 1680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "nr_devices"
          ],
          "line": 1673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 1671
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nstatic int btrfs_remount(struct super_block *sb, int *flags, char *data);\n\nstatic int btrfs_calc_avail_data_space(struct btrfs_root *root, u64 *free_bytes)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct btrfs_device_info *devices_info;\n\tstruct btrfs_fs_devices *fs_devices = fs_info->fs_devices;\n\tstruct btrfs_device *device;\n\tu64 skip_space;\n\tu64 type;\n\tu64 avail_space;\n\tu64 used_space;\n\tu64 min_stripe_size;\n\tint min_stripes = 1, num_stripes = 1;\n\tint i = 0, nr_devices;\n\tint ret;\n\n\t/*\n\t * We aren't under the device list lock, so this is racey-ish, but good\n\t * enough for our purposes.\n\t */\n\tnr_devices = fs_info->fs_devices->open_devices;\n\tif (!nr_devices) {\n\t\tsmp_mb();\n\t\tnr_devices = fs_info->fs_devices->open_devices;\n\t\tASSERT(nr_devices);\n\t\tif (!nr_devices) {\n\t\t\t*free_bytes = 0;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tdevices_info = kmalloc_array(nr_devices, sizeof(*devices_info),\n\t\t\t       GFP_NOFS);\n\tif (!devices_info)\n\t\treturn -ENOMEM;\n\n\t/* calc min stripe number for data space alloction */\n\ttype = btrfs_get_alloc_profile(root, 1);\n\tif (type & BTRFS_BLOCK_GROUP_RAID0) {\n\t\tmin_stripes = 2;\n\t\tnum_stripes = nr_devices;\n\t} else if (type & BTRFS_BLOCK_GROUP_RAID1) {\n\t\tmin_stripes = 2;\n\t\tnum_stripes = 2;\n\t} else if (type & BTRFS_BLOCK_GROUP_RAID10) {\n\t\tmin_stripes = 4;\n\t\tnum_stripes = 4;\n\t}\n\n\tif (type & BTRFS_BLOCK_GROUP_DUP)\n\t\tmin_stripe_size = 2 * BTRFS_STRIPE_LEN;\n\telse\n\t\tmin_stripe_size = BTRFS_STRIPE_LEN;\n\n\tif (fs_info->alloc_start)\n\t\tmutex_lock(&fs_devices->device_list_mutex);\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(device, &fs_devices->devices, dev_list) {\n\t\tif (!device->in_fs_metadata || !device->bdev ||\n\t\t    device->is_tgtdev_for_dev_replace)\n\t\t\tcontinue;\n\n\t\tif (i >= nr_devices)\n\t\t\tbreak;\n\n\t\tavail_space = device->total_bytes - device->bytes_used;\n\n\t\t/* align with stripe_len */\n\t\tdo_div(avail_space, BTRFS_STRIPE_LEN);\n\t\tavail_space *= BTRFS_STRIPE_LEN;\n\n\t\t/*\n\t\t * In order to avoid overwritting the superblock on the drive,\n\t\t * btrfs starts at an offset of at least 1MB when doing chunk\n\t\t * allocation.\n\t\t */\n\t\tskip_space = 1024 * 1024;\n\n\t\t/* user can set the offset in fs_info->alloc_start. */\n\t\tif (fs_info->alloc_start &&\n\t\t    fs_info->alloc_start + BTRFS_STRIPE_LEN <=\n\t\t    device->total_bytes) {\n\t\t\trcu_read_unlock();\n\t\t\tskip_space = max(fs_info->alloc_start, skip_space);\n\n\t\t\t/*\n\t\t\t * btrfs can not use the free space in\n\t\t\t * [0, skip_space - 1], we must subtract it from the\n\t\t\t * total. In order to implement it, we account the used\n\t\t\t * space in this range first.\n\t\t\t */\n\t\t\tret = btrfs_account_dev_extents_size(device, 0,\n\t\t\t\t\t\t\t     skip_space - 1,\n\t\t\t\t\t\t\t     &used_space);\n\t\t\tif (ret) {\n\t\t\t\tkfree(devices_info);\n\t\t\t\tmutex_unlock(&fs_devices->device_list_mutex);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\trcu_read_lock();\n\n\t\t\t/* calc the free space in [0, skip_space - 1] */\n\t\t\tskip_space -= used_space;\n\t\t}\n\n\t\t/*\n\t\t * we can use the free space in [0, skip_space - 1], subtract\n\t\t * it from the total.\n\t\t */\n\t\tif (avail_space && avail_space >= skip_space)\n\t\t\tavail_space -= skip_space;\n\t\telse\n\t\t\tavail_space = 0;\n\n\t\tif (avail_space < min_stripe_size)\n\t\t\tcontinue;\n\n\t\tdevices_info[i].dev = device;\n\t\tdevices_info[i].max_avail = avail_space;\n\n\t\ti++;\n\t}\n\trcu_read_unlock();\n\tif (fs_info->alloc_start)\n\t\tmutex_unlock(&fs_devices->device_list_mutex);\n\n\tnr_devices = i;\n\n\tbtrfs_descending_sort_devices(devices_info, nr_devices);\n\n\ti = nr_devices - 1;\n\tavail_space = 0;\n\twhile (nr_devices >= min_stripes) {\n\t\tif (num_stripes > nr_devices)\n\t\t\tnum_stripes = nr_devices;\n\n\t\tif (devices_info[i].max_avail >= min_stripe_size) {\n\t\t\tint j;\n\t\t\tu64 alloc_size;\n\n\t\t\tavail_space += devices_info[i].max_avail * num_stripes;\n\t\t\talloc_size = devices_info[i].max_avail;\n\t\t\tfor (j = i + 1 - num_stripes; j <= i; j++)\n\t\t\t\tdevices_info[j].max_avail -= alloc_size;\n\t\t}\n\t\ti--;\n\t\tnr_devices--;\n\t}\n\n\tkfree(devices_info);\n\t*free_bytes = avail_space;\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_descending_sort_devices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
    "lines": "1638-1644",
    "snippet": "static inline void btrfs_descending_sort_devices(\n\t\t\t\t\tstruct btrfs_device_info *devices,\n\t\t\t\t\tsize_t nr_devices)\n{\n\tsort(devices, nr_devices, sizeof(struct btrfs_device_info),\n\t     btrfs_cmp_device_free_bytes, NULL);\n}",
    "includes": [
      "#include <trace/events/btrfs.h>",
      "#include \"qgroup.h\"",
      "#include \"tests/btrfs-tests.h\"",
      "#include \"backref.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"compression.h\"",
      "#include \"export.h\"",
      "#include \"volumes.h\"",
      "#include \"xattr.h\"",
      "#include \"props.h\"",
      "#include \"hash.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/namei.h>",
      "#include <linux/ctype.h>",
      "#include <linux/parser.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sort",
          "args": [
            "devices",
            "nr_devices",
            "sizeof(struct btrfs_device_info)",
            "btrfs_cmp_device_free_bytes",
            "NULL"
          ],
          "line": 1642
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nstatic inline void btrfs_descending_sort_devices(\n\t\t\t\t\tstruct btrfs_device_info *devices,\n\t\t\t\t\tsize_t nr_devices)\n{\n\tsort(devices, nr_devices, sizeof(struct btrfs_device_info),\n\t     btrfs_cmp_device_free_bytes, NULL);\n}"
  },
  {
    "function_name": "btrfs_cmp_device_free_bytes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
    "lines": "1621-1632",
    "snippet": "static int btrfs_cmp_device_free_bytes(const void *dev_info1,\n\t\t\t\t       const void *dev_info2)\n{\n\tif (((struct btrfs_device_info *)dev_info1)->max_avail >\n\t    ((struct btrfs_device_info *)dev_info2)->max_avail)\n\t\treturn -1;\n\telse if (((struct btrfs_device_info *)dev_info1)->max_avail <\n\t\t ((struct btrfs_device_info *)dev_info2)->max_avail)\n\t\treturn 1;\n\telse\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/btrfs.h>",
      "#include \"qgroup.h\"",
      "#include \"tests/btrfs-tests.h\"",
      "#include \"backref.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"compression.h\"",
      "#include \"export.h\"",
      "#include \"volumes.h\"",
      "#include \"xattr.h\"",
      "#include \"props.h\"",
      "#include \"hash.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/namei.h>",
      "#include <linux/ctype.h>",
      "#include <linux/parser.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nstatic int btrfs_cmp_device_free_bytes(const void *dev_info1,\n\t\t\t\t       const void *dev_info2)\n{\n\tif (((struct btrfs_device_info *)dev_info1)->max_avail >\n\t    ((struct btrfs_device_info *)dev_info2)->max_avail)\n\t\treturn -1;\n\telse if (((struct btrfs_device_info *)dev_info1)->max_avail <\n\t\t ((struct btrfs_device_info *)dev_info2)->max_avail)\n\t\treturn 1;\n\telse\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_remount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
    "lines": "1475-1618",
    "snippet": "static int btrfs_remount(struct super_block *sb, int *flags, char *data)\n{\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(sb);\n\tstruct btrfs_root *root = fs_info->tree_root;\n\tunsigned old_flags = sb->s_flags;\n\tunsigned long old_opts = fs_info->mount_opt;\n\tunsigned long old_compress_type = fs_info->compress_type;\n\tu64 old_max_inline = fs_info->max_inline;\n\tu64 old_alloc_start = fs_info->alloc_start;\n\tint old_thread_pool_size = fs_info->thread_pool_size;\n\tunsigned int old_metadata_ratio = fs_info->metadata_ratio;\n\tint ret;\n\n\tsync_filesystem(sb);\n\tbtrfs_remount_prepare(fs_info);\n\n\tif (data) {\n\t\tstruct security_mnt_opts new_sec_opts;\n\n\t\tsecurity_init_mnt_opts(&new_sec_opts);\n\t\tret = parse_security_options(data, &new_sec_opts);\n\t\tif (ret)\n\t\t\tgoto restore;\n\t\tret = setup_security_options(fs_info, sb,\n\t\t\t\t\t     &new_sec_opts);\n\t\tif (ret) {\n\t\t\tsecurity_free_mnt_opts(&new_sec_opts);\n\t\t\tgoto restore;\n\t\t}\n\t}\n\n\tret = btrfs_parse_options(root, data);\n\tif (ret) {\n\t\tret = -EINVAL;\n\t\tgoto restore;\n\t}\n\n\tbtrfs_remount_begin(fs_info, old_opts, *flags);\n\tbtrfs_resize_thread_pool(fs_info,\n\t\tfs_info->thread_pool_size, old_thread_pool_size);\n\n\tif ((*flags & MS_RDONLY) == (sb->s_flags & MS_RDONLY))\n\t\tgoto out;\n\n\tif (*flags & MS_RDONLY) {\n\t\t/*\n\t\t * this also happens on 'umount -rf' or on shutdown, when\n\t\t * the filesystem is busy.\n\t\t */\n\t\tcancel_work_sync(&fs_info->async_reclaim_work);\n\n\t\t/* wait for the uuid_scan task to finish */\n\t\tdown(&fs_info->uuid_tree_rescan_sem);\n\t\t/* avoid complains from lockdep et al. */\n\t\tup(&fs_info->uuid_tree_rescan_sem);\n\n\t\tsb->s_flags |= MS_RDONLY;\n\n\t\tbtrfs_dev_replace_suspend_for_unmount(fs_info);\n\t\tbtrfs_scrub_cancel(fs_info);\n\t\tbtrfs_pause_balance(fs_info);\n\n\t\tret = btrfs_commit_super(root);\n\t\tif (ret)\n\t\t\tgoto restore;\n\t} else {\n\t\tif (test_bit(BTRFS_FS_STATE_ERROR, &root->fs_info->fs_state)) {\n\t\t\tbtrfs_err(fs_info,\n\t\t\t\t\"Remounting read-write after error is not allowed\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto restore;\n\t\t}\n\t\tif (fs_info->fs_devices->rw_devices == 0) {\n\t\t\tret = -EACCES;\n\t\t\tgoto restore;\n\t\t}\n\n\t\tif (fs_info->fs_devices->missing_devices >\n\t\t     fs_info->num_tolerated_disk_barrier_failures &&\n\t\t    !(*flags & MS_RDONLY)) {\n\t\t\tbtrfs_warn(fs_info,\n\t\t\t\t\"too many missing devices, writeable remount is not allowed\");\n\t\t\tret = -EACCES;\n\t\t\tgoto restore;\n\t\t}\n\n\t\tif (btrfs_super_log_root(fs_info->super_copy) != 0) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto restore;\n\t\t}\n\n\t\tret = btrfs_cleanup_fs_roots(fs_info);\n\t\tif (ret)\n\t\t\tgoto restore;\n\n\t\t/* recover relocation */\n\t\tmutex_lock(&fs_info->cleaner_mutex);\n\t\tret = btrfs_recover_relocation(root);\n\t\tmutex_unlock(&fs_info->cleaner_mutex);\n\t\tif (ret)\n\t\t\tgoto restore;\n\n\t\tret = btrfs_resume_balance_async(fs_info);\n\t\tif (ret)\n\t\t\tgoto restore;\n\n\t\tret = btrfs_resume_dev_replace_async(fs_info);\n\t\tif (ret) {\n\t\t\tbtrfs_warn(fs_info, \"failed to resume dev_replace\");\n\t\t\tgoto restore;\n\t\t}\n\n\t\tif (!fs_info->uuid_root) {\n\t\t\tbtrfs_info(fs_info, \"creating UUID tree\");\n\t\t\tret = btrfs_create_uuid_tree(fs_info);\n\t\t\tif (ret) {\n\t\t\t\tbtrfs_warn(fs_info, \"failed to create the UUID tree %d\", ret);\n\t\t\t\tgoto restore;\n\t\t\t}\n\t\t}\n\t\tsb->s_flags &= ~MS_RDONLY;\n\t}\nout:\n\twake_up_process(fs_info->transaction_kthread);\n\tbtrfs_remount_cleanup(fs_info, old_opts);\n\treturn 0;\n\nrestore:\n\t/* We've hit an error - don't reset MS_RDONLY */\n\tif (sb->s_flags & MS_RDONLY)\n\t\told_flags |= MS_RDONLY;\n\tsb->s_flags = old_flags;\n\tfs_info->mount_opt = old_opts;\n\tfs_info->compress_type = old_compress_type;\n\tfs_info->max_inline = old_max_inline;\n\tmutex_lock(&fs_info->chunk_mutex);\n\tfs_info->alloc_start = old_alloc_start;\n\tmutex_unlock(&fs_info->chunk_mutex);\n\tbtrfs_resize_thread_pool(fs_info,\n\t\told_thread_pool_size, fs_info->thread_pool_size);\n\tfs_info->metadata_ratio = old_metadata_ratio;\n\tbtrfs_remount_cleanup(fs_info, old_opts);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/btrfs.h>",
      "#include \"qgroup.h\"",
      "#include \"tests/btrfs-tests.h\"",
      "#include \"backref.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"compression.h\"",
      "#include \"export.h\"",
      "#include \"volumes.h\"",
      "#include \"xattr.h\"",
      "#include \"props.h\"",
      "#include \"hash.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/namei.h>",
      "#include <linux/ctype.h>",
      "#include <linux/parser.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btrfs_remount(struct super_block *sb, int *flags, char *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_remount_cleanup",
          "args": [
            "fs_info",
            "old_opts"
          ],
          "line": 1616
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_remount_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "1459-1473",
          "snippet": "static inline void btrfs_remount_cleanup(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t unsigned long old_opts)\n{\n\t/*\n\t * We need cleanup all defragable inodes if the autodefragment is\n\t * close or the fs is R/O.\n\t */\n\tif (btrfs_raw_test_opt(old_opts, AUTO_DEFRAG) &&\n\t    (!btrfs_raw_test_opt(fs_info->mount_opt, AUTO_DEFRAG) ||\n\t     (fs_info->sb->s_flags & MS_RDONLY))) {\n\t\tbtrfs_cleanup_defrag_inodes(fs_info);\n\t}\n\n\tclear_bit(BTRFS_FS_STATE_REMOUNTING, &fs_info->fs_state);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nstatic inline void btrfs_remount_cleanup(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t unsigned long old_opts)\n{\n\t/*\n\t * We need cleanup all defragable inodes if the autodefragment is\n\t * close or the fs is R/O.\n\t */\n\tif (btrfs_raw_test_opt(old_opts, AUTO_DEFRAG) &&\n\t    (!btrfs_raw_test_opt(fs_info->mount_opt, AUTO_DEFRAG) ||\n\t     (fs_info->sb->s_flags & MS_RDONLY))) {\n\t\tbtrfs_cleanup_defrag_inodes(fs_info);\n\t}\n\n\tclear_bit(BTRFS_FS_STATE_REMOUNTING, &fs_info->fs_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_resize_thread_pool",
          "args": [
            "fs_info",
            "old_thread_pool_size",
            "fs_info->thread_pool_size"
          ],
          "line": 1613
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_resize_thread_pool",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "1413-1438",
          "snippet": "static void btrfs_resize_thread_pool(struct btrfs_fs_info *fs_info,\n\t\t\t\t     int new_pool_size, int old_pool_size)\n{\n\tif (new_pool_size == old_pool_size)\n\t\treturn;\n\n\tfs_info->thread_pool_size = new_pool_size;\n\n\tbtrfs_info(fs_info, \"resize thread pool %d -> %d\",\n\t       old_pool_size, new_pool_size);\n\n\tbtrfs_workqueue_set_max(fs_info->workers, new_pool_size);\n\tbtrfs_workqueue_set_max(fs_info->delalloc_workers, new_pool_size);\n\tbtrfs_workqueue_set_max(fs_info->submit_workers, new_pool_size);\n\tbtrfs_workqueue_set_max(fs_info->caching_workers, new_pool_size);\n\tbtrfs_workqueue_set_max(fs_info->endio_workers, new_pool_size);\n\tbtrfs_workqueue_set_max(fs_info->endio_meta_workers, new_pool_size);\n\tbtrfs_workqueue_set_max(fs_info->endio_meta_write_workers,\n\t\t\t\tnew_pool_size);\n\tbtrfs_workqueue_set_max(fs_info->endio_write_workers, new_pool_size);\n\tbtrfs_workqueue_set_max(fs_info->endio_freespace_worker, new_pool_size);\n\tbtrfs_workqueue_set_max(fs_info->delayed_workers, new_pool_size);\n\tbtrfs_workqueue_set_max(fs_info->readahead_workers, new_pool_size);\n\tbtrfs_workqueue_set_max(fs_info->scrub_wr_completion_workers,\n\t\t\t\tnew_pool_size);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nstatic void btrfs_resize_thread_pool(struct btrfs_fs_info *fs_info,\n\t\t\t\t     int new_pool_size, int old_pool_size)\n{\n\tif (new_pool_size == old_pool_size)\n\t\treturn;\n\n\tfs_info->thread_pool_size = new_pool_size;\n\n\tbtrfs_info(fs_info, \"resize thread pool %d -> %d\",\n\t       old_pool_size, new_pool_size);\n\n\tbtrfs_workqueue_set_max(fs_info->workers, new_pool_size);\n\tbtrfs_workqueue_set_max(fs_info->delalloc_workers, new_pool_size);\n\tbtrfs_workqueue_set_max(fs_info->submit_workers, new_pool_size);\n\tbtrfs_workqueue_set_max(fs_info->caching_workers, new_pool_size);\n\tbtrfs_workqueue_set_max(fs_info->endio_workers, new_pool_size);\n\tbtrfs_workqueue_set_max(fs_info->endio_meta_workers, new_pool_size);\n\tbtrfs_workqueue_set_max(fs_info->endio_meta_write_workers,\n\t\t\t\tnew_pool_size);\n\tbtrfs_workqueue_set_max(fs_info->endio_write_workers, new_pool_size);\n\tbtrfs_workqueue_set_max(fs_info->endio_freespace_worker, new_pool_size);\n\tbtrfs_workqueue_set_max(fs_info->delayed_workers, new_pool_size);\n\tbtrfs_workqueue_set_max(fs_info->readahead_workers, new_pool_size);\n\tbtrfs_workqueue_set_max(fs_info->scrub_wr_completion_workers,\n\t\t\t\tnew_pool_size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->chunk_mutex"
          ],
          "line": 1612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fs_info->chunk_mutex"
          ],
          "line": 1610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "fs_info->transaction_kthread"
          ],
          "line": 1598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_warn",
          "args": [
            "fs_info",
            "\"failed to create the UUID tree %d\"",
            "ret"
          ],
          "line": 1591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_create_uuid_tree",
          "args": [
            "fs_info"
          ],
          "line": 1589
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_create_uuid_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "3890-3930",
          "snippet": "int btrfs_create_uuid_tree(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_root *tree_root = fs_info->tree_root;\n\tstruct btrfs_root *uuid_root;\n\tstruct task_struct *task;\n\tint ret;\n\n\t/*\n\t * 1 - root node\n\t * 1 - root item\n\t */\n\ttrans = btrfs_start_transaction(tree_root, 2);\n\tif (IS_ERR(trans))\n\t\treturn PTR_ERR(trans);\n\n\tuuid_root = btrfs_create_tree(trans, fs_info,\n\t\t\t\t      BTRFS_UUID_TREE_OBJECTID);\n\tif (IS_ERR(uuid_root)) {\n\t\tbtrfs_abort_transaction(trans, tree_root,\n\t\t\t\t\tPTR_ERR(uuid_root));\n\t\treturn PTR_ERR(uuid_root);\n\t}\n\n\tfs_info->uuid_root = uuid_root;\n\n\tret = btrfs_commit_transaction(trans, tree_root);\n\tif (ret)\n\t\treturn ret;\n\n\tdown(&fs_info->uuid_tree_rescan_sem);\n\ttask = kthread_run(btrfs_uuid_scan_kthread, fs_info, \"btrfs-uuid\");\n\tif (IS_ERR(task)) {\n\t\t/* fs_info->update_uuid_tree_gen remains 0 in all error case */\n\t\tbtrfs_warn(fs_info, \"failed to start uuid_scan task\");\n\t\tup(&fs_info->uuid_tree_rescan_sem);\n\t\treturn PTR_ERR(task);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_relocate_sys_chunks(struct btrfs_root *root);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int btrfs_relocate_sys_chunks(struct btrfs_root *root);\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_create_uuid_tree(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_root *tree_root = fs_info->tree_root;\n\tstruct btrfs_root *uuid_root;\n\tstruct task_struct *task;\n\tint ret;\n\n\t/*\n\t * 1 - root node\n\t * 1 - root item\n\t */\n\ttrans = btrfs_start_transaction(tree_root, 2);\n\tif (IS_ERR(trans))\n\t\treturn PTR_ERR(trans);\n\n\tuuid_root = btrfs_create_tree(trans, fs_info,\n\t\t\t\t      BTRFS_UUID_TREE_OBJECTID);\n\tif (IS_ERR(uuid_root)) {\n\t\tbtrfs_abort_transaction(trans, tree_root,\n\t\t\t\t\tPTR_ERR(uuid_root));\n\t\treturn PTR_ERR(uuid_root);\n\t}\n\n\tfs_info->uuid_root = uuid_root;\n\n\tret = btrfs_commit_transaction(trans, tree_root);\n\tif (ret)\n\t\treturn ret;\n\n\tdown(&fs_info->uuid_tree_rescan_sem);\n\ttask = kthread_run(btrfs_uuid_scan_kthread, fs_info, \"btrfs-uuid\");\n\tif (IS_ERR(task)) {\n\t\t/* fs_info->update_uuid_tree_gen remains 0 in all error case */\n\t\tbtrfs_warn(fs_info, \"failed to start uuid_scan task\");\n\t\tup(&fs_info->uuid_tree_rescan_sem);\n\t\treturn PTR_ERR(task);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_info",
          "args": [
            "fs_info",
            "\"creating UUID tree\""
          ],
          "line": 1588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_warn",
          "args": [
            "fs_info",
            "\"failed to resume dev_replace\""
          ],
          "line": 1583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_resume_dev_replace_async",
          "args": [
            "fs_info"
          ],
          "line": 1581
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_resume_dev_replace_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
          "lines": "763-795",
          "snippet": "int btrfs_resume_dev_replace_async(struct btrfs_fs_info *fs_info)\n{\n\tstruct task_struct *task;\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\n\tbtrfs_dev_replace_lock(dev_replace);\n\tswitch (dev_replace->replace_state) {\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED:\n\t\tbtrfs_dev_replace_unlock(dev_replace);\n\t\treturn 0;\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED:\n\t\tbreak;\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED:\n\t\tdev_replace->replace_state =\n\t\t\tBTRFS_IOCTL_DEV_REPLACE_STATE_STARTED;\n\t\tbreak;\n\t}\n\tif (!dev_replace->tgtdev || !dev_replace->tgtdev->bdev) {\n\t\tbtrfs_info(fs_info, \"cannot continue dev_replace, tgtdev is missing\");\n\t\tbtrfs_info(fs_info,\n\t\t\t\"you may cancel the operation after 'mount -o degraded'\");\n\t\tbtrfs_dev_replace_unlock(dev_replace);\n\t\treturn 0;\n\t}\n\tbtrfs_dev_replace_unlock(dev_replace);\n\n\tWARN_ON(atomic_xchg(\n\t\t&fs_info->mutually_exclusive_operation_running, 1));\n\ttask = kthread_run(btrfs_dev_replace_kthread, fs_info, \"btrfs-devrepl\");\n\treturn PTR_ERR_OR_ZERO(task);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/math64.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void btrfs_dev_replace_update_device_in_mapping_tree(\n\t\t\t\t\t\tstruct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tstruct btrfs_device *srcdev,\n\t\t\t\t\t\tstruct btrfs_device *tgtdev);",
            "static u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);",
            "static int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic void btrfs_dev_replace_update_device_in_mapping_tree(\n\t\t\t\t\t\tstruct btrfs_fs_info *fs_info,\n\t\t\t\t\t\tstruct btrfs_device *srcdev,\n\t\t\t\t\t\tstruct btrfs_device *tgtdev);\nstatic u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);\nstatic int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);\n\nint btrfs_resume_dev_replace_async(struct btrfs_fs_info *fs_info)\n{\n\tstruct task_struct *task;\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\n\tbtrfs_dev_replace_lock(dev_replace);\n\tswitch (dev_replace->replace_state) {\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED:\n\t\tbtrfs_dev_replace_unlock(dev_replace);\n\t\treturn 0;\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED:\n\t\tbreak;\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED:\n\t\tdev_replace->replace_state =\n\t\t\tBTRFS_IOCTL_DEV_REPLACE_STATE_STARTED;\n\t\tbreak;\n\t}\n\tif (!dev_replace->tgtdev || !dev_replace->tgtdev->bdev) {\n\t\tbtrfs_info(fs_info, \"cannot continue dev_replace, tgtdev is missing\");\n\t\tbtrfs_info(fs_info,\n\t\t\t\"you may cancel the operation after 'mount -o degraded'\");\n\t\tbtrfs_dev_replace_unlock(dev_replace);\n\t\treturn 0;\n\t}\n\tbtrfs_dev_replace_unlock(dev_replace);\n\n\tWARN_ON(atomic_xchg(\n\t\t&fs_info->mutually_exclusive_operation_running, 1));\n\ttask = kthread_run(btrfs_dev_replace_kthread, fs_info, \"btrfs-devrepl\");\n\treturn PTR_ERR_OR_ZERO(task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_resume_balance_async",
          "args": [
            "fs_info"
          ],
          "line": 1577
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_resume_balance_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "3544-3562",
          "snippet": "int btrfs_resume_balance_async(struct btrfs_fs_info *fs_info)\n{\n\tstruct task_struct *tsk;\n\n\tspin_lock(&fs_info->balance_lock);\n\tif (!fs_info->balance_ctl) {\n\t\tspin_unlock(&fs_info->balance_lock);\n\t\treturn 0;\n\t}\n\tspin_unlock(&fs_info->balance_lock);\n\n\tif (btrfs_test_opt(fs_info->tree_root, SKIP_BALANCE)) {\n\t\tbtrfs_info(fs_info, \"force skipping balance\");\n\t\treturn 0;\n\t}\n\n\ttsk = kthread_run(balance_kthread, fs_info, \"btrfs-balance\");\n\treturn PTR_ERR_OR_ZERO(tsk);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_resume_balance_async(struct btrfs_fs_info *fs_info)\n{\n\tstruct task_struct *tsk;\n\n\tspin_lock(&fs_info->balance_lock);\n\tif (!fs_info->balance_ctl) {\n\t\tspin_unlock(&fs_info->balance_lock);\n\t\treturn 0;\n\t}\n\tspin_unlock(&fs_info->balance_lock);\n\n\tif (btrfs_test_opt(fs_info->tree_root, SKIP_BALANCE)) {\n\t\tbtrfs_info(fs_info, \"force skipping balance\");\n\t\treturn 0;\n\t}\n\n\ttsk = kthread_run(balance_kthread, fs_info, \"btrfs-balance\");\n\treturn PTR_ERR_OR_ZERO(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fs_info->cleaner_mutex"
          ],
          "line": 1573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_recover_relocation",
          "args": [
            "root"
          ],
          "line": 1572
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_recover_relocation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/relocation.c",
          "lines": "4320-4470",
          "snippet": "int btrfs_recover_relocation(struct btrfs_root *root)\n{\n\tLIST_HEAD(reloc_roots);\n\tstruct btrfs_key key;\n\tstruct btrfs_root *fs_root;\n\tstruct btrfs_root *reloc_root;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct reloc_control *rc = NULL;\n\tstruct btrfs_trans_handle *trans;\n\tint ret;\n\tint err = 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tpath->reada = -1;\n\n\tkey.objectid = BTRFS_TREE_RELOC_OBJECTID;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\tkey.offset = (u64)-1;\n\n\twhile (1) {\n\t\tret = btrfs_search_slot(NULL, root->fs_info->tree_root, &key,\n\t\t\t\t\tpath, 0, 0);\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tgoto out;\n\t\t}\n\t\tif (ret > 0) {\n\t\t\tif (path->slots[0] == 0)\n\t\t\t\tbreak;\n\t\t\tpath->slots[0]--;\n\t\t}\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\t\tbtrfs_release_path(path);\n\n\t\tif (key.objectid != BTRFS_TREE_RELOC_OBJECTID ||\n\t\t    key.type != BTRFS_ROOT_ITEM_KEY)\n\t\t\tbreak;\n\n\t\treloc_root = btrfs_read_fs_root(root, &key);\n\t\tif (IS_ERR(reloc_root)) {\n\t\t\terr = PTR_ERR(reloc_root);\n\t\t\tgoto out;\n\t\t}\n\n\t\tlist_add(&reloc_root->root_list, &reloc_roots);\n\n\t\tif (btrfs_root_refs(&reloc_root->root_item) > 0) {\n\t\t\tfs_root = read_fs_root(root->fs_info,\n\t\t\t\t\t       reloc_root->root_key.offset);\n\t\t\tif (IS_ERR(fs_root)) {\n\t\t\t\tret = PTR_ERR(fs_root);\n\t\t\t\tif (ret != -ENOENT) {\n\t\t\t\t\terr = ret;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tret = mark_garbage_root(reloc_root);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\terr = ret;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (key.offset == 0)\n\t\t\tbreak;\n\n\t\tkey.offset--;\n\t}\n\tbtrfs_release_path(path);\n\n\tif (list_empty(&reloc_roots))\n\t\tgoto out;\n\n\trc = alloc_reloc_control(root->fs_info);\n\tif (!rc) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\trc->extent_root = root->fs_info->extent_root;\n\n\tset_reloc_control(rc);\n\n\ttrans = btrfs_join_transaction(rc->extent_root);\n\tif (IS_ERR(trans)) {\n\t\tunset_reloc_control(rc);\n\t\terr = PTR_ERR(trans);\n\t\tgoto out_free;\n\t}\n\n\trc->merge_reloc_tree = 1;\n\n\twhile (!list_empty(&reloc_roots)) {\n\t\treloc_root = list_entry(reloc_roots.next,\n\t\t\t\t\tstruct btrfs_root, root_list);\n\t\tlist_del(&reloc_root->root_list);\n\n\t\tif (btrfs_root_refs(&reloc_root->root_item) == 0) {\n\t\t\tlist_add_tail(&reloc_root->root_list,\n\t\t\t\t      &rc->reloc_roots);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfs_root = read_fs_root(root->fs_info,\n\t\t\t\t       reloc_root->root_key.offset);\n\t\tif (IS_ERR(fs_root)) {\n\t\t\terr = PTR_ERR(fs_root);\n\t\t\tgoto out_free;\n\t\t}\n\n\t\terr = __add_reloc_root(reloc_root);\n\t\tBUG_ON(err < 0); /* -ENOMEM or logic error */\n\t\tfs_root->reloc_root = reloc_root;\n\t}\n\n\terr = btrfs_commit_transaction(trans, rc->extent_root);\n\tif (err)\n\t\tgoto out_free;\n\n\tmerge_reloc_roots(rc);\n\n\tunset_reloc_control(rc);\n\n\ttrans = btrfs_join_transaction(rc->extent_root);\n\tif (IS_ERR(trans))\n\t\terr = PTR_ERR(trans);\n\telse\n\t\terr = btrfs_commit_transaction(trans, rc->extent_root);\nout_free:\n\tkfree(rc);\nout:\n\tif (!list_empty(&reloc_roots))\n\t\tfree_reloc_roots(&reloc_roots);\n\n\tbtrfs_free_path(path);\n\n\tif (err == 0) {\n\t\t/* cleanup orphan inode in data relocation tree */\n\t\tfs_root = read_fs_root(root->fs_info,\n\t\t\t\t       BTRFS_DATA_RELOC_TREE_OBJECTID);\n\t\tif (IS_ERR(fs_root))\n\t\t\terr = PTR_ERR(fs_root);\n\t\telse\n\t\t\terr = btrfs_orphan_cleanup(fs_root);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"async-thread.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"locking.h\"",
            "#include \"volumes.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"async-thread.h\"\n#include \"btrfs_inode.h\"\n#include \"locking.h\"\n#include \"volumes.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/sched.h>\n\nstatic noinline_for_stack\nstruct;\n\nint btrfs_recover_relocation(struct btrfs_root *root)\n{\n\tLIST_HEAD(reloc_roots);\n\tstruct btrfs_key key;\n\tstruct btrfs_root *fs_root;\n\tstruct btrfs_root *reloc_root;\n\tstruct btrfs_path *path;\n\tstruct extent_buffer *leaf;\n\tstruct reloc_control *rc = NULL;\n\tstruct btrfs_trans_handle *trans;\n\tint ret;\n\tint err = 0;\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn -ENOMEM;\n\tpath->reada = -1;\n\n\tkey.objectid = BTRFS_TREE_RELOC_OBJECTID;\n\tkey.type = BTRFS_ROOT_ITEM_KEY;\n\tkey.offset = (u64)-1;\n\n\twhile (1) {\n\t\tret = btrfs_search_slot(NULL, root->fs_info->tree_root, &key,\n\t\t\t\t\tpath, 0, 0);\n\t\tif (ret < 0) {\n\t\t\terr = ret;\n\t\t\tgoto out;\n\t\t}\n\t\tif (ret > 0) {\n\t\t\tif (path->slots[0] == 0)\n\t\t\t\tbreak;\n\t\t\tpath->slots[0]--;\n\t\t}\n\t\tleaf = path->nodes[0];\n\t\tbtrfs_item_key_to_cpu(leaf, &key, path->slots[0]);\n\t\tbtrfs_release_path(path);\n\n\t\tif (key.objectid != BTRFS_TREE_RELOC_OBJECTID ||\n\t\t    key.type != BTRFS_ROOT_ITEM_KEY)\n\t\t\tbreak;\n\n\t\treloc_root = btrfs_read_fs_root(root, &key);\n\t\tif (IS_ERR(reloc_root)) {\n\t\t\terr = PTR_ERR(reloc_root);\n\t\t\tgoto out;\n\t\t}\n\n\t\tlist_add(&reloc_root->root_list, &reloc_roots);\n\n\t\tif (btrfs_root_refs(&reloc_root->root_item) > 0) {\n\t\t\tfs_root = read_fs_root(root->fs_info,\n\t\t\t\t\t       reloc_root->root_key.offset);\n\t\t\tif (IS_ERR(fs_root)) {\n\t\t\t\tret = PTR_ERR(fs_root);\n\t\t\t\tif (ret != -ENOENT) {\n\t\t\t\t\terr = ret;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tret = mark_garbage_root(reloc_root);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\terr = ret;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (key.offset == 0)\n\t\t\tbreak;\n\n\t\tkey.offset--;\n\t}\n\tbtrfs_release_path(path);\n\n\tif (list_empty(&reloc_roots))\n\t\tgoto out;\n\n\trc = alloc_reloc_control(root->fs_info);\n\tif (!rc) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\trc->extent_root = root->fs_info->extent_root;\n\n\tset_reloc_control(rc);\n\n\ttrans = btrfs_join_transaction(rc->extent_root);\n\tif (IS_ERR(trans)) {\n\t\tunset_reloc_control(rc);\n\t\terr = PTR_ERR(trans);\n\t\tgoto out_free;\n\t}\n\n\trc->merge_reloc_tree = 1;\n\n\twhile (!list_empty(&reloc_roots)) {\n\t\treloc_root = list_entry(reloc_roots.next,\n\t\t\t\t\tstruct btrfs_root, root_list);\n\t\tlist_del(&reloc_root->root_list);\n\n\t\tif (btrfs_root_refs(&reloc_root->root_item) == 0) {\n\t\t\tlist_add_tail(&reloc_root->root_list,\n\t\t\t\t      &rc->reloc_roots);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfs_root = read_fs_root(root->fs_info,\n\t\t\t\t       reloc_root->root_key.offset);\n\t\tif (IS_ERR(fs_root)) {\n\t\t\terr = PTR_ERR(fs_root);\n\t\t\tgoto out_free;\n\t\t}\n\n\t\terr = __add_reloc_root(reloc_root);\n\t\tBUG_ON(err < 0); /* -ENOMEM or logic error */\n\t\tfs_root->reloc_root = reloc_root;\n\t}\n\n\terr = btrfs_commit_transaction(trans, rc->extent_root);\n\tif (err)\n\t\tgoto out_free;\n\n\tmerge_reloc_roots(rc);\n\n\tunset_reloc_control(rc);\n\n\ttrans = btrfs_join_transaction(rc->extent_root);\n\tif (IS_ERR(trans))\n\t\terr = PTR_ERR(trans);\n\telse\n\t\terr = btrfs_commit_transaction(trans, rc->extent_root);\nout_free:\n\tkfree(rc);\nout:\n\tif (!list_empty(&reloc_roots))\n\t\tfree_reloc_roots(&reloc_roots);\n\n\tbtrfs_free_path(path);\n\n\tif (err == 0) {\n\t\t/* cleanup orphan inode in data relocation tree */\n\t\tfs_root = read_fs_root(root->fs_info,\n\t\t\t\t       BTRFS_DATA_RELOC_TREE_OBJECTID);\n\t\tif (IS_ERR(fs_root))\n\t\t\terr = PTR_ERR(fs_root);\n\t\telse\n\t\t\terr = btrfs_orphan_cleanup(fs_root);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fs_info->cleaner_mutex"
          ],
          "line": 1571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_cleanup_fs_roots",
          "args": [
            "fs_info"
          ],
          "line": 1566
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_cleanup_fs_roots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3569-3618",
          "snippet": "int btrfs_cleanup_fs_roots(struct btrfs_fs_info *fs_info)\n{\n\tu64 root_objectid = 0;\n\tstruct btrfs_root *gang[8];\n\tint i = 0;\n\tint err = 0;\n\tunsigned int ret = 0;\n\tint index;\n\n\twhile (1) {\n\t\tindex = srcu_read_lock(&fs_info->subvol_srcu);\n\t\tret = radix_tree_gang_lookup(&fs_info->fs_roots_radix,\n\t\t\t\t\t     (void **)gang, root_objectid,\n\t\t\t\t\t     ARRAY_SIZE(gang));\n\t\tif (!ret) {\n\t\t\tsrcu_read_unlock(&fs_info->subvol_srcu, index);\n\t\t\tbreak;\n\t\t}\n\t\troot_objectid = gang[ret - 1]->root_key.objectid + 1;\n\n\t\tfor (i = 0; i < ret; i++) {\n\t\t\t/* Avoid to grab roots in dead_roots */\n\t\t\tif (btrfs_root_refs(&gang[i]->root_item) == 0) {\n\t\t\t\tgang[i] = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* grab all the search result for later use */\n\t\t\tgang[i] = btrfs_grab_fs_root(gang[i]);\n\t\t}\n\t\tsrcu_read_unlock(&fs_info->subvol_srcu, index);\n\n\t\tfor (i = 0; i < ret; i++) {\n\t\t\tif (!gang[i])\n\t\t\t\tcontinue;\n\t\t\troot_objectid = gang[i]->root_key.objectid;\n\t\t\terr = btrfs_orphan_cleanup(gang[i]);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tbtrfs_put_fs_root(gang[i]);\n\t\t}\n\t\troot_objectid++;\n\t}\n\n\t/* release the uncleaned roots due to error */\n\tfor (; i < ret; i++) {\n\t\tif (gang[i])\n\t\t\tbtrfs_put_fs_root(gang[i]);\n\t}\n\treturn err;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_cleanup_fs_roots(struct btrfs_fs_info *fs_info)\n{\n\tu64 root_objectid = 0;\n\tstruct btrfs_root *gang[8];\n\tint i = 0;\n\tint err = 0;\n\tunsigned int ret = 0;\n\tint index;\n\n\twhile (1) {\n\t\tindex = srcu_read_lock(&fs_info->subvol_srcu);\n\t\tret = radix_tree_gang_lookup(&fs_info->fs_roots_radix,\n\t\t\t\t\t     (void **)gang, root_objectid,\n\t\t\t\t\t     ARRAY_SIZE(gang));\n\t\tif (!ret) {\n\t\t\tsrcu_read_unlock(&fs_info->subvol_srcu, index);\n\t\t\tbreak;\n\t\t}\n\t\troot_objectid = gang[ret - 1]->root_key.objectid + 1;\n\n\t\tfor (i = 0; i < ret; i++) {\n\t\t\t/* Avoid to grab roots in dead_roots */\n\t\t\tif (btrfs_root_refs(&gang[i]->root_item) == 0) {\n\t\t\t\tgang[i] = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* grab all the search result for later use */\n\t\t\tgang[i] = btrfs_grab_fs_root(gang[i]);\n\t\t}\n\t\tsrcu_read_unlock(&fs_info->subvol_srcu, index);\n\n\t\tfor (i = 0; i < ret; i++) {\n\t\t\tif (!gang[i])\n\t\t\t\tcontinue;\n\t\t\troot_objectid = gang[i]->root_key.objectid;\n\t\t\terr = btrfs_orphan_cleanup(gang[i]);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tbtrfs_put_fs_root(gang[i]);\n\t\t}\n\t\troot_objectid++;\n\t}\n\n\t/* release the uncleaned roots due to error */\n\tfor (; i < ret; i++) {\n\t\tif (gang[i])\n\t\t\tbtrfs_put_fs_root(gang[i]);\n\t}\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_super_log_root",
          "args": [
            "fs_info->super_copy"
          ],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_warn",
          "args": [
            "fs_info",
            "\"too many missing devices, writeable remount is not allowed\""
          ],
          "line": 1555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_err",
          "args": [
            "fs_info",
            "\"Remounting read-write after error is not allowed\""
          ],
          "line": 1542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BTRFS_FS_STATE_ERROR",
            "&root->fs_info->fs_state"
          ],
          "line": 1541
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_commit_super",
          "args": [
            "root"
          ],
          "line": 1537
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_commit_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3620-3637",
          "snippet": "int btrfs_commit_super(struct btrfs_root *root)\n{\n\tstruct btrfs_trans_handle *trans;\n\n\tmutex_lock(&root->fs_info->cleaner_mutex);\n\tbtrfs_run_delayed_iputs(root);\n\tmutex_unlock(&root->fs_info->cleaner_mutex);\n\twake_up_process(root->fs_info->cleaner_kthread);\n\n\t/* wait until ongoing cleanup work done */\n\tdown_write(&root->fs_info->cleanup_work_sem);\n\tup_write(&root->fs_info->cleanup_work_sem);\n\n\ttrans = btrfs_join_transaction(root);\n\tif (IS_ERR(trans))\n\t\treturn PTR_ERR(trans);\n\treturn btrfs_commit_transaction(trans, root);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void end_workqueue_fn(struct btrfs_work *work);",
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void end_workqueue_fn(struct btrfs_work *work);\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nint btrfs_commit_super(struct btrfs_root *root)\n{\n\tstruct btrfs_trans_handle *trans;\n\n\tmutex_lock(&root->fs_info->cleaner_mutex);\n\tbtrfs_run_delayed_iputs(root);\n\tmutex_unlock(&root->fs_info->cleaner_mutex);\n\twake_up_process(root->fs_info->cleaner_kthread);\n\n\t/* wait until ongoing cleanup work done */\n\tdown_write(&root->fs_info->cleanup_work_sem);\n\tup_write(&root->fs_info->cleanup_work_sem);\n\n\ttrans = btrfs_join_transaction(root);\n\tif (IS_ERR(trans))\n\t\treturn PTR_ERR(trans);\n\treturn btrfs_commit_transaction(trans, root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_pause_balance",
          "args": [
            "fs_info"
          ],
          "line": 1535
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_pause_balance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "3624-3651",
          "snippet": "int btrfs_pause_balance(struct btrfs_fs_info *fs_info)\n{\n\tint ret = 0;\n\n\tmutex_lock(&fs_info->balance_mutex);\n\tif (!fs_info->balance_ctl) {\n\t\tmutex_unlock(&fs_info->balance_mutex);\n\t\treturn -ENOTCONN;\n\t}\n\n\tif (atomic_read(&fs_info->balance_running)) {\n\t\tatomic_inc(&fs_info->balance_pause_req);\n\t\tmutex_unlock(&fs_info->balance_mutex);\n\n\t\twait_event(fs_info->balance_wait_q,\n\t\t\t   atomic_read(&fs_info->balance_running) == 0);\n\n\t\tmutex_lock(&fs_info->balance_mutex);\n\t\t/* we are good with balance_ctl ripped off from under us */\n\t\tBUG_ON(atomic_read(&fs_info->balance_running));\n\t\tatomic_dec(&fs_info->balance_pause_req);\n\t} else {\n\t\tret = -ENOTCONN;\n\t}\n\n\tmutex_unlock(&fs_info->balance_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_pause_balance(struct btrfs_fs_info *fs_info)\n{\n\tint ret = 0;\n\n\tmutex_lock(&fs_info->balance_mutex);\n\tif (!fs_info->balance_ctl) {\n\t\tmutex_unlock(&fs_info->balance_mutex);\n\t\treturn -ENOTCONN;\n\t}\n\n\tif (atomic_read(&fs_info->balance_running)) {\n\t\tatomic_inc(&fs_info->balance_pause_req);\n\t\tmutex_unlock(&fs_info->balance_mutex);\n\n\t\twait_event(fs_info->balance_wait_q,\n\t\t\t   atomic_read(&fs_info->balance_running) == 0);\n\n\t\tmutex_lock(&fs_info->balance_mutex);\n\t\t/* we are good with balance_ctl ripped off from under us */\n\t\tBUG_ON(atomic_read(&fs_info->balance_running));\n\t\tatomic_dec(&fs_info->balance_pause_req);\n\t} else {\n\t\tret = -ENOTCONN;\n\t}\n\n\tmutex_unlock(&fs_info->balance_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_scrub_cancel",
          "args": [
            "fs_info"
          ],
          "line": 1534
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_scrub_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/scrub.c",
          "lines": "3781-3800",
          "snippet": "int btrfs_scrub_cancel(struct btrfs_fs_info *fs_info)\n{\n\tmutex_lock(&fs_info->scrub_lock);\n\tif (!atomic_read(&fs_info->scrubs_running)) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\treturn -ENOTCONN;\n\t}\n\n\tatomic_inc(&fs_info->scrub_cancel_req);\n\twhile (atomic_read(&fs_info->scrubs_running)) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\twait_event(fs_info->scrub_pause_wait,\n\t\t\t   atomic_read(&fs_info->scrubs_running) == 0);\n\t\tmutex_lock(&fs_info->scrub_lock);\n\t}\n\tatomic_dec(&fs_info->scrub_cancel_req);\n\tmutex_unlock(&fs_info->scrub_lock);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"raid56.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"dev-replace.h\"",
            "#include \"extent_io.h\"",
            "#include \"backref.h\"",
            "#include \"transaction.h\"",
            "#include \"ordered-data.h\"",
            "#include \"disk-io.h\"",
            "#include \"volumes.h\"",
            "#include \"ctree.h\"",
            "#include <linux/ratelimit.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);",
            "static noinline_for_stack\nstruct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"raid56.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"dev-replace.h\"\n#include \"extent_io.h\"\n#include \"backref.h\"\n#include \"transaction.h\"\n#include \"ordered-data.h\"\n#include \"disk-io.h\"\n#include \"volumes.h\"\n#include \"ctree.h\"\n#include <linux/ratelimit.h>\n#include <linux/blkdev.h>\n\nstatic void __scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);\nstatic noinline_for_stack\nstruct;\n\nint btrfs_scrub_cancel(struct btrfs_fs_info *fs_info)\n{\n\tmutex_lock(&fs_info->scrub_lock);\n\tif (!atomic_read(&fs_info->scrubs_running)) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\treturn -ENOTCONN;\n\t}\n\n\tatomic_inc(&fs_info->scrub_cancel_req);\n\twhile (atomic_read(&fs_info->scrubs_running)) {\n\t\tmutex_unlock(&fs_info->scrub_lock);\n\t\twait_event(fs_info->scrub_pause_wait,\n\t\t\t   atomic_read(&fs_info->scrubs_running) == 0);\n\t\tmutex_lock(&fs_info->scrub_lock);\n\t}\n\tatomic_dec(&fs_info->scrub_cancel_req);\n\tmutex_unlock(&fs_info->scrub_lock);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_dev_replace_suspend_for_unmount",
          "args": [
            "fs_info"
          ],
          "line": 1533
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dev_replace_suspend_for_unmount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dev-replace.c",
          "lines": "737-760",
          "snippet": "void btrfs_dev_replace_suspend_for_unmount(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\n\tmutex_lock(&dev_replace->lock_finishing_cancel_unmount);\n\tbtrfs_dev_replace_lock(dev_replace);\n\tswitch (dev_replace->replace_state) {\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED:\n\t\tbreak;\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED:\n\t\tdev_replace->replace_state =\n\t\t\tBTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED;\n\t\tdev_replace->time_stopped = get_seconds();\n\t\tdev_replace->item_needs_writeback = 1;\n\t\tbtrfs_info(fs_info, \"suspending dev_replace for unmount\");\n\t\tbreak;\n\t}\n\n\tbtrfs_dev_replace_unlock(dev_replace);\n\tmutex_unlock(&dev_replace->lock_finishing_cancel_unmount);\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/math64.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);",
            "static int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/math64.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic u64 __btrfs_dev_replace_cancel(struct btrfs_fs_info *fs_info);\nstatic int btrfs_dev_replace_continue_on_mount(struct btrfs_fs_info *fs_info);\n\nvoid btrfs_dev_replace_suspend_for_unmount(struct btrfs_fs_info *fs_info)\n{\n\tstruct btrfs_dev_replace *dev_replace = &fs_info->dev_replace;\n\n\tmutex_lock(&dev_replace->lock_finishing_cancel_unmount);\n\tbtrfs_dev_replace_lock(dev_replace);\n\tswitch (dev_replace->replace_state) {\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_NEVER_STARTED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_FINISHED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_CANCELED:\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED:\n\t\tbreak;\n\tcase BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED:\n\t\tdev_replace->replace_state =\n\t\t\tBTRFS_IOCTL_DEV_REPLACE_STATE_SUSPENDED;\n\t\tdev_replace->time_stopped = get_seconds();\n\t\tdev_replace->item_needs_writeback = 1;\n\t\tbtrfs_info(fs_info, \"suspending dev_replace for unmount\");\n\t\tbreak;\n\t}\n\n\tbtrfs_dev_replace_unlock(dev_replace);\n\tmutex_unlock(&dev_replace->lock_finishing_cancel_unmount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up",
          "args": [
            "&fs_info->uuid_tree_rescan_sem"
          ],
          "line": 1529
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_kill_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "1895-1900",
          "snippet": "static void btrfs_kill_super(struct super_block *sb)\n{\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(sb);\n\tkill_anon_super(sb);\n\tfree_fs_info(fs_info);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nstatic void btrfs_kill_super(struct super_block *sb)\n{\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(sb);\n\tkill_anon_super(sb);\n\tfree_fs_info(fs_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down",
          "args": [
            "&fs_info->uuid_tree_rescan_sem"
          ],
          "line": 1527
        },
        "resolved": true,
        "details": {
          "function_name": "eneric_shutdown_super(",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/super.c",
          "lines": "393-425",
          "snippet": "oid generic_shutdown_super(struct super_block *sb)\n{\n\tconst struct super_operations *sop = sb->s_op;\n\n\tif (sb->s_root) {\n\t\tshrink_dcache_for_umount(sb);\n\t\tsync_filesystem(sb);\n\t\tsb->s_flags &= ~MS_ACTIVE;\n\n\t\tfsnotify_unmount_inodes(&sb->s_inodes);\n\n\t\tevict_inodes(sb);\n\n\t\tif (sb->s_dio_done_wq) {\n\t\t\tdestroy_workqueue(sb->s_dio_done_wq);\n\t\t\tsb->s_dio_done_wq = NULL;\n\t\t}\n\n\t\tif (sop->put_super)\n\t\t\tsop->put_super(sb);\n\n\t\tif (!list_empty(&sb->s_inodes)) {\n\t\t\tprintk(\"VFS: Busy inodes after unmount of %s. \"\n\t\t\t   \"Self-destruct in 5 seconds.  Have a nice day...\\n\",\n\t\t\t   sb->s_id);\n\t\t}\n\t}\n\tspin_lock(&sb_lock);\n\t/* should be initialized for __put_super_and_need_restart() */\n\thlist_del_init(&sb->s_instances);\n\tspin_unlock(&sb_lock);\n\tup_write(&sb->s_umount);\n}",
          "includes": [
            "include \"internal.h\"",
            "include <linux/lockdep.h>\n#",
            "include <linux/fsnotify.h>\n#",
            "include <linux/cleancache.h>\n#",
            "include <linux/rculist_bl.h>\n#",
            "include <linux/backing-dev.h>\n#",
            "include <linux/mutex.h>\n#",
            "include <linux/idr.h>\n#",
            "include <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#",
            "include <linux/security.h>\n#",
            "include <linux/mount.h>\n#",
            "include <linux/blkdev.h>\n#",
            "include <linux/slab.h>\n#",
            "include <linux/export.h>\n#"
          ],
          "macros_used": [],
          "globals_used": [
            "tatic DEFINE_SPINLOCK(sb_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "include \"internal.h\"\ninclude <linux/lockdep.h>\n#\ninclude <linux/fsnotify.h>\n#\ninclude <linux/cleancache.h>\n#\ninclude <linux/rculist_bl.h>\n#\ninclude <linux/backing-dev.h>\n#\ninclude <linux/mutex.h>\n#\ninclude <linux/idr.h>\n#\ninclude <linux/writeback.h>\t\t/* for the emergency remount stuff */\n#\ninclude <linux/security.h>\n#\ninclude <linux/mount.h>\n#\ninclude <linux/blkdev.h>\n#\ninclude <linux/slab.h>\n#\ninclude <linux/export.h>\n#\n\ntatic DEFINE_SPINLOCK(sb_lock);\n\noid generic_shutdown_super(struct super_block *sb)\n{\n\tconst struct super_operations *sop = sb->s_op;\n\n\tif (sb->s_root) {\n\t\tshrink_dcache_for_umount(sb);\n\t\tsync_filesystem(sb);\n\t\tsb->s_flags &= ~MS_ACTIVE;\n\n\t\tfsnotify_unmount_inodes(&sb->s_inodes);\n\n\t\tevict_inodes(sb);\n\n\t\tif (sb->s_dio_done_wq) {\n\t\t\tdestroy_workqueue(sb->s_dio_done_wq);\n\t\t\tsb->s_dio_done_wq = NULL;\n\t\t}\n\n\t\tif (sop->put_super)\n\t\t\tsop->put_super(sb);\n\n\t\tif (!list_empty(&sb->s_inodes)) {\n\t\t\tprintk(\"VFS: Busy inodes after unmount of %s. \"\n\t\t\t   \"Self-destruct in 5 seconds.  Have a nice day...\\n\",\n\t\t\t   sb->s_id);\n\t\t}\n\t}\n\tspin_lock(&sb_lock);\n\t/* should be initialized for __put_super_and_need_restart() */\n\thlist_del_init(&sb->s_instances);\n\tspin_unlock(&sb_lock);\n\tup_write(&sb->s_umount);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cancel_work_sync",
          "args": [
            "&fs_info->async_reclaim_work"
          ],
          "line": 1524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_remount_begin",
          "args": [
            "fs_info",
            "old_opts",
            "*flags"
          ],
          "line": 1512
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_remount_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "1445-1457",
          "snippet": "static inline void btrfs_remount_begin(struct btrfs_fs_info *fs_info,\n\t\t\t\t       unsigned long old_opts, int flags)\n{\n\tif (btrfs_raw_test_opt(old_opts, AUTO_DEFRAG) &&\n\t    (!btrfs_raw_test_opt(fs_info->mount_opt, AUTO_DEFRAG) ||\n\t     (flags & MS_RDONLY))) {\n\t\t/* wait for any defraggers to finish */\n\t\twait_event(fs_info->transaction_wait,\n\t\t\t   (atomic_read(&fs_info->defrag_running) == 0));\n\t\tif (flags & MS_RDONLY)\n\t\t\tsync_filesystem(fs_info->sb);\n\t}\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nstatic inline void btrfs_remount_begin(struct btrfs_fs_info *fs_info,\n\t\t\t\t       unsigned long old_opts, int flags)\n{\n\tif (btrfs_raw_test_opt(old_opts, AUTO_DEFRAG) &&\n\t    (!btrfs_raw_test_opt(fs_info->mount_opt, AUTO_DEFRAG) ||\n\t     (flags & MS_RDONLY))) {\n\t\t/* wait for any defraggers to finish */\n\t\twait_event(fs_info->transaction_wait,\n\t\t\t   (atomic_read(&fs_info->defrag_running) == 0));\n\t\tif (flags & MS_RDONLY)\n\t\t\tsync_filesystem(fs_info->sb);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_parse_options",
          "args": [
            "root",
            "data"
          ],
          "line": 1506
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_parse_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "388-759",
          "snippet": "int btrfs_parse_options(struct btrfs_root *root, char *options)\n{\n\tstruct btrfs_fs_info *info = root->fs_info;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tchar *p, *num, *orig = NULL;\n\tu64 cache_gen;\n\tint intarg;\n\tint ret = 0;\n\tchar *compress_type;\n\tbool compress_force = false;\n\n\tcache_gen = btrfs_super_cache_generation(root->fs_info->super_copy);\n\tif (cache_gen)\n\t\tbtrfs_set_opt(info->mount_opt, SPACE_CACHE);\n\n\tif (!options)\n\t\tgoto out;\n\n\t/*\n\t * strsep changes the string, duplicate it because parse_options\n\t * gets called twice\n\t */\n\toptions = kstrdup(options, GFP_NOFS);\n\tif (!options)\n\t\treturn -ENOMEM;\n\n\torig = options;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_degraded:\n\t\t\tbtrfs_info(root->fs_info, \"allowing degraded mounts\");\n\t\t\tbtrfs_set_opt(info->mount_opt, DEGRADED);\n\t\t\tbreak;\n\t\tcase Opt_subvol:\n\t\tcase Opt_subvolid:\n\t\tcase Opt_subvolrootid:\n\t\tcase Opt_device:\n\t\t\t/*\n\t\t\t * These are parsed by btrfs_parse_early_options\n\t\t\t * and can be happily ignored here.\n\t\t\t */\n\t\t\tbreak;\n\t\tcase Opt_nodatasum:\n\t\t\tbtrfs_set_and_info(root, NODATASUM,\n\t\t\t\t\t   \"setting nodatasum\");\n\t\t\tbreak;\n\t\tcase Opt_datasum:\n\t\t\tif (btrfs_test_opt(root, NODATASUM)) {\n\t\t\t\tif (btrfs_test_opt(root, NODATACOW))\n\t\t\t\t\tbtrfs_info(root->fs_info, \"setting datasum, datacow enabled\");\n\t\t\t\telse\n\t\t\t\t\tbtrfs_info(root->fs_info, \"setting datasum\");\n\t\t\t}\n\t\t\tbtrfs_clear_opt(info->mount_opt, NODATACOW);\n\t\t\tbtrfs_clear_opt(info->mount_opt, NODATASUM);\n\t\t\tbreak;\n\t\tcase Opt_nodatacow:\n\t\t\tif (!btrfs_test_opt(root, NODATACOW)) {\n\t\t\t\tif (!btrfs_test_opt(root, COMPRESS) ||\n\t\t\t\t    !btrfs_test_opt(root, FORCE_COMPRESS)) {\n\t\t\t\t\tbtrfs_info(root->fs_info,\n\t\t\t\t\t\t   \"setting nodatacow, compression disabled\");\n\t\t\t\t} else {\n\t\t\t\t\tbtrfs_info(root->fs_info, \"setting nodatacow\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbtrfs_clear_opt(info->mount_opt, COMPRESS);\n\t\t\tbtrfs_clear_opt(info->mount_opt, FORCE_COMPRESS);\n\t\t\tbtrfs_set_opt(info->mount_opt, NODATACOW);\n\t\t\tbtrfs_set_opt(info->mount_opt, NODATASUM);\n\t\t\tbreak;\n\t\tcase Opt_datacow:\n\t\t\tbtrfs_clear_and_info(root, NODATACOW,\n\t\t\t\t\t     \"setting datacow\");\n\t\t\tbreak;\n\t\tcase Opt_compress_force:\n\t\tcase Opt_compress_force_type:\n\t\t\tcompress_force = true;\n\t\t\t/* Fallthrough */\n\t\tcase Opt_compress:\n\t\tcase Opt_compress_type:\n\t\t\tif (token == Opt_compress ||\n\t\t\t    token == Opt_compress_force ||\n\t\t\t    strcmp(args[0].from, \"zlib\") == 0) {\n\t\t\t\tcompress_type = \"zlib\";\n\t\t\t\tinfo->compress_type = BTRFS_COMPRESS_ZLIB;\n\t\t\t\tbtrfs_set_opt(info->mount_opt, COMPRESS);\n\t\t\t\tbtrfs_clear_opt(info->mount_opt, NODATACOW);\n\t\t\t\tbtrfs_clear_opt(info->mount_opt, NODATASUM);\n\t\t\t} else if (strcmp(args[0].from, \"lzo\") == 0) {\n\t\t\t\tcompress_type = \"lzo\";\n\t\t\t\tinfo->compress_type = BTRFS_COMPRESS_LZO;\n\t\t\t\tbtrfs_set_opt(info->mount_opt, COMPRESS);\n\t\t\t\tbtrfs_clear_opt(info->mount_opt, NODATACOW);\n\t\t\t\tbtrfs_clear_opt(info->mount_opt, NODATASUM);\n\t\t\t\tbtrfs_set_fs_incompat(info, COMPRESS_LZO);\n\t\t\t} else if (strncmp(args[0].from, \"no\", 2) == 0) {\n\t\t\t\tcompress_type = \"no\";\n\t\t\t\tbtrfs_clear_opt(info->mount_opt, COMPRESS);\n\t\t\t\tbtrfs_clear_opt(info->mount_opt, FORCE_COMPRESS);\n\t\t\t\tcompress_force = false;\n\t\t\t} else {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (compress_force) {\n\t\t\t\tbtrfs_set_and_info(root, FORCE_COMPRESS,\n\t\t\t\t\t\t   \"force %s compression\",\n\t\t\t\t\t\t   compress_type);\n\t\t\t} else {\n\t\t\t\tif (!btrfs_test_opt(root, COMPRESS))\n\t\t\t\t\tbtrfs_info(root->fs_info,\n\t\t\t\t\t\t   \"btrfs: use %s compression\",\n\t\t\t\t\t\t   compress_type);\n\t\t\t\t/*\n\t\t\t\t * If we remount from compress-force=xxx to\n\t\t\t\t * compress=xxx, we need clear FORCE_COMPRESS\n\t\t\t\t * flag, otherwise, there is no way for users\n\t\t\t\t * to disable forcible compression separately.\n\t\t\t\t */\n\t\t\t\tbtrfs_clear_opt(info->mount_opt, FORCE_COMPRESS);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_ssd:\n\t\t\tbtrfs_set_and_info(root, SSD,\n\t\t\t\t\t   \"use ssd allocation scheme\");\n\t\t\tbreak;\n\t\tcase Opt_ssd_spread:\n\t\t\tbtrfs_set_and_info(root, SSD_SPREAD,\n\t\t\t\t\t   \"use spread ssd allocation scheme\");\n\t\t\tbtrfs_set_opt(info->mount_opt, SSD);\n\t\t\tbreak;\n\t\tcase Opt_nossd:\n\t\t\tbtrfs_set_and_info(root, NOSSD,\n\t\t\t\t\t     \"not using ssd allocation scheme\");\n\t\t\tbtrfs_clear_opt(info->mount_opt, SSD);\n\t\t\tbreak;\n\t\tcase Opt_barrier:\n\t\t\tbtrfs_clear_and_info(root, NOBARRIER,\n\t\t\t\t\t     \"turning on barriers\");\n\t\t\tbreak;\n\t\tcase Opt_nobarrier:\n\t\t\tbtrfs_set_and_info(root, NOBARRIER,\n\t\t\t\t\t   \"turning off barriers\");\n\t\t\tbreak;\n\t\tcase Opt_thread_pool:\n\t\t\tret = match_int(&args[0], &intarg);\n\t\t\tif (ret) {\n\t\t\t\tgoto out;\n\t\t\t} else if (intarg > 0) {\n\t\t\t\tinfo->thread_pool_size = intarg;\n\t\t\t} else {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_max_inline:\n\t\t\tnum = match_strdup(&args[0]);\n\t\t\tif (num) {\n\t\t\t\tinfo->max_inline = memparse(num, NULL);\n\t\t\t\tkfree(num);\n\n\t\t\t\tif (info->max_inline) {\n\t\t\t\t\tinfo->max_inline = min_t(u64,\n\t\t\t\t\t\tinfo->max_inline,\n\t\t\t\t\t\troot->sectorsize);\n\t\t\t\t}\n\t\t\t\tbtrfs_info(root->fs_info, \"max_inline at %llu\",\n\t\t\t\t\tinfo->max_inline);\n\t\t\t} else {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_alloc_start:\n\t\t\tnum = match_strdup(&args[0]);\n\t\t\tif (num) {\n\t\t\t\tmutex_lock(&info->chunk_mutex);\n\t\t\t\tinfo->alloc_start = memparse(num, NULL);\n\t\t\t\tmutex_unlock(&info->chunk_mutex);\n\t\t\t\tkfree(num);\n\t\t\t\tbtrfs_info(root->fs_info, \"allocations start at %llu\",\n\t\t\t\t\tinfo->alloc_start);\n\t\t\t} else {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_acl:\n#ifdef CONFIG_BTRFS_FS_POSIX_ACL\n\t\t\troot->fs_info->sb->s_flags |= MS_POSIXACL;\n\t\t\tbreak;\n#else\n\t\t\tbtrfs_err(root->fs_info,\n\t\t\t\t\"support for ACL not compiled in!\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n#endif\n\t\tcase Opt_noacl:\n\t\t\troot->fs_info->sb->s_flags &= ~MS_POSIXACL;\n\t\t\tbreak;\n\t\tcase Opt_notreelog:\n\t\t\tbtrfs_set_and_info(root, NOTREELOG,\n\t\t\t\t\t   \"disabling tree log\");\n\t\t\tbreak;\n\t\tcase Opt_treelog:\n\t\t\tbtrfs_clear_and_info(root, NOTREELOG,\n\t\t\t\t\t     \"enabling tree log\");\n\t\t\tbreak;\n\t\tcase Opt_flushoncommit:\n\t\t\tbtrfs_set_and_info(root, FLUSHONCOMMIT,\n\t\t\t\t\t   \"turning on flush-on-commit\");\n\t\t\tbreak;\n\t\tcase Opt_noflushoncommit:\n\t\t\tbtrfs_clear_and_info(root, FLUSHONCOMMIT,\n\t\t\t\t\t     \"turning off flush-on-commit\");\n\t\t\tbreak;\n\t\tcase Opt_ratio:\n\t\t\tret = match_int(&args[0], &intarg);\n\t\t\tif (ret) {\n\t\t\t\tgoto out;\n\t\t\t} else if (intarg >= 0) {\n\t\t\t\tinfo->metadata_ratio = intarg;\n\t\t\t\tbtrfs_info(root->fs_info, \"metadata ratio %d\",\n\t\t\t\t       info->metadata_ratio);\n\t\t\t} else {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_discard:\n\t\t\tbtrfs_set_and_info(root, DISCARD,\n\t\t\t\t\t   \"turning on discard\");\n\t\t\tbreak;\n\t\tcase Opt_nodiscard:\n\t\t\tbtrfs_clear_and_info(root, DISCARD,\n\t\t\t\t\t     \"turning off discard\");\n\t\t\tbreak;\n\t\tcase Opt_space_cache:\n\t\t\tbtrfs_set_and_info(root, SPACE_CACHE,\n\t\t\t\t\t   \"enabling disk space caching\");\n\t\t\tbreak;\n\t\tcase Opt_rescan_uuid_tree:\n\t\t\tbtrfs_set_opt(info->mount_opt, RESCAN_UUID_TREE);\n\t\t\tbreak;\n\t\tcase Opt_no_space_cache:\n\t\t\tbtrfs_clear_and_info(root, SPACE_CACHE,\n\t\t\t\t\t     \"disabling disk space caching\");\n\t\t\tbreak;\n\t\tcase Opt_inode_cache:\n\t\t\tbtrfs_set_pending_and_info(info, INODE_MAP_CACHE,\n\t\t\t\t\t   \"enabling inode map caching\");\n\t\t\tbreak;\n\t\tcase Opt_noinode_cache:\n\t\t\tbtrfs_clear_pending_and_info(info, INODE_MAP_CACHE,\n\t\t\t\t\t     \"disabling inode map caching\");\n\t\t\tbreak;\n\t\tcase Opt_clear_cache:\n\t\t\tbtrfs_set_and_info(root, CLEAR_CACHE,\n\t\t\t\t\t   \"force clearing of disk cache\");\n\t\t\tbreak;\n\t\tcase Opt_user_subvol_rm_allowed:\n\t\t\tbtrfs_set_opt(info->mount_opt, USER_SUBVOL_RM_ALLOWED);\n\t\t\tbreak;\n\t\tcase Opt_enospc_debug:\n\t\t\tbtrfs_set_opt(info->mount_opt, ENOSPC_DEBUG);\n\t\t\tbreak;\n\t\tcase Opt_noenospc_debug:\n\t\t\tbtrfs_clear_opt(info->mount_opt, ENOSPC_DEBUG);\n\t\t\tbreak;\n\t\tcase Opt_defrag:\n\t\t\tbtrfs_set_and_info(root, AUTO_DEFRAG,\n\t\t\t\t\t   \"enabling auto defrag\");\n\t\t\tbreak;\n\t\tcase Opt_nodefrag:\n\t\t\tbtrfs_clear_and_info(root, AUTO_DEFRAG,\n\t\t\t\t\t     \"disabling auto defrag\");\n\t\t\tbreak;\n\t\tcase Opt_recovery:\n\t\t\tbtrfs_info(root->fs_info, \"enabling auto recovery\");\n\t\t\tbtrfs_set_opt(info->mount_opt, RECOVERY);\n\t\t\tbreak;\n\t\tcase Opt_skip_balance:\n\t\t\tbtrfs_set_opt(info->mount_opt, SKIP_BALANCE);\n\t\t\tbreak;\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\t\tcase Opt_check_integrity_including_extent_data:\n\t\t\tbtrfs_info(root->fs_info,\n\t\t\t\t   \"enabling check integrity including extent data\");\n\t\t\tbtrfs_set_opt(info->mount_opt,\n\t\t\t\t      CHECK_INTEGRITY_INCLUDING_EXTENT_DATA);\n\t\t\tbtrfs_set_opt(info->mount_opt, CHECK_INTEGRITY);\n\t\t\tbreak;\n\t\tcase Opt_check_integrity:\n\t\t\tbtrfs_info(root->fs_info, \"enabling check integrity\");\n\t\t\tbtrfs_set_opt(info->mount_opt, CHECK_INTEGRITY);\n\t\t\tbreak;\n\t\tcase Opt_check_integrity_print_mask:\n\t\t\tret = match_int(&args[0], &intarg);\n\t\t\tif (ret) {\n\t\t\t\tgoto out;\n\t\t\t} else if (intarg >= 0) {\n\t\t\t\tinfo->check_integrity_print_mask = intarg;\n\t\t\t\tbtrfs_info(root->fs_info, \"check_integrity_print_mask 0x%x\",\n\t\t\t\t       info->check_integrity_print_mask);\n\t\t\t} else {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n#else\n\t\tcase Opt_check_integrity_including_extent_data:\n\t\tcase Opt_check_integrity:\n\t\tcase Opt_check_integrity_print_mask:\n\t\t\tbtrfs_err(root->fs_info,\n\t\t\t\t\"support for check_integrity* not compiled in!\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n#endif\n\t\tcase Opt_fatal_errors:\n\t\t\tif (strcmp(args[0].from, \"panic\") == 0)\n\t\t\t\tbtrfs_set_opt(info->mount_opt,\n\t\t\t\t\t      PANIC_ON_FATAL_ERROR);\n\t\t\telse if (strcmp(args[0].from, \"bug\") == 0)\n\t\t\t\tbtrfs_clear_opt(info->mount_opt,\n\t\t\t\t\t      PANIC_ON_FATAL_ERROR);\n\t\t\telse {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_commit_interval:\n\t\t\tintarg = 0;\n\t\t\tret = match_int(&args[0], &intarg);\n\t\t\tif (ret < 0) {\n\t\t\t\tbtrfs_err(root->fs_info, \"invalid commit interval\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (intarg > 0) {\n\t\t\t\tif (intarg > 300) {\n\t\t\t\t\tbtrfs_warn(root->fs_info, \"excessive commit interval %d\",\n\t\t\t\t\t\t\tintarg);\n\t\t\t\t}\n\t\t\t\tinfo->commit_interval = intarg;\n\t\t\t} else {\n\t\t\t\tbtrfs_info(root->fs_info, \"using default commit interval %ds\",\n\t\t\t\t    BTRFS_DEFAULT_COMMIT_INTERVAL);\n\t\t\t\tinfo->commit_interval = BTRFS_DEFAULT_COMMIT_INTERVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_err:\n\t\t\tbtrfs_info(root->fs_info, \"unrecognized mount option '%s'\", p);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tif (!ret && btrfs_test_opt(root, SPACE_CACHE))\n\t\tbtrfs_info(root->fs_info, \"disk space caching is enabled\");\n\tkfree(orig);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_remount(struct super_block *sb, int *flags, char *data);",
            "static match_table_t tokens = {\n\t{Opt_degraded, \"degraded\"},\n\t{Opt_subvol, \"subvol=%s\"},\n\t{Opt_subvolid, \"subvolid=%s\"},\n\t{Opt_device, \"device=%s\"},\n\t{Opt_nodatasum, \"nodatasum\"},\n\t{Opt_datasum, \"datasum\"},\n\t{Opt_nodatacow, \"nodatacow\"},\n\t{Opt_datacow, \"datacow\"},\n\t{Opt_nobarrier, \"nobarrier\"},\n\t{Opt_barrier, \"barrier\"},\n\t{Opt_max_inline, \"max_inline=%s\"},\n\t{Opt_alloc_start, \"alloc_start=%s\"},\n\t{Opt_thread_pool, \"thread_pool=%d\"},\n\t{Opt_compress, \"compress\"},\n\t{Opt_compress_type, \"compress=%s\"},\n\t{Opt_compress_force, \"compress-force\"},\n\t{Opt_compress_force_type, \"compress-force=%s\"},\n\t{Opt_ssd, \"ssd\"},\n\t{Opt_ssd_spread, \"ssd_spread\"},\n\t{Opt_nossd, \"nossd\"},\n\t{Opt_acl, \"acl\"},\n\t{Opt_noacl, \"noacl\"},\n\t{Opt_notreelog, \"notreelog\"},\n\t{Opt_treelog, \"treelog\"},\n\t{Opt_flushoncommit, \"flushoncommit\"},\n\t{Opt_noflushoncommit, \"noflushoncommit\"},\n\t{Opt_ratio, \"metadata_ratio=%d\"},\n\t{Opt_discard, \"discard\"},\n\t{Opt_nodiscard, \"nodiscard\"},\n\t{Opt_space_cache, \"space_cache\"},\n\t{Opt_clear_cache, \"clear_cache\"},\n\t{Opt_user_subvol_rm_allowed, \"user_subvol_rm_allowed\"},\n\t{Opt_enospc_debug, \"enospc_debug\"},\n\t{Opt_noenospc_debug, \"noenospc_debug\"},\n\t{Opt_subvolrootid, \"subvolrootid=%d\"},\n\t{Opt_defrag, \"autodefrag\"},\n\t{Opt_nodefrag, \"noautodefrag\"},\n\t{Opt_inode_cache, \"inode_cache\"},\n\t{Opt_noinode_cache, \"noinode_cache\"},\n\t{Opt_no_space_cache, \"nospace_cache\"},\n\t{Opt_recovery, \"recovery\"},\n\t{Opt_skip_balance, \"skip_balance\"},\n\t{Opt_check_integrity, \"check_int\"},\n\t{Opt_check_integrity_including_extent_data, \"check_int_data\"},\n\t{Opt_check_integrity_print_mask, \"check_int_print_mask=%d\"},\n\t{Opt_rescan_uuid_tree, \"rescan_uuid_tree\"},\n\t{Opt_fatal_errors, \"fatal_errors=%s\"},\n\t{Opt_commit_interval, \"commit=%d\"},\n\t{Opt_err, NULL},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nstatic int btrfs_remount(struct super_block *sb, int *flags, char *data);\nstatic match_table_t tokens = {\n\t{Opt_degraded, \"degraded\"},\n\t{Opt_subvol, \"subvol=%s\"},\n\t{Opt_subvolid, \"subvolid=%s\"},\n\t{Opt_device, \"device=%s\"},\n\t{Opt_nodatasum, \"nodatasum\"},\n\t{Opt_datasum, \"datasum\"},\n\t{Opt_nodatacow, \"nodatacow\"},\n\t{Opt_datacow, \"datacow\"},\n\t{Opt_nobarrier, \"nobarrier\"},\n\t{Opt_barrier, \"barrier\"},\n\t{Opt_max_inline, \"max_inline=%s\"},\n\t{Opt_alloc_start, \"alloc_start=%s\"},\n\t{Opt_thread_pool, \"thread_pool=%d\"},\n\t{Opt_compress, \"compress\"},\n\t{Opt_compress_type, \"compress=%s\"},\n\t{Opt_compress_force, \"compress-force\"},\n\t{Opt_compress_force_type, \"compress-force=%s\"},\n\t{Opt_ssd, \"ssd\"},\n\t{Opt_ssd_spread, \"ssd_spread\"},\n\t{Opt_nossd, \"nossd\"},\n\t{Opt_acl, \"acl\"},\n\t{Opt_noacl, \"noacl\"},\n\t{Opt_notreelog, \"notreelog\"},\n\t{Opt_treelog, \"treelog\"},\n\t{Opt_flushoncommit, \"flushoncommit\"},\n\t{Opt_noflushoncommit, \"noflushoncommit\"},\n\t{Opt_ratio, \"metadata_ratio=%d\"},\n\t{Opt_discard, \"discard\"},\n\t{Opt_nodiscard, \"nodiscard\"},\n\t{Opt_space_cache, \"space_cache\"},\n\t{Opt_clear_cache, \"clear_cache\"},\n\t{Opt_user_subvol_rm_allowed, \"user_subvol_rm_allowed\"},\n\t{Opt_enospc_debug, \"enospc_debug\"},\n\t{Opt_noenospc_debug, \"noenospc_debug\"},\n\t{Opt_subvolrootid, \"subvolrootid=%d\"},\n\t{Opt_defrag, \"autodefrag\"},\n\t{Opt_nodefrag, \"noautodefrag\"},\n\t{Opt_inode_cache, \"inode_cache\"},\n\t{Opt_noinode_cache, \"noinode_cache\"},\n\t{Opt_no_space_cache, \"nospace_cache\"},\n\t{Opt_recovery, \"recovery\"},\n\t{Opt_skip_balance, \"skip_balance\"},\n\t{Opt_check_integrity, \"check_int\"},\n\t{Opt_check_integrity_including_extent_data, \"check_int_data\"},\n\t{Opt_check_integrity_print_mask, \"check_int_print_mask=%d\"},\n\t{Opt_rescan_uuid_tree, \"rescan_uuid_tree\"},\n\t{Opt_fatal_errors, \"fatal_errors=%s\"},\n\t{Opt_commit_interval, \"commit=%d\"},\n\t{Opt_err, NULL},\n};\n\nint btrfs_parse_options(struct btrfs_root *root, char *options)\n{\n\tstruct btrfs_fs_info *info = root->fs_info;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tchar *p, *num, *orig = NULL;\n\tu64 cache_gen;\n\tint intarg;\n\tint ret = 0;\n\tchar *compress_type;\n\tbool compress_force = false;\n\n\tcache_gen = btrfs_super_cache_generation(root->fs_info->super_copy);\n\tif (cache_gen)\n\t\tbtrfs_set_opt(info->mount_opt, SPACE_CACHE);\n\n\tif (!options)\n\t\tgoto out;\n\n\t/*\n\t * strsep changes the string, duplicate it because parse_options\n\t * gets called twice\n\t */\n\toptions = kstrdup(options, GFP_NOFS);\n\tif (!options)\n\t\treturn -ENOMEM;\n\n\torig = options;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_degraded:\n\t\t\tbtrfs_info(root->fs_info, \"allowing degraded mounts\");\n\t\t\tbtrfs_set_opt(info->mount_opt, DEGRADED);\n\t\t\tbreak;\n\t\tcase Opt_subvol:\n\t\tcase Opt_subvolid:\n\t\tcase Opt_subvolrootid:\n\t\tcase Opt_device:\n\t\t\t/*\n\t\t\t * These are parsed by btrfs_parse_early_options\n\t\t\t * and can be happily ignored here.\n\t\t\t */\n\t\t\tbreak;\n\t\tcase Opt_nodatasum:\n\t\t\tbtrfs_set_and_info(root, NODATASUM,\n\t\t\t\t\t   \"setting nodatasum\");\n\t\t\tbreak;\n\t\tcase Opt_datasum:\n\t\t\tif (btrfs_test_opt(root, NODATASUM)) {\n\t\t\t\tif (btrfs_test_opt(root, NODATACOW))\n\t\t\t\t\tbtrfs_info(root->fs_info, \"setting datasum, datacow enabled\");\n\t\t\t\telse\n\t\t\t\t\tbtrfs_info(root->fs_info, \"setting datasum\");\n\t\t\t}\n\t\t\tbtrfs_clear_opt(info->mount_opt, NODATACOW);\n\t\t\tbtrfs_clear_opt(info->mount_opt, NODATASUM);\n\t\t\tbreak;\n\t\tcase Opt_nodatacow:\n\t\t\tif (!btrfs_test_opt(root, NODATACOW)) {\n\t\t\t\tif (!btrfs_test_opt(root, COMPRESS) ||\n\t\t\t\t    !btrfs_test_opt(root, FORCE_COMPRESS)) {\n\t\t\t\t\tbtrfs_info(root->fs_info,\n\t\t\t\t\t\t   \"setting nodatacow, compression disabled\");\n\t\t\t\t} else {\n\t\t\t\t\tbtrfs_info(root->fs_info, \"setting nodatacow\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbtrfs_clear_opt(info->mount_opt, COMPRESS);\n\t\t\tbtrfs_clear_opt(info->mount_opt, FORCE_COMPRESS);\n\t\t\tbtrfs_set_opt(info->mount_opt, NODATACOW);\n\t\t\tbtrfs_set_opt(info->mount_opt, NODATASUM);\n\t\t\tbreak;\n\t\tcase Opt_datacow:\n\t\t\tbtrfs_clear_and_info(root, NODATACOW,\n\t\t\t\t\t     \"setting datacow\");\n\t\t\tbreak;\n\t\tcase Opt_compress_force:\n\t\tcase Opt_compress_force_type:\n\t\t\tcompress_force = true;\n\t\t\t/* Fallthrough */\n\t\tcase Opt_compress:\n\t\tcase Opt_compress_type:\n\t\t\tif (token == Opt_compress ||\n\t\t\t    token == Opt_compress_force ||\n\t\t\t    strcmp(args[0].from, \"zlib\") == 0) {\n\t\t\t\tcompress_type = \"zlib\";\n\t\t\t\tinfo->compress_type = BTRFS_COMPRESS_ZLIB;\n\t\t\t\tbtrfs_set_opt(info->mount_opt, COMPRESS);\n\t\t\t\tbtrfs_clear_opt(info->mount_opt, NODATACOW);\n\t\t\t\tbtrfs_clear_opt(info->mount_opt, NODATASUM);\n\t\t\t} else if (strcmp(args[0].from, \"lzo\") == 0) {\n\t\t\t\tcompress_type = \"lzo\";\n\t\t\t\tinfo->compress_type = BTRFS_COMPRESS_LZO;\n\t\t\t\tbtrfs_set_opt(info->mount_opt, COMPRESS);\n\t\t\t\tbtrfs_clear_opt(info->mount_opt, NODATACOW);\n\t\t\t\tbtrfs_clear_opt(info->mount_opt, NODATASUM);\n\t\t\t\tbtrfs_set_fs_incompat(info, COMPRESS_LZO);\n\t\t\t} else if (strncmp(args[0].from, \"no\", 2) == 0) {\n\t\t\t\tcompress_type = \"no\";\n\t\t\t\tbtrfs_clear_opt(info->mount_opt, COMPRESS);\n\t\t\t\tbtrfs_clear_opt(info->mount_opt, FORCE_COMPRESS);\n\t\t\t\tcompress_force = false;\n\t\t\t} else {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (compress_force) {\n\t\t\t\tbtrfs_set_and_info(root, FORCE_COMPRESS,\n\t\t\t\t\t\t   \"force %s compression\",\n\t\t\t\t\t\t   compress_type);\n\t\t\t} else {\n\t\t\t\tif (!btrfs_test_opt(root, COMPRESS))\n\t\t\t\t\tbtrfs_info(root->fs_info,\n\t\t\t\t\t\t   \"btrfs: use %s compression\",\n\t\t\t\t\t\t   compress_type);\n\t\t\t\t/*\n\t\t\t\t * If we remount from compress-force=xxx to\n\t\t\t\t * compress=xxx, we need clear FORCE_COMPRESS\n\t\t\t\t * flag, otherwise, there is no way for users\n\t\t\t\t * to disable forcible compression separately.\n\t\t\t\t */\n\t\t\t\tbtrfs_clear_opt(info->mount_opt, FORCE_COMPRESS);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_ssd:\n\t\t\tbtrfs_set_and_info(root, SSD,\n\t\t\t\t\t   \"use ssd allocation scheme\");\n\t\t\tbreak;\n\t\tcase Opt_ssd_spread:\n\t\t\tbtrfs_set_and_info(root, SSD_SPREAD,\n\t\t\t\t\t   \"use spread ssd allocation scheme\");\n\t\t\tbtrfs_set_opt(info->mount_opt, SSD);\n\t\t\tbreak;\n\t\tcase Opt_nossd:\n\t\t\tbtrfs_set_and_info(root, NOSSD,\n\t\t\t\t\t     \"not using ssd allocation scheme\");\n\t\t\tbtrfs_clear_opt(info->mount_opt, SSD);\n\t\t\tbreak;\n\t\tcase Opt_barrier:\n\t\t\tbtrfs_clear_and_info(root, NOBARRIER,\n\t\t\t\t\t     \"turning on barriers\");\n\t\t\tbreak;\n\t\tcase Opt_nobarrier:\n\t\t\tbtrfs_set_and_info(root, NOBARRIER,\n\t\t\t\t\t   \"turning off barriers\");\n\t\t\tbreak;\n\t\tcase Opt_thread_pool:\n\t\t\tret = match_int(&args[0], &intarg);\n\t\t\tif (ret) {\n\t\t\t\tgoto out;\n\t\t\t} else if (intarg > 0) {\n\t\t\t\tinfo->thread_pool_size = intarg;\n\t\t\t} else {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_max_inline:\n\t\t\tnum = match_strdup(&args[0]);\n\t\t\tif (num) {\n\t\t\t\tinfo->max_inline = memparse(num, NULL);\n\t\t\t\tkfree(num);\n\n\t\t\t\tif (info->max_inline) {\n\t\t\t\t\tinfo->max_inline = min_t(u64,\n\t\t\t\t\t\tinfo->max_inline,\n\t\t\t\t\t\troot->sectorsize);\n\t\t\t\t}\n\t\t\t\tbtrfs_info(root->fs_info, \"max_inline at %llu\",\n\t\t\t\t\tinfo->max_inline);\n\t\t\t} else {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_alloc_start:\n\t\t\tnum = match_strdup(&args[0]);\n\t\t\tif (num) {\n\t\t\t\tmutex_lock(&info->chunk_mutex);\n\t\t\t\tinfo->alloc_start = memparse(num, NULL);\n\t\t\t\tmutex_unlock(&info->chunk_mutex);\n\t\t\t\tkfree(num);\n\t\t\t\tbtrfs_info(root->fs_info, \"allocations start at %llu\",\n\t\t\t\t\tinfo->alloc_start);\n\t\t\t} else {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_acl:\n#ifdef CONFIG_BTRFS_FS_POSIX_ACL\n\t\t\troot->fs_info->sb->s_flags |= MS_POSIXACL;\n\t\t\tbreak;\n#else\n\t\t\tbtrfs_err(root->fs_info,\n\t\t\t\t\"support for ACL not compiled in!\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n#endif\n\t\tcase Opt_noacl:\n\t\t\troot->fs_info->sb->s_flags &= ~MS_POSIXACL;\n\t\t\tbreak;\n\t\tcase Opt_notreelog:\n\t\t\tbtrfs_set_and_info(root, NOTREELOG,\n\t\t\t\t\t   \"disabling tree log\");\n\t\t\tbreak;\n\t\tcase Opt_treelog:\n\t\t\tbtrfs_clear_and_info(root, NOTREELOG,\n\t\t\t\t\t     \"enabling tree log\");\n\t\t\tbreak;\n\t\tcase Opt_flushoncommit:\n\t\t\tbtrfs_set_and_info(root, FLUSHONCOMMIT,\n\t\t\t\t\t   \"turning on flush-on-commit\");\n\t\t\tbreak;\n\t\tcase Opt_noflushoncommit:\n\t\t\tbtrfs_clear_and_info(root, FLUSHONCOMMIT,\n\t\t\t\t\t     \"turning off flush-on-commit\");\n\t\t\tbreak;\n\t\tcase Opt_ratio:\n\t\t\tret = match_int(&args[0], &intarg);\n\t\t\tif (ret) {\n\t\t\t\tgoto out;\n\t\t\t} else if (intarg >= 0) {\n\t\t\t\tinfo->metadata_ratio = intarg;\n\t\t\t\tbtrfs_info(root->fs_info, \"metadata ratio %d\",\n\t\t\t\t       info->metadata_ratio);\n\t\t\t} else {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_discard:\n\t\t\tbtrfs_set_and_info(root, DISCARD,\n\t\t\t\t\t   \"turning on discard\");\n\t\t\tbreak;\n\t\tcase Opt_nodiscard:\n\t\t\tbtrfs_clear_and_info(root, DISCARD,\n\t\t\t\t\t     \"turning off discard\");\n\t\t\tbreak;\n\t\tcase Opt_space_cache:\n\t\t\tbtrfs_set_and_info(root, SPACE_CACHE,\n\t\t\t\t\t   \"enabling disk space caching\");\n\t\t\tbreak;\n\t\tcase Opt_rescan_uuid_tree:\n\t\t\tbtrfs_set_opt(info->mount_opt, RESCAN_UUID_TREE);\n\t\t\tbreak;\n\t\tcase Opt_no_space_cache:\n\t\t\tbtrfs_clear_and_info(root, SPACE_CACHE,\n\t\t\t\t\t     \"disabling disk space caching\");\n\t\t\tbreak;\n\t\tcase Opt_inode_cache:\n\t\t\tbtrfs_set_pending_and_info(info, INODE_MAP_CACHE,\n\t\t\t\t\t   \"enabling inode map caching\");\n\t\t\tbreak;\n\t\tcase Opt_noinode_cache:\n\t\t\tbtrfs_clear_pending_and_info(info, INODE_MAP_CACHE,\n\t\t\t\t\t     \"disabling inode map caching\");\n\t\t\tbreak;\n\t\tcase Opt_clear_cache:\n\t\t\tbtrfs_set_and_info(root, CLEAR_CACHE,\n\t\t\t\t\t   \"force clearing of disk cache\");\n\t\t\tbreak;\n\t\tcase Opt_user_subvol_rm_allowed:\n\t\t\tbtrfs_set_opt(info->mount_opt, USER_SUBVOL_RM_ALLOWED);\n\t\t\tbreak;\n\t\tcase Opt_enospc_debug:\n\t\t\tbtrfs_set_opt(info->mount_opt, ENOSPC_DEBUG);\n\t\t\tbreak;\n\t\tcase Opt_noenospc_debug:\n\t\t\tbtrfs_clear_opt(info->mount_opt, ENOSPC_DEBUG);\n\t\t\tbreak;\n\t\tcase Opt_defrag:\n\t\t\tbtrfs_set_and_info(root, AUTO_DEFRAG,\n\t\t\t\t\t   \"enabling auto defrag\");\n\t\t\tbreak;\n\t\tcase Opt_nodefrag:\n\t\t\tbtrfs_clear_and_info(root, AUTO_DEFRAG,\n\t\t\t\t\t     \"disabling auto defrag\");\n\t\t\tbreak;\n\t\tcase Opt_recovery:\n\t\t\tbtrfs_info(root->fs_info, \"enabling auto recovery\");\n\t\t\tbtrfs_set_opt(info->mount_opt, RECOVERY);\n\t\t\tbreak;\n\t\tcase Opt_skip_balance:\n\t\t\tbtrfs_set_opt(info->mount_opt, SKIP_BALANCE);\n\t\t\tbreak;\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\t\tcase Opt_check_integrity_including_extent_data:\n\t\t\tbtrfs_info(root->fs_info,\n\t\t\t\t   \"enabling check integrity including extent data\");\n\t\t\tbtrfs_set_opt(info->mount_opt,\n\t\t\t\t      CHECK_INTEGRITY_INCLUDING_EXTENT_DATA);\n\t\t\tbtrfs_set_opt(info->mount_opt, CHECK_INTEGRITY);\n\t\t\tbreak;\n\t\tcase Opt_check_integrity:\n\t\t\tbtrfs_info(root->fs_info, \"enabling check integrity\");\n\t\t\tbtrfs_set_opt(info->mount_opt, CHECK_INTEGRITY);\n\t\t\tbreak;\n\t\tcase Opt_check_integrity_print_mask:\n\t\t\tret = match_int(&args[0], &intarg);\n\t\t\tif (ret) {\n\t\t\t\tgoto out;\n\t\t\t} else if (intarg >= 0) {\n\t\t\t\tinfo->check_integrity_print_mask = intarg;\n\t\t\t\tbtrfs_info(root->fs_info, \"check_integrity_print_mask 0x%x\",\n\t\t\t\t       info->check_integrity_print_mask);\n\t\t\t} else {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n#else\n\t\tcase Opt_check_integrity_including_extent_data:\n\t\tcase Opt_check_integrity:\n\t\tcase Opt_check_integrity_print_mask:\n\t\t\tbtrfs_err(root->fs_info,\n\t\t\t\t\"support for check_integrity* not compiled in!\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n#endif\n\t\tcase Opt_fatal_errors:\n\t\t\tif (strcmp(args[0].from, \"panic\") == 0)\n\t\t\t\tbtrfs_set_opt(info->mount_opt,\n\t\t\t\t\t      PANIC_ON_FATAL_ERROR);\n\t\t\telse if (strcmp(args[0].from, \"bug\") == 0)\n\t\t\t\tbtrfs_clear_opt(info->mount_opt,\n\t\t\t\t\t      PANIC_ON_FATAL_ERROR);\n\t\t\telse {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_commit_interval:\n\t\t\tintarg = 0;\n\t\t\tret = match_int(&args[0], &intarg);\n\t\t\tif (ret < 0) {\n\t\t\t\tbtrfs_err(root->fs_info, \"invalid commit interval\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (intarg > 0) {\n\t\t\t\tif (intarg > 300) {\n\t\t\t\t\tbtrfs_warn(root->fs_info, \"excessive commit interval %d\",\n\t\t\t\t\t\t\tintarg);\n\t\t\t\t}\n\t\t\t\tinfo->commit_interval = intarg;\n\t\t\t} else {\n\t\t\t\tbtrfs_info(root->fs_info, \"using default commit interval %ds\",\n\t\t\t\t    BTRFS_DEFAULT_COMMIT_INTERVAL);\n\t\t\t\tinfo->commit_interval = BTRFS_DEFAULT_COMMIT_INTERVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_err:\n\t\t\tbtrfs_info(root->fs_info, \"unrecognized mount option '%s'\", p);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tif (!ret && btrfs_test_opt(root, SPACE_CACHE))\n\t\tbtrfs_info(root->fs_info, \"disk space caching is enabled\");\n\tkfree(orig);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_free_mnt_opts",
          "args": [
            "&new_sec_opts"
          ],
          "line": 1501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_security_options",
          "args": [
            "fs_info",
            "sb",
            "&new_sec_opts"
          ],
          "line": 1498
        },
        "resolved": true,
        "details": {
          "function_name": "setup_security_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "1255-1284",
          "snippet": "static int setup_security_options(struct btrfs_fs_info *fs_info,\n\t\t\t\t  struct super_block *sb,\n\t\t\t\t  struct security_mnt_opts *sec_opts)\n{\n\tint ret = 0;\n\n\t/*\n\t * Call security_sb_set_mnt_opts() to check whether new sec_opts\n\t * is valid.\n\t */\n\tret = security_sb_set_mnt_opts(sb, sec_opts, 0, NULL);\n\tif (ret)\n\t\treturn ret;\n\n#ifdef CONFIG_SECURITY\n\tif (!fs_info->security_opts.num_mnt_opts) {\n\t\t/* first time security setup, copy sec_opts to fs_info */\n\t\tmemcpy(&fs_info->security_opts, sec_opts, sizeof(*sec_opts));\n\t} else {\n\t\t/*\n\t\t * Since SELinux(the only one supports security_mnt_opts) does\n\t\t * NOT support changing context during remount/mount same sb,\n\t\t * This must be the same or part of the same security options,\n\t\t * just free it.\n\t\t */\n\t\tsecurity_free_mnt_opts(sec_opts);\n\t}\n#endif\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nstatic int setup_security_options(struct btrfs_fs_info *fs_info,\n\t\t\t\t  struct super_block *sb,\n\t\t\t\t  struct security_mnt_opts *sec_opts)\n{\n\tint ret = 0;\n\n\t/*\n\t * Call security_sb_set_mnt_opts() to check whether new sec_opts\n\t * is valid.\n\t */\n\tret = security_sb_set_mnt_opts(sb, sec_opts, 0, NULL);\n\tif (ret)\n\t\treturn ret;\n\n#ifdef CONFIG_SECURITY\n\tif (!fs_info->security_opts.num_mnt_opts) {\n\t\t/* first time security setup, copy sec_opts to fs_info */\n\t\tmemcpy(&fs_info->security_opts, sec_opts, sizeof(*sec_opts));\n\t} else {\n\t\t/*\n\t\t * Since SELinux(the only one supports security_mnt_opts) does\n\t\t * NOT support changing context during remount/mount same sb,\n\t\t * This must be the same or part of the same security options,\n\t\t * just free it.\n\t\t */\n\t\tsecurity_free_mnt_opts(sec_opts);\n\t}\n#endif\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_security_options",
          "args": [
            "data",
            "&new_sec_opts"
          ],
          "line": 1495
        },
        "resolved": true,
        "details": {
          "function_name": "parse_security_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "1236-1253",
          "snippet": "static int parse_security_options(char *orig_opts,\n\t\t\t\t  struct security_mnt_opts *sec_opts)\n{\n\tchar *secdata = NULL;\n\tint ret = 0;\n\n\tsecdata = alloc_secdata();\n\tif (!secdata)\n\t\treturn -ENOMEM;\n\tret = security_sb_copy_data(orig_opts, secdata);\n\tif (ret) {\n\t\tfree_secdata(secdata);\n\t\treturn ret;\n\t}\n\tret = security_sb_parse_opts_str(secdata, sec_opts);\n\tfree_secdata(secdata);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nstatic int parse_security_options(char *orig_opts,\n\t\t\t\t  struct security_mnt_opts *sec_opts)\n{\n\tchar *secdata = NULL;\n\tint ret = 0;\n\n\tsecdata = alloc_secdata();\n\tif (!secdata)\n\t\treturn -ENOMEM;\n\tret = security_sb_copy_data(orig_opts, secdata);\n\tif (ret) {\n\t\tfree_secdata(secdata);\n\t\treturn ret;\n\t}\n\tret = security_sb_parse_opts_str(secdata, sec_opts);\n\tfree_secdata(secdata);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_init_mnt_opts",
          "args": [
            "&new_sec_opts"
          ],
          "line": 1494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_remount_prepare",
          "args": [
            "fs_info"
          ],
          "line": 1489
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_remount_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "1440-1443",
          "snippet": "static inline void btrfs_remount_prepare(struct btrfs_fs_info *fs_info)\n{\n\tset_bit(BTRFS_FS_STATE_REMOUNTING, &fs_info->fs_state);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nstatic inline void btrfs_remount_prepare(struct btrfs_fs_info *fs_info)\n{\n\tset_bit(BTRFS_FS_STATE_REMOUNTING, &fs_info->fs_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_filesystem",
          "args": [
            "sb"
          ],
          "line": 1488
        },
        "resolved": true,
        "details": {
          "function_name": "sync_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sync.c",
          "lines": "47-67",
          "snippet": "int sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/linkage.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nint sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_sb",
          "args": [
            "sb"
          ],
          "line": 1477
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3272-3275",
          "snippet": "static inline struct btrfs_fs_info *btrfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline struct btrfs_fs_info *btrfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nstatic int btrfs_remount(struct super_block *sb, int *flags, char *data);\n\nstatic int btrfs_remount(struct super_block *sb, int *flags, char *data)\n{\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(sb);\n\tstruct btrfs_root *root = fs_info->tree_root;\n\tunsigned old_flags = sb->s_flags;\n\tunsigned long old_opts = fs_info->mount_opt;\n\tunsigned long old_compress_type = fs_info->compress_type;\n\tu64 old_max_inline = fs_info->max_inline;\n\tu64 old_alloc_start = fs_info->alloc_start;\n\tint old_thread_pool_size = fs_info->thread_pool_size;\n\tunsigned int old_metadata_ratio = fs_info->metadata_ratio;\n\tint ret;\n\n\tsync_filesystem(sb);\n\tbtrfs_remount_prepare(fs_info);\n\n\tif (data) {\n\t\tstruct security_mnt_opts new_sec_opts;\n\n\t\tsecurity_init_mnt_opts(&new_sec_opts);\n\t\tret = parse_security_options(data, &new_sec_opts);\n\t\tif (ret)\n\t\t\tgoto restore;\n\t\tret = setup_security_options(fs_info, sb,\n\t\t\t\t\t     &new_sec_opts);\n\t\tif (ret) {\n\t\t\tsecurity_free_mnt_opts(&new_sec_opts);\n\t\t\tgoto restore;\n\t\t}\n\t}\n\n\tret = btrfs_parse_options(root, data);\n\tif (ret) {\n\t\tret = -EINVAL;\n\t\tgoto restore;\n\t}\n\n\tbtrfs_remount_begin(fs_info, old_opts, *flags);\n\tbtrfs_resize_thread_pool(fs_info,\n\t\tfs_info->thread_pool_size, old_thread_pool_size);\n\n\tif ((*flags & MS_RDONLY) == (sb->s_flags & MS_RDONLY))\n\t\tgoto out;\n\n\tif (*flags & MS_RDONLY) {\n\t\t/*\n\t\t * this also happens on 'umount -rf' or on shutdown, when\n\t\t * the filesystem is busy.\n\t\t */\n\t\tcancel_work_sync(&fs_info->async_reclaim_work);\n\n\t\t/* wait for the uuid_scan task to finish */\n\t\tdown(&fs_info->uuid_tree_rescan_sem);\n\t\t/* avoid complains from lockdep et al. */\n\t\tup(&fs_info->uuid_tree_rescan_sem);\n\n\t\tsb->s_flags |= MS_RDONLY;\n\n\t\tbtrfs_dev_replace_suspend_for_unmount(fs_info);\n\t\tbtrfs_scrub_cancel(fs_info);\n\t\tbtrfs_pause_balance(fs_info);\n\n\t\tret = btrfs_commit_super(root);\n\t\tif (ret)\n\t\t\tgoto restore;\n\t} else {\n\t\tif (test_bit(BTRFS_FS_STATE_ERROR, &root->fs_info->fs_state)) {\n\t\t\tbtrfs_err(fs_info,\n\t\t\t\t\"Remounting read-write after error is not allowed\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto restore;\n\t\t}\n\t\tif (fs_info->fs_devices->rw_devices == 0) {\n\t\t\tret = -EACCES;\n\t\t\tgoto restore;\n\t\t}\n\n\t\tif (fs_info->fs_devices->missing_devices >\n\t\t     fs_info->num_tolerated_disk_barrier_failures &&\n\t\t    !(*flags & MS_RDONLY)) {\n\t\t\tbtrfs_warn(fs_info,\n\t\t\t\t\"too many missing devices, writeable remount is not allowed\");\n\t\t\tret = -EACCES;\n\t\t\tgoto restore;\n\t\t}\n\n\t\tif (btrfs_super_log_root(fs_info->super_copy) != 0) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto restore;\n\t\t}\n\n\t\tret = btrfs_cleanup_fs_roots(fs_info);\n\t\tif (ret)\n\t\t\tgoto restore;\n\n\t\t/* recover relocation */\n\t\tmutex_lock(&fs_info->cleaner_mutex);\n\t\tret = btrfs_recover_relocation(root);\n\t\tmutex_unlock(&fs_info->cleaner_mutex);\n\t\tif (ret)\n\t\t\tgoto restore;\n\n\t\tret = btrfs_resume_balance_async(fs_info);\n\t\tif (ret)\n\t\t\tgoto restore;\n\n\t\tret = btrfs_resume_dev_replace_async(fs_info);\n\t\tif (ret) {\n\t\t\tbtrfs_warn(fs_info, \"failed to resume dev_replace\");\n\t\t\tgoto restore;\n\t\t}\n\n\t\tif (!fs_info->uuid_root) {\n\t\t\tbtrfs_info(fs_info, \"creating UUID tree\");\n\t\t\tret = btrfs_create_uuid_tree(fs_info);\n\t\t\tif (ret) {\n\t\t\t\tbtrfs_warn(fs_info, \"failed to create the UUID tree %d\", ret);\n\t\t\t\tgoto restore;\n\t\t\t}\n\t\t}\n\t\tsb->s_flags &= ~MS_RDONLY;\n\t}\nout:\n\twake_up_process(fs_info->transaction_kthread);\n\tbtrfs_remount_cleanup(fs_info, old_opts);\n\treturn 0;\n\nrestore:\n\t/* We've hit an error - don't reset MS_RDONLY */\n\tif (sb->s_flags & MS_RDONLY)\n\t\told_flags |= MS_RDONLY;\n\tsb->s_flags = old_flags;\n\tfs_info->mount_opt = old_opts;\n\tfs_info->compress_type = old_compress_type;\n\tfs_info->max_inline = old_max_inline;\n\tmutex_lock(&fs_info->chunk_mutex);\n\tfs_info->alloc_start = old_alloc_start;\n\tmutex_unlock(&fs_info->chunk_mutex);\n\tbtrfs_resize_thread_pool(fs_info,\n\t\told_thread_pool_size, fs_info->thread_pool_size);\n\tfs_info->metadata_ratio = old_metadata_ratio;\n\tbtrfs_remount_cleanup(fs_info, old_opts);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_remount_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
    "lines": "1459-1473",
    "snippet": "static inline void btrfs_remount_cleanup(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t unsigned long old_opts)\n{\n\t/*\n\t * We need cleanup all defragable inodes if the autodefragment is\n\t * close or the fs is R/O.\n\t */\n\tif (btrfs_raw_test_opt(old_opts, AUTO_DEFRAG) &&\n\t    (!btrfs_raw_test_opt(fs_info->mount_opt, AUTO_DEFRAG) ||\n\t     (fs_info->sb->s_flags & MS_RDONLY))) {\n\t\tbtrfs_cleanup_defrag_inodes(fs_info);\n\t}\n\n\tclear_bit(BTRFS_FS_STATE_REMOUNTING, &fs_info->fs_state);\n}",
    "includes": [
      "#include <trace/events/btrfs.h>",
      "#include \"qgroup.h\"",
      "#include \"tests/btrfs-tests.h\"",
      "#include \"backref.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"compression.h\"",
      "#include \"export.h\"",
      "#include \"volumes.h\"",
      "#include \"xattr.h\"",
      "#include \"props.h\"",
      "#include \"hash.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/namei.h>",
      "#include <linux/ctype.h>",
      "#include <linux/parser.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "BTRFS_FS_STATE_REMOUNTING",
            "&fs_info->fs_state"
          ],
          "line": 1472
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_cleanup_defrag_inodes",
          "args": [
            "fs_info"
          ],
          "line": 1469
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_cleanup_defrag_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/file.c",
          "lines": "264-285",
          "snippet": "void btrfs_cleanup_defrag_inodes(struct btrfs_fs_info *fs_info)\n{\n\tstruct inode_defrag *defrag;\n\tstruct rb_node *node;\n\n\tspin_lock(&fs_info->defrag_inodes_lock);\n\tnode = rb_first(&fs_info->defrag_inodes);\n\twhile (node) {\n\t\trb_erase(node, &fs_info->defrag_inodes);\n\t\tdefrag = rb_entry(node, struct inode_defrag, rb_node);\n\t\tkmem_cache_free(btrfs_inode_defrag_cachep, defrag);\n\n\t\tif (need_resched()) {\n\t\t\tspin_unlock(&fs_info->defrag_inodes_lock);\n\t\t\tcond_resched();\n\t\t\tspin_lock(&fs_info->defrag_inodes_lock);\n\t\t}\n\n\t\tnode = rb_first(&fs_info->defrag_inodes);\n\t}\n\tspin_unlock(&fs_info->defrag_inodes_lock);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"volumes.h\"",
            "#include \"locking.h\"",
            "#include \"tree-log.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *btrfs_inode_defrag_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"volumes.h\"\n#include \"locking.h\"\n#include \"tree-log.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/btrfs.h>\n#include <linux/slab.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n\nstatic struct kmem_cache *btrfs_inode_defrag_cachep;\n\nvoid btrfs_cleanup_defrag_inodes(struct btrfs_fs_info *fs_info)\n{\n\tstruct inode_defrag *defrag;\n\tstruct rb_node *node;\n\n\tspin_lock(&fs_info->defrag_inodes_lock);\n\tnode = rb_first(&fs_info->defrag_inodes);\n\twhile (node) {\n\t\trb_erase(node, &fs_info->defrag_inodes);\n\t\tdefrag = rb_entry(node, struct inode_defrag, rb_node);\n\t\tkmem_cache_free(btrfs_inode_defrag_cachep, defrag);\n\n\t\tif (need_resched()) {\n\t\t\tspin_unlock(&fs_info->defrag_inodes_lock);\n\t\t\tcond_resched();\n\t\t\tspin_lock(&fs_info->defrag_inodes_lock);\n\t\t}\n\n\t\tnode = rb_first(&fs_info->defrag_inodes);\n\t}\n\tspin_unlock(&fs_info->defrag_inodes_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_raw_test_opt",
          "args": [
            "fs_info->mount_opt",
            "AUTO_DEFRAG"
          ],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_raw_test_opt",
          "args": [
            "old_opts",
            "AUTO_DEFRAG"
          ],
          "line": 1466
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nstatic inline void btrfs_remount_cleanup(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t unsigned long old_opts)\n{\n\t/*\n\t * We need cleanup all defragable inodes if the autodefragment is\n\t * close or the fs is R/O.\n\t */\n\tif (btrfs_raw_test_opt(old_opts, AUTO_DEFRAG) &&\n\t    (!btrfs_raw_test_opt(fs_info->mount_opt, AUTO_DEFRAG) ||\n\t     (fs_info->sb->s_flags & MS_RDONLY))) {\n\t\tbtrfs_cleanup_defrag_inodes(fs_info);\n\t}\n\n\tclear_bit(BTRFS_FS_STATE_REMOUNTING, &fs_info->fs_state);\n}"
  },
  {
    "function_name": "btrfs_remount_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
    "lines": "1445-1457",
    "snippet": "static inline void btrfs_remount_begin(struct btrfs_fs_info *fs_info,\n\t\t\t\t       unsigned long old_opts, int flags)\n{\n\tif (btrfs_raw_test_opt(old_opts, AUTO_DEFRAG) &&\n\t    (!btrfs_raw_test_opt(fs_info->mount_opt, AUTO_DEFRAG) ||\n\t     (flags & MS_RDONLY))) {\n\t\t/* wait for any defraggers to finish */\n\t\twait_event(fs_info->transaction_wait,\n\t\t\t   (atomic_read(&fs_info->defrag_running) == 0));\n\t\tif (flags & MS_RDONLY)\n\t\t\tsync_filesystem(fs_info->sb);\n\t}\n}",
    "includes": [
      "#include <trace/events/btrfs.h>",
      "#include \"qgroup.h\"",
      "#include \"tests/btrfs-tests.h\"",
      "#include \"backref.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"compression.h\"",
      "#include \"export.h\"",
      "#include \"volumes.h\"",
      "#include \"xattr.h\"",
      "#include \"props.h\"",
      "#include \"hash.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/namei.h>",
      "#include <linux/ctype.h>",
      "#include <linux/parser.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sync_filesystem",
          "args": [
            "fs_info->sb"
          ],
          "line": 1455
        },
        "resolved": true,
        "details": {
          "function_name": "sync_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/sync.c",
          "lines": "47-67",
          "snippet": "int sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/linkage.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/namei.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/backing-dev.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/linkage.h>\n#include <linux/syscalls.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/namei.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n\nint sync_filesystem(struct super_block *sb)\n{\n\tint ret;\n\n\t/*\n\t * We need to be protected against the filesystem going from\n\t * r/o to r/w or vice versa.\n\t */\n\tWARN_ON(!rwsem_is_locked(&sb->s_umount));\n\n\t/*\n\t * No point in syncing out anything if the filesystem is read-only.\n\t */\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tret = __sync_filesystem(sb, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn __sync_filesystem(sb, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "fs_info->transaction_wait",
            "(atomic_read(&fs_info->defrag_running) == 0)"
          ],
          "line": 1452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&fs_info->defrag_running"
          ],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_raw_test_opt",
          "args": [
            "fs_info->mount_opt",
            "AUTO_DEFRAG"
          ],
          "line": 1449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_raw_test_opt",
          "args": [
            "old_opts",
            "AUTO_DEFRAG"
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nstatic inline void btrfs_remount_begin(struct btrfs_fs_info *fs_info,\n\t\t\t\t       unsigned long old_opts, int flags)\n{\n\tif (btrfs_raw_test_opt(old_opts, AUTO_DEFRAG) &&\n\t    (!btrfs_raw_test_opt(fs_info->mount_opt, AUTO_DEFRAG) ||\n\t     (flags & MS_RDONLY))) {\n\t\t/* wait for any defraggers to finish */\n\t\twait_event(fs_info->transaction_wait,\n\t\t\t   (atomic_read(&fs_info->defrag_running) == 0));\n\t\tif (flags & MS_RDONLY)\n\t\t\tsync_filesystem(fs_info->sb);\n\t}\n}"
  },
  {
    "function_name": "btrfs_remount_prepare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
    "lines": "1440-1443",
    "snippet": "static inline void btrfs_remount_prepare(struct btrfs_fs_info *fs_info)\n{\n\tset_bit(BTRFS_FS_STATE_REMOUNTING, &fs_info->fs_state);\n}",
    "includes": [
      "#include <trace/events/btrfs.h>",
      "#include \"qgroup.h\"",
      "#include \"tests/btrfs-tests.h\"",
      "#include \"backref.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"compression.h\"",
      "#include \"export.h\"",
      "#include \"volumes.h\"",
      "#include \"xattr.h\"",
      "#include \"props.h\"",
      "#include \"hash.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/namei.h>",
      "#include <linux/ctype.h>",
      "#include <linux/parser.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "BTRFS_FS_STATE_REMOUNTING",
            "&fs_info->fs_state"
          ],
          "line": 1442
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nstatic inline void btrfs_remount_prepare(struct btrfs_fs_info *fs_info)\n{\n\tset_bit(BTRFS_FS_STATE_REMOUNTING, &fs_info->fs_state);\n}"
  },
  {
    "function_name": "btrfs_resize_thread_pool",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
    "lines": "1413-1438",
    "snippet": "static void btrfs_resize_thread_pool(struct btrfs_fs_info *fs_info,\n\t\t\t\t     int new_pool_size, int old_pool_size)\n{\n\tif (new_pool_size == old_pool_size)\n\t\treturn;\n\n\tfs_info->thread_pool_size = new_pool_size;\n\n\tbtrfs_info(fs_info, \"resize thread pool %d -> %d\",\n\t       old_pool_size, new_pool_size);\n\n\tbtrfs_workqueue_set_max(fs_info->workers, new_pool_size);\n\tbtrfs_workqueue_set_max(fs_info->delalloc_workers, new_pool_size);\n\tbtrfs_workqueue_set_max(fs_info->submit_workers, new_pool_size);\n\tbtrfs_workqueue_set_max(fs_info->caching_workers, new_pool_size);\n\tbtrfs_workqueue_set_max(fs_info->endio_workers, new_pool_size);\n\tbtrfs_workqueue_set_max(fs_info->endio_meta_workers, new_pool_size);\n\tbtrfs_workqueue_set_max(fs_info->endio_meta_write_workers,\n\t\t\t\tnew_pool_size);\n\tbtrfs_workqueue_set_max(fs_info->endio_write_workers, new_pool_size);\n\tbtrfs_workqueue_set_max(fs_info->endio_freespace_worker, new_pool_size);\n\tbtrfs_workqueue_set_max(fs_info->delayed_workers, new_pool_size);\n\tbtrfs_workqueue_set_max(fs_info->readahead_workers, new_pool_size);\n\tbtrfs_workqueue_set_max(fs_info->scrub_wr_completion_workers,\n\t\t\t\tnew_pool_size);\n}",
    "includes": [
      "#include <trace/events/btrfs.h>",
      "#include \"qgroup.h\"",
      "#include \"tests/btrfs-tests.h\"",
      "#include \"backref.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"compression.h\"",
      "#include \"export.h\"",
      "#include \"volumes.h\"",
      "#include \"xattr.h\"",
      "#include \"props.h\"",
      "#include \"hash.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/namei.h>",
      "#include <linux/ctype.h>",
      "#include <linux/parser.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_workqueue_set_max",
          "args": [
            "fs_info->scrub_wr_completion_workers",
            "new_pool_size"
          ],
          "line": 1436
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_workqueue_set_max",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/async-thread.c",
          "lines": "353-360",
          "snippet": "void btrfs_workqueue_set_max(struct btrfs_workqueue *wq, int max)\n{\n\tif (!wq)\n\t\treturn;\n\twq->normal->max_active = max;\n\tif (wq->high)\n\t\twq->high->max_active = max;\n}",
          "includes": [
            "#include \"ctree.h\"",
            "#include \"async-thread.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>",
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ctree.h\"\n#include \"async-thread.h\"\n#include <linux/freezer.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n\nstatic inline void\n__btrfs_destroy_workqueue(struct __btrfs_workqueue *wq);\n\nvoid btrfs_workqueue_set_max(struct btrfs_workqueue *wq, int max)\n{\n\tif (!wq)\n\t\treturn;\n\twq->normal->max_active = max;\n\tif (wq->high)\n\t\twq->high->max_active = max;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_info",
          "args": [
            "fs_info",
            "\"resize thread pool %d -> %d\"",
            "old_pool_size",
            "new_pool_size"
          ],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nstatic void btrfs_resize_thread_pool(struct btrfs_fs_info *fs_info,\n\t\t\t\t     int new_pool_size, int old_pool_size)\n{\n\tif (new_pool_size == old_pool_size)\n\t\treturn;\n\n\tfs_info->thread_pool_size = new_pool_size;\n\n\tbtrfs_info(fs_info, \"resize thread pool %d -> %d\",\n\t       old_pool_size, new_pool_size);\n\n\tbtrfs_workqueue_set_max(fs_info->workers, new_pool_size);\n\tbtrfs_workqueue_set_max(fs_info->delalloc_workers, new_pool_size);\n\tbtrfs_workqueue_set_max(fs_info->submit_workers, new_pool_size);\n\tbtrfs_workqueue_set_max(fs_info->caching_workers, new_pool_size);\n\tbtrfs_workqueue_set_max(fs_info->endio_workers, new_pool_size);\n\tbtrfs_workqueue_set_max(fs_info->endio_meta_workers, new_pool_size);\n\tbtrfs_workqueue_set_max(fs_info->endio_meta_write_workers,\n\t\t\t\tnew_pool_size);\n\tbtrfs_workqueue_set_max(fs_info->endio_write_workers, new_pool_size);\n\tbtrfs_workqueue_set_max(fs_info->endio_freespace_worker, new_pool_size);\n\tbtrfs_workqueue_set_max(fs_info->delayed_workers, new_pool_size);\n\tbtrfs_workqueue_set_max(fs_info->readahead_workers, new_pool_size);\n\tbtrfs_workqueue_set_max(fs_info->scrub_wr_completion_workers,\n\t\t\t\tnew_pool_size);\n}"
  },
  {
    "function_name": "btrfs_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
    "lines": "1292-1411",
    "snippet": "static struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,\n\t\tconst char *device_name, void *data)\n{\n\tstruct block_device *bdev = NULL;\n\tstruct super_block *s;\n\tstruct dentry *root;\n\tstruct btrfs_fs_devices *fs_devices = NULL;\n\tstruct btrfs_fs_info *fs_info = NULL;\n\tstruct security_mnt_opts new_sec_opts;\n\tfmode_t mode = FMODE_READ;\n\tchar *subvol_name = NULL;\n\tu64 subvol_objectid = 0;\n\tint error = 0;\n\n\tif (!(flags & MS_RDONLY))\n\t\tmode |= FMODE_WRITE;\n\n\terror = btrfs_parse_early_options(data, mode, fs_type,\n\t\t\t\t\t  &subvol_name, &subvol_objectid,\n\t\t\t\t\t  &fs_devices);\n\tif (error) {\n\t\tkfree(subvol_name);\n\t\treturn ERR_PTR(error);\n\t}\n\n\tif (subvol_name) {\n\t\troot = mount_subvol(subvol_name, flags, device_name, data);\n\t\tkfree(subvol_name);\n\t\treturn root;\n\t}\n\n\tsecurity_init_mnt_opts(&new_sec_opts);\n\tif (data) {\n\t\terror = parse_security_options(data, &new_sec_opts);\n\t\tif (error)\n\t\t\treturn ERR_PTR(error);\n\t}\n\n\terror = btrfs_scan_one_device(device_name, mode, fs_type, &fs_devices);\n\tif (error)\n\t\tgoto error_sec_opts;\n\n\t/*\n\t * Setup a dummy root and fs_info for test/set super.  This is because\n\t * we don't actually fill this stuff out until open_ctree, but we need\n\t * it for searching for existing supers, so this lets us do that and\n\t * then open_ctree will properly initialize everything later.\n\t */\n\tfs_info = kzalloc(sizeof(struct btrfs_fs_info), GFP_NOFS);\n\tif (!fs_info) {\n\t\terror = -ENOMEM;\n\t\tgoto error_sec_opts;\n\t}\n\n\tfs_info->fs_devices = fs_devices;\n\n\tfs_info->super_copy = kzalloc(BTRFS_SUPER_INFO_SIZE, GFP_NOFS);\n\tfs_info->super_for_commit = kzalloc(BTRFS_SUPER_INFO_SIZE, GFP_NOFS);\n\tsecurity_init_mnt_opts(&fs_info->security_opts);\n\tif (!fs_info->super_copy || !fs_info->super_for_commit) {\n\t\terror = -ENOMEM;\n\t\tgoto error_fs_info;\n\t}\n\n\terror = btrfs_open_devices(fs_devices, mode, fs_type);\n\tif (error)\n\t\tgoto error_fs_info;\n\n\tif (!(flags & MS_RDONLY) && fs_devices->rw_devices == 0) {\n\t\terror = -EACCES;\n\t\tgoto error_close_devices;\n\t}\n\n\tbdev = fs_devices->latest_bdev;\n\ts = sget(fs_type, btrfs_test_super, btrfs_set_super, flags | MS_NOSEC,\n\t\t fs_info);\n\tif (IS_ERR(s)) {\n\t\terror = PTR_ERR(s);\n\t\tgoto error_close_devices;\n\t}\n\n\tif (s->s_root) {\n\t\tbtrfs_close_devices(fs_devices);\n\t\tfree_fs_info(fs_info);\n\t\tif ((flags ^ s->s_flags) & MS_RDONLY)\n\t\t\terror = -EBUSY;\n\t} else {\n\t\tchar b[BDEVNAME_SIZE];\n\n\t\tstrlcpy(s->s_id, bdevname(bdev, b), sizeof(s->s_id));\n\t\tbtrfs_sb(s)->bdev_holder = fs_type;\n\t\terror = btrfs_fill_super(s, fs_devices, data,\n\t\t\t\t\t flags & MS_SILENT ? 1 : 0);\n\t}\n\n\troot = !error ? get_default_root(s, subvol_objectid) : ERR_PTR(error);\n\tif (IS_ERR(root)) {\n\t\tdeactivate_locked_super(s);\n\t\terror = PTR_ERR(root);\n\t\tgoto error_sec_opts;\n\t}\n\n\tfs_info = btrfs_sb(s);\n\terror = setup_security_options(fs_info, s, &new_sec_opts);\n\tif (error) {\n\t\tdput(root);\n\t\tdeactivate_locked_super(s);\n\t\tgoto error_sec_opts;\n\t}\n\n\treturn root;\n\nerror_close_devices:\n\tbtrfs_close_devices(fs_devices);\nerror_fs_info:\n\tfree_fs_info(fs_info);\nerror_sec_opts:\n\tsecurity_free_mnt_opts(&new_sec_opts);\n\treturn ERR_PTR(error);\n}",
    "includes": [
      "#include <trace/events/btrfs.h>",
      "#include \"qgroup.h\"",
      "#include \"tests/btrfs-tests.h\"",
      "#include \"backref.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"compression.h\"",
      "#include \"export.h\"",
      "#include \"volumes.h\"",
      "#include \"xattr.h\"",
      "#include \"props.h\"",
      "#include \"hash.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/namei.h>",
      "#include <linux/ctype.h>",
      "#include <linux/parser.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btrfs_remount(struct super_block *sb, int *flags, char *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_free_mnt_opts",
          "args": [
            "&new_sec_opts"
          ],
          "line": 1409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_fs_info",
          "args": [
            "fs_info"
          ],
          "line": 1407
        },
        "resolved": true,
        "details": {
          "function_name": "free_fs_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3632-3647",
          "snippet": "static inline void free_fs_info(struct btrfs_fs_info *fs_info)\n{\n\tkfree(fs_info->balance_ctl);\n\tkfree(fs_info->delayed_root);\n\tkfree(fs_info->extent_root);\n\tkfree(fs_info->tree_root);\n\tkfree(fs_info->chunk_root);\n\tkfree(fs_info->dev_root);\n\tkfree(fs_info->csum_root);\n\tkfree(fs_info->quota_root);\n\tkfree(fs_info->uuid_root);\n\tkfree(fs_info->super_copy);\n\tkfree(fs_info->super_for_commit);\n\tsecurity_free_mnt_opts(&fs_info->security_opts);\n\tkfree(fs_info);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void free_fs_info(struct btrfs_fs_info *fs_info)\n{\n\tkfree(fs_info->balance_ctl);\n\tkfree(fs_info->delayed_root);\n\tkfree(fs_info->extent_root);\n\tkfree(fs_info->tree_root);\n\tkfree(fs_info->chunk_root);\n\tkfree(fs_info->dev_root);\n\tkfree(fs_info->csum_root);\n\tkfree(fs_info->quota_root);\n\tkfree(fs_info->uuid_root);\n\tkfree(fs_info->super_copy);\n\tkfree(fs_info->super_for_commit);\n\tsecurity_free_mnt_opts(&fs_info->security_opts);\n\tkfree(fs_info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_close_devices",
          "args": [
            "fs_devices"
          ],
          "line": 1405
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_close_devices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "746-772",
          "snippet": "int btrfs_close_devices(struct btrfs_fs_devices *fs_devices)\n{\n\tstruct btrfs_fs_devices *seed_devices = NULL;\n\tint ret;\n\n\tmutex_lock(&uuid_mutex);\n\tret = __btrfs_close_devices(fs_devices);\n\tif (!fs_devices->opened) {\n\t\tseed_devices = fs_devices->seed;\n\t\tfs_devices->seed = NULL;\n\t}\n\tmutex_unlock(&uuid_mutex);\n\n\twhile (seed_devices) {\n\t\tfs_devices = seed_devices;\n\t\tseed_devices = fs_devices->seed;\n\t\t__btrfs_close_devices(fs_devices);\n\t\tfree_fs_devices(fs_devices);\n\t}\n\t/*\n\t * Wait for rcu kworkers under __btrfs_close_devices\n\t * to finish all blkdev_puts so device is really\n\t * free when umount is done.\n\t */\n\trcu_barrier();\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_close_devices(struct btrfs_fs_devices *fs_devices)\n{\n\tstruct btrfs_fs_devices *seed_devices = NULL;\n\tint ret;\n\n\tmutex_lock(&uuid_mutex);\n\tret = __btrfs_close_devices(fs_devices);\n\tif (!fs_devices->opened) {\n\t\tseed_devices = fs_devices->seed;\n\t\tfs_devices->seed = NULL;\n\t}\n\tmutex_unlock(&uuid_mutex);\n\n\twhile (seed_devices) {\n\t\tfs_devices = seed_devices;\n\t\tseed_devices = fs_devices->seed;\n\t\t__btrfs_close_devices(fs_devices);\n\t\tfree_fs_devices(fs_devices);\n\t}\n\t/*\n\t * Wait for rcu kworkers under __btrfs_close_devices\n\t * to finish all blkdev_puts so device is really\n\t * free when umount is done.\n\t */\n\trcu_barrier();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "deactivate_locked_super",
          "args": [
            "s"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "root"
          ],
          "line": 1397
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setup_security_options",
          "args": [
            "fs_info",
            "s",
            "&new_sec_opts"
          ],
          "line": 1395
        },
        "resolved": true,
        "details": {
          "function_name": "setup_security_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "1255-1284",
          "snippet": "static int setup_security_options(struct btrfs_fs_info *fs_info,\n\t\t\t\t  struct super_block *sb,\n\t\t\t\t  struct security_mnt_opts *sec_opts)\n{\n\tint ret = 0;\n\n\t/*\n\t * Call security_sb_set_mnt_opts() to check whether new sec_opts\n\t * is valid.\n\t */\n\tret = security_sb_set_mnt_opts(sb, sec_opts, 0, NULL);\n\tif (ret)\n\t\treturn ret;\n\n#ifdef CONFIG_SECURITY\n\tif (!fs_info->security_opts.num_mnt_opts) {\n\t\t/* first time security setup, copy sec_opts to fs_info */\n\t\tmemcpy(&fs_info->security_opts, sec_opts, sizeof(*sec_opts));\n\t} else {\n\t\t/*\n\t\t * Since SELinux(the only one supports security_mnt_opts) does\n\t\t * NOT support changing context during remount/mount same sb,\n\t\t * This must be the same or part of the same security options,\n\t\t * just free it.\n\t\t */\n\t\tsecurity_free_mnt_opts(sec_opts);\n\t}\n#endif\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nstatic int setup_security_options(struct btrfs_fs_info *fs_info,\n\t\t\t\t  struct super_block *sb,\n\t\t\t\t  struct security_mnt_opts *sec_opts)\n{\n\tint ret = 0;\n\n\t/*\n\t * Call security_sb_set_mnt_opts() to check whether new sec_opts\n\t * is valid.\n\t */\n\tret = security_sb_set_mnt_opts(sb, sec_opts, 0, NULL);\n\tif (ret)\n\t\treturn ret;\n\n#ifdef CONFIG_SECURITY\n\tif (!fs_info->security_opts.num_mnt_opts) {\n\t\t/* first time security setup, copy sec_opts to fs_info */\n\t\tmemcpy(&fs_info->security_opts, sec_opts, sizeof(*sec_opts));\n\t} else {\n\t\t/*\n\t\t * Since SELinux(the only one supports security_mnt_opts) does\n\t\t * NOT support changing context during remount/mount same sb,\n\t\t * This must be the same or part of the same security options,\n\t\t * just free it.\n\t\t */\n\t\tsecurity_free_mnt_opts(sec_opts);\n\t}\n#endif\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_sb",
          "args": [
            "s"
          ],
          "line": 1394
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3272-3275",
          "snippet": "static inline struct btrfs_fs_info *btrfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline struct btrfs_fs_info *btrfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "root"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deactivate_locked_super",
          "args": [
            "s"
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "root"
          ],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 1387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_default_root",
          "args": [
            "s",
            "subvol_objectid"
          ],
          "line": 1387
        },
        "resolved": true,
        "details": {
          "function_name": "get_default_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "844-925",
          "snippet": "static struct dentry *get_default_root(struct super_block *sb,\n\t\t\t\t       u64 subvol_objectid)\n{\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(sb);\n\tstruct btrfs_root *root = fs_info->tree_root;\n\tstruct btrfs_root *new_root;\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key location;\n\tstruct inode *inode;\n\tu64 dir_id;\n\tint new = 0;\n\n\t/*\n\t * We have a specific subvol we want to mount, just setup location and\n\t * go look up the root.\n\t */\n\tif (subvol_objectid) {\n\t\tlocation.objectid = subvol_objectid;\n\t\tlocation.type = BTRFS_ROOT_ITEM_KEY;\n\t\tlocation.offset = (u64)-1;\n\t\tgoto find_root;\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn ERR_PTR(-ENOMEM);\n\tpath->leave_spinning = 1;\n\n\t/*\n\t * Find the \"default\" dir item which points to the root item that we\n\t * will mount by default if we haven't been given a specific subvolume\n\t * to mount.\n\t */\n\tdir_id = btrfs_super_root_dir(fs_info->super_copy);\n\tdi = btrfs_lookup_dir_item(NULL, root, path, dir_id, \"default\", 7, 0);\n\tif (IS_ERR(di)) {\n\t\tbtrfs_free_path(path);\n\t\treturn ERR_CAST(di);\n\t}\n\tif (!di) {\n\t\t/*\n\t\t * Ok the default dir item isn't there.  This is weird since\n\t\t * it's always been there, but don't freak out, just try and\n\t\t * mount to root most subvolume.\n\t\t */\n\t\tbtrfs_free_path(path);\n\t\tdir_id = BTRFS_FIRST_FREE_OBJECTID;\n\t\tnew_root = fs_info->fs_root;\n\t\tgoto setup_root;\n\t}\n\n\tbtrfs_dir_item_key_to_cpu(path->nodes[0], di, &location);\n\tbtrfs_free_path(path);\n\nfind_root:\n\tnew_root = btrfs_read_fs_root_no_name(fs_info, &location);\n\tif (IS_ERR(new_root))\n\t\treturn ERR_CAST(new_root);\n\n\tdir_id = btrfs_root_dirid(&new_root->root_item);\nsetup_root:\n\tlocation.objectid = dir_id;\n\tlocation.type = BTRFS_INODE_ITEM_KEY;\n\tlocation.offset = 0;\n\n\tinode = btrfs_iget(sb, &location, new_root, &new);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\t/*\n\t * If we're just mounting the root most subvol put the inode and return\n\t * a reference to the dentry.  We will have already gotten a reference\n\t * to the inode in btrfs_fill_super so we're good to go.\n\t */\n\tif (!new && sb->s_root->d_inode == inode) {\n\t\tiput(inode);\n\t\treturn dget(sb->s_root);\n\t}\n\n\treturn d_obtain_root(inode);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nstatic struct dentry *get_default_root(struct super_block *sb,\n\t\t\t\t       u64 subvol_objectid)\n{\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(sb);\n\tstruct btrfs_root *root = fs_info->tree_root;\n\tstruct btrfs_root *new_root;\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key location;\n\tstruct inode *inode;\n\tu64 dir_id;\n\tint new = 0;\n\n\t/*\n\t * We have a specific subvol we want to mount, just setup location and\n\t * go look up the root.\n\t */\n\tif (subvol_objectid) {\n\t\tlocation.objectid = subvol_objectid;\n\t\tlocation.type = BTRFS_ROOT_ITEM_KEY;\n\t\tlocation.offset = (u64)-1;\n\t\tgoto find_root;\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn ERR_PTR(-ENOMEM);\n\tpath->leave_spinning = 1;\n\n\t/*\n\t * Find the \"default\" dir item which points to the root item that we\n\t * will mount by default if we haven't been given a specific subvolume\n\t * to mount.\n\t */\n\tdir_id = btrfs_super_root_dir(fs_info->super_copy);\n\tdi = btrfs_lookup_dir_item(NULL, root, path, dir_id, \"default\", 7, 0);\n\tif (IS_ERR(di)) {\n\t\tbtrfs_free_path(path);\n\t\treturn ERR_CAST(di);\n\t}\n\tif (!di) {\n\t\t/*\n\t\t * Ok the default dir item isn't there.  This is weird since\n\t\t * it's always been there, but don't freak out, just try and\n\t\t * mount to root most subvolume.\n\t\t */\n\t\tbtrfs_free_path(path);\n\t\tdir_id = BTRFS_FIRST_FREE_OBJECTID;\n\t\tnew_root = fs_info->fs_root;\n\t\tgoto setup_root;\n\t}\n\n\tbtrfs_dir_item_key_to_cpu(path->nodes[0], di, &location);\n\tbtrfs_free_path(path);\n\nfind_root:\n\tnew_root = btrfs_read_fs_root_no_name(fs_info, &location);\n\tif (IS_ERR(new_root))\n\t\treturn ERR_CAST(new_root);\n\n\tdir_id = btrfs_root_dirid(&new_root->root_item);\nsetup_root:\n\tlocation.objectid = dir_id;\n\tlocation.type = BTRFS_INODE_ITEM_KEY;\n\tlocation.offset = 0;\n\n\tinode = btrfs_iget(sb, &location, new_root, &new);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\t/*\n\t * If we're just mounting the root most subvol put the inode and return\n\t * a reference to the dentry.  We will have already gotten a reference\n\t * to the inode in btrfs_fill_super so we're good to go.\n\t */\n\tif (!new && sb->s_root->d_inode == inode) {\n\t\tiput(inode);\n\t\treturn dget(sb->s_root);\n\t}\n\n\treturn d_obtain_root(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_fill_super",
          "args": [
            "s",
            "fs_devices",
            "data",
            "flags & MS_SILENT ? 1 : 0"
          ],
          "line": 1383
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_fill_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "927-976",
          "snippet": "static int btrfs_fill_super(struct super_block *sb,\n\t\t\t    struct btrfs_fs_devices *fs_devices,\n\t\t\t    void *data, int silent)\n{\n\tstruct inode *inode;\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(sb);\n\tstruct btrfs_key key;\n\tint err;\n\n\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n\tsb->s_magic = BTRFS_SUPER_MAGIC;\n\tsb->s_op = &btrfs_super_ops;\n\tsb->s_d_op = &btrfs_dentry_operations;\n\tsb->s_export_op = &btrfs_export_ops;\n\tsb->s_xattr = btrfs_xattr_handlers;\n\tsb->s_time_gran = 1;\n#ifdef CONFIG_BTRFS_FS_POSIX_ACL\n\tsb->s_flags |= MS_POSIXACL;\n#endif\n\tsb->s_flags |= MS_I_VERSION;\n\terr = open_ctree(sb, fs_devices, (char *)data);\n\tif (err) {\n\t\tprintk(KERN_ERR \"BTRFS: open_ctree failed\\n\");\n\t\treturn err;\n\t}\n\n\tkey.objectid = BTRFS_FIRST_FREE_OBJECTID;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\tinode = btrfs_iget(sb, &key, fs_info->fs_root, NULL);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tgoto fail_close;\n\t}\n\n\tsb->s_root = d_make_root(inode);\n\tif (!sb->s_root) {\n\t\terr = -ENOMEM;\n\t\tgoto fail_close;\n\t}\n\n\tsave_mount_options(sb, data);\n\tcleancache_init_fs(sb);\n\tsb->s_flags |= MS_ACTIVE;\n\treturn 0;\n\nfail_close:\n\tclose_ctree(fs_info->tree_root);\n\treturn err;\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct super_operations btrfs_super_ops;",
            "static int btrfs_remount(struct super_block *sb, int *flags, char *data);",
            "static const struct super_operations btrfs_super_ops = {\n\t.drop_inode\t= btrfs_drop_inode,\n\t.evict_inode\t= btrfs_evict_inode,\n\t.put_super\t= btrfs_put_super,\n\t.sync_fs\t= btrfs_sync_fs,\n\t.show_options\t= btrfs_show_options,\n\t.show_devname\t= btrfs_show_devname,\n\t.write_inode\t= btrfs_write_inode,\n\t.alloc_inode\t= btrfs_alloc_inode,\n\t.destroy_inode\t= btrfs_destroy_inode,\n\t.statfs\t\t= btrfs_statfs,\n\t.remount_fs\t= btrfs_remount,\n\t.freeze_fs\t= btrfs_freeze,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nstatic const struct super_operations btrfs_super_ops;\nstatic int btrfs_remount(struct super_block *sb, int *flags, char *data);\nstatic const struct super_operations btrfs_super_ops = {\n\t.drop_inode\t= btrfs_drop_inode,\n\t.evict_inode\t= btrfs_evict_inode,\n\t.put_super\t= btrfs_put_super,\n\t.sync_fs\t= btrfs_sync_fs,\n\t.show_options\t= btrfs_show_options,\n\t.show_devname\t= btrfs_show_devname,\n\t.write_inode\t= btrfs_write_inode,\n\t.alloc_inode\t= btrfs_alloc_inode,\n\t.destroy_inode\t= btrfs_destroy_inode,\n\t.statfs\t\t= btrfs_statfs,\n\t.remount_fs\t= btrfs_remount,\n\t.freeze_fs\t= btrfs_freeze,\n};\n\nstatic int btrfs_fill_super(struct super_block *sb,\n\t\t\t    struct btrfs_fs_devices *fs_devices,\n\t\t\t    void *data, int silent)\n{\n\tstruct inode *inode;\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(sb);\n\tstruct btrfs_key key;\n\tint err;\n\n\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n\tsb->s_magic = BTRFS_SUPER_MAGIC;\n\tsb->s_op = &btrfs_super_ops;\n\tsb->s_d_op = &btrfs_dentry_operations;\n\tsb->s_export_op = &btrfs_export_ops;\n\tsb->s_xattr = btrfs_xattr_handlers;\n\tsb->s_time_gran = 1;\n#ifdef CONFIG_BTRFS_FS_POSIX_ACL\n\tsb->s_flags |= MS_POSIXACL;\n#endif\n\tsb->s_flags |= MS_I_VERSION;\n\terr = open_ctree(sb, fs_devices, (char *)data);\n\tif (err) {\n\t\tprintk(KERN_ERR \"BTRFS: open_ctree failed\\n\");\n\t\treturn err;\n\t}\n\n\tkey.objectid = BTRFS_FIRST_FREE_OBJECTID;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\tinode = btrfs_iget(sb, &key, fs_info->fs_root, NULL);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tgoto fail_close;\n\t}\n\n\tsb->s_root = d_make_root(inode);\n\tif (!sb->s_root) {\n\t\terr = -ENOMEM;\n\t\tgoto fail_close;\n\t}\n\n\tsave_mount_options(sb, data);\n\tcleancache_init_fs(sb);\n\tsb->s_flags |= MS_ACTIVE;\n\treturn 0;\n\nfail_close:\n\tclose_ctree(fs_info->tree_root);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "s->s_id",
            "bdevname(bdev, b)",
            "sizeof(s->s_id)"
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdevname",
          "args": [
            "bdev",
            "b"
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "s"
          ],
          "line": 1369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "s"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sget",
          "args": [
            "fs_type",
            "btrfs_test_super",
            "btrfs_set_super",
            "flags | MS_NOSEC",
            "fs_info"
          ],
          "line": 1366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_open_devices",
          "args": [
            "fs_devices",
            "mode",
            "fs_type"
          ],
          "line": 1356
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_open_devices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "860-874",
          "snippet": "int btrfs_open_devices(struct btrfs_fs_devices *fs_devices,\n\t\t       fmode_t flags, void *holder)\n{\n\tint ret;\n\n\tmutex_lock(&uuid_mutex);\n\tif (fs_devices->opened) {\n\t\tfs_devices->opened++;\n\t\tret = 0;\n\t} else {\n\t\tret = __btrfs_open_devices(fs_devices, flags, holder);\n\t}\n\tmutex_unlock(&uuid_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_open_devices(struct btrfs_fs_devices *fs_devices,\n\t\t       fmode_t flags, void *holder)\n{\n\tint ret;\n\n\tmutex_lock(&uuid_mutex);\n\tif (fs_devices->opened) {\n\t\tfs_devices->opened++;\n\t\tret = 0;\n\t} else {\n\t\tret = __btrfs_open_devices(fs_devices, flags, holder);\n\t}\n\tmutex_unlock(&uuid_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_init_mnt_opts",
          "args": [
            "&fs_info->security_opts"
          ],
          "line": 1350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "BTRFS_SUPER_INFO_SIZE",
            "GFP_NOFS"
          ],
          "line": 1349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "BTRFS_SUPER_INFO_SIZE",
            "GFP_NOFS"
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct btrfs_fs_info)",
            "GFP_NOFS"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_scan_one_device",
          "args": [
            "device_name",
            "mode",
            "fs_type",
            "&fs_devices"
          ],
          "line": 1330
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_scan_one_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "881-970",
          "snippet": "int btrfs_scan_one_device(const char *path, fmode_t flags, void *holder,\n\t\t\t  struct btrfs_fs_devices **fs_devices_ret)\n{\n\tstruct btrfs_super_block *disk_super;\n\tstruct block_device *bdev;\n\tstruct page *page;\n\tvoid *p;\n\tint ret = -EINVAL;\n\tu64 devid;\n\tu64 transid;\n\tu64 total_devices;\n\tu64 bytenr;\n\tpgoff_t index;\n\n\t/*\n\t * we would like to check all the supers, but that would make\n\t * a btrfs mount succeed after a mkfs from a different FS.\n\t * So, we need to add a special mount option to scan for\n\t * later supers, using BTRFS_SUPER_MIRROR_MAX instead\n\t */\n\tbytenr = btrfs_sb_offset(0);\n\tflags |= FMODE_EXCL;\n\tmutex_lock(&uuid_mutex);\n\n\tbdev = blkdev_get_by_path(path, flags, holder);\n\n\tif (IS_ERR(bdev)) {\n\t\tret = PTR_ERR(bdev);\n\t\tgoto error;\n\t}\n\n\t/* make sure our super fits in the device */\n\tif (bytenr + PAGE_CACHE_SIZE >= i_size_read(bdev->bd_inode))\n\t\tgoto error_bdev_put;\n\n\t/* make sure our super fits in the page */\n\tif (sizeof(*disk_super) > PAGE_CACHE_SIZE)\n\t\tgoto error_bdev_put;\n\n\t/* make sure our super doesn't straddle pages on disk */\n\tindex = bytenr >> PAGE_CACHE_SHIFT;\n\tif ((bytenr + sizeof(*disk_super) - 1) >> PAGE_CACHE_SHIFT != index)\n\t\tgoto error_bdev_put;\n\n\t/* pull in the page with our super */\n\tpage = read_cache_page_gfp(bdev->bd_inode->i_mapping,\n\t\t\t\t   index, GFP_NOFS);\n\n\tif (IS_ERR_OR_NULL(page))\n\t\tgoto error_bdev_put;\n\n\tp = kmap(page);\n\n\t/* align our pointer to the offset of the super block */\n\tdisk_super = p + (bytenr & ~PAGE_CACHE_MASK);\n\n\tif (btrfs_super_bytenr(disk_super) != bytenr ||\n\t    btrfs_super_magic(disk_super) != BTRFS_MAGIC)\n\t\tgoto error_unmap;\n\n\tdevid = btrfs_stack_device_id(&disk_super->dev_item);\n\ttransid = btrfs_super_generation(disk_super);\n\ttotal_devices = btrfs_super_num_devices(disk_super);\n\n\tret = device_list_add(path, disk_super, devid, fs_devices_ret);\n\tif (ret > 0) {\n\t\tif (disk_super->label[0]) {\n\t\t\tif (disk_super->label[BTRFS_LABEL_SIZE - 1])\n\t\t\t\tdisk_super->label[BTRFS_LABEL_SIZE - 1] = '\\0';\n\t\t\tprintk(KERN_INFO \"BTRFS: device label %s \", disk_super->label);\n\t\t} else {\n\t\t\tprintk(KERN_INFO \"BTRFS: device fsid %pU \", disk_super->fsid);\n\t\t}\n\n\t\tprintk(KERN_CONT \"devid %llu transid %llu %s\\n\", devid, transid, path);\n\t\tret = 0;\n\t}\n\tif (!ret && fs_devices_ret)\n\t\t(*fs_devices_ret)->total_devices = total_devices;\n\nerror_unmap:\n\tkunmap(page);\n\tpage_cache_release(page);\n\nerror_bdev_put:\n\tblkdev_put(bdev, flags);\nerror:\n\tmutex_unlock(&uuid_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_scan_one_device(const char *path, fmode_t flags, void *holder,\n\t\t\t  struct btrfs_fs_devices **fs_devices_ret)\n{\n\tstruct btrfs_super_block *disk_super;\n\tstruct block_device *bdev;\n\tstruct page *page;\n\tvoid *p;\n\tint ret = -EINVAL;\n\tu64 devid;\n\tu64 transid;\n\tu64 total_devices;\n\tu64 bytenr;\n\tpgoff_t index;\n\n\t/*\n\t * we would like to check all the supers, but that would make\n\t * a btrfs mount succeed after a mkfs from a different FS.\n\t * So, we need to add a special mount option to scan for\n\t * later supers, using BTRFS_SUPER_MIRROR_MAX instead\n\t */\n\tbytenr = btrfs_sb_offset(0);\n\tflags |= FMODE_EXCL;\n\tmutex_lock(&uuid_mutex);\n\n\tbdev = blkdev_get_by_path(path, flags, holder);\n\n\tif (IS_ERR(bdev)) {\n\t\tret = PTR_ERR(bdev);\n\t\tgoto error;\n\t}\n\n\t/* make sure our super fits in the device */\n\tif (bytenr + PAGE_CACHE_SIZE >= i_size_read(bdev->bd_inode))\n\t\tgoto error_bdev_put;\n\n\t/* make sure our super fits in the page */\n\tif (sizeof(*disk_super) > PAGE_CACHE_SIZE)\n\t\tgoto error_bdev_put;\n\n\t/* make sure our super doesn't straddle pages on disk */\n\tindex = bytenr >> PAGE_CACHE_SHIFT;\n\tif ((bytenr + sizeof(*disk_super) - 1) >> PAGE_CACHE_SHIFT != index)\n\t\tgoto error_bdev_put;\n\n\t/* pull in the page with our super */\n\tpage = read_cache_page_gfp(bdev->bd_inode->i_mapping,\n\t\t\t\t   index, GFP_NOFS);\n\n\tif (IS_ERR_OR_NULL(page))\n\t\tgoto error_bdev_put;\n\n\tp = kmap(page);\n\n\t/* align our pointer to the offset of the super block */\n\tdisk_super = p + (bytenr & ~PAGE_CACHE_MASK);\n\n\tif (btrfs_super_bytenr(disk_super) != bytenr ||\n\t    btrfs_super_magic(disk_super) != BTRFS_MAGIC)\n\t\tgoto error_unmap;\n\n\tdevid = btrfs_stack_device_id(&disk_super->dev_item);\n\ttransid = btrfs_super_generation(disk_super);\n\ttotal_devices = btrfs_super_num_devices(disk_super);\n\n\tret = device_list_add(path, disk_super, devid, fs_devices_ret);\n\tif (ret > 0) {\n\t\tif (disk_super->label[0]) {\n\t\t\tif (disk_super->label[BTRFS_LABEL_SIZE - 1])\n\t\t\t\tdisk_super->label[BTRFS_LABEL_SIZE - 1] = '\\0';\n\t\t\tprintk(KERN_INFO \"BTRFS: device label %s \", disk_super->label);\n\t\t} else {\n\t\t\tprintk(KERN_INFO \"BTRFS: device fsid %pU \", disk_super->fsid);\n\t\t}\n\n\t\tprintk(KERN_CONT \"devid %llu transid %llu %s\\n\", devid, transid, path);\n\t\tret = 0;\n\t}\n\tif (!ret && fs_devices_ret)\n\t\t(*fs_devices_ret)->total_devices = total_devices;\n\nerror_unmap:\n\tkunmap(page);\n\tpage_cache_release(page);\n\nerror_bdev_put:\n\tblkdev_put(bdev, flags);\nerror:\n\tmutex_unlock(&uuid_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_security_options",
          "args": [
            "data",
            "&new_sec_opts"
          ],
          "line": 1325
        },
        "resolved": true,
        "details": {
          "function_name": "parse_security_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "1236-1253",
          "snippet": "static int parse_security_options(char *orig_opts,\n\t\t\t\t  struct security_mnt_opts *sec_opts)\n{\n\tchar *secdata = NULL;\n\tint ret = 0;\n\n\tsecdata = alloc_secdata();\n\tif (!secdata)\n\t\treturn -ENOMEM;\n\tret = security_sb_copy_data(orig_opts, secdata);\n\tif (ret) {\n\t\tfree_secdata(secdata);\n\t\treturn ret;\n\t}\n\tret = security_sb_parse_opts_str(secdata, sec_opts);\n\tfree_secdata(secdata);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nstatic int parse_security_options(char *orig_opts,\n\t\t\t\t  struct security_mnt_opts *sec_opts)\n{\n\tchar *secdata = NULL;\n\tint ret = 0;\n\n\tsecdata = alloc_secdata();\n\tif (!secdata)\n\t\treturn -ENOMEM;\n\tret = security_sb_copy_data(orig_opts, secdata);\n\tif (ret) {\n\t\tfree_secdata(secdata);\n\t\treturn ret;\n\t}\n\tret = security_sb_parse_opts_str(secdata, sec_opts);\n\tfree_secdata(secdata);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_init_mnt_opts",
          "args": [
            "&new_sec_opts"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "subvol_name"
          ],
          "line": 1319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount_subvol",
          "args": [
            "subvol_name",
            "flags",
            "device_name",
            "data"
          ],
          "line": 1318
        },
        "resolved": true,
        "details": {
          "function_name": "mount_subvol",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "1182-1234",
          "snippet": "static struct dentry *mount_subvol(const char *subvol_name, int flags,\n\t\t\t\t   const char *device_name, char *data)\n{\n\tstruct dentry *root;\n\tstruct vfsmount *mnt;\n\tchar *newargs;\n\n\tnewargs = setup_root_args(data);\n\tif (!newargs)\n\t\treturn ERR_PTR(-ENOMEM);\n\tmnt = vfs_kern_mount(&btrfs_fs_type, flags, device_name,\n\t\t\t     newargs);\n\n\tif (PTR_RET(mnt) == -EBUSY) {\n\t\tif (flags & MS_RDONLY) {\n\t\t\tmnt = vfs_kern_mount(&btrfs_fs_type, flags & ~MS_RDONLY, device_name,\n\t\t\t\t\t     newargs);\n\t\t} else {\n\t\t\tint r;\n\t\t\tmnt = vfs_kern_mount(&btrfs_fs_type, flags | MS_RDONLY, device_name,\n\t\t\t\t\t     newargs);\n\t\t\tif (IS_ERR(mnt)) {\n\t\t\t\tkfree(newargs);\n\t\t\t\treturn ERR_CAST(mnt);\n\t\t\t}\n\n\t\t\tr = btrfs_remount(mnt->mnt_sb, &flags, NULL);\n\t\t\tif (r < 0) {\n\t\t\t\t/* FIXME: release vfsmount mnt ??*/\n\t\t\t\tkfree(newargs);\n\t\t\t\treturn ERR_PTR(r);\n\t\t\t}\n\t\t}\n\t}\n\n\tkfree(newargs);\n\n\tif (IS_ERR(mnt))\n\t\treturn ERR_CAST(mnt);\n\n\troot = mount_subtree(mnt, subvol_name);\n\n\tif (!IS_ERR(root) && !is_subvolume_inode(root->d_inode)) {\n\t\tstruct super_block *s = root->d_sb;\n\t\tdput(root);\n\t\troot = ERR_PTR(-EINVAL);\n\t\tdeactivate_locked_super(s);\n\t\tprintk(KERN_ERR \"BTRFS: '%s' is not a valid subvolume\\n\",\n\t\t\t\tsubvol_name);\n\t}\n\n\treturn root;\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type btrfs_fs_type;",
            "static int btrfs_remount(struct super_block *sb, int *flags, char *data);",
            "static struct file_system_type btrfs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"btrfs\",\n\t.mount\t\t= btrfs_mount,\n\t.kill_sb\t= btrfs_kill_super,\n\t.fs_flags\t= FS_REQUIRES_DEV | FS_BINARY_MOUNTDATA,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nstatic struct file_system_type btrfs_fs_type;\nstatic int btrfs_remount(struct super_block *sb, int *flags, char *data);\nstatic struct file_system_type btrfs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"btrfs\",\n\t.mount\t\t= btrfs_mount,\n\t.kill_sb\t= btrfs_kill_super,\n\t.fs_flags\t= FS_REQUIRES_DEV | FS_BINARY_MOUNTDATA,\n};\n\nstatic struct dentry *mount_subvol(const char *subvol_name, int flags,\n\t\t\t\t   const char *device_name, char *data)\n{\n\tstruct dentry *root;\n\tstruct vfsmount *mnt;\n\tchar *newargs;\n\n\tnewargs = setup_root_args(data);\n\tif (!newargs)\n\t\treturn ERR_PTR(-ENOMEM);\n\tmnt = vfs_kern_mount(&btrfs_fs_type, flags, device_name,\n\t\t\t     newargs);\n\n\tif (PTR_RET(mnt) == -EBUSY) {\n\t\tif (flags & MS_RDONLY) {\n\t\t\tmnt = vfs_kern_mount(&btrfs_fs_type, flags & ~MS_RDONLY, device_name,\n\t\t\t\t\t     newargs);\n\t\t} else {\n\t\t\tint r;\n\t\t\tmnt = vfs_kern_mount(&btrfs_fs_type, flags | MS_RDONLY, device_name,\n\t\t\t\t\t     newargs);\n\t\t\tif (IS_ERR(mnt)) {\n\t\t\t\tkfree(newargs);\n\t\t\t\treturn ERR_CAST(mnt);\n\t\t\t}\n\n\t\t\tr = btrfs_remount(mnt->mnt_sb, &flags, NULL);\n\t\t\tif (r < 0) {\n\t\t\t\t/* FIXME: release vfsmount mnt ??*/\n\t\t\t\tkfree(newargs);\n\t\t\t\treturn ERR_PTR(r);\n\t\t\t}\n\t\t}\n\t}\n\n\tkfree(newargs);\n\n\tif (IS_ERR(mnt))\n\t\treturn ERR_CAST(mnt);\n\n\troot = mount_subtree(mnt, subvol_name);\n\n\tif (!IS_ERR(root) && !is_subvolume_inode(root->d_inode)) {\n\t\tstruct super_block *s = root->d_sb;\n\t\tdput(root);\n\t\troot = ERR_PTR(-EINVAL);\n\t\tdeactivate_locked_super(s);\n\t\tprintk(KERN_ERR \"BTRFS: '%s' is not a valid subvolume\\n\",\n\t\t\t\tsubvol_name);\n\t}\n\n\treturn root;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "subvol_name"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_parse_early_options",
          "args": [
            "data",
            "mode",
            "fs_type",
            "&subvol_name",
            "&subvol_objectid",
            "&fs_devices"
          ],
          "line": 1309
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_parse_early_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "767-842",
          "snippet": "static int btrfs_parse_early_options(const char *options, fmode_t flags,\n\t\tvoid *holder, char **subvol_name, u64 *subvol_objectid,\n\t\tstruct btrfs_fs_devices **fs_devices)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\tchar *device_name, *opts, *orig, *p;\n\tchar *num = NULL;\n\tint error = 0;\n\n\tif (!options)\n\t\treturn 0;\n\n\t/*\n\t * strsep changes the string, duplicate it because parse_options\n\t * gets called twice\n\t */\n\topts = kstrdup(options, GFP_KERNEL);\n\tif (!opts)\n\t\treturn -ENOMEM;\n\torig = opts;\n\n\twhile ((p = strsep(&opts, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_subvol:\n\t\t\tkfree(*subvol_name);\n\t\t\t*subvol_name = match_strdup(&args[0]);\n\t\t\tif (!*subvol_name) {\n\t\t\t\terror = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_subvolid:\n\t\t\tnum = match_strdup(&args[0]);\n\t\t\tif (num) {\n\t\t\t\t*subvol_objectid = memparse(num, NULL);\n\t\t\t\tkfree(num);\n\t\t\t\t/* we want the original fs_tree */\n\t\t\t\tif (!*subvol_objectid)\n\t\t\t\t\t*subvol_objectid =\n\t\t\t\t\t\tBTRFS_FS_TREE_OBJECTID;\n\t\t\t} else {\n\t\t\t\terror = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_subvolrootid:\n\t\t\tprintk(KERN_WARNING\n\t\t\t\t\"BTRFS: 'subvolrootid' mount option is deprecated and has \"\n\t\t\t\t\"no effect\\n\");\n\t\t\tbreak;\n\t\tcase Opt_device:\n\t\t\tdevice_name = match_strdup(&args[0]);\n\t\t\tif (!device_name) {\n\t\t\t\terror = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\terror = btrfs_scan_one_device(device_name,\n\t\t\t\t\tflags, holder, fs_devices);\n\t\t\tkfree(device_name);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\tkfree(orig);\n\treturn error;\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static match_table_t tokens = {\n\t{Opt_degraded, \"degraded\"},\n\t{Opt_subvol, \"subvol=%s\"},\n\t{Opt_subvolid, \"subvolid=%s\"},\n\t{Opt_device, \"device=%s\"},\n\t{Opt_nodatasum, \"nodatasum\"},\n\t{Opt_datasum, \"datasum\"},\n\t{Opt_nodatacow, \"nodatacow\"},\n\t{Opt_datacow, \"datacow\"},\n\t{Opt_nobarrier, \"nobarrier\"},\n\t{Opt_barrier, \"barrier\"},\n\t{Opt_max_inline, \"max_inline=%s\"},\n\t{Opt_alloc_start, \"alloc_start=%s\"},\n\t{Opt_thread_pool, \"thread_pool=%d\"},\n\t{Opt_compress, \"compress\"},\n\t{Opt_compress_type, \"compress=%s\"},\n\t{Opt_compress_force, \"compress-force\"},\n\t{Opt_compress_force_type, \"compress-force=%s\"},\n\t{Opt_ssd, \"ssd\"},\n\t{Opt_ssd_spread, \"ssd_spread\"},\n\t{Opt_nossd, \"nossd\"},\n\t{Opt_acl, \"acl\"},\n\t{Opt_noacl, \"noacl\"},\n\t{Opt_notreelog, \"notreelog\"},\n\t{Opt_treelog, \"treelog\"},\n\t{Opt_flushoncommit, \"flushoncommit\"},\n\t{Opt_noflushoncommit, \"noflushoncommit\"},\n\t{Opt_ratio, \"metadata_ratio=%d\"},\n\t{Opt_discard, \"discard\"},\n\t{Opt_nodiscard, \"nodiscard\"},\n\t{Opt_space_cache, \"space_cache\"},\n\t{Opt_clear_cache, \"clear_cache\"},\n\t{Opt_user_subvol_rm_allowed, \"user_subvol_rm_allowed\"},\n\t{Opt_enospc_debug, \"enospc_debug\"},\n\t{Opt_noenospc_debug, \"noenospc_debug\"},\n\t{Opt_subvolrootid, \"subvolrootid=%d\"},\n\t{Opt_defrag, \"autodefrag\"},\n\t{Opt_nodefrag, \"noautodefrag\"},\n\t{Opt_inode_cache, \"inode_cache\"},\n\t{Opt_noinode_cache, \"noinode_cache\"},\n\t{Opt_no_space_cache, \"nospace_cache\"},\n\t{Opt_recovery, \"recovery\"},\n\t{Opt_skip_balance, \"skip_balance\"},\n\t{Opt_check_integrity, \"check_int\"},\n\t{Opt_check_integrity_including_extent_data, \"check_int_data\"},\n\t{Opt_check_integrity_print_mask, \"check_int_print_mask=%d\"},\n\t{Opt_rescan_uuid_tree, \"rescan_uuid_tree\"},\n\t{Opt_fatal_errors, \"fatal_errors=%s\"},\n\t{Opt_commit_interval, \"commit=%d\"},\n\t{Opt_err, NULL},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nstatic match_table_t tokens = {\n\t{Opt_degraded, \"degraded\"},\n\t{Opt_subvol, \"subvol=%s\"},\n\t{Opt_subvolid, \"subvolid=%s\"},\n\t{Opt_device, \"device=%s\"},\n\t{Opt_nodatasum, \"nodatasum\"},\n\t{Opt_datasum, \"datasum\"},\n\t{Opt_nodatacow, \"nodatacow\"},\n\t{Opt_datacow, \"datacow\"},\n\t{Opt_nobarrier, \"nobarrier\"},\n\t{Opt_barrier, \"barrier\"},\n\t{Opt_max_inline, \"max_inline=%s\"},\n\t{Opt_alloc_start, \"alloc_start=%s\"},\n\t{Opt_thread_pool, \"thread_pool=%d\"},\n\t{Opt_compress, \"compress\"},\n\t{Opt_compress_type, \"compress=%s\"},\n\t{Opt_compress_force, \"compress-force\"},\n\t{Opt_compress_force_type, \"compress-force=%s\"},\n\t{Opt_ssd, \"ssd\"},\n\t{Opt_ssd_spread, \"ssd_spread\"},\n\t{Opt_nossd, \"nossd\"},\n\t{Opt_acl, \"acl\"},\n\t{Opt_noacl, \"noacl\"},\n\t{Opt_notreelog, \"notreelog\"},\n\t{Opt_treelog, \"treelog\"},\n\t{Opt_flushoncommit, \"flushoncommit\"},\n\t{Opt_noflushoncommit, \"noflushoncommit\"},\n\t{Opt_ratio, \"metadata_ratio=%d\"},\n\t{Opt_discard, \"discard\"},\n\t{Opt_nodiscard, \"nodiscard\"},\n\t{Opt_space_cache, \"space_cache\"},\n\t{Opt_clear_cache, \"clear_cache\"},\n\t{Opt_user_subvol_rm_allowed, \"user_subvol_rm_allowed\"},\n\t{Opt_enospc_debug, \"enospc_debug\"},\n\t{Opt_noenospc_debug, \"noenospc_debug\"},\n\t{Opt_subvolrootid, \"subvolrootid=%d\"},\n\t{Opt_defrag, \"autodefrag\"},\n\t{Opt_nodefrag, \"noautodefrag\"},\n\t{Opt_inode_cache, \"inode_cache\"},\n\t{Opt_noinode_cache, \"noinode_cache\"},\n\t{Opt_no_space_cache, \"nospace_cache\"},\n\t{Opt_recovery, \"recovery\"},\n\t{Opt_skip_balance, \"skip_balance\"},\n\t{Opt_check_integrity, \"check_int\"},\n\t{Opt_check_integrity_including_extent_data, \"check_int_data\"},\n\t{Opt_check_integrity_print_mask, \"check_int_print_mask=%d\"},\n\t{Opt_rescan_uuid_tree, \"rescan_uuid_tree\"},\n\t{Opt_fatal_errors, \"fatal_errors=%s\"},\n\t{Opt_commit_interval, \"commit=%d\"},\n\t{Opt_err, NULL},\n};\n\nstatic int btrfs_parse_early_options(const char *options, fmode_t flags,\n\t\tvoid *holder, char **subvol_name, u64 *subvol_objectid,\n\t\tstruct btrfs_fs_devices **fs_devices)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\tchar *device_name, *opts, *orig, *p;\n\tchar *num = NULL;\n\tint error = 0;\n\n\tif (!options)\n\t\treturn 0;\n\n\t/*\n\t * strsep changes the string, duplicate it because parse_options\n\t * gets called twice\n\t */\n\topts = kstrdup(options, GFP_KERNEL);\n\tif (!opts)\n\t\treturn -ENOMEM;\n\torig = opts;\n\n\twhile ((p = strsep(&opts, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_subvol:\n\t\t\tkfree(*subvol_name);\n\t\t\t*subvol_name = match_strdup(&args[0]);\n\t\t\tif (!*subvol_name) {\n\t\t\t\terror = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_subvolid:\n\t\t\tnum = match_strdup(&args[0]);\n\t\t\tif (num) {\n\t\t\t\t*subvol_objectid = memparse(num, NULL);\n\t\t\t\tkfree(num);\n\t\t\t\t/* we want the original fs_tree */\n\t\t\t\tif (!*subvol_objectid)\n\t\t\t\t\t*subvol_objectid =\n\t\t\t\t\t\tBTRFS_FS_TREE_OBJECTID;\n\t\t\t} else {\n\t\t\t\terror = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_subvolrootid:\n\t\t\tprintk(KERN_WARNING\n\t\t\t\t\"BTRFS: 'subvolrootid' mount option is deprecated and has \"\n\t\t\t\t\"no effect\\n\");\n\t\t\tbreak;\n\t\tcase Opt_device:\n\t\t\tdevice_name = match_strdup(&args[0]);\n\t\t\tif (!device_name) {\n\t\t\t\terror = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\terror = btrfs_scan_one_device(device_name,\n\t\t\t\t\tflags, holder, fs_devices);\n\t\t\tkfree(device_name);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\tkfree(orig);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nstatic int btrfs_remount(struct super_block *sb, int *flags, char *data);\n\nstatic struct dentry *btrfs_mount(struct file_system_type *fs_type, int flags,\n\t\tconst char *device_name, void *data)\n{\n\tstruct block_device *bdev = NULL;\n\tstruct super_block *s;\n\tstruct dentry *root;\n\tstruct btrfs_fs_devices *fs_devices = NULL;\n\tstruct btrfs_fs_info *fs_info = NULL;\n\tstruct security_mnt_opts new_sec_opts;\n\tfmode_t mode = FMODE_READ;\n\tchar *subvol_name = NULL;\n\tu64 subvol_objectid = 0;\n\tint error = 0;\n\n\tif (!(flags & MS_RDONLY))\n\t\tmode |= FMODE_WRITE;\n\n\terror = btrfs_parse_early_options(data, mode, fs_type,\n\t\t\t\t\t  &subvol_name, &subvol_objectid,\n\t\t\t\t\t  &fs_devices);\n\tif (error) {\n\t\tkfree(subvol_name);\n\t\treturn ERR_PTR(error);\n\t}\n\n\tif (subvol_name) {\n\t\troot = mount_subvol(subvol_name, flags, device_name, data);\n\t\tkfree(subvol_name);\n\t\treturn root;\n\t}\n\n\tsecurity_init_mnt_opts(&new_sec_opts);\n\tif (data) {\n\t\terror = parse_security_options(data, &new_sec_opts);\n\t\tif (error)\n\t\t\treturn ERR_PTR(error);\n\t}\n\n\terror = btrfs_scan_one_device(device_name, mode, fs_type, &fs_devices);\n\tif (error)\n\t\tgoto error_sec_opts;\n\n\t/*\n\t * Setup a dummy root and fs_info for test/set super.  This is because\n\t * we don't actually fill this stuff out until open_ctree, but we need\n\t * it for searching for existing supers, so this lets us do that and\n\t * then open_ctree will properly initialize everything later.\n\t */\n\tfs_info = kzalloc(sizeof(struct btrfs_fs_info), GFP_NOFS);\n\tif (!fs_info) {\n\t\terror = -ENOMEM;\n\t\tgoto error_sec_opts;\n\t}\n\n\tfs_info->fs_devices = fs_devices;\n\n\tfs_info->super_copy = kzalloc(BTRFS_SUPER_INFO_SIZE, GFP_NOFS);\n\tfs_info->super_for_commit = kzalloc(BTRFS_SUPER_INFO_SIZE, GFP_NOFS);\n\tsecurity_init_mnt_opts(&fs_info->security_opts);\n\tif (!fs_info->super_copy || !fs_info->super_for_commit) {\n\t\terror = -ENOMEM;\n\t\tgoto error_fs_info;\n\t}\n\n\terror = btrfs_open_devices(fs_devices, mode, fs_type);\n\tif (error)\n\t\tgoto error_fs_info;\n\n\tif (!(flags & MS_RDONLY) && fs_devices->rw_devices == 0) {\n\t\terror = -EACCES;\n\t\tgoto error_close_devices;\n\t}\n\n\tbdev = fs_devices->latest_bdev;\n\ts = sget(fs_type, btrfs_test_super, btrfs_set_super, flags | MS_NOSEC,\n\t\t fs_info);\n\tif (IS_ERR(s)) {\n\t\terror = PTR_ERR(s);\n\t\tgoto error_close_devices;\n\t}\n\n\tif (s->s_root) {\n\t\tbtrfs_close_devices(fs_devices);\n\t\tfree_fs_info(fs_info);\n\t\tif ((flags ^ s->s_flags) & MS_RDONLY)\n\t\t\terror = -EBUSY;\n\t} else {\n\t\tchar b[BDEVNAME_SIZE];\n\n\t\tstrlcpy(s->s_id, bdevname(bdev, b), sizeof(s->s_id));\n\t\tbtrfs_sb(s)->bdev_holder = fs_type;\n\t\terror = btrfs_fill_super(s, fs_devices, data,\n\t\t\t\t\t flags & MS_SILENT ? 1 : 0);\n\t}\n\n\troot = !error ? get_default_root(s, subvol_objectid) : ERR_PTR(error);\n\tif (IS_ERR(root)) {\n\t\tdeactivate_locked_super(s);\n\t\terror = PTR_ERR(root);\n\t\tgoto error_sec_opts;\n\t}\n\n\tfs_info = btrfs_sb(s);\n\terror = setup_security_options(fs_info, s, &new_sec_opts);\n\tif (error) {\n\t\tdput(root);\n\t\tdeactivate_locked_super(s);\n\t\tgoto error_sec_opts;\n\t}\n\n\treturn root;\n\nerror_close_devices:\n\tbtrfs_close_devices(fs_devices);\nerror_fs_info:\n\tfree_fs_info(fs_info);\nerror_sec_opts:\n\tsecurity_free_mnt_opts(&new_sec_opts);\n\treturn ERR_PTR(error);\n}"
  },
  {
    "function_name": "setup_security_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
    "lines": "1255-1284",
    "snippet": "static int setup_security_options(struct btrfs_fs_info *fs_info,\n\t\t\t\t  struct super_block *sb,\n\t\t\t\t  struct security_mnt_opts *sec_opts)\n{\n\tint ret = 0;\n\n\t/*\n\t * Call security_sb_set_mnt_opts() to check whether new sec_opts\n\t * is valid.\n\t */\n\tret = security_sb_set_mnt_opts(sb, sec_opts, 0, NULL);\n\tif (ret)\n\t\treturn ret;\n\n#ifdef CONFIG_SECURITY\n\tif (!fs_info->security_opts.num_mnt_opts) {\n\t\t/* first time security setup, copy sec_opts to fs_info */\n\t\tmemcpy(&fs_info->security_opts, sec_opts, sizeof(*sec_opts));\n\t} else {\n\t\t/*\n\t\t * Since SELinux(the only one supports security_mnt_opts) does\n\t\t * NOT support changing context during remount/mount same sb,\n\t\t * This must be the same or part of the same security options,\n\t\t * just free it.\n\t\t */\n\t\tsecurity_free_mnt_opts(sec_opts);\n\t}\n#endif\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/btrfs.h>",
      "#include \"qgroup.h\"",
      "#include \"tests/btrfs-tests.h\"",
      "#include \"backref.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"compression.h\"",
      "#include \"export.h\"",
      "#include \"volumes.h\"",
      "#include \"xattr.h\"",
      "#include \"props.h\"",
      "#include \"hash.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/namei.h>",
      "#include <linux/ctype.h>",
      "#include <linux/parser.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "security_free_mnt_opts",
          "args": [
            "sec_opts"
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&fs_info->security_opts",
            "sec_opts",
            "sizeof(*sec_opts)"
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_sb_set_mnt_opts",
          "args": [
            "sb",
            "sec_opts",
            "0",
            "NULL"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nstatic int setup_security_options(struct btrfs_fs_info *fs_info,\n\t\t\t\t  struct super_block *sb,\n\t\t\t\t  struct security_mnt_opts *sec_opts)\n{\n\tint ret = 0;\n\n\t/*\n\t * Call security_sb_set_mnt_opts() to check whether new sec_opts\n\t * is valid.\n\t */\n\tret = security_sb_set_mnt_opts(sb, sec_opts, 0, NULL);\n\tif (ret)\n\t\treturn ret;\n\n#ifdef CONFIG_SECURITY\n\tif (!fs_info->security_opts.num_mnt_opts) {\n\t\t/* first time security setup, copy sec_opts to fs_info */\n\t\tmemcpy(&fs_info->security_opts, sec_opts, sizeof(*sec_opts));\n\t} else {\n\t\t/*\n\t\t * Since SELinux(the only one supports security_mnt_opts) does\n\t\t * NOT support changing context during remount/mount same sb,\n\t\t * This must be the same or part of the same security options,\n\t\t * just free it.\n\t\t */\n\t\tsecurity_free_mnt_opts(sec_opts);\n\t}\n#endif\n\treturn ret;\n}"
  },
  {
    "function_name": "parse_security_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
    "lines": "1236-1253",
    "snippet": "static int parse_security_options(char *orig_opts,\n\t\t\t\t  struct security_mnt_opts *sec_opts)\n{\n\tchar *secdata = NULL;\n\tint ret = 0;\n\n\tsecdata = alloc_secdata();\n\tif (!secdata)\n\t\treturn -ENOMEM;\n\tret = security_sb_copy_data(orig_opts, secdata);\n\tif (ret) {\n\t\tfree_secdata(secdata);\n\t\treturn ret;\n\t}\n\tret = security_sb_parse_opts_str(secdata, sec_opts);\n\tfree_secdata(secdata);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/btrfs.h>",
      "#include \"qgroup.h\"",
      "#include \"tests/btrfs-tests.h\"",
      "#include \"backref.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"compression.h\"",
      "#include \"export.h\"",
      "#include \"volumes.h\"",
      "#include \"xattr.h\"",
      "#include \"props.h\"",
      "#include \"hash.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/namei.h>",
      "#include <linux/ctype.h>",
      "#include <linux/parser.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_secdata",
          "args": [
            "secdata"
          ],
          "line": 1251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_sb_parse_opts_str",
          "args": [
            "secdata",
            "sec_opts"
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_secdata",
          "args": [
            "secdata"
          ],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_sb_copy_data",
          "args": [
            "orig_opts",
            "secdata"
          ],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_secdata",
          "args": [],
          "line": 1242
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nstatic int parse_security_options(char *orig_opts,\n\t\t\t\t  struct security_mnt_opts *sec_opts)\n{\n\tchar *secdata = NULL;\n\tint ret = 0;\n\n\tsecdata = alloc_secdata();\n\tif (!secdata)\n\t\treturn -ENOMEM;\n\tret = security_sb_copy_data(orig_opts, secdata);\n\tif (ret) {\n\t\tfree_secdata(secdata);\n\t\treturn ret;\n\t}\n\tret = security_sb_parse_opts_str(secdata, sec_opts);\n\tfree_secdata(secdata);\n\treturn ret;\n}"
  },
  {
    "function_name": "mount_subvol",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
    "lines": "1182-1234",
    "snippet": "static struct dentry *mount_subvol(const char *subvol_name, int flags,\n\t\t\t\t   const char *device_name, char *data)\n{\n\tstruct dentry *root;\n\tstruct vfsmount *mnt;\n\tchar *newargs;\n\n\tnewargs = setup_root_args(data);\n\tif (!newargs)\n\t\treturn ERR_PTR(-ENOMEM);\n\tmnt = vfs_kern_mount(&btrfs_fs_type, flags, device_name,\n\t\t\t     newargs);\n\n\tif (PTR_RET(mnt) == -EBUSY) {\n\t\tif (flags & MS_RDONLY) {\n\t\t\tmnt = vfs_kern_mount(&btrfs_fs_type, flags & ~MS_RDONLY, device_name,\n\t\t\t\t\t     newargs);\n\t\t} else {\n\t\t\tint r;\n\t\t\tmnt = vfs_kern_mount(&btrfs_fs_type, flags | MS_RDONLY, device_name,\n\t\t\t\t\t     newargs);\n\t\t\tif (IS_ERR(mnt)) {\n\t\t\t\tkfree(newargs);\n\t\t\t\treturn ERR_CAST(mnt);\n\t\t\t}\n\n\t\t\tr = btrfs_remount(mnt->mnt_sb, &flags, NULL);\n\t\t\tif (r < 0) {\n\t\t\t\t/* FIXME: release vfsmount mnt ??*/\n\t\t\t\tkfree(newargs);\n\t\t\t\treturn ERR_PTR(r);\n\t\t\t}\n\t\t}\n\t}\n\n\tkfree(newargs);\n\n\tif (IS_ERR(mnt))\n\t\treturn ERR_CAST(mnt);\n\n\troot = mount_subtree(mnt, subvol_name);\n\n\tif (!IS_ERR(root) && !is_subvolume_inode(root->d_inode)) {\n\t\tstruct super_block *s = root->d_sb;\n\t\tdput(root);\n\t\troot = ERR_PTR(-EINVAL);\n\t\tdeactivate_locked_super(s);\n\t\tprintk(KERN_ERR \"BTRFS: '%s' is not a valid subvolume\\n\",\n\t\t\t\tsubvol_name);\n\t}\n\n\treturn root;\n}",
    "includes": [
      "#include <trace/events/btrfs.h>",
      "#include \"qgroup.h\"",
      "#include \"tests/btrfs-tests.h\"",
      "#include \"backref.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"compression.h\"",
      "#include \"export.h\"",
      "#include \"volumes.h\"",
      "#include \"xattr.h\"",
      "#include \"props.h\"",
      "#include \"hash.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/namei.h>",
      "#include <linux/ctype.h>",
      "#include <linux/parser.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type btrfs_fs_type;",
      "static int btrfs_remount(struct super_block *sb, int *flags, char *data);",
      "static struct file_system_type btrfs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"btrfs\",\n\t.mount\t\t= btrfs_mount,\n\t.kill_sb\t= btrfs_kill_super,\n\t.fs_flags\t= FS_REQUIRES_DEV | FS_BINARY_MOUNTDATA,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"BTRFS: '%s' is not a valid subvolume\\n\"",
            "subvol_name"
          ],
          "line": 1229
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "deactivate_locked_super",
          "args": [
            "s"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "root"
          ],
          "line": 1226
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_subvolume_inode",
          "args": [
            "root->d_inode"
          ],
          "line": 1224
        },
        "resolved": true,
        "details": {
          "function_name": "is_subvolume_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "1124-1129",
          "snippet": "static inline int is_subvolume_inode(struct inode *inode)\n{\n\tif (inode && inode->i_ino == BTRFS_FIRST_FREE_OBJECTID)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nstatic inline int is_subvolume_inode(struct inode *inode)\n{\n\tif (inode && inode->i_ino == BTRFS_FIRST_FREE_OBJECTID)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "root"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount_subtree",
          "args": [
            "mnt",
            "subvol_name"
          ],
          "line": 1222
        },
        "resolved": true,
        "details": {
          "function_name": "mount_subtree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "2795-2822",
          "snippet": "struct dentry *mount_subtree(struct vfsmount *mnt, const char *name)\n{\n\tstruct mnt_namespace *ns;\n\tstruct super_block *s;\n\tstruct path path;\n\tint err;\n\n\tns = create_mnt_ns(mnt);\n\tif (IS_ERR(ns))\n\t\treturn ERR_CAST(ns);\n\n\terr = vfs_path_lookup(mnt->mnt_root, mnt,\n\t\t\tname, LOOKUP_FOLLOW|LOOKUP_AUTOMOUNT, &path);\n\n\tput_mnt_ns(ns);\n\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\t/* trade a vfsmount reference for active sb one */\n\ts = path.mnt->mnt_sb;\n\tatomic_inc(&s->s_active);\n\tmntput(path.mnt);\n\t/* lock the sucker */\n\tdown_write(&s->s_umount);\n\t/* ... and return the root of (sub)tree on it */\n\treturn path.dentry;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstruct dentry *mount_subtree(struct vfsmount *mnt, const char *name)\n{\n\tstruct mnt_namespace *ns;\n\tstruct super_block *s;\n\tstruct path path;\n\tint err;\n\n\tns = create_mnt_ns(mnt);\n\tif (IS_ERR(ns))\n\t\treturn ERR_CAST(ns);\n\n\terr = vfs_path_lookup(mnt->mnt_root, mnt,\n\t\t\tname, LOOKUP_FOLLOW|LOOKUP_AUTOMOUNT, &path);\n\n\tput_mnt_ns(ns);\n\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\t/* trade a vfsmount reference for active sb one */\n\ts = path.mnt->mnt_sb;\n\tatomic_inc(&s->s_active);\n\tmntput(path.mnt);\n\t/* lock the sucker */\n\tdown_write(&s->s_umount);\n\t/* ... and return the root of (sub)tree on it */\n\treturn path.dentry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "mnt"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "mnt"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "newargs"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "r"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "newargs"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_remount",
          "args": [
            "mnt->mnt_sb",
            "&flags",
            "NULL"
          ],
          "line": 1208
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_remount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "1475-1618",
          "snippet": "static int btrfs_remount(struct super_block *sb, int *flags, char *data)\n{\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(sb);\n\tstruct btrfs_root *root = fs_info->tree_root;\n\tunsigned old_flags = sb->s_flags;\n\tunsigned long old_opts = fs_info->mount_opt;\n\tunsigned long old_compress_type = fs_info->compress_type;\n\tu64 old_max_inline = fs_info->max_inline;\n\tu64 old_alloc_start = fs_info->alloc_start;\n\tint old_thread_pool_size = fs_info->thread_pool_size;\n\tunsigned int old_metadata_ratio = fs_info->metadata_ratio;\n\tint ret;\n\n\tsync_filesystem(sb);\n\tbtrfs_remount_prepare(fs_info);\n\n\tif (data) {\n\t\tstruct security_mnt_opts new_sec_opts;\n\n\t\tsecurity_init_mnt_opts(&new_sec_opts);\n\t\tret = parse_security_options(data, &new_sec_opts);\n\t\tif (ret)\n\t\t\tgoto restore;\n\t\tret = setup_security_options(fs_info, sb,\n\t\t\t\t\t     &new_sec_opts);\n\t\tif (ret) {\n\t\t\tsecurity_free_mnt_opts(&new_sec_opts);\n\t\t\tgoto restore;\n\t\t}\n\t}\n\n\tret = btrfs_parse_options(root, data);\n\tif (ret) {\n\t\tret = -EINVAL;\n\t\tgoto restore;\n\t}\n\n\tbtrfs_remount_begin(fs_info, old_opts, *flags);\n\tbtrfs_resize_thread_pool(fs_info,\n\t\tfs_info->thread_pool_size, old_thread_pool_size);\n\n\tif ((*flags & MS_RDONLY) == (sb->s_flags & MS_RDONLY))\n\t\tgoto out;\n\n\tif (*flags & MS_RDONLY) {\n\t\t/*\n\t\t * this also happens on 'umount -rf' or on shutdown, when\n\t\t * the filesystem is busy.\n\t\t */\n\t\tcancel_work_sync(&fs_info->async_reclaim_work);\n\n\t\t/* wait for the uuid_scan task to finish */\n\t\tdown(&fs_info->uuid_tree_rescan_sem);\n\t\t/* avoid complains from lockdep et al. */\n\t\tup(&fs_info->uuid_tree_rescan_sem);\n\n\t\tsb->s_flags |= MS_RDONLY;\n\n\t\tbtrfs_dev_replace_suspend_for_unmount(fs_info);\n\t\tbtrfs_scrub_cancel(fs_info);\n\t\tbtrfs_pause_balance(fs_info);\n\n\t\tret = btrfs_commit_super(root);\n\t\tif (ret)\n\t\t\tgoto restore;\n\t} else {\n\t\tif (test_bit(BTRFS_FS_STATE_ERROR, &root->fs_info->fs_state)) {\n\t\t\tbtrfs_err(fs_info,\n\t\t\t\t\"Remounting read-write after error is not allowed\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto restore;\n\t\t}\n\t\tif (fs_info->fs_devices->rw_devices == 0) {\n\t\t\tret = -EACCES;\n\t\t\tgoto restore;\n\t\t}\n\n\t\tif (fs_info->fs_devices->missing_devices >\n\t\t     fs_info->num_tolerated_disk_barrier_failures &&\n\t\t    !(*flags & MS_RDONLY)) {\n\t\t\tbtrfs_warn(fs_info,\n\t\t\t\t\"too many missing devices, writeable remount is not allowed\");\n\t\t\tret = -EACCES;\n\t\t\tgoto restore;\n\t\t}\n\n\t\tif (btrfs_super_log_root(fs_info->super_copy) != 0) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto restore;\n\t\t}\n\n\t\tret = btrfs_cleanup_fs_roots(fs_info);\n\t\tif (ret)\n\t\t\tgoto restore;\n\n\t\t/* recover relocation */\n\t\tmutex_lock(&fs_info->cleaner_mutex);\n\t\tret = btrfs_recover_relocation(root);\n\t\tmutex_unlock(&fs_info->cleaner_mutex);\n\t\tif (ret)\n\t\t\tgoto restore;\n\n\t\tret = btrfs_resume_balance_async(fs_info);\n\t\tif (ret)\n\t\t\tgoto restore;\n\n\t\tret = btrfs_resume_dev_replace_async(fs_info);\n\t\tif (ret) {\n\t\t\tbtrfs_warn(fs_info, \"failed to resume dev_replace\");\n\t\t\tgoto restore;\n\t\t}\n\n\t\tif (!fs_info->uuid_root) {\n\t\t\tbtrfs_info(fs_info, \"creating UUID tree\");\n\t\t\tret = btrfs_create_uuid_tree(fs_info);\n\t\t\tif (ret) {\n\t\t\t\tbtrfs_warn(fs_info, \"failed to create the UUID tree %d\", ret);\n\t\t\t\tgoto restore;\n\t\t\t}\n\t\t}\n\t\tsb->s_flags &= ~MS_RDONLY;\n\t}\nout:\n\twake_up_process(fs_info->transaction_kthread);\n\tbtrfs_remount_cleanup(fs_info, old_opts);\n\treturn 0;\n\nrestore:\n\t/* We've hit an error - don't reset MS_RDONLY */\n\tif (sb->s_flags & MS_RDONLY)\n\t\told_flags |= MS_RDONLY;\n\tsb->s_flags = old_flags;\n\tfs_info->mount_opt = old_opts;\n\tfs_info->compress_type = old_compress_type;\n\tfs_info->max_inline = old_max_inline;\n\tmutex_lock(&fs_info->chunk_mutex);\n\tfs_info->alloc_start = old_alloc_start;\n\tmutex_unlock(&fs_info->chunk_mutex);\n\tbtrfs_resize_thread_pool(fs_info,\n\t\told_thread_pool_size, fs_info->thread_pool_size);\n\tfs_info->metadata_ratio = old_metadata_ratio;\n\tbtrfs_remount_cleanup(fs_info, old_opts);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_remount(struct super_block *sb, int *flags, char *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nstatic int btrfs_remount(struct super_block *sb, int *flags, char *data);\n\nstatic int btrfs_remount(struct super_block *sb, int *flags, char *data)\n{\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(sb);\n\tstruct btrfs_root *root = fs_info->tree_root;\n\tunsigned old_flags = sb->s_flags;\n\tunsigned long old_opts = fs_info->mount_opt;\n\tunsigned long old_compress_type = fs_info->compress_type;\n\tu64 old_max_inline = fs_info->max_inline;\n\tu64 old_alloc_start = fs_info->alloc_start;\n\tint old_thread_pool_size = fs_info->thread_pool_size;\n\tunsigned int old_metadata_ratio = fs_info->metadata_ratio;\n\tint ret;\n\n\tsync_filesystem(sb);\n\tbtrfs_remount_prepare(fs_info);\n\n\tif (data) {\n\t\tstruct security_mnt_opts new_sec_opts;\n\n\t\tsecurity_init_mnt_opts(&new_sec_opts);\n\t\tret = parse_security_options(data, &new_sec_opts);\n\t\tif (ret)\n\t\t\tgoto restore;\n\t\tret = setup_security_options(fs_info, sb,\n\t\t\t\t\t     &new_sec_opts);\n\t\tif (ret) {\n\t\t\tsecurity_free_mnt_opts(&new_sec_opts);\n\t\t\tgoto restore;\n\t\t}\n\t}\n\n\tret = btrfs_parse_options(root, data);\n\tif (ret) {\n\t\tret = -EINVAL;\n\t\tgoto restore;\n\t}\n\n\tbtrfs_remount_begin(fs_info, old_opts, *flags);\n\tbtrfs_resize_thread_pool(fs_info,\n\t\tfs_info->thread_pool_size, old_thread_pool_size);\n\n\tif ((*flags & MS_RDONLY) == (sb->s_flags & MS_RDONLY))\n\t\tgoto out;\n\n\tif (*flags & MS_RDONLY) {\n\t\t/*\n\t\t * this also happens on 'umount -rf' or on shutdown, when\n\t\t * the filesystem is busy.\n\t\t */\n\t\tcancel_work_sync(&fs_info->async_reclaim_work);\n\n\t\t/* wait for the uuid_scan task to finish */\n\t\tdown(&fs_info->uuid_tree_rescan_sem);\n\t\t/* avoid complains from lockdep et al. */\n\t\tup(&fs_info->uuid_tree_rescan_sem);\n\n\t\tsb->s_flags |= MS_RDONLY;\n\n\t\tbtrfs_dev_replace_suspend_for_unmount(fs_info);\n\t\tbtrfs_scrub_cancel(fs_info);\n\t\tbtrfs_pause_balance(fs_info);\n\n\t\tret = btrfs_commit_super(root);\n\t\tif (ret)\n\t\t\tgoto restore;\n\t} else {\n\t\tif (test_bit(BTRFS_FS_STATE_ERROR, &root->fs_info->fs_state)) {\n\t\t\tbtrfs_err(fs_info,\n\t\t\t\t\"Remounting read-write after error is not allowed\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto restore;\n\t\t}\n\t\tif (fs_info->fs_devices->rw_devices == 0) {\n\t\t\tret = -EACCES;\n\t\t\tgoto restore;\n\t\t}\n\n\t\tif (fs_info->fs_devices->missing_devices >\n\t\t     fs_info->num_tolerated_disk_barrier_failures &&\n\t\t    !(*flags & MS_RDONLY)) {\n\t\t\tbtrfs_warn(fs_info,\n\t\t\t\t\"too many missing devices, writeable remount is not allowed\");\n\t\t\tret = -EACCES;\n\t\t\tgoto restore;\n\t\t}\n\n\t\tif (btrfs_super_log_root(fs_info->super_copy) != 0) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto restore;\n\t\t}\n\n\t\tret = btrfs_cleanup_fs_roots(fs_info);\n\t\tif (ret)\n\t\t\tgoto restore;\n\n\t\t/* recover relocation */\n\t\tmutex_lock(&fs_info->cleaner_mutex);\n\t\tret = btrfs_recover_relocation(root);\n\t\tmutex_unlock(&fs_info->cleaner_mutex);\n\t\tif (ret)\n\t\t\tgoto restore;\n\n\t\tret = btrfs_resume_balance_async(fs_info);\n\t\tif (ret)\n\t\t\tgoto restore;\n\n\t\tret = btrfs_resume_dev_replace_async(fs_info);\n\t\tif (ret) {\n\t\t\tbtrfs_warn(fs_info, \"failed to resume dev_replace\");\n\t\t\tgoto restore;\n\t\t}\n\n\t\tif (!fs_info->uuid_root) {\n\t\t\tbtrfs_info(fs_info, \"creating UUID tree\");\n\t\t\tret = btrfs_create_uuid_tree(fs_info);\n\t\t\tif (ret) {\n\t\t\t\tbtrfs_warn(fs_info, \"failed to create the UUID tree %d\", ret);\n\t\t\t\tgoto restore;\n\t\t\t}\n\t\t}\n\t\tsb->s_flags &= ~MS_RDONLY;\n\t}\nout:\n\twake_up_process(fs_info->transaction_kthread);\n\tbtrfs_remount_cleanup(fs_info, old_opts);\n\treturn 0;\n\nrestore:\n\t/* We've hit an error - don't reset MS_RDONLY */\n\tif (sb->s_flags & MS_RDONLY)\n\t\told_flags |= MS_RDONLY;\n\tsb->s_flags = old_flags;\n\tfs_info->mount_opt = old_opts;\n\tfs_info->compress_type = old_compress_type;\n\tfs_info->max_inline = old_max_inline;\n\tmutex_lock(&fs_info->chunk_mutex);\n\tfs_info->alloc_start = old_alloc_start;\n\tmutex_unlock(&fs_info->chunk_mutex);\n\tbtrfs_resize_thread_pool(fs_info,\n\t\told_thread_pool_size, fs_info->thread_pool_size);\n\tfs_info->metadata_ratio = old_metadata_ratio;\n\tbtrfs_remount_cleanup(fs_info, old_opts);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "mnt"
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "newargs"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "mnt"
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_kern_mount",
          "args": [
            "&btrfs_fs_type",
            "flags | MS_RDONLY",
            "device_name",
            "newargs"
          ],
          "line": 1201
        },
        "resolved": true,
        "details": {
          "function_name": "vfs_kern_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "921-952",
          "snippet": "struct vfsmount *\nvfs_kern_mount(struct file_system_type *type, int flags, const char *name, void *data)\n{\n\tstruct mount *mnt;\n\tstruct dentry *root;\n\n\tif (!type)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tmnt = alloc_vfsmnt(name);\n\tif (!mnt)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (flags & MS_KERNMOUNT)\n\t\tmnt->mnt.mnt_flags = MNT_INTERNAL;\n\n\troot = mount_fs(type, flags, name, data);\n\tif (IS_ERR(root)) {\n\t\tmnt_free_id(mnt);\n\t\tfree_vfsmnt(mnt);\n\t\treturn ERR_CAST(root);\n\t}\n\n\tmnt->mnt.mnt_root = root;\n\tmnt->mnt.mnt_sb = root->d_sb;\n\tmnt->mnt_mountpoint = mnt->mnt.mnt_root;\n\tmnt->mnt_parent = mnt;\n\tlock_mount_hash();\n\tlist_add_tail(&mnt->mnt_instance, &root->d_sb->s_mounts);\n\tunlock_mount_hash();\n\treturn &mnt->mnt;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void shrink_submounts(struct mount *mnt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nstatic void shrink_submounts(struct mount *mnt);\n\nstruct vfsmount *\nvfs_kern_mount(struct file_system_type *type, int flags, const char *name, void *data)\n{\n\tstruct mount *mnt;\n\tstruct dentry *root;\n\n\tif (!type)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tmnt = alloc_vfsmnt(name);\n\tif (!mnt)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (flags & MS_KERNMOUNT)\n\t\tmnt->mnt.mnt_flags = MNT_INTERNAL;\n\n\troot = mount_fs(type, flags, name, data);\n\tif (IS_ERR(root)) {\n\t\tmnt_free_id(mnt);\n\t\tfree_vfsmnt(mnt);\n\t\treturn ERR_CAST(root);\n\t}\n\n\tmnt->mnt.mnt_root = root;\n\tmnt->mnt.mnt_sb = root->d_sb;\n\tmnt->mnt_mountpoint = mnt->mnt.mnt_root;\n\tmnt->mnt_parent = mnt;\n\tlock_mount_hash();\n\tlist_add_tail(&mnt->mnt_instance, &root->d_sb->s_mounts);\n\tunlock_mount_hash();\n\treturn &mnt->mnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_RET",
          "args": [
            "mnt"
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_root_args",
          "args": [
            "data"
          ],
          "line": 1189
        },
        "resolved": true,
        "details": {
          "function_name": "setup_root_args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "1136-1180",
          "snippet": "static char *setup_root_args(char *args)\n{\n\tunsigned len = strlen(args) + 2 + 1;\n\tchar *src, *dst, *buf;\n\n\t/*\n\t * We need the same args as before, but with this substitution:\n\t * s!subvol=[^,]+!subvolid=0!\n\t *\n\t * Since the replacement string is up to 2 bytes longer than the\n\t * original, allocate strlen(args) + 2 + 1 bytes.\n\t */\n\n\tsrc = strstr(args, \"subvol=\");\n\t/* This shouldn't happen, but just in case.. */\n\tif (!src)\n\t\treturn NULL;\n\n\tbuf = dst = kmalloc(len, GFP_NOFS);\n\tif (!buf)\n\t\treturn NULL;\n\n\t/*\n\t * If the subvol= arg is not at the start of the string,\n\t * copy whatever precedes it into buf.\n\t */\n\tif (src != args) {\n\t\t*src++ = '\\0';\n\t\tstrcpy(buf, args);\n\t\tdst += strlen(args);\n\t}\n\n\tstrcpy(dst, \"subvolid=0\");\n\tdst += strlen(\"subvolid=0\");\n\n\t/*\n\t * If there is a \",\" after the original subvol=... string,\n\t * copy that suffix into our buffer.  Otherwise, we're done.\n\t */\n\tsrc = strchr(src, ',');\n\tif (src)\n\t\tstrcpy(dst, src);\n\n\treturn buf;\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nstatic char *setup_root_args(char *args)\n{\n\tunsigned len = strlen(args) + 2 + 1;\n\tchar *src, *dst, *buf;\n\n\t/*\n\t * We need the same args as before, but with this substitution:\n\t * s!subvol=[^,]+!subvolid=0!\n\t *\n\t * Since the replacement string is up to 2 bytes longer than the\n\t * original, allocate strlen(args) + 2 + 1 bytes.\n\t */\n\n\tsrc = strstr(args, \"subvol=\");\n\t/* This shouldn't happen, but just in case.. */\n\tif (!src)\n\t\treturn NULL;\n\n\tbuf = dst = kmalloc(len, GFP_NOFS);\n\tif (!buf)\n\t\treturn NULL;\n\n\t/*\n\t * If the subvol= arg is not at the start of the string,\n\t * copy whatever precedes it into buf.\n\t */\n\tif (src != args) {\n\t\t*src++ = '\\0';\n\t\tstrcpy(buf, args);\n\t\tdst += strlen(args);\n\t}\n\n\tstrcpy(dst, \"subvolid=0\");\n\tdst += strlen(\"subvolid=0\");\n\n\t/*\n\t * If there is a \",\" after the original subvol=... string,\n\t * copy that suffix into our buffer.  Otherwise, we're done.\n\t */\n\tsrc = strchr(src, ',');\n\tif (src)\n\t\tstrcpy(dst, src);\n\n\treturn buf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nstatic struct file_system_type btrfs_fs_type;\nstatic int btrfs_remount(struct super_block *sb, int *flags, char *data);\nstatic struct file_system_type btrfs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"btrfs\",\n\t.mount\t\t= btrfs_mount,\n\t.kill_sb\t= btrfs_kill_super,\n\t.fs_flags\t= FS_REQUIRES_DEV | FS_BINARY_MOUNTDATA,\n};\n\nstatic struct dentry *mount_subvol(const char *subvol_name, int flags,\n\t\t\t\t   const char *device_name, char *data)\n{\n\tstruct dentry *root;\n\tstruct vfsmount *mnt;\n\tchar *newargs;\n\n\tnewargs = setup_root_args(data);\n\tif (!newargs)\n\t\treturn ERR_PTR(-ENOMEM);\n\tmnt = vfs_kern_mount(&btrfs_fs_type, flags, device_name,\n\t\t\t     newargs);\n\n\tif (PTR_RET(mnt) == -EBUSY) {\n\t\tif (flags & MS_RDONLY) {\n\t\t\tmnt = vfs_kern_mount(&btrfs_fs_type, flags & ~MS_RDONLY, device_name,\n\t\t\t\t\t     newargs);\n\t\t} else {\n\t\t\tint r;\n\t\t\tmnt = vfs_kern_mount(&btrfs_fs_type, flags | MS_RDONLY, device_name,\n\t\t\t\t\t     newargs);\n\t\t\tif (IS_ERR(mnt)) {\n\t\t\t\tkfree(newargs);\n\t\t\t\treturn ERR_CAST(mnt);\n\t\t\t}\n\n\t\t\tr = btrfs_remount(mnt->mnt_sb, &flags, NULL);\n\t\t\tif (r < 0) {\n\t\t\t\t/* FIXME: release vfsmount mnt ??*/\n\t\t\t\tkfree(newargs);\n\t\t\t\treturn ERR_PTR(r);\n\t\t\t}\n\t\t}\n\t}\n\n\tkfree(newargs);\n\n\tif (IS_ERR(mnt))\n\t\treturn ERR_CAST(mnt);\n\n\troot = mount_subtree(mnt, subvol_name);\n\n\tif (!IS_ERR(root) && !is_subvolume_inode(root->d_inode)) {\n\t\tstruct super_block *s = root->d_sb;\n\t\tdput(root);\n\t\troot = ERR_PTR(-EINVAL);\n\t\tdeactivate_locked_super(s);\n\t\tprintk(KERN_ERR \"BTRFS: '%s' is not a valid subvolume\\n\",\n\t\t\t\tsubvol_name);\n\t}\n\n\treturn root;\n}"
  },
  {
    "function_name": "setup_root_args",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
    "lines": "1136-1180",
    "snippet": "static char *setup_root_args(char *args)\n{\n\tunsigned len = strlen(args) + 2 + 1;\n\tchar *src, *dst, *buf;\n\n\t/*\n\t * We need the same args as before, but with this substitution:\n\t * s!subvol=[^,]+!subvolid=0!\n\t *\n\t * Since the replacement string is up to 2 bytes longer than the\n\t * original, allocate strlen(args) + 2 + 1 bytes.\n\t */\n\n\tsrc = strstr(args, \"subvol=\");\n\t/* This shouldn't happen, but just in case.. */\n\tif (!src)\n\t\treturn NULL;\n\n\tbuf = dst = kmalloc(len, GFP_NOFS);\n\tif (!buf)\n\t\treturn NULL;\n\n\t/*\n\t * If the subvol= arg is not at the start of the string,\n\t * copy whatever precedes it into buf.\n\t */\n\tif (src != args) {\n\t\t*src++ = '\\0';\n\t\tstrcpy(buf, args);\n\t\tdst += strlen(args);\n\t}\n\n\tstrcpy(dst, \"subvolid=0\");\n\tdst += strlen(\"subvolid=0\");\n\n\t/*\n\t * If there is a \",\" after the original subvol=... string,\n\t * copy that suffix into our buffer.  Otherwise, we're done.\n\t */\n\tsrc = strchr(src, ',');\n\tif (src)\n\t\tstrcpy(dst, src);\n\n\treturn buf;\n}",
    "includes": [
      "#include <trace/events/btrfs.h>",
      "#include \"qgroup.h\"",
      "#include \"tests/btrfs-tests.h\"",
      "#include \"backref.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"compression.h\"",
      "#include \"export.h\"",
      "#include \"volumes.h\"",
      "#include \"xattr.h\"",
      "#include \"props.h\"",
      "#include \"hash.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/namei.h>",
      "#include <linux/ctype.h>",
      "#include <linux/parser.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dst",
            "src"
          ],
          "line": 1177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "src",
            "','"
          ],
          "line": 1175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"subvolid=0\""
          ],
          "line": 1169
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "dst",
            "\"subvolid=0\""
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "buf",
            "args"
          ],
          "line": 1164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "len",
            "GFP_NOFS"
          ],
          "line": 1154
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "args",
            "\"subvol=\""
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nstatic char *setup_root_args(char *args)\n{\n\tunsigned len = strlen(args) + 2 + 1;\n\tchar *src, *dst, *buf;\n\n\t/*\n\t * We need the same args as before, but with this substitution:\n\t * s!subvol=[^,]+!subvolid=0!\n\t *\n\t * Since the replacement string is up to 2 bytes longer than the\n\t * original, allocate strlen(args) + 2 + 1 bytes.\n\t */\n\n\tsrc = strstr(args, \"subvol=\");\n\t/* This shouldn't happen, but just in case.. */\n\tif (!src)\n\t\treturn NULL;\n\n\tbuf = dst = kmalloc(len, GFP_NOFS);\n\tif (!buf)\n\t\treturn NULL;\n\n\t/*\n\t * If the subvol= arg is not at the start of the string,\n\t * copy whatever precedes it into buf.\n\t */\n\tif (src != args) {\n\t\t*src++ = '\\0';\n\t\tstrcpy(buf, args);\n\t\tdst += strlen(args);\n\t}\n\n\tstrcpy(dst, \"subvolid=0\");\n\tdst += strlen(\"subvolid=0\");\n\n\t/*\n\t * If there is a \",\" after the original subvol=... string,\n\t * copy that suffix into our buffer.  Otherwise, we're done.\n\t */\n\tsrc = strchr(src, ',');\n\tif (src)\n\t\tstrcpy(dst, src);\n\n\treturn buf;\n}"
  },
  {
    "function_name": "is_subvolume_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
    "lines": "1124-1129",
    "snippet": "static inline int is_subvolume_inode(struct inode *inode)\n{\n\tif (inode && inode->i_ino == BTRFS_FIRST_FREE_OBJECTID)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/btrfs.h>",
      "#include \"qgroup.h\"",
      "#include \"tests/btrfs-tests.h\"",
      "#include \"backref.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"compression.h\"",
      "#include \"export.h\"",
      "#include \"volumes.h\"",
      "#include \"xattr.h\"",
      "#include \"props.h\"",
      "#include \"hash.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/namei.h>",
      "#include <linux/ctype.h>",
      "#include <linux/parser.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nstatic inline int is_subvolume_inode(struct inode *inode)\n{\n\tif (inode && inode->i_ino == BTRFS_FIRST_FREE_OBJECTID)\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_set_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
    "lines": "1113-1119",
    "snippet": "static int btrfs_set_super(struct super_block *s, void *data)\n{\n\tint err = set_anon_super(s, data);\n\tif (!err)\n\t\ts->s_fs_info = data;\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/btrfs.h>",
      "#include \"qgroup.h\"",
      "#include \"tests/btrfs-tests.h\"",
      "#include \"backref.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"compression.h\"",
      "#include \"export.h\"",
      "#include \"volumes.h\"",
      "#include \"xattr.h\"",
      "#include \"props.h\"",
      "#include \"hash.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/namei.h>",
      "#include <linux/ctype.h>",
      "#include <linux/parser.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btrfs_remount(struct super_block *sb, int *flags, char *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_anon_super",
          "args": [
            "s",
            "data"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nstatic int btrfs_remount(struct super_block *sb, int *flags, char *data);\n\nstatic int btrfs_set_super(struct super_block *s, void *data)\n{\n\tint err = set_anon_super(s, data);\n\tif (!err)\n\t\ts->s_fs_info = data;\n\treturn err;\n}"
  },
  {
    "function_name": "btrfs_test_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
    "lines": "1105-1111",
    "snippet": "static int btrfs_test_super(struct super_block *s, void *data)\n{\n\tstruct btrfs_fs_info *p = data;\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(s);\n\n\treturn fs_info->fs_devices == p->fs_devices;\n}",
    "includes": [
      "#include <trace/events/btrfs.h>",
      "#include \"qgroup.h\"",
      "#include \"tests/btrfs-tests.h\"",
      "#include \"backref.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"compression.h\"",
      "#include \"export.h\"",
      "#include \"volumes.h\"",
      "#include \"xattr.h\"",
      "#include \"props.h\"",
      "#include \"hash.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/namei.h>",
      "#include <linux/ctype.h>",
      "#include <linux/parser.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btrfs_remount(struct super_block *sb, int *flags, char *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_sb",
          "args": [
            "s"
          ],
          "line": 1108
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3272-3275",
          "snippet": "static inline struct btrfs_fs_info *btrfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline struct btrfs_fs_info *btrfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nstatic int btrfs_remount(struct super_block *sb, int *flags, char *data);\n\nstatic int btrfs_test_super(struct super_block *s, void *data)\n{\n\tstruct btrfs_fs_info *p = data;\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(s);\n\n\treturn fs_info->fs_devices == p->fs_devices;\n}"
  },
  {
    "function_name": "btrfs_show_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
    "lines": "1021-1103",
    "snippet": "static int btrfs_show_options(struct seq_file *seq, struct dentry *dentry)\n{\n\tstruct btrfs_fs_info *info = btrfs_sb(dentry->d_sb);\n\tstruct btrfs_root *root = info->tree_root;\n\tchar *compress_type;\n\n\tif (btrfs_test_opt(root, DEGRADED))\n\t\tseq_puts(seq, \",degraded\");\n\tif (btrfs_test_opt(root, NODATASUM))\n\t\tseq_puts(seq, \",nodatasum\");\n\tif (btrfs_test_opt(root, NODATACOW))\n\t\tseq_puts(seq, \",nodatacow\");\n\tif (btrfs_test_opt(root, NOBARRIER))\n\t\tseq_puts(seq, \",nobarrier\");\n\tif (info->max_inline != BTRFS_DEFAULT_MAX_INLINE)\n\t\tseq_printf(seq, \",max_inline=%llu\", info->max_inline);\n\tif (info->alloc_start != 0)\n\t\tseq_printf(seq, \",alloc_start=%llu\", info->alloc_start);\n\tif (info->thread_pool_size !=  min_t(unsigned long,\n\t\t\t\t\t     num_online_cpus() + 2, 8))\n\t\tseq_printf(seq, \",thread_pool=%d\", info->thread_pool_size);\n\tif (btrfs_test_opt(root, COMPRESS)) {\n\t\tif (info->compress_type == BTRFS_COMPRESS_ZLIB)\n\t\t\tcompress_type = \"zlib\";\n\t\telse\n\t\t\tcompress_type = \"lzo\";\n\t\tif (btrfs_test_opt(root, FORCE_COMPRESS))\n\t\t\tseq_printf(seq, \",compress-force=%s\", compress_type);\n\t\telse\n\t\t\tseq_printf(seq, \",compress=%s\", compress_type);\n\t}\n\tif (btrfs_test_opt(root, NOSSD))\n\t\tseq_puts(seq, \",nossd\");\n\tif (btrfs_test_opt(root, SSD_SPREAD))\n\t\tseq_puts(seq, \",ssd_spread\");\n\telse if (btrfs_test_opt(root, SSD))\n\t\tseq_puts(seq, \",ssd\");\n\tif (btrfs_test_opt(root, NOTREELOG))\n\t\tseq_puts(seq, \",notreelog\");\n\tif (btrfs_test_opt(root, FLUSHONCOMMIT))\n\t\tseq_puts(seq, \",flushoncommit\");\n\tif (btrfs_test_opt(root, DISCARD))\n\t\tseq_puts(seq, \",discard\");\n\tif (!(root->fs_info->sb->s_flags & MS_POSIXACL))\n\t\tseq_puts(seq, \",noacl\");\n\tif (btrfs_test_opt(root, SPACE_CACHE))\n\t\tseq_puts(seq, \",space_cache\");\n\telse\n\t\tseq_puts(seq, \",nospace_cache\");\n\tif (btrfs_test_opt(root, RESCAN_UUID_TREE))\n\t\tseq_puts(seq, \",rescan_uuid_tree\");\n\tif (btrfs_test_opt(root, CLEAR_CACHE))\n\t\tseq_puts(seq, \",clear_cache\");\n\tif (btrfs_test_opt(root, USER_SUBVOL_RM_ALLOWED))\n\t\tseq_puts(seq, \",user_subvol_rm_allowed\");\n\tif (btrfs_test_opt(root, ENOSPC_DEBUG))\n\t\tseq_puts(seq, \",enospc_debug\");\n\tif (btrfs_test_opt(root, AUTO_DEFRAG))\n\t\tseq_puts(seq, \",autodefrag\");\n\tif (btrfs_test_opt(root, INODE_MAP_CACHE))\n\t\tseq_puts(seq, \",inode_cache\");\n\tif (btrfs_test_opt(root, SKIP_BALANCE))\n\t\tseq_puts(seq, \",skip_balance\");\n\tif (btrfs_test_opt(root, RECOVERY))\n\t\tseq_puts(seq, \",recovery\");\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_test_opt(root, CHECK_INTEGRITY_INCLUDING_EXTENT_DATA))\n\t\tseq_puts(seq, \",check_int_data\");\n\telse if (btrfs_test_opt(root, CHECK_INTEGRITY))\n\t\tseq_puts(seq, \",check_int\");\n\tif (info->check_integrity_print_mask)\n\t\tseq_printf(seq, \",check_int_print_mask=%d\",\n\t\t\t\tinfo->check_integrity_print_mask);\n#endif\n\tif (info->metadata_ratio)\n\t\tseq_printf(seq, \",metadata_ratio=%d\",\n\t\t\t\tinfo->metadata_ratio);\n\tif (btrfs_test_opt(root, PANIC_ON_FATAL_ERROR))\n\t\tseq_puts(seq, \",fatal_errors=panic\");\n\tif (info->commit_interval != BTRFS_DEFAULT_COMMIT_INTERVAL)\n\t\tseq_printf(seq, \",commit=%d\", info->commit_interval);\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/btrfs.h>",
      "#include \"qgroup.h\"",
      "#include \"tests/btrfs-tests.h\"",
      "#include \"backref.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"compression.h\"",
      "#include \"export.h\"",
      "#include \"volumes.h\"",
      "#include \"xattr.h\"",
      "#include \"props.h\"",
      "#include \"hash.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/namei.h>",
      "#include <linux/ctype.h>",
      "#include <linux/parser.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "seq",
            "\",commit=%d\"",
            "info->commit_interval"
          ],
          "line": 1101
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "seq",
            "\",fatal_errors=panic\""
          ],
          "line": 1099
        },
        "resolved": true,
        "details": {
          "function_name": "seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "658-668",
          "snippet": "int seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_puts(struct seq_file *m, const char *s)\n{\n\tint len = strlen(s);\n\tif (m->count + len < m->size) {\n\t\tmemcpy(m->buf + m->count, s, len);\n\t\tm->count += len;\n\t\treturn 0;\n\t}\n\tseq_set_overflow(m);\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_test_opt",
          "args": [
            "root",
            "PANIC_ON_FATAL_ERROR"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_test_opt",
          "args": [
            "root",
            "CHECK_INTEGRITY"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_test_opt",
          "args": [
            "root",
            "CHECK_INTEGRITY_INCLUDING_EXTENT_DATA"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_test_opt",
          "args": [
            "root",
            "RECOVERY"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_test_opt",
          "args": [
            "root",
            "SKIP_BALANCE"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_test_opt",
          "args": [
            "root",
            "INODE_MAP_CACHE"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_test_opt",
          "args": [
            "root",
            "AUTO_DEFRAG"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_test_opt",
          "args": [
            "root",
            "ENOSPC_DEBUG"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_test_opt",
          "args": [
            "root",
            "USER_SUBVOL_RM_ALLOWED"
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_test_opt",
          "args": [
            "root",
            "CLEAR_CACHE"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_test_opt",
          "args": [
            "root",
            "RESCAN_UUID_TREE"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_test_opt",
          "args": [
            "root",
            "SPACE_CACHE"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_test_opt",
          "args": [
            "root",
            "DISCARD"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_test_opt",
          "args": [
            "root",
            "FLUSHONCOMMIT"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_test_opt",
          "args": [
            "root",
            "NOTREELOG"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_test_opt",
          "args": [
            "root",
            "SSD"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_test_opt",
          "args": [
            "root",
            "SSD_SPREAD"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_test_opt",
          "args": [
            "root",
            "NOSSD"
          ],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_test_opt",
          "args": [
            "root",
            "FORCE_COMPRESS"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_test_opt",
          "args": [
            "root",
            "COMPRESS"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "unsignedlong",
            "num_online_cpus() + 2",
            "8"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_online_cpus",
          "args": [],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_test_opt",
          "args": [
            "root",
            "NOBARRIER"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_test_opt",
          "args": [
            "root",
            "NODATACOW"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_test_opt",
          "args": [
            "root",
            "NODATASUM"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_test_opt",
          "args": [
            "root",
            "DEGRADED"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_sb",
          "args": [
            "dentry->d_sb"
          ],
          "line": 1023
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3272-3275",
          "snippet": "static inline struct btrfs_fs_info *btrfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline struct btrfs_fs_info *btrfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nstatic int btrfs_show_options(struct seq_file *seq, struct dentry *dentry)\n{\n\tstruct btrfs_fs_info *info = btrfs_sb(dentry->d_sb);\n\tstruct btrfs_root *root = info->tree_root;\n\tchar *compress_type;\n\n\tif (btrfs_test_opt(root, DEGRADED))\n\t\tseq_puts(seq, \",degraded\");\n\tif (btrfs_test_opt(root, NODATASUM))\n\t\tseq_puts(seq, \",nodatasum\");\n\tif (btrfs_test_opt(root, NODATACOW))\n\t\tseq_puts(seq, \",nodatacow\");\n\tif (btrfs_test_opt(root, NOBARRIER))\n\t\tseq_puts(seq, \",nobarrier\");\n\tif (info->max_inline != BTRFS_DEFAULT_MAX_INLINE)\n\t\tseq_printf(seq, \",max_inline=%llu\", info->max_inline);\n\tif (info->alloc_start != 0)\n\t\tseq_printf(seq, \",alloc_start=%llu\", info->alloc_start);\n\tif (info->thread_pool_size !=  min_t(unsigned long,\n\t\t\t\t\t     num_online_cpus() + 2, 8))\n\t\tseq_printf(seq, \",thread_pool=%d\", info->thread_pool_size);\n\tif (btrfs_test_opt(root, COMPRESS)) {\n\t\tif (info->compress_type == BTRFS_COMPRESS_ZLIB)\n\t\t\tcompress_type = \"zlib\";\n\t\telse\n\t\t\tcompress_type = \"lzo\";\n\t\tif (btrfs_test_opt(root, FORCE_COMPRESS))\n\t\t\tseq_printf(seq, \",compress-force=%s\", compress_type);\n\t\telse\n\t\t\tseq_printf(seq, \",compress=%s\", compress_type);\n\t}\n\tif (btrfs_test_opt(root, NOSSD))\n\t\tseq_puts(seq, \",nossd\");\n\tif (btrfs_test_opt(root, SSD_SPREAD))\n\t\tseq_puts(seq, \",ssd_spread\");\n\telse if (btrfs_test_opt(root, SSD))\n\t\tseq_puts(seq, \",ssd\");\n\tif (btrfs_test_opt(root, NOTREELOG))\n\t\tseq_puts(seq, \",notreelog\");\n\tif (btrfs_test_opt(root, FLUSHONCOMMIT))\n\t\tseq_puts(seq, \",flushoncommit\");\n\tif (btrfs_test_opt(root, DISCARD))\n\t\tseq_puts(seq, \",discard\");\n\tif (!(root->fs_info->sb->s_flags & MS_POSIXACL))\n\t\tseq_puts(seq, \",noacl\");\n\tif (btrfs_test_opt(root, SPACE_CACHE))\n\t\tseq_puts(seq, \",space_cache\");\n\telse\n\t\tseq_puts(seq, \",nospace_cache\");\n\tif (btrfs_test_opt(root, RESCAN_UUID_TREE))\n\t\tseq_puts(seq, \",rescan_uuid_tree\");\n\tif (btrfs_test_opt(root, CLEAR_CACHE))\n\t\tseq_puts(seq, \",clear_cache\");\n\tif (btrfs_test_opt(root, USER_SUBVOL_RM_ALLOWED))\n\t\tseq_puts(seq, \",user_subvol_rm_allowed\");\n\tif (btrfs_test_opt(root, ENOSPC_DEBUG))\n\t\tseq_puts(seq, \",enospc_debug\");\n\tif (btrfs_test_opt(root, AUTO_DEFRAG))\n\t\tseq_puts(seq, \",autodefrag\");\n\tif (btrfs_test_opt(root, INODE_MAP_CACHE))\n\t\tseq_puts(seq, \",inode_cache\");\n\tif (btrfs_test_opt(root, SKIP_BALANCE))\n\t\tseq_puts(seq, \",skip_balance\");\n\tif (btrfs_test_opt(root, RECOVERY))\n\t\tseq_puts(seq, \",recovery\");\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_test_opt(root, CHECK_INTEGRITY_INCLUDING_EXTENT_DATA))\n\t\tseq_puts(seq, \",check_int_data\");\n\telse if (btrfs_test_opt(root, CHECK_INTEGRITY))\n\t\tseq_puts(seq, \",check_int\");\n\tif (info->check_integrity_print_mask)\n\t\tseq_printf(seq, \",check_int_print_mask=%d\",\n\t\t\t\tinfo->check_integrity_print_mask);\n#endif\n\tif (info->metadata_ratio)\n\t\tseq_printf(seq, \",metadata_ratio=%d\",\n\t\t\t\tinfo->metadata_ratio);\n\tif (btrfs_test_opt(root, PANIC_ON_FATAL_ERROR))\n\t\tseq_puts(seq, \",fatal_errors=panic\");\n\tif (info->commit_interval != BTRFS_DEFAULT_COMMIT_INTERVAL)\n\t\tseq_printf(seq, \",commit=%d\", info->commit_interval);\n\treturn 0;\n}"
  },
  {
    "function_name": "btrfs_sync_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
    "lines": "978-1019",
    "snippet": "int btrfs_sync_fs(struct super_block *sb, int wait)\n{\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(sb);\n\tstruct btrfs_root *root = fs_info->tree_root;\n\n\ttrace_btrfs_sync_fs(wait);\n\n\tif (!wait) {\n\t\tfilemap_flush(fs_info->btree_inode->i_mapping);\n\t\treturn 0;\n\t}\n\n\tbtrfs_wait_ordered_roots(fs_info, -1);\n\n\ttrans = btrfs_attach_transaction_barrier(root);\n\tif (IS_ERR(trans)) {\n\t\t/* no transaction, don't bother */\n\t\tif (PTR_ERR(trans) == -ENOENT) {\n\t\t\t/*\n\t\t\t * Exit unless we have some pending changes\n\t\t\t * that need to go through commit\n\t\t\t */\n\t\t\tif (fs_info->pending_changes == 0)\n\t\t\t\treturn 0;\n\t\t\t/*\n\t\t\t * A non-blocking test if the fs is frozen. We must not\n\t\t\t * start a new transaction here otherwise a deadlock\n\t\t\t * happens. The pending operations are delayed to the\n\t\t\t * next commit after thawing.\n\t\t\t */\n\t\t\tif (__sb_start_write(sb, SB_FREEZE_WRITE, false))\n\t\t\t\t__sb_end_write(sb, SB_FREEZE_WRITE);\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t\ttrans = btrfs_start_transaction(root, 0);\n\t\t}\n\t\tif (IS_ERR(trans))\n\t\t\treturn PTR_ERR(trans);\n\t}\n\treturn btrfs_commit_transaction(trans, root);\n}",
    "includes": [
      "#include <trace/events/btrfs.h>",
      "#include \"qgroup.h\"",
      "#include \"tests/btrfs-tests.h\"",
      "#include \"backref.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"compression.h\"",
      "#include \"export.h\"",
      "#include \"volumes.h\"",
      "#include \"xattr.h\"",
      "#include \"props.h\"",
      "#include \"hash.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/namei.h>",
      "#include <linux/ctype.h>",
      "#include <linux/parser.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_commit_transaction",
          "args": [
            "trans",
            "root"
          ],
          "line": 1018
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_commit_transaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "1764-2099",
          "snippet": "int btrfs_commit_transaction(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tint ret;\n\n\t/* Stop the commit early if ->aborted is set */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\t/* make a pass through all the delayed refs we have so far\n\t * any runnings procs may add more while we are here\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tcur_trans = trans->transaction;\n\n\t/*\n\t * set the flushing flag so procs in this transaction have to\n\t * start sending their work down.\n\t */\n\tcur_trans->delayed_refs.flushing = 1;\n\tsmp_wmb();\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tret = btrfs_end_transaction(trans, root);\n\n\t\twait_for_commit(root, cur_trans);\n\n\t\tif (unlikely(cur_trans->aborted))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tif (cur_trans->list.prev != &root->fs_info->trans_list) {\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state != TRANS_STATE_COMPLETED) {\n\t\t\tatomic_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t\twait_for_commit(root, prev_trans);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(root->fs_info);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t/* some pending stuffs might be added after the previous flush. */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tbtrfs_wait_delalloc_flush(root->fs_info);\n\n\tbtrfs_wait_pending_ordered(cur_trans, root->fs_info);\n\n\tbtrfs_scrub_pause(root);\n\t/*\n\t * Ok now we need to make sure to block out any other joins while we\n\t * commit the transaction.  We could have started a join before setting\n\t * COMMIT_DOING so make sure to wait for num_writers to == 1 again.\n\t */\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&root->fs_info->trans_lock);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t/* ->aborted might be set after the previous check, so check it */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tgoto scrub_continue;\n\t}\n\t/*\n\t * the reloc mutex makes sure that we stop\n\t * the balancing code from coming in and moving\n\t * extents around in the middle of the commit\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\n\t/*\n\t * We needn't worry about the delayed items because we will\n\t * deal with them in create_pending_snapshot(), which is the\n\t * core function of the snapshot creation.\n\t */\n\tret = create_pending_snapshots(trans, root->fs_info);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * We insert the dir indexes of the snapshots and update the inode\n\t * of the snapshots' parents after the snapshot creation, so there\n\t * are some delayed items which are not dealt with. Now deal with\n\t * them.\n\t *\n\t * We needn't worry that this operation will corrupt the snapshots,\n\t * because all the tree which are snapshoted will be forced to COW\n\t * the nodes and leaves.\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * make sure none of the code above managed to slip in a\n\t * delayed item\n\t */\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\t/* btrfs_commit_tree_roots is responsible for getting the\n\t * various roots consistent with each other.  Every pointer\n\t * in the tree of tree roots has to point to the most up to date\n\t * root for every subvolume and other tree.  So, we have to keep\n\t * the tree logging code from jumping in and changing any\n\t * of the trees.\n\t *\n\t * At this point in the commit, there can't be any tree-log\n\t * writers, but a little lower down we drop the trans mutex\n\t * and let new people in.  By holding the tree_log_mutex\n\t * from now until after the super is written, we avoid races\n\t * with the tree-log code.\n\t */\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * Since the transaction is done, we can apply the pending changes\n\t * before the next transaction.\n\t */\n\tbtrfs_apply_pending_changes(root->fs_info);\n\n\t/* commit_fs_roots gets rid of all the tree log roots, it is now\n\t * safe to free the root of tree log roots\n\t */\n\tbtrfs_free_log_root_tree(trans, root->fs_info);\n\n\tret = commit_cowonly_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * The tasks which save the space cache and inode cache may also\n\t * update ->aborted, check it.\n\t */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tbtrfs_prepare_extent_commit(trans, root);\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&root->fs_info->tree_root->root_item,\n\t\t\t    root->fs_info->tree_root->node);\n\tlist_add_tail(&root->fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&root->fs_info->chunk_root->root_item,\n\t\t\t    root->fs_info->chunk_root->node);\n\tlist_add_tail(&root->fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tswitch_commit_roots(cur_trans, root->fs_info);\n\n\tassert_qgroups_uptodate(trans);\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tupdate_super_roots(root);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_copy, 0);\n\tmemcpy(root->fs_info->super_for_commit, root->fs_info->super_copy,\n\t       sizeof(*root->fs_info->super_copy));\n\n\tbtrfs_update_commit_device_size(root->fs_info);\n\tbtrfs_update_commit_device_bytes_used(root, cur_trans);\n\n\tclear_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\tclear_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twake_up(&root->fs_info->transaction_wait);\n\n\tret = btrfs_write_and_wait_transaction(trans, root);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Error while writing out transaction\");\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = write_ctree_super(trans, root, 0);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * the super is written, we can safely allow the tree-loggers\n\t * to go about their business\n\t */\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\n\tbtrfs_finish_extent_commit(trans, root);\n\n\tif (cur_trans->have_free_bgs)\n\t\tbtrfs_clear_space_info_full(root->fs_info);\n\n\troot->fs_info->last_trans_committed = cur_trans->transid;\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tbtrfs_scrub_continue(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\tif (current != root->fs_info->transaction_kthread)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\treturn ret;\n\nscrub_continue:\n\tbtrfs_scrub_continue(root);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\tbtrfs_warn(root->fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, root, ret);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint btrfs_commit_transaction(struct btrfs_trans_handle *trans,\n\t\t\t     struct btrfs_root *root)\n{\n\tstruct btrfs_transaction *cur_trans = trans->transaction;\n\tstruct btrfs_transaction *prev_trans = NULL;\n\tstruct btrfs_inode *btree_ino = BTRFS_I(root->fs_info->btree_inode);\n\tint ret;\n\n\t/* Stop the commit early if ->aborted is set */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\t/* make a pass through all the delayed refs we have so far\n\t * any runnings procs may add more while we are here\n\t */\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\n\tcur_trans = trans->transaction;\n\n\t/*\n\t * set the flushing flag so procs in this transaction have to\n\t * start sending their work down.\n\t */\n\tcur_trans->delayed_refs.flushing = 1;\n\tsmp_wmb();\n\n\tif (!list_empty(&trans->new_bgs))\n\t\tbtrfs_create_pending_block_groups(trans, root);\n\n\tret = btrfs_run_delayed_refs(trans, root, 0);\n\tif (ret) {\n\t\tbtrfs_end_transaction(trans, root);\n\t\treturn ret;\n\t}\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_splice(&trans->ordered, &cur_trans->pending_ordered);\n\tif (cur_trans->state >= TRANS_STATE_COMMIT_START) {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\tatomic_inc(&cur_trans->use_count);\n\t\tret = btrfs_end_transaction(trans, root);\n\n\t\twait_for_commit(root, cur_trans);\n\n\t\tif (unlikely(cur_trans->aborted))\n\t\t\tret = cur_trans->aborted;\n\n\t\tbtrfs_put_transaction(cur_trans);\n\n\t\treturn ret;\n\t}\n\n\tcur_trans->state = TRANS_STATE_COMMIT_START;\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\n\tif (cur_trans->list.prev != &root->fs_info->trans_list) {\n\t\tprev_trans = list_entry(cur_trans->list.prev,\n\t\t\t\t\tstruct btrfs_transaction, list);\n\t\tif (prev_trans->state != TRANS_STATE_COMPLETED) {\n\t\t\tatomic_inc(&prev_trans->use_count);\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\n\t\t\twait_for_commit(root, prev_trans);\n\n\t\t\tbtrfs_put_transaction(prev_trans);\n\t\t} else {\n\t\t\tspin_unlock(&root->fs_info->trans_lock);\n\t\t}\n\t} else {\n\t\tspin_unlock(&root->fs_info->trans_lock);\n\t}\n\n\textwriter_counter_dec(cur_trans, trans->type);\n\n\tret = btrfs_start_delalloc_flush(root->fs_info);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\twait_event(cur_trans->writer_wait,\n\t\t   extwriter_counter_read(cur_trans) == 0);\n\n\t/* some pending stuffs might be added after the previous flush. */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret)\n\t\tgoto cleanup_transaction;\n\n\tbtrfs_wait_delalloc_flush(root->fs_info);\n\n\tbtrfs_wait_pending_ordered(cur_trans, root->fs_info);\n\n\tbtrfs_scrub_pause(root);\n\t/*\n\t * Ok now we need to make sure to block out any other joins while we\n\t * commit the transaction.  We could have started a join before setting\n\t * COMMIT_DOING so make sure to wait for num_writers to == 1 again.\n\t */\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_COMMIT_DOING;\n\tspin_unlock(&root->fs_info->trans_lock);\n\twait_event(cur_trans->writer_wait,\n\t\t   atomic_read(&cur_trans->num_writers) == 1);\n\n\t/* ->aborted might be set after the previous check, so check it */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tgoto scrub_continue;\n\t}\n\t/*\n\t * the reloc mutex makes sure that we stop\n\t * the balancing code from coming in and moving\n\t * extents around in the middle of the commit\n\t */\n\tmutex_lock(&root->fs_info->reloc_mutex);\n\n\t/*\n\t * We needn't worry about the delayed items because we will\n\t * deal with them in create_pending_snapshot(), which is the\n\t * core function of the snapshot creation.\n\t */\n\tret = create_pending_snapshots(trans, root->fs_info);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * We insert the dir indexes of the snapshots and update the inode\n\t * of the snapshots' parents after the snapshot creation, so there\n\t * are some delayed items which are not dealt with. Now deal with\n\t * them.\n\t *\n\t * We needn't worry that this operation will corrupt the snapshots,\n\t * because all the tree which are snapshoted will be forced to COW\n\t * the nodes and leaves.\n\t */\n\tret = btrfs_run_delayed_items(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = btrfs_run_delayed_refs(trans, root, (unsigned long)-1);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * make sure none of the code above managed to slip in a\n\t * delayed item\n\t */\n\tbtrfs_assert_delayed_root_empty(root);\n\n\tWARN_ON(cur_trans != trans->transaction);\n\n\t/* btrfs_commit_tree_roots is responsible for getting the\n\t * various roots consistent with each other.  Every pointer\n\t * in the tree of tree roots has to point to the most up to date\n\t * root for every subvolume and other tree.  So, we have to keep\n\t * the tree logging code from jumping in and changing any\n\t * of the trees.\n\t *\n\t * At this point in the commit, there can't be any tree-log\n\t * writers, but a little lower down we drop the trans mutex\n\t * and let new people in.  By holding the tree_log_mutex\n\t * from now until after the super is written, we avoid races\n\t * with the tree-log code.\n\t */\n\tmutex_lock(&root->fs_info->tree_log_mutex);\n\n\tret = commit_fs_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * Since the transaction is done, we can apply the pending changes\n\t * before the next transaction.\n\t */\n\tbtrfs_apply_pending_changes(root->fs_info);\n\n\t/* commit_fs_roots gets rid of all the tree log roots, it is now\n\t * safe to free the root of tree log roots\n\t */\n\tbtrfs_free_log_root_tree(trans, root->fs_info);\n\n\tret = commit_cowonly_roots(trans, root);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * The tasks which save the space cache and inode cache may also\n\t * update ->aborted, check it.\n\t */\n\tif (unlikely(ACCESS_ONCE(cur_trans->aborted))) {\n\t\tret = cur_trans->aborted;\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tmutex_unlock(&root->fs_info->reloc_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tbtrfs_prepare_extent_commit(trans, root);\n\n\tcur_trans = root->fs_info->running_transaction;\n\n\tbtrfs_set_root_node(&root->fs_info->tree_root->root_item,\n\t\t\t    root->fs_info->tree_root->node);\n\tlist_add_tail(&root->fs_info->tree_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tbtrfs_set_root_node(&root->fs_info->chunk_root->root_item,\n\t\t\t    root->fs_info->chunk_root->node);\n\tlist_add_tail(&root->fs_info->chunk_root->dirty_list,\n\t\t      &cur_trans->switch_commits);\n\n\tswitch_commit_roots(cur_trans, root->fs_info);\n\n\tassert_qgroups_uptodate(trans);\n\tASSERT(list_empty(&cur_trans->dirty_bgs));\n\tupdate_super_roots(root);\n\n\tbtrfs_set_super_log_root(root->fs_info->super_copy, 0);\n\tbtrfs_set_super_log_root_level(root->fs_info->super_copy, 0);\n\tmemcpy(root->fs_info->super_for_commit, root->fs_info->super_copy,\n\t       sizeof(*root->fs_info->super_copy));\n\n\tbtrfs_update_commit_device_size(root->fs_info);\n\tbtrfs_update_commit_device_bytes_used(root, cur_trans);\n\n\tclear_bit(BTRFS_INODE_BTREE_LOG1_ERR, &btree_ino->runtime_flags);\n\tclear_bit(BTRFS_INODE_BTREE_LOG2_ERR, &btree_ino->runtime_flags);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tcur_trans->state = TRANS_STATE_UNBLOCKED;\n\troot->fs_info->running_transaction = NULL;\n\tspin_unlock(&root->fs_info->trans_lock);\n\tmutex_unlock(&root->fs_info->reloc_mutex);\n\n\twake_up(&root->fs_info->transaction_wait);\n\n\tret = btrfs_write_and_wait_transaction(trans, root);\n\tif (ret) {\n\t\tbtrfs_error(root->fs_info, ret,\n\t\t\t    \"Error while writing out transaction\");\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\tret = write_ctree_super(trans, root, 0);\n\tif (ret) {\n\t\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\t\tgoto scrub_continue;\n\t}\n\n\t/*\n\t * the super is written, we can safely allow the tree-loggers\n\t * to go about their business\n\t */\n\tmutex_unlock(&root->fs_info->tree_log_mutex);\n\n\tbtrfs_finish_extent_commit(trans, root);\n\n\tif (cur_trans->have_free_bgs)\n\t\tbtrfs_clear_space_info_full(root->fs_info);\n\n\troot->fs_info->last_trans_committed = cur_trans->transid;\n\t/*\n\t * We needn't acquire the lock here because there is no other task\n\t * which can change it.\n\t */\n\tcur_trans->state = TRANS_STATE_COMPLETED;\n\twake_up(&cur_trans->commit_wait);\n\n\tspin_lock(&root->fs_info->trans_lock);\n\tlist_del_init(&cur_trans->list);\n\tspin_unlock(&root->fs_info->trans_lock);\n\n\tbtrfs_put_transaction(cur_trans);\n\tbtrfs_put_transaction(cur_trans);\n\n\tif (trans->type & __TRANS_FREEZABLE)\n\t\tsb_end_intwrite(root->fs_info->sb);\n\n\ttrace_btrfs_transaction_commit(root);\n\n\tbtrfs_scrub_continue(root);\n\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\n\tkmem_cache_free(btrfs_trans_handle_cachep, trans);\n\n\tif (current != root->fs_info->transaction_kthread)\n\t\tbtrfs_run_delayed_iputs(root);\n\n\treturn ret;\n\nscrub_continue:\n\tbtrfs_scrub_continue(root);\ncleanup_transaction:\n\tbtrfs_trans_release_metadata(trans, root);\n\ttrans->block_rsv = NULL;\n\tif (trans->qgroup_reserved) {\n\t\tbtrfs_qgroup_free(root, trans->qgroup_reserved);\n\t\ttrans->qgroup_reserved = 0;\n\t}\n\tbtrfs_warn(root->fs_info, \"Skipping commit of aborted transaction.\");\n\tif (current->journal_info == trans)\n\t\tcurrent->journal_info = NULL;\n\tcleanup_transaction(trans, root, ret);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "trans"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trans"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_start_transaction",
          "args": [
            "root",
            "0"
          ],
          "line": 1013
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_start_transaction_lflush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "569-574",
          "snippet": "struct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct btrfs_trans_handle *btrfs_start_transaction_lflush(\n\t\t\t\t\tstruct btrfs_root *root, int num_items)\n{\n\treturn start_transaction(root, num_items, TRANS_START,\n\t\t\t\t BTRFS_RESERVE_FLUSH_LIMIT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__sb_end_write",
          "args": [
            "sb",
            "SB_FREEZE_WRITE"
          ],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__sb_start_write",
          "args": [
            "sb",
            "SB_FREEZE_WRITE",
            "false"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "trans"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "trans"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_attach_transaction_barrier",
          "args": [
            "root"
          ],
          "line": 993
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_attach_transaction_barrier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/transaction.c",
          "lines": "616-626",
          "snippet": "struct btrfs_trans_handle *\nbtrfs_attach_transaction_barrier(struct btrfs_root *root)\n{\n\tstruct btrfs_trans_handle *trans;\n\n\ttrans = start_transaction(root, 0, TRANS_ATTACH, 0);\n\tif (IS_ERR(trans) && PTR_ERR(trans) == -ENOENT)\n\t\tbtrfs_wait_for_commit(root, 0);\n\n\treturn trans;\n}",
          "includes": [
            "#include \"qgroup.h\"",
            "#include \"dev-replace.h\"",
            "#include \"volumes.h\"",
            "#include \"inode-map.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/uuid.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/writeback.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qgroup.h\"\n#include \"dev-replace.h\"\n#include \"volumes.h\"\n#include \"inode-map.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/uuid.h>\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/writeback.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstruct btrfs_trans_handle *\nbtrfs_attach_transaction_barrier(struct btrfs_root *root)\n{\n\tstruct btrfs_trans_handle *trans;\n\n\ttrans = start_transaction(root, 0, TRANS_ATTACH, 0);\n\tif (IS_ERR(trans) && PTR_ERR(trans) == -ENOENT)\n\t\tbtrfs_wait_for_commit(root, 0);\n\n\treturn trans;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_wait_ordered_roots",
          "args": [
            "fs_info",
            "-1"
          ],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_wait_ordered_roots",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ordered-data.c",
          "lines": "656-688",
          "snippet": "void btrfs_wait_ordered_roots(struct btrfs_fs_info *fs_info, int nr)\n{\n\tstruct btrfs_root *root;\n\tstruct list_head splice;\n\tint done;\n\n\tINIT_LIST_HEAD(&splice);\n\n\tmutex_lock(&fs_info->ordered_operations_mutex);\n\tspin_lock(&fs_info->ordered_root_lock);\n\tlist_splice_init(&fs_info->ordered_roots, &splice);\n\twhile (!list_empty(&splice) && nr) {\n\t\troot = list_first_entry(&splice, struct btrfs_root,\n\t\t\t\t\tordered_root);\n\t\troot = btrfs_grab_fs_root(root);\n\t\tBUG_ON(!root);\n\t\tlist_move_tail(&root->ordered_root,\n\t\t\t       &fs_info->ordered_roots);\n\t\tspin_unlock(&fs_info->ordered_root_lock);\n\n\t\tdone = btrfs_wait_ordered_extents(root, nr);\n\t\tbtrfs_put_fs_root(root);\n\n\t\tspin_lock(&fs_info->ordered_root_lock);\n\t\tif (nr != -1) {\n\t\t\tnr -= done;\n\t\t\tWARN_ON(nr < 0);\n\t\t}\n\t}\n\tlist_splice_tail(&splice, &fs_info->ordered_roots);\n\tspin_unlock(&fs_info->ordered_root_lock);\n\tmutex_unlock(&fs_info->ordered_operations_mutex);\n}",
          "includes": [
            "#include \"disk-io.h\"",
            "#include \"extent_io.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"ctree.h\"",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"disk-io.h\"\n#include \"extent_io.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"ctree.h\"\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/blkdev.h>\n#include <linux/slab.h>\n\nvoid btrfs_wait_ordered_roots(struct btrfs_fs_info *fs_info, int nr)\n{\n\tstruct btrfs_root *root;\n\tstruct list_head splice;\n\tint done;\n\n\tINIT_LIST_HEAD(&splice);\n\n\tmutex_lock(&fs_info->ordered_operations_mutex);\n\tspin_lock(&fs_info->ordered_root_lock);\n\tlist_splice_init(&fs_info->ordered_roots, &splice);\n\twhile (!list_empty(&splice) && nr) {\n\t\troot = list_first_entry(&splice, struct btrfs_root,\n\t\t\t\t\tordered_root);\n\t\troot = btrfs_grab_fs_root(root);\n\t\tBUG_ON(!root);\n\t\tlist_move_tail(&root->ordered_root,\n\t\t\t       &fs_info->ordered_roots);\n\t\tspin_unlock(&fs_info->ordered_root_lock);\n\n\t\tdone = btrfs_wait_ordered_extents(root, nr);\n\t\tbtrfs_put_fs_root(root);\n\n\t\tspin_lock(&fs_info->ordered_root_lock);\n\t\tif (nr != -1) {\n\t\t\tnr -= done;\n\t\t\tWARN_ON(nr < 0);\n\t\t}\n\t}\n\tlist_splice_tail(&splice, &fs_info->ordered_roots);\n\tspin_unlock(&fs_info->ordered_root_lock);\n\tmutex_unlock(&fs_info->ordered_operations_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "filemap_flush",
          "args": [
            "fs_info->btree_inode->i_mapping"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_btrfs_sync_fs",
          "args": [
            "wait"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_sb",
          "args": [
            "sb"
          ],
          "line": 981
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3272-3275",
          "snippet": "static inline struct btrfs_fs_info *btrfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline struct btrfs_fs_info *btrfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nint btrfs_sync_fs(struct super_block *sb, int wait)\n{\n\tstruct btrfs_trans_handle *trans;\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(sb);\n\tstruct btrfs_root *root = fs_info->tree_root;\n\n\ttrace_btrfs_sync_fs(wait);\n\n\tif (!wait) {\n\t\tfilemap_flush(fs_info->btree_inode->i_mapping);\n\t\treturn 0;\n\t}\n\n\tbtrfs_wait_ordered_roots(fs_info, -1);\n\n\ttrans = btrfs_attach_transaction_barrier(root);\n\tif (IS_ERR(trans)) {\n\t\t/* no transaction, don't bother */\n\t\tif (PTR_ERR(trans) == -ENOENT) {\n\t\t\t/*\n\t\t\t * Exit unless we have some pending changes\n\t\t\t * that need to go through commit\n\t\t\t */\n\t\t\tif (fs_info->pending_changes == 0)\n\t\t\t\treturn 0;\n\t\t\t/*\n\t\t\t * A non-blocking test if the fs is frozen. We must not\n\t\t\t * start a new transaction here otherwise a deadlock\n\t\t\t * happens. The pending operations are delayed to the\n\t\t\t * next commit after thawing.\n\t\t\t */\n\t\t\tif (__sb_start_write(sb, SB_FREEZE_WRITE, false))\n\t\t\t\t__sb_end_write(sb, SB_FREEZE_WRITE);\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t\ttrans = btrfs_start_transaction(root, 0);\n\t\t}\n\t\tif (IS_ERR(trans))\n\t\t\treturn PTR_ERR(trans);\n\t}\n\treturn btrfs_commit_transaction(trans, root);\n}"
  },
  {
    "function_name": "btrfs_fill_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
    "lines": "927-976",
    "snippet": "static int btrfs_fill_super(struct super_block *sb,\n\t\t\t    struct btrfs_fs_devices *fs_devices,\n\t\t\t    void *data, int silent)\n{\n\tstruct inode *inode;\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(sb);\n\tstruct btrfs_key key;\n\tint err;\n\n\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n\tsb->s_magic = BTRFS_SUPER_MAGIC;\n\tsb->s_op = &btrfs_super_ops;\n\tsb->s_d_op = &btrfs_dentry_operations;\n\tsb->s_export_op = &btrfs_export_ops;\n\tsb->s_xattr = btrfs_xattr_handlers;\n\tsb->s_time_gran = 1;\n#ifdef CONFIG_BTRFS_FS_POSIX_ACL\n\tsb->s_flags |= MS_POSIXACL;\n#endif\n\tsb->s_flags |= MS_I_VERSION;\n\terr = open_ctree(sb, fs_devices, (char *)data);\n\tif (err) {\n\t\tprintk(KERN_ERR \"BTRFS: open_ctree failed\\n\");\n\t\treturn err;\n\t}\n\n\tkey.objectid = BTRFS_FIRST_FREE_OBJECTID;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\tinode = btrfs_iget(sb, &key, fs_info->fs_root, NULL);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tgoto fail_close;\n\t}\n\n\tsb->s_root = d_make_root(inode);\n\tif (!sb->s_root) {\n\t\terr = -ENOMEM;\n\t\tgoto fail_close;\n\t}\n\n\tsave_mount_options(sb, data);\n\tcleancache_init_fs(sb);\n\tsb->s_flags |= MS_ACTIVE;\n\treturn 0;\n\nfail_close:\n\tclose_ctree(fs_info->tree_root);\n\treturn err;\n}",
    "includes": [
      "#include <trace/events/btrfs.h>",
      "#include \"qgroup.h\"",
      "#include \"tests/btrfs-tests.h\"",
      "#include \"backref.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"compression.h\"",
      "#include \"export.h\"",
      "#include \"volumes.h\"",
      "#include \"xattr.h\"",
      "#include \"props.h\"",
      "#include \"hash.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/namei.h>",
      "#include <linux/ctype.h>",
      "#include <linux/parser.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct super_operations btrfs_super_ops;",
      "static int btrfs_remount(struct super_block *sb, int *flags, char *data);",
      "static const struct super_operations btrfs_super_ops = {\n\t.drop_inode\t= btrfs_drop_inode,\n\t.evict_inode\t= btrfs_evict_inode,\n\t.put_super\t= btrfs_put_super,\n\t.sync_fs\t= btrfs_sync_fs,\n\t.show_options\t= btrfs_show_options,\n\t.show_devname\t= btrfs_show_devname,\n\t.write_inode\t= btrfs_write_inode,\n\t.alloc_inode\t= btrfs_alloc_inode,\n\t.destroy_inode\t= btrfs_destroy_inode,\n\t.statfs\t\t= btrfs_statfs,\n\t.remount_fs\t= btrfs_remount,\n\t.freeze_fs\t= btrfs_freeze,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "close_ctree",
          "args": [
            "fs_info->tree_root"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "close_ctree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3639-3739",
          "snippet": "void close_ctree(struct btrfs_root *root)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tint ret;\n\n\tfs_info->closing = 1;\n\tsmp_mb();\n\n\t/* wait for the uuid_scan task to finish */\n\tdown(&fs_info->uuid_tree_rescan_sem);\n\t/* avoid complains from lockdep et al., set sem back to initial state */\n\tup(&fs_info->uuid_tree_rescan_sem);\n\n\t/* pause restriper - we want to resume on mount */\n\tbtrfs_pause_balance(fs_info);\n\n\tbtrfs_dev_replace_suspend_for_unmount(fs_info);\n\n\tbtrfs_scrub_cancel(fs_info);\n\n\t/* wait for any defraggers to finish */\n\twait_event(fs_info->transaction_wait,\n\t\t   (atomic_read(&fs_info->defrag_running) == 0));\n\n\t/* clear out the rbtree of defraggable inodes */\n\tbtrfs_cleanup_defrag_inodes(fs_info);\n\n\tcancel_work_sync(&fs_info->async_reclaim_work);\n\n\tif (!(fs_info->sb->s_flags & MS_RDONLY)) {\n\t\tret = btrfs_commit_super(root);\n\t\tif (ret)\n\t\t\tbtrfs_err(root->fs_info, \"commit super ret %d\", ret);\n\t}\n\n\tif (test_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state))\n\t\tbtrfs_error_commit_super(root);\n\n\tkthread_stop(fs_info->transaction_kthread);\n\tkthread_stop(fs_info->cleaner_kthread);\n\n\tfs_info->closing = 2;\n\tsmp_mb();\n\n\tbtrfs_free_qgroup_config(root->fs_info);\n\n\tif (percpu_counter_sum(&fs_info->delalloc_bytes)) {\n\t\tbtrfs_info(root->fs_info, \"at unmount delalloc count %lld\",\n\t\t       percpu_counter_sum(&fs_info->delalloc_bytes));\n\t}\n\n\tbtrfs_sysfs_remove_one(fs_info);\n\n\tbtrfs_free_fs_roots(fs_info);\n\n\tbtrfs_put_block_group_cache(fs_info);\n\n\tbtrfs_free_block_groups(fs_info);\n\n\t/*\n\t * we must make sure there is not any read request to\n\t * submit after we stopping all workers.\n\t */\n\tinvalidate_inode_pages2(fs_info->btree_inode->i_mapping);\n\tbtrfs_stop_all_workers(fs_info);\n\n\tfs_info->open = 0;\n\tfree_root_pointers(fs_info, 1);\n\n\tiput(fs_info->btree_inode);\n\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_test_opt(root, CHECK_INTEGRITY))\n\t\tbtrfsic_unmount(root, fs_info->fs_devices);\n#endif\n\n\tbtrfs_close_devices(fs_info->fs_devices);\n\tbtrfs_mapping_tree_free(&fs_info->mapping_tree);\n\n\tpercpu_counter_destroy(&fs_info->dirty_metadata_bytes);\n\tpercpu_counter_destroy(&fs_info->delalloc_bytes);\n\tpercpu_counter_destroy(&fs_info->bio_counter);\n\tbdi_destroy(&fs_info->bdi);\n\tcleanup_srcu_struct(&fs_info->subvol_srcu);\n\n\tbtrfs_free_stripe_hash_table(fs_info);\n\n\tbtrfs_free_block_rsv(root, root->orphan_block_rsv);\n\troot->orphan_block_rsv = NULL;\n\n\tlock_chunks(root);\n\twhile (!list_empty(&fs_info->pinned_chunks)) {\n\t\tstruct extent_map *em;\n\n\t\tem = list_first_entry(&fs_info->pinned_chunks,\n\t\t\t\t      struct extent_map, list);\n\t\tlist_del_init(&em->list);\n\t\tfree_extent_map(em);\n\t}\n\tunlock_chunks(root);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid close_ctree(struct btrfs_root *root)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tint ret;\n\n\tfs_info->closing = 1;\n\tsmp_mb();\n\n\t/* wait for the uuid_scan task to finish */\n\tdown(&fs_info->uuid_tree_rescan_sem);\n\t/* avoid complains from lockdep et al., set sem back to initial state */\n\tup(&fs_info->uuid_tree_rescan_sem);\n\n\t/* pause restriper - we want to resume on mount */\n\tbtrfs_pause_balance(fs_info);\n\n\tbtrfs_dev_replace_suspend_for_unmount(fs_info);\n\n\tbtrfs_scrub_cancel(fs_info);\n\n\t/* wait for any defraggers to finish */\n\twait_event(fs_info->transaction_wait,\n\t\t   (atomic_read(&fs_info->defrag_running) == 0));\n\n\t/* clear out the rbtree of defraggable inodes */\n\tbtrfs_cleanup_defrag_inodes(fs_info);\n\n\tcancel_work_sync(&fs_info->async_reclaim_work);\n\n\tif (!(fs_info->sb->s_flags & MS_RDONLY)) {\n\t\tret = btrfs_commit_super(root);\n\t\tif (ret)\n\t\t\tbtrfs_err(root->fs_info, \"commit super ret %d\", ret);\n\t}\n\n\tif (test_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state))\n\t\tbtrfs_error_commit_super(root);\n\n\tkthread_stop(fs_info->transaction_kthread);\n\tkthread_stop(fs_info->cleaner_kthread);\n\n\tfs_info->closing = 2;\n\tsmp_mb();\n\n\tbtrfs_free_qgroup_config(root->fs_info);\n\n\tif (percpu_counter_sum(&fs_info->delalloc_bytes)) {\n\t\tbtrfs_info(root->fs_info, \"at unmount delalloc count %lld\",\n\t\t       percpu_counter_sum(&fs_info->delalloc_bytes));\n\t}\n\n\tbtrfs_sysfs_remove_one(fs_info);\n\n\tbtrfs_free_fs_roots(fs_info);\n\n\tbtrfs_put_block_group_cache(fs_info);\n\n\tbtrfs_free_block_groups(fs_info);\n\n\t/*\n\t * we must make sure there is not any read request to\n\t * submit after we stopping all workers.\n\t */\n\tinvalidate_inode_pages2(fs_info->btree_inode->i_mapping);\n\tbtrfs_stop_all_workers(fs_info);\n\n\tfs_info->open = 0;\n\tfree_root_pointers(fs_info, 1);\n\n\tiput(fs_info->btree_inode);\n\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_test_opt(root, CHECK_INTEGRITY))\n\t\tbtrfsic_unmount(root, fs_info->fs_devices);\n#endif\n\n\tbtrfs_close_devices(fs_info->fs_devices);\n\tbtrfs_mapping_tree_free(&fs_info->mapping_tree);\n\n\tpercpu_counter_destroy(&fs_info->dirty_metadata_bytes);\n\tpercpu_counter_destroy(&fs_info->delalloc_bytes);\n\tpercpu_counter_destroy(&fs_info->bio_counter);\n\tbdi_destroy(&fs_info->bdi);\n\tcleanup_srcu_struct(&fs_info->subvol_srcu);\n\n\tbtrfs_free_stripe_hash_table(fs_info);\n\n\tbtrfs_free_block_rsv(root, root->orphan_block_rsv);\n\troot->orphan_block_rsv = NULL;\n\n\tlock_chunks(root);\n\twhile (!list_empty(&fs_info->pinned_chunks)) {\n\t\tstruct extent_map *em;\n\n\t\tem = list_first_entry(&fs_info->pinned_chunks,\n\t\t\t\t      struct extent_map, list);\n\t\tlist_del_init(&em->list);\n\t\tfree_extent_map(em);\n\t}\n\tunlock_chunks(root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cleancache_init_fs",
          "args": [
            "sb"
          ],
          "line": 969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "save_mount_options",
          "args": [
            "sb",
            "data"
          ],
          "line": 968
        },
        "resolved": true,
        "details": {
          "function_name": "save_mount_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1189-1193",
          "snippet": "void save_mount_options(struct super_block *sb, char *options)\n{\n\tBUG_ON(sb->s_options);\n\trcu_assign_pointer(sb->s_options, kstrdup(options, GFP_KERNEL));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid save_mount_options(struct super_block *sb, char *options)\n{\n\tBUG_ON(sb->s_options);\n\trcu_assign_pointer(sb->s_options, kstrdup(options, GFP_KERNEL));\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_make_root",
          "args": [
            "inode"
          ],
          "line": 962
        },
        "resolved": true,
        "details": {
          "function_name": "d_make_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1857-1871",
          "snippet": "struct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_iget",
          "args": [
            "sb",
            "&key",
            "fs_info->fs_root",
            "NULL"
          ],
          "line": 956
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "5312-5336",
          "snippet": "struct inode *btrfs_iget(struct super_block *s, struct btrfs_key *location,\n\t\t\t struct btrfs_root *root, int *new)\n{\n\tstruct inode *inode;\n\n\tinode = btrfs_iget_locked(s, location, root);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (inode->i_state & I_NEW) {\n\t\tbtrfs_read_locked_inode(inode);\n\t\tif (!is_bad_inode(inode)) {\n\t\t\tinode_tree_add(inode);\n\t\t\tunlock_new_inode(inode);\n\t\t\tif (new)\n\t\t\t\t*new = 1;\n\t\t} else {\n\t\t\tunlock_new_inode(inode);\n\t\t\tiput(inode);\n\t\t\tinode = ERR_PTR(-ESTALE);\n\t\t}\n\t}\n\n\treturn inode;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nstruct inode *btrfs_iget(struct super_block *s, struct btrfs_key *location,\n\t\t\t struct btrfs_root *root, int *new)\n{\n\tstruct inode *inode;\n\n\tinode = btrfs_iget_locked(s, location, root);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (inode->i_state & I_NEW) {\n\t\tbtrfs_read_locked_inode(inode);\n\t\tif (!is_bad_inode(inode)) {\n\t\t\tinode_tree_add(inode);\n\t\t\tunlock_new_inode(inode);\n\t\t\tif (new)\n\t\t\t\t*new = 1;\n\t\t} else {\n\t\t\tunlock_new_inode(inode);\n\t\t\tiput(inode);\n\t\t\tinode = ERR_PTR(-ESTALE);\n\t\t}\n\t}\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"BTRFS: open_ctree failed\\n\""
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "open_ctree",
          "args": [
            "sb",
            "fs_devices",
            "(char *)data"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "open_ctree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "2149-3061",
          "snippet": "int open_ctree(struct super_block *sb,\n\t       struct btrfs_fs_devices *fs_devices,\n\t       char *options)\n{\n\tu32 sectorsize;\n\tu32 nodesize;\n\tu32 stripesize;\n\tu64 generation;\n\tu64 features;\n\tstruct btrfs_key location;\n\tstruct buffer_head *bh;\n\tstruct btrfs_super_block *disk_super;\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(sb);\n\tstruct btrfs_root *tree_root;\n\tstruct btrfs_root *extent_root;\n\tstruct btrfs_root *csum_root;\n\tstruct btrfs_root *chunk_root;\n\tstruct btrfs_root *dev_root;\n\tstruct btrfs_root *quota_root;\n\tstruct btrfs_root *uuid_root;\n\tstruct btrfs_root *log_tree_root;\n\tint ret;\n\tint err = -EINVAL;\n\tint num_backups_tried = 0;\n\tint backup_index = 0;\n\tint max_active;\n\tint flags = WQ_MEM_RECLAIM | WQ_FREEZABLE | WQ_UNBOUND;\n\tbool create_uuid_tree;\n\tbool check_uuid_tree;\n\n\ttree_root = fs_info->tree_root = btrfs_alloc_root(fs_info);\n\tchunk_root = fs_info->chunk_root = btrfs_alloc_root(fs_info);\n\tif (!tree_root || !chunk_root) {\n\t\terr = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tret = init_srcu_struct(&fs_info->subvol_srcu);\n\tif (ret) {\n\t\terr = ret;\n\t\tgoto fail;\n\t}\n\n\tret = setup_bdi(fs_info, &fs_info->bdi);\n\tif (ret) {\n\t\terr = ret;\n\t\tgoto fail_srcu;\n\t}\n\n\tret = percpu_counter_init(&fs_info->dirty_metadata_bytes, 0, GFP_KERNEL);\n\tif (ret) {\n\t\terr = ret;\n\t\tgoto fail_bdi;\n\t}\n\tfs_info->dirty_metadata_batch = PAGE_CACHE_SIZE *\n\t\t\t\t\t(1 + ilog2(nr_cpu_ids));\n\n\tret = percpu_counter_init(&fs_info->delalloc_bytes, 0, GFP_KERNEL);\n\tif (ret) {\n\t\terr = ret;\n\t\tgoto fail_dirty_metadata_bytes;\n\t}\n\n\tret = percpu_counter_init(&fs_info->bio_counter, 0, GFP_KERNEL);\n\tif (ret) {\n\t\terr = ret;\n\t\tgoto fail_delalloc_bytes;\n\t}\n\n\tfs_info->btree_inode = new_inode(sb);\n\tif (!fs_info->btree_inode) {\n\t\terr = -ENOMEM;\n\t\tgoto fail_bio_counter;\n\t}\n\n\tmapping_set_gfp_mask(fs_info->btree_inode->i_mapping, GFP_NOFS);\n\n\tINIT_RADIX_TREE(&fs_info->fs_roots_radix, GFP_ATOMIC);\n\tINIT_RADIX_TREE(&fs_info->buffer_radix, GFP_ATOMIC);\n\tINIT_LIST_HEAD(&fs_info->trans_list);\n\tINIT_LIST_HEAD(&fs_info->dead_roots);\n\tINIT_LIST_HEAD(&fs_info->delayed_iputs);\n\tINIT_LIST_HEAD(&fs_info->delalloc_roots);\n\tINIT_LIST_HEAD(&fs_info->caching_block_groups);\n\tspin_lock_init(&fs_info->delalloc_root_lock);\n\tspin_lock_init(&fs_info->trans_lock);\n\tspin_lock_init(&fs_info->fs_roots_radix_lock);\n\tspin_lock_init(&fs_info->delayed_iput_lock);\n\tspin_lock_init(&fs_info->defrag_inodes_lock);\n\tspin_lock_init(&fs_info->free_chunk_lock);\n\tspin_lock_init(&fs_info->tree_mod_seq_lock);\n\tspin_lock_init(&fs_info->super_lock);\n\tspin_lock_init(&fs_info->qgroup_op_lock);\n\tspin_lock_init(&fs_info->buffer_lock);\n\tspin_lock_init(&fs_info->unused_bgs_lock);\n\tmutex_init(&fs_info->unused_bg_unpin_mutex);\n\trwlock_init(&fs_info->tree_mod_log_lock);\n\tmutex_init(&fs_info->reloc_mutex);\n\tmutex_init(&fs_info->delalloc_root_mutex);\n\tseqlock_init(&fs_info->profiles_lock);\n\n\tinit_completion(&fs_info->kobj_unregister);\n\tINIT_LIST_HEAD(&fs_info->dirty_cowonly_roots);\n\tINIT_LIST_HEAD(&fs_info->space_info);\n\tINIT_LIST_HEAD(&fs_info->tree_mod_seq_list);\n\tINIT_LIST_HEAD(&fs_info->unused_bgs);\n\tbtrfs_mapping_init(&fs_info->mapping_tree);\n\tbtrfs_init_block_rsv(&fs_info->global_block_rsv,\n\t\t\t     BTRFS_BLOCK_RSV_GLOBAL);\n\tbtrfs_init_block_rsv(&fs_info->delalloc_block_rsv,\n\t\t\t     BTRFS_BLOCK_RSV_DELALLOC);\n\tbtrfs_init_block_rsv(&fs_info->trans_block_rsv, BTRFS_BLOCK_RSV_TRANS);\n\tbtrfs_init_block_rsv(&fs_info->chunk_block_rsv, BTRFS_BLOCK_RSV_CHUNK);\n\tbtrfs_init_block_rsv(&fs_info->empty_block_rsv, BTRFS_BLOCK_RSV_EMPTY);\n\tbtrfs_init_block_rsv(&fs_info->delayed_block_rsv,\n\t\t\t     BTRFS_BLOCK_RSV_DELOPS);\n\tatomic_set(&fs_info->nr_async_submits, 0);\n\tatomic_set(&fs_info->async_delalloc_pages, 0);\n\tatomic_set(&fs_info->async_submit_draining, 0);\n\tatomic_set(&fs_info->nr_async_bios, 0);\n\tatomic_set(&fs_info->defrag_running, 0);\n\tatomic_set(&fs_info->qgroup_op_seq, 0);\n\tatomic64_set(&fs_info->tree_mod_seq, 0);\n\tfs_info->sb = sb;\n\tfs_info->max_inline = BTRFS_DEFAULT_MAX_INLINE;\n\tfs_info->metadata_ratio = 0;\n\tfs_info->defrag_inodes = RB_ROOT;\n\tfs_info->free_chunk_space = 0;\n\tfs_info->tree_mod_log = RB_ROOT;\n\tfs_info->commit_interval = BTRFS_DEFAULT_COMMIT_INTERVAL;\n\tfs_info->avg_delayed_ref_runtime = div64_u64(NSEC_PER_SEC, 64);\n\t/* readahead state */\n\tINIT_RADIX_TREE(&fs_info->reada_tree, GFP_NOFS & ~__GFP_WAIT);\n\tspin_lock_init(&fs_info->reada_lock);\n\n\tfs_info->thread_pool_size = min_t(unsigned long,\n\t\t\t\t\t  num_online_cpus() + 2, 8);\n\n\tINIT_LIST_HEAD(&fs_info->ordered_roots);\n\tspin_lock_init(&fs_info->ordered_root_lock);\n\tfs_info->delayed_root = kmalloc(sizeof(struct btrfs_delayed_root),\n\t\t\t\t\tGFP_NOFS);\n\tif (!fs_info->delayed_root) {\n\t\terr = -ENOMEM;\n\t\tgoto fail_iput;\n\t}\n\tbtrfs_init_delayed_root(fs_info->delayed_root);\n\n\tmutex_init(&fs_info->scrub_lock);\n\tatomic_set(&fs_info->scrubs_running, 0);\n\tatomic_set(&fs_info->scrub_pause_req, 0);\n\tatomic_set(&fs_info->scrubs_paused, 0);\n\tatomic_set(&fs_info->scrub_cancel_req, 0);\n\tinit_waitqueue_head(&fs_info->replace_wait);\n\tinit_waitqueue_head(&fs_info->scrub_pause_wait);\n\tfs_info->scrub_workers_refcnt = 0;\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tfs_info->check_integrity_print_mask = 0;\n#endif\n\n\tspin_lock_init(&fs_info->balance_lock);\n\tmutex_init(&fs_info->balance_mutex);\n\tatomic_set(&fs_info->balance_running, 0);\n\tatomic_set(&fs_info->balance_pause_req, 0);\n\tatomic_set(&fs_info->balance_cancel_req, 0);\n\tfs_info->balance_ctl = NULL;\n\tinit_waitqueue_head(&fs_info->balance_wait_q);\n\tbtrfs_init_async_reclaim_work(&fs_info->async_reclaim_work);\n\n\tsb->s_blocksize = 4096;\n\tsb->s_blocksize_bits = blksize_bits(4096);\n\tsb->s_bdi = &fs_info->bdi;\n\n\tfs_info->btree_inode->i_ino = BTRFS_BTREE_INODE_OBJECTID;\n\tset_nlink(fs_info->btree_inode, 1);\n\t/*\n\t * we set the i_size on the btree inode to the max possible int.\n\t * the real end of the address space is determined by all of\n\t * the devices in the system\n\t */\n\tfs_info->btree_inode->i_size = OFFSET_MAX;\n\tfs_info->btree_inode->i_mapping->a_ops = &btree_aops;\n\n\tRB_CLEAR_NODE(&BTRFS_I(fs_info->btree_inode)->rb_node);\n\textent_io_tree_init(&BTRFS_I(fs_info->btree_inode)->io_tree,\n\t\t\t     fs_info->btree_inode->i_mapping);\n\tBTRFS_I(fs_info->btree_inode)->io_tree.track_uptodate = 0;\n\textent_map_tree_init(&BTRFS_I(fs_info->btree_inode)->extent_tree);\n\n\tBTRFS_I(fs_info->btree_inode)->io_tree.ops = &btree_extent_io_ops;\n\n\tBTRFS_I(fs_info->btree_inode)->root = tree_root;\n\tmemset(&BTRFS_I(fs_info->btree_inode)->location, 0,\n\t       sizeof(struct btrfs_key));\n\tset_bit(BTRFS_INODE_DUMMY,\n\t\t&BTRFS_I(fs_info->btree_inode)->runtime_flags);\n\tbtrfs_insert_inode_hash(fs_info->btree_inode);\n\n\tspin_lock_init(&fs_info->block_group_cache_lock);\n\tfs_info->block_group_cache_tree = RB_ROOT;\n\tfs_info->first_logical_byte = (u64)-1;\n\n\textent_io_tree_init(&fs_info->freed_extents[0],\n\t\t\t     fs_info->btree_inode->i_mapping);\n\textent_io_tree_init(&fs_info->freed_extents[1],\n\t\t\t     fs_info->btree_inode->i_mapping);\n\tfs_info->pinned_extents = &fs_info->freed_extents[0];\n\tfs_info->do_barriers = 1;\n\n\n\tmutex_init(&fs_info->ordered_operations_mutex);\n\tmutex_init(&fs_info->ordered_extent_flush_mutex);\n\tmutex_init(&fs_info->tree_log_mutex);\n\tmutex_init(&fs_info->chunk_mutex);\n\tmutex_init(&fs_info->transaction_kthread_mutex);\n\tmutex_init(&fs_info->cleaner_mutex);\n\tmutex_init(&fs_info->volume_mutex);\n\tinit_rwsem(&fs_info->commit_root_sem);\n\tinit_rwsem(&fs_info->cleanup_work_sem);\n\tinit_rwsem(&fs_info->subvol_sem);\n\tsema_init(&fs_info->uuid_tree_rescan_sem, 1);\n\tfs_info->dev_replace.lock_owner = 0;\n\tatomic_set(&fs_info->dev_replace.nesting_level, 0);\n\tmutex_init(&fs_info->dev_replace.lock_finishing_cancel_unmount);\n\tmutex_init(&fs_info->dev_replace.lock_management_lock);\n\tmutex_init(&fs_info->dev_replace.lock);\n\n\tspin_lock_init(&fs_info->qgroup_lock);\n\tmutex_init(&fs_info->qgroup_ioctl_lock);\n\tfs_info->qgroup_tree = RB_ROOT;\n\tfs_info->qgroup_op_tree = RB_ROOT;\n\tINIT_LIST_HEAD(&fs_info->dirty_qgroups);\n\tfs_info->qgroup_seq = 1;\n\tfs_info->quota_enabled = 0;\n\tfs_info->pending_quota_state = 0;\n\tfs_info->qgroup_ulist = NULL;\n\tmutex_init(&fs_info->qgroup_rescan_lock);\n\n\tbtrfs_init_free_cluster(&fs_info->meta_alloc_cluster);\n\tbtrfs_init_free_cluster(&fs_info->data_alloc_cluster);\n\n\tinit_waitqueue_head(&fs_info->transaction_throttle);\n\tinit_waitqueue_head(&fs_info->transaction_wait);\n\tinit_waitqueue_head(&fs_info->transaction_blocked_wait);\n\tinit_waitqueue_head(&fs_info->async_submit_wait);\n\n\tINIT_LIST_HEAD(&fs_info->pinned_chunks);\n\n\tret = btrfs_alloc_stripe_hash_table(fs_info);\n\tif (ret) {\n\t\terr = ret;\n\t\tgoto fail_alloc;\n\t}\n\n\t__setup_root(4096, 4096, 4096, tree_root,\n\t\t     fs_info, BTRFS_ROOT_TREE_OBJECTID);\n\n\tinvalidate_bdev(fs_devices->latest_bdev);\n\n\t/*\n\t * Read super block and check the signature bytes only\n\t */\n\tbh = btrfs_read_dev_super(fs_devices->latest_bdev);\n\tif (!bh) {\n\t\terr = -EINVAL;\n\t\tgoto fail_alloc;\n\t}\n\n\t/*\n\t * We want to check superblock checksum, the type is stored inside.\n\t * Pass the whole disk block of size BTRFS_SUPER_INFO_SIZE (4k).\n\t */\n\tif (btrfs_check_super_csum(bh->b_data)) {\n\t\tprintk(KERN_ERR \"BTRFS: superblock checksum mismatch\\n\");\n\t\terr = -EINVAL;\n\t\tgoto fail_alloc;\n\t}\n\n\t/*\n\t * super_copy is zeroed at allocation time and we never touch the\n\t * following bytes up to INFO_SIZE, the checksum is calculated from\n\t * the whole block of INFO_SIZE\n\t */\n\tmemcpy(fs_info->super_copy, bh->b_data, sizeof(*fs_info->super_copy));\n\tmemcpy(fs_info->super_for_commit, fs_info->super_copy,\n\t       sizeof(*fs_info->super_for_commit));\n\tbrelse(bh);\n\n\tmemcpy(fs_info->fsid, fs_info->super_copy->fsid, BTRFS_FSID_SIZE);\n\n\tret = btrfs_check_super_valid(fs_info, sb->s_flags & MS_RDONLY);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"BTRFS: superblock contains fatal errors\\n\");\n\t\terr = -EINVAL;\n\t\tgoto fail_alloc;\n\t}\n\n\tdisk_super = fs_info->super_copy;\n\tif (!btrfs_super_root(disk_super))\n\t\tgoto fail_alloc;\n\n\t/* check FS state, whether FS is broken. */\n\tif (btrfs_super_flags(disk_super) & BTRFS_SUPER_FLAG_ERROR)\n\t\tset_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state);\n\n\t/*\n\t * run through our array of backup supers and setup\n\t * our ring pointer to the oldest one\n\t */\n\tgeneration = btrfs_super_generation(disk_super);\n\tfind_oldest_super_backup(fs_info, generation);\n\n\t/*\n\t * In the long term, we'll store the compression type in the super\n\t * block, and it'll be used for per file compression control.\n\t */\n\tfs_info->compress_type = BTRFS_COMPRESS_ZLIB;\n\n\tret = btrfs_parse_options(tree_root, options);\n\tif (ret) {\n\t\terr = ret;\n\t\tgoto fail_alloc;\n\t}\n\n\tfeatures = btrfs_super_incompat_flags(disk_super) &\n\t\t~BTRFS_FEATURE_INCOMPAT_SUPP;\n\tif (features) {\n\t\tprintk(KERN_ERR \"BTRFS: couldn't mount because of \"\n\t\t       \"unsupported optional features (%Lx).\\n\",\n\t\t       features);\n\t\terr = -EINVAL;\n\t\tgoto fail_alloc;\n\t}\n\n\t/*\n\t * Leafsize and nodesize were always equal, this is only a sanity check.\n\t */\n\tif (le32_to_cpu(disk_super->__unused_leafsize) !=\n\t    btrfs_super_nodesize(disk_super)) {\n\t\tprintk(KERN_ERR \"BTRFS: couldn't mount because metadata \"\n\t\t       \"blocksizes don't match.  node %d leaf %d\\n\",\n\t\t       btrfs_super_nodesize(disk_super),\n\t\t       le32_to_cpu(disk_super->__unused_leafsize));\n\t\terr = -EINVAL;\n\t\tgoto fail_alloc;\n\t}\n\tif (btrfs_super_nodesize(disk_super) > BTRFS_MAX_METADATA_BLOCKSIZE) {\n\t\tprintk(KERN_ERR \"BTRFS: couldn't mount because metadata \"\n\t\t       \"blocksize (%d) was too large\\n\",\n\t\t       btrfs_super_nodesize(disk_super));\n\t\terr = -EINVAL;\n\t\tgoto fail_alloc;\n\t}\n\n\tfeatures = btrfs_super_incompat_flags(disk_super);\n\tfeatures |= BTRFS_FEATURE_INCOMPAT_MIXED_BACKREF;\n\tif (tree_root->fs_info->compress_type == BTRFS_COMPRESS_LZO)\n\t\tfeatures |= BTRFS_FEATURE_INCOMPAT_COMPRESS_LZO;\n\n\tif (features & BTRFS_FEATURE_INCOMPAT_SKINNY_METADATA)\n\t\tprintk(KERN_INFO \"BTRFS: has skinny extents\\n\");\n\n\t/*\n\t * flag our filesystem as having big metadata blocks if\n\t * they are bigger than the page size\n\t */\n\tif (btrfs_super_nodesize(disk_super) > PAGE_CACHE_SIZE) {\n\t\tif (!(features & BTRFS_FEATURE_INCOMPAT_BIG_METADATA))\n\t\t\tprintk(KERN_INFO \"BTRFS: flagging fs with big metadata feature\\n\");\n\t\tfeatures |= BTRFS_FEATURE_INCOMPAT_BIG_METADATA;\n\t}\n\n\tnodesize = btrfs_super_nodesize(disk_super);\n\tsectorsize = btrfs_super_sectorsize(disk_super);\n\tstripesize = btrfs_super_stripesize(disk_super);\n\tfs_info->dirty_metadata_batch = nodesize * (1 + ilog2(nr_cpu_ids));\n\tfs_info->delalloc_batch = sectorsize * 512 * (1 + ilog2(nr_cpu_ids));\n\n\t/*\n\t * mixed block groups end up with duplicate but slightly offset\n\t * extent buffers for the same range.  It leads to corruptions\n\t */\n\tif ((features & BTRFS_FEATURE_INCOMPAT_MIXED_GROUPS) &&\n\t    (sectorsize != nodesize)) {\n\t\tprintk(KERN_ERR \"BTRFS: unequal leaf/node/sector sizes \"\n\t\t\t\t\"are not allowed for mixed block groups on %s\\n\",\n\t\t\t\tsb->s_id);\n\t\tgoto fail_alloc;\n\t}\n\n\t/*\n\t * Needn't use the lock because there is no other task which will\n\t * update the flag.\n\t */\n\tbtrfs_set_super_incompat_flags(disk_super, features);\n\n\tfeatures = btrfs_super_compat_ro_flags(disk_super) &\n\t\t~BTRFS_FEATURE_COMPAT_RO_SUPP;\n\tif (!(sb->s_flags & MS_RDONLY) && features) {\n\t\tprintk(KERN_ERR \"BTRFS: couldn't mount RDWR because of \"\n\t\t       \"unsupported option features (%Lx).\\n\",\n\t\t       features);\n\t\terr = -EINVAL;\n\t\tgoto fail_alloc;\n\t}\n\n\tmax_active = fs_info->thread_pool_size;\n\n\tfs_info->workers =\n\t\tbtrfs_alloc_workqueue(\"worker\", flags | WQ_HIGHPRI,\n\t\t\t\t      max_active, 16);\n\n\tfs_info->delalloc_workers =\n\t\tbtrfs_alloc_workqueue(\"delalloc\", flags, max_active, 2);\n\n\tfs_info->flush_workers =\n\t\tbtrfs_alloc_workqueue(\"flush_delalloc\", flags, max_active, 0);\n\n\tfs_info->caching_workers =\n\t\tbtrfs_alloc_workqueue(\"cache\", flags, max_active, 0);\n\n\t/*\n\t * a higher idle thresh on the submit workers makes it much more\n\t * likely that bios will be send down in a sane order to the\n\t * devices\n\t */\n\tfs_info->submit_workers =\n\t\tbtrfs_alloc_workqueue(\"submit\", flags,\n\t\t\t\t      min_t(u64, fs_devices->num_devices,\n\t\t\t\t\t    max_active), 64);\n\n\tfs_info->fixup_workers =\n\t\tbtrfs_alloc_workqueue(\"fixup\", flags, 1, 0);\n\n\t/*\n\t * endios are largely parallel and should have a very\n\t * low idle thresh\n\t */\n\tfs_info->endio_workers =\n\t\tbtrfs_alloc_workqueue(\"endio\", flags, max_active, 4);\n\tfs_info->endio_meta_workers =\n\t\tbtrfs_alloc_workqueue(\"endio-meta\", flags, max_active, 4);\n\tfs_info->endio_meta_write_workers =\n\t\tbtrfs_alloc_workqueue(\"endio-meta-write\", flags, max_active, 2);\n\tfs_info->endio_raid56_workers =\n\t\tbtrfs_alloc_workqueue(\"endio-raid56\", flags, max_active, 4);\n\tfs_info->endio_repair_workers =\n\t\tbtrfs_alloc_workqueue(\"endio-repair\", flags, 1, 0);\n\tfs_info->rmw_workers =\n\t\tbtrfs_alloc_workqueue(\"rmw\", flags, max_active, 2);\n\tfs_info->endio_write_workers =\n\t\tbtrfs_alloc_workqueue(\"endio-write\", flags, max_active, 2);\n\tfs_info->endio_freespace_worker =\n\t\tbtrfs_alloc_workqueue(\"freespace-write\", flags, max_active, 0);\n\tfs_info->delayed_workers =\n\t\tbtrfs_alloc_workqueue(\"delayed-meta\", flags, max_active, 0);\n\tfs_info->readahead_workers =\n\t\tbtrfs_alloc_workqueue(\"readahead\", flags, max_active, 2);\n\tfs_info->qgroup_rescan_workers =\n\t\tbtrfs_alloc_workqueue(\"qgroup-rescan\", flags, 1, 0);\n\tfs_info->extent_workers =\n\t\tbtrfs_alloc_workqueue(\"extent-refs\", flags,\n\t\t\t\t      min_t(u64, fs_devices->num_devices,\n\t\t\t\t\t    max_active), 8);\n\n\tif (!(fs_info->workers && fs_info->delalloc_workers &&\n\t      fs_info->submit_workers && fs_info->flush_workers &&\n\t      fs_info->endio_workers && fs_info->endio_meta_workers &&\n\t      fs_info->endio_meta_write_workers &&\n\t      fs_info->endio_repair_workers &&\n\t      fs_info->endio_write_workers && fs_info->endio_raid56_workers &&\n\t      fs_info->endio_freespace_worker && fs_info->rmw_workers &&\n\t      fs_info->caching_workers && fs_info->readahead_workers &&\n\t      fs_info->fixup_workers && fs_info->delayed_workers &&\n\t      fs_info->extent_workers &&\n\t      fs_info->qgroup_rescan_workers)) {\n\t\terr = -ENOMEM;\n\t\tgoto fail_sb_buffer;\n\t}\n\n\tfs_info->bdi.ra_pages *= btrfs_super_num_devices(disk_super);\n\tfs_info->bdi.ra_pages = max(fs_info->bdi.ra_pages,\n\t\t\t\t    4 * 1024 * 1024 / PAGE_CACHE_SIZE);\n\n\ttree_root->nodesize = nodesize;\n\ttree_root->sectorsize = sectorsize;\n\ttree_root->stripesize = stripesize;\n\n\tsb->s_blocksize = sectorsize;\n\tsb->s_blocksize_bits = blksize_bits(sectorsize);\n\n\tif (btrfs_super_magic(disk_super) != BTRFS_MAGIC) {\n\t\tprintk(KERN_ERR \"BTRFS: valid FS not found on %s\\n\", sb->s_id);\n\t\tgoto fail_sb_buffer;\n\t}\n\n\tif (sectorsize != PAGE_SIZE) {\n\t\tprintk(KERN_ERR \"BTRFS: incompatible sector size (%lu) \"\n\t\t       \"found on %s\\n\", (unsigned long)sectorsize, sb->s_id);\n\t\tgoto fail_sb_buffer;\n\t}\n\n\tmutex_lock(&fs_info->chunk_mutex);\n\tret = btrfs_read_sys_array(tree_root);\n\tmutex_unlock(&fs_info->chunk_mutex);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"BTRFS: failed to read the system \"\n\t\t       \"array on %s\\n\", sb->s_id);\n\t\tgoto fail_sb_buffer;\n\t}\n\n\tgeneration = btrfs_super_chunk_root_generation(disk_super);\n\n\t__setup_root(nodesize, sectorsize, stripesize, chunk_root,\n\t\t     fs_info, BTRFS_CHUNK_TREE_OBJECTID);\n\n\tchunk_root->node = read_tree_block(chunk_root,\n\t\t\t\t\t   btrfs_super_chunk_root(disk_super),\n\t\t\t\t\t   generation);\n\tif (!chunk_root->node ||\n\t    !test_bit(EXTENT_BUFFER_UPTODATE, &chunk_root->node->bflags)) {\n\t\tprintk(KERN_ERR \"BTRFS: failed to read chunk root on %s\\n\",\n\t\t       sb->s_id);\n\t\tgoto fail_tree_roots;\n\t}\n\tbtrfs_set_root_node(&chunk_root->root_item, chunk_root->node);\n\tchunk_root->commit_root = btrfs_root_node(chunk_root);\n\n\tread_extent_buffer(chunk_root->node, fs_info->chunk_tree_uuid,\n\t   btrfs_header_chunk_tree_uuid(chunk_root->node), BTRFS_UUID_SIZE);\n\n\tret = btrfs_read_chunk_tree(chunk_root);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"BTRFS: failed to read chunk tree on %s\\n\",\n\t\t       sb->s_id);\n\t\tgoto fail_tree_roots;\n\t}\n\n\t/*\n\t * keep the device that is marked to be the target device for the\n\t * dev_replace procedure\n\t */\n\tbtrfs_close_extra_devices(fs_info, fs_devices, 0);\n\n\tif (!fs_devices->latest_bdev) {\n\t\tprintk(KERN_ERR \"BTRFS: failed to read devices on %s\\n\",\n\t\t       sb->s_id);\n\t\tgoto fail_tree_roots;\n\t}\n\nretry_root_backup:\n\tgeneration = btrfs_super_generation(disk_super);\n\n\ttree_root->node = read_tree_block(tree_root,\n\t\t\t\t\t  btrfs_super_root(disk_super),\n\t\t\t\t\t  generation);\n\tif (!tree_root->node ||\n\t    !test_bit(EXTENT_BUFFER_UPTODATE, &tree_root->node->bflags)) {\n\t\tprintk(KERN_WARNING \"BTRFS: failed to read tree root on %s\\n\",\n\t\t       sb->s_id);\n\n\t\tgoto recovery_tree_root;\n\t}\n\n\tbtrfs_set_root_node(&tree_root->root_item, tree_root->node);\n\ttree_root->commit_root = btrfs_root_node(tree_root);\n\tbtrfs_set_root_refs(&tree_root->root_item, 1);\n\n\tlocation.objectid = BTRFS_EXTENT_TREE_OBJECTID;\n\tlocation.type = BTRFS_ROOT_ITEM_KEY;\n\tlocation.offset = 0;\n\n\textent_root = btrfs_read_tree_root(tree_root, &location);\n\tif (IS_ERR(extent_root)) {\n\t\tret = PTR_ERR(extent_root);\n\t\tgoto recovery_tree_root;\n\t}\n\tset_bit(BTRFS_ROOT_TRACK_DIRTY, &extent_root->state);\n\tfs_info->extent_root = extent_root;\n\n\tlocation.objectid = BTRFS_DEV_TREE_OBJECTID;\n\tdev_root = btrfs_read_tree_root(tree_root, &location);\n\tif (IS_ERR(dev_root)) {\n\t\tret = PTR_ERR(dev_root);\n\t\tgoto recovery_tree_root;\n\t}\n\tset_bit(BTRFS_ROOT_TRACK_DIRTY, &dev_root->state);\n\tfs_info->dev_root = dev_root;\n\tbtrfs_init_devices_late(fs_info);\n\n\tlocation.objectid = BTRFS_CSUM_TREE_OBJECTID;\n\tcsum_root = btrfs_read_tree_root(tree_root, &location);\n\tif (IS_ERR(csum_root)) {\n\t\tret = PTR_ERR(csum_root);\n\t\tgoto recovery_tree_root;\n\t}\n\tset_bit(BTRFS_ROOT_TRACK_DIRTY, &csum_root->state);\n\tfs_info->csum_root = csum_root;\n\n\tlocation.objectid = BTRFS_QUOTA_TREE_OBJECTID;\n\tquota_root = btrfs_read_tree_root(tree_root, &location);\n\tif (!IS_ERR(quota_root)) {\n\t\tset_bit(BTRFS_ROOT_TRACK_DIRTY, &quota_root->state);\n\t\tfs_info->quota_enabled = 1;\n\t\tfs_info->pending_quota_state = 1;\n\t\tfs_info->quota_root = quota_root;\n\t}\n\n\tlocation.objectid = BTRFS_UUID_TREE_OBJECTID;\n\tuuid_root = btrfs_read_tree_root(tree_root, &location);\n\tif (IS_ERR(uuid_root)) {\n\t\tret = PTR_ERR(uuid_root);\n\t\tif (ret != -ENOENT)\n\t\t\tgoto recovery_tree_root;\n\t\tcreate_uuid_tree = true;\n\t\tcheck_uuid_tree = false;\n\t} else {\n\t\tset_bit(BTRFS_ROOT_TRACK_DIRTY, &uuid_root->state);\n\t\tfs_info->uuid_root = uuid_root;\n\t\tcreate_uuid_tree = false;\n\t\tcheck_uuid_tree =\n\t\t    generation != btrfs_super_uuid_tree_generation(disk_super);\n\t}\n\n\tfs_info->generation = generation;\n\tfs_info->last_trans_committed = generation;\n\n\tret = btrfs_recover_balance(fs_info);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"BTRFS: failed to recover balance\\n\");\n\t\tgoto fail_block_groups;\n\t}\n\n\tret = btrfs_init_dev_stats(fs_info);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"BTRFS: failed to init dev_stats: %d\\n\",\n\t\t       ret);\n\t\tgoto fail_block_groups;\n\t}\n\n\tret = btrfs_init_dev_replace(fs_info);\n\tif (ret) {\n\t\tpr_err(\"BTRFS: failed to init dev_replace: %d\\n\", ret);\n\t\tgoto fail_block_groups;\n\t}\n\n\tbtrfs_close_extra_devices(fs_info, fs_devices, 1);\n\n\tret = btrfs_sysfs_add_one(fs_info);\n\tif (ret) {\n\t\tpr_err(\"BTRFS: failed to init sysfs interface: %d\\n\", ret);\n\t\tgoto fail_block_groups;\n\t}\n\n\tret = btrfs_init_space_info(fs_info);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"BTRFS: Failed to initial space info: %d\\n\", ret);\n\t\tgoto fail_sysfs;\n\t}\n\n\tret = btrfs_read_block_groups(extent_root);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"BTRFS: Failed to read block groups: %d\\n\", ret);\n\t\tgoto fail_sysfs;\n\t}\n\tfs_info->num_tolerated_disk_barrier_failures =\n\t\tbtrfs_calc_num_tolerated_disk_barrier_failures(fs_info);\n\tif (fs_info->fs_devices->missing_devices >\n\t     fs_info->num_tolerated_disk_barrier_failures &&\n\t    !(sb->s_flags & MS_RDONLY)) {\n\t\tprintk(KERN_WARNING \"BTRFS: \"\n\t\t\t\"too many missing devices, writeable mount is not allowed\\n\");\n\t\tgoto fail_sysfs;\n\t}\n\n\tfs_info->cleaner_kthread = kthread_run(cleaner_kthread, tree_root,\n\t\t\t\t\t       \"btrfs-cleaner\");\n\tif (IS_ERR(fs_info->cleaner_kthread))\n\t\tgoto fail_sysfs;\n\n\tfs_info->transaction_kthread = kthread_run(transaction_kthread,\n\t\t\t\t\t\t   tree_root,\n\t\t\t\t\t\t   \"btrfs-transaction\");\n\tif (IS_ERR(fs_info->transaction_kthread))\n\t\tgoto fail_cleaner;\n\n\tif (!btrfs_test_opt(tree_root, SSD) &&\n\t    !btrfs_test_opt(tree_root, NOSSD) &&\n\t    !fs_info->fs_devices->rotating) {\n\t\tprintk(KERN_INFO \"BTRFS: detected SSD devices, enabling SSD \"\n\t\t       \"mode\\n\");\n\t\tbtrfs_set_opt(fs_info->mount_opt, SSD);\n\t}\n\n\t/*\n\t * Mount does not set all options immediatelly, we can do it now and do\n\t * not have to wait for transaction commit\n\t */\n\tbtrfs_apply_pending_changes(fs_info);\n\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_test_opt(tree_root, CHECK_INTEGRITY)) {\n\t\tret = btrfsic_mount(tree_root, fs_devices,\n\t\t\t\t    btrfs_test_opt(tree_root,\n\t\t\t\t\tCHECK_INTEGRITY_INCLUDING_EXTENT_DATA) ?\n\t\t\t\t    1 : 0,\n\t\t\t\t    fs_info->check_integrity_print_mask);\n\t\tif (ret)\n\t\t\tprintk(KERN_WARNING \"BTRFS: failed to initialize\"\n\t\t\t       \" integrity check module %s\\n\", sb->s_id);\n\t}\n#endif\n\tret = btrfs_read_qgroup_config(fs_info);\n\tif (ret)\n\t\tgoto fail_trans_kthread;\n\n\t/* do not make disk changes in broken FS */\n\tif (btrfs_super_log_root(disk_super) != 0) {\n\t\tu64 bytenr = btrfs_super_log_root(disk_super);\n\n\t\tif (fs_devices->rw_devices == 0) {\n\t\t\tprintk(KERN_WARNING \"BTRFS: log replay required \"\n\t\t\t       \"on RO media\\n\");\n\t\t\terr = -EIO;\n\t\t\tgoto fail_qgroup;\n\t\t}\n\n\t\tlog_tree_root = btrfs_alloc_root(fs_info);\n\t\tif (!log_tree_root) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto fail_qgroup;\n\t\t}\n\n\t\t__setup_root(nodesize, sectorsize, stripesize,\n\t\t\t     log_tree_root, fs_info, BTRFS_TREE_LOG_OBJECTID);\n\n\t\tlog_tree_root->node = read_tree_block(tree_root, bytenr,\n\t\t\t\t\t\t      generation + 1);\n\t\tif (!log_tree_root->node ||\n\t\t    !extent_buffer_uptodate(log_tree_root->node)) {\n\t\t\tprintk(KERN_ERR \"BTRFS: failed to read log tree\\n\");\n\t\t\tfree_extent_buffer(log_tree_root->node);\n\t\t\tkfree(log_tree_root);\n\t\t\tgoto fail_qgroup;\n\t\t}\n\t\t/* returns with log_tree_root freed on success */\n\t\tret = btrfs_recover_log_trees(log_tree_root);\n\t\tif (ret) {\n\t\t\tbtrfs_error(tree_root->fs_info, ret,\n\t\t\t\t    \"Failed to recover log tree\");\n\t\t\tfree_extent_buffer(log_tree_root->node);\n\t\t\tkfree(log_tree_root);\n\t\t\tgoto fail_qgroup;\n\t\t}\n\n\t\tif (sb->s_flags & MS_RDONLY) {\n\t\t\tret = btrfs_commit_super(tree_root);\n\t\t\tif (ret)\n\t\t\t\tgoto fail_qgroup;\n\t\t}\n\t}\n\n\tret = btrfs_find_orphan_roots(tree_root);\n\tif (ret)\n\t\tgoto fail_qgroup;\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tret = btrfs_cleanup_fs_roots(fs_info);\n\t\tif (ret)\n\t\t\tgoto fail_qgroup;\n\n\t\tmutex_lock(&fs_info->cleaner_mutex);\n\t\tret = btrfs_recover_relocation(tree_root);\n\t\tmutex_unlock(&fs_info->cleaner_mutex);\n\t\tif (ret < 0) {\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"BTRFS: failed to recover relocation\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto fail_qgroup;\n\t\t}\n\t}\n\n\tlocation.objectid = BTRFS_FS_TREE_OBJECTID;\n\tlocation.type = BTRFS_ROOT_ITEM_KEY;\n\tlocation.offset = 0;\n\n\tfs_info->fs_root = btrfs_read_fs_root_no_name(fs_info, &location);\n\tif (IS_ERR(fs_info->fs_root)) {\n\t\terr = PTR_ERR(fs_info->fs_root);\n\t\tgoto fail_qgroup;\n\t}\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tdown_read(&fs_info->cleanup_work_sem);\n\tif ((ret = btrfs_orphan_cleanup(fs_info->fs_root)) ||\n\t    (ret = btrfs_orphan_cleanup(fs_info->tree_root))) {\n\t\tup_read(&fs_info->cleanup_work_sem);\n\t\tclose_ctree(tree_root);\n\t\treturn ret;\n\t}\n\tup_read(&fs_info->cleanup_work_sem);\n\n\tret = btrfs_resume_balance_async(fs_info);\n\tif (ret) {\n\t\tprintk(KERN_WARNING \"BTRFS: failed to resume balance\\n\");\n\t\tclose_ctree(tree_root);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_resume_dev_replace_async(fs_info);\n\tif (ret) {\n\t\tpr_warn(\"BTRFS: failed to resume dev_replace\\n\");\n\t\tclose_ctree(tree_root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_qgroup_rescan_resume(fs_info);\n\n\tif (create_uuid_tree) {\n\t\tpr_info(\"BTRFS: creating UUID tree\\n\");\n\t\tret = btrfs_create_uuid_tree(fs_info);\n\t\tif (ret) {\n\t\t\tpr_warn(\"BTRFS: failed to create the UUID tree %d\\n\",\n\t\t\t\tret);\n\t\t\tclose_ctree(tree_root);\n\t\t\treturn ret;\n\t\t}\n\t} else if (check_uuid_tree ||\n\t\t   btrfs_test_opt(tree_root, RESCAN_UUID_TREE)) {\n\t\tpr_info(\"BTRFS: checking UUID tree\\n\");\n\t\tret = btrfs_check_uuid_tree(fs_info);\n\t\tif (ret) {\n\t\t\tpr_warn(\"BTRFS: failed to check the UUID tree %d\\n\",\n\t\t\t\tret);\n\t\t\tclose_ctree(tree_root);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tfs_info->update_uuid_tree_gen = 1;\n\t}\n\n\tfs_info->open = 1;\n\n\treturn 0;\n\nfail_qgroup:\n\tbtrfs_free_qgroup_config(fs_info);\nfail_trans_kthread:\n\tkthread_stop(fs_info->transaction_kthread);\n\tbtrfs_cleanup_transaction(fs_info->tree_root);\n\tbtrfs_free_fs_roots(fs_info);\nfail_cleaner:\n\tkthread_stop(fs_info->cleaner_kthread);\n\n\t/*\n\t * make sure we're done with the btree inode before we stop our\n\t * kthreads\n\t */\n\tfilemap_write_and_wait(fs_info->btree_inode->i_mapping);\n\nfail_sysfs:\n\tbtrfs_sysfs_remove_one(fs_info);\n\nfail_block_groups:\n\tbtrfs_put_block_group_cache(fs_info);\n\tbtrfs_free_block_groups(fs_info);\n\nfail_tree_roots:\n\tfree_root_pointers(fs_info, 1);\n\tinvalidate_inode_pages2(fs_info->btree_inode->i_mapping);\n\nfail_sb_buffer:\n\tbtrfs_stop_all_workers(fs_info);\nfail_alloc:\nfail_iput:\n\tbtrfs_mapping_tree_free(&fs_info->mapping_tree);\n\n\tiput(fs_info->btree_inode);\nfail_bio_counter:\n\tpercpu_counter_destroy(&fs_info->bio_counter);\nfail_delalloc_bytes:\n\tpercpu_counter_destroy(&fs_info->delalloc_bytes);\nfail_dirty_metadata_bytes:\n\tpercpu_counter_destroy(&fs_info->dirty_metadata_bytes);\nfail_bdi:\n\tbdi_destroy(&fs_info->bdi);\nfail_srcu:\n\tcleanup_srcu_struct(&fs_info->subvol_srcu);\nfail:\n\tbtrfs_free_stripe_hash_table(fs_info);\n\tbtrfs_close_devices(fs_info->fs_devices);\n\treturn err;\n\nrecovery_tree_root:\n\tif (!btrfs_test_opt(tree_root, RECOVERY))\n\t\tgoto fail_tree_roots;\n\n\tfree_root_pointers(fs_info, 0);\n\n\t/* don't use the log in recovery mode, it won't be valid */\n\tbtrfs_set_super_log_root(disk_super, 0);\n\n\t/* we can't trust the free space cache either */\n\tbtrfs_set_opt(fs_info->mount_opt, CLEAR_CACHE);\n\n\tret = next_root_backup(fs_info, fs_info->super_copy,\n\t\t\t       &num_backups_tried, &backup_index);\n\tif (ret == -1)\n\t\tgoto fail_block_groups;\n\tgoto retry_root_backup;\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct extent_io_ops btree_extent_io_ops;",
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_destroy_pinned_extent(struct btrfs_root *root,\n\t\t\t\t       struct extent_io_tree *pinned_extents);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);",
            "static const struct address_space_operations btree_aops = {\n\t.readpage\t= btree_readpage,\n\t.writepages\t= btree_writepages,\n\t.releasepage\t= btree_releasepage,\n\t.invalidatepage = btree_invalidatepage,\n#ifdef CONFIG_MIGRATION\n\t.migratepage\t= btree_migratepage,\n#endif\n\t.set_page_dirty = btree_set_page_dirty,\n};",
            "static struct extent_io_ops btree_extent_io_ops = {\n\t.readpage_end_io_hook = btree_readpage_end_io_hook,\n\t.readpage_io_failed_hook = btree_io_failed_hook,\n\t.submit_bio_hook = btree_submit_bio_hook,\n\t/* note we're sharing with inode.c for the merge bio hook */\n\t.merge_bio_hook = btrfs_merge_bio_hook,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic struct extent_io_ops btree_extent_io_ops;\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_destroy_pinned_extent(struct btrfs_root *root,\n\t\t\t\t       struct extent_io_tree *pinned_extents);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\nstatic const struct address_space_operations btree_aops = {\n\t.readpage\t= btree_readpage,\n\t.writepages\t= btree_writepages,\n\t.releasepage\t= btree_releasepage,\n\t.invalidatepage = btree_invalidatepage,\n#ifdef CONFIG_MIGRATION\n\t.migratepage\t= btree_migratepage,\n#endif\n\t.set_page_dirty = btree_set_page_dirty,\n};\nstatic struct extent_io_ops btree_extent_io_ops = {\n\t.readpage_end_io_hook = btree_readpage_end_io_hook,\n\t.readpage_io_failed_hook = btree_io_failed_hook,\n\t.submit_bio_hook = btree_submit_bio_hook,\n\t/* note we're sharing with inode.c for the merge bio hook */\n\t.merge_bio_hook = btrfs_merge_bio_hook,\n};\n\nint open_ctree(struct super_block *sb,\n\t       struct btrfs_fs_devices *fs_devices,\n\t       char *options)\n{\n\tu32 sectorsize;\n\tu32 nodesize;\n\tu32 stripesize;\n\tu64 generation;\n\tu64 features;\n\tstruct btrfs_key location;\n\tstruct buffer_head *bh;\n\tstruct btrfs_super_block *disk_super;\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(sb);\n\tstruct btrfs_root *tree_root;\n\tstruct btrfs_root *extent_root;\n\tstruct btrfs_root *csum_root;\n\tstruct btrfs_root *chunk_root;\n\tstruct btrfs_root *dev_root;\n\tstruct btrfs_root *quota_root;\n\tstruct btrfs_root *uuid_root;\n\tstruct btrfs_root *log_tree_root;\n\tint ret;\n\tint err = -EINVAL;\n\tint num_backups_tried = 0;\n\tint backup_index = 0;\n\tint max_active;\n\tint flags = WQ_MEM_RECLAIM | WQ_FREEZABLE | WQ_UNBOUND;\n\tbool create_uuid_tree;\n\tbool check_uuid_tree;\n\n\ttree_root = fs_info->tree_root = btrfs_alloc_root(fs_info);\n\tchunk_root = fs_info->chunk_root = btrfs_alloc_root(fs_info);\n\tif (!tree_root || !chunk_root) {\n\t\terr = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tret = init_srcu_struct(&fs_info->subvol_srcu);\n\tif (ret) {\n\t\terr = ret;\n\t\tgoto fail;\n\t}\n\n\tret = setup_bdi(fs_info, &fs_info->bdi);\n\tif (ret) {\n\t\terr = ret;\n\t\tgoto fail_srcu;\n\t}\n\n\tret = percpu_counter_init(&fs_info->dirty_metadata_bytes, 0, GFP_KERNEL);\n\tif (ret) {\n\t\terr = ret;\n\t\tgoto fail_bdi;\n\t}\n\tfs_info->dirty_metadata_batch = PAGE_CACHE_SIZE *\n\t\t\t\t\t(1 + ilog2(nr_cpu_ids));\n\n\tret = percpu_counter_init(&fs_info->delalloc_bytes, 0, GFP_KERNEL);\n\tif (ret) {\n\t\terr = ret;\n\t\tgoto fail_dirty_metadata_bytes;\n\t}\n\n\tret = percpu_counter_init(&fs_info->bio_counter, 0, GFP_KERNEL);\n\tif (ret) {\n\t\terr = ret;\n\t\tgoto fail_delalloc_bytes;\n\t}\n\n\tfs_info->btree_inode = new_inode(sb);\n\tif (!fs_info->btree_inode) {\n\t\terr = -ENOMEM;\n\t\tgoto fail_bio_counter;\n\t}\n\n\tmapping_set_gfp_mask(fs_info->btree_inode->i_mapping, GFP_NOFS);\n\n\tINIT_RADIX_TREE(&fs_info->fs_roots_radix, GFP_ATOMIC);\n\tINIT_RADIX_TREE(&fs_info->buffer_radix, GFP_ATOMIC);\n\tINIT_LIST_HEAD(&fs_info->trans_list);\n\tINIT_LIST_HEAD(&fs_info->dead_roots);\n\tINIT_LIST_HEAD(&fs_info->delayed_iputs);\n\tINIT_LIST_HEAD(&fs_info->delalloc_roots);\n\tINIT_LIST_HEAD(&fs_info->caching_block_groups);\n\tspin_lock_init(&fs_info->delalloc_root_lock);\n\tspin_lock_init(&fs_info->trans_lock);\n\tspin_lock_init(&fs_info->fs_roots_radix_lock);\n\tspin_lock_init(&fs_info->delayed_iput_lock);\n\tspin_lock_init(&fs_info->defrag_inodes_lock);\n\tspin_lock_init(&fs_info->free_chunk_lock);\n\tspin_lock_init(&fs_info->tree_mod_seq_lock);\n\tspin_lock_init(&fs_info->super_lock);\n\tspin_lock_init(&fs_info->qgroup_op_lock);\n\tspin_lock_init(&fs_info->buffer_lock);\n\tspin_lock_init(&fs_info->unused_bgs_lock);\n\tmutex_init(&fs_info->unused_bg_unpin_mutex);\n\trwlock_init(&fs_info->tree_mod_log_lock);\n\tmutex_init(&fs_info->reloc_mutex);\n\tmutex_init(&fs_info->delalloc_root_mutex);\n\tseqlock_init(&fs_info->profiles_lock);\n\n\tinit_completion(&fs_info->kobj_unregister);\n\tINIT_LIST_HEAD(&fs_info->dirty_cowonly_roots);\n\tINIT_LIST_HEAD(&fs_info->space_info);\n\tINIT_LIST_HEAD(&fs_info->tree_mod_seq_list);\n\tINIT_LIST_HEAD(&fs_info->unused_bgs);\n\tbtrfs_mapping_init(&fs_info->mapping_tree);\n\tbtrfs_init_block_rsv(&fs_info->global_block_rsv,\n\t\t\t     BTRFS_BLOCK_RSV_GLOBAL);\n\tbtrfs_init_block_rsv(&fs_info->delalloc_block_rsv,\n\t\t\t     BTRFS_BLOCK_RSV_DELALLOC);\n\tbtrfs_init_block_rsv(&fs_info->trans_block_rsv, BTRFS_BLOCK_RSV_TRANS);\n\tbtrfs_init_block_rsv(&fs_info->chunk_block_rsv, BTRFS_BLOCK_RSV_CHUNK);\n\tbtrfs_init_block_rsv(&fs_info->empty_block_rsv, BTRFS_BLOCK_RSV_EMPTY);\n\tbtrfs_init_block_rsv(&fs_info->delayed_block_rsv,\n\t\t\t     BTRFS_BLOCK_RSV_DELOPS);\n\tatomic_set(&fs_info->nr_async_submits, 0);\n\tatomic_set(&fs_info->async_delalloc_pages, 0);\n\tatomic_set(&fs_info->async_submit_draining, 0);\n\tatomic_set(&fs_info->nr_async_bios, 0);\n\tatomic_set(&fs_info->defrag_running, 0);\n\tatomic_set(&fs_info->qgroup_op_seq, 0);\n\tatomic64_set(&fs_info->tree_mod_seq, 0);\n\tfs_info->sb = sb;\n\tfs_info->max_inline = BTRFS_DEFAULT_MAX_INLINE;\n\tfs_info->metadata_ratio = 0;\n\tfs_info->defrag_inodes = RB_ROOT;\n\tfs_info->free_chunk_space = 0;\n\tfs_info->tree_mod_log = RB_ROOT;\n\tfs_info->commit_interval = BTRFS_DEFAULT_COMMIT_INTERVAL;\n\tfs_info->avg_delayed_ref_runtime = div64_u64(NSEC_PER_SEC, 64);\n\t/* readahead state */\n\tINIT_RADIX_TREE(&fs_info->reada_tree, GFP_NOFS & ~__GFP_WAIT);\n\tspin_lock_init(&fs_info->reada_lock);\n\n\tfs_info->thread_pool_size = min_t(unsigned long,\n\t\t\t\t\t  num_online_cpus() + 2, 8);\n\n\tINIT_LIST_HEAD(&fs_info->ordered_roots);\n\tspin_lock_init(&fs_info->ordered_root_lock);\n\tfs_info->delayed_root = kmalloc(sizeof(struct btrfs_delayed_root),\n\t\t\t\t\tGFP_NOFS);\n\tif (!fs_info->delayed_root) {\n\t\terr = -ENOMEM;\n\t\tgoto fail_iput;\n\t}\n\tbtrfs_init_delayed_root(fs_info->delayed_root);\n\n\tmutex_init(&fs_info->scrub_lock);\n\tatomic_set(&fs_info->scrubs_running, 0);\n\tatomic_set(&fs_info->scrub_pause_req, 0);\n\tatomic_set(&fs_info->scrubs_paused, 0);\n\tatomic_set(&fs_info->scrub_cancel_req, 0);\n\tinit_waitqueue_head(&fs_info->replace_wait);\n\tinit_waitqueue_head(&fs_info->scrub_pause_wait);\n\tfs_info->scrub_workers_refcnt = 0;\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tfs_info->check_integrity_print_mask = 0;\n#endif\n\n\tspin_lock_init(&fs_info->balance_lock);\n\tmutex_init(&fs_info->balance_mutex);\n\tatomic_set(&fs_info->balance_running, 0);\n\tatomic_set(&fs_info->balance_pause_req, 0);\n\tatomic_set(&fs_info->balance_cancel_req, 0);\n\tfs_info->balance_ctl = NULL;\n\tinit_waitqueue_head(&fs_info->balance_wait_q);\n\tbtrfs_init_async_reclaim_work(&fs_info->async_reclaim_work);\n\n\tsb->s_blocksize = 4096;\n\tsb->s_blocksize_bits = blksize_bits(4096);\n\tsb->s_bdi = &fs_info->bdi;\n\n\tfs_info->btree_inode->i_ino = BTRFS_BTREE_INODE_OBJECTID;\n\tset_nlink(fs_info->btree_inode, 1);\n\t/*\n\t * we set the i_size on the btree inode to the max possible int.\n\t * the real end of the address space is determined by all of\n\t * the devices in the system\n\t */\n\tfs_info->btree_inode->i_size = OFFSET_MAX;\n\tfs_info->btree_inode->i_mapping->a_ops = &btree_aops;\n\n\tRB_CLEAR_NODE(&BTRFS_I(fs_info->btree_inode)->rb_node);\n\textent_io_tree_init(&BTRFS_I(fs_info->btree_inode)->io_tree,\n\t\t\t     fs_info->btree_inode->i_mapping);\n\tBTRFS_I(fs_info->btree_inode)->io_tree.track_uptodate = 0;\n\textent_map_tree_init(&BTRFS_I(fs_info->btree_inode)->extent_tree);\n\n\tBTRFS_I(fs_info->btree_inode)->io_tree.ops = &btree_extent_io_ops;\n\n\tBTRFS_I(fs_info->btree_inode)->root = tree_root;\n\tmemset(&BTRFS_I(fs_info->btree_inode)->location, 0,\n\t       sizeof(struct btrfs_key));\n\tset_bit(BTRFS_INODE_DUMMY,\n\t\t&BTRFS_I(fs_info->btree_inode)->runtime_flags);\n\tbtrfs_insert_inode_hash(fs_info->btree_inode);\n\n\tspin_lock_init(&fs_info->block_group_cache_lock);\n\tfs_info->block_group_cache_tree = RB_ROOT;\n\tfs_info->first_logical_byte = (u64)-1;\n\n\textent_io_tree_init(&fs_info->freed_extents[0],\n\t\t\t     fs_info->btree_inode->i_mapping);\n\textent_io_tree_init(&fs_info->freed_extents[1],\n\t\t\t     fs_info->btree_inode->i_mapping);\n\tfs_info->pinned_extents = &fs_info->freed_extents[0];\n\tfs_info->do_barriers = 1;\n\n\n\tmutex_init(&fs_info->ordered_operations_mutex);\n\tmutex_init(&fs_info->ordered_extent_flush_mutex);\n\tmutex_init(&fs_info->tree_log_mutex);\n\tmutex_init(&fs_info->chunk_mutex);\n\tmutex_init(&fs_info->transaction_kthread_mutex);\n\tmutex_init(&fs_info->cleaner_mutex);\n\tmutex_init(&fs_info->volume_mutex);\n\tinit_rwsem(&fs_info->commit_root_sem);\n\tinit_rwsem(&fs_info->cleanup_work_sem);\n\tinit_rwsem(&fs_info->subvol_sem);\n\tsema_init(&fs_info->uuid_tree_rescan_sem, 1);\n\tfs_info->dev_replace.lock_owner = 0;\n\tatomic_set(&fs_info->dev_replace.nesting_level, 0);\n\tmutex_init(&fs_info->dev_replace.lock_finishing_cancel_unmount);\n\tmutex_init(&fs_info->dev_replace.lock_management_lock);\n\tmutex_init(&fs_info->dev_replace.lock);\n\n\tspin_lock_init(&fs_info->qgroup_lock);\n\tmutex_init(&fs_info->qgroup_ioctl_lock);\n\tfs_info->qgroup_tree = RB_ROOT;\n\tfs_info->qgroup_op_tree = RB_ROOT;\n\tINIT_LIST_HEAD(&fs_info->dirty_qgroups);\n\tfs_info->qgroup_seq = 1;\n\tfs_info->quota_enabled = 0;\n\tfs_info->pending_quota_state = 0;\n\tfs_info->qgroup_ulist = NULL;\n\tmutex_init(&fs_info->qgroup_rescan_lock);\n\n\tbtrfs_init_free_cluster(&fs_info->meta_alloc_cluster);\n\tbtrfs_init_free_cluster(&fs_info->data_alloc_cluster);\n\n\tinit_waitqueue_head(&fs_info->transaction_throttle);\n\tinit_waitqueue_head(&fs_info->transaction_wait);\n\tinit_waitqueue_head(&fs_info->transaction_blocked_wait);\n\tinit_waitqueue_head(&fs_info->async_submit_wait);\n\n\tINIT_LIST_HEAD(&fs_info->pinned_chunks);\n\n\tret = btrfs_alloc_stripe_hash_table(fs_info);\n\tif (ret) {\n\t\terr = ret;\n\t\tgoto fail_alloc;\n\t}\n\n\t__setup_root(4096, 4096, 4096, tree_root,\n\t\t     fs_info, BTRFS_ROOT_TREE_OBJECTID);\n\n\tinvalidate_bdev(fs_devices->latest_bdev);\n\n\t/*\n\t * Read super block and check the signature bytes only\n\t */\n\tbh = btrfs_read_dev_super(fs_devices->latest_bdev);\n\tif (!bh) {\n\t\terr = -EINVAL;\n\t\tgoto fail_alloc;\n\t}\n\n\t/*\n\t * We want to check superblock checksum, the type is stored inside.\n\t * Pass the whole disk block of size BTRFS_SUPER_INFO_SIZE (4k).\n\t */\n\tif (btrfs_check_super_csum(bh->b_data)) {\n\t\tprintk(KERN_ERR \"BTRFS: superblock checksum mismatch\\n\");\n\t\terr = -EINVAL;\n\t\tgoto fail_alloc;\n\t}\n\n\t/*\n\t * super_copy is zeroed at allocation time and we never touch the\n\t * following bytes up to INFO_SIZE, the checksum is calculated from\n\t * the whole block of INFO_SIZE\n\t */\n\tmemcpy(fs_info->super_copy, bh->b_data, sizeof(*fs_info->super_copy));\n\tmemcpy(fs_info->super_for_commit, fs_info->super_copy,\n\t       sizeof(*fs_info->super_for_commit));\n\tbrelse(bh);\n\n\tmemcpy(fs_info->fsid, fs_info->super_copy->fsid, BTRFS_FSID_SIZE);\n\n\tret = btrfs_check_super_valid(fs_info, sb->s_flags & MS_RDONLY);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"BTRFS: superblock contains fatal errors\\n\");\n\t\terr = -EINVAL;\n\t\tgoto fail_alloc;\n\t}\n\n\tdisk_super = fs_info->super_copy;\n\tif (!btrfs_super_root(disk_super))\n\t\tgoto fail_alloc;\n\n\t/* check FS state, whether FS is broken. */\n\tif (btrfs_super_flags(disk_super) & BTRFS_SUPER_FLAG_ERROR)\n\t\tset_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state);\n\n\t/*\n\t * run through our array of backup supers and setup\n\t * our ring pointer to the oldest one\n\t */\n\tgeneration = btrfs_super_generation(disk_super);\n\tfind_oldest_super_backup(fs_info, generation);\n\n\t/*\n\t * In the long term, we'll store the compression type in the super\n\t * block, and it'll be used for per file compression control.\n\t */\n\tfs_info->compress_type = BTRFS_COMPRESS_ZLIB;\n\n\tret = btrfs_parse_options(tree_root, options);\n\tif (ret) {\n\t\terr = ret;\n\t\tgoto fail_alloc;\n\t}\n\n\tfeatures = btrfs_super_incompat_flags(disk_super) &\n\t\t~BTRFS_FEATURE_INCOMPAT_SUPP;\n\tif (features) {\n\t\tprintk(KERN_ERR \"BTRFS: couldn't mount because of \"\n\t\t       \"unsupported optional features (%Lx).\\n\",\n\t\t       features);\n\t\terr = -EINVAL;\n\t\tgoto fail_alloc;\n\t}\n\n\t/*\n\t * Leafsize and nodesize were always equal, this is only a sanity check.\n\t */\n\tif (le32_to_cpu(disk_super->__unused_leafsize) !=\n\t    btrfs_super_nodesize(disk_super)) {\n\t\tprintk(KERN_ERR \"BTRFS: couldn't mount because metadata \"\n\t\t       \"blocksizes don't match.  node %d leaf %d\\n\",\n\t\t       btrfs_super_nodesize(disk_super),\n\t\t       le32_to_cpu(disk_super->__unused_leafsize));\n\t\terr = -EINVAL;\n\t\tgoto fail_alloc;\n\t}\n\tif (btrfs_super_nodesize(disk_super) > BTRFS_MAX_METADATA_BLOCKSIZE) {\n\t\tprintk(KERN_ERR \"BTRFS: couldn't mount because metadata \"\n\t\t       \"blocksize (%d) was too large\\n\",\n\t\t       btrfs_super_nodesize(disk_super));\n\t\terr = -EINVAL;\n\t\tgoto fail_alloc;\n\t}\n\n\tfeatures = btrfs_super_incompat_flags(disk_super);\n\tfeatures |= BTRFS_FEATURE_INCOMPAT_MIXED_BACKREF;\n\tif (tree_root->fs_info->compress_type == BTRFS_COMPRESS_LZO)\n\t\tfeatures |= BTRFS_FEATURE_INCOMPAT_COMPRESS_LZO;\n\n\tif (features & BTRFS_FEATURE_INCOMPAT_SKINNY_METADATA)\n\t\tprintk(KERN_INFO \"BTRFS: has skinny extents\\n\");\n\n\t/*\n\t * flag our filesystem as having big metadata blocks if\n\t * they are bigger than the page size\n\t */\n\tif (btrfs_super_nodesize(disk_super) > PAGE_CACHE_SIZE) {\n\t\tif (!(features & BTRFS_FEATURE_INCOMPAT_BIG_METADATA))\n\t\t\tprintk(KERN_INFO \"BTRFS: flagging fs with big metadata feature\\n\");\n\t\tfeatures |= BTRFS_FEATURE_INCOMPAT_BIG_METADATA;\n\t}\n\n\tnodesize = btrfs_super_nodesize(disk_super);\n\tsectorsize = btrfs_super_sectorsize(disk_super);\n\tstripesize = btrfs_super_stripesize(disk_super);\n\tfs_info->dirty_metadata_batch = nodesize * (1 + ilog2(nr_cpu_ids));\n\tfs_info->delalloc_batch = sectorsize * 512 * (1 + ilog2(nr_cpu_ids));\n\n\t/*\n\t * mixed block groups end up with duplicate but slightly offset\n\t * extent buffers for the same range.  It leads to corruptions\n\t */\n\tif ((features & BTRFS_FEATURE_INCOMPAT_MIXED_GROUPS) &&\n\t    (sectorsize != nodesize)) {\n\t\tprintk(KERN_ERR \"BTRFS: unequal leaf/node/sector sizes \"\n\t\t\t\t\"are not allowed for mixed block groups on %s\\n\",\n\t\t\t\tsb->s_id);\n\t\tgoto fail_alloc;\n\t}\n\n\t/*\n\t * Needn't use the lock because there is no other task which will\n\t * update the flag.\n\t */\n\tbtrfs_set_super_incompat_flags(disk_super, features);\n\n\tfeatures = btrfs_super_compat_ro_flags(disk_super) &\n\t\t~BTRFS_FEATURE_COMPAT_RO_SUPP;\n\tif (!(sb->s_flags & MS_RDONLY) && features) {\n\t\tprintk(KERN_ERR \"BTRFS: couldn't mount RDWR because of \"\n\t\t       \"unsupported option features (%Lx).\\n\",\n\t\t       features);\n\t\terr = -EINVAL;\n\t\tgoto fail_alloc;\n\t}\n\n\tmax_active = fs_info->thread_pool_size;\n\n\tfs_info->workers =\n\t\tbtrfs_alloc_workqueue(\"worker\", flags | WQ_HIGHPRI,\n\t\t\t\t      max_active, 16);\n\n\tfs_info->delalloc_workers =\n\t\tbtrfs_alloc_workqueue(\"delalloc\", flags, max_active, 2);\n\n\tfs_info->flush_workers =\n\t\tbtrfs_alloc_workqueue(\"flush_delalloc\", flags, max_active, 0);\n\n\tfs_info->caching_workers =\n\t\tbtrfs_alloc_workqueue(\"cache\", flags, max_active, 0);\n\n\t/*\n\t * a higher idle thresh on the submit workers makes it much more\n\t * likely that bios will be send down in a sane order to the\n\t * devices\n\t */\n\tfs_info->submit_workers =\n\t\tbtrfs_alloc_workqueue(\"submit\", flags,\n\t\t\t\t      min_t(u64, fs_devices->num_devices,\n\t\t\t\t\t    max_active), 64);\n\n\tfs_info->fixup_workers =\n\t\tbtrfs_alloc_workqueue(\"fixup\", flags, 1, 0);\n\n\t/*\n\t * endios are largely parallel and should have a very\n\t * low idle thresh\n\t */\n\tfs_info->endio_workers =\n\t\tbtrfs_alloc_workqueue(\"endio\", flags, max_active, 4);\n\tfs_info->endio_meta_workers =\n\t\tbtrfs_alloc_workqueue(\"endio-meta\", flags, max_active, 4);\n\tfs_info->endio_meta_write_workers =\n\t\tbtrfs_alloc_workqueue(\"endio-meta-write\", flags, max_active, 2);\n\tfs_info->endio_raid56_workers =\n\t\tbtrfs_alloc_workqueue(\"endio-raid56\", flags, max_active, 4);\n\tfs_info->endio_repair_workers =\n\t\tbtrfs_alloc_workqueue(\"endio-repair\", flags, 1, 0);\n\tfs_info->rmw_workers =\n\t\tbtrfs_alloc_workqueue(\"rmw\", flags, max_active, 2);\n\tfs_info->endio_write_workers =\n\t\tbtrfs_alloc_workqueue(\"endio-write\", flags, max_active, 2);\n\tfs_info->endio_freespace_worker =\n\t\tbtrfs_alloc_workqueue(\"freespace-write\", flags, max_active, 0);\n\tfs_info->delayed_workers =\n\t\tbtrfs_alloc_workqueue(\"delayed-meta\", flags, max_active, 0);\n\tfs_info->readahead_workers =\n\t\tbtrfs_alloc_workqueue(\"readahead\", flags, max_active, 2);\n\tfs_info->qgroup_rescan_workers =\n\t\tbtrfs_alloc_workqueue(\"qgroup-rescan\", flags, 1, 0);\n\tfs_info->extent_workers =\n\t\tbtrfs_alloc_workqueue(\"extent-refs\", flags,\n\t\t\t\t      min_t(u64, fs_devices->num_devices,\n\t\t\t\t\t    max_active), 8);\n\n\tif (!(fs_info->workers && fs_info->delalloc_workers &&\n\t      fs_info->submit_workers && fs_info->flush_workers &&\n\t      fs_info->endio_workers && fs_info->endio_meta_workers &&\n\t      fs_info->endio_meta_write_workers &&\n\t      fs_info->endio_repair_workers &&\n\t      fs_info->endio_write_workers && fs_info->endio_raid56_workers &&\n\t      fs_info->endio_freespace_worker && fs_info->rmw_workers &&\n\t      fs_info->caching_workers && fs_info->readahead_workers &&\n\t      fs_info->fixup_workers && fs_info->delayed_workers &&\n\t      fs_info->extent_workers &&\n\t      fs_info->qgroup_rescan_workers)) {\n\t\terr = -ENOMEM;\n\t\tgoto fail_sb_buffer;\n\t}\n\n\tfs_info->bdi.ra_pages *= btrfs_super_num_devices(disk_super);\n\tfs_info->bdi.ra_pages = max(fs_info->bdi.ra_pages,\n\t\t\t\t    4 * 1024 * 1024 / PAGE_CACHE_SIZE);\n\n\ttree_root->nodesize = nodesize;\n\ttree_root->sectorsize = sectorsize;\n\ttree_root->stripesize = stripesize;\n\n\tsb->s_blocksize = sectorsize;\n\tsb->s_blocksize_bits = blksize_bits(sectorsize);\n\n\tif (btrfs_super_magic(disk_super) != BTRFS_MAGIC) {\n\t\tprintk(KERN_ERR \"BTRFS: valid FS not found on %s\\n\", sb->s_id);\n\t\tgoto fail_sb_buffer;\n\t}\n\n\tif (sectorsize != PAGE_SIZE) {\n\t\tprintk(KERN_ERR \"BTRFS: incompatible sector size (%lu) \"\n\t\t       \"found on %s\\n\", (unsigned long)sectorsize, sb->s_id);\n\t\tgoto fail_sb_buffer;\n\t}\n\n\tmutex_lock(&fs_info->chunk_mutex);\n\tret = btrfs_read_sys_array(tree_root);\n\tmutex_unlock(&fs_info->chunk_mutex);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"BTRFS: failed to read the system \"\n\t\t       \"array on %s\\n\", sb->s_id);\n\t\tgoto fail_sb_buffer;\n\t}\n\n\tgeneration = btrfs_super_chunk_root_generation(disk_super);\n\n\t__setup_root(nodesize, sectorsize, stripesize, chunk_root,\n\t\t     fs_info, BTRFS_CHUNK_TREE_OBJECTID);\n\n\tchunk_root->node = read_tree_block(chunk_root,\n\t\t\t\t\t   btrfs_super_chunk_root(disk_super),\n\t\t\t\t\t   generation);\n\tif (!chunk_root->node ||\n\t    !test_bit(EXTENT_BUFFER_UPTODATE, &chunk_root->node->bflags)) {\n\t\tprintk(KERN_ERR \"BTRFS: failed to read chunk root on %s\\n\",\n\t\t       sb->s_id);\n\t\tgoto fail_tree_roots;\n\t}\n\tbtrfs_set_root_node(&chunk_root->root_item, chunk_root->node);\n\tchunk_root->commit_root = btrfs_root_node(chunk_root);\n\n\tread_extent_buffer(chunk_root->node, fs_info->chunk_tree_uuid,\n\t   btrfs_header_chunk_tree_uuid(chunk_root->node), BTRFS_UUID_SIZE);\n\n\tret = btrfs_read_chunk_tree(chunk_root);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"BTRFS: failed to read chunk tree on %s\\n\",\n\t\t       sb->s_id);\n\t\tgoto fail_tree_roots;\n\t}\n\n\t/*\n\t * keep the device that is marked to be the target device for the\n\t * dev_replace procedure\n\t */\n\tbtrfs_close_extra_devices(fs_info, fs_devices, 0);\n\n\tif (!fs_devices->latest_bdev) {\n\t\tprintk(KERN_ERR \"BTRFS: failed to read devices on %s\\n\",\n\t\t       sb->s_id);\n\t\tgoto fail_tree_roots;\n\t}\n\nretry_root_backup:\n\tgeneration = btrfs_super_generation(disk_super);\n\n\ttree_root->node = read_tree_block(tree_root,\n\t\t\t\t\t  btrfs_super_root(disk_super),\n\t\t\t\t\t  generation);\n\tif (!tree_root->node ||\n\t    !test_bit(EXTENT_BUFFER_UPTODATE, &tree_root->node->bflags)) {\n\t\tprintk(KERN_WARNING \"BTRFS: failed to read tree root on %s\\n\",\n\t\t       sb->s_id);\n\n\t\tgoto recovery_tree_root;\n\t}\n\n\tbtrfs_set_root_node(&tree_root->root_item, tree_root->node);\n\ttree_root->commit_root = btrfs_root_node(tree_root);\n\tbtrfs_set_root_refs(&tree_root->root_item, 1);\n\n\tlocation.objectid = BTRFS_EXTENT_TREE_OBJECTID;\n\tlocation.type = BTRFS_ROOT_ITEM_KEY;\n\tlocation.offset = 0;\n\n\textent_root = btrfs_read_tree_root(tree_root, &location);\n\tif (IS_ERR(extent_root)) {\n\t\tret = PTR_ERR(extent_root);\n\t\tgoto recovery_tree_root;\n\t}\n\tset_bit(BTRFS_ROOT_TRACK_DIRTY, &extent_root->state);\n\tfs_info->extent_root = extent_root;\n\n\tlocation.objectid = BTRFS_DEV_TREE_OBJECTID;\n\tdev_root = btrfs_read_tree_root(tree_root, &location);\n\tif (IS_ERR(dev_root)) {\n\t\tret = PTR_ERR(dev_root);\n\t\tgoto recovery_tree_root;\n\t}\n\tset_bit(BTRFS_ROOT_TRACK_DIRTY, &dev_root->state);\n\tfs_info->dev_root = dev_root;\n\tbtrfs_init_devices_late(fs_info);\n\n\tlocation.objectid = BTRFS_CSUM_TREE_OBJECTID;\n\tcsum_root = btrfs_read_tree_root(tree_root, &location);\n\tif (IS_ERR(csum_root)) {\n\t\tret = PTR_ERR(csum_root);\n\t\tgoto recovery_tree_root;\n\t}\n\tset_bit(BTRFS_ROOT_TRACK_DIRTY, &csum_root->state);\n\tfs_info->csum_root = csum_root;\n\n\tlocation.objectid = BTRFS_QUOTA_TREE_OBJECTID;\n\tquota_root = btrfs_read_tree_root(tree_root, &location);\n\tif (!IS_ERR(quota_root)) {\n\t\tset_bit(BTRFS_ROOT_TRACK_DIRTY, &quota_root->state);\n\t\tfs_info->quota_enabled = 1;\n\t\tfs_info->pending_quota_state = 1;\n\t\tfs_info->quota_root = quota_root;\n\t}\n\n\tlocation.objectid = BTRFS_UUID_TREE_OBJECTID;\n\tuuid_root = btrfs_read_tree_root(tree_root, &location);\n\tif (IS_ERR(uuid_root)) {\n\t\tret = PTR_ERR(uuid_root);\n\t\tif (ret != -ENOENT)\n\t\t\tgoto recovery_tree_root;\n\t\tcreate_uuid_tree = true;\n\t\tcheck_uuid_tree = false;\n\t} else {\n\t\tset_bit(BTRFS_ROOT_TRACK_DIRTY, &uuid_root->state);\n\t\tfs_info->uuid_root = uuid_root;\n\t\tcreate_uuid_tree = false;\n\t\tcheck_uuid_tree =\n\t\t    generation != btrfs_super_uuid_tree_generation(disk_super);\n\t}\n\n\tfs_info->generation = generation;\n\tfs_info->last_trans_committed = generation;\n\n\tret = btrfs_recover_balance(fs_info);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"BTRFS: failed to recover balance\\n\");\n\t\tgoto fail_block_groups;\n\t}\n\n\tret = btrfs_init_dev_stats(fs_info);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"BTRFS: failed to init dev_stats: %d\\n\",\n\t\t       ret);\n\t\tgoto fail_block_groups;\n\t}\n\n\tret = btrfs_init_dev_replace(fs_info);\n\tif (ret) {\n\t\tpr_err(\"BTRFS: failed to init dev_replace: %d\\n\", ret);\n\t\tgoto fail_block_groups;\n\t}\n\n\tbtrfs_close_extra_devices(fs_info, fs_devices, 1);\n\n\tret = btrfs_sysfs_add_one(fs_info);\n\tif (ret) {\n\t\tpr_err(\"BTRFS: failed to init sysfs interface: %d\\n\", ret);\n\t\tgoto fail_block_groups;\n\t}\n\n\tret = btrfs_init_space_info(fs_info);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"BTRFS: Failed to initial space info: %d\\n\", ret);\n\t\tgoto fail_sysfs;\n\t}\n\n\tret = btrfs_read_block_groups(extent_root);\n\tif (ret) {\n\t\tprintk(KERN_ERR \"BTRFS: Failed to read block groups: %d\\n\", ret);\n\t\tgoto fail_sysfs;\n\t}\n\tfs_info->num_tolerated_disk_barrier_failures =\n\t\tbtrfs_calc_num_tolerated_disk_barrier_failures(fs_info);\n\tif (fs_info->fs_devices->missing_devices >\n\t     fs_info->num_tolerated_disk_barrier_failures &&\n\t    !(sb->s_flags & MS_RDONLY)) {\n\t\tprintk(KERN_WARNING \"BTRFS: \"\n\t\t\t\"too many missing devices, writeable mount is not allowed\\n\");\n\t\tgoto fail_sysfs;\n\t}\n\n\tfs_info->cleaner_kthread = kthread_run(cleaner_kthread, tree_root,\n\t\t\t\t\t       \"btrfs-cleaner\");\n\tif (IS_ERR(fs_info->cleaner_kthread))\n\t\tgoto fail_sysfs;\n\n\tfs_info->transaction_kthread = kthread_run(transaction_kthread,\n\t\t\t\t\t\t   tree_root,\n\t\t\t\t\t\t   \"btrfs-transaction\");\n\tif (IS_ERR(fs_info->transaction_kthread))\n\t\tgoto fail_cleaner;\n\n\tif (!btrfs_test_opt(tree_root, SSD) &&\n\t    !btrfs_test_opt(tree_root, NOSSD) &&\n\t    !fs_info->fs_devices->rotating) {\n\t\tprintk(KERN_INFO \"BTRFS: detected SSD devices, enabling SSD \"\n\t\t       \"mode\\n\");\n\t\tbtrfs_set_opt(fs_info->mount_opt, SSD);\n\t}\n\n\t/*\n\t * Mount does not set all options immediatelly, we can do it now and do\n\t * not have to wait for transaction commit\n\t */\n\tbtrfs_apply_pending_changes(fs_info);\n\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_test_opt(tree_root, CHECK_INTEGRITY)) {\n\t\tret = btrfsic_mount(tree_root, fs_devices,\n\t\t\t\t    btrfs_test_opt(tree_root,\n\t\t\t\t\tCHECK_INTEGRITY_INCLUDING_EXTENT_DATA) ?\n\t\t\t\t    1 : 0,\n\t\t\t\t    fs_info->check_integrity_print_mask);\n\t\tif (ret)\n\t\t\tprintk(KERN_WARNING \"BTRFS: failed to initialize\"\n\t\t\t       \" integrity check module %s\\n\", sb->s_id);\n\t}\n#endif\n\tret = btrfs_read_qgroup_config(fs_info);\n\tif (ret)\n\t\tgoto fail_trans_kthread;\n\n\t/* do not make disk changes in broken FS */\n\tif (btrfs_super_log_root(disk_super) != 0) {\n\t\tu64 bytenr = btrfs_super_log_root(disk_super);\n\n\t\tif (fs_devices->rw_devices == 0) {\n\t\t\tprintk(KERN_WARNING \"BTRFS: log replay required \"\n\t\t\t       \"on RO media\\n\");\n\t\t\terr = -EIO;\n\t\t\tgoto fail_qgroup;\n\t\t}\n\n\t\tlog_tree_root = btrfs_alloc_root(fs_info);\n\t\tif (!log_tree_root) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto fail_qgroup;\n\t\t}\n\n\t\t__setup_root(nodesize, sectorsize, stripesize,\n\t\t\t     log_tree_root, fs_info, BTRFS_TREE_LOG_OBJECTID);\n\n\t\tlog_tree_root->node = read_tree_block(tree_root, bytenr,\n\t\t\t\t\t\t      generation + 1);\n\t\tif (!log_tree_root->node ||\n\t\t    !extent_buffer_uptodate(log_tree_root->node)) {\n\t\t\tprintk(KERN_ERR \"BTRFS: failed to read log tree\\n\");\n\t\t\tfree_extent_buffer(log_tree_root->node);\n\t\t\tkfree(log_tree_root);\n\t\t\tgoto fail_qgroup;\n\t\t}\n\t\t/* returns with log_tree_root freed on success */\n\t\tret = btrfs_recover_log_trees(log_tree_root);\n\t\tif (ret) {\n\t\t\tbtrfs_error(tree_root->fs_info, ret,\n\t\t\t\t    \"Failed to recover log tree\");\n\t\t\tfree_extent_buffer(log_tree_root->node);\n\t\t\tkfree(log_tree_root);\n\t\t\tgoto fail_qgroup;\n\t\t}\n\n\t\tif (sb->s_flags & MS_RDONLY) {\n\t\t\tret = btrfs_commit_super(tree_root);\n\t\t\tif (ret)\n\t\t\t\tgoto fail_qgroup;\n\t\t}\n\t}\n\n\tret = btrfs_find_orphan_roots(tree_root);\n\tif (ret)\n\t\tgoto fail_qgroup;\n\n\tif (!(sb->s_flags & MS_RDONLY)) {\n\t\tret = btrfs_cleanup_fs_roots(fs_info);\n\t\tif (ret)\n\t\t\tgoto fail_qgroup;\n\n\t\tmutex_lock(&fs_info->cleaner_mutex);\n\t\tret = btrfs_recover_relocation(tree_root);\n\t\tmutex_unlock(&fs_info->cleaner_mutex);\n\t\tif (ret < 0) {\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"BTRFS: failed to recover relocation\\n\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto fail_qgroup;\n\t\t}\n\t}\n\n\tlocation.objectid = BTRFS_FS_TREE_OBJECTID;\n\tlocation.type = BTRFS_ROOT_ITEM_KEY;\n\tlocation.offset = 0;\n\n\tfs_info->fs_root = btrfs_read_fs_root_no_name(fs_info, &location);\n\tif (IS_ERR(fs_info->fs_root)) {\n\t\terr = PTR_ERR(fs_info->fs_root);\n\t\tgoto fail_qgroup;\n\t}\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn 0;\n\n\tdown_read(&fs_info->cleanup_work_sem);\n\tif ((ret = btrfs_orphan_cleanup(fs_info->fs_root)) ||\n\t    (ret = btrfs_orphan_cleanup(fs_info->tree_root))) {\n\t\tup_read(&fs_info->cleanup_work_sem);\n\t\tclose_ctree(tree_root);\n\t\treturn ret;\n\t}\n\tup_read(&fs_info->cleanup_work_sem);\n\n\tret = btrfs_resume_balance_async(fs_info);\n\tif (ret) {\n\t\tprintk(KERN_WARNING \"BTRFS: failed to resume balance\\n\");\n\t\tclose_ctree(tree_root);\n\t\treturn ret;\n\t}\n\n\tret = btrfs_resume_dev_replace_async(fs_info);\n\tif (ret) {\n\t\tpr_warn(\"BTRFS: failed to resume dev_replace\\n\");\n\t\tclose_ctree(tree_root);\n\t\treturn ret;\n\t}\n\n\tbtrfs_qgroup_rescan_resume(fs_info);\n\n\tif (create_uuid_tree) {\n\t\tpr_info(\"BTRFS: creating UUID tree\\n\");\n\t\tret = btrfs_create_uuid_tree(fs_info);\n\t\tif (ret) {\n\t\t\tpr_warn(\"BTRFS: failed to create the UUID tree %d\\n\",\n\t\t\t\tret);\n\t\t\tclose_ctree(tree_root);\n\t\t\treturn ret;\n\t\t}\n\t} else if (check_uuid_tree ||\n\t\t   btrfs_test_opt(tree_root, RESCAN_UUID_TREE)) {\n\t\tpr_info(\"BTRFS: checking UUID tree\\n\");\n\t\tret = btrfs_check_uuid_tree(fs_info);\n\t\tif (ret) {\n\t\t\tpr_warn(\"BTRFS: failed to check the UUID tree %d\\n\",\n\t\t\t\tret);\n\t\t\tclose_ctree(tree_root);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tfs_info->update_uuid_tree_gen = 1;\n\t}\n\n\tfs_info->open = 1;\n\n\treturn 0;\n\nfail_qgroup:\n\tbtrfs_free_qgroup_config(fs_info);\nfail_trans_kthread:\n\tkthread_stop(fs_info->transaction_kthread);\n\tbtrfs_cleanup_transaction(fs_info->tree_root);\n\tbtrfs_free_fs_roots(fs_info);\nfail_cleaner:\n\tkthread_stop(fs_info->cleaner_kthread);\n\n\t/*\n\t * make sure we're done with the btree inode before we stop our\n\t * kthreads\n\t */\n\tfilemap_write_and_wait(fs_info->btree_inode->i_mapping);\n\nfail_sysfs:\n\tbtrfs_sysfs_remove_one(fs_info);\n\nfail_block_groups:\n\tbtrfs_put_block_group_cache(fs_info);\n\tbtrfs_free_block_groups(fs_info);\n\nfail_tree_roots:\n\tfree_root_pointers(fs_info, 1);\n\tinvalidate_inode_pages2(fs_info->btree_inode->i_mapping);\n\nfail_sb_buffer:\n\tbtrfs_stop_all_workers(fs_info);\nfail_alloc:\nfail_iput:\n\tbtrfs_mapping_tree_free(&fs_info->mapping_tree);\n\n\tiput(fs_info->btree_inode);\nfail_bio_counter:\n\tpercpu_counter_destroy(&fs_info->bio_counter);\nfail_delalloc_bytes:\n\tpercpu_counter_destroy(&fs_info->delalloc_bytes);\nfail_dirty_metadata_bytes:\n\tpercpu_counter_destroy(&fs_info->dirty_metadata_bytes);\nfail_bdi:\n\tbdi_destroy(&fs_info->bdi);\nfail_srcu:\n\tcleanup_srcu_struct(&fs_info->subvol_srcu);\nfail:\n\tbtrfs_free_stripe_hash_table(fs_info);\n\tbtrfs_close_devices(fs_info->fs_devices);\n\treturn err;\n\nrecovery_tree_root:\n\tif (!btrfs_test_opt(tree_root, RECOVERY))\n\t\tgoto fail_tree_roots;\n\n\tfree_root_pointers(fs_info, 0);\n\n\t/* don't use the log in recovery mode, it won't be valid */\n\tbtrfs_set_super_log_root(disk_super, 0);\n\n\t/* we can't trust the free space cache either */\n\tbtrfs_set_opt(fs_info->mount_opt, CLEAR_CACHE);\n\n\tret = next_root_backup(fs_info, fs_info->super_copy,\n\t\t\t       &num_backups_tried, &backup_index);\n\tif (ret == -1)\n\t\tgoto fail_block_groups;\n\tgoto retry_root_backup;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_sb",
          "args": [
            "sb"
          ],
          "line": 932
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3272-3275",
          "snippet": "static inline struct btrfs_fs_info *btrfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline struct btrfs_fs_info *btrfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nstatic const struct super_operations btrfs_super_ops;\nstatic int btrfs_remount(struct super_block *sb, int *flags, char *data);\nstatic const struct super_operations btrfs_super_ops = {\n\t.drop_inode\t= btrfs_drop_inode,\n\t.evict_inode\t= btrfs_evict_inode,\n\t.put_super\t= btrfs_put_super,\n\t.sync_fs\t= btrfs_sync_fs,\n\t.show_options\t= btrfs_show_options,\n\t.show_devname\t= btrfs_show_devname,\n\t.write_inode\t= btrfs_write_inode,\n\t.alloc_inode\t= btrfs_alloc_inode,\n\t.destroy_inode\t= btrfs_destroy_inode,\n\t.statfs\t\t= btrfs_statfs,\n\t.remount_fs\t= btrfs_remount,\n\t.freeze_fs\t= btrfs_freeze,\n};\n\nstatic int btrfs_fill_super(struct super_block *sb,\n\t\t\t    struct btrfs_fs_devices *fs_devices,\n\t\t\t    void *data, int silent)\n{\n\tstruct inode *inode;\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(sb);\n\tstruct btrfs_key key;\n\tint err;\n\n\tsb->s_maxbytes = MAX_LFS_FILESIZE;\n\tsb->s_magic = BTRFS_SUPER_MAGIC;\n\tsb->s_op = &btrfs_super_ops;\n\tsb->s_d_op = &btrfs_dentry_operations;\n\tsb->s_export_op = &btrfs_export_ops;\n\tsb->s_xattr = btrfs_xattr_handlers;\n\tsb->s_time_gran = 1;\n#ifdef CONFIG_BTRFS_FS_POSIX_ACL\n\tsb->s_flags |= MS_POSIXACL;\n#endif\n\tsb->s_flags |= MS_I_VERSION;\n\terr = open_ctree(sb, fs_devices, (char *)data);\n\tif (err) {\n\t\tprintk(KERN_ERR \"BTRFS: open_ctree failed\\n\");\n\t\treturn err;\n\t}\n\n\tkey.objectid = BTRFS_FIRST_FREE_OBJECTID;\n\tkey.type = BTRFS_INODE_ITEM_KEY;\n\tkey.offset = 0;\n\tinode = btrfs_iget(sb, &key, fs_info->fs_root, NULL);\n\tif (IS_ERR(inode)) {\n\t\terr = PTR_ERR(inode);\n\t\tgoto fail_close;\n\t}\n\n\tsb->s_root = d_make_root(inode);\n\tif (!sb->s_root) {\n\t\terr = -ENOMEM;\n\t\tgoto fail_close;\n\t}\n\n\tsave_mount_options(sb, data);\n\tcleancache_init_fs(sb);\n\tsb->s_flags |= MS_ACTIVE;\n\treturn 0;\n\nfail_close:\n\tclose_ctree(fs_info->tree_root);\n\treturn err;\n}"
  },
  {
    "function_name": "get_default_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
    "lines": "844-925",
    "snippet": "static struct dentry *get_default_root(struct super_block *sb,\n\t\t\t\t       u64 subvol_objectid)\n{\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(sb);\n\tstruct btrfs_root *root = fs_info->tree_root;\n\tstruct btrfs_root *new_root;\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key location;\n\tstruct inode *inode;\n\tu64 dir_id;\n\tint new = 0;\n\n\t/*\n\t * We have a specific subvol we want to mount, just setup location and\n\t * go look up the root.\n\t */\n\tif (subvol_objectid) {\n\t\tlocation.objectid = subvol_objectid;\n\t\tlocation.type = BTRFS_ROOT_ITEM_KEY;\n\t\tlocation.offset = (u64)-1;\n\t\tgoto find_root;\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn ERR_PTR(-ENOMEM);\n\tpath->leave_spinning = 1;\n\n\t/*\n\t * Find the \"default\" dir item which points to the root item that we\n\t * will mount by default if we haven't been given a specific subvolume\n\t * to mount.\n\t */\n\tdir_id = btrfs_super_root_dir(fs_info->super_copy);\n\tdi = btrfs_lookup_dir_item(NULL, root, path, dir_id, \"default\", 7, 0);\n\tif (IS_ERR(di)) {\n\t\tbtrfs_free_path(path);\n\t\treturn ERR_CAST(di);\n\t}\n\tif (!di) {\n\t\t/*\n\t\t * Ok the default dir item isn't there.  This is weird since\n\t\t * it's always been there, but don't freak out, just try and\n\t\t * mount to root most subvolume.\n\t\t */\n\t\tbtrfs_free_path(path);\n\t\tdir_id = BTRFS_FIRST_FREE_OBJECTID;\n\t\tnew_root = fs_info->fs_root;\n\t\tgoto setup_root;\n\t}\n\n\tbtrfs_dir_item_key_to_cpu(path->nodes[0], di, &location);\n\tbtrfs_free_path(path);\n\nfind_root:\n\tnew_root = btrfs_read_fs_root_no_name(fs_info, &location);\n\tif (IS_ERR(new_root))\n\t\treturn ERR_CAST(new_root);\n\n\tdir_id = btrfs_root_dirid(&new_root->root_item);\nsetup_root:\n\tlocation.objectid = dir_id;\n\tlocation.type = BTRFS_INODE_ITEM_KEY;\n\tlocation.offset = 0;\n\n\tinode = btrfs_iget(sb, &location, new_root, &new);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\t/*\n\t * If we're just mounting the root most subvol put the inode and return\n\t * a reference to the dentry.  We will have already gotten a reference\n\t * to the inode in btrfs_fill_super so we're good to go.\n\t */\n\tif (!new && sb->s_root->d_inode == inode) {\n\t\tiput(inode);\n\t\treturn dget(sb->s_root);\n\t}\n\n\treturn d_obtain_root(inode);\n}",
    "includes": [
      "#include <trace/events/btrfs.h>",
      "#include \"qgroup.h\"",
      "#include \"tests/btrfs-tests.h\"",
      "#include \"backref.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"compression.h\"",
      "#include \"export.h\"",
      "#include \"volumes.h\"",
      "#include \"xattr.h\"",
      "#include \"props.h\"",
      "#include \"hash.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/namei.h>",
      "#include <linux/ctype.h>",
      "#include <linux/parser.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_obtain_root",
          "args": [
            "inode"
          ],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "d_obtain_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1998-2001",
          "snippet": "struct dentry *d_obtain_root(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, 0);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_obtain_root(struct inode *inode)\n{\n\treturn __d_obtain_alias(inode, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "sb->s_root"
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_run_delayed_iputs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "3100-3123",
          "snippet": "void btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nvoid btrfs_run_delayed_iputs(struct btrfs_root *root)\n{\n\tLIST_HEAD(list);\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tstruct delayed_iput *delayed;\n\tint empty;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tempty = list_empty(&fs_info->delayed_iputs);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\tif (empty)\n\t\treturn;\n\n\tspin_lock(&fs_info->delayed_iput_lock);\n\tlist_splice_init(&fs_info->delayed_iputs, &list);\n\tspin_unlock(&fs_info->delayed_iput_lock);\n\n\twhile (!list_empty(&list)) {\n\t\tdelayed = list_entry(list.next, struct delayed_iput, list);\n\t\tlist_del(&delayed->list);\n\t\tiput(delayed->inode);\n\t\tkfree(delayed);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "inode"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_iget",
          "args": [
            "sb",
            "&location",
            "new_root",
            "&new"
          ],
          "line": 910
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/inode.c",
          "lines": "5312-5336",
          "snippet": "struct inode *btrfs_iget(struct super_block *s, struct btrfs_key *location,\n\t\t\t struct btrfs_root *root, int *new)\n{\n\tstruct inode *inode;\n\n\tinode = btrfs_iget_locked(s, location, root);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (inode->i_state & I_NEW) {\n\t\tbtrfs_read_locked_inode(inode);\n\t\tif (!is_bad_inode(inode)) {\n\t\t\tinode_tree_add(inode);\n\t\t\tunlock_new_inode(inode);\n\t\t\tif (new)\n\t\t\t\t*new = 1;\n\t\t} else {\n\t\t\tunlock_new_inode(inode);\n\t\t\tiput(inode);\n\t\t\tinode = ERR_PTR(-ESTALE);\n\t\t}\n\t}\n\n\treturn inode;\n}",
          "includes": [
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"backref.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"locking.h\"",
            "#include \"compression.h\"",
            "#include \"volumes.h\"",
            "#include \"tree-log.h\"",
            "#include \"xattr.h\"",
            "#include \"ordered-data.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/slab.h>",
            "#include <linux/falloc.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/xattr.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/aio.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/bio.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int btrfs_truncate(struct inode *inode);",
            "static int btrfs_dirty_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"props.h\"\n#include \"hash.h\"\n#include \"backref.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"locking.h\"\n#include \"compression.h\"\n#include \"volumes.h\"\n#include \"tree-log.h\"\n#include \"xattr.h\"\n#include \"ordered-data.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/blkdev.h>\n#include <linux/btrfs.h>\n#include <linux/mount.h>\n#include <linux/ratelimit.h>\n#include <linux/slab.h>\n#include <linux/falloc.h>\n#include <linux/posix_acl.h>\n#include <linux/xattr.h>\n#include <linux/bit_spinlock.h>\n#include <linux/aio.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/buffer_head.h>\n#include <linux/bio.h>\n#include <linux/kernel.h>\n\nstatic int btrfs_truncate(struct inode *inode);\nstatic int btrfs_dirty_inode(struct inode *inode);\n\nstruct inode *btrfs_iget(struct super_block *s, struct btrfs_key *location,\n\t\t\t struct btrfs_root *root, int *new)\n{\n\tstruct inode *inode;\n\n\tinode = btrfs_iget_locked(s, location, root);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (inode->i_state & I_NEW) {\n\t\tbtrfs_read_locked_inode(inode);\n\t\tif (!is_bad_inode(inode)) {\n\t\t\tinode_tree_add(inode);\n\t\t\tunlock_new_inode(inode);\n\t\t\tif (new)\n\t\t\t\t*new = 1;\n\t\t} else {\n\t\t\tunlock_new_inode(inode);\n\t\t\tiput(inode);\n\t\t\tinode = ERR_PTR(-ESTALE);\n\t\t}\n\t}\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_root_dirid",
          "args": [
            "&new_root->root_item"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "new_root"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "new_root"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_read_fs_root_no_name",
          "args": [
            "fs_info",
            "&location"
          ],
          "line": 900
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_read_fs_root_no_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.h",
          "lines": "76-81",
          "snippet": "static inline struct btrfs_root *\nbtrfs_read_fs_root_no_name(struct btrfs_fs_info *fs_info,\n\t\t\t   struct btrfs_key *location)\n{\n\treturn btrfs_get_fs_root(fs_info, location, true);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct btrfs_root *\nbtrfs_read_fs_root_no_name(struct btrfs_fs_info *fs_info,\n\t\t\t   struct btrfs_key *location)\n{\n\treturn btrfs_get_fs_root(fs_info, location, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_free_path",
          "args": [
            "path"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "107-113",
          "snippet": "void btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nvoid btrfs_free_path(struct btrfs_path *p)\n{\n\tif (!p)\n\t\treturn;\n\tbtrfs_release_path(p);\n\tkmem_cache_free(btrfs_path_cachep, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_dir_item_key_to_cpu",
          "args": [
            "path->nodes[0]",
            "di",
            "&location"
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_dir_item_key_to_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "2763-2770",
          "snippet": "static inline void btrfs_dir_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t      struct btrfs_dir_item *item,\n\t\t\t\t      struct btrfs_key *key)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_dir_item_key(eb, item, &disk_key);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void btrfs_dir_item_key_to_cpu(struct extent_buffer *eb,\n\t\t\t\t      struct btrfs_dir_item *item,\n\t\t\t\t      struct btrfs_key *key)\n{\n\tstruct btrfs_disk_key disk_key;\n\tbtrfs_dir_item_key(eb, item, &disk_key);\n\tbtrfs_disk_key_to_cpu(key, &disk_key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "di"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "di"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_lookup_dir_item",
          "args": [
            "NULL",
            "root",
            "path",
            "dir_id",
            "\"default\"",
            "7",
            "0"
          ],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_lookup_dir_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/dir-item.c",
          "lines": "191-214",
          "snippet": "struct btrfs_dir_item *btrfs_lookup_dir_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t     struct btrfs_root *root,\n\t\t\t\t\t     struct btrfs_path *path, u64 dir,\n\t\t\t\t\t     const char *name, int name_len,\n\t\t\t\t\t     int mod)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tint ins_len = mod < 0 ? -1 : 0;\n\tint cow = mod != 0;\n\n\tkey.objectid = dir;\n\tkey.type = BTRFS_DIR_ITEM_KEY;\n\n\tkey.offset = btrfs_name_hash(name, name_len);\n\n\tret = btrfs_search_slot(trans, root, &key, path, ins_len, cow);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\tif (ret > 0)\n\t\treturn NULL;\n\n\treturn btrfs_match_dir_item_name(root, path, name, name_len);\n}",
          "includes": [
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n\nstruct btrfs_dir_item *btrfs_lookup_dir_item(struct btrfs_trans_handle *trans,\n\t\t\t\t\t     struct btrfs_root *root,\n\t\t\t\t\t     struct btrfs_path *path, u64 dir,\n\t\t\t\t\t     const char *name, int name_len,\n\t\t\t\t\t     int mod)\n{\n\tint ret;\n\tstruct btrfs_key key;\n\tint ins_len = mod < 0 ? -1 : 0;\n\tint cow = mod != 0;\n\n\tkey.objectid = dir;\n\tkey.type = BTRFS_DIR_ITEM_KEY;\n\n\tkey.offset = btrfs_name_hash(name, name_len);\n\n\tret = btrfs_search_slot(trans, root, &key, path, ins_len, cow);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\tif (ret > 0)\n\t\treturn NULL;\n\n\treturn btrfs_match_dir_item_name(root, path, name, name_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_super_root_dir",
          "args": [
            "fs_info->super_copy"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_alloc_path",
          "args": [],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_alloc_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.c",
          "lines": "45-50",
          "snippet": "struct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}",
          "includes": [
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <linux/rbtree.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <linux/rbtree.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic noinline struct;\n\nstruct btrfs_path *btrfs_alloc_path(void)\n{\n\tstruct btrfs_path *path;\n\tpath = kmem_cache_zalloc(btrfs_path_cachep, GFP_NOFS);\n\treturn path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_sb",
          "args": [
            "sb"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3272-3275",
          "snippet": "static inline struct btrfs_fs_info *btrfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline struct btrfs_fs_info *btrfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nstatic struct dentry *get_default_root(struct super_block *sb,\n\t\t\t\t       u64 subvol_objectid)\n{\n\tstruct btrfs_fs_info *fs_info = btrfs_sb(sb);\n\tstruct btrfs_root *root = fs_info->tree_root;\n\tstruct btrfs_root *new_root;\n\tstruct btrfs_dir_item *di;\n\tstruct btrfs_path *path;\n\tstruct btrfs_key location;\n\tstruct inode *inode;\n\tu64 dir_id;\n\tint new = 0;\n\n\t/*\n\t * We have a specific subvol we want to mount, just setup location and\n\t * go look up the root.\n\t */\n\tif (subvol_objectid) {\n\t\tlocation.objectid = subvol_objectid;\n\t\tlocation.type = BTRFS_ROOT_ITEM_KEY;\n\t\tlocation.offset = (u64)-1;\n\t\tgoto find_root;\n\t}\n\n\tpath = btrfs_alloc_path();\n\tif (!path)\n\t\treturn ERR_PTR(-ENOMEM);\n\tpath->leave_spinning = 1;\n\n\t/*\n\t * Find the \"default\" dir item which points to the root item that we\n\t * will mount by default if we haven't been given a specific subvolume\n\t * to mount.\n\t */\n\tdir_id = btrfs_super_root_dir(fs_info->super_copy);\n\tdi = btrfs_lookup_dir_item(NULL, root, path, dir_id, \"default\", 7, 0);\n\tif (IS_ERR(di)) {\n\t\tbtrfs_free_path(path);\n\t\treturn ERR_CAST(di);\n\t}\n\tif (!di) {\n\t\t/*\n\t\t * Ok the default dir item isn't there.  This is weird since\n\t\t * it's always been there, but don't freak out, just try and\n\t\t * mount to root most subvolume.\n\t\t */\n\t\tbtrfs_free_path(path);\n\t\tdir_id = BTRFS_FIRST_FREE_OBJECTID;\n\t\tnew_root = fs_info->fs_root;\n\t\tgoto setup_root;\n\t}\n\n\tbtrfs_dir_item_key_to_cpu(path->nodes[0], di, &location);\n\tbtrfs_free_path(path);\n\nfind_root:\n\tnew_root = btrfs_read_fs_root_no_name(fs_info, &location);\n\tif (IS_ERR(new_root))\n\t\treturn ERR_CAST(new_root);\n\n\tdir_id = btrfs_root_dirid(&new_root->root_item);\nsetup_root:\n\tlocation.objectid = dir_id;\n\tlocation.type = BTRFS_INODE_ITEM_KEY;\n\tlocation.offset = 0;\n\n\tinode = btrfs_iget(sb, &location, new_root, &new);\n\tif (IS_ERR(inode))\n\t\treturn ERR_CAST(inode);\n\n\t/*\n\t * If we're just mounting the root most subvol put the inode and return\n\t * a reference to the dentry.  We will have already gotten a reference\n\t * to the inode in btrfs_fill_super so we're good to go.\n\t */\n\tif (!new && sb->s_root->d_inode == inode) {\n\t\tiput(inode);\n\t\treturn dget(sb->s_root);\n\t}\n\n\treturn d_obtain_root(inode);\n}"
  },
  {
    "function_name": "btrfs_parse_early_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
    "lines": "767-842",
    "snippet": "static int btrfs_parse_early_options(const char *options, fmode_t flags,\n\t\tvoid *holder, char **subvol_name, u64 *subvol_objectid,\n\t\tstruct btrfs_fs_devices **fs_devices)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\tchar *device_name, *opts, *orig, *p;\n\tchar *num = NULL;\n\tint error = 0;\n\n\tif (!options)\n\t\treturn 0;\n\n\t/*\n\t * strsep changes the string, duplicate it because parse_options\n\t * gets called twice\n\t */\n\topts = kstrdup(options, GFP_KERNEL);\n\tif (!opts)\n\t\treturn -ENOMEM;\n\torig = opts;\n\n\twhile ((p = strsep(&opts, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_subvol:\n\t\t\tkfree(*subvol_name);\n\t\t\t*subvol_name = match_strdup(&args[0]);\n\t\t\tif (!*subvol_name) {\n\t\t\t\terror = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_subvolid:\n\t\t\tnum = match_strdup(&args[0]);\n\t\t\tif (num) {\n\t\t\t\t*subvol_objectid = memparse(num, NULL);\n\t\t\t\tkfree(num);\n\t\t\t\t/* we want the original fs_tree */\n\t\t\t\tif (!*subvol_objectid)\n\t\t\t\t\t*subvol_objectid =\n\t\t\t\t\t\tBTRFS_FS_TREE_OBJECTID;\n\t\t\t} else {\n\t\t\t\terror = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_subvolrootid:\n\t\t\tprintk(KERN_WARNING\n\t\t\t\t\"BTRFS: 'subvolrootid' mount option is deprecated and has \"\n\t\t\t\t\"no effect\\n\");\n\t\t\tbreak;\n\t\tcase Opt_device:\n\t\t\tdevice_name = match_strdup(&args[0]);\n\t\t\tif (!device_name) {\n\t\t\t\terror = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\terror = btrfs_scan_one_device(device_name,\n\t\t\t\t\tflags, holder, fs_devices);\n\t\t\tkfree(device_name);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\tkfree(orig);\n\treturn error;\n}",
    "includes": [
      "#include <trace/events/btrfs.h>",
      "#include \"qgroup.h\"",
      "#include \"tests/btrfs-tests.h\"",
      "#include \"backref.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"compression.h\"",
      "#include \"export.h\"",
      "#include \"volumes.h\"",
      "#include \"xattr.h\"",
      "#include \"props.h\"",
      "#include \"hash.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/namei.h>",
      "#include <linux/ctype.h>",
      "#include <linux/parser.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static match_table_t tokens = {\n\t{Opt_degraded, \"degraded\"},\n\t{Opt_subvol, \"subvol=%s\"},\n\t{Opt_subvolid, \"subvolid=%s\"},\n\t{Opt_device, \"device=%s\"},\n\t{Opt_nodatasum, \"nodatasum\"},\n\t{Opt_datasum, \"datasum\"},\n\t{Opt_nodatacow, \"nodatacow\"},\n\t{Opt_datacow, \"datacow\"},\n\t{Opt_nobarrier, \"nobarrier\"},\n\t{Opt_barrier, \"barrier\"},\n\t{Opt_max_inline, \"max_inline=%s\"},\n\t{Opt_alloc_start, \"alloc_start=%s\"},\n\t{Opt_thread_pool, \"thread_pool=%d\"},\n\t{Opt_compress, \"compress\"},\n\t{Opt_compress_type, \"compress=%s\"},\n\t{Opt_compress_force, \"compress-force\"},\n\t{Opt_compress_force_type, \"compress-force=%s\"},\n\t{Opt_ssd, \"ssd\"},\n\t{Opt_ssd_spread, \"ssd_spread\"},\n\t{Opt_nossd, \"nossd\"},\n\t{Opt_acl, \"acl\"},\n\t{Opt_noacl, \"noacl\"},\n\t{Opt_notreelog, \"notreelog\"},\n\t{Opt_treelog, \"treelog\"},\n\t{Opt_flushoncommit, \"flushoncommit\"},\n\t{Opt_noflushoncommit, \"noflushoncommit\"},\n\t{Opt_ratio, \"metadata_ratio=%d\"},\n\t{Opt_discard, \"discard\"},\n\t{Opt_nodiscard, \"nodiscard\"},\n\t{Opt_space_cache, \"space_cache\"},\n\t{Opt_clear_cache, \"clear_cache\"},\n\t{Opt_user_subvol_rm_allowed, \"user_subvol_rm_allowed\"},\n\t{Opt_enospc_debug, \"enospc_debug\"},\n\t{Opt_noenospc_debug, \"noenospc_debug\"},\n\t{Opt_subvolrootid, \"subvolrootid=%d\"},\n\t{Opt_defrag, \"autodefrag\"},\n\t{Opt_nodefrag, \"noautodefrag\"},\n\t{Opt_inode_cache, \"inode_cache\"},\n\t{Opt_noinode_cache, \"noinode_cache\"},\n\t{Opt_no_space_cache, \"nospace_cache\"},\n\t{Opt_recovery, \"recovery\"},\n\t{Opt_skip_balance, \"skip_balance\"},\n\t{Opt_check_integrity, \"check_int\"},\n\t{Opt_check_integrity_including_extent_data, \"check_int_data\"},\n\t{Opt_check_integrity_print_mask, \"check_int_print_mask=%d\"},\n\t{Opt_rescan_uuid_tree, \"rescan_uuid_tree\"},\n\t{Opt_fatal_errors, \"fatal_errors=%s\"},\n\t{Opt_commit_interval, \"commit=%d\"},\n\t{Opt_err, NULL},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "orig"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "device_name"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_scan_one_device",
          "args": [
            "device_name",
            "flags",
            "holder",
            "fs_devices"
          ],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_scan_one_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/volumes.c",
          "lines": "881-970",
          "snippet": "int btrfs_scan_one_device(const char *path, fmode_t flags, void *holder,\n\t\t\t  struct btrfs_fs_devices **fs_devices_ret)\n{\n\tstruct btrfs_super_block *disk_super;\n\tstruct block_device *bdev;\n\tstruct page *page;\n\tvoid *p;\n\tint ret = -EINVAL;\n\tu64 devid;\n\tu64 transid;\n\tu64 total_devices;\n\tu64 bytenr;\n\tpgoff_t index;\n\n\t/*\n\t * we would like to check all the supers, but that would make\n\t * a btrfs mount succeed after a mkfs from a different FS.\n\t * So, we need to add a special mount option to scan for\n\t * later supers, using BTRFS_SUPER_MIRROR_MAX instead\n\t */\n\tbytenr = btrfs_sb_offset(0);\n\tflags |= FMODE_EXCL;\n\tmutex_lock(&uuid_mutex);\n\n\tbdev = blkdev_get_by_path(path, flags, holder);\n\n\tif (IS_ERR(bdev)) {\n\t\tret = PTR_ERR(bdev);\n\t\tgoto error;\n\t}\n\n\t/* make sure our super fits in the device */\n\tif (bytenr + PAGE_CACHE_SIZE >= i_size_read(bdev->bd_inode))\n\t\tgoto error_bdev_put;\n\n\t/* make sure our super fits in the page */\n\tif (sizeof(*disk_super) > PAGE_CACHE_SIZE)\n\t\tgoto error_bdev_put;\n\n\t/* make sure our super doesn't straddle pages on disk */\n\tindex = bytenr >> PAGE_CACHE_SHIFT;\n\tif ((bytenr + sizeof(*disk_super) - 1) >> PAGE_CACHE_SHIFT != index)\n\t\tgoto error_bdev_put;\n\n\t/* pull in the page with our super */\n\tpage = read_cache_page_gfp(bdev->bd_inode->i_mapping,\n\t\t\t\t   index, GFP_NOFS);\n\n\tif (IS_ERR_OR_NULL(page))\n\t\tgoto error_bdev_put;\n\n\tp = kmap(page);\n\n\t/* align our pointer to the offset of the super block */\n\tdisk_super = p + (bytenr & ~PAGE_CACHE_MASK);\n\n\tif (btrfs_super_bytenr(disk_super) != bytenr ||\n\t    btrfs_super_magic(disk_super) != BTRFS_MAGIC)\n\t\tgoto error_unmap;\n\n\tdevid = btrfs_stack_device_id(&disk_super->dev_item);\n\ttransid = btrfs_super_generation(disk_super);\n\ttotal_devices = btrfs_super_num_devices(disk_super);\n\n\tret = device_list_add(path, disk_super, devid, fs_devices_ret);\n\tif (ret > 0) {\n\t\tif (disk_super->label[0]) {\n\t\t\tif (disk_super->label[BTRFS_LABEL_SIZE - 1])\n\t\t\t\tdisk_super->label[BTRFS_LABEL_SIZE - 1] = '\\0';\n\t\t\tprintk(KERN_INFO \"BTRFS: device label %s \", disk_super->label);\n\t\t} else {\n\t\t\tprintk(KERN_INFO \"BTRFS: device fsid %pU \", disk_super->fsid);\n\t\t}\n\n\t\tprintk(KERN_CONT \"devid %llu transid %llu %s\\n\", devid, transid, path);\n\t\tret = 0;\n\t}\n\tif (!ret && fs_devices_ret)\n\t\t(*fs_devices_ret)->total_devices = total_devices;\n\nerror_unmap:\n\tkunmap(page);\n\tpage_cache_release(page);\n\nerror_bdev_put:\n\tblkdev_put(bdev, flags);\nerror:\n\tmutex_unlock(&uuid_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfs.h\"",
            "#include \"dev-replace.h\"",
            "#include \"math.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"async-thread.h\"",
            "#include \"raid56.h\"",
            "#include \"volumes.h\"",
            "#include \"print-tree.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"extent_map.h\"",
            "#include \"ctree.h\"",
            "#include <asm/div64.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/raid/pq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/capability.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/random.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/slab.h>",
            "#include <linux/bio.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);",
            "static void btrfs_dev_stat_print_on_load(struct btrfs_device *device);",
            "static noinline struct",
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfs.h\"\n#include \"dev-replace.h\"\n#include \"math.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"async-thread.h\"\n#include \"raid56.h\"\n#include \"volumes.h\"\n#include \"print-tree.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"extent_map.h\"\n#include \"ctree.h\"\n#include <asm/div64.h>\n#include <linux/semaphore.h>\n#include <linux/raid/pq.h>\n#include <linux/kthread.h>\n#include <linux/ratelimit.h>\n#include <linux/capability.h>\n#include <linux/iocontext.h>\n#include <linux/random.h>\n#include <linux/blkdev.h>\n#include <linux/buffer_head.h>\n#include <linux/slab.h>\n#include <linux/bio.h>\n#include <linux/sched.h>\n\nstatic int init_first_rw_device(struct btrfs_trans_handle *trans,\n\t\t\t\tstruct btrfs_root *root,\n\t\t\t\tstruct btrfs_device *device);\nstatic void btrfs_dev_stat_print_on_load(struct btrfs_device *device);\nstatic noinline struct;\nstatic noinline struct;\n\nint btrfs_scan_one_device(const char *path, fmode_t flags, void *holder,\n\t\t\t  struct btrfs_fs_devices **fs_devices_ret)\n{\n\tstruct btrfs_super_block *disk_super;\n\tstruct block_device *bdev;\n\tstruct page *page;\n\tvoid *p;\n\tint ret = -EINVAL;\n\tu64 devid;\n\tu64 transid;\n\tu64 total_devices;\n\tu64 bytenr;\n\tpgoff_t index;\n\n\t/*\n\t * we would like to check all the supers, but that would make\n\t * a btrfs mount succeed after a mkfs from a different FS.\n\t * So, we need to add a special mount option to scan for\n\t * later supers, using BTRFS_SUPER_MIRROR_MAX instead\n\t */\n\tbytenr = btrfs_sb_offset(0);\n\tflags |= FMODE_EXCL;\n\tmutex_lock(&uuid_mutex);\n\n\tbdev = blkdev_get_by_path(path, flags, holder);\n\n\tif (IS_ERR(bdev)) {\n\t\tret = PTR_ERR(bdev);\n\t\tgoto error;\n\t}\n\n\t/* make sure our super fits in the device */\n\tif (bytenr + PAGE_CACHE_SIZE >= i_size_read(bdev->bd_inode))\n\t\tgoto error_bdev_put;\n\n\t/* make sure our super fits in the page */\n\tif (sizeof(*disk_super) > PAGE_CACHE_SIZE)\n\t\tgoto error_bdev_put;\n\n\t/* make sure our super doesn't straddle pages on disk */\n\tindex = bytenr >> PAGE_CACHE_SHIFT;\n\tif ((bytenr + sizeof(*disk_super) - 1) >> PAGE_CACHE_SHIFT != index)\n\t\tgoto error_bdev_put;\n\n\t/* pull in the page with our super */\n\tpage = read_cache_page_gfp(bdev->bd_inode->i_mapping,\n\t\t\t\t   index, GFP_NOFS);\n\n\tif (IS_ERR_OR_NULL(page))\n\t\tgoto error_bdev_put;\n\n\tp = kmap(page);\n\n\t/* align our pointer to the offset of the super block */\n\tdisk_super = p + (bytenr & ~PAGE_CACHE_MASK);\n\n\tif (btrfs_super_bytenr(disk_super) != bytenr ||\n\t    btrfs_super_magic(disk_super) != BTRFS_MAGIC)\n\t\tgoto error_unmap;\n\n\tdevid = btrfs_stack_device_id(&disk_super->dev_item);\n\ttransid = btrfs_super_generation(disk_super);\n\ttotal_devices = btrfs_super_num_devices(disk_super);\n\n\tret = device_list_add(path, disk_super, devid, fs_devices_ret);\n\tif (ret > 0) {\n\t\tif (disk_super->label[0]) {\n\t\t\tif (disk_super->label[BTRFS_LABEL_SIZE - 1])\n\t\t\t\tdisk_super->label[BTRFS_LABEL_SIZE - 1] = '\\0';\n\t\t\tprintk(KERN_INFO \"BTRFS: device label %s \", disk_super->label);\n\t\t} else {\n\t\t\tprintk(KERN_INFO \"BTRFS: device fsid %pU \", disk_super->fsid);\n\t\t}\n\n\t\tprintk(KERN_CONT \"devid %llu transid %llu %s\\n\", devid, transid, path);\n\t\tret = 0;\n\t}\n\tif (!ret && fs_devices_ret)\n\t\t(*fs_devices_ret)->total_devices = total_devices;\n\nerror_unmap:\n\tkunmap(page);\n\tpage_cache_release(page);\n\nerror_bdev_put:\n\tblkdev_put(bdev, flags);\nerror:\n\tmutex_unlock(&uuid_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_strdup",
          "args": [
            "&args[0]"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING\n\t\t\t\t\"BTRFS: 'subvolrootid' mount option is deprecated and has \"\n\t\t\t\t\"no effect\\n\""
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "num"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memparse",
          "args": [
            "num",
            "NULL"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_strdup",
          "args": [
            "&args[0]"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_strdup",
          "args": [
            "&args[0]"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "*subvol_name"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_token",
          "args": [
            "p",
            "tokens",
            "args"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&opts",
            "\",\""
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "options",
            "GFP_KERNEL"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nstatic match_table_t tokens = {\n\t{Opt_degraded, \"degraded\"},\n\t{Opt_subvol, \"subvol=%s\"},\n\t{Opt_subvolid, \"subvolid=%s\"},\n\t{Opt_device, \"device=%s\"},\n\t{Opt_nodatasum, \"nodatasum\"},\n\t{Opt_datasum, \"datasum\"},\n\t{Opt_nodatacow, \"nodatacow\"},\n\t{Opt_datacow, \"datacow\"},\n\t{Opt_nobarrier, \"nobarrier\"},\n\t{Opt_barrier, \"barrier\"},\n\t{Opt_max_inline, \"max_inline=%s\"},\n\t{Opt_alloc_start, \"alloc_start=%s\"},\n\t{Opt_thread_pool, \"thread_pool=%d\"},\n\t{Opt_compress, \"compress\"},\n\t{Opt_compress_type, \"compress=%s\"},\n\t{Opt_compress_force, \"compress-force\"},\n\t{Opt_compress_force_type, \"compress-force=%s\"},\n\t{Opt_ssd, \"ssd\"},\n\t{Opt_ssd_spread, \"ssd_spread\"},\n\t{Opt_nossd, \"nossd\"},\n\t{Opt_acl, \"acl\"},\n\t{Opt_noacl, \"noacl\"},\n\t{Opt_notreelog, \"notreelog\"},\n\t{Opt_treelog, \"treelog\"},\n\t{Opt_flushoncommit, \"flushoncommit\"},\n\t{Opt_noflushoncommit, \"noflushoncommit\"},\n\t{Opt_ratio, \"metadata_ratio=%d\"},\n\t{Opt_discard, \"discard\"},\n\t{Opt_nodiscard, \"nodiscard\"},\n\t{Opt_space_cache, \"space_cache\"},\n\t{Opt_clear_cache, \"clear_cache\"},\n\t{Opt_user_subvol_rm_allowed, \"user_subvol_rm_allowed\"},\n\t{Opt_enospc_debug, \"enospc_debug\"},\n\t{Opt_noenospc_debug, \"noenospc_debug\"},\n\t{Opt_subvolrootid, \"subvolrootid=%d\"},\n\t{Opt_defrag, \"autodefrag\"},\n\t{Opt_nodefrag, \"noautodefrag\"},\n\t{Opt_inode_cache, \"inode_cache\"},\n\t{Opt_noinode_cache, \"noinode_cache\"},\n\t{Opt_no_space_cache, \"nospace_cache\"},\n\t{Opt_recovery, \"recovery\"},\n\t{Opt_skip_balance, \"skip_balance\"},\n\t{Opt_check_integrity, \"check_int\"},\n\t{Opt_check_integrity_including_extent_data, \"check_int_data\"},\n\t{Opt_check_integrity_print_mask, \"check_int_print_mask=%d\"},\n\t{Opt_rescan_uuid_tree, \"rescan_uuid_tree\"},\n\t{Opt_fatal_errors, \"fatal_errors=%s\"},\n\t{Opt_commit_interval, \"commit=%d\"},\n\t{Opt_err, NULL},\n};\n\nstatic int btrfs_parse_early_options(const char *options, fmode_t flags,\n\t\tvoid *holder, char **subvol_name, u64 *subvol_objectid,\n\t\tstruct btrfs_fs_devices **fs_devices)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\tchar *device_name, *opts, *orig, *p;\n\tchar *num = NULL;\n\tint error = 0;\n\n\tif (!options)\n\t\treturn 0;\n\n\t/*\n\t * strsep changes the string, duplicate it because parse_options\n\t * gets called twice\n\t */\n\topts = kstrdup(options, GFP_KERNEL);\n\tif (!opts)\n\t\treturn -ENOMEM;\n\torig = opts;\n\n\twhile ((p = strsep(&opts, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_subvol:\n\t\t\tkfree(*subvol_name);\n\t\t\t*subvol_name = match_strdup(&args[0]);\n\t\t\tif (!*subvol_name) {\n\t\t\t\terror = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_subvolid:\n\t\t\tnum = match_strdup(&args[0]);\n\t\t\tif (num) {\n\t\t\t\t*subvol_objectid = memparse(num, NULL);\n\t\t\t\tkfree(num);\n\t\t\t\t/* we want the original fs_tree */\n\t\t\t\tif (!*subvol_objectid)\n\t\t\t\t\t*subvol_objectid =\n\t\t\t\t\t\tBTRFS_FS_TREE_OBJECTID;\n\t\t\t} else {\n\t\t\t\terror = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_subvolrootid:\n\t\t\tprintk(KERN_WARNING\n\t\t\t\t\"BTRFS: 'subvolrootid' mount option is deprecated and has \"\n\t\t\t\t\"no effect\\n\");\n\t\t\tbreak;\n\t\tcase Opt_device:\n\t\t\tdevice_name = match_strdup(&args[0]);\n\t\t\tif (!device_name) {\n\t\t\t\terror = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\terror = btrfs_scan_one_device(device_name,\n\t\t\t\t\tflags, holder, fs_devices);\n\t\t\tkfree(device_name);\n\t\t\tif (error)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\tkfree(orig);\n\treturn error;\n}"
  },
  {
    "function_name": "btrfs_parse_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
    "lines": "388-759",
    "snippet": "int btrfs_parse_options(struct btrfs_root *root, char *options)\n{\n\tstruct btrfs_fs_info *info = root->fs_info;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tchar *p, *num, *orig = NULL;\n\tu64 cache_gen;\n\tint intarg;\n\tint ret = 0;\n\tchar *compress_type;\n\tbool compress_force = false;\n\n\tcache_gen = btrfs_super_cache_generation(root->fs_info->super_copy);\n\tif (cache_gen)\n\t\tbtrfs_set_opt(info->mount_opt, SPACE_CACHE);\n\n\tif (!options)\n\t\tgoto out;\n\n\t/*\n\t * strsep changes the string, duplicate it because parse_options\n\t * gets called twice\n\t */\n\toptions = kstrdup(options, GFP_NOFS);\n\tif (!options)\n\t\treturn -ENOMEM;\n\n\torig = options;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_degraded:\n\t\t\tbtrfs_info(root->fs_info, \"allowing degraded mounts\");\n\t\t\tbtrfs_set_opt(info->mount_opt, DEGRADED);\n\t\t\tbreak;\n\t\tcase Opt_subvol:\n\t\tcase Opt_subvolid:\n\t\tcase Opt_subvolrootid:\n\t\tcase Opt_device:\n\t\t\t/*\n\t\t\t * These are parsed by btrfs_parse_early_options\n\t\t\t * and can be happily ignored here.\n\t\t\t */\n\t\t\tbreak;\n\t\tcase Opt_nodatasum:\n\t\t\tbtrfs_set_and_info(root, NODATASUM,\n\t\t\t\t\t   \"setting nodatasum\");\n\t\t\tbreak;\n\t\tcase Opt_datasum:\n\t\t\tif (btrfs_test_opt(root, NODATASUM)) {\n\t\t\t\tif (btrfs_test_opt(root, NODATACOW))\n\t\t\t\t\tbtrfs_info(root->fs_info, \"setting datasum, datacow enabled\");\n\t\t\t\telse\n\t\t\t\t\tbtrfs_info(root->fs_info, \"setting datasum\");\n\t\t\t}\n\t\t\tbtrfs_clear_opt(info->mount_opt, NODATACOW);\n\t\t\tbtrfs_clear_opt(info->mount_opt, NODATASUM);\n\t\t\tbreak;\n\t\tcase Opt_nodatacow:\n\t\t\tif (!btrfs_test_opt(root, NODATACOW)) {\n\t\t\t\tif (!btrfs_test_opt(root, COMPRESS) ||\n\t\t\t\t    !btrfs_test_opt(root, FORCE_COMPRESS)) {\n\t\t\t\t\tbtrfs_info(root->fs_info,\n\t\t\t\t\t\t   \"setting nodatacow, compression disabled\");\n\t\t\t\t} else {\n\t\t\t\t\tbtrfs_info(root->fs_info, \"setting nodatacow\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbtrfs_clear_opt(info->mount_opt, COMPRESS);\n\t\t\tbtrfs_clear_opt(info->mount_opt, FORCE_COMPRESS);\n\t\t\tbtrfs_set_opt(info->mount_opt, NODATACOW);\n\t\t\tbtrfs_set_opt(info->mount_opt, NODATASUM);\n\t\t\tbreak;\n\t\tcase Opt_datacow:\n\t\t\tbtrfs_clear_and_info(root, NODATACOW,\n\t\t\t\t\t     \"setting datacow\");\n\t\t\tbreak;\n\t\tcase Opt_compress_force:\n\t\tcase Opt_compress_force_type:\n\t\t\tcompress_force = true;\n\t\t\t/* Fallthrough */\n\t\tcase Opt_compress:\n\t\tcase Opt_compress_type:\n\t\t\tif (token == Opt_compress ||\n\t\t\t    token == Opt_compress_force ||\n\t\t\t    strcmp(args[0].from, \"zlib\") == 0) {\n\t\t\t\tcompress_type = \"zlib\";\n\t\t\t\tinfo->compress_type = BTRFS_COMPRESS_ZLIB;\n\t\t\t\tbtrfs_set_opt(info->mount_opt, COMPRESS);\n\t\t\t\tbtrfs_clear_opt(info->mount_opt, NODATACOW);\n\t\t\t\tbtrfs_clear_opt(info->mount_opt, NODATASUM);\n\t\t\t} else if (strcmp(args[0].from, \"lzo\") == 0) {\n\t\t\t\tcompress_type = \"lzo\";\n\t\t\t\tinfo->compress_type = BTRFS_COMPRESS_LZO;\n\t\t\t\tbtrfs_set_opt(info->mount_opt, COMPRESS);\n\t\t\t\tbtrfs_clear_opt(info->mount_opt, NODATACOW);\n\t\t\t\tbtrfs_clear_opt(info->mount_opt, NODATASUM);\n\t\t\t\tbtrfs_set_fs_incompat(info, COMPRESS_LZO);\n\t\t\t} else if (strncmp(args[0].from, \"no\", 2) == 0) {\n\t\t\t\tcompress_type = \"no\";\n\t\t\t\tbtrfs_clear_opt(info->mount_opt, COMPRESS);\n\t\t\t\tbtrfs_clear_opt(info->mount_opt, FORCE_COMPRESS);\n\t\t\t\tcompress_force = false;\n\t\t\t} else {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (compress_force) {\n\t\t\t\tbtrfs_set_and_info(root, FORCE_COMPRESS,\n\t\t\t\t\t\t   \"force %s compression\",\n\t\t\t\t\t\t   compress_type);\n\t\t\t} else {\n\t\t\t\tif (!btrfs_test_opt(root, COMPRESS))\n\t\t\t\t\tbtrfs_info(root->fs_info,\n\t\t\t\t\t\t   \"btrfs: use %s compression\",\n\t\t\t\t\t\t   compress_type);\n\t\t\t\t/*\n\t\t\t\t * If we remount from compress-force=xxx to\n\t\t\t\t * compress=xxx, we need clear FORCE_COMPRESS\n\t\t\t\t * flag, otherwise, there is no way for users\n\t\t\t\t * to disable forcible compression separately.\n\t\t\t\t */\n\t\t\t\tbtrfs_clear_opt(info->mount_opt, FORCE_COMPRESS);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_ssd:\n\t\t\tbtrfs_set_and_info(root, SSD,\n\t\t\t\t\t   \"use ssd allocation scheme\");\n\t\t\tbreak;\n\t\tcase Opt_ssd_spread:\n\t\t\tbtrfs_set_and_info(root, SSD_SPREAD,\n\t\t\t\t\t   \"use spread ssd allocation scheme\");\n\t\t\tbtrfs_set_opt(info->mount_opt, SSD);\n\t\t\tbreak;\n\t\tcase Opt_nossd:\n\t\t\tbtrfs_set_and_info(root, NOSSD,\n\t\t\t\t\t     \"not using ssd allocation scheme\");\n\t\t\tbtrfs_clear_opt(info->mount_opt, SSD);\n\t\t\tbreak;\n\t\tcase Opt_barrier:\n\t\t\tbtrfs_clear_and_info(root, NOBARRIER,\n\t\t\t\t\t     \"turning on barriers\");\n\t\t\tbreak;\n\t\tcase Opt_nobarrier:\n\t\t\tbtrfs_set_and_info(root, NOBARRIER,\n\t\t\t\t\t   \"turning off barriers\");\n\t\t\tbreak;\n\t\tcase Opt_thread_pool:\n\t\t\tret = match_int(&args[0], &intarg);\n\t\t\tif (ret) {\n\t\t\t\tgoto out;\n\t\t\t} else if (intarg > 0) {\n\t\t\t\tinfo->thread_pool_size = intarg;\n\t\t\t} else {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_max_inline:\n\t\t\tnum = match_strdup(&args[0]);\n\t\t\tif (num) {\n\t\t\t\tinfo->max_inline = memparse(num, NULL);\n\t\t\t\tkfree(num);\n\n\t\t\t\tif (info->max_inline) {\n\t\t\t\t\tinfo->max_inline = min_t(u64,\n\t\t\t\t\t\tinfo->max_inline,\n\t\t\t\t\t\troot->sectorsize);\n\t\t\t\t}\n\t\t\t\tbtrfs_info(root->fs_info, \"max_inline at %llu\",\n\t\t\t\t\tinfo->max_inline);\n\t\t\t} else {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_alloc_start:\n\t\t\tnum = match_strdup(&args[0]);\n\t\t\tif (num) {\n\t\t\t\tmutex_lock(&info->chunk_mutex);\n\t\t\t\tinfo->alloc_start = memparse(num, NULL);\n\t\t\t\tmutex_unlock(&info->chunk_mutex);\n\t\t\t\tkfree(num);\n\t\t\t\tbtrfs_info(root->fs_info, \"allocations start at %llu\",\n\t\t\t\t\tinfo->alloc_start);\n\t\t\t} else {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_acl:\n#ifdef CONFIG_BTRFS_FS_POSIX_ACL\n\t\t\troot->fs_info->sb->s_flags |= MS_POSIXACL;\n\t\t\tbreak;\n#else\n\t\t\tbtrfs_err(root->fs_info,\n\t\t\t\t\"support for ACL not compiled in!\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n#endif\n\t\tcase Opt_noacl:\n\t\t\troot->fs_info->sb->s_flags &= ~MS_POSIXACL;\n\t\t\tbreak;\n\t\tcase Opt_notreelog:\n\t\t\tbtrfs_set_and_info(root, NOTREELOG,\n\t\t\t\t\t   \"disabling tree log\");\n\t\t\tbreak;\n\t\tcase Opt_treelog:\n\t\t\tbtrfs_clear_and_info(root, NOTREELOG,\n\t\t\t\t\t     \"enabling tree log\");\n\t\t\tbreak;\n\t\tcase Opt_flushoncommit:\n\t\t\tbtrfs_set_and_info(root, FLUSHONCOMMIT,\n\t\t\t\t\t   \"turning on flush-on-commit\");\n\t\t\tbreak;\n\t\tcase Opt_noflushoncommit:\n\t\t\tbtrfs_clear_and_info(root, FLUSHONCOMMIT,\n\t\t\t\t\t     \"turning off flush-on-commit\");\n\t\t\tbreak;\n\t\tcase Opt_ratio:\n\t\t\tret = match_int(&args[0], &intarg);\n\t\t\tif (ret) {\n\t\t\t\tgoto out;\n\t\t\t} else if (intarg >= 0) {\n\t\t\t\tinfo->metadata_ratio = intarg;\n\t\t\t\tbtrfs_info(root->fs_info, \"metadata ratio %d\",\n\t\t\t\t       info->metadata_ratio);\n\t\t\t} else {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_discard:\n\t\t\tbtrfs_set_and_info(root, DISCARD,\n\t\t\t\t\t   \"turning on discard\");\n\t\t\tbreak;\n\t\tcase Opt_nodiscard:\n\t\t\tbtrfs_clear_and_info(root, DISCARD,\n\t\t\t\t\t     \"turning off discard\");\n\t\t\tbreak;\n\t\tcase Opt_space_cache:\n\t\t\tbtrfs_set_and_info(root, SPACE_CACHE,\n\t\t\t\t\t   \"enabling disk space caching\");\n\t\t\tbreak;\n\t\tcase Opt_rescan_uuid_tree:\n\t\t\tbtrfs_set_opt(info->mount_opt, RESCAN_UUID_TREE);\n\t\t\tbreak;\n\t\tcase Opt_no_space_cache:\n\t\t\tbtrfs_clear_and_info(root, SPACE_CACHE,\n\t\t\t\t\t     \"disabling disk space caching\");\n\t\t\tbreak;\n\t\tcase Opt_inode_cache:\n\t\t\tbtrfs_set_pending_and_info(info, INODE_MAP_CACHE,\n\t\t\t\t\t   \"enabling inode map caching\");\n\t\t\tbreak;\n\t\tcase Opt_noinode_cache:\n\t\t\tbtrfs_clear_pending_and_info(info, INODE_MAP_CACHE,\n\t\t\t\t\t     \"disabling inode map caching\");\n\t\t\tbreak;\n\t\tcase Opt_clear_cache:\n\t\t\tbtrfs_set_and_info(root, CLEAR_CACHE,\n\t\t\t\t\t   \"force clearing of disk cache\");\n\t\t\tbreak;\n\t\tcase Opt_user_subvol_rm_allowed:\n\t\t\tbtrfs_set_opt(info->mount_opt, USER_SUBVOL_RM_ALLOWED);\n\t\t\tbreak;\n\t\tcase Opt_enospc_debug:\n\t\t\tbtrfs_set_opt(info->mount_opt, ENOSPC_DEBUG);\n\t\t\tbreak;\n\t\tcase Opt_noenospc_debug:\n\t\t\tbtrfs_clear_opt(info->mount_opt, ENOSPC_DEBUG);\n\t\t\tbreak;\n\t\tcase Opt_defrag:\n\t\t\tbtrfs_set_and_info(root, AUTO_DEFRAG,\n\t\t\t\t\t   \"enabling auto defrag\");\n\t\t\tbreak;\n\t\tcase Opt_nodefrag:\n\t\t\tbtrfs_clear_and_info(root, AUTO_DEFRAG,\n\t\t\t\t\t     \"disabling auto defrag\");\n\t\t\tbreak;\n\t\tcase Opt_recovery:\n\t\t\tbtrfs_info(root->fs_info, \"enabling auto recovery\");\n\t\t\tbtrfs_set_opt(info->mount_opt, RECOVERY);\n\t\t\tbreak;\n\t\tcase Opt_skip_balance:\n\t\t\tbtrfs_set_opt(info->mount_opt, SKIP_BALANCE);\n\t\t\tbreak;\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\t\tcase Opt_check_integrity_including_extent_data:\n\t\t\tbtrfs_info(root->fs_info,\n\t\t\t\t   \"enabling check integrity including extent data\");\n\t\t\tbtrfs_set_opt(info->mount_opt,\n\t\t\t\t      CHECK_INTEGRITY_INCLUDING_EXTENT_DATA);\n\t\t\tbtrfs_set_opt(info->mount_opt, CHECK_INTEGRITY);\n\t\t\tbreak;\n\t\tcase Opt_check_integrity:\n\t\t\tbtrfs_info(root->fs_info, \"enabling check integrity\");\n\t\t\tbtrfs_set_opt(info->mount_opt, CHECK_INTEGRITY);\n\t\t\tbreak;\n\t\tcase Opt_check_integrity_print_mask:\n\t\t\tret = match_int(&args[0], &intarg);\n\t\t\tif (ret) {\n\t\t\t\tgoto out;\n\t\t\t} else if (intarg >= 0) {\n\t\t\t\tinfo->check_integrity_print_mask = intarg;\n\t\t\t\tbtrfs_info(root->fs_info, \"check_integrity_print_mask 0x%x\",\n\t\t\t\t       info->check_integrity_print_mask);\n\t\t\t} else {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n#else\n\t\tcase Opt_check_integrity_including_extent_data:\n\t\tcase Opt_check_integrity:\n\t\tcase Opt_check_integrity_print_mask:\n\t\t\tbtrfs_err(root->fs_info,\n\t\t\t\t\"support for check_integrity* not compiled in!\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n#endif\n\t\tcase Opt_fatal_errors:\n\t\t\tif (strcmp(args[0].from, \"panic\") == 0)\n\t\t\t\tbtrfs_set_opt(info->mount_opt,\n\t\t\t\t\t      PANIC_ON_FATAL_ERROR);\n\t\t\telse if (strcmp(args[0].from, \"bug\") == 0)\n\t\t\t\tbtrfs_clear_opt(info->mount_opt,\n\t\t\t\t\t      PANIC_ON_FATAL_ERROR);\n\t\t\telse {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_commit_interval:\n\t\t\tintarg = 0;\n\t\t\tret = match_int(&args[0], &intarg);\n\t\t\tif (ret < 0) {\n\t\t\t\tbtrfs_err(root->fs_info, \"invalid commit interval\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (intarg > 0) {\n\t\t\t\tif (intarg > 300) {\n\t\t\t\t\tbtrfs_warn(root->fs_info, \"excessive commit interval %d\",\n\t\t\t\t\t\t\tintarg);\n\t\t\t\t}\n\t\t\t\tinfo->commit_interval = intarg;\n\t\t\t} else {\n\t\t\t\tbtrfs_info(root->fs_info, \"using default commit interval %ds\",\n\t\t\t\t    BTRFS_DEFAULT_COMMIT_INTERVAL);\n\t\t\t\tinfo->commit_interval = BTRFS_DEFAULT_COMMIT_INTERVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_err:\n\t\t\tbtrfs_info(root->fs_info, \"unrecognized mount option '%s'\", p);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tif (!ret && btrfs_test_opt(root, SPACE_CACHE))\n\t\tbtrfs_info(root->fs_info, \"disk space caching is enabled\");\n\tkfree(orig);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/btrfs.h>",
      "#include \"qgroup.h\"",
      "#include \"tests/btrfs-tests.h\"",
      "#include \"backref.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"compression.h\"",
      "#include \"export.h\"",
      "#include \"volumes.h\"",
      "#include \"xattr.h\"",
      "#include \"props.h\"",
      "#include \"hash.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/namei.h>",
      "#include <linux/ctype.h>",
      "#include <linux/parser.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int btrfs_remount(struct super_block *sb, int *flags, char *data);",
      "static match_table_t tokens = {\n\t{Opt_degraded, \"degraded\"},\n\t{Opt_subvol, \"subvol=%s\"},\n\t{Opt_subvolid, \"subvolid=%s\"},\n\t{Opt_device, \"device=%s\"},\n\t{Opt_nodatasum, \"nodatasum\"},\n\t{Opt_datasum, \"datasum\"},\n\t{Opt_nodatacow, \"nodatacow\"},\n\t{Opt_datacow, \"datacow\"},\n\t{Opt_nobarrier, \"nobarrier\"},\n\t{Opt_barrier, \"barrier\"},\n\t{Opt_max_inline, \"max_inline=%s\"},\n\t{Opt_alloc_start, \"alloc_start=%s\"},\n\t{Opt_thread_pool, \"thread_pool=%d\"},\n\t{Opt_compress, \"compress\"},\n\t{Opt_compress_type, \"compress=%s\"},\n\t{Opt_compress_force, \"compress-force\"},\n\t{Opt_compress_force_type, \"compress-force=%s\"},\n\t{Opt_ssd, \"ssd\"},\n\t{Opt_ssd_spread, \"ssd_spread\"},\n\t{Opt_nossd, \"nossd\"},\n\t{Opt_acl, \"acl\"},\n\t{Opt_noacl, \"noacl\"},\n\t{Opt_notreelog, \"notreelog\"},\n\t{Opt_treelog, \"treelog\"},\n\t{Opt_flushoncommit, \"flushoncommit\"},\n\t{Opt_noflushoncommit, \"noflushoncommit\"},\n\t{Opt_ratio, \"metadata_ratio=%d\"},\n\t{Opt_discard, \"discard\"},\n\t{Opt_nodiscard, \"nodiscard\"},\n\t{Opt_space_cache, \"space_cache\"},\n\t{Opt_clear_cache, \"clear_cache\"},\n\t{Opt_user_subvol_rm_allowed, \"user_subvol_rm_allowed\"},\n\t{Opt_enospc_debug, \"enospc_debug\"},\n\t{Opt_noenospc_debug, \"noenospc_debug\"},\n\t{Opt_subvolrootid, \"subvolrootid=%d\"},\n\t{Opt_defrag, \"autodefrag\"},\n\t{Opt_nodefrag, \"noautodefrag\"},\n\t{Opt_inode_cache, \"inode_cache\"},\n\t{Opt_noinode_cache, \"noinode_cache\"},\n\t{Opt_no_space_cache, \"nospace_cache\"},\n\t{Opt_recovery, \"recovery\"},\n\t{Opt_skip_balance, \"skip_balance\"},\n\t{Opt_check_integrity, \"check_int\"},\n\t{Opt_check_integrity_including_extent_data, \"check_int_data\"},\n\t{Opt_check_integrity_print_mask, \"check_int_print_mask=%d\"},\n\t{Opt_rescan_uuid_tree, \"rescan_uuid_tree\"},\n\t{Opt_fatal_errors, \"fatal_errors=%s\"},\n\t{Opt_commit_interval, \"commit=%d\"},\n\t{Opt_err, NULL},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "orig"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_info",
          "args": [
            "root->fs_info",
            "\"disk space caching is enabled\""
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_test_opt",
          "args": [
            "root",
            "SPACE_CACHE"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_info",
          "args": [
            "root->fs_info",
            "\"unrecognized mount option '%s'\"",
            "p"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_info",
          "args": [
            "root->fs_info",
            "\"using default commit interval %ds\"",
            "BTRFS_DEFAULT_COMMIT_INTERVAL"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_warn",
          "args": [
            "root->fs_info",
            "\"excessive commit interval %d\"",
            "intarg"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_err",
          "args": [
            "root->fs_info",
            "\"invalid commit interval\""
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "&args[0]",
            "&intarg"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_clear_opt",
          "args": [
            "info->mount_opt",
            "PANIC_ON_FATAL_ERROR"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "args[0].from",
            "\"bug\""
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "strcmp_null",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/super.c",
          "lines": "292-301",
          "snippet": "static int strcmp_null(const char *s1, const char *s2)\n{\n\tif (!s1 && !s2)\n\t\treturn 0;\n\tif (s1 && !s2)\n\t\treturn -1;\n\tif (!s1 && s2)\n\t\treturn 1;\n\treturn strcmp(s1, s2);\n}",
          "includes": [
            "#include <linux/ceph/debugfs.h>",
            "#include <linux/ceph/auth.h>",
            "#include <linux/ceph/mon_client.h>",
            "#include <linux/ceph/decode.h>",
            "#include <linux/ceph/ceph_features.h>",
            "#include \"cache.h\"",
            "#include \"mds_client.h\"",
            "#include \"super.h\"",
            "#include <linux/string.h>",
            "#include <linux/statfs.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/parser.h>",
            "#include <linux/mount.h>",
            "#include <linux/module.h>",
            "#include <linux/in6.h>",
            "#include <linux/inet.h>",
            "#include <linux/fs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ceph/debugfs.h>\n#include <linux/ceph/auth.h>\n#include <linux/ceph/mon_client.h>\n#include <linux/ceph/decode.h>\n#include <linux/ceph/ceph_features.h>\n#include \"cache.h\"\n#include \"mds_client.h\"\n#include \"super.h\"\n#include <linux/string.h>\n#include <linux/statfs.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/parser.h>\n#include <linux/mount.h>\n#include <linux/module.h>\n#include <linux/in6.h>\n#include <linux/inet.h>\n#include <linux/fs.h>\n#include <linux/ctype.h>\n#include <linux/backing-dev.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic int strcmp_null(const char *s1, const char *s2)\n{\n\tif (!s1 && !s2)\n\t\treturn 0;\n\tif (s1 && !s2)\n\t\treturn -1;\n\tif (!s1 && s2)\n\t\treturn 1;\n\treturn strcmp(s1, s2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_set_opt",
          "args": [
            "info->mount_opt",
            "PANIC_ON_FATAL_ERROR"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_err",
          "args": [
            "root->fs_info",
            "\"support for check_integrity* not compiled in!\""
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_info",
          "args": [
            "root->fs_info",
            "\"check_integrity_print_mask 0x%x\"",
            "info->check_integrity_print_mask"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "&args[0]",
            "&intarg"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_opt",
          "args": [
            "info->mount_opt",
            "CHECK_INTEGRITY"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_info",
          "args": [
            "root->fs_info",
            "\"enabling check integrity\""
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_opt",
          "args": [
            "info->mount_opt",
            "CHECK_INTEGRITY"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_opt",
          "args": [
            "info->mount_opt",
            "CHECK_INTEGRITY_INCLUDING_EXTENT_DATA"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_info",
          "args": [
            "root->fs_info",
            "\"enabling check integrity including extent data\""
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_opt",
          "args": [
            "info->mount_opt",
            "SKIP_BALANCE"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_opt",
          "args": [
            "info->mount_opt",
            "RECOVERY"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_info",
          "args": [
            "root->fs_info",
            "\"enabling auto recovery\""
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_clear_and_info",
          "args": [
            "root",
            "AUTO_DEFRAG",
            "\"disabling auto defrag\""
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_and_info",
          "args": [
            "root",
            "AUTO_DEFRAG",
            "\"enabling auto defrag\""
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_clear_opt",
          "args": [
            "info->mount_opt",
            "ENOSPC_DEBUG"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_opt",
          "args": [
            "info->mount_opt",
            "ENOSPC_DEBUG"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_opt",
          "args": [
            "info->mount_opt",
            "USER_SUBVOL_RM_ALLOWED"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_and_info",
          "args": [
            "root",
            "CLEAR_CACHE",
            "\"force clearing of disk cache\""
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_clear_pending_and_info",
          "args": [
            "info",
            "INODE_MAP_CACHE",
            "\"disabling inode map caching\""
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_pending_and_info",
          "args": [
            "info",
            "INODE_MAP_CACHE",
            "\"enabling inode map caching\""
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_clear_and_info",
          "args": [
            "root",
            "SPACE_CACHE",
            "\"disabling disk space caching\""
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_opt",
          "args": [
            "info->mount_opt",
            "RESCAN_UUID_TREE"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_and_info",
          "args": [
            "root",
            "SPACE_CACHE",
            "\"enabling disk space caching\""
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_clear_and_info",
          "args": [
            "root",
            "DISCARD",
            "\"turning off discard\""
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_and_info",
          "args": [
            "root",
            "DISCARD",
            "\"turning on discard\""
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_info",
          "args": [
            "root->fs_info",
            "\"metadata ratio %d\"",
            "info->metadata_ratio"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "&args[0]",
            "&intarg"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_clear_and_info",
          "args": [
            "root",
            "FLUSHONCOMMIT",
            "\"turning off flush-on-commit\""
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_and_info",
          "args": [
            "root",
            "FLUSHONCOMMIT",
            "\"turning on flush-on-commit\""
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_clear_and_info",
          "args": [
            "root",
            "NOTREELOG",
            "\"enabling tree log\""
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_and_info",
          "args": [
            "root",
            "NOTREELOG",
            "\"disabling tree log\""
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_err",
          "args": [
            "root->fs_info",
            "\"support for ACL not compiled in!\""
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_info",
          "args": [
            "root->fs_info",
            "\"allocations start at %llu\"",
            "info->alloc_start"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "num"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&info->chunk_mutex"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memparse",
          "args": [
            "num",
            "NULL"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&info->chunk_mutex"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_strdup",
          "args": [
            "&args[0]"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_info",
          "args": [
            "root->fs_info",
            "\"max_inline at %llu\"",
            "info->max_inline"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u64",
            "info->max_inline",
            "root->sectorsize"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "num"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memparse",
          "args": [
            "num",
            "NULL"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_strdup",
          "args": [
            "&args[0]"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "&args[0]",
            "&intarg"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_and_info",
          "args": [
            "root",
            "NOBARRIER",
            "\"turning off barriers\""
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_clear_and_info",
          "args": [
            "root",
            "NOBARRIER",
            "\"turning on barriers\""
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_clear_opt",
          "args": [
            "info->mount_opt",
            "SSD"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_and_info",
          "args": [
            "root",
            "NOSSD",
            "\"not using ssd allocation scheme\""
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_opt",
          "args": [
            "info->mount_opt",
            "SSD"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_and_info",
          "args": [
            "root",
            "SSD_SPREAD",
            "\"use spread ssd allocation scheme\""
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_and_info",
          "args": [
            "root",
            "SSD",
            "\"use ssd allocation scheme\""
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_clear_opt",
          "args": [
            "info->mount_opt",
            "FORCE_COMPRESS"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_info",
          "args": [
            "root->fs_info",
            "\"btrfs: use %s compression\"",
            "compress_type"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_test_opt",
          "args": [
            "root",
            "COMPRESS"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_and_info",
          "args": [
            "root",
            "FORCE_COMPRESS",
            "\"force %s compression\"",
            "compress_type"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_clear_opt",
          "args": [
            "info->mount_opt",
            "FORCE_COMPRESS"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_clear_opt",
          "args": [
            "info->mount_opt",
            "COMPRESS"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "args[0].from",
            "\"no\"",
            "2"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_fs_incompat",
          "args": [
            "info",
            "COMPRESS_LZO"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_set_fs_incompat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "4040-4059",
          "snippet": "static inline void __btrfs_set_fs_incompat(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t   u64 flag)\n{\n\tstruct btrfs_super_block *disk_super;\n\tu64 features;\n\n\tdisk_super = fs_info->super_copy;\n\tfeatures = btrfs_super_incompat_flags(disk_super);\n\tif (!(features & flag)) {\n\t\tspin_lock(&fs_info->super_lock);\n\t\tfeatures = btrfs_super_incompat_flags(disk_super);\n\t\tif (!(features & flag)) {\n\t\t\tfeatures |= flag;\n\t\t\tbtrfs_set_super_incompat_flags(disk_super, features);\n\t\t\tbtrfs_info(fs_info, \"setting %llu feature flag\",\n\t\t\t\t\t flag);\n\t\t}\n\t\tspin_unlock(&fs_info->super_lock);\n\t}\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void __btrfs_set_fs_incompat(struct btrfs_fs_info *fs_info,\n\t\t\t\t\t   u64 flag)\n{\n\tstruct btrfs_super_block *disk_super;\n\tu64 features;\n\n\tdisk_super = fs_info->super_copy;\n\tfeatures = btrfs_super_incompat_flags(disk_super);\n\tif (!(features & flag)) {\n\t\tspin_lock(&fs_info->super_lock);\n\t\tfeatures = btrfs_super_incompat_flags(disk_super);\n\t\tif (!(features & flag)) {\n\t\t\tfeatures |= flag;\n\t\t\tbtrfs_set_super_incompat_flags(disk_super, features);\n\t\t\tbtrfs_info(fs_info, \"setting %llu feature flag\",\n\t\t\t\t\t flag);\n\t\t}\n\t\tspin_unlock(&fs_info->super_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_clear_opt",
          "args": [
            "info->mount_opt",
            "NODATASUM"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_clear_opt",
          "args": [
            "info->mount_opt",
            "NODATACOW"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_opt",
          "args": [
            "info->mount_opt",
            "COMPRESS"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_clear_opt",
          "args": [
            "info->mount_opt",
            "NODATASUM"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_clear_opt",
          "args": [
            "info->mount_opt",
            "NODATACOW"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_opt",
          "args": [
            "info->mount_opt",
            "COMPRESS"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_clear_and_info",
          "args": [
            "root",
            "NODATACOW",
            "\"setting datacow\""
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_opt",
          "args": [
            "info->mount_opt",
            "NODATASUM"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_opt",
          "args": [
            "info->mount_opt",
            "NODATACOW"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_clear_opt",
          "args": [
            "info->mount_opt",
            "FORCE_COMPRESS"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_clear_opt",
          "args": [
            "info->mount_opt",
            "COMPRESS"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_info",
          "args": [
            "root->fs_info",
            "\"setting nodatacow\""
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_info",
          "args": [
            "root->fs_info",
            "\"setting nodatacow, compression disabled\""
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_test_opt",
          "args": [
            "root",
            "FORCE_COMPRESS"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_test_opt",
          "args": [
            "root",
            "COMPRESS"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_test_opt",
          "args": [
            "root",
            "NODATACOW"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_clear_opt",
          "args": [
            "info->mount_opt",
            "NODATASUM"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_clear_opt",
          "args": [
            "info->mount_opt",
            "NODATACOW"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_info",
          "args": [
            "root->fs_info",
            "\"setting datasum\""
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_info",
          "args": [
            "root->fs_info",
            "\"setting datasum, datacow enabled\""
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_test_opt",
          "args": [
            "root",
            "NODATACOW"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_test_opt",
          "args": [
            "root",
            "NODATASUM"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_and_info",
          "args": [
            "root",
            "NODATASUM",
            "\"setting nodatasum\""
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_opt",
          "args": [
            "info->mount_opt",
            "DEGRADED"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_info",
          "args": [
            "root->fs_info",
            "\"allowing degraded mounts\""
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_token",
          "args": [
            "p",
            "tokens",
            "args"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&options",
            "\",\""
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "options",
            "GFP_NOFS"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_set_opt",
          "args": [
            "info->mount_opt",
            "SPACE_CACHE"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_super_cache_generation",
          "args": [
            "root->fs_info->super_copy"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nstatic int btrfs_remount(struct super_block *sb, int *flags, char *data);\nstatic match_table_t tokens = {\n\t{Opt_degraded, \"degraded\"},\n\t{Opt_subvol, \"subvol=%s\"},\n\t{Opt_subvolid, \"subvolid=%s\"},\n\t{Opt_device, \"device=%s\"},\n\t{Opt_nodatasum, \"nodatasum\"},\n\t{Opt_datasum, \"datasum\"},\n\t{Opt_nodatacow, \"nodatacow\"},\n\t{Opt_datacow, \"datacow\"},\n\t{Opt_nobarrier, \"nobarrier\"},\n\t{Opt_barrier, \"barrier\"},\n\t{Opt_max_inline, \"max_inline=%s\"},\n\t{Opt_alloc_start, \"alloc_start=%s\"},\n\t{Opt_thread_pool, \"thread_pool=%d\"},\n\t{Opt_compress, \"compress\"},\n\t{Opt_compress_type, \"compress=%s\"},\n\t{Opt_compress_force, \"compress-force\"},\n\t{Opt_compress_force_type, \"compress-force=%s\"},\n\t{Opt_ssd, \"ssd\"},\n\t{Opt_ssd_spread, \"ssd_spread\"},\n\t{Opt_nossd, \"nossd\"},\n\t{Opt_acl, \"acl\"},\n\t{Opt_noacl, \"noacl\"},\n\t{Opt_notreelog, \"notreelog\"},\n\t{Opt_treelog, \"treelog\"},\n\t{Opt_flushoncommit, \"flushoncommit\"},\n\t{Opt_noflushoncommit, \"noflushoncommit\"},\n\t{Opt_ratio, \"metadata_ratio=%d\"},\n\t{Opt_discard, \"discard\"},\n\t{Opt_nodiscard, \"nodiscard\"},\n\t{Opt_space_cache, \"space_cache\"},\n\t{Opt_clear_cache, \"clear_cache\"},\n\t{Opt_user_subvol_rm_allowed, \"user_subvol_rm_allowed\"},\n\t{Opt_enospc_debug, \"enospc_debug\"},\n\t{Opt_noenospc_debug, \"noenospc_debug\"},\n\t{Opt_subvolrootid, \"subvolrootid=%d\"},\n\t{Opt_defrag, \"autodefrag\"},\n\t{Opt_nodefrag, \"noautodefrag\"},\n\t{Opt_inode_cache, \"inode_cache\"},\n\t{Opt_noinode_cache, \"noinode_cache\"},\n\t{Opt_no_space_cache, \"nospace_cache\"},\n\t{Opt_recovery, \"recovery\"},\n\t{Opt_skip_balance, \"skip_balance\"},\n\t{Opt_check_integrity, \"check_int\"},\n\t{Opt_check_integrity_including_extent_data, \"check_int_data\"},\n\t{Opt_check_integrity_print_mask, \"check_int_print_mask=%d\"},\n\t{Opt_rescan_uuid_tree, \"rescan_uuid_tree\"},\n\t{Opt_fatal_errors, \"fatal_errors=%s\"},\n\t{Opt_commit_interval, \"commit=%d\"},\n\t{Opt_err, NULL},\n};\n\nint btrfs_parse_options(struct btrfs_root *root, char *options)\n{\n\tstruct btrfs_fs_info *info = root->fs_info;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tchar *p, *num, *orig = NULL;\n\tu64 cache_gen;\n\tint intarg;\n\tint ret = 0;\n\tchar *compress_type;\n\tbool compress_force = false;\n\n\tcache_gen = btrfs_super_cache_generation(root->fs_info->super_copy);\n\tif (cache_gen)\n\t\tbtrfs_set_opt(info->mount_opt, SPACE_CACHE);\n\n\tif (!options)\n\t\tgoto out;\n\n\t/*\n\t * strsep changes the string, duplicate it because parse_options\n\t * gets called twice\n\t */\n\toptions = kstrdup(options, GFP_NOFS);\n\tif (!options)\n\t\treturn -ENOMEM;\n\n\torig = options;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_degraded:\n\t\t\tbtrfs_info(root->fs_info, \"allowing degraded mounts\");\n\t\t\tbtrfs_set_opt(info->mount_opt, DEGRADED);\n\t\t\tbreak;\n\t\tcase Opt_subvol:\n\t\tcase Opt_subvolid:\n\t\tcase Opt_subvolrootid:\n\t\tcase Opt_device:\n\t\t\t/*\n\t\t\t * These are parsed by btrfs_parse_early_options\n\t\t\t * and can be happily ignored here.\n\t\t\t */\n\t\t\tbreak;\n\t\tcase Opt_nodatasum:\n\t\t\tbtrfs_set_and_info(root, NODATASUM,\n\t\t\t\t\t   \"setting nodatasum\");\n\t\t\tbreak;\n\t\tcase Opt_datasum:\n\t\t\tif (btrfs_test_opt(root, NODATASUM)) {\n\t\t\t\tif (btrfs_test_opt(root, NODATACOW))\n\t\t\t\t\tbtrfs_info(root->fs_info, \"setting datasum, datacow enabled\");\n\t\t\t\telse\n\t\t\t\t\tbtrfs_info(root->fs_info, \"setting datasum\");\n\t\t\t}\n\t\t\tbtrfs_clear_opt(info->mount_opt, NODATACOW);\n\t\t\tbtrfs_clear_opt(info->mount_opt, NODATASUM);\n\t\t\tbreak;\n\t\tcase Opt_nodatacow:\n\t\t\tif (!btrfs_test_opt(root, NODATACOW)) {\n\t\t\t\tif (!btrfs_test_opt(root, COMPRESS) ||\n\t\t\t\t    !btrfs_test_opt(root, FORCE_COMPRESS)) {\n\t\t\t\t\tbtrfs_info(root->fs_info,\n\t\t\t\t\t\t   \"setting nodatacow, compression disabled\");\n\t\t\t\t} else {\n\t\t\t\t\tbtrfs_info(root->fs_info, \"setting nodatacow\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbtrfs_clear_opt(info->mount_opt, COMPRESS);\n\t\t\tbtrfs_clear_opt(info->mount_opt, FORCE_COMPRESS);\n\t\t\tbtrfs_set_opt(info->mount_opt, NODATACOW);\n\t\t\tbtrfs_set_opt(info->mount_opt, NODATASUM);\n\t\t\tbreak;\n\t\tcase Opt_datacow:\n\t\t\tbtrfs_clear_and_info(root, NODATACOW,\n\t\t\t\t\t     \"setting datacow\");\n\t\t\tbreak;\n\t\tcase Opt_compress_force:\n\t\tcase Opt_compress_force_type:\n\t\t\tcompress_force = true;\n\t\t\t/* Fallthrough */\n\t\tcase Opt_compress:\n\t\tcase Opt_compress_type:\n\t\t\tif (token == Opt_compress ||\n\t\t\t    token == Opt_compress_force ||\n\t\t\t    strcmp(args[0].from, \"zlib\") == 0) {\n\t\t\t\tcompress_type = \"zlib\";\n\t\t\t\tinfo->compress_type = BTRFS_COMPRESS_ZLIB;\n\t\t\t\tbtrfs_set_opt(info->mount_opt, COMPRESS);\n\t\t\t\tbtrfs_clear_opt(info->mount_opt, NODATACOW);\n\t\t\t\tbtrfs_clear_opt(info->mount_opt, NODATASUM);\n\t\t\t} else if (strcmp(args[0].from, \"lzo\") == 0) {\n\t\t\t\tcompress_type = \"lzo\";\n\t\t\t\tinfo->compress_type = BTRFS_COMPRESS_LZO;\n\t\t\t\tbtrfs_set_opt(info->mount_opt, COMPRESS);\n\t\t\t\tbtrfs_clear_opt(info->mount_opt, NODATACOW);\n\t\t\t\tbtrfs_clear_opt(info->mount_opt, NODATASUM);\n\t\t\t\tbtrfs_set_fs_incompat(info, COMPRESS_LZO);\n\t\t\t} else if (strncmp(args[0].from, \"no\", 2) == 0) {\n\t\t\t\tcompress_type = \"no\";\n\t\t\t\tbtrfs_clear_opt(info->mount_opt, COMPRESS);\n\t\t\t\tbtrfs_clear_opt(info->mount_opt, FORCE_COMPRESS);\n\t\t\t\tcompress_force = false;\n\t\t\t} else {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tif (compress_force) {\n\t\t\t\tbtrfs_set_and_info(root, FORCE_COMPRESS,\n\t\t\t\t\t\t   \"force %s compression\",\n\t\t\t\t\t\t   compress_type);\n\t\t\t} else {\n\t\t\t\tif (!btrfs_test_opt(root, COMPRESS))\n\t\t\t\t\tbtrfs_info(root->fs_info,\n\t\t\t\t\t\t   \"btrfs: use %s compression\",\n\t\t\t\t\t\t   compress_type);\n\t\t\t\t/*\n\t\t\t\t * If we remount from compress-force=xxx to\n\t\t\t\t * compress=xxx, we need clear FORCE_COMPRESS\n\t\t\t\t * flag, otherwise, there is no way for users\n\t\t\t\t * to disable forcible compression separately.\n\t\t\t\t */\n\t\t\t\tbtrfs_clear_opt(info->mount_opt, FORCE_COMPRESS);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_ssd:\n\t\t\tbtrfs_set_and_info(root, SSD,\n\t\t\t\t\t   \"use ssd allocation scheme\");\n\t\t\tbreak;\n\t\tcase Opt_ssd_spread:\n\t\t\tbtrfs_set_and_info(root, SSD_SPREAD,\n\t\t\t\t\t   \"use spread ssd allocation scheme\");\n\t\t\tbtrfs_set_opt(info->mount_opt, SSD);\n\t\t\tbreak;\n\t\tcase Opt_nossd:\n\t\t\tbtrfs_set_and_info(root, NOSSD,\n\t\t\t\t\t     \"not using ssd allocation scheme\");\n\t\t\tbtrfs_clear_opt(info->mount_opt, SSD);\n\t\t\tbreak;\n\t\tcase Opt_barrier:\n\t\t\tbtrfs_clear_and_info(root, NOBARRIER,\n\t\t\t\t\t     \"turning on barriers\");\n\t\t\tbreak;\n\t\tcase Opt_nobarrier:\n\t\t\tbtrfs_set_and_info(root, NOBARRIER,\n\t\t\t\t\t   \"turning off barriers\");\n\t\t\tbreak;\n\t\tcase Opt_thread_pool:\n\t\t\tret = match_int(&args[0], &intarg);\n\t\t\tif (ret) {\n\t\t\t\tgoto out;\n\t\t\t} else if (intarg > 0) {\n\t\t\t\tinfo->thread_pool_size = intarg;\n\t\t\t} else {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_max_inline:\n\t\t\tnum = match_strdup(&args[0]);\n\t\t\tif (num) {\n\t\t\t\tinfo->max_inline = memparse(num, NULL);\n\t\t\t\tkfree(num);\n\n\t\t\t\tif (info->max_inline) {\n\t\t\t\t\tinfo->max_inline = min_t(u64,\n\t\t\t\t\t\tinfo->max_inline,\n\t\t\t\t\t\troot->sectorsize);\n\t\t\t\t}\n\t\t\t\tbtrfs_info(root->fs_info, \"max_inline at %llu\",\n\t\t\t\t\tinfo->max_inline);\n\t\t\t} else {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_alloc_start:\n\t\t\tnum = match_strdup(&args[0]);\n\t\t\tif (num) {\n\t\t\t\tmutex_lock(&info->chunk_mutex);\n\t\t\t\tinfo->alloc_start = memparse(num, NULL);\n\t\t\t\tmutex_unlock(&info->chunk_mutex);\n\t\t\t\tkfree(num);\n\t\t\t\tbtrfs_info(root->fs_info, \"allocations start at %llu\",\n\t\t\t\t\tinfo->alloc_start);\n\t\t\t} else {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_acl:\n#ifdef CONFIG_BTRFS_FS_POSIX_ACL\n\t\t\troot->fs_info->sb->s_flags |= MS_POSIXACL;\n\t\t\tbreak;\n#else\n\t\t\tbtrfs_err(root->fs_info,\n\t\t\t\t\"support for ACL not compiled in!\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n#endif\n\t\tcase Opt_noacl:\n\t\t\troot->fs_info->sb->s_flags &= ~MS_POSIXACL;\n\t\t\tbreak;\n\t\tcase Opt_notreelog:\n\t\t\tbtrfs_set_and_info(root, NOTREELOG,\n\t\t\t\t\t   \"disabling tree log\");\n\t\t\tbreak;\n\t\tcase Opt_treelog:\n\t\t\tbtrfs_clear_and_info(root, NOTREELOG,\n\t\t\t\t\t     \"enabling tree log\");\n\t\t\tbreak;\n\t\tcase Opt_flushoncommit:\n\t\t\tbtrfs_set_and_info(root, FLUSHONCOMMIT,\n\t\t\t\t\t   \"turning on flush-on-commit\");\n\t\t\tbreak;\n\t\tcase Opt_noflushoncommit:\n\t\t\tbtrfs_clear_and_info(root, FLUSHONCOMMIT,\n\t\t\t\t\t     \"turning off flush-on-commit\");\n\t\t\tbreak;\n\t\tcase Opt_ratio:\n\t\t\tret = match_int(&args[0], &intarg);\n\t\t\tif (ret) {\n\t\t\t\tgoto out;\n\t\t\t} else if (intarg >= 0) {\n\t\t\t\tinfo->metadata_ratio = intarg;\n\t\t\t\tbtrfs_info(root->fs_info, \"metadata ratio %d\",\n\t\t\t\t       info->metadata_ratio);\n\t\t\t} else {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_discard:\n\t\t\tbtrfs_set_and_info(root, DISCARD,\n\t\t\t\t\t   \"turning on discard\");\n\t\t\tbreak;\n\t\tcase Opt_nodiscard:\n\t\t\tbtrfs_clear_and_info(root, DISCARD,\n\t\t\t\t\t     \"turning off discard\");\n\t\t\tbreak;\n\t\tcase Opt_space_cache:\n\t\t\tbtrfs_set_and_info(root, SPACE_CACHE,\n\t\t\t\t\t   \"enabling disk space caching\");\n\t\t\tbreak;\n\t\tcase Opt_rescan_uuid_tree:\n\t\t\tbtrfs_set_opt(info->mount_opt, RESCAN_UUID_TREE);\n\t\t\tbreak;\n\t\tcase Opt_no_space_cache:\n\t\t\tbtrfs_clear_and_info(root, SPACE_CACHE,\n\t\t\t\t\t     \"disabling disk space caching\");\n\t\t\tbreak;\n\t\tcase Opt_inode_cache:\n\t\t\tbtrfs_set_pending_and_info(info, INODE_MAP_CACHE,\n\t\t\t\t\t   \"enabling inode map caching\");\n\t\t\tbreak;\n\t\tcase Opt_noinode_cache:\n\t\t\tbtrfs_clear_pending_and_info(info, INODE_MAP_CACHE,\n\t\t\t\t\t     \"disabling inode map caching\");\n\t\t\tbreak;\n\t\tcase Opt_clear_cache:\n\t\t\tbtrfs_set_and_info(root, CLEAR_CACHE,\n\t\t\t\t\t   \"force clearing of disk cache\");\n\t\t\tbreak;\n\t\tcase Opt_user_subvol_rm_allowed:\n\t\t\tbtrfs_set_opt(info->mount_opt, USER_SUBVOL_RM_ALLOWED);\n\t\t\tbreak;\n\t\tcase Opt_enospc_debug:\n\t\t\tbtrfs_set_opt(info->mount_opt, ENOSPC_DEBUG);\n\t\t\tbreak;\n\t\tcase Opt_noenospc_debug:\n\t\t\tbtrfs_clear_opt(info->mount_opt, ENOSPC_DEBUG);\n\t\t\tbreak;\n\t\tcase Opt_defrag:\n\t\t\tbtrfs_set_and_info(root, AUTO_DEFRAG,\n\t\t\t\t\t   \"enabling auto defrag\");\n\t\t\tbreak;\n\t\tcase Opt_nodefrag:\n\t\t\tbtrfs_clear_and_info(root, AUTO_DEFRAG,\n\t\t\t\t\t     \"disabling auto defrag\");\n\t\t\tbreak;\n\t\tcase Opt_recovery:\n\t\t\tbtrfs_info(root->fs_info, \"enabling auto recovery\");\n\t\t\tbtrfs_set_opt(info->mount_opt, RECOVERY);\n\t\t\tbreak;\n\t\tcase Opt_skip_balance:\n\t\t\tbtrfs_set_opt(info->mount_opt, SKIP_BALANCE);\n\t\t\tbreak;\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\t\tcase Opt_check_integrity_including_extent_data:\n\t\t\tbtrfs_info(root->fs_info,\n\t\t\t\t   \"enabling check integrity including extent data\");\n\t\t\tbtrfs_set_opt(info->mount_opt,\n\t\t\t\t      CHECK_INTEGRITY_INCLUDING_EXTENT_DATA);\n\t\t\tbtrfs_set_opt(info->mount_opt, CHECK_INTEGRITY);\n\t\t\tbreak;\n\t\tcase Opt_check_integrity:\n\t\t\tbtrfs_info(root->fs_info, \"enabling check integrity\");\n\t\t\tbtrfs_set_opt(info->mount_opt, CHECK_INTEGRITY);\n\t\t\tbreak;\n\t\tcase Opt_check_integrity_print_mask:\n\t\t\tret = match_int(&args[0], &intarg);\n\t\t\tif (ret) {\n\t\t\t\tgoto out;\n\t\t\t} else if (intarg >= 0) {\n\t\t\t\tinfo->check_integrity_print_mask = intarg;\n\t\t\t\tbtrfs_info(root->fs_info, \"check_integrity_print_mask 0x%x\",\n\t\t\t\t       info->check_integrity_print_mask);\n\t\t\t} else {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n#else\n\t\tcase Opt_check_integrity_including_extent_data:\n\t\tcase Opt_check_integrity:\n\t\tcase Opt_check_integrity_print_mask:\n\t\t\tbtrfs_err(root->fs_info,\n\t\t\t\t\"support for check_integrity* not compiled in!\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n#endif\n\t\tcase Opt_fatal_errors:\n\t\t\tif (strcmp(args[0].from, \"panic\") == 0)\n\t\t\t\tbtrfs_set_opt(info->mount_opt,\n\t\t\t\t\t      PANIC_ON_FATAL_ERROR);\n\t\t\telse if (strcmp(args[0].from, \"bug\") == 0)\n\t\t\t\tbtrfs_clear_opt(info->mount_opt,\n\t\t\t\t\t      PANIC_ON_FATAL_ERROR);\n\t\t\telse {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_commit_interval:\n\t\t\tintarg = 0;\n\t\t\tret = match_int(&args[0], &intarg);\n\t\t\tif (ret < 0) {\n\t\t\t\tbtrfs_err(root->fs_info, \"invalid commit interval\");\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (intarg > 0) {\n\t\t\t\tif (intarg > 300) {\n\t\t\t\t\tbtrfs_warn(root->fs_info, \"excessive commit interval %d\",\n\t\t\t\t\t\t\tintarg);\n\t\t\t\t}\n\t\t\t\tinfo->commit_interval = intarg;\n\t\t\t} else {\n\t\t\t\tbtrfs_info(root->fs_info, \"using default commit interval %ds\",\n\t\t\t\t    BTRFS_DEFAULT_COMMIT_INTERVAL);\n\t\t\t\tinfo->commit_interval = BTRFS_DEFAULT_COMMIT_INTERVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_err:\n\t\t\tbtrfs_info(root->fs_info, \"unrecognized mount option '%s'\", p);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tif (!ret && btrfs_test_opt(root, SPACE_CACHE))\n\t\tbtrfs_info(root->fs_info, \"disk space caching is enabled\");\n\tkfree(orig);\n\treturn ret;\n}"
  },
  {
    "function_name": "btrfs_put_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
    "lines": "309-312",
    "snippet": "static void btrfs_put_super(struct super_block *sb)\n{\n\tclose_ctree(btrfs_sb(sb)->tree_root);\n}",
    "includes": [
      "#include <trace/events/btrfs.h>",
      "#include \"qgroup.h\"",
      "#include \"tests/btrfs-tests.h\"",
      "#include \"backref.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"compression.h\"",
      "#include \"export.h\"",
      "#include \"volumes.h\"",
      "#include \"xattr.h\"",
      "#include \"props.h\"",
      "#include \"hash.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/namei.h>",
      "#include <linux/ctype.h>",
      "#include <linux/parser.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close_ctree",
          "args": [
            "btrfs_sb(sb)->tree_root"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "close_ctree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3639-3739",
          "snippet": "void close_ctree(struct btrfs_root *root)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tint ret;\n\n\tfs_info->closing = 1;\n\tsmp_mb();\n\n\t/* wait for the uuid_scan task to finish */\n\tdown(&fs_info->uuid_tree_rescan_sem);\n\t/* avoid complains from lockdep et al., set sem back to initial state */\n\tup(&fs_info->uuid_tree_rescan_sem);\n\n\t/* pause restriper - we want to resume on mount */\n\tbtrfs_pause_balance(fs_info);\n\n\tbtrfs_dev_replace_suspend_for_unmount(fs_info);\n\n\tbtrfs_scrub_cancel(fs_info);\n\n\t/* wait for any defraggers to finish */\n\twait_event(fs_info->transaction_wait,\n\t\t   (atomic_read(&fs_info->defrag_running) == 0));\n\n\t/* clear out the rbtree of defraggable inodes */\n\tbtrfs_cleanup_defrag_inodes(fs_info);\n\n\tcancel_work_sync(&fs_info->async_reclaim_work);\n\n\tif (!(fs_info->sb->s_flags & MS_RDONLY)) {\n\t\tret = btrfs_commit_super(root);\n\t\tif (ret)\n\t\t\tbtrfs_err(root->fs_info, \"commit super ret %d\", ret);\n\t}\n\n\tif (test_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state))\n\t\tbtrfs_error_commit_super(root);\n\n\tkthread_stop(fs_info->transaction_kthread);\n\tkthread_stop(fs_info->cleaner_kthread);\n\n\tfs_info->closing = 2;\n\tsmp_mb();\n\n\tbtrfs_free_qgroup_config(root->fs_info);\n\n\tif (percpu_counter_sum(&fs_info->delalloc_bytes)) {\n\t\tbtrfs_info(root->fs_info, \"at unmount delalloc count %lld\",\n\t\t       percpu_counter_sum(&fs_info->delalloc_bytes));\n\t}\n\n\tbtrfs_sysfs_remove_one(fs_info);\n\n\tbtrfs_free_fs_roots(fs_info);\n\n\tbtrfs_put_block_group_cache(fs_info);\n\n\tbtrfs_free_block_groups(fs_info);\n\n\t/*\n\t * we must make sure there is not any read request to\n\t * submit after we stopping all workers.\n\t */\n\tinvalidate_inode_pages2(fs_info->btree_inode->i_mapping);\n\tbtrfs_stop_all_workers(fs_info);\n\n\tfs_info->open = 0;\n\tfree_root_pointers(fs_info, 1);\n\n\tiput(fs_info->btree_inode);\n\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_test_opt(root, CHECK_INTEGRITY))\n\t\tbtrfsic_unmount(root, fs_info->fs_devices);\n#endif\n\n\tbtrfs_close_devices(fs_info->fs_devices);\n\tbtrfs_mapping_tree_free(&fs_info->mapping_tree);\n\n\tpercpu_counter_destroy(&fs_info->dirty_metadata_bytes);\n\tpercpu_counter_destroy(&fs_info->delalloc_bytes);\n\tpercpu_counter_destroy(&fs_info->bio_counter);\n\tbdi_destroy(&fs_info->bdi);\n\tcleanup_srcu_struct(&fs_info->subvol_srcu);\n\n\tbtrfs_free_stripe_hash_table(fs_info);\n\n\tbtrfs_free_block_rsv(root, root->orphan_block_rsv);\n\troot->orphan_block_rsv = NULL;\n\n\tlock_chunks(root);\n\twhile (!list_empty(&fs_info->pinned_chunks)) {\n\t\tstruct extent_map *em;\n\n\t\tem = list_first_entry(&fs_info->pinned_chunks,\n\t\t\t\t      struct extent_map, list);\n\t\tlist_del_init(&em->list);\n\t\tfree_extent_map(em);\n\t}\n\tunlock_chunks(root);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_fs_root(struct btrfs_root *root);",
            "static void btrfs_destroy_ordered_extents(struct btrfs_root *root);",
            "static int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);",
            "static void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);",
            "static int btrfs_cleanup_transaction(struct btrfs_root *root);",
            "static void btrfs_error_commit_super(struct btrfs_root *root);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nstatic void free_fs_root(struct btrfs_root *root);\nstatic void btrfs_destroy_ordered_extents(struct btrfs_root *root);\nstatic int btrfs_destroy_delayed_refs(struct btrfs_transaction *trans,\n\t\t\t\t      struct btrfs_root *root);\nstatic void btrfs_destroy_delalloc_inodes(struct btrfs_root *root);\nstatic int btrfs_cleanup_transaction(struct btrfs_root *root);\nstatic void btrfs_error_commit_super(struct btrfs_root *root);\n\nvoid close_ctree(struct btrfs_root *root)\n{\n\tstruct btrfs_fs_info *fs_info = root->fs_info;\n\tint ret;\n\n\tfs_info->closing = 1;\n\tsmp_mb();\n\n\t/* wait for the uuid_scan task to finish */\n\tdown(&fs_info->uuid_tree_rescan_sem);\n\t/* avoid complains from lockdep et al., set sem back to initial state */\n\tup(&fs_info->uuid_tree_rescan_sem);\n\n\t/* pause restriper - we want to resume on mount */\n\tbtrfs_pause_balance(fs_info);\n\n\tbtrfs_dev_replace_suspend_for_unmount(fs_info);\n\n\tbtrfs_scrub_cancel(fs_info);\n\n\t/* wait for any defraggers to finish */\n\twait_event(fs_info->transaction_wait,\n\t\t   (atomic_read(&fs_info->defrag_running) == 0));\n\n\t/* clear out the rbtree of defraggable inodes */\n\tbtrfs_cleanup_defrag_inodes(fs_info);\n\n\tcancel_work_sync(&fs_info->async_reclaim_work);\n\n\tif (!(fs_info->sb->s_flags & MS_RDONLY)) {\n\t\tret = btrfs_commit_super(root);\n\t\tif (ret)\n\t\t\tbtrfs_err(root->fs_info, \"commit super ret %d\", ret);\n\t}\n\n\tif (test_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state))\n\t\tbtrfs_error_commit_super(root);\n\n\tkthread_stop(fs_info->transaction_kthread);\n\tkthread_stop(fs_info->cleaner_kthread);\n\n\tfs_info->closing = 2;\n\tsmp_mb();\n\n\tbtrfs_free_qgroup_config(root->fs_info);\n\n\tif (percpu_counter_sum(&fs_info->delalloc_bytes)) {\n\t\tbtrfs_info(root->fs_info, \"at unmount delalloc count %lld\",\n\t\t       percpu_counter_sum(&fs_info->delalloc_bytes));\n\t}\n\n\tbtrfs_sysfs_remove_one(fs_info);\n\n\tbtrfs_free_fs_roots(fs_info);\n\n\tbtrfs_put_block_group_cache(fs_info);\n\n\tbtrfs_free_block_groups(fs_info);\n\n\t/*\n\t * we must make sure there is not any read request to\n\t * submit after we stopping all workers.\n\t */\n\tinvalidate_inode_pages2(fs_info->btree_inode->i_mapping);\n\tbtrfs_stop_all_workers(fs_info);\n\n\tfs_info->open = 0;\n\tfree_root_pointers(fs_info, 1);\n\n\tiput(fs_info->btree_inode);\n\n#ifdef CONFIG_BTRFS_FS_CHECK_INTEGRITY\n\tif (btrfs_test_opt(root, CHECK_INTEGRITY))\n\t\tbtrfsic_unmount(root, fs_info->fs_devices);\n#endif\n\n\tbtrfs_close_devices(fs_info->fs_devices);\n\tbtrfs_mapping_tree_free(&fs_info->mapping_tree);\n\n\tpercpu_counter_destroy(&fs_info->dirty_metadata_bytes);\n\tpercpu_counter_destroy(&fs_info->delalloc_bytes);\n\tpercpu_counter_destroy(&fs_info->bio_counter);\n\tbdi_destroy(&fs_info->bdi);\n\tcleanup_srcu_struct(&fs_info->subvol_srcu);\n\n\tbtrfs_free_stripe_hash_table(fs_info);\n\n\tbtrfs_free_block_rsv(root, root->orphan_block_rsv);\n\troot->orphan_block_rsv = NULL;\n\n\tlock_chunks(root);\n\twhile (!list_empty(&fs_info->pinned_chunks)) {\n\t\tstruct extent_map *em;\n\n\t\tem = list_first_entry(&fs_info->pinned_chunks,\n\t\t\t\t      struct extent_map, list);\n\t\tlist_del_init(&em->list);\n\t\tfree_extent_map(em);\n\t}\n\tunlock_chunks(root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_sb",
          "args": [
            "sb"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/ctree.h",
          "lines": "3272-3275",
          "snippet": "static inline struct btrfs_fs_info *btrfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"async-thread.h\"",
            "#include \"extent_map.h\"",
            "#include \"extent_io.h\"",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/btrfs.h>",
            "#include <linux/pagemap.h>",
            "#include <asm/kmap_types.h>",
            "#include <trace/events/btrfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/slab.h>",
            "#include <linux/wait.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/completion.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/fs.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"async-thread.h\"\n#include \"extent_map.h\"\n#include \"extent_io.h\"\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/btrfs.h>\n#include <linux/pagemap.h>\n#include <asm/kmap_types.h>\n#include <trace/events/btrfs.h>\n#include <linux/kobject.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/backing-dev.h>\n#include <linux/completion.h>\n#include <linux/semaphore.h>\n#include <linux/rwsem.h>\n#include <linux/fs.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline struct btrfs_fs_info *btrfs_sb(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nstatic void btrfs_put_super(struct super_block *sb)\n{\n\tclose_ctree(btrfs_sb(sb)->tree_root);\n}"
  },
  {
    "function_name": "__btrfs_panic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
    "lines": "284-307",
    "snippet": "void __btrfs_panic(struct btrfs_fs_info *fs_info, const char *function,\n\t\t   unsigned int line, int errno, const char *fmt, ...)\n{\n\tchar *s_id = \"<unknown>\";\n\tconst char *errstr;\n\tstruct va_format vaf = { .fmt = fmt };\n\tva_list args;\n\n\tif (fs_info)\n\t\ts_id = fs_info->sb->s_id;\n\n\tva_start(args, fmt);\n\tvaf.va = &args;\n\n\terrstr = btrfs_decode_error(errno);\n\tif (fs_info && (fs_info->mount_opt & BTRFS_MOUNT_PANIC_ON_FATAL_ERROR))\n\t\tpanic(KERN_CRIT \"BTRFS panic (device %s) in %s:%d: %pV (errno=%d %s)\\n\",\n\t\t\ts_id, function, line, &vaf, errno, errstr);\n\n\tbtrfs_crit(fs_info, \"panic in %s:%d: %pV (errno=%d %s)\",\n\t\t   function, line, &vaf, errno, errstr);\n\tva_end(args);\n\t/* Caller calls BUG() */\n}",
    "includes": [
      "#include <trace/events/btrfs.h>",
      "#include \"qgroup.h\"",
      "#include \"tests/btrfs-tests.h\"",
      "#include \"backref.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"compression.h\"",
      "#include \"export.h\"",
      "#include \"volumes.h\"",
      "#include \"xattr.h\"",
      "#include \"props.h\"",
      "#include \"hash.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/namei.h>",
      "#include <linux/ctype.h>",
      "#include <linux/parser.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_crit",
          "args": [
            "fs_info",
            "\"panic in %s:%d: %pV (errno=%d %s)\"",
            "function",
            "line",
            "&vaf",
            "errno",
            "errstr"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "KERN_CRIT \"BTRFS panic (device %s) in %s:%d: %pV (errno=%d %s)\\n\"",
            "s_id",
            "function",
            "line",
            "&vaf",
            "errno",
            "errstr"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "284-307",
          "snippet": "void __btrfs_panic(struct btrfs_fs_info *fs_info, const char *function,\n\t\t   unsigned int line, int errno, const char *fmt, ...)\n{\n\tchar *s_id = \"<unknown>\";\n\tconst char *errstr;\n\tstruct va_format vaf = { .fmt = fmt };\n\tva_list args;\n\n\tif (fs_info)\n\t\ts_id = fs_info->sb->s_id;\n\n\tva_start(args, fmt);\n\tvaf.va = &args;\n\n\terrstr = btrfs_decode_error(errno);\n\tif (fs_info && (fs_info->mount_opt & BTRFS_MOUNT_PANIC_ON_FATAL_ERROR))\n\t\tpanic(KERN_CRIT \"BTRFS panic (device %s) in %s:%d: %pV (errno=%d %s)\\n\",\n\t\t\ts_id, function, line, &vaf, errno, errstr);\n\n\tbtrfs_crit(fs_info, \"panic in %s:%d: %pV (errno=%d %s)\",\n\t\t   function, line, &vaf, errno, errstr);\n\tva_end(args);\n\t/* Caller calls BUG() */\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "btrfs_decode_error",
          "args": [
            "errno"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_decode_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "72-98",
          "snippet": "static const char *btrfs_decode_error(int errno)\n{\n\tchar *errstr = \"unknown\";\n\n\tswitch (errno) {\n\tcase -EIO:\n\t\terrstr = \"IO failure\";\n\t\tbreak;\n\tcase -ENOMEM:\n\t\terrstr = \"Out of memory\";\n\t\tbreak;\n\tcase -EROFS:\n\t\terrstr = \"Readonly filesystem\";\n\t\tbreak;\n\tcase -EEXIST:\n\t\terrstr = \"Object already exists\";\n\t\tbreak;\n\tcase -ENOSPC:\n\t\terrstr = \"No space left\";\n\t\tbreak;\n\tcase -ENOENT:\n\t\terrstr = \"No such entry\";\n\t\tbreak;\n\t}\n\n\treturn errstr;\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nstatic const char *btrfs_decode_error(int errno)\n{\n\tchar *errstr = \"unknown\";\n\n\tswitch (errno) {\n\tcase -EIO:\n\t\terrstr = \"IO failure\";\n\t\tbreak;\n\tcase -ENOMEM:\n\t\terrstr = \"Out of memory\";\n\t\tbreak;\n\tcase -EROFS:\n\t\terrstr = \"Readonly filesystem\";\n\t\tbreak;\n\tcase -EEXIST:\n\t\terrstr = \"Object already exists\";\n\t\tbreak;\n\tcase -ENOSPC:\n\t\terrstr = \"No space left\";\n\t\tbreak;\n\tcase -ENOENT:\n\t\terrstr = \"No such entry\";\n\t\tbreak;\n\t}\n\n\treturn errstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid __btrfs_panic(struct btrfs_fs_info *fs_info, const char *function,\n\t\t   unsigned int line, int errno, const char *fmt, ...)\n{\n\tchar *s_id = \"<unknown>\";\n\tconst char *errstr;\n\tstruct va_format vaf = { .fmt = fmt };\n\tva_list args;\n\n\tif (fs_info)\n\t\ts_id = fs_info->sb->s_id;\n\n\tva_start(args, fmt);\n\tvaf.va = &args;\n\n\terrstr = btrfs_decode_error(errno);\n\tif (fs_info && (fs_info->mount_opt & BTRFS_MOUNT_PANIC_ON_FATAL_ERROR))\n\t\tpanic(KERN_CRIT \"BTRFS panic (device %s) in %s:%d: %pV (errno=%d %s)\\n\",\n\t\t\ts_id, function, line, &vaf, errno, errstr);\n\n\tbtrfs_crit(fs_info, \"panic in %s:%d: %pV (errno=%d %s)\",\n\t\t   function, line, &vaf, errno, errstr);\n\tva_end(args);\n\t/* Caller calls BUG() */\n}"
  },
  {
    "function_name": "__btrfs_abort_transaction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
    "lines": "250-279",
    "snippet": "void __btrfs_abort_transaction(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root, const char *function,\n\t\t\t       unsigned int line, int errno)\n{\n\t/*\n\t * Report first abort since mount\n\t */\n\tif (!test_and_set_bit(BTRFS_FS_STATE_TRANS_ABORTED,\n\t\t\t\t&root->fs_info->fs_state)) {\n\t\tWARN(1, KERN_DEBUG \"BTRFS: Transaction aborted (error %d)\\n\",\n\t\t\t\terrno);\n\t}\n\ttrans->aborted = errno;\n\t/* Nothing used. The other threads that have joined this\n\t * transaction may be able to continue. */\n\tif (!trans->blocks_used && list_empty(&trans->new_bgs)) {\n\t\tconst char *errstr;\n\n\t\terrstr = btrfs_decode_error(errno);\n\t\tbtrfs_warn(root->fs_info,\n\t\t           \"%s:%d: Aborting unused transaction(%s).\",\n\t\t           function, line, errstr);\n\t\treturn;\n\t}\n\tACCESS_ONCE(trans->transaction->aborted) = errno;\n\t/* Wake up anybody who may be waiting on this transaction */\n\twake_up(&root->fs_info->transaction_wait);\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\t__btrfs_std_error(root->fs_info, function, line, errno, NULL);\n}",
    "includes": [
      "#include <trace/events/btrfs.h>",
      "#include \"qgroup.h\"",
      "#include \"tests/btrfs-tests.h\"",
      "#include \"backref.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"compression.h\"",
      "#include \"export.h\"",
      "#include \"volumes.h\"",
      "#include \"xattr.h\"",
      "#include \"props.h\"",
      "#include \"hash.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/namei.h>",
      "#include <linux/ctype.h>",
      "#include <linux/parser.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__btrfs_std_error",
          "args": [
            "root->fs_info",
            "function",
            "line",
            "errno",
            "NULL"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "__btrfs_std_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "217-234",
          "snippet": "void __btrfs_std_error(struct btrfs_fs_info *fs_info, const char *function,\n\t\t       unsigned int line, int errno, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\n\t/*\n\t * Special case: if the error is EROFS, and we're already\n\t * under MS_RDONLY, then it is safe here.\n\t */\n\tif (errno == -EROFS && (sb->s_flags & MS_RDONLY))\n\t\treturn;\n\n\t/* Don't go through full error handling during mount */\n\tif (sb->s_flags & MS_BORN) {\n\t\tsave_error_info(fs_info);\n\t\tbtrfs_handle_error(fs_info);\n\t}\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid __btrfs_std_error(struct btrfs_fs_info *fs_info, const char *function,\n\t\t       unsigned int line, int errno, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\n\t/*\n\t * Special case: if the error is EROFS, and we're already\n\t * under MS_RDONLY, then it is safe here.\n\t */\n\tif (errno == -EROFS && (sb->s_flags & MS_RDONLY))\n\t\treturn;\n\n\t/* Don't go through full error handling during mount */\n\tif (sb->s_flags & MS_BORN) {\n\t\tsave_error_info(fs_info);\n\t\tbtrfs_handle_error(fs_info);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&root->fs_info->transaction_blocked_wait"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "locks_wake_up_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/locks.c",
          "lines": "656-681",
          "snippet": "static void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}",
          "includes": [
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <asm/uaccess.h>",
            "#include <trace/events/filelock.h>",
            "#include <linux/lglock.h>",
            "#include <linux/percpu.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/time.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/security.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(blocked_lock_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <asm/uaccess.h>\n#include <trace/events/filelock.h>\n#include <linux/lglock.h>\n#include <linux/percpu.h>\n#include <linux/hashtable.h>\n#include <linux/pid_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/time.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n\nstatic DEFINE_SPINLOCK(blocked_lock_lock);\n\nstatic void locks_wake_up_blocks(struct file_lock *blocker)\n{\n\t/*\n\t * Avoid taking global lock if list is empty. This is safe since new\n\t * blocked requests are only added to the list under the flc_lock, and\n\t * the flc_lock is always held here. Note that removal from the fl_block\n\t * list does not require the flc_lock, so we must recheck list_empty()\n\t * after acquiring the blocked_lock_lock.\n\t */\n\tif (list_empty(&blocker->fl_block))\n\t\treturn;\n\n\tspin_lock(&blocked_lock_lock);\n\twhile (!list_empty(&blocker->fl_block)) {\n\t\tstruct file_lock *waiter;\n\n\t\twaiter = list_first_entry(&blocker->fl_block,\n\t\t\t\tstruct file_lock, fl_block);\n\t\t__locks_delete_block(waiter);\n\t\tif (waiter->fl_lmops && waiter->fl_lmops->lm_notify)\n\t\t\twaiter->fl_lmops->lm_notify(waiter);\n\t\telse\n\t\t\twake_up(&waiter->fl_wait);\n\t}\n\tspin_unlock(&blocked_lock_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ACCESS_ONCE",
          "args": [
            "trans->transaction->aborted"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_warn",
          "args": [
            "root->fs_info",
            "\"%s:%d: Aborting unused transaction(%s).\"",
            "function",
            "line",
            "errstr"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_decode_error",
          "args": [
            "errno"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_decode_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "72-98",
          "snippet": "static const char *btrfs_decode_error(int errno)\n{\n\tchar *errstr = \"unknown\";\n\n\tswitch (errno) {\n\tcase -EIO:\n\t\terrstr = \"IO failure\";\n\t\tbreak;\n\tcase -ENOMEM:\n\t\terrstr = \"Out of memory\";\n\t\tbreak;\n\tcase -EROFS:\n\t\terrstr = \"Readonly filesystem\";\n\t\tbreak;\n\tcase -EEXIST:\n\t\terrstr = \"Object already exists\";\n\t\tbreak;\n\tcase -ENOSPC:\n\t\terrstr = \"No space left\";\n\t\tbreak;\n\tcase -ENOENT:\n\t\terrstr = \"No such entry\";\n\t\tbreak;\n\t}\n\n\treturn errstr;\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nstatic const char *btrfs_decode_error(int errno)\n{\n\tchar *errstr = \"unknown\";\n\n\tswitch (errno) {\n\tcase -EIO:\n\t\terrstr = \"IO failure\";\n\t\tbreak;\n\tcase -ENOMEM:\n\t\terrstr = \"Out of memory\";\n\t\tbreak;\n\tcase -EROFS:\n\t\terrstr = \"Readonly filesystem\";\n\t\tbreak;\n\tcase -EEXIST:\n\t\terrstr = \"Object already exists\";\n\t\tbreak;\n\tcase -ENOSPC:\n\t\terrstr = \"No space left\";\n\t\tbreak;\n\tcase -ENOENT:\n\t\terrstr = \"No such entry\";\n\t\tbreak;\n\t}\n\n\treturn errstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&trans->new_bgs"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "KERN_DEBUG \"BTRFS: Transaction aborted (error %d)\\n\"",
            "errno"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "BTRFS_FS_STATE_TRANS_ABORTED",
            "&root->fs_info->fs_state"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_test_and_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1117-1127",
          "snippet": "static inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline int f2fs_test_and_set_bit(unsigned int nr, char *addr)\n{\n\tint mask;\n\tint ret;\n\n\taddr += (nr >> 3);\n\tmask = 1 << (7 - (nr & 0x07));\n\tret = mask & *addr;\n\t*addr |= mask;\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid __btrfs_abort_transaction(struct btrfs_trans_handle *trans,\n\t\t\t       struct btrfs_root *root, const char *function,\n\t\t\t       unsigned int line, int errno)\n{\n\t/*\n\t * Report first abort since mount\n\t */\n\tif (!test_and_set_bit(BTRFS_FS_STATE_TRANS_ABORTED,\n\t\t\t\t&root->fs_info->fs_state)) {\n\t\tWARN(1, KERN_DEBUG \"BTRFS: Transaction aborted (error %d)\\n\",\n\t\t\t\terrno);\n\t}\n\ttrans->aborted = errno;\n\t/* Nothing used. The other threads that have joined this\n\t * transaction may be able to continue. */\n\tif (!trans->blocks_used && list_empty(&trans->new_bgs)) {\n\t\tconst char *errstr;\n\n\t\terrstr = btrfs_decode_error(errno);\n\t\tbtrfs_warn(root->fs_info,\n\t\t           \"%s:%d: Aborting unused transaction(%s).\",\n\t\t           function, line, errstr);\n\t\treturn;\n\t}\n\tACCESS_ONCE(trans->transaction->aborted) = errno;\n\t/* Wake up anybody who may be waiting on this transaction */\n\twake_up(&root->fs_info->transaction_wait);\n\twake_up(&root->fs_info->transaction_blocked_wait);\n\t__btrfs_std_error(root->fs_info, function, line, errno, NULL);\n}"
  },
  {
    "function_name": "__btrfs_std_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
    "lines": "217-234",
    "snippet": "void __btrfs_std_error(struct btrfs_fs_info *fs_info, const char *function,\n\t\t       unsigned int line, int errno, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\n\t/*\n\t * Special case: if the error is EROFS, and we're already\n\t * under MS_RDONLY, then it is safe here.\n\t */\n\tif (errno == -EROFS && (sb->s_flags & MS_RDONLY))\n\t\treturn;\n\n\t/* Don't go through full error handling during mount */\n\tif (sb->s_flags & MS_BORN) {\n\t\tsave_error_info(fs_info);\n\t\tbtrfs_handle_error(fs_info);\n\t}\n}",
    "includes": [
      "#include <trace/events/btrfs.h>",
      "#include \"qgroup.h\"",
      "#include \"tests/btrfs-tests.h\"",
      "#include \"backref.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"compression.h\"",
      "#include \"export.h\"",
      "#include \"volumes.h\"",
      "#include \"xattr.h\"",
      "#include \"props.h\"",
      "#include \"hash.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/namei.h>",
      "#include <linux/ctype.h>",
      "#include <linux/parser.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_handle_error",
          "args": [
            "fs_info"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_handle_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "110-131",
          "snippet": "static void btrfs_handle_error(struct btrfs_fs_info *fs_info)\n{\n\tstruct super_block *sb = fs_info->sb;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\tif (test_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state)) {\n\t\tsb->s_flags |= MS_RDONLY;\n\t\tbtrfs_info(fs_info, \"forced readonly\");\n\t\t/*\n\t\t * Note that a running device replace operation is not\n\t\t * canceled here although there is no way to update\n\t\t * the progress. It would add the risk of a deadlock,\n\t\t * therefore the canceling is ommited. The only penalty\n\t\t * is that some I/O remains active until the procedure\n\t\t * completes. The next time when the filesystem is\n\t\t * mounted writeable again, the device replace\n\t\t * operation continues.\n\t\t */\n\t}\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nstatic void btrfs_handle_error(struct btrfs_fs_info *fs_info)\n{\n\tstruct super_block *sb = fs_info->sb;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\tif (test_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state)) {\n\t\tsb->s_flags |= MS_RDONLY;\n\t\tbtrfs_info(fs_info, \"forced readonly\");\n\t\t/*\n\t\t * Note that a running device replace operation is not\n\t\t * canceled here although there is no way to update\n\t\t * the progress. It would add the risk of a deadlock,\n\t\t * therefore the canceling is ommited. The only penalty\n\t\t * is that some I/O remains active until the procedure\n\t\t * completes. The next time when the filesystem is\n\t\t * mounted writeable again, the device replace\n\t\t * operation continues.\n\t\t */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "save_error_info",
          "args": [
            "fs_info"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "save_error_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "100-107",
          "snippet": "static void save_error_info(struct btrfs_fs_info *fs_info)\n{\n\t/*\n\t * today we only save the error info into ram.  Long term we'll\n\t * also send it down to the disk\n\t */\n\tset_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nstatic void save_error_info(struct btrfs_fs_info *fs_info)\n{\n\t/*\n\t * today we only save the error info into ram.  Long term we'll\n\t * also send it down to the disk\n\t */\n\tset_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid __btrfs_std_error(struct btrfs_fs_info *fs_info, const char *function,\n\t\t       unsigned int line, int errno, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\n\t/*\n\t * Special case: if the error is EROFS, and we're already\n\t * under MS_RDONLY, then it is safe here.\n\t */\n\tif (errno == -EROFS && (sb->s_flags & MS_RDONLY))\n\t\treturn;\n\n\t/* Don't go through full error handling during mount */\n\tif (sb->s_flags & MS_BORN) {\n\t\tsave_error_info(fs_info);\n\t\tbtrfs_handle_error(fs_info);\n\t}\n}"
  },
  {
    "function_name": "btrfs_printk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
    "lines": "186-213",
    "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
    "includes": [
      "#include <trace/events/btrfs.h>",
      "#include \"qgroup.h\"",
      "#include \"tests/btrfs-tests.h\"",
      "#include \"backref.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"compression.h\"",
      "#include \"export.h\"",
      "#include \"volumes.h\"",
      "#include \"xattr.h\"",
      "#include \"props.h\"",
      "#include \"hash.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/namei.h>",
      "#include <linux/ctype.h>",
      "#include <linux/parser.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"%sBTRFS %s (device %s): %pV\\n\"",
            "lvl",
            "type",
            "sb->s_id",
            "&vaf"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "lvl",
            "fmt",
            "size"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk_skip_level",
          "args": [
            "fmt"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk_get_level",
          "args": [
            "fmt"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
  },
  {
    "function_name": "__btrfs_std_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
    "lines": "138-173",
    "snippet": "void __btrfs_std_error(struct btrfs_fs_info *fs_info, const char *function,\n\t\t       unsigned int line, int errno, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tconst char *errstr;\n\n\t/*\n\t * Special case: if the error is EROFS, and we're already\n\t * under MS_RDONLY, then it is safe here.\n\t */\n\tif (errno == -EROFS && (sb->s_flags & MS_RDONLY))\n  \t\treturn;\n\n\terrstr = btrfs_decode_error(errno);\n\tif (fmt) {\n\t\tstruct va_format vaf;\n\t\tva_list args;\n\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\n\t\tprintk(KERN_CRIT\n\t\t\t\"BTRFS: error (device %s) in %s:%d: errno=%d %s (%pV)\\n\",\n\t\t\tsb->s_id, function, line, errno, errstr, &vaf);\n\t\tva_end(args);\n\t} else {\n\t\tprintk(KERN_CRIT \"BTRFS: error (device %s) in %s:%d: errno=%d %s\\n\",\n\t\t\tsb->s_id, function, line, errno, errstr);\n\t}\n\n\t/* Don't go through full error handling during mount */\n\tsave_error_info(fs_info);\n\tif (sb->s_flags & MS_BORN)\n\t\tbtrfs_handle_error(fs_info);\n}",
    "includes": [
      "#include <trace/events/btrfs.h>",
      "#include \"qgroup.h\"",
      "#include \"tests/btrfs-tests.h\"",
      "#include \"backref.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"compression.h\"",
      "#include \"export.h\"",
      "#include \"volumes.h\"",
      "#include \"xattr.h\"",
      "#include \"props.h\"",
      "#include \"hash.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/namei.h>",
      "#include <linux/ctype.h>",
      "#include <linux/parser.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_handle_error",
          "args": [
            "fs_info"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_handle_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "110-131",
          "snippet": "static void btrfs_handle_error(struct btrfs_fs_info *fs_info)\n{\n\tstruct super_block *sb = fs_info->sb;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\tif (test_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state)) {\n\t\tsb->s_flags |= MS_RDONLY;\n\t\tbtrfs_info(fs_info, \"forced readonly\");\n\t\t/*\n\t\t * Note that a running device replace operation is not\n\t\t * canceled here although there is no way to update\n\t\t * the progress. It would add the risk of a deadlock,\n\t\t * therefore the canceling is ommited. The only penalty\n\t\t * is that some I/O remains active until the procedure\n\t\t * completes. The next time when the filesystem is\n\t\t * mounted writeable again, the device replace\n\t\t * operation continues.\n\t\t */\n\t}\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nstatic void btrfs_handle_error(struct btrfs_fs_info *fs_info)\n{\n\tstruct super_block *sb = fs_info->sb;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\tif (test_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state)) {\n\t\tsb->s_flags |= MS_RDONLY;\n\t\tbtrfs_info(fs_info, \"forced readonly\");\n\t\t/*\n\t\t * Note that a running device replace operation is not\n\t\t * canceled here although there is no way to update\n\t\t * the progress. It would add the risk of a deadlock,\n\t\t * therefore the canceling is ommited. The only penalty\n\t\t * is that some I/O remains active until the procedure\n\t\t * completes. The next time when the filesystem is\n\t\t * mounted writeable again, the device replace\n\t\t * operation continues.\n\t\t */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "save_error_info",
          "args": [
            "fs_info"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "save_error_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "100-107",
          "snippet": "static void save_error_info(struct btrfs_fs_info *fs_info)\n{\n\t/*\n\t * today we only save the error info into ram.  Long term we'll\n\t * also send it down to the disk\n\t */\n\tset_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nstatic void save_error_info(struct btrfs_fs_info *fs_info)\n{\n\t/*\n\t * today we only save the error info into ram.  Long term we'll\n\t * also send it down to the disk\n\t */\n\tset_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_CRIT \"BTRFS: error (device %s) in %s:%d: errno=%d %s\\n\"",
            "sb->s_id",
            "function",
            "line",
            "errno",
            "errstr"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "186-213",
          "snippet": "void btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid btrfs_printk(const struct btrfs_fs_info *fs_info, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tchar lvl[4];\n\tstruct va_format vaf;\n\tva_list args;\n\tconst char *type = logtypes[4];\n\tint kern_level;\n\n\tva_start(args, fmt);\n\n\tkern_level = printk_get_level(fmt);\n\tif (kern_level) {\n\t\tsize_t size = printk_skip_level(fmt) - fmt;\n\t\tmemcpy(lvl, fmt,  size);\n\t\tlvl[size] = '\\0';\n\t\tfmt += size;\n\t\ttype = logtypes[kern_level - '0'];\n\t} else\n\t\t*lvl = '\\0';\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tprintk(\"%sBTRFS %s (device %s): %pV\\n\", lvl, type, sb->s_id, &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btrfs_decode_error",
          "args": [
            "errno"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_decode_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
          "lines": "72-98",
          "snippet": "static const char *btrfs_decode_error(int errno)\n{\n\tchar *errstr = \"unknown\";\n\n\tswitch (errno) {\n\tcase -EIO:\n\t\terrstr = \"IO failure\";\n\t\tbreak;\n\tcase -ENOMEM:\n\t\terrstr = \"Out of memory\";\n\t\tbreak;\n\tcase -EROFS:\n\t\terrstr = \"Readonly filesystem\";\n\t\tbreak;\n\tcase -EEXIST:\n\t\terrstr = \"Object already exists\";\n\t\tbreak;\n\tcase -ENOSPC:\n\t\terrstr = \"No space left\";\n\t\tbreak;\n\tcase -ENOENT:\n\t\terrstr = \"No such entry\";\n\t\tbreak;\n\t}\n\n\treturn errstr;\n}",
          "includes": [
            "#include <trace/events/btrfs.h>",
            "#include \"qgroup.h\"",
            "#include \"tests/btrfs-tests.h\"",
            "#include \"backref.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"compression.h\"",
            "#include \"export.h\"",
            "#include \"volumes.h\"",
            "#include \"xattr.h\"",
            "#include \"props.h\"",
            "#include \"hash.h\"",
            "#include \"print-tree.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include \"delayed-inode.h\"",
            "#include <linux/btrfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/namei.h>",
            "#include <linux/ctype.h>",
            "#include <linux/parser.h>",
            "#include <linux/compat.h>",
            "#include <linux/statfs.h>",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/mpage.h>",
            "#include <linux/mount.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/time.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nstatic const char *btrfs_decode_error(int errno)\n{\n\tchar *errstr = \"unknown\";\n\n\tswitch (errno) {\n\tcase -EIO:\n\t\terrstr = \"IO failure\";\n\t\tbreak;\n\tcase -ENOMEM:\n\t\terrstr = \"Out of memory\";\n\t\tbreak;\n\tcase -EROFS:\n\t\terrstr = \"Readonly filesystem\";\n\t\tbreak;\n\tcase -EEXIST:\n\t\terrstr = \"Object already exists\";\n\t\tbreak;\n\tcase -ENOSPC:\n\t\terrstr = \"No space left\";\n\t\tbreak;\n\tcase -ENOENT:\n\t\terrstr = \"No such entry\";\n\t\tbreak;\n\t}\n\n\treturn errstr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nvoid __btrfs_std_error(struct btrfs_fs_info *fs_info, const char *function,\n\t\t       unsigned int line, int errno, const char *fmt, ...)\n{\n\tstruct super_block *sb = fs_info->sb;\n\tconst char *errstr;\n\n\t/*\n\t * Special case: if the error is EROFS, and we're already\n\t * under MS_RDONLY, then it is safe here.\n\t */\n\tif (errno == -EROFS && (sb->s_flags & MS_RDONLY))\n  \t\treturn;\n\n\terrstr = btrfs_decode_error(errno);\n\tif (fmt) {\n\t\tstruct va_format vaf;\n\t\tva_list args;\n\n\t\tva_start(args, fmt);\n\t\tvaf.fmt = fmt;\n\t\tvaf.va = &args;\n\n\t\tprintk(KERN_CRIT\n\t\t\t\"BTRFS: error (device %s) in %s:%d: errno=%d %s (%pV)\\n\",\n\t\t\tsb->s_id, function, line, errno, errstr, &vaf);\n\t\tva_end(args);\n\t} else {\n\t\tprintk(KERN_CRIT \"BTRFS: error (device %s) in %s:%d: errno=%d %s\\n\",\n\t\t\tsb->s_id, function, line, errno, errstr);\n\t}\n\n\t/* Don't go through full error handling during mount */\n\tsave_error_info(fs_info);\n\tif (sb->s_flags & MS_BORN)\n\t\tbtrfs_handle_error(fs_info);\n}"
  },
  {
    "function_name": "btrfs_handle_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
    "lines": "110-131",
    "snippet": "static void btrfs_handle_error(struct btrfs_fs_info *fs_info)\n{\n\tstruct super_block *sb = fs_info->sb;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\tif (test_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state)) {\n\t\tsb->s_flags |= MS_RDONLY;\n\t\tbtrfs_info(fs_info, \"forced readonly\");\n\t\t/*\n\t\t * Note that a running device replace operation is not\n\t\t * canceled here although there is no way to update\n\t\t * the progress. It would add the risk of a deadlock,\n\t\t * therefore the canceling is ommited. The only penalty\n\t\t * is that some I/O remains active until the procedure\n\t\t * completes. The next time when the filesystem is\n\t\t * mounted writeable again, the device replace\n\t\t * operation continues.\n\t\t */\n\t}\n}",
    "includes": [
      "#include <trace/events/btrfs.h>",
      "#include \"qgroup.h\"",
      "#include \"tests/btrfs-tests.h\"",
      "#include \"backref.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"compression.h\"",
      "#include \"export.h\"",
      "#include \"volumes.h\"",
      "#include \"xattr.h\"",
      "#include \"props.h\"",
      "#include \"hash.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/namei.h>",
      "#include <linux/ctype.h>",
      "#include <linux/parser.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btrfs_info",
          "args": [
            "fs_info",
            "\"forced readonly\""
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "BTRFS_FS_STATE_ERROR",
            "&fs_info->fs_state"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nstatic void btrfs_handle_error(struct btrfs_fs_info *fs_info)\n{\n\tstruct super_block *sb = fs_info->sb;\n\n\tif (sb->s_flags & MS_RDONLY)\n\t\treturn;\n\n\tif (test_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state)) {\n\t\tsb->s_flags |= MS_RDONLY;\n\t\tbtrfs_info(fs_info, \"forced readonly\");\n\t\t/*\n\t\t * Note that a running device replace operation is not\n\t\t * canceled here although there is no way to update\n\t\t * the progress. It would add the risk of a deadlock,\n\t\t * therefore the canceling is ommited. The only penalty\n\t\t * is that some I/O remains active until the procedure\n\t\t * completes. The next time when the filesystem is\n\t\t * mounted writeable again, the device replace\n\t\t * operation continues.\n\t\t */\n\t}\n}"
  },
  {
    "function_name": "save_error_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
    "lines": "100-107",
    "snippet": "static void save_error_info(struct btrfs_fs_info *fs_info)\n{\n\t/*\n\t * today we only save the error info into ram.  Long term we'll\n\t * also send it down to the disk\n\t */\n\tset_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state);\n}",
    "includes": [
      "#include <trace/events/btrfs.h>",
      "#include \"qgroup.h\"",
      "#include \"tests/btrfs-tests.h\"",
      "#include \"backref.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"compression.h\"",
      "#include \"export.h\"",
      "#include \"volumes.h\"",
      "#include \"xattr.h\"",
      "#include \"props.h\"",
      "#include \"hash.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/namei.h>",
      "#include <linux/ctype.h>",
      "#include <linux/parser.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "BTRFS_FS_STATE_ERROR",
            "&fs_info->fs_state"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nstatic void save_error_info(struct btrfs_fs_info *fs_info)\n{\n\t/*\n\t * today we only save the error info into ram.  Long term we'll\n\t * also send it down to the disk\n\t */\n\tset_bit(BTRFS_FS_STATE_ERROR, &fs_info->fs_state);\n}"
  },
  {
    "function_name": "btrfs_decode_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/super.c",
    "lines": "72-98",
    "snippet": "static const char *btrfs_decode_error(int errno)\n{\n\tchar *errstr = \"unknown\";\n\n\tswitch (errno) {\n\tcase -EIO:\n\t\terrstr = \"IO failure\";\n\t\tbreak;\n\tcase -ENOMEM:\n\t\terrstr = \"Out of memory\";\n\t\tbreak;\n\tcase -EROFS:\n\t\terrstr = \"Readonly filesystem\";\n\t\tbreak;\n\tcase -EEXIST:\n\t\terrstr = \"Object already exists\";\n\t\tbreak;\n\tcase -ENOSPC:\n\t\terrstr = \"No space left\";\n\t\tbreak;\n\tcase -ENOENT:\n\t\terrstr = \"No such entry\";\n\t\tbreak;\n\t}\n\n\treturn errstr;\n}",
    "includes": [
      "#include <trace/events/btrfs.h>",
      "#include \"qgroup.h\"",
      "#include \"tests/btrfs-tests.h\"",
      "#include \"backref.h\"",
      "#include \"free-space-cache.h\"",
      "#include \"dev-replace.h\"",
      "#include \"rcu-string.h\"",
      "#include \"compression.h\"",
      "#include \"export.h\"",
      "#include \"volumes.h\"",
      "#include \"xattr.h\"",
      "#include \"props.h\"",
      "#include \"hash.h\"",
      "#include \"print-tree.h\"",
      "#include \"btrfs_inode.h\"",
      "#include \"transaction.h\"",
      "#include \"disk-io.h\"",
      "#include \"ctree.h\"",
      "#include \"delayed-inode.h\"",
      "#include <linux/btrfs.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/cleancache.h>",
      "#include <linux/slab.h>",
      "#include <linux/magic.h>",
      "#include <linux/miscdevice.h>",
      "#include <linux/namei.h>",
      "#include <linux/ctype.h>",
      "#include <linux/parser.h>",
      "#include <linux/compat.h>",
      "#include <linux/statfs.h>",
      "#include <linux/writeback.h>",
      "#include <linux/swap.h>",
      "#include <linux/mpage.h>",
      "#include <linux/mount.h>",
      "#include <linux/backing-dev.h>",
      "#include <linux/string.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>",
      "#include <linux/time.h>",
      "#include <linux/highmem.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/module.h>",
      "#include <linux/blkdev.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/btrfs.h>\n#include \"qgroup.h\"\n#include \"tests/btrfs-tests.h\"\n#include \"backref.h\"\n#include \"free-space-cache.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"compression.h\"\n#include \"export.h\"\n#include \"volumes.h\"\n#include \"xattr.h\"\n#include \"props.h\"\n#include \"hash.h\"\n#include \"print-tree.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include \"delayed-inode.h\"\n#include <linux/btrfs.h>\n#include <linux/ratelimit.h>\n#include <linux/cleancache.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/miscdevice.h>\n#include <linux/namei.h>\n#include <linux/ctype.h>\n#include <linux/parser.h>\n#include <linux/compat.h>\n#include <linux/statfs.h>\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/mpage.h>\n#include <linux/mount.h>\n#include <linux/backing-dev.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/time.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/buffer_head.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n\nstatic const char *btrfs_decode_error(int errno)\n{\n\tchar *errstr = \"unknown\";\n\n\tswitch (errno) {\n\tcase -EIO:\n\t\terrstr = \"IO failure\";\n\t\tbreak;\n\tcase -ENOMEM:\n\t\terrstr = \"Out of memory\";\n\t\tbreak;\n\tcase -EROFS:\n\t\terrstr = \"Readonly filesystem\";\n\t\tbreak;\n\tcase -EEXIST:\n\t\terrstr = \"Object already exists\";\n\t\tbreak;\n\tcase -ENOSPC:\n\t\terrstr = \"No space left\";\n\t\tbreak;\n\tcase -ENOENT:\n\t\terrstr = \"No such entry\";\n\t\tbreak;\n\t}\n\n\treturn errstr;\n}"
  }
]