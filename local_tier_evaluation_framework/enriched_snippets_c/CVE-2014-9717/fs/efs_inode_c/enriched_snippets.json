[
  {
    "function_name": "efs_map_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efs/inode.c",
    "lines": "197-309",
    "snippet": "efs_block_t efs_map_block(struct inode *inode, efs_block_t block) {\n\tstruct efs_sb_info    *sb = SUPER_INFO(inode->i_sb);\n\tstruct efs_inode_info *in = INODE_INFO(inode);\n\tstruct buffer_head    *bh = NULL;\n\n\tint cur, last, first = 1;\n\tint ibase, ioffset, dirext, direxts, indext, indexts;\n\tefs_block_t iblock, result = 0, lastblock = 0;\n\tefs_extent ext, *exts;\n\n\tlast = in->lastextent;\n\n\tif (in->numextents <= EFS_DIRECTEXTENTS) {\n\t\t/* first check the last extent we returned */\n\t\tif ((result = efs_extent_check(&in->extents[last], block, sb)))\n\t\t\treturn result;\n    \n\t\t/* if we only have one extent then nothing can be found */\n\t\tif (in->numextents == 1) {\n\t\t\tpr_err(\"%s() failed to map (1 extent)\\n\", __func__);\n\t\t\treturn 0;\n\t\t}\n\n\t\tdirexts = in->numextents;\n\n\t\t/*\n\t\t * check the stored extents in the inode\n\t\t * start with next extent and check forwards\n\t\t */\n\t\tfor(dirext = 1; dirext < direxts; dirext++) {\n\t\t\tcur = (last + dirext) % in->numextents;\n\t\t\tif ((result = efs_extent_check(&in->extents[cur], block, sb))) {\n\t\t\t\tin->lastextent = cur;\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\tpr_err(\"%s() failed to map block %u (dir)\\n\", __func__, block);\n\t\treturn 0;\n\t}\n\n\tpr_debug(\"%s(): indirect search for logical block %u\\n\",\n\t\t __func__, block);\n\tdirexts = in->extents[0].cooked.ex_offset;\n\tindexts = in->numextents;\n\n\tfor(indext = 0; indext < indexts; indext++) {\n\t\tcur = (last + indext) % indexts;\n\n\t\t/*\n\t\t * work out which direct extent contains `cur'.\n\t\t *\n\t\t * also compute ibase: i.e. the number of the first\n\t\t * indirect extent contained within direct extent `cur'.\n\t\t *\n\t\t */\n\t\tibase = 0;\n\t\tfor(dirext = 0; cur < ibase && dirext < direxts; dirext++) {\n\t\t\tibase += in->extents[dirext].cooked.ex_length *\n\t\t\t\t(EFS_BLOCKSIZE / sizeof(efs_extent));\n\t\t}\n\n\t\tif (dirext == direxts) {\n\t\t\t/* should never happen */\n\t\t\tpr_err(\"couldn't find direct extent for indirect extent %d (block %u)\\n\",\n\t\t\t       cur, block);\n\t\t\tif (bh) brelse(bh);\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\t/* work out block number and offset of this indirect extent */\n\t\tiblock = sb->fs_start + in->extents[dirext].cooked.ex_bn +\n\t\t\t(cur - ibase) /\n\t\t\t(EFS_BLOCKSIZE / sizeof(efs_extent));\n\t\tioffset = (cur - ibase) %\n\t\t\t(EFS_BLOCKSIZE / sizeof(efs_extent));\n\n\t\tif (first || lastblock != iblock) {\n\t\t\tif (bh) brelse(bh);\n\n\t\t\tbh = sb_bread(inode->i_sb, iblock);\n\t\t\tif (!bh) {\n\t\t\t\tpr_err(\"%s() failed at block %d\\n\",\n\t\t\t\t       __func__, iblock);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tpr_debug(\"%s(): read indirect extent block %d\\n\",\n\t\t\t\t __func__, iblock);\n\t\t\tfirst = 0;\n\t\t\tlastblock = iblock;\n\t\t}\n\n\t\texts = (efs_extent *) bh->b_data;\n\n\t\textent_copy(&(exts[ioffset]), &ext);\n\n\t\tif (ext.cooked.ex_magic != 0) {\n\t\t\tpr_err(\"extent %d has bad magic number in block %d\\n\",\n\t\t\t       cur, iblock);\n\t\t\tif (bh) brelse(bh);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif ((result = efs_extent_check(&ext, block, sb))) {\n\t\t\tif (bh) brelse(bh);\n\t\t\tin->lastextent = cur;\n\t\t\treturn result;\n\t\t}\n\t}\n\tif (bh) brelse(bh);\n\tpr_err(\"%s() failed to map block %u (indir)\\n\", __func__, block);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/efs_fs_sb.h>",
      "#include \"efs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s() failed to map block %u (indir)\\n\"",
            "__func__",
            "block"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "efs_extent_check",
          "args": [
            "&ext",
            "block",
            "sb"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "efs_extent_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efs/inode.c",
          "lines": "176-195",
          "snippet": "static inline efs_block_t\nefs_extent_check(efs_extent *ptr, efs_block_t block, struct efs_sb_info *sb) {\n\tefs_block_t start;\n\tefs_block_t length;\n\tefs_block_t offset;\n\n\t/*\n\t * given an extent and a logical block within a file,\n\t * can this block be found within this extent ?\n\t */\n\tstart  = ptr->cooked.ex_bn;\n\tlength = ptr->cooked.ex_length;\n\toffset = ptr->cooked.ex_offset;\n\n\tif ((block >= offset) && (block < offset+length)) {\n\t\treturn(sb->fs_start + start + block - offset);\n\t} else {\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include <linux/efs_fs_sb.h>",
            "#include \"efs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/efs_fs_sb.h>\n#include \"efs.h\"\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/buffer_head.h>\n\nstatic inline efs_block_t\nefs_extent_check(efs_extent *ptr, efs_block_t block, struct efs_sb_info *sb) {\n\tefs_block_t start;\n\tefs_block_t length;\n\tefs_block_t offset;\n\n\t/*\n\t * given an extent and a logical block within a file,\n\t * can this block be found within this extent ?\n\t */\n\tstart  = ptr->cooked.ex_bn;\n\tlength = ptr->cooked.ex_length;\n\toffset = ptr->cooked.ex_offset;\n\n\tif ((block >= offset) && (block < offset+length)) {\n\t\treturn(sb->fs_start + start + block - offset);\n\t} else {\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"extent %d has bad magic number in block %d\\n\"",
            "cur",
            "iblock"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extent_copy",
          "args": [
            "&(exts[ioffset])",
            "&ext"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "extent_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efs/inode.c",
          "lines": "29-45",
          "snippet": "static inline void extent_copy(efs_extent *src, efs_extent *dst) {\n\t/*\n\t * this is slightly evil. it doesn't just copy\n\t * efs_extent from src to dst, it also mangles\n\t * the bits so that dst ends up in cpu byte-order.\n\t */\n\n\tdst->cooked.ex_magic  =  (unsigned int) src->raw[0];\n\tdst->cooked.ex_bn     = ((unsigned int) src->raw[1] << 16) |\n\t\t\t\t((unsigned int) src->raw[2] <<  8) |\n\t\t\t\t((unsigned int) src->raw[3] <<  0);\n\tdst->cooked.ex_length =  (unsigned int) src->raw[4];\n\tdst->cooked.ex_offset = ((unsigned int) src->raw[5] << 16) |\n\t\t\t\t((unsigned int) src->raw[6] <<  8) |\n\t\t\t\t((unsigned int) src->raw[7] <<  0);\n\treturn;\n}",
          "includes": [
            "#include <linux/efs_fs_sb.h>",
            "#include \"efs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/efs_fs_sb.h>\n#include \"efs.h\"\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/buffer_head.h>\n\nstatic inline void extent_copy(efs_extent *src, efs_extent *dst) {\n\t/*\n\t * this is slightly evil. it doesn't just copy\n\t * efs_extent from src to dst, it also mangles\n\t * the bits so that dst ends up in cpu byte-order.\n\t */\n\n\tdst->cooked.ex_magic  =  (unsigned int) src->raw[0];\n\tdst->cooked.ex_bn     = ((unsigned int) src->raw[1] << 16) |\n\t\t\t\t((unsigned int) src->raw[2] <<  8) |\n\t\t\t\t((unsigned int) src->raw[3] <<  0);\n\tdst->cooked.ex_length =  (unsigned int) src->raw[4];\n\tdst->cooked.ex_offset = ((unsigned int) src->raw[5] << 16) |\n\t\t\t\t((unsigned int) src->raw[6] <<  8) |\n\t\t\t\t((unsigned int) src->raw[7] <<  0);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s(): read indirect extent block %d\\n\"",
            "__func__",
            "iblock"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s() failed at block %d\\n\"",
            "__func__",
            "iblock"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "inode->i_sb",
            "iblock"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"couldn't find direct extent for indirect extent %d (block %u)\\n\"",
            "cur",
            "block"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s(): indirect search for logical block %u\\n\"",
            "__func__",
            "block"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s() failed to map block %u (dir)\\n\"",
            "__func__",
            "block"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s() failed to map (1 extent)\\n\"",
            "__func__"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INODE_INFO",
          "args": [
            "inode"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_INFO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efs/efs.h",
          "lines": "117-120",
          "snippet": "static inline struct efs_inode_info *INODE_INFO(struct inode *inode)\n{\n\treturn container_of(inode, struct efs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/efs_fs_sb.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/efs_fs_sb.h>\n#include <asm/uaccess.h>\n#include <linux/fs.h>\n\nstatic inline struct efs_inode_info *INODE_INFO(struct inode *inode)\n{\n\treturn container_of(inode, struct efs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SUPER_INFO",
          "args": [
            "inode->i_sb"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "SUPER_INFO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efs/efs.h",
          "lines": "122-125",
          "snippet": "static inline struct efs_sb_info *SUPER_INFO(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/efs_fs_sb.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/efs_fs_sb.h>\n#include <asm/uaccess.h>\n#include <linux/fs.h>\n\nstatic inline struct efs_sb_info *SUPER_INFO(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/efs_fs_sb.h>\n#include \"efs.h\"\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/buffer_head.h>\n\nefs_block_t efs_map_block(struct inode *inode, efs_block_t block) {\n\tstruct efs_sb_info    *sb = SUPER_INFO(inode->i_sb);\n\tstruct efs_inode_info *in = INODE_INFO(inode);\n\tstruct buffer_head    *bh = NULL;\n\n\tint cur, last, first = 1;\n\tint ibase, ioffset, dirext, direxts, indext, indexts;\n\tefs_block_t iblock, result = 0, lastblock = 0;\n\tefs_extent ext, *exts;\n\n\tlast = in->lastextent;\n\n\tif (in->numextents <= EFS_DIRECTEXTENTS) {\n\t\t/* first check the last extent we returned */\n\t\tif ((result = efs_extent_check(&in->extents[last], block, sb)))\n\t\t\treturn result;\n    \n\t\t/* if we only have one extent then nothing can be found */\n\t\tif (in->numextents == 1) {\n\t\t\tpr_err(\"%s() failed to map (1 extent)\\n\", __func__);\n\t\t\treturn 0;\n\t\t}\n\n\t\tdirexts = in->numextents;\n\n\t\t/*\n\t\t * check the stored extents in the inode\n\t\t * start with next extent and check forwards\n\t\t */\n\t\tfor(dirext = 1; dirext < direxts; dirext++) {\n\t\t\tcur = (last + dirext) % in->numextents;\n\t\t\tif ((result = efs_extent_check(&in->extents[cur], block, sb))) {\n\t\t\t\tin->lastextent = cur;\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\tpr_err(\"%s() failed to map block %u (dir)\\n\", __func__, block);\n\t\treturn 0;\n\t}\n\n\tpr_debug(\"%s(): indirect search for logical block %u\\n\",\n\t\t __func__, block);\n\tdirexts = in->extents[0].cooked.ex_offset;\n\tindexts = in->numextents;\n\n\tfor(indext = 0; indext < indexts; indext++) {\n\t\tcur = (last + indext) % indexts;\n\n\t\t/*\n\t\t * work out which direct extent contains `cur'.\n\t\t *\n\t\t * also compute ibase: i.e. the number of the first\n\t\t * indirect extent contained within direct extent `cur'.\n\t\t *\n\t\t */\n\t\tibase = 0;\n\t\tfor(dirext = 0; cur < ibase && dirext < direxts; dirext++) {\n\t\t\tibase += in->extents[dirext].cooked.ex_length *\n\t\t\t\t(EFS_BLOCKSIZE / sizeof(efs_extent));\n\t\t}\n\n\t\tif (dirext == direxts) {\n\t\t\t/* should never happen */\n\t\t\tpr_err(\"couldn't find direct extent for indirect extent %d (block %u)\\n\",\n\t\t\t       cur, block);\n\t\t\tif (bh) brelse(bh);\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\t/* work out block number and offset of this indirect extent */\n\t\tiblock = sb->fs_start + in->extents[dirext].cooked.ex_bn +\n\t\t\t(cur - ibase) /\n\t\t\t(EFS_BLOCKSIZE / sizeof(efs_extent));\n\t\tioffset = (cur - ibase) %\n\t\t\t(EFS_BLOCKSIZE / sizeof(efs_extent));\n\n\t\tif (first || lastblock != iblock) {\n\t\t\tif (bh) brelse(bh);\n\n\t\t\tbh = sb_bread(inode->i_sb, iblock);\n\t\t\tif (!bh) {\n\t\t\t\tpr_err(\"%s() failed at block %d\\n\",\n\t\t\t\t       __func__, iblock);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tpr_debug(\"%s(): read indirect extent block %d\\n\",\n\t\t\t\t __func__, iblock);\n\t\t\tfirst = 0;\n\t\t\tlastblock = iblock;\n\t\t}\n\n\t\texts = (efs_extent *) bh->b_data;\n\n\t\textent_copy(&(exts[ioffset]), &ext);\n\n\t\tif (ext.cooked.ex_magic != 0) {\n\t\t\tpr_err(\"extent %d has bad magic number in block %d\\n\",\n\t\t\t       cur, iblock);\n\t\t\tif (bh) brelse(bh);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif ((result = efs_extent_check(&ext, block, sb))) {\n\t\t\tif (bh) brelse(bh);\n\t\t\tin->lastextent = cur;\n\t\t\treturn result;\n\t\t}\n\t}\n\tif (bh) brelse(bh);\n\tpr_err(\"%s() failed to map block %u (indir)\\n\", __func__, block);\n\treturn 0;\n}"
  },
  {
    "function_name": "efs_extent_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efs/inode.c",
    "lines": "176-195",
    "snippet": "static inline efs_block_t\nefs_extent_check(efs_extent *ptr, efs_block_t block, struct efs_sb_info *sb) {\n\tefs_block_t start;\n\tefs_block_t length;\n\tefs_block_t offset;\n\n\t/*\n\t * given an extent and a logical block within a file,\n\t * can this block be found within this extent ?\n\t */\n\tstart  = ptr->cooked.ex_bn;\n\tlength = ptr->cooked.ex_length;\n\toffset = ptr->cooked.ex_offset;\n\n\tif ((block >= offset) && (block < offset+length)) {\n\t\treturn(sb->fs_start + start + block - offset);\n\t} else {\n\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include <linux/efs_fs_sb.h>",
      "#include \"efs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/efs_fs_sb.h>\n#include \"efs.h\"\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/buffer_head.h>\n\nstatic inline efs_block_t\nefs_extent_check(efs_extent *ptr, efs_block_t block, struct efs_sb_info *sb) {\n\tefs_block_t start;\n\tefs_block_t length;\n\tefs_block_t offset;\n\n\t/*\n\t * given an extent and a logical block within a file,\n\t * can this block be found within this extent ?\n\t */\n\tstart  = ptr->cooked.ex_bn;\n\tlength = ptr->cooked.ex_length;\n\toffset = ptr->cooked.ex_offset;\n\n\tif ((block >= offset) && (block < offset+length)) {\n\t\treturn(sb->fs_start + start + block - offset);\n\t} else {\n\t\treturn 0;\n\t}\n}"
  },
  {
    "function_name": "efs_iget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efs/inode.c",
    "lines": "47-174",
    "snippet": "struct inode *efs_iget(struct super_block *super, unsigned long ino)\n{\n\tint i, inode_index;\n\tdev_t device;\n\tu32 rdev;\n\tstruct buffer_head *bh;\n\tstruct efs_sb_info    *sb = SUPER_INFO(super);\n\tstruct efs_inode_info *in;\n\tefs_block_t block, offset;\n\tstruct efs_dinode *efs_inode;\n\tstruct inode *inode;\n\n\tinode = iget_locked(super, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tin = INODE_INFO(inode);\n\n\t/*\n\t** EFS layout:\n\t**\n\t** |   cylinder group    |   cylinder group    |   cylinder group ..etc\n\t** |inodes|data          |inodes|data          |inodes|data       ..etc\n\t**\n\t** work out the inode block index, (considering initially that the\n\t** inodes are stored as consecutive blocks). then work out the block\n\t** number of that inode given the above layout, and finally the\n\t** offset of the inode within that block.\n\t*/\n\n\tinode_index = inode->i_ino /\n\t\t(EFS_BLOCKSIZE / sizeof(struct efs_dinode));\n\n\tblock = sb->fs_start + sb->first_block + \n\t\t(sb->group_size * (inode_index / sb->inode_blocks)) +\n\t\t(inode_index % sb->inode_blocks);\n\n\toffset = (inode->i_ino %\n\t\t\t(EFS_BLOCKSIZE / sizeof(struct efs_dinode))) *\n\t\tsizeof(struct efs_dinode);\n\n\tbh = sb_bread(inode->i_sb, block);\n\tif (!bh) {\n\t\tpr_warn(\"%s() failed at block %d\\n\", __func__, block);\n\t\tgoto read_inode_error;\n\t}\n\n\tefs_inode = (struct efs_dinode *) (bh->b_data + offset);\n    \n\tinode->i_mode  = be16_to_cpu(efs_inode->di_mode);\n\tset_nlink(inode, be16_to_cpu(efs_inode->di_nlink));\n\ti_uid_write(inode, (uid_t)be16_to_cpu(efs_inode->di_uid));\n\ti_gid_write(inode, (gid_t)be16_to_cpu(efs_inode->di_gid));\n\tinode->i_size  = be32_to_cpu(efs_inode->di_size);\n\tinode->i_atime.tv_sec = be32_to_cpu(efs_inode->di_atime);\n\tinode->i_mtime.tv_sec = be32_to_cpu(efs_inode->di_mtime);\n\tinode->i_ctime.tv_sec = be32_to_cpu(efs_inode->di_ctime);\n\tinode->i_atime.tv_nsec = inode->i_mtime.tv_nsec = inode->i_ctime.tv_nsec = 0;\n\n\t/* this is the number of blocks in the file */\n\tif (inode->i_size == 0) {\n\t\tinode->i_blocks = 0;\n\t} else {\n\t\tinode->i_blocks = ((inode->i_size - 1) >> EFS_BLOCKSIZE_BITS) + 1;\n\t}\n\n\trdev = be16_to_cpu(efs_inode->di_u.di_dev.odev);\n\tif (rdev == 0xffff) {\n\t\trdev = be32_to_cpu(efs_inode->di_u.di_dev.ndev);\n\t\tif (sysv_major(rdev) > 0xfff)\n\t\t\tdevice = 0;\n\t\telse\n\t\t\tdevice = MKDEV(sysv_major(rdev), sysv_minor(rdev));\n\t} else\n\t\tdevice = old_decode_dev(rdev);\n\n\t/* get the number of extents for this object */\n\tin->numextents = be16_to_cpu(efs_inode->di_numextents);\n\tin->lastextent = 0;\n\n\t/* copy the extents contained within the inode to memory */\n\tfor(i = 0; i < EFS_DIRECTEXTENTS; i++) {\n\t\textent_copy(&(efs_inode->di_u.di_extents[i]), &(in->extents[i]));\n\t\tif (i < in->numextents && in->extents[i].cooked.ex_magic != 0) {\n\t\t\tpr_warn(\"extent %d has bad magic number in inode %lu\\n\",\n\t\t\t\ti, inode->i_ino);\n\t\t\tbrelse(bh);\n\t\t\tgoto read_inode_error;\n\t\t}\n\t}\n\n\tbrelse(bh);\n\tpr_debug(\"efs_iget(): inode %lu, extents %d, mode %o\\n\",\n\t\t inode->i_ino, in->numextents, inode->i_mode);\n\tswitch (inode->i_mode & S_IFMT) {\n\t\tcase S_IFDIR: \n\t\t\tinode->i_op = &efs_dir_inode_operations; \n\t\t\tinode->i_fop = &efs_dir_operations; \n\t\t\tbreak;\n\t\tcase S_IFREG:\n\t\t\tinode->i_fop = &generic_ro_fops;\n\t\t\tinode->i_data.a_ops = &efs_aops;\n\t\t\tbreak;\n\t\tcase S_IFLNK:\n\t\t\tinode->i_op = &page_symlink_inode_operations;\n\t\t\tinode->i_data.a_ops = &efs_symlink_aops;\n\t\t\tbreak;\n\t\tcase S_IFCHR:\n\t\tcase S_IFBLK:\n\t\tcase S_IFIFO:\n\t\t\tinit_special_inode(inode, inode->i_mode, device);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_warn(\"unsupported inode mode %o\\n\", inode->i_mode);\n\t\t\tgoto read_inode_error;\n\t\t\tbreak;\n\t}\n\n\tunlock_new_inode(inode);\n\treturn inode;\n        \nread_inode_error:\n\tpr_warn(\"failed to read inode %lu\\n\", inode->i_ino);\n\tiget_failed(inode);\n\treturn ERR_PTR(-EIO);\n}",
    "includes": [
      "#include <linux/efs_fs_sb.h>",
      "#include \"efs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct address_space_operations efs_aops = {\n\t.readpage = efs_readpage,\n\t.bmap = _efs_bmap\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iget_failed",
          "args": [
            "inode"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "iget_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "208-213",
          "snippet": "void iget_failed(struct inode *inode)\n{\n\tmake_bad_inode(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nvoid iget_failed(struct inode *inode)\n{\n\tmake_bad_inode(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"failed to read inode %lu\\n\"",
            "inode->i_ino"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"unsupported inode mode %o\\n\"",
            "inode->i_mode"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_special_inode",
          "args": [
            "inode",
            "inode->i_mode",
            "device"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "init_special_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1854-1871",
          "snippet": "void init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)\n{\n\tinode->i_mode = mode;\n\tif (S_ISCHR(mode)) {\n\t\tinode->i_fop = &def_chr_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISBLK(mode)) {\n\t\tinode->i_fop = &def_blk_fops;\n\t\tinode->i_rdev = rdev;\n\t} else if (S_ISFIFO(mode))\n\t\tinode->i_fop = &pipefifo_fops;\n\telse if (S_ISSOCK(mode))\n\t\t;\t/* leave it no_open_fops */\n\telse\n\t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\"\n\t\t\t\t  \" inode %s:%lu\\n\", mode, inode->i_sb->s_id,\n\t\t\t\t  inode->i_ino);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"efs_iget(): inode %lu, extents %d, mode %o\\n\"",
            "inode->i_ino",
            "in->numextents",
            "inode->i_mode"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"extent %d has bad magic number in inode %lu\\n\"",
            "i",
            "inode->i_ino"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "extent_copy",
          "args": [
            "&(efs_inode->di_u.di_extents[i])",
            "&(in->extents[i])"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "extent_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efs/inode.c",
          "lines": "29-45",
          "snippet": "static inline void extent_copy(efs_extent *src, efs_extent *dst) {\n\t/*\n\t * this is slightly evil. it doesn't just copy\n\t * efs_extent from src to dst, it also mangles\n\t * the bits so that dst ends up in cpu byte-order.\n\t */\n\n\tdst->cooked.ex_magic  =  (unsigned int) src->raw[0];\n\tdst->cooked.ex_bn     = ((unsigned int) src->raw[1] << 16) |\n\t\t\t\t((unsigned int) src->raw[2] <<  8) |\n\t\t\t\t((unsigned int) src->raw[3] <<  0);\n\tdst->cooked.ex_length =  (unsigned int) src->raw[4];\n\tdst->cooked.ex_offset = ((unsigned int) src->raw[5] << 16) |\n\t\t\t\t((unsigned int) src->raw[6] <<  8) |\n\t\t\t\t((unsigned int) src->raw[7] <<  0);\n\treturn;\n}",
          "includes": [
            "#include <linux/efs_fs_sb.h>",
            "#include \"efs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/efs_fs_sb.h>\n#include \"efs.h\"\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/buffer_head.h>\n\nstatic inline void extent_copy(efs_extent *src, efs_extent *dst) {\n\t/*\n\t * this is slightly evil. it doesn't just copy\n\t * efs_extent from src to dst, it also mangles\n\t * the bits so that dst ends up in cpu byte-order.\n\t */\n\n\tdst->cooked.ex_magic  =  (unsigned int) src->raw[0];\n\tdst->cooked.ex_bn     = ((unsigned int) src->raw[1] << 16) |\n\t\t\t\t((unsigned int) src->raw[2] <<  8) |\n\t\t\t\t((unsigned int) src->raw[3] <<  0);\n\tdst->cooked.ex_length =  (unsigned int) src->raw[4];\n\tdst->cooked.ex_offset = ((unsigned int) src->raw[5] << 16) |\n\t\t\t\t((unsigned int) src->raw[6] <<  8) |\n\t\t\t\t((unsigned int) src->raw[7] <<  0);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "efs_inode->di_numextents"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "old_decode_dev",
          "args": [
            "rdev"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MKDEV",
          "args": [
            "sysv_major(rdev)",
            "sysv_minor(rdev)"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysv_minor",
          "args": [
            "rdev"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysv_major",
          "args": [
            "rdev"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysv_major",
          "args": [
            "rdev"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "efs_inode->di_u.di_dev.ndev"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "efs_inode->di_u.di_dev.odev"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "efs_inode->di_ctime"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "efs_inode->di_mtime"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "efs_inode->di_atime"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "efs_inode->di_size"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_gid_write",
          "args": [
            "inode",
            "(gid_t)be16_to_cpu(efs_inode->di_gid)"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "efs_inode->di_gid"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_uid_write",
          "args": [
            "inode",
            "(uid_t)be16_to_cpu(efs_inode->di_uid)"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "efs_inode->di_uid"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "be16_to_cpu(efs_inode->di_nlink)"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "efs_inode->di_nlink"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "efs_inode->di_mode"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s() failed at block %d\\n\"",
            "__func__",
            "block"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "inode->i_sb",
            "block"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INODE_INFO",
          "args": [
            "inode"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_INFO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efs/efs.h",
          "lines": "117-120",
          "snippet": "static inline struct efs_inode_info *INODE_INFO(struct inode *inode)\n{\n\treturn container_of(inode, struct efs_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <linux/efs_fs_sb.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/efs_fs_sb.h>\n#include <asm/uaccess.h>\n#include <linux/fs.h>\n\nstatic inline struct efs_inode_info *INODE_INFO(struct inode *inode)\n{\n\treturn container_of(inode, struct efs_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iget_locked",
          "args": [
            "super",
            "ino"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "iget_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1063-1109",
          "snippet": "struct inode *iget_locked(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode_fast(sb, head, ino);\n\tspin_unlock(&inode_hash_lock);\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode_fast(sb, head, ino);\n\t\tif (!old) {\n\t\t\tinode->i_ino = ino;\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *iget_locked(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode_fast(sb, head, ino);\n\tspin_unlock(&inode_hash_lock);\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode_fast(sb, head, ino);\n\t\tif (!old) {\n\t\t\tinode->i_ino = ino;\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SUPER_INFO",
          "args": [
            "super"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "SUPER_INFO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efs/efs.h",
          "lines": "122-125",
          "snippet": "static inline struct efs_sb_info *SUPER_INFO(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <linux/efs_fs_sb.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/efs_fs_sb.h>\n#include <asm/uaccess.h>\n#include <linux/fs.h>\n\nstatic inline struct efs_sb_info *SUPER_INFO(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/efs_fs_sb.h>\n#include \"efs.h\"\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/buffer_head.h>\n\nstatic const struct address_space_operations efs_aops = {\n\t.readpage = efs_readpage,\n\t.bmap = _efs_bmap\n};\n\nstruct inode *efs_iget(struct super_block *super, unsigned long ino)\n{\n\tint i, inode_index;\n\tdev_t device;\n\tu32 rdev;\n\tstruct buffer_head *bh;\n\tstruct efs_sb_info    *sb = SUPER_INFO(super);\n\tstruct efs_inode_info *in;\n\tefs_block_t block, offset;\n\tstruct efs_dinode *efs_inode;\n\tstruct inode *inode;\n\n\tinode = iget_locked(super, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tin = INODE_INFO(inode);\n\n\t/*\n\t** EFS layout:\n\t**\n\t** |   cylinder group    |   cylinder group    |   cylinder group ..etc\n\t** |inodes|data          |inodes|data          |inodes|data       ..etc\n\t**\n\t** work out the inode block index, (considering initially that the\n\t** inodes are stored as consecutive blocks). then work out the block\n\t** number of that inode given the above layout, and finally the\n\t** offset of the inode within that block.\n\t*/\n\n\tinode_index = inode->i_ino /\n\t\t(EFS_BLOCKSIZE / sizeof(struct efs_dinode));\n\n\tblock = sb->fs_start + sb->first_block + \n\t\t(sb->group_size * (inode_index / sb->inode_blocks)) +\n\t\t(inode_index % sb->inode_blocks);\n\n\toffset = (inode->i_ino %\n\t\t\t(EFS_BLOCKSIZE / sizeof(struct efs_dinode))) *\n\t\tsizeof(struct efs_dinode);\n\n\tbh = sb_bread(inode->i_sb, block);\n\tif (!bh) {\n\t\tpr_warn(\"%s() failed at block %d\\n\", __func__, block);\n\t\tgoto read_inode_error;\n\t}\n\n\tefs_inode = (struct efs_dinode *) (bh->b_data + offset);\n    \n\tinode->i_mode  = be16_to_cpu(efs_inode->di_mode);\n\tset_nlink(inode, be16_to_cpu(efs_inode->di_nlink));\n\ti_uid_write(inode, (uid_t)be16_to_cpu(efs_inode->di_uid));\n\ti_gid_write(inode, (gid_t)be16_to_cpu(efs_inode->di_gid));\n\tinode->i_size  = be32_to_cpu(efs_inode->di_size);\n\tinode->i_atime.tv_sec = be32_to_cpu(efs_inode->di_atime);\n\tinode->i_mtime.tv_sec = be32_to_cpu(efs_inode->di_mtime);\n\tinode->i_ctime.tv_sec = be32_to_cpu(efs_inode->di_ctime);\n\tinode->i_atime.tv_nsec = inode->i_mtime.tv_nsec = inode->i_ctime.tv_nsec = 0;\n\n\t/* this is the number of blocks in the file */\n\tif (inode->i_size == 0) {\n\t\tinode->i_blocks = 0;\n\t} else {\n\t\tinode->i_blocks = ((inode->i_size - 1) >> EFS_BLOCKSIZE_BITS) + 1;\n\t}\n\n\trdev = be16_to_cpu(efs_inode->di_u.di_dev.odev);\n\tif (rdev == 0xffff) {\n\t\trdev = be32_to_cpu(efs_inode->di_u.di_dev.ndev);\n\t\tif (sysv_major(rdev) > 0xfff)\n\t\t\tdevice = 0;\n\t\telse\n\t\t\tdevice = MKDEV(sysv_major(rdev), sysv_minor(rdev));\n\t} else\n\t\tdevice = old_decode_dev(rdev);\n\n\t/* get the number of extents for this object */\n\tin->numextents = be16_to_cpu(efs_inode->di_numextents);\n\tin->lastextent = 0;\n\n\t/* copy the extents contained within the inode to memory */\n\tfor(i = 0; i < EFS_DIRECTEXTENTS; i++) {\n\t\textent_copy(&(efs_inode->di_u.di_extents[i]), &(in->extents[i]));\n\t\tif (i < in->numextents && in->extents[i].cooked.ex_magic != 0) {\n\t\t\tpr_warn(\"extent %d has bad magic number in inode %lu\\n\",\n\t\t\t\ti, inode->i_ino);\n\t\t\tbrelse(bh);\n\t\t\tgoto read_inode_error;\n\t\t}\n\t}\n\n\tbrelse(bh);\n\tpr_debug(\"efs_iget(): inode %lu, extents %d, mode %o\\n\",\n\t\t inode->i_ino, in->numextents, inode->i_mode);\n\tswitch (inode->i_mode & S_IFMT) {\n\t\tcase S_IFDIR: \n\t\t\tinode->i_op = &efs_dir_inode_operations; \n\t\t\tinode->i_fop = &efs_dir_operations; \n\t\t\tbreak;\n\t\tcase S_IFREG:\n\t\t\tinode->i_fop = &generic_ro_fops;\n\t\t\tinode->i_data.a_ops = &efs_aops;\n\t\t\tbreak;\n\t\tcase S_IFLNK:\n\t\t\tinode->i_op = &page_symlink_inode_operations;\n\t\t\tinode->i_data.a_ops = &efs_symlink_aops;\n\t\t\tbreak;\n\t\tcase S_IFCHR:\n\t\tcase S_IFBLK:\n\t\tcase S_IFIFO:\n\t\t\tinit_special_inode(inode, inode->i_mode, device);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_warn(\"unsupported inode mode %o\\n\", inode->i_mode);\n\t\t\tgoto read_inode_error;\n\t\t\tbreak;\n\t}\n\n\tunlock_new_inode(inode);\n\treturn inode;\n        \nread_inode_error:\n\tpr_warn(\"failed to read inode %lu\\n\", inode->i_ino);\n\tiget_failed(inode);\n\treturn ERR_PTR(-EIO);\n}"
  },
  {
    "function_name": "extent_copy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efs/inode.c",
    "lines": "29-45",
    "snippet": "static inline void extent_copy(efs_extent *src, efs_extent *dst) {\n\t/*\n\t * this is slightly evil. it doesn't just copy\n\t * efs_extent from src to dst, it also mangles\n\t * the bits so that dst ends up in cpu byte-order.\n\t */\n\n\tdst->cooked.ex_magic  =  (unsigned int) src->raw[0];\n\tdst->cooked.ex_bn     = ((unsigned int) src->raw[1] << 16) |\n\t\t\t\t((unsigned int) src->raw[2] <<  8) |\n\t\t\t\t((unsigned int) src->raw[3] <<  0);\n\tdst->cooked.ex_length =  (unsigned int) src->raw[4];\n\tdst->cooked.ex_offset = ((unsigned int) src->raw[5] << 16) |\n\t\t\t\t((unsigned int) src->raw[6] <<  8) |\n\t\t\t\t((unsigned int) src->raw[7] <<  0);\n\treturn;\n}",
    "includes": [
      "#include <linux/efs_fs_sb.h>",
      "#include \"efs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/efs_fs_sb.h>\n#include \"efs.h\"\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/buffer_head.h>\n\nstatic inline void extent_copy(efs_extent *src, efs_extent *dst) {\n\t/*\n\t * this is slightly evil. it doesn't just copy\n\t * efs_extent from src to dst, it also mangles\n\t * the bits so that dst ends up in cpu byte-order.\n\t */\n\n\tdst->cooked.ex_magic  =  (unsigned int) src->raw[0];\n\tdst->cooked.ex_bn     = ((unsigned int) src->raw[1] << 16) |\n\t\t\t\t((unsigned int) src->raw[2] <<  8) |\n\t\t\t\t((unsigned int) src->raw[3] <<  0);\n\tdst->cooked.ex_length =  (unsigned int) src->raw[4];\n\tdst->cooked.ex_offset = ((unsigned int) src->raw[5] << 16) |\n\t\t\t\t((unsigned int) src->raw[6] <<  8) |\n\t\t\t\t((unsigned int) src->raw[7] <<  0);\n\treturn;\n}"
  },
  {
    "function_name": "_efs_bmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efs/inode.c",
    "lines": "20-23",
    "snippet": "static sector_t _efs_bmap(struct address_space *mapping, sector_t block)\n{\n\treturn generic_block_bmap(mapping,block,efs_get_block);\n}",
    "includes": [
      "#include <linux/efs_fs_sb.h>",
      "#include \"efs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "generic_block_bmap",
          "args": [
            "mapping",
            "block",
            "efs_get_block"
          ],
          "line": 22
        },
        "resolved": true,
        "details": {
          "function_name": "generic_block_bmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2924-2934",
          "snippet": "sector_t generic_block_bmap(struct address_space *mapping, sector_t block,\n\t\t\t    get_block_t *get_block)\n{\n\tstruct buffer_head tmp;\n\tstruct inode *inode = mapping->host;\n\ttmp.b_state = 0;\n\ttmp.b_blocknr = 0;\n\ttmp.b_size = 1 << inode->i_blkbits;\n\tget_block(inode, block, &tmp, 0);\n\treturn tmp.b_blocknr;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nsector_t generic_block_bmap(struct address_space *mapping, sector_t block,\n\t\t\t    get_block_t *get_block)\n{\n\tstruct buffer_head tmp;\n\tstruct inode *inode = mapping->host;\n\ttmp.b_state = 0;\n\ttmp.b_blocknr = 0;\n\ttmp.b_size = 1 << inode->i_blkbits;\n\tget_block(inode, block, &tmp, 0);\n\treturn tmp.b_blocknr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/efs_fs_sb.h>\n#include \"efs.h\"\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/buffer_head.h>\n\nstatic sector_t _efs_bmap(struct address_space *mapping, sector_t block)\n{\n\treturn generic_block_bmap(mapping,block,efs_get_block);\n}"
  },
  {
    "function_name": "efs_readpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/efs/inode.c",
    "lines": "16-19",
    "snippet": "static int efs_readpage(struct file *file, struct page *page)\n{\n\treturn block_read_full_page(page,efs_get_block);\n}",
    "includes": [
      "#include <linux/efs_fs_sb.h>",
      "#include \"efs.h\"",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/buffer_head.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "block_read_full_page",
          "args": [
            "page",
            "efs_get_block"
          ],
          "line": 18
        },
        "resolved": true,
        "details": {
          "function_name": "block_read_full_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2159-2242",
          "snippet": "int block_read_full_page(struct page *page, get_block_t *get_block)\n{\n\tstruct inode *inode = page->mapping->host;\n\tsector_t iblock, lblock;\n\tstruct buffer_head *bh, *head, *arr[MAX_BUF_PER_PAGE];\n\tunsigned int blocksize, bbits;\n\tint nr, i;\n\tint fully_mapped = 1;\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tiblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\tlblock = (i_size_read(inode)+blocksize-1) >> bbits;\n\tbh = head;\n\tnr = 0;\n\ti = 0;\n\n\tdo {\n\t\tif (buffer_uptodate(bh))\n\t\t\tcontinue;\n\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tint err = 0;\n\n\t\t\tfully_mapped = 0;\n\t\t\tif (iblock < lblock) {\n\t\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\t\terr = get_block(inode, iblock, bh, 0);\n\t\t\t\tif (err)\n\t\t\t\t\tSetPageError(page);\n\t\t\t}\n\t\t\tif (!buffer_mapped(bh)) {\n\t\t\t\tzero_user(page, i * blocksize, blocksize);\n\t\t\t\tif (!err)\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * get_block() might have updated the buffer\n\t\t\t * synchronously\n\t\t\t */\n\t\t\tif (buffer_uptodate(bh))\n\t\t\t\tcontinue;\n\t\t}\n\t\tarr[nr++] = bh;\n\t} while (i++, iblock++, (bh = bh->b_this_page) != head);\n\n\tif (fully_mapped)\n\t\tSetPageMappedToDisk(page);\n\n\tif (!nr) {\n\t\t/*\n\t\t * All buffers are uptodate - we can set the page uptodate\n\t\t * as well. But not if get_block() returned an error.\n\t\t */\n\t\tif (!PageError(page))\n\t\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\n\t/* Stage two: lock the buffers */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tlock_buffer(bh);\n\t\tmark_buffer_async_read(bh);\n\t}\n\n\t/*\n\t * Stage 3: start the IO.  Check for uptodateness\n\t * inside the buffer lock in case another process reading\n\t * the underlying blockdev brought it uptodate (the sct fix).\n\t */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tif (buffer_uptodate(bh))\n\t\t\tend_buffer_async_read(bh, 1);\n\t\telse\n\t\t\tsubmit_bh(READ, bh);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_read_full_page(struct page *page, get_block_t *get_block)\n{\n\tstruct inode *inode = page->mapping->host;\n\tsector_t iblock, lblock;\n\tstruct buffer_head *bh, *head, *arr[MAX_BUF_PER_PAGE];\n\tunsigned int blocksize, bbits;\n\tint nr, i;\n\tint fully_mapped = 1;\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tiblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\tlblock = (i_size_read(inode)+blocksize-1) >> bbits;\n\tbh = head;\n\tnr = 0;\n\ti = 0;\n\n\tdo {\n\t\tif (buffer_uptodate(bh))\n\t\t\tcontinue;\n\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tint err = 0;\n\n\t\t\tfully_mapped = 0;\n\t\t\tif (iblock < lblock) {\n\t\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\t\terr = get_block(inode, iblock, bh, 0);\n\t\t\t\tif (err)\n\t\t\t\t\tSetPageError(page);\n\t\t\t}\n\t\t\tif (!buffer_mapped(bh)) {\n\t\t\t\tzero_user(page, i * blocksize, blocksize);\n\t\t\t\tif (!err)\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * get_block() might have updated the buffer\n\t\t\t * synchronously\n\t\t\t */\n\t\t\tif (buffer_uptodate(bh))\n\t\t\t\tcontinue;\n\t\t}\n\t\tarr[nr++] = bh;\n\t} while (i++, iblock++, (bh = bh->b_this_page) != head);\n\n\tif (fully_mapped)\n\t\tSetPageMappedToDisk(page);\n\n\tif (!nr) {\n\t\t/*\n\t\t * All buffers are uptodate - we can set the page uptodate\n\t\t * as well. But not if get_block() returned an error.\n\t\t */\n\t\tif (!PageError(page))\n\t\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\n\t/* Stage two: lock the buffers */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tlock_buffer(bh);\n\t\tmark_buffer_async_read(bh);\n\t}\n\n\t/*\n\t * Stage 3: start the IO.  Check for uptodateness\n\t * inside the buffer lock in case another process reading\n\t * the underlying blockdev brought it uptodate (the sct fix).\n\t */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tif (buffer_uptodate(bh))\n\t\t\tend_buffer_async_read(bh, 1);\n\t\telse\n\t\t\tsubmit_bh(READ, bh);\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/efs_fs_sb.h>\n#include \"efs.h\"\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/buffer_head.h>\n\nstatic int efs_readpage(struct file *file, struct page *page)\n{\n\treturn block_read_full_page(page,efs_get_block);\n}"
  }
]