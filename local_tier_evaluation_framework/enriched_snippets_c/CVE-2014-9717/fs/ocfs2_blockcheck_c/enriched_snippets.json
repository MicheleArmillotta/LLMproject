[
  {
    "function_name": "ocfs2_validate_meta_ecc_bhs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
    "lines": "634-646",
    "snippet": "int ocfs2_validate_meta_ecc_bhs(struct super_block *sb,\n\t\t\t\tstruct buffer_head **bhs, int nr,\n\t\t\t\tstruct ocfs2_block_check *bc)\n{\n\tint rc = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tif (ocfs2_meta_ecc(osb))\n\t\trc = ocfs2_block_check_validate_bhs(bhs, nr, bc,\n\t\t\t\t\t\t    &osb->osb_ecc_stats);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"blockcheck.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/bitops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/crc32.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_block_check_validate_bhs",
          "args": [
            "bhs",
            "nr",
            "bc",
            "&osb->osb_ecc_stats"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_block_check_validate_bhs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
          "lines": "527-598",
          "snippet": "int ocfs2_block_check_validate_bhs(struct buffer_head **bhs, int nr,\n\t\t\t\t   struct ocfs2_block_check *bc,\n\t\t\t\t   struct ocfs2_blockcheck_stats *stats)\n{\n\tint i, rc = 0;\n\tu32 bc_crc32e;\n\tu16 bc_ecc;\n\tu32 crc, ecc, fix;\n\n\tBUG_ON(nr < 0);\n\n\tif (!nr)\n\t\treturn 0;\n\n\tocfs2_blockcheck_inc_check(stats);\n\n\tbc_crc32e = le32_to_cpu(bc->bc_crc32e);\n\tbc_ecc = le16_to_cpu(bc->bc_ecc);\n\n\tmemset(bc, 0, sizeof(struct ocfs2_block_check));\n\n\t/* Fast path - if the crc32 validates, we're good to go */\n\tfor (i = 0, crc = ~0; i < nr; i++)\n\t\tcrc = crc32_le(crc, bhs[i]->b_data, bhs[i]->b_size);\n\tif (crc == bc_crc32e)\n\t\tgoto out;\n\n\tocfs2_blockcheck_inc_failure(stats);\n\tmlog(ML_ERROR,\n\t     \"CRC32 failed: stored: %u, computed %u.  Applying ECC.\\n\",\n\t     (unsigned int)bc_crc32e, (unsigned int)crc);\n\n\t/* Ok, try ECC fixups */\n\tfor (i = 0, ecc = 0; i < nr; i++) {\n\t\t/*\n\t\t * The number of bits in a buffer is obviously b_size*8.\n\t\t * The offset of this buffer is b_size*i, so the bit offset\n\t\t * of this buffer is b_size*8*i.\n\t\t */\n\t\tecc = (u16)ocfs2_hamming_encode(ecc, bhs[i]->b_data,\n\t\t\t\t\t\tbhs[i]->b_size * 8,\n\t\t\t\t\t\tbhs[i]->b_size * 8 * i);\n\t}\n\tfix = ecc ^ bc_ecc;\n\tfor (i = 0; i < nr; i++) {\n\t\t/*\n\t\t * Try the fix against each buffer.  It will only affect\n\t\t * one of them.\n\t\t */\n\t\tocfs2_hamming_fix(bhs[i]->b_data, bhs[i]->b_size * 8,\n\t\t\t\t  bhs[i]->b_size * 8 * i, fix);\n\t}\n\n\t/* And check the crc32 again */\n\tfor (i = 0, crc = ~0; i < nr; i++)\n\t\tcrc = crc32_le(crc, bhs[i]->b_data, bhs[i]->b_size);\n\tif (crc == bc_crc32e) {\n\t\tocfs2_blockcheck_inc_recover(stats);\n\t\tgoto out;\n\t}\n\n\tmlog(ML_ERROR, \"Fixed CRC32 failed: stored: %u, computed %u\\n\",\n\t     (unsigned int)bc_crc32e, (unsigned int)crc);\n\n\trc = -EIO;\n\nout:\n\tbc->bc_crc32e = cpu_to_le32(bc_crc32e);\n\tbc->bc_ecc = cpu_to_le16(bc_ecc);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"blockcheck.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nint ocfs2_block_check_validate_bhs(struct buffer_head **bhs, int nr,\n\t\t\t\t   struct ocfs2_block_check *bc,\n\t\t\t\t   struct ocfs2_blockcheck_stats *stats)\n{\n\tint i, rc = 0;\n\tu32 bc_crc32e;\n\tu16 bc_ecc;\n\tu32 crc, ecc, fix;\n\n\tBUG_ON(nr < 0);\n\n\tif (!nr)\n\t\treturn 0;\n\n\tocfs2_blockcheck_inc_check(stats);\n\n\tbc_crc32e = le32_to_cpu(bc->bc_crc32e);\n\tbc_ecc = le16_to_cpu(bc->bc_ecc);\n\n\tmemset(bc, 0, sizeof(struct ocfs2_block_check));\n\n\t/* Fast path - if the crc32 validates, we're good to go */\n\tfor (i = 0, crc = ~0; i < nr; i++)\n\t\tcrc = crc32_le(crc, bhs[i]->b_data, bhs[i]->b_size);\n\tif (crc == bc_crc32e)\n\t\tgoto out;\n\n\tocfs2_blockcheck_inc_failure(stats);\n\tmlog(ML_ERROR,\n\t     \"CRC32 failed: stored: %u, computed %u.  Applying ECC.\\n\",\n\t     (unsigned int)bc_crc32e, (unsigned int)crc);\n\n\t/* Ok, try ECC fixups */\n\tfor (i = 0, ecc = 0; i < nr; i++) {\n\t\t/*\n\t\t * The number of bits in a buffer is obviously b_size*8.\n\t\t * The offset of this buffer is b_size*i, so the bit offset\n\t\t * of this buffer is b_size*8*i.\n\t\t */\n\t\tecc = (u16)ocfs2_hamming_encode(ecc, bhs[i]->b_data,\n\t\t\t\t\t\tbhs[i]->b_size * 8,\n\t\t\t\t\t\tbhs[i]->b_size * 8 * i);\n\t}\n\tfix = ecc ^ bc_ecc;\n\tfor (i = 0; i < nr; i++) {\n\t\t/*\n\t\t * Try the fix against each buffer.  It will only affect\n\t\t * one of them.\n\t\t */\n\t\tocfs2_hamming_fix(bhs[i]->b_data, bhs[i]->b_size * 8,\n\t\t\t\t  bhs[i]->b_size * 8 * i, fix);\n\t}\n\n\t/* And check the crc32 again */\n\tfor (i = 0, crc = ~0; i < nr; i++)\n\t\tcrc = crc32_le(crc, bhs[i]->b_data, bhs[i]->b_size);\n\tif (crc == bc_crc32e) {\n\t\tocfs2_blockcheck_inc_recover(stats);\n\t\tgoto out;\n\t}\n\n\tmlog(ML_ERROR, \"Fixed CRC32 failed: stored: %u, computed %u\\n\",\n\t     (unsigned int)bc_crc32e, (unsigned int)crc);\n\n\trc = -EIO;\n\nout:\n\tbc->bc_crc32e = cpu_to_le32(bc_crc32e);\n\tbc->bc_ecc = cpu_to_le16(bc_ecc);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_meta_ecc",
          "args": [
            "osb"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_meta_ecc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "525-530",
          "snippet": "static inline int ocfs2_meta_ecc(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_META_ECC)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_meta_ecc(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_META_ECC)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nint ocfs2_validate_meta_ecc_bhs(struct super_block *sb,\n\t\t\t\tstruct buffer_head **bhs, int nr,\n\t\t\t\tstruct ocfs2_block_check *bc)\n{\n\tint rc = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tif (ocfs2_meta_ecc(osb))\n\t\trc = ocfs2_block_check_validate_bhs(bhs, nr, bc,\n\t\t\t\t\t\t    &osb->osb_ecc_stats);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "ocfs2_compute_meta_ecc_bhs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
    "lines": "626-632",
    "snippet": "void ocfs2_compute_meta_ecc_bhs(struct super_block *sb,\n\t\t\t\tstruct buffer_head **bhs, int nr,\n\t\t\t\tstruct ocfs2_block_check *bc)\n{\n\tif (ocfs2_meta_ecc(OCFS2_SB(sb)))\n\t\tocfs2_block_check_compute_bhs(bhs, nr, bc);\n}",
    "includes": [
      "#include \"blockcheck.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/bitops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/crc32.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_block_check_compute_bhs",
          "args": [
            "bhs",
            "nr",
            "bc"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_block_check_compute_bhs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
          "lines": "483-516",
          "snippet": "void ocfs2_block_check_compute_bhs(struct buffer_head **bhs, int nr,\n\t\t\t\t   struct ocfs2_block_check *bc)\n{\n\tint i;\n\tu32 crc, ecc;\n\n\tBUG_ON(nr < 0);\n\n\tif (!nr)\n\t\treturn;\n\n\tmemset(bc, 0, sizeof(struct ocfs2_block_check));\n\n\tfor (i = 0, crc = ~0, ecc = 0; i < nr; i++) {\n\t\tcrc = crc32_le(crc, bhs[i]->b_data, bhs[i]->b_size);\n\t\t/*\n\t\t * The number of bits in a buffer is obviously b_size*8.\n\t\t * The offset of this buffer is b_size*i, so the bit offset\n\t\t * of this buffer is b_size*8*i.\n\t\t */\n\t\tecc = (u16)ocfs2_hamming_encode(ecc, bhs[i]->b_data,\n\t\t\t\t\t\tbhs[i]->b_size * 8,\n\t\t\t\t\t\tbhs[i]->b_size * 8 * i);\n\t}\n\n\t/*\n\t * No ecc'd ocfs2 structure is larger than 4K, so ecc will be no\n\t * larger than 16 bits.\n\t */\n\tBUG_ON(ecc > USHRT_MAX);\n\n\tbc->bc_crc32e = cpu_to_le32(crc);\n\tbc->bc_ecc = cpu_to_le16((u16)ecc);\n}",
          "includes": [
            "#include \"blockcheck.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid ocfs2_block_check_compute_bhs(struct buffer_head **bhs, int nr,\n\t\t\t\t   struct ocfs2_block_check *bc)\n{\n\tint i;\n\tu32 crc, ecc;\n\n\tBUG_ON(nr < 0);\n\n\tif (!nr)\n\t\treturn;\n\n\tmemset(bc, 0, sizeof(struct ocfs2_block_check));\n\n\tfor (i = 0, crc = ~0, ecc = 0; i < nr; i++) {\n\t\tcrc = crc32_le(crc, bhs[i]->b_data, bhs[i]->b_size);\n\t\t/*\n\t\t * The number of bits in a buffer is obviously b_size*8.\n\t\t * The offset of this buffer is b_size*i, so the bit offset\n\t\t * of this buffer is b_size*8*i.\n\t\t */\n\t\tecc = (u16)ocfs2_hamming_encode(ecc, bhs[i]->b_data,\n\t\t\t\t\t\tbhs[i]->b_size * 8,\n\t\t\t\t\t\tbhs[i]->b_size * 8 * i);\n\t}\n\n\t/*\n\t * No ecc'd ocfs2 structure is larger than 4K, so ecc will be no\n\t * larger than 16 bits.\n\t */\n\tBUG_ON(ecc > USHRT_MAX);\n\n\tbc->bc_crc32e = cpu_to_le32(crc);\n\tbc->bc_ecc = cpu_to_le16((u16)ecc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_meta_ecc",
          "args": [
            "OCFS2_SB(sb)"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_meta_ecc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "525-530",
          "snippet": "static inline int ocfs2_meta_ecc(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_META_ECC)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_meta_ecc(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_META_ECC)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid ocfs2_compute_meta_ecc_bhs(struct super_block *sb,\n\t\t\t\tstruct buffer_head **bhs, int nr,\n\t\t\t\tstruct ocfs2_block_check *bc)\n{\n\tif (ocfs2_meta_ecc(OCFS2_SB(sb)))\n\t\tocfs2_block_check_compute_bhs(bhs, nr, bc);\n}"
  },
  {
    "function_name": "ocfs2_validate_meta_ecc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
    "lines": "613-624",
    "snippet": "int ocfs2_validate_meta_ecc(struct super_block *sb, void *data,\n\t\t\t    struct ocfs2_block_check *bc)\n{\n\tint rc = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tif (ocfs2_meta_ecc(osb))\n\t\trc = ocfs2_block_check_validate(data, sb->s_blocksize, bc,\n\t\t\t\t\t\t&osb->osb_ecc_stats);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"blockcheck.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/bitops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/crc32.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_block_check_validate",
          "args": [
            "data",
            "sb->s_blocksize",
            "bc",
            "&osb->osb_ecc_stats"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_block_check_validate_bhs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
          "lines": "527-598",
          "snippet": "int ocfs2_block_check_validate_bhs(struct buffer_head **bhs, int nr,\n\t\t\t\t   struct ocfs2_block_check *bc,\n\t\t\t\t   struct ocfs2_blockcheck_stats *stats)\n{\n\tint i, rc = 0;\n\tu32 bc_crc32e;\n\tu16 bc_ecc;\n\tu32 crc, ecc, fix;\n\n\tBUG_ON(nr < 0);\n\n\tif (!nr)\n\t\treturn 0;\n\n\tocfs2_blockcheck_inc_check(stats);\n\n\tbc_crc32e = le32_to_cpu(bc->bc_crc32e);\n\tbc_ecc = le16_to_cpu(bc->bc_ecc);\n\n\tmemset(bc, 0, sizeof(struct ocfs2_block_check));\n\n\t/* Fast path - if the crc32 validates, we're good to go */\n\tfor (i = 0, crc = ~0; i < nr; i++)\n\t\tcrc = crc32_le(crc, bhs[i]->b_data, bhs[i]->b_size);\n\tif (crc == bc_crc32e)\n\t\tgoto out;\n\n\tocfs2_blockcheck_inc_failure(stats);\n\tmlog(ML_ERROR,\n\t     \"CRC32 failed: stored: %u, computed %u.  Applying ECC.\\n\",\n\t     (unsigned int)bc_crc32e, (unsigned int)crc);\n\n\t/* Ok, try ECC fixups */\n\tfor (i = 0, ecc = 0; i < nr; i++) {\n\t\t/*\n\t\t * The number of bits in a buffer is obviously b_size*8.\n\t\t * The offset of this buffer is b_size*i, so the bit offset\n\t\t * of this buffer is b_size*8*i.\n\t\t */\n\t\tecc = (u16)ocfs2_hamming_encode(ecc, bhs[i]->b_data,\n\t\t\t\t\t\tbhs[i]->b_size * 8,\n\t\t\t\t\t\tbhs[i]->b_size * 8 * i);\n\t}\n\tfix = ecc ^ bc_ecc;\n\tfor (i = 0; i < nr; i++) {\n\t\t/*\n\t\t * Try the fix against each buffer.  It will only affect\n\t\t * one of them.\n\t\t */\n\t\tocfs2_hamming_fix(bhs[i]->b_data, bhs[i]->b_size * 8,\n\t\t\t\t  bhs[i]->b_size * 8 * i, fix);\n\t}\n\n\t/* And check the crc32 again */\n\tfor (i = 0, crc = ~0; i < nr; i++)\n\t\tcrc = crc32_le(crc, bhs[i]->b_data, bhs[i]->b_size);\n\tif (crc == bc_crc32e) {\n\t\tocfs2_blockcheck_inc_recover(stats);\n\t\tgoto out;\n\t}\n\n\tmlog(ML_ERROR, \"Fixed CRC32 failed: stored: %u, computed %u\\n\",\n\t     (unsigned int)bc_crc32e, (unsigned int)crc);\n\n\trc = -EIO;\n\nout:\n\tbc->bc_crc32e = cpu_to_le32(bc_crc32e);\n\tbc->bc_ecc = cpu_to_le16(bc_ecc);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"blockcheck.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nint ocfs2_block_check_validate_bhs(struct buffer_head **bhs, int nr,\n\t\t\t\t   struct ocfs2_block_check *bc,\n\t\t\t\t   struct ocfs2_blockcheck_stats *stats)\n{\n\tint i, rc = 0;\n\tu32 bc_crc32e;\n\tu16 bc_ecc;\n\tu32 crc, ecc, fix;\n\n\tBUG_ON(nr < 0);\n\n\tif (!nr)\n\t\treturn 0;\n\n\tocfs2_blockcheck_inc_check(stats);\n\n\tbc_crc32e = le32_to_cpu(bc->bc_crc32e);\n\tbc_ecc = le16_to_cpu(bc->bc_ecc);\n\n\tmemset(bc, 0, sizeof(struct ocfs2_block_check));\n\n\t/* Fast path - if the crc32 validates, we're good to go */\n\tfor (i = 0, crc = ~0; i < nr; i++)\n\t\tcrc = crc32_le(crc, bhs[i]->b_data, bhs[i]->b_size);\n\tif (crc == bc_crc32e)\n\t\tgoto out;\n\n\tocfs2_blockcheck_inc_failure(stats);\n\tmlog(ML_ERROR,\n\t     \"CRC32 failed: stored: %u, computed %u.  Applying ECC.\\n\",\n\t     (unsigned int)bc_crc32e, (unsigned int)crc);\n\n\t/* Ok, try ECC fixups */\n\tfor (i = 0, ecc = 0; i < nr; i++) {\n\t\t/*\n\t\t * The number of bits in a buffer is obviously b_size*8.\n\t\t * The offset of this buffer is b_size*i, so the bit offset\n\t\t * of this buffer is b_size*8*i.\n\t\t */\n\t\tecc = (u16)ocfs2_hamming_encode(ecc, bhs[i]->b_data,\n\t\t\t\t\t\tbhs[i]->b_size * 8,\n\t\t\t\t\t\tbhs[i]->b_size * 8 * i);\n\t}\n\tfix = ecc ^ bc_ecc;\n\tfor (i = 0; i < nr; i++) {\n\t\t/*\n\t\t * Try the fix against each buffer.  It will only affect\n\t\t * one of them.\n\t\t */\n\t\tocfs2_hamming_fix(bhs[i]->b_data, bhs[i]->b_size * 8,\n\t\t\t\t  bhs[i]->b_size * 8 * i, fix);\n\t}\n\n\t/* And check the crc32 again */\n\tfor (i = 0, crc = ~0; i < nr; i++)\n\t\tcrc = crc32_le(crc, bhs[i]->b_data, bhs[i]->b_size);\n\tif (crc == bc_crc32e) {\n\t\tocfs2_blockcheck_inc_recover(stats);\n\t\tgoto out;\n\t}\n\n\tmlog(ML_ERROR, \"Fixed CRC32 failed: stored: %u, computed %u\\n\",\n\t     (unsigned int)bc_crc32e, (unsigned int)crc);\n\n\trc = -EIO;\n\nout:\n\tbc->bc_crc32e = cpu_to_le32(bc_crc32e);\n\tbc->bc_ecc = cpu_to_le16(bc_ecc);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_meta_ecc",
          "args": [
            "osb"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_meta_ecc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "525-530",
          "snippet": "static inline int ocfs2_meta_ecc(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_META_ECC)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_meta_ecc(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_META_ECC)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nint ocfs2_validate_meta_ecc(struct super_block *sb, void *data,\n\t\t\t    struct ocfs2_block_check *bc)\n{\n\tint rc = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tif (ocfs2_meta_ecc(osb))\n\t\trc = ocfs2_block_check_validate(data, sb->s_blocksize, bc,\n\t\t\t\t\t\t&osb->osb_ecc_stats);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "ocfs2_compute_meta_ecc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
    "lines": "606-611",
    "snippet": "void ocfs2_compute_meta_ecc(struct super_block *sb, void *data,\n\t\t\t    struct ocfs2_block_check *bc)\n{\n\tif (ocfs2_meta_ecc(OCFS2_SB(sb)))\n\t\tocfs2_block_check_compute(data, sb->s_blocksize, bc);\n}",
    "includes": [
      "#include \"blockcheck.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/bitops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/crc32.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_block_check_compute",
          "args": [
            "data",
            "sb->s_blocksize",
            "bc"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_block_check_compute_bhs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
          "lines": "483-516",
          "snippet": "void ocfs2_block_check_compute_bhs(struct buffer_head **bhs, int nr,\n\t\t\t\t   struct ocfs2_block_check *bc)\n{\n\tint i;\n\tu32 crc, ecc;\n\n\tBUG_ON(nr < 0);\n\n\tif (!nr)\n\t\treturn;\n\n\tmemset(bc, 0, sizeof(struct ocfs2_block_check));\n\n\tfor (i = 0, crc = ~0, ecc = 0; i < nr; i++) {\n\t\tcrc = crc32_le(crc, bhs[i]->b_data, bhs[i]->b_size);\n\t\t/*\n\t\t * The number of bits in a buffer is obviously b_size*8.\n\t\t * The offset of this buffer is b_size*i, so the bit offset\n\t\t * of this buffer is b_size*8*i.\n\t\t */\n\t\tecc = (u16)ocfs2_hamming_encode(ecc, bhs[i]->b_data,\n\t\t\t\t\t\tbhs[i]->b_size * 8,\n\t\t\t\t\t\tbhs[i]->b_size * 8 * i);\n\t}\n\n\t/*\n\t * No ecc'd ocfs2 structure is larger than 4K, so ecc will be no\n\t * larger than 16 bits.\n\t */\n\tBUG_ON(ecc > USHRT_MAX);\n\n\tbc->bc_crc32e = cpu_to_le32(crc);\n\tbc->bc_ecc = cpu_to_le16((u16)ecc);\n}",
          "includes": [
            "#include \"blockcheck.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid ocfs2_block_check_compute_bhs(struct buffer_head **bhs, int nr,\n\t\t\t\t   struct ocfs2_block_check *bc)\n{\n\tint i;\n\tu32 crc, ecc;\n\n\tBUG_ON(nr < 0);\n\n\tif (!nr)\n\t\treturn;\n\n\tmemset(bc, 0, sizeof(struct ocfs2_block_check));\n\n\tfor (i = 0, crc = ~0, ecc = 0; i < nr; i++) {\n\t\tcrc = crc32_le(crc, bhs[i]->b_data, bhs[i]->b_size);\n\t\t/*\n\t\t * The number of bits in a buffer is obviously b_size*8.\n\t\t * The offset of this buffer is b_size*i, so the bit offset\n\t\t * of this buffer is b_size*8*i.\n\t\t */\n\t\tecc = (u16)ocfs2_hamming_encode(ecc, bhs[i]->b_data,\n\t\t\t\t\t\tbhs[i]->b_size * 8,\n\t\t\t\t\t\tbhs[i]->b_size * 8 * i);\n\t}\n\n\t/*\n\t * No ecc'd ocfs2 structure is larger than 4K, so ecc will be no\n\t * larger than 16 bits.\n\t */\n\tBUG_ON(ecc > USHRT_MAX);\n\n\tbc->bc_crc32e = cpu_to_le32(crc);\n\tbc->bc_ecc = cpu_to_le16((u16)ecc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_meta_ecc",
          "args": [
            "OCFS2_SB(sb)"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_meta_ecc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "525-530",
          "snippet": "static inline int ocfs2_meta_ecc(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_META_ECC)\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_meta_ecc(struct ocfs2_super *osb)\n{\n\tif (osb->s_feature_incompat & OCFS2_FEATURE_INCOMPAT_META_ECC)\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid ocfs2_compute_meta_ecc(struct super_block *sb, void *data,\n\t\t\t    struct ocfs2_block_check *bc)\n{\n\tif (ocfs2_meta_ecc(OCFS2_SB(sb)))\n\t\tocfs2_block_check_compute(data, sb->s_blocksize, bc);\n}"
  },
  {
    "function_name": "ocfs2_block_check_validate_bhs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
    "lines": "527-598",
    "snippet": "int ocfs2_block_check_validate_bhs(struct buffer_head **bhs, int nr,\n\t\t\t\t   struct ocfs2_block_check *bc,\n\t\t\t\t   struct ocfs2_blockcheck_stats *stats)\n{\n\tint i, rc = 0;\n\tu32 bc_crc32e;\n\tu16 bc_ecc;\n\tu32 crc, ecc, fix;\n\n\tBUG_ON(nr < 0);\n\n\tif (!nr)\n\t\treturn 0;\n\n\tocfs2_blockcheck_inc_check(stats);\n\n\tbc_crc32e = le32_to_cpu(bc->bc_crc32e);\n\tbc_ecc = le16_to_cpu(bc->bc_ecc);\n\n\tmemset(bc, 0, sizeof(struct ocfs2_block_check));\n\n\t/* Fast path - if the crc32 validates, we're good to go */\n\tfor (i = 0, crc = ~0; i < nr; i++)\n\t\tcrc = crc32_le(crc, bhs[i]->b_data, bhs[i]->b_size);\n\tif (crc == bc_crc32e)\n\t\tgoto out;\n\n\tocfs2_blockcheck_inc_failure(stats);\n\tmlog(ML_ERROR,\n\t     \"CRC32 failed: stored: %u, computed %u.  Applying ECC.\\n\",\n\t     (unsigned int)bc_crc32e, (unsigned int)crc);\n\n\t/* Ok, try ECC fixups */\n\tfor (i = 0, ecc = 0; i < nr; i++) {\n\t\t/*\n\t\t * The number of bits in a buffer is obviously b_size*8.\n\t\t * The offset of this buffer is b_size*i, so the bit offset\n\t\t * of this buffer is b_size*8*i.\n\t\t */\n\t\tecc = (u16)ocfs2_hamming_encode(ecc, bhs[i]->b_data,\n\t\t\t\t\t\tbhs[i]->b_size * 8,\n\t\t\t\t\t\tbhs[i]->b_size * 8 * i);\n\t}\n\tfix = ecc ^ bc_ecc;\n\tfor (i = 0; i < nr; i++) {\n\t\t/*\n\t\t * Try the fix against each buffer.  It will only affect\n\t\t * one of them.\n\t\t */\n\t\tocfs2_hamming_fix(bhs[i]->b_data, bhs[i]->b_size * 8,\n\t\t\t\t  bhs[i]->b_size * 8 * i, fix);\n\t}\n\n\t/* And check the crc32 again */\n\tfor (i = 0, crc = ~0; i < nr; i++)\n\t\tcrc = crc32_le(crc, bhs[i]->b_data, bhs[i]->b_size);\n\tif (crc == bc_crc32e) {\n\t\tocfs2_blockcheck_inc_recover(stats);\n\t\tgoto out;\n\t}\n\n\tmlog(ML_ERROR, \"Fixed CRC32 failed: stored: %u, computed %u\\n\",\n\t     (unsigned int)bc_crc32e, (unsigned int)crc);\n\n\trc = -EIO;\n\nout:\n\tbc->bc_crc32e = cpu_to_le32(bc_crc32e);\n\tbc->bc_ecc = cpu_to_le16(bc_ecc);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"blockcheck.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/bitops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/crc32.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "bc_ecc"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "bc_crc32e"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Fixed CRC32 failed: stored: %u, computed %u\\n\"",
            "(unsigned int)bc_crc32e",
            "(unsigned int)crc"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_blockcheck_inc_recover",
          "args": [
            "stats"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_blockcheck_inc_recover",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
          "lines": "355-369",
          "snippet": "static void ocfs2_blockcheck_inc_recover(struct ocfs2_blockcheck_stats *stats)\n{\n\tu64 new_count;\n\n\tif (!stats)\n\t\treturn;\n\n\tspin_lock(&stats->b_lock);\n\tstats->b_recover_count++;\n\tnew_count = stats->b_recover_count;\n\tspin_unlock(&stats->b_lock);\n\n\tif (!new_count)\n\t\tmlog(ML_NOTICE, \"ECC recovery count has wrapped\\n\");\n}",
          "includes": [
            "#include \"blockcheck.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic void ocfs2_blockcheck_inc_recover(struct ocfs2_blockcheck_stats *stats)\n{\n\tu64 new_count;\n\n\tif (!stats)\n\t\treturn;\n\n\tspin_lock(&stats->b_lock);\n\tstats->b_recover_count++;\n\tnew_count = stats->b_recover_count;\n\tspin_unlock(&stats->b_lock);\n\n\tif (!new_count)\n\t\tmlog(ML_NOTICE, \"ECC recovery count has wrapped\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "crc32_le",
          "args": [
            "crc",
            "bhs[i]->b_data",
            "bhs[i]->b_size"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_hamming_fix",
          "args": [
            "bhs[i]->b_data",
            "bhs[i]->b_size * 8",
            "bhs[i]->b_size * 8 * i",
            "fix"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_hamming_fix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
          "lines": "166-220",
          "snippet": "void ocfs2_hamming_fix(void *data, unsigned int d, unsigned int nr,\n\t\t       unsigned int fix)\n{\n\tunsigned int i, b;\n\n\tBUG_ON(!d);\n\n\t/*\n\t * If the bit to fix has an hweight of 1, it's a parity bit.  One\n\t * busted parity bit is its own error.  Nothing to do here.\n\t */\n\tif (hweight32(fix) == 1)\n\t\treturn;\n\n\t/*\n\t * nr + d is the bit right past the data hunk we're looking at.\n\t * If fix after that, nothing to do\n\t */\n\tif (fix >= calc_code_bit(nr + d, NULL))\n\t\treturn;\n\n\t/*\n\t * nr is the offset in the data hunk we're starting at.  Let's\n\t * start b at the offset in the code buffer.  See hamming_encode()\n\t * for a more detailed description of 'b'.\n\t */\n\tb = calc_code_bit(nr, NULL);\n\t/* If the fix is before this hunk, nothing to do */\n\tif (fix < b)\n\t\treturn;\n\n\tfor (i = 0; i < d; i++, b++)\n\t{\n\t\t/* Skip past parity bits */\n\t\twhile (hweight32(b) == 1)\n\t\t\tb++;\n\n\t\t/*\n\t\t * i is the offset in this data hunk.\n\t\t * nr + i is the offset in the total data buffer.\n\t\t * b is the offset in the total code buffer.\n\t\t *\n\t\t * Thus, when b == fix, bit i in the current hunk needs\n\t\t * fixing.\n\t\t */\n\t\tif (b == fix)\n\t\t{\n\t\t\tif (ocfs2_test_bit(i, data))\n\t\t\t\tocfs2_clear_bit(i, data);\n\t\t\telse\n\t\t\t\tocfs2_set_bit(i, data);\n\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"blockcheck.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid ocfs2_hamming_fix(void *data, unsigned int d, unsigned int nr,\n\t\t       unsigned int fix)\n{\n\tunsigned int i, b;\n\n\tBUG_ON(!d);\n\n\t/*\n\t * If the bit to fix has an hweight of 1, it's a parity bit.  One\n\t * busted parity bit is its own error.  Nothing to do here.\n\t */\n\tif (hweight32(fix) == 1)\n\t\treturn;\n\n\t/*\n\t * nr + d is the bit right past the data hunk we're looking at.\n\t * If fix after that, nothing to do\n\t */\n\tif (fix >= calc_code_bit(nr + d, NULL))\n\t\treturn;\n\n\t/*\n\t * nr is the offset in the data hunk we're starting at.  Let's\n\t * start b at the offset in the code buffer.  See hamming_encode()\n\t * for a more detailed description of 'b'.\n\t */\n\tb = calc_code_bit(nr, NULL);\n\t/* If the fix is before this hunk, nothing to do */\n\tif (fix < b)\n\t\treturn;\n\n\tfor (i = 0; i < d; i++, b++)\n\t{\n\t\t/* Skip past parity bits */\n\t\twhile (hweight32(b) == 1)\n\t\t\tb++;\n\n\t\t/*\n\t\t * i is the offset in this data hunk.\n\t\t * nr + i is the offset in the total data buffer.\n\t\t * b is the offset in the total code buffer.\n\t\t *\n\t\t * Thus, when b == fix, bit i in the current hunk needs\n\t\t * fixing.\n\t\t */\n\t\tif (b == fix)\n\t\t{\n\t\t\tif (ocfs2_test_bit(i, data))\n\t\t\t\tocfs2_clear_bit(i, data);\n\t\t\telse\n\t\t\t\tocfs2_set_bit(i, data);\n\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_hamming_encode",
          "args": [
            "ecc",
            "bhs[i]->b_data",
            "bhs[i]->b_size * 8",
            "bhs[i]->b_size * 8 * i"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_hamming_encode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
          "lines": "107-152",
          "snippet": "u32 ocfs2_hamming_encode(u32 parity, void *data, unsigned int d, unsigned int nr)\n{\n\tunsigned int i, b, p = 0;\n\n\tBUG_ON(!d);\n\n\t/*\n\t * b is the hamming code bit number.  Hamming code specifies a\n\t * 1-based array, but C uses 0-based.  So 'i' is for C, and 'b' is\n\t * for the algorithm.\n\t *\n\t * The i++ in the for loop is so that the start offset passed\n\t * to ocfs2_find_next_bit_set() is one greater than the previously\n\t * found bit.\n\t */\n\tfor (i = 0; (i = ocfs2_find_next_bit(data, d, i)) < d; i++)\n\t{\n\t\t/*\n\t\t * i is the offset in this hunk, nr + i is the total bit\n\t\t * offset.\n\t\t */\n\t\tb = calc_code_bit(nr + i, &p);\n\n\t\t/*\n\t\t * Data bits in the resultant code are checked by\n\t\t * parity bits that are part of the bit number\n\t\t * representation.  Huh?\n\t\t *\n\t\t * <wikipedia href=\"http://en.wikipedia.org/wiki/Hamming_code\">\n\t\t * In other words, the parity bit at position 2^k\n\t\t * checks bits in positions having bit k set in\n\t\t * their binary representation.  Conversely, for\n\t\t * instance, bit 13, i.e. 1101(2), is checked by\n\t\t * bits 1000(2) = 8, 0100(2)=4 and 0001(2) = 1.\n\t\t * </wikipedia>\n\t\t *\n\t\t * Note that 'k' is the _code_ bit number.  'b' in\n\t\t * our loop.\n\t\t */\n\t\tparity ^= b;\n\t}\n\n\t/* While the data buffer was treated as little endian, the\n\t * return value is in host endian. */\n\treturn parity;\n}",
          "includes": [
            "#include \"blockcheck.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nu32 ocfs2_hamming_encode(u32 parity, void *data, unsigned int d, unsigned int nr)\n{\n\tunsigned int i, b, p = 0;\n\n\tBUG_ON(!d);\n\n\t/*\n\t * b is the hamming code bit number.  Hamming code specifies a\n\t * 1-based array, but C uses 0-based.  So 'i' is for C, and 'b' is\n\t * for the algorithm.\n\t *\n\t * The i++ in the for loop is so that the start offset passed\n\t * to ocfs2_find_next_bit_set() is one greater than the previously\n\t * found bit.\n\t */\n\tfor (i = 0; (i = ocfs2_find_next_bit(data, d, i)) < d; i++)\n\t{\n\t\t/*\n\t\t * i is the offset in this hunk, nr + i is the total bit\n\t\t * offset.\n\t\t */\n\t\tb = calc_code_bit(nr + i, &p);\n\n\t\t/*\n\t\t * Data bits in the resultant code are checked by\n\t\t * parity bits that are part of the bit number\n\t\t * representation.  Huh?\n\t\t *\n\t\t * <wikipedia href=\"http://en.wikipedia.org/wiki/Hamming_code\">\n\t\t * In other words, the parity bit at position 2^k\n\t\t * checks bits in positions having bit k set in\n\t\t * their binary representation.  Conversely, for\n\t\t * instance, bit 13, i.e. 1101(2), is checked by\n\t\t * bits 1000(2) = 8, 0100(2)=4 and 0001(2) = 1.\n\t\t * </wikipedia>\n\t\t *\n\t\t * Note that 'k' is the _code_ bit number.  'b' in\n\t\t * our loop.\n\t\t */\n\t\tparity ^= b;\n\t}\n\n\t/* While the data buffer was treated as little endian, the\n\t * return value is in host endian. */\n\treturn parity;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_blockcheck_inc_failure",
          "args": [
            "stats"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_blockcheck_inc_failure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
          "lines": "339-353",
          "snippet": "static void ocfs2_blockcheck_inc_failure(struct ocfs2_blockcheck_stats *stats)\n{\n\tu64 new_count;\n\n\tif (!stats)\n\t\treturn;\n\n\tspin_lock(&stats->b_lock);\n\tstats->b_failure_count++;\n\tnew_count = stats->b_failure_count;\n\tspin_unlock(&stats->b_lock);\n\n\tif (!new_count)\n\t\tmlog(ML_NOTICE, \"Checksum failure count has wrapped\\n\");\n}",
          "includes": [
            "#include \"blockcheck.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic void ocfs2_blockcheck_inc_failure(struct ocfs2_blockcheck_stats *stats)\n{\n\tu64 new_count;\n\n\tif (!stats)\n\t\treturn;\n\n\tspin_lock(&stats->b_lock);\n\tstats->b_failure_count++;\n\tnew_count = stats->b_failure_count;\n\tspin_unlock(&stats->b_lock);\n\n\tif (!new_count)\n\t\tmlog(ML_NOTICE, \"Checksum failure count has wrapped\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "crc32_le",
          "args": [
            "crc",
            "bhs[i]->b_data",
            "bhs[i]->b_size"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bc",
            "0",
            "sizeof(struct ocfs2_block_check)"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "bc->bc_ecc"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "bc->bc_crc32e"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_blockcheck_inc_check",
          "args": [
            "stats"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_blockcheck_inc_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
          "lines": "323-337",
          "snippet": "static void ocfs2_blockcheck_inc_check(struct ocfs2_blockcheck_stats *stats)\n{\n\tu64 new_count;\n\n\tif (!stats)\n\t\treturn;\n\n\tspin_lock(&stats->b_lock);\n\tstats->b_check_count++;\n\tnew_count = stats->b_check_count;\n\tspin_unlock(&stats->b_lock);\n\n\tif (!new_count)\n\t\tmlog(ML_NOTICE, \"Block check count has wrapped\\n\");\n}",
          "includes": [
            "#include \"blockcheck.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic void ocfs2_blockcheck_inc_check(struct ocfs2_blockcheck_stats *stats)\n{\n\tu64 new_count;\n\n\tif (!stats)\n\t\treturn;\n\n\tspin_lock(&stats->b_lock);\n\tstats->b_check_count++;\n\tnew_count = stats->b_check_count;\n\tspin_unlock(&stats->b_lock);\n\n\tif (!new_count)\n\t\tmlog(ML_NOTICE, \"Block check count has wrapped\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "nr < 0"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nint ocfs2_block_check_validate_bhs(struct buffer_head **bhs, int nr,\n\t\t\t\t   struct ocfs2_block_check *bc,\n\t\t\t\t   struct ocfs2_blockcheck_stats *stats)\n{\n\tint i, rc = 0;\n\tu32 bc_crc32e;\n\tu16 bc_ecc;\n\tu32 crc, ecc, fix;\n\n\tBUG_ON(nr < 0);\n\n\tif (!nr)\n\t\treturn 0;\n\n\tocfs2_blockcheck_inc_check(stats);\n\n\tbc_crc32e = le32_to_cpu(bc->bc_crc32e);\n\tbc_ecc = le16_to_cpu(bc->bc_ecc);\n\n\tmemset(bc, 0, sizeof(struct ocfs2_block_check));\n\n\t/* Fast path - if the crc32 validates, we're good to go */\n\tfor (i = 0, crc = ~0; i < nr; i++)\n\t\tcrc = crc32_le(crc, bhs[i]->b_data, bhs[i]->b_size);\n\tif (crc == bc_crc32e)\n\t\tgoto out;\n\n\tocfs2_blockcheck_inc_failure(stats);\n\tmlog(ML_ERROR,\n\t     \"CRC32 failed: stored: %u, computed %u.  Applying ECC.\\n\",\n\t     (unsigned int)bc_crc32e, (unsigned int)crc);\n\n\t/* Ok, try ECC fixups */\n\tfor (i = 0, ecc = 0; i < nr; i++) {\n\t\t/*\n\t\t * The number of bits in a buffer is obviously b_size*8.\n\t\t * The offset of this buffer is b_size*i, so the bit offset\n\t\t * of this buffer is b_size*8*i.\n\t\t */\n\t\tecc = (u16)ocfs2_hamming_encode(ecc, bhs[i]->b_data,\n\t\t\t\t\t\tbhs[i]->b_size * 8,\n\t\t\t\t\t\tbhs[i]->b_size * 8 * i);\n\t}\n\tfix = ecc ^ bc_ecc;\n\tfor (i = 0; i < nr; i++) {\n\t\t/*\n\t\t * Try the fix against each buffer.  It will only affect\n\t\t * one of them.\n\t\t */\n\t\tocfs2_hamming_fix(bhs[i]->b_data, bhs[i]->b_size * 8,\n\t\t\t\t  bhs[i]->b_size * 8 * i, fix);\n\t}\n\n\t/* And check the crc32 again */\n\tfor (i = 0, crc = ~0; i < nr; i++)\n\t\tcrc = crc32_le(crc, bhs[i]->b_data, bhs[i]->b_size);\n\tif (crc == bc_crc32e) {\n\t\tocfs2_blockcheck_inc_recover(stats);\n\t\tgoto out;\n\t}\n\n\tmlog(ML_ERROR, \"Fixed CRC32 failed: stored: %u, computed %u\\n\",\n\t     (unsigned int)bc_crc32e, (unsigned int)crc);\n\n\trc = -EIO;\n\nout:\n\tbc->bc_crc32e = cpu_to_le32(bc_crc32e);\n\tbc->bc_ecc = cpu_to_le16(bc_ecc);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "ocfs2_block_check_compute_bhs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
    "lines": "483-516",
    "snippet": "void ocfs2_block_check_compute_bhs(struct buffer_head **bhs, int nr,\n\t\t\t\t   struct ocfs2_block_check *bc)\n{\n\tint i;\n\tu32 crc, ecc;\n\n\tBUG_ON(nr < 0);\n\n\tif (!nr)\n\t\treturn;\n\n\tmemset(bc, 0, sizeof(struct ocfs2_block_check));\n\n\tfor (i = 0, crc = ~0, ecc = 0; i < nr; i++) {\n\t\tcrc = crc32_le(crc, bhs[i]->b_data, bhs[i]->b_size);\n\t\t/*\n\t\t * The number of bits in a buffer is obviously b_size*8.\n\t\t * The offset of this buffer is b_size*i, so the bit offset\n\t\t * of this buffer is b_size*8*i.\n\t\t */\n\t\tecc = (u16)ocfs2_hamming_encode(ecc, bhs[i]->b_data,\n\t\t\t\t\t\tbhs[i]->b_size * 8,\n\t\t\t\t\t\tbhs[i]->b_size * 8 * i);\n\t}\n\n\t/*\n\t * No ecc'd ocfs2 structure is larger than 4K, so ecc will be no\n\t * larger than 16 bits.\n\t */\n\tBUG_ON(ecc > USHRT_MAX);\n\n\tbc->bc_crc32e = cpu_to_le32(crc);\n\tbc->bc_ecc = cpu_to_le16((u16)ecc);\n}",
    "includes": [
      "#include \"blockcheck.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/bitops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/crc32.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "(u16)ecc"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "crc"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ecc > USHRT_MAX"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_hamming_encode",
          "args": [
            "ecc",
            "bhs[i]->b_data",
            "bhs[i]->b_size * 8",
            "bhs[i]->b_size * 8 * i"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_hamming_encode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
          "lines": "107-152",
          "snippet": "u32 ocfs2_hamming_encode(u32 parity, void *data, unsigned int d, unsigned int nr)\n{\n\tunsigned int i, b, p = 0;\n\n\tBUG_ON(!d);\n\n\t/*\n\t * b is the hamming code bit number.  Hamming code specifies a\n\t * 1-based array, but C uses 0-based.  So 'i' is for C, and 'b' is\n\t * for the algorithm.\n\t *\n\t * The i++ in the for loop is so that the start offset passed\n\t * to ocfs2_find_next_bit_set() is one greater than the previously\n\t * found bit.\n\t */\n\tfor (i = 0; (i = ocfs2_find_next_bit(data, d, i)) < d; i++)\n\t{\n\t\t/*\n\t\t * i is the offset in this hunk, nr + i is the total bit\n\t\t * offset.\n\t\t */\n\t\tb = calc_code_bit(nr + i, &p);\n\n\t\t/*\n\t\t * Data bits in the resultant code are checked by\n\t\t * parity bits that are part of the bit number\n\t\t * representation.  Huh?\n\t\t *\n\t\t * <wikipedia href=\"http://en.wikipedia.org/wiki/Hamming_code\">\n\t\t * In other words, the parity bit at position 2^k\n\t\t * checks bits in positions having bit k set in\n\t\t * their binary representation.  Conversely, for\n\t\t * instance, bit 13, i.e. 1101(2), is checked by\n\t\t * bits 1000(2) = 8, 0100(2)=4 and 0001(2) = 1.\n\t\t * </wikipedia>\n\t\t *\n\t\t * Note that 'k' is the _code_ bit number.  'b' in\n\t\t * our loop.\n\t\t */\n\t\tparity ^= b;\n\t}\n\n\t/* While the data buffer was treated as little endian, the\n\t * return value is in host endian. */\n\treturn parity;\n}",
          "includes": [
            "#include \"blockcheck.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nu32 ocfs2_hamming_encode(u32 parity, void *data, unsigned int d, unsigned int nr)\n{\n\tunsigned int i, b, p = 0;\n\n\tBUG_ON(!d);\n\n\t/*\n\t * b is the hamming code bit number.  Hamming code specifies a\n\t * 1-based array, but C uses 0-based.  So 'i' is for C, and 'b' is\n\t * for the algorithm.\n\t *\n\t * The i++ in the for loop is so that the start offset passed\n\t * to ocfs2_find_next_bit_set() is one greater than the previously\n\t * found bit.\n\t */\n\tfor (i = 0; (i = ocfs2_find_next_bit(data, d, i)) < d; i++)\n\t{\n\t\t/*\n\t\t * i is the offset in this hunk, nr + i is the total bit\n\t\t * offset.\n\t\t */\n\t\tb = calc_code_bit(nr + i, &p);\n\n\t\t/*\n\t\t * Data bits in the resultant code are checked by\n\t\t * parity bits that are part of the bit number\n\t\t * representation.  Huh?\n\t\t *\n\t\t * <wikipedia href=\"http://en.wikipedia.org/wiki/Hamming_code\">\n\t\t * In other words, the parity bit at position 2^k\n\t\t * checks bits in positions having bit k set in\n\t\t * their binary representation.  Conversely, for\n\t\t * instance, bit 13, i.e. 1101(2), is checked by\n\t\t * bits 1000(2) = 8, 0100(2)=4 and 0001(2) = 1.\n\t\t * </wikipedia>\n\t\t *\n\t\t * Note that 'k' is the _code_ bit number.  'b' in\n\t\t * our loop.\n\t\t */\n\t\tparity ^= b;\n\t}\n\n\t/* While the data buffer was treated as little endian, the\n\t * return value is in host endian. */\n\treturn parity;\n}"
        }
      },
      {
        "call_info": {
          "callee": "crc32_le",
          "args": [
            "crc",
            "bhs[i]->b_data",
            "bhs[i]->b_size"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bc",
            "0",
            "sizeof(struct ocfs2_block_check)"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "nr < 0"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid ocfs2_block_check_compute_bhs(struct buffer_head **bhs, int nr,\n\t\t\t\t   struct ocfs2_block_check *bc)\n{\n\tint i;\n\tu32 crc, ecc;\n\n\tBUG_ON(nr < 0);\n\n\tif (!nr)\n\t\treturn;\n\n\tmemset(bc, 0, sizeof(struct ocfs2_block_check));\n\n\tfor (i = 0, crc = ~0, ecc = 0; i < nr; i++) {\n\t\tcrc = crc32_le(crc, bhs[i]->b_data, bhs[i]->b_size);\n\t\t/*\n\t\t * The number of bits in a buffer is obviously b_size*8.\n\t\t * The offset of this buffer is b_size*i, so the bit offset\n\t\t * of this buffer is b_size*8*i.\n\t\t */\n\t\tecc = (u16)ocfs2_hamming_encode(ecc, bhs[i]->b_data,\n\t\t\t\t\t\tbhs[i]->b_size * 8,\n\t\t\t\t\t\tbhs[i]->b_size * 8 * i);\n\t}\n\n\t/*\n\t * No ecc'd ocfs2 structure is larger than 4K, so ecc will be no\n\t * larger than 16 bits.\n\t */\n\tBUG_ON(ecc > USHRT_MAX);\n\n\tbc->bc_crc32e = cpu_to_le32(crc);\n\tbc->bc_ecc = cpu_to_le16((u16)ecc);\n}"
  },
  {
    "function_name": "ocfs2_block_check_validate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
    "lines": "420-467",
    "snippet": "int ocfs2_block_check_validate(void *data, size_t blocksize,\n\t\t\t       struct ocfs2_block_check *bc,\n\t\t\t       struct ocfs2_blockcheck_stats *stats)\n{\n\tint rc = 0;\n\tu32 bc_crc32e;\n\tu16 bc_ecc;\n\tu32 crc, ecc;\n\n\tocfs2_blockcheck_inc_check(stats);\n\n\tbc_crc32e = le32_to_cpu(bc->bc_crc32e);\n\tbc_ecc = le16_to_cpu(bc->bc_ecc);\n\n\tmemset(bc, 0, sizeof(struct ocfs2_block_check));\n\n\t/* Fast path - if the crc32 validates, we're good to go */\n\tcrc = crc32_le(~0, data, blocksize);\n\tif (crc == bc_crc32e)\n\t\tgoto out;\n\n\tocfs2_blockcheck_inc_failure(stats);\n\tmlog(ML_ERROR,\n\t     \"CRC32 failed: stored: 0x%x, computed 0x%x. Applying ECC.\\n\",\n\t     (unsigned int)bc_crc32e, (unsigned int)crc);\n\n\t/* Ok, try ECC fixups */\n\tecc = ocfs2_hamming_encode_block(data, blocksize);\n\tocfs2_hamming_fix_block(data, blocksize, ecc ^ bc_ecc);\n\n\t/* And check the crc32 again */\n\tcrc = crc32_le(~0, data, blocksize);\n\tif (crc == bc_crc32e) {\n\t\tocfs2_blockcheck_inc_recover(stats);\n\t\tgoto out;\n\t}\n\n\tmlog(ML_ERROR, \"Fixed CRC32 failed: stored: 0x%x, computed 0x%x\\n\",\n\t     (unsigned int)bc_crc32e, (unsigned int)crc);\n\n\trc = -EIO;\n\nout:\n\tbc->bc_crc32e = cpu_to_le32(bc_crc32e);\n\tbc->bc_ecc = cpu_to_le16(bc_ecc);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"blockcheck.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/bitops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/crc32.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "bc_ecc"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "bc_crc32e"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Fixed CRC32 failed: stored: 0x%x, computed 0x%x\\n\"",
            "(unsigned int)bc_crc32e",
            "(unsigned int)crc"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_blockcheck_inc_recover",
          "args": [
            "stats"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_blockcheck_inc_recover",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
          "lines": "355-369",
          "snippet": "static void ocfs2_blockcheck_inc_recover(struct ocfs2_blockcheck_stats *stats)\n{\n\tu64 new_count;\n\n\tif (!stats)\n\t\treturn;\n\n\tspin_lock(&stats->b_lock);\n\tstats->b_recover_count++;\n\tnew_count = stats->b_recover_count;\n\tspin_unlock(&stats->b_lock);\n\n\tif (!new_count)\n\t\tmlog(ML_NOTICE, \"ECC recovery count has wrapped\\n\");\n}",
          "includes": [
            "#include \"blockcheck.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic void ocfs2_blockcheck_inc_recover(struct ocfs2_blockcheck_stats *stats)\n{\n\tu64 new_count;\n\n\tif (!stats)\n\t\treturn;\n\n\tspin_lock(&stats->b_lock);\n\tstats->b_recover_count++;\n\tnew_count = stats->b_recover_count;\n\tspin_unlock(&stats->b_lock);\n\n\tif (!new_count)\n\t\tmlog(ML_NOTICE, \"ECC recovery count has wrapped\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "crc32_le",
          "args": [
            "~0",
            "data",
            "blocksize"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_hamming_fix_block",
          "args": [
            "data",
            "blocksize",
            "ecc ^ bc_ecc"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_hamming_fix_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
          "lines": "222-226",
          "snippet": "void ocfs2_hamming_fix_block(void *data, unsigned int blocksize,\n\t\t\t     unsigned int fix)\n{\n\tocfs2_hamming_fix(data, blocksize * 8, 0, fix);\n}",
          "includes": [
            "#include \"blockcheck.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid ocfs2_hamming_fix_block(void *data, unsigned int blocksize,\n\t\t\t     unsigned int fix)\n{\n\tocfs2_hamming_fix(data, blocksize * 8, 0, fix);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_hamming_encode_block",
          "args": [
            "data",
            "blocksize"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_hamming_encode_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
          "lines": "154-157",
          "snippet": "u32 ocfs2_hamming_encode_block(void *data, unsigned int blocksize)\n{\n\treturn ocfs2_hamming_encode(0, data, blocksize * 8, 0);\n}",
          "includes": [
            "#include \"blockcheck.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nu32 ocfs2_hamming_encode_block(void *data, unsigned int blocksize)\n{\n\treturn ocfs2_hamming_encode(0, data, blocksize * 8, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_blockcheck_inc_failure",
          "args": [
            "stats"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_blockcheck_inc_failure",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
          "lines": "339-353",
          "snippet": "static void ocfs2_blockcheck_inc_failure(struct ocfs2_blockcheck_stats *stats)\n{\n\tu64 new_count;\n\n\tif (!stats)\n\t\treturn;\n\n\tspin_lock(&stats->b_lock);\n\tstats->b_failure_count++;\n\tnew_count = stats->b_failure_count;\n\tspin_unlock(&stats->b_lock);\n\n\tif (!new_count)\n\t\tmlog(ML_NOTICE, \"Checksum failure count has wrapped\\n\");\n}",
          "includes": [
            "#include \"blockcheck.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic void ocfs2_blockcheck_inc_failure(struct ocfs2_blockcheck_stats *stats)\n{\n\tu64 new_count;\n\n\tif (!stats)\n\t\treturn;\n\n\tspin_lock(&stats->b_lock);\n\tstats->b_failure_count++;\n\tnew_count = stats->b_failure_count;\n\tspin_unlock(&stats->b_lock);\n\n\tif (!new_count)\n\t\tmlog(ML_NOTICE, \"Checksum failure count has wrapped\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "crc32_le",
          "args": [
            "~0",
            "data",
            "blocksize"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bc",
            "0",
            "sizeof(struct ocfs2_block_check)"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "bc->bc_ecc"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "bc->bc_crc32e"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_blockcheck_inc_check",
          "args": [
            "stats"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_blockcheck_inc_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
          "lines": "323-337",
          "snippet": "static void ocfs2_blockcheck_inc_check(struct ocfs2_blockcheck_stats *stats)\n{\n\tu64 new_count;\n\n\tif (!stats)\n\t\treturn;\n\n\tspin_lock(&stats->b_lock);\n\tstats->b_check_count++;\n\tnew_count = stats->b_check_count;\n\tspin_unlock(&stats->b_lock);\n\n\tif (!new_count)\n\t\tmlog(ML_NOTICE, \"Block check count has wrapped\\n\");\n}",
          "includes": [
            "#include \"blockcheck.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic void ocfs2_blockcheck_inc_check(struct ocfs2_blockcheck_stats *stats)\n{\n\tu64 new_count;\n\n\tif (!stats)\n\t\treturn;\n\n\tspin_lock(&stats->b_lock);\n\tstats->b_check_count++;\n\tnew_count = stats->b_check_count;\n\tspin_unlock(&stats->b_lock);\n\n\tif (!new_count)\n\t\tmlog(ML_NOTICE, \"Block check count has wrapped\\n\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nint ocfs2_block_check_validate(void *data, size_t blocksize,\n\t\t\t       struct ocfs2_block_check *bc,\n\t\t\t       struct ocfs2_blockcheck_stats *stats)\n{\n\tint rc = 0;\n\tu32 bc_crc32e;\n\tu16 bc_ecc;\n\tu32 crc, ecc;\n\n\tocfs2_blockcheck_inc_check(stats);\n\n\tbc_crc32e = le32_to_cpu(bc->bc_crc32e);\n\tbc_ecc = le16_to_cpu(bc->bc_ecc);\n\n\tmemset(bc, 0, sizeof(struct ocfs2_block_check));\n\n\t/* Fast path - if the crc32 validates, we're good to go */\n\tcrc = crc32_le(~0, data, blocksize);\n\tif (crc == bc_crc32e)\n\t\tgoto out;\n\n\tocfs2_blockcheck_inc_failure(stats);\n\tmlog(ML_ERROR,\n\t     \"CRC32 failed: stored: 0x%x, computed 0x%x. Applying ECC.\\n\",\n\t     (unsigned int)bc_crc32e, (unsigned int)crc);\n\n\t/* Ok, try ECC fixups */\n\tecc = ocfs2_hamming_encode_block(data, blocksize);\n\tocfs2_hamming_fix_block(data, blocksize, ecc ^ bc_ecc);\n\n\t/* And check the crc32 again */\n\tcrc = crc32_le(~0, data, blocksize);\n\tif (crc == bc_crc32e) {\n\t\tocfs2_blockcheck_inc_recover(stats);\n\t\tgoto out;\n\t}\n\n\tmlog(ML_ERROR, \"Fixed CRC32 failed: stored: 0x%x, computed 0x%x\\n\",\n\t     (unsigned int)bc_crc32e, (unsigned int)crc);\n\n\trc = -EIO;\n\nout:\n\tbc->bc_crc32e = cpu_to_le32(bc_crc32e);\n\tbc->bc_ecc = cpu_to_le16(bc_ecc);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "ocfs2_block_check_compute",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
    "lines": "391-410",
    "snippet": "void ocfs2_block_check_compute(void *data, size_t blocksize,\n\t\t\t       struct ocfs2_block_check *bc)\n{\n\tu32 crc;\n\tu32 ecc;\n\n\tmemset(bc, 0, sizeof(struct ocfs2_block_check));\n\n\tcrc = crc32_le(~0, data, blocksize);\n\tecc = ocfs2_hamming_encode_block(data, blocksize);\n\n\t/*\n\t * No ecc'd ocfs2 structure is larger than 4K, so ecc will be no\n\t * larger than 16 bits.\n\t */\n\tBUG_ON(ecc > USHRT_MAX);\n\n\tbc->bc_crc32e = cpu_to_le32(crc);\n\tbc->bc_ecc = cpu_to_le16((u16)ecc);\n}",
    "includes": [
      "#include \"blockcheck.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/bitops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/crc32.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "(u16)ecc"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "crc"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ecc > USHRT_MAX"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_hamming_encode_block",
          "args": [
            "data",
            "blocksize"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_hamming_encode_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
          "lines": "154-157",
          "snippet": "u32 ocfs2_hamming_encode_block(void *data, unsigned int blocksize)\n{\n\treturn ocfs2_hamming_encode(0, data, blocksize * 8, 0);\n}",
          "includes": [
            "#include \"blockcheck.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nu32 ocfs2_hamming_encode_block(void *data, unsigned int blocksize)\n{\n\treturn ocfs2_hamming_encode(0, data, blocksize * 8, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "crc32_le",
          "args": [
            "~0",
            "data",
            "blocksize"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "bc",
            "0",
            "sizeof(struct ocfs2_block_check)"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid ocfs2_block_check_compute(void *data, size_t blocksize,\n\t\t\t       struct ocfs2_block_check *bc)\n{\n\tu32 crc;\n\tu32 ecc;\n\n\tmemset(bc, 0, sizeof(struct ocfs2_block_check));\n\n\tcrc = crc32_le(~0, data, blocksize);\n\tecc = ocfs2_hamming_encode_block(data, blocksize);\n\n\t/*\n\t * No ecc'd ocfs2 structure is larger than 4K, so ecc will be no\n\t * larger than 16 bits.\n\t */\n\tBUG_ON(ecc > USHRT_MAX);\n\n\tbc->bc_crc32e = cpu_to_le32(crc);\n\tbc->bc_ecc = cpu_to_le16((u16)ecc);\n}"
  },
  {
    "function_name": "ocfs2_blockcheck_inc_recover",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
    "lines": "355-369",
    "snippet": "static void ocfs2_blockcheck_inc_recover(struct ocfs2_blockcheck_stats *stats)\n{\n\tu64 new_count;\n\n\tif (!stats)\n\t\treturn;\n\n\tspin_lock(&stats->b_lock);\n\tstats->b_recover_count++;\n\tnew_count = stats->b_recover_count;\n\tspin_unlock(&stats->b_lock);\n\n\tif (!new_count)\n\t\tmlog(ML_NOTICE, \"ECC recovery count has wrapped\\n\");\n}",
    "includes": [
      "#include \"blockcheck.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/bitops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/crc32.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_NOTICE",
            "\"ECC recovery count has wrapped\\n\""
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&stats->b_lock"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&stats->b_lock"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic void ocfs2_blockcheck_inc_recover(struct ocfs2_blockcheck_stats *stats)\n{\n\tu64 new_count;\n\n\tif (!stats)\n\t\treturn;\n\n\tspin_lock(&stats->b_lock);\n\tstats->b_recover_count++;\n\tnew_count = stats->b_recover_count;\n\tspin_unlock(&stats->b_lock);\n\n\tif (!new_count)\n\t\tmlog(ML_NOTICE, \"ECC recovery count has wrapped\\n\");\n}"
  },
  {
    "function_name": "ocfs2_blockcheck_inc_failure",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
    "lines": "339-353",
    "snippet": "static void ocfs2_blockcheck_inc_failure(struct ocfs2_blockcheck_stats *stats)\n{\n\tu64 new_count;\n\n\tif (!stats)\n\t\treturn;\n\n\tspin_lock(&stats->b_lock);\n\tstats->b_failure_count++;\n\tnew_count = stats->b_failure_count;\n\tspin_unlock(&stats->b_lock);\n\n\tif (!new_count)\n\t\tmlog(ML_NOTICE, \"Checksum failure count has wrapped\\n\");\n}",
    "includes": [
      "#include \"blockcheck.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/bitops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/crc32.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_NOTICE",
            "\"Checksum failure count has wrapped\\n\""
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&stats->b_lock"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&stats->b_lock"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic void ocfs2_blockcheck_inc_failure(struct ocfs2_blockcheck_stats *stats)\n{\n\tu64 new_count;\n\n\tif (!stats)\n\t\treturn;\n\n\tspin_lock(&stats->b_lock);\n\tstats->b_failure_count++;\n\tnew_count = stats->b_failure_count;\n\tspin_unlock(&stats->b_lock);\n\n\tif (!new_count)\n\t\tmlog(ML_NOTICE, \"Checksum failure count has wrapped\\n\");\n}"
  },
  {
    "function_name": "ocfs2_blockcheck_inc_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
    "lines": "323-337",
    "snippet": "static void ocfs2_blockcheck_inc_check(struct ocfs2_blockcheck_stats *stats)\n{\n\tu64 new_count;\n\n\tif (!stats)\n\t\treturn;\n\n\tspin_lock(&stats->b_lock);\n\tstats->b_check_count++;\n\tnew_count = stats->b_check_count;\n\tspin_unlock(&stats->b_lock);\n\n\tif (!new_count)\n\t\tmlog(ML_NOTICE, \"Block check count has wrapped\\n\");\n}",
    "includes": [
      "#include \"blockcheck.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/bitops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/crc32.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_NOTICE",
            "\"Block check count has wrapped\\n\""
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&stats->b_lock"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&stats->b_lock"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic void ocfs2_blockcheck_inc_check(struct ocfs2_blockcheck_stats *stats)\n{\n\tu64 new_count;\n\n\tif (!stats)\n\t\treturn;\n\n\tspin_lock(&stats->b_lock);\n\tstats->b_check_count++;\n\tnew_count = stats->b_check_count;\n\tspin_unlock(&stats->b_lock);\n\n\tif (!new_count)\n\t\tmlog(ML_NOTICE, \"Block check count has wrapped\\n\");\n}"
  },
  {
    "function_name": "ocfs2_blockcheck_stats_debugfs_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
    "lines": "318-321",
    "snippet": "void ocfs2_blockcheck_stats_debugfs_remove(struct ocfs2_blockcheck_stats *stats)\n{\n\tocfs2_blockcheck_debug_remove(stats);\n}",
    "includes": [
      "#include \"blockcheck.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/bitops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/crc32.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_blockcheck_debug_remove",
          "args": [
            "stats"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_blockcheck_debug_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
          "lines": "306-308",
          "snippet": "static inline void ocfs2_blockcheck_debug_remove(struct ocfs2_blockcheck_stats *stats)\n{\n}",
          "includes": [
            "#include \"blockcheck.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic inline void ocfs2_blockcheck_debug_remove(struct ocfs2_blockcheck_stats *stats)\n{\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid ocfs2_blockcheck_stats_debugfs_remove(struct ocfs2_blockcheck_stats *stats)\n{\n\tocfs2_blockcheck_debug_remove(stats);\n}"
  },
  {
    "function_name": "ocfs2_blockcheck_stats_debugfs_install",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
    "lines": "312-316",
    "snippet": "int ocfs2_blockcheck_stats_debugfs_install(struct ocfs2_blockcheck_stats *stats,\n\t\t\t\t\t   struct dentry *parent)\n{\n\treturn ocfs2_blockcheck_debug_install(stats, parent);\n}",
    "includes": [
      "#include \"blockcheck.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/bitops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/crc32.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_blockcheck_debug_install",
          "args": [
            "stats",
            "parent"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_blockcheck_debug_install",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
          "lines": "300-304",
          "snippet": "static inline int ocfs2_blockcheck_debug_install(struct ocfs2_blockcheck_stats *stats,\n\t\t\t\t\t\t struct dentry *parent)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"blockcheck.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic inline int ocfs2_blockcheck_debug_install(struct ocfs2_blockcheck_stats *stats,\n\t\t\t\t\t\t struct dentry *parent)\n{\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nint ocfs2_blockcheck_stats_debugfs_install(struct ocfs2_blockcheck_stats *stats,\n\t\t\t\t\t   struct dentry *parent)\n{\n\treturn ocfs2_blockcheck_debug_install(stats, parent);\n}"
  },
  {
    "function_name": "ocfs2_blockcheck_debug_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
    "lines": "306-308",
    "snippet": "static inline void ocfs2_blockcheck_debug_remove(struct ocfs2_blockcheck_stats *stats)\n{\n}",
    "includes": [
      "#include \"blockcheck.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/bitops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/crc32.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic inline void ocfs2_blockcheck_debug_remove(struct ocfs2_blockcheck_stats *stats)\n{\n}"
  },
  {
    "function_name": "ocfs2_blockcheck_debug_install",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
    "lines": "300-304",
    "snippet": "static inline int ocfs2_blockcheck_debug_install(struct ocfs2_blockcheck_stats *stats,\n\t\t\t\t\t\t struct dentry *parent)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"blockcheck.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/bitops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/crc32.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic inline int ocfs2_blockcheck_debug_install(struct ocfs2_blockcheck_stats *stats,\n\t\t\t\t\t\t struct dentry *parent)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_blockcheck_debug_install",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
    "lines": "264-298",
    "snippet": "static int ocfs2_blockcheck_debug_install(struct ocfs2_blockcheck_stats *stats,\n\t\t\t\t\t  struct dentry *parent)\n{\n\tint rc = -EINVAL;\n\n\tif (!stats)\n\t\tgoto out;\n\n\tstats->b_debug_dir = debugfs_create_dir(\"blockcheck\", parent);\n\tif (!stats->b_debug_dir)\n\t\tgoto out;\n\n\tstats->b_debug_check =\n\t\tblockcheck_debugfs_create(\"blocks_checked\",\n\t\t\t\t\t  stats->b_debug_dir,\n\t\t\t\t\t  &stats->b_check_count);\n\n\tstats->b_debug_failure =\n\t\tblockcheck_debugfs_create(\"checksums_failed\",\n\t\t\t\t\t  stats->b_debug_dir,\n\t\t\t\t\t  &stats->b_failure_count);\n\n\tstats->b_debug_recover =\n\t\tblockcheck_debugfs_create(\"ecc_recoveries\",\n\t\t\t\t\t  stats->b_debug_dir,\n\t\t\t\t\t  &stats->b_recover_count);\n\tif (stats->b_debug_check && stats->b_debug_failure &&\n\t    stats->b_debug_recover)\n\t\trc = 0;\n\nout:\n\tif (rc)\n\t\tocfs2_blockcheck_debug_remove(stats);\n\treturn rc;\n}",
    "includes": [
      "#include \"blockcheck.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/bitops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/crc32.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_blockcheck_debug_remove",
          "args": [
            "stats"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_blockcheck_debug_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
          "lines": "306-308",
          "snippet": "static inline void ocfs2_blockcheck_debug_remove(struct ocfs2_blockcheck_stats *stats)\n{\n}",
          "includes": [
            "#include \"blockcheck.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic inline void ocfs2_blockcheck_debug_remove(struct ocfs2_blockcheck_stats *stats)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "blockcheck_debugfs_create",
          "args": [
            "\"ecc_recoveries\"",
            "stats->b_debug_dir",
            "&stats->b_recover_count"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "blockcheck_debugfs_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
          "lines": "242-248",
          "snippet": "static struct dentry *blockcheck_debugfs_create(const char *name,\n\t\t\t\t\t\tstruct dentry *parent,\n\t\t\t\t\t\tu64 *value)\n{\n\treturn debugfs_create_file(name, S_IFREG | S_IRUSR, parent, value,\n\t\t\t\t   &blockcheck_fops);\n}",
          "includes": [
            "#include \"blockcheck.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic struct dentry *blockcheck_debugfs_create(const char *name,\n\t\t\t\t\t\tstruct dentry *parent,\n\t\t\t\t\t\tu64 *value)\n{\n\treturn debugfs_create_file(name, S_IFREG | S_IRUSR, parent, value,\n\t\t\t\t   &blockcheck_fops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugfs_create_dir",
          "args": [
            "\"blockcheck\"",
            "parent"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "debugfs_create_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/debugfs/inode.c",
          "lines": "407-429",
          "snippet": "struct dentry *debugfs_create_dir(const char *name, struct dentry *parent)\n{\n\tstruct dentry *dentry = start_creating(name, parent);\n\tstruct inode *inode;\n\n\tif (IS_ERR(dentry))\n\t\treturn NULL;\n\n\tinode = debugfs_get_inode(dentry->d_sb);\n\tif (unlikely(!inode))\n\t\treturn failed_creating(dentry);\n\n\tinode->i_mode = S_IFDIR | S_IRWXU | S_IRUGO | S_IXUGO;\n\tinode->i_op = &simple_dir_inode_operations;\n\tinode->i_fop = &simple_dir_operations;\n\n\t/* directory inodes start off with i_nlink == 2 (for \".\" entry) */\n\tinc_nlink(inode);\n\td_instantiate(dentry, inode);\n\tinc_nlink(dentry->d_parent->d_inode);\n\tfsnotify_mkdir(dentry->d_parent->d_inode, dentry);\n\treturn end_creating(dentry);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/parser.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/kobject.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fsnotify.h>\n#include <linux/debugfs.h>\n#include <linux/namei.h>\n#include <linux/kobject.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstruct dentry *debugfs_create_dir(const char *name, struct dentry *parent)\n{\n\tstruct dentry *dentry = start_creating(name, parent);\n\tstruct inode *inode;\n\n\tif (IS_ERR(dentry))\n\t\treturn NULL;\n\n\tinode = debugfs_get_inode(dentry->d_sb);\n\tif (unlikely(!inode))\n\t\treturn failed_creating(dentry);\n\n\tinode->i_mode = S_IFDIR | S_IRWXU | S_IRUGO | S_IXUGO;\n\tinode->i_op = &simple_dir_inode_operations;\n\tinode->i_fop = &simple_dir_operations;\n\n\t/* directory inodes start off with i_nlink == 2 (for \".\" entry) */\n\tinc_nlink(inode);\n\td_instantiate(dentry, inode);\n\tinc_nlink(dentry->d_parent->d_inode);\n\tfsnotify_mkdir(dentry->d_parent->d_inode, dentry);\n\treturn end_creating(dentry);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic int ocfs2_blockcheck_debug_install(struct ocfs2_blockcheck_stats *stats,\n\t\t\t\t\t  struct dentry *parent)\n{\n\tint rc = -EINVAL;\n\n\tif (!stats)\n\t\tgoto out;\n\n\tstats->b_debug_dir = debugfs_create_dir(\"blockcheck\", parent);\n\tif (!stats->b_debug_dir)\n\t\tgoto out;\n\n\tstats->b_debug_check =\n\t\tblockcheck_debugfs_create(\"blocks_checked\",\n\t\t\t\t\t  stats->b_debug_dir,\n\t\t\t\t\t  &stats->b_check_count);\n\n\tstats->b_debug_failure =\n\t\tblockcheck_debugfs_create(\"checksums_failed\",\n\t\t\t\t\t  stats->b_debug_dir,\n\t\t\t\t\t  &stats->b_failure_count);\n\n\tstats->b_debug_recover =\n\t\tblockcheck_debugfs_create(\"ecc_recoveries\",\n\t\t\t\t\t  stats->b_debug_dir,\n\t\t\t\t\t  &stats->b_recover_count);\n\tif (stats->b_debug_check && stats->b_debug_failure &&\n\t    stats->b_debug_recover)\n\t\trc = 0;\n\nout:\n\tif (rc)\n\t\tocfs2_blockcheck_debug_remove(stats);\n\treturn rc;\n}"
  },
  {
    "function_name": "ocfs2_blockcheck_debug_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
    "lines": "250-262",
    "snippet": "static void ocfs2_blockcheck_debug_remove(struct ocfs2_blockcheck_stats *stats)\n{\n\tif (stats) {\n\t\tdebugfs_remove(stats->b_debug_check);\n\t\tstats->b_debug_check = NULL;\n\t\tdebugfs_remove(stats->b_debug_failure);\n\t\tstats->b_debug_failure = NULL;\n\t\tdebugfs_remove(stats->b_debug_recover);\n\t\tstats->b_debug_recover = NULL;\n\t\tdebugfs_remove(stats->b_debug_dir);\n\t\tstats->b_debug_dir = NULL;\n\t}\n}",
    "includes": [
      "#include \"blockcheck.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/bitops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/crc32.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debugfs_remove",
          "args": [
            "stats->b_debug_dir"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_blockcheck_stats_debugfs_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
          "lines": "318-321",
          "snippet": "void ocfs2_blockcheck_stats_debugfs_remove(struct ocfs2_blockcheck_stats *stats)\n{\n\tocfs2_blockcheck_debug_remove(stats);\n}",
          "includes": [
            "#include \"blockcheck.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid ocfs2_blockcheck_stats_debugfs_remove(struct ocfs2_blockcheck_stats *stats)\n{\n\tocfs2_blockcheck_debug_remove(stats);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic void ocfs2_blockcheck_debug_remove(struct ocfs2_blockcheck_stats *stats)\n{\n\tif (stats) {\n\t\tdebugfs_remove(stats->b_debug_check);\n\t\tstats->b_debug_check = NULL;\n\t\tdebugfs_remove(stats->b_debug_failure);\n\t\tstats->b_debug_failure = NULL;\n\t\tdebugfs_remove(stats->b_debug_recover);\n\t\tstats->b_debug_recover = NULL;\n\t\tdebugfs_remove(stats->b_debug_dir);\n\t\tstats->b_debug_dir = NULL;\n\t}\n}"
  },
  {
    "function_name": "blockcheck_debugfs_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
    "lines": "242-248",
    "snippet": "static struct dentry *blockcheck_debugfs_create(const char *name,\n\t\t\t\t\t\tstruct dentry *parent,\n\t\t\t\t\t\tu64 *value)\n{\n\treturn debugfs_create_file(name, S_IFREG | S_IRUSR, parent, value,\n\t\t\t\t   &blockcheck_fops);\n}",
    "includes": [
      "#include \"blockcheck.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/bitops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/crc32.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debugfs_create_file",
          "args": [
            "name",
            "S_IFREG | S_IRUSR",
            "parent",
            "value",
            "&blockcheck_fops"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "debugfs_create_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/debugfs/inode.c",
          "lines": "321-346",
          "snippet": "struct dentry *debugfs_create_file(const char *name, umode_t mode,\n\t\t\t\t   struct dentry *parent, void *data,\n\t\t\t\t   const struct file_operations *fops)\n{\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\n\tif (!(mode & S_IFMT))\n\t\tmode |= S_IFREG;\n\tBUG_ON(!S_ISREG(mode));\n\tdentry = start_creating(name, parent);\n\n\tif (IS_ERR(dentry))\n\t\treturn NULL;\n\n\tinode = debugfs_get_inode(dentry->d_sb);\n\tif (unlikely(!inode))\n\t\treturn failed_creating(dentry);\n\n\tinode->i_mode = mode;\n\tinode->i_fop = fops ? fops : &debugfs_file_operations;\n\tinode->i_private = data;\n\td_instantiate(dentry, inode);\n\tfsnotify_create(dentry->d_parent->d_inode, dentry);\n\treturn end_creating(dentry);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/parser.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/string.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/kobject.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/parser.h>\n#include <linux/seq_file.h>\n#include <linux/string.h>\n#include <linux/fsnotify.h>\n#include <linux/debugfs.h>\n#include <linux/namei.h>\n#include <linux/kobject.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstruct dentry *debugfs_create_file(const char *name, umode_t mode,\n\t\t\t\t   struct dentry *parent, void *data,\n\t\t\t\t   const struct file_operations *fops)\n{\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\n\tif (!(mode & S_IFMT))\n\t\tmode |= S_IFREG;\n\tBUG_ON(!S_ISREG(mode));\n\tdentry = start_creating(name, parent);\n\n\tif (IS_ERR(dentry))\n\t\treturn NULL;\n\n\tinode = debugfs_get_inode(dentry->d_sb);\n\tif (unlikely(!inode))\n\t\treturn failed_creating(dentry);\n\n\tinode->i_mode = mode;\n\tinode->i_fop = fops ? fops : &debugfs_file_operations;\n\tinode->i_private = data;\n\td_instantiate(dentry, inode);\n\tfsnotify_create(dentry->d_parent->d_inode, dentry);\n\treturn end_creating(dentry);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic struct dentry *blockcheck_debugfs_create(const char *name,\n\t\t\t\t\t\tstruct dentry *parent,\n\t\t\t\t\t\tu64 *value)\n{\n\treturn debugfs_create_file(name, S_IFREG | S_IRUSR, parent, value,\n\t\t\t\t   &blockcheck_fops);\n}"
  },
  {
    "function_name": "blockcheck_u64_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
    "lines": "235-239",
    "snippet": "static int blockcheck_u64_get(void *data, u64 *val)\n{\n\t*val = *(u64 *)data;\n\treturn 0;\n}",
    "includes": [
      "#include \"blockcheck.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/bitops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/crc32.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic int blockcheck_u64_get(void *data, u64 *val)\n{\n\t*val = *(u64 *)data;\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_hamming_fix_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
    "lines": "222-226",
    "snippet": "void ocfs2_hamming_fix_block(void *data, unsigned int blocksize,\n\t\t\t     unsigned int fix)\n{\n\tocfs2_hamming_fix(data, blocksize * 8, 0, fix);\n}",
    "includes": [
      "#include \"blockcheck.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/bitops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/crc32.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_hamming_fix",
          "args": [
            "data",
            "blocksize * 8",
            "0",
            "fix"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_hamming_fix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
          "lines": "166-220",
          "snippet": "void ocfs2_hamming_fix(void *data, unsigned int d, unsigned int nr,\n\t\t       unsigned int fix)\n{\n\tunsigned int i, b;\n\n\tBUG_ON(!d);\n\n\t/*\n\t * If the bit to fix has an hweight of 1, it's a parity bit.  One\n\t * busted parity bit is its own error.  Nothing to do here.\n\t */\n\tif (hweight32(fix) == 1)\n\t\treturn;\n\n\t/*\n\t * nr + d is the bit right past the data hunk we're looking at.\n\t * If fix after that, nothing to do\n\t */\n\tif (fix >= calc_code_bit(nr + d, NULL))\n\t\treturn;\n\n\t/*\n\t * nr is the offset in the data hunk we're starting at.  Let's\n\t * start b at the offset in the code buffer.  See hamming_encode()\n\t * for a more detailed description of 'b'.\n\t */\n\tb = calc_code_bit(nr, NULL);\n\t/* If the fix is before this hunk, nothing to do */\n\tif (fix < b)\n\t\treturn;\n\n\tfor (i = 0; i < d; i++, b++)\n\t{\n\t\t/* Skip past parity bits */\n\t\twhile (hweight32(b) == 1)\n\t\t\tb++;\n\n\t\t/*\n\t\t * i is the offset in this data hunk.\n\t\t * nr + i is the offset in the total data buffer.\n\t\t * b is the offset in the total code buffer.\n\t\t *\n\t\t * Thus, when b == fix, bit i in the current hunk needs\n\t\t * fixing.\n\t\t */\n\t\tif (b == fix)\n\t\t{\n\t\t\tif (ocfs2_test_bit(i, data))\n\t\t\t\tocfs2_clear_bit(i, data);\n\t\t\telse\n\t\t\t\tocfs2_set_bit(i, data);\n\t\t\tbreak;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"blockcheck.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid ocfs2_hamming_fix(void *data, unsigned int d, unsigned int nr,\n\t\t       unsigned int fix)\n{\n\tunsigned int i, b;\n\n\tBUG_ON(!d);\n\n\t/*\n\t * If the bit to fix has an hweight of 1, it's a parity bit.  One\n\t * busted parity bit is its own error.  Nothing to do here.\n\t */\n\tif (hweight32(fix) == 1)\n\t\treturn;\n\n\t/*\n\t * nr + d is the bit right past the data hunk we're looking at.\n\t * If fix after that, nothing to do\n\t */\n\tif (fix >= calc_code_bit(nr + d, NULL))\n\t\treturn;\n\n\t/*\n\t * nr is the offset in the data hunk we're starting at.  Let's\n\t * start b at the offset in the code buffer.  See hamming_encode()\n\t * for a more detailed description of 'b'.\n\t */\n\tb = calc_code_bit(nr, NULL);\n\t/* If the fix is before this hunk, nothing to do */\n\tif (fix < b)\n\t\treturn;\n\n\tfor (i = 0; i < d; i++, b++)\n\t{\n\t\t/* Skip past parity bits */\n\t\twhile (hweight32(b) == 1)\n\t\t\tb++;\n\n\t\t/*\n\t\t * i is the offset in this data hunk.\n\t\t * nr + i is the offset in the total data buffer.\n\t\t * b is the offset in the total code buffer.\n\t\t *\n\t\t * Thus, when b == fix, bit i in the current hunk needs\n\t\t * fixing.\n\t\t */\n\t\tif (b == fix)\n\t\t{\n\t\t\tif (ocfs2_test_bit(i, data))\n\t\t\t\tocfs2_clear_bit(i, data);\n\t\t\telse\n\t\t\t\tocfs2_set_bit(i, data);\n\t\t\tbreak;\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid ocfs2_hamming_fix_block(void *data, unsigned int blocksize,\n\t\t\t     unsigned int fix)\n{\n\tocfs2_hamming_fix(data, blocksize * 8, 0, fix);\n}"
  },
  {
    "function_name": "ocfs2_hamming_fix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
    "lines": "166-220",
    "snippet": "void ocfs2_hamming_fix(void *data, unsigned int d, unsigned int nr,\n\t\t       unsigned int fix)\n{\n\tunsigned int i, b;\n\n\tBUG_ON(!d);\n\n\t/*\n\t * If the bit to fix has an hweight of 1, it's a parity bit.  One\n\t * busted parity bit is its own error.  Nothing to do here.\n\t */\n\tif (hweight32(fix) == 1)\n\t\treturn;\n\n\t/*\n\t * nr + d is the bit right past the data hunk we're looking at.\n\t * If fix after that, nothing to do\n\t */\n\tif (fix >= calc_code_bit(nr + d, NULL))\n\t\treturn;\n\n\t/*\n\t * nr is the offset in the data hunk we're starting at.  Let's\n\t * start b at the offset in the code buffer.  See hamming_encode()\n\t * for a more detailed description of 'b'.\n\t */\n\tb = calc_code_bit(nr, NULL);\n\t/* If the fix is before this hunk, nothing to do */\n\tif (fix < b)\n\t\treturn;\n\n\tfor (i = 0; i < d; i++, b++)\n\t{\n\t\t/* Skip past parity bits */\n\t\twhile (hweight32(b) == 1)\n\t\t\tb++;\n\n\t\t/*\n\t\t * i is the offset in this data hunk.\n\t\t * nr + i is the offset in the total data buffer.\n\t\t * b is the offset in the total code buffer.\n\t\t *\n\t\t * Thus, when b == fix, bit i in the current hunk needs\n\t\t * fixing.\n\t\t */\n\t\tif (b == fix)\n\t\t{\n\t\t\tif (ocfs2_test_bit(i, data))\n\t\t\t\tocfs2_clear_bit(i, data);\n\t\t\telse\n\t\t\t\tocfs2_set_bit(i, data);\n\t\t\tbreak;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"blockcheck.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/bitops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/crc32.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_set_bit",
          "args": [
            "i",
            "data"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_clear_bit",
          "args": [
            "i",
            "data"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_test_bit",
          "args": [
            "i",
            "data"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hweight32",
          "args": [
            "b"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calc_code_bit",
          "args": [
            "nr",
            "NULL"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "calc_code_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
          "lines": "64-94",
          "snippet": "static unsigned int calc_code_bit(unsigned int i, unsigned int *p_cache)\n{\n\tunsigned int b, p = 0;\n\n\t/*\n\t * Data bits are 0-based, but we're talking code bits, which\n\t * are 1-based.\n\t */\n\tb = i + 1;\n\n\t/* Use the cache if it is there */\n\tif (p_cache)\n\t\tp = *p_cache;\n        b += p;\n\n\t/*\n\t * For every power of two below our bit number, bump our bit.\n\t *\n\t * We compare with (b + 1) because we have to compare with what b\n\t * would be _if_ it were bumped up by the parity bit.  Capice?\n\t *\n\t * p is set above.\n\t */\n\tfor (; (1 << p) < (b + 1); p++)\n\t\tb++;\n\n\tif (p_cache)\n\t\t*p_cache = p;\n\n\treturn b;\n}",
          "includes": [
            "#include \"blockcheck.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic unsigned int calc_code_bit(unsigned int i, unsigned int *p_cache)\n{\n\tunsigned int b, p = 0;\n\n\t/*\n\t * Data bits are 0-based, but we're talking code bits, which\n\t * are 1-based.\n\t */\n\tb = i + 1;\n\n\t/* Use the cache if it is there */\n\tif (p_cache)\n\t\tp = *p_cache;\n        b += p;\n\n\t/*\n\t * For every power of two below our bit number, bump our bit.\n\t *\n\t * We compare with (b + 1) because we have to compare with what b\n\t * would be _if_ it were bumped up by the parity bit.  Capice?\n\t *\n\t * p is set above.\n\t */\n\tfor (; (1 << p) < (b + 1); p++)\n\t\tb++;\n\n\tif (p_cache)\n\t\t*p_cache = p;\n\n\treturn b;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hweight32",
          "args": [
            "fix"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!d"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nvoid ocfs2_hamming_fix(void *data, unsigned int d, unsigned int nr,\n\t\t       unsigned int fix)\n{\n\tunsigned int i, b;\n\n\tBUG_ON(!d);\n\n\t/*\n\t * If the bit to fix has an hweight of 1, it's a parity bit.  One\n\t * busted parity bit is its own error.  Nothing to do here.\n\t */\n\tif (hweight32(fix) == 1)\n\t\treturn;\n\n\t/*\n\t * nr + d is the bit right past the data hunk we're looking at.\n\t * If fix after that, nothing to do\n\t */\n\tif (fix >= calc_code_bit(nr + d, NULL))\n\t\treturn;\n\n\t/*\n\t * nr is the offset in the data hunk we're starting at.  Let's\n\t * start b at the offset in the code buffer.  See hamming_encode()\n\t * for a more detailed description of 'b'.\n\t */\n\tb = calc_code_bit(nr, NULL);\n\t/* If the fix is before this hunk, nothing to do */\n\tif (fix < b)\n\t\treturn;\n\n\tfor (i = 0; i < d; i++, b++)\n\t{\n\t\t/* Skip past parity bits */\n\t\twhile (hweight32(b) == 1)\n\t\t\tb++;\n\n\t\t/*\n\t\t * i is the offset in this data hunk.\n\t\t * nr + i is the offset in the total data buffer.\n\t\t * b is the offset in the total code buffer.\n\t\t *\n\t\t * Thus, when b == fix, bit i in the current hunk needs\n\t\t * fixing.\n\t\t */\n\t\tif (b == fix)\n\t\t{\n\t\t\tif (ocfs2_test_bit(i, data))\n\t\t\t\tocfs2_clear_bit(i, data);\n\t\t\telse\n\t\t\t\tocfs2_set_bit(i, data);\n\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "ocfs2_hamming_encode_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
    "lines": "154-157",
    "snippet": "u32 ocfs2_hamming_encode_block(void *data, unsigned int blocksize)\n{\n\treturn ocfs2_hamming_encode(0, data, blocksize * 8, 0);\n}",
    "includes": [
      "#include \"blockcheck.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/bitops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/crc32.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_hamming_encode",
          "args": [
            "0",
            "data",
            "blocksize * 8",
            "0"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_hamming_encode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
          "lines": "107-152",
          "snippet": "u32 ocfs2_hamming_encode(u32 parity, void *data, unsigned int d, unsigned int nr)\n{\n\tunsigned int i, b, p = 0;\n\n\tBUG_ON(!d);\n\n\t/*\n\t * b is the hamming code bit number.  Hamming code specifies a\n\t * 1-based array, but C uses 0-based.  So 'i' is for C, and 'b' is\n\t * for the algorithm.\n\t *\n\t * The i++ in the for loop is so that the start offset passed\n\t * to ocfs2_find_next_bit_set() is one greater than the previously\n\t * found bit.\n\t */\n\tfor (i = 0; (i = ocfs2_find_next_bit(data, d, i)) < d; i++)\n\t{\n\t\t/*\n\t\t * i is the offset in this hunk, nr + i is the total bit\n\t\t * offset.\n\t\t */\n\t\tb = calc_code_bit(nr + i, &p);\n\n\t\t/*\n\t\t * Data bits in the resultant code are checked by\n\t\t * parity bits that are part of the bit number\n\t\t * representation.  Huh?\n\t\t *\n\t\t * <wikipedia href=\"http://en.wikipedia.org/wiki/Hamming_code\">\n\t\t * In other words, the parity bit at position 2^k\n\t\t * checks bits in positions having bit k set in\n\t\t * their binary representation.  Conversely, for\n\t\t * instance, bit 13, i.e. 1101(2), is checked by\n\t\t * bits 1000(2) = 8, 0100(2)=4 and 0001(2) = 1.\n\t\t * </wikipedia>\n\t\t *\n\t\t * Note that 'k' is the _code_ bit number.  'b' in\n\t\t * our loop.\n\t\t */\n\t\tparity ^= b;\n\t}\n\n\t/* While the data buffer was treated as little endian, the\n\t * return value is in host endian. */\n\treturn parity;\n}",
          "includes": [
            "#include \"blockcheck.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nu32 ocfs2_hamming_encode(u32 parity, void *data, unsigned int d, unsigned int nr)\n{\n\tunsigned int i, b, p = 0;\n\n\tBUG_ON(!d);\n\n\t/*\n\t * b is the hamming code bit number.  Hamming code specifies a\n\t * 1-based array, but C uses 0-based.  So 'i' is for C, and 'b' is\n\t * for the algorithm.\n\t *\n\t * The i++ in the for loop is so that the start offset passed\n\t * to ocfs2_find_next_bit_set() is one greater than the previously\n\t * found bit.\n\t */\n\tfor (i = 0; (i = ocfs2_find_next_bit(data, d, i)) < d; i++)\n\t{\n\t\t/*\n\t\t * i is the offset in this hunk, nr + i is the total bit\n\t\t * offset.\n\t\t */\n\t\tb = calc_code_bit(nr + i, &p);\n\n\t\t/*\n\t\t * Data bits in the resultant code are checked by\n\t\t * parity bits that are part of the bit number\n\t\t * representation.  Huh?\n\t\t *\n\t\t * <wikipedia href=\"http://en.wikipedia.org/wiki/Hamming_code\">\n\t\t * In other words, the parity bit at position 2^k\n\t\t * checks bits in positions having bit k set in\n\t\t * their binary representation.  Conversely, for\n\t\t * instance, bit 13, i.e. 1101(2), is checked by\n\t\t * bits 1000(2) = 8, 0100(2)=4 and 0001(2) = 1.\n\t\t * </wikipedia>\n\t\t *\n\t\t * Note that 'k' is the _code_ bit number.  'b' in\n\t\t * our loop.\n\t\t */\n\t\tparity ^= b;\n\t}\n\n\t/* While the data buffer was treated as little endian, the\n\t * return value is in host endian. */\n\treturn parity;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nu32 ocfs2_hamming_encode_block(void *data, unsigned int blocksize)\n{\n\treturn ocfs2_hamming_encode(0, data, blocksize * 8, 0);\n}"
  },
  {
    "function_name": "ocfs2_hamming_encode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
    "lines": "107-152",
    "snippet": "u32 ocfs2_hamming_encode(u32 parity, void *data, unsigned int d, unsigned int nr)\n{\n\tunsigned int i, b, p = 0;\n\n\tBUG_ON(!d);\n\n\t/*\n\t * b is the hamming code bit number.  Hamming code specifies a\n\t * 1-based array, but C uses 0-based.  So 'i' is for C, and 'b' is\n\t * for the algorithm.\n\t *\n\t * The i++ in the for loop is so that the start offset passed\n\t * to ocfs2_find_next_bit_set() is one greater than the previously\n\t * found bit.\n\t */\n\tfor (i = 0; (i = ocfs2_find_next_bit(data, d, i)) < d; i++)\n\t{\n\t\t/*\n\t\t * i is the offset in this hunk, nr + i is the total bit\n\t\t * offset.\n\t\t */\n\t\tb = calc_code_bit(nr + i, &p);\n\n\t\t/*\n\t\t * Data bits in the resultant code are checked by\n\t\t * parity bits that are part of the bit number\n\t\t * representation.  Huh?\n\t\t *\n\t\t * <wikipedia href=\"http://en.wikipedia.org/wiki/Hamming_code\">\n\t\t * In other words, the parity bit at position 2^k\n\t\t * checks bits in positions having bit k set in\n\t\t * their binary representation.  Conversely, for\n\t\t * instance, bit 13, i.e. 1101(2), is checked by\n\t\t * bits 1000(2) = 8, 0100(2)=4 and 0001(2) = 1.\n\t\t * </wikipedia>\n\t\t *\n\t\t * Note that 'k' is the _code_ bit number.  'b' in\n\t\t * our loop.\n\t\t */\n\t\tparity ^= b;\n\t}\n\n\t/* While the data buffer was treated as little endian, the\n\t * return value is in host endian. */\n\treturn parity;\n}",
    "includes": [
      "#include \"blockcheck.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/bitops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/crc32.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "calc_code_bit",
          "args": [
            "nr + i",
            "&p"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "calc_code_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
          "lines": "64-94",
          "snippet": "static unsigned int calc_code_bit(unsigned int i, unsigned int *p_cache)\n{\n\tunsigned int b, p = 0;\n\n\t/*\n\t * Data bits are 0-based, but we're talking code bits, which\n\t * are 1-based.\n\t */\n\tb = i + 1;\n\n\t/* Use the cache if it is there */\n\tif (p_cache)\n\t\tp = *p_cache;\n        b += p;\n\n\t/*\n\t * For every power of two below our bit number, bump our bit.\n\t *\n\t * We compare with (b + 1) because we have to compare with what b\n\t * would be _if_ it were bumped up by the parity bit.  Capice?\n\t *\n\t * p is set above.\n\t */\n\tfor (; (1 << p) < (b + 1); p++)\n\t\tb++;\n\n\tif (p_cache)\n\t\t*p_cache = p;\n\n\treturn b;\n}",
          "includes": [
            "#include \"blockcheck.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic unsigned int calc_code_bit(unsigned int i, unsigned int *p_cache)\n{\n\tunsigned int b, p = 0;\n\n\t/*\n\t * Data bits are 0-based, but we're talking code bits, which\n\t * are 1-based.\n\t */\n\tb = i + 1;\n\n\t/* Use the cache if it is there */\n\tif (p_cache)\n\t\tp = *p_cache;\n        b += p;\n\n\t/*\n\t * For every power of two below our bit number, bump our bit.\n\t *\n\t * We compare with (b + 1) because we have to compare with what b\n\t * would be _if_ it were bumped up by the parity bit.  Capice?\n\t *\n\t * p is set above.\n\t */\n\tfor (; (1 << p) < (b + 1); p++)\n\t\tb++;\n\n\tif (p_cache)\n\t\t*p_cache = p;\n\n\treturn b;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_find_next_bit",
          "args": [
            "data",
            "d",
            "i"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!d"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nu32 ocfs2_hamming_encode(u32 parity, void *data, unsigned int d, unsigned int nr)\n{\n\tunsigned int i, b, p = 0;\n\n\tBUG_ON(!d);\n\n\t/*\n\t * b is the hamming code bit number.  Hamming code specifies a\n\t * 1-based array, but C uses 0-based.  So 'i' is for C, and 'b' is\n\t * for the algorithm.\n\t *\n\t * The i++ in the for loop is so that the start offset passed\n\t * to ocfs2_find_next_bit_set() is one greater than the previously\n\t * found bit.\n\t */\n\tfor (i = 0; (i = ocfs2_find_next_bit(data, d, i)) < d; i++)\n\t{\n\t\t/*\n\t\t * i is the offset in this hunk, nr + i is the total bit\n\t\t * offset.\n\t\t */\n\t\tb = calc_code_bit(nr + i, &p);\n\n\t\t/*\n\t\t * Data bits in the resultant code are checked by\n\t\t * parity bits that are part of the bit number\n\t\t * representation.  Huh?\n\t\t *\n\t\t * <wikipedia href=\"http://en.wikipedia.org/wiki/Hamming_code\">\n\t\t * In other words, the parity bit at position 2^k\n\t\t * checks bits in positions having bit k set in\n\t\t * their binary representation.  Conversely, for\n\t\t * instance, bit 13, i.e. 1101(2), is checked by\n\t\t * bits 1000(2) = 8, 0100(2)=4 and 0001(2) = 1.\n\t\t * </wikipedia>\n\t\t *\n\t\t * Note that 'k' is the _code_ bit number.  'b' in\n\t\t * our loop.\n\t\t */\n\t\tparity ^= b;\n\t}\n\n\t/* While the data buffer was treated as little endian, the\n\t * return value is in host endian. */\n\treturn parity;\n}"
  },
  {
    "function_name": "calc_code_bit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
    "lines": "64-94",
    "snippet": "static unsigned int calc_code_bit(unsigned int i, unsigned int *p_cache)\n{\n\tunsigned int b, p = 0;\n\n\t/*\n\t * Data bits are 0-based, but we're talking code bits, which\n\t * are 1-based.\n\t */\n\tb = i + 1;\n\n\t/* Use the cache if it is there */\n\tif (p_cache)\n\t\tp = *p_cache;\n        b += p;\n\n\t/*\n\t * For every power of two below our bit number, bump our bit.\n\t *\n\t * We compare with (b + 1) because we have to compare with what b\n\t * would be _if_ it were bumped up by the parity bit.  Capice?\n\t *\n\t * p is set above.\n\t */\n\tfor (; (1 << p) < (b + 1); p++)\n\t\tb++;\n\n\tif (p_cache)\n\t\t*p_cache = p;\n\n\treturn b;\n}",
    "includes": [
      "#include \"blockcheck.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <asm/byteorder.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/bitops.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/crc32.h>",
      "#include <linux/types.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic unsigned int calc_code_bit(unsigned int i, unsigned int *p_cache)\n{\n\tunsigned int b, p = 0;\n\n\t/*\n\t * Data bits are 0-based, but we're talking code bits, which\n\t * are 1-based.\n\t */\n\tb = i + 1;\n\n\t/* Use the cache if it is there */\n\tif (p_cache)\n\t\tp = *p_cache;\n        b += p;\n\n\t/*\n\t * For every power of two below our bit number, bump our bit.\n\t *\n\t * We compare with (b + 1) because we have to compare with what b\n\t * would be _if_ it were bumped up by the parity bit.  Capice?\n\t *\n\t * p is set above.\n\t */\n\tfor (; (1 << p) < (b + 1); p++)\n\t\tb++;\n\n\tif (p_cache)\n\t\t*p_cache = p;\n\n\treturn b;\n}"
  }
]