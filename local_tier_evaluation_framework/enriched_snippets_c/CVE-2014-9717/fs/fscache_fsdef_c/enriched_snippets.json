[
  {
    "function_name": "fscache_fsdef_netfs_check_aux",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/fsdef.c",
    "lines": "123-146",
    "snippet": "static enum fscache_checkaux fscache_fsdef_netfs_check_aux(\n\tvoid *cookie_netfs_data,\n\tconst void *data,\n\tuint16_t datalen)\n{\n\tstruct fscache_netfs *netfs = cookie_netfs_data;\n\tuint32_t version;\n\n\t_enter(\"{%s},,%hu\", netfs->name, datalen);\n\n\tif (datalen != sizeof(version)) {\n\t\t_leave(\" = OBSOLETE [dl=%d v=%zu]\", datalen, sizeof(version));\n\t\treturn FSCACHE_CHECKAUX_OBSOLETE;\n\t}\n\n\tmemcpy(&version, data, sizeof(version));\n\tif (version != netfs->version) {\n\t\t_leave(\" = OBSOLETE [ver=%x net=%x]\", version, netfs->version);\n\t\treturn FSCACHE_CHECKAUX_OBSOLETE;\n\t}\n\n\t_leave(\" = OKAY\");\n\treturn FSCACHE_CHECKAUX_OKAY;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static\nenum fscache_checkaux fscache_fsdef_netfs_check_aux(void *cookie_netfs_data,\n\t\t\t\t\t\t    const void *data,\n\t\t\t\t\t\t    uint16_t datalen);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = OKAY\""
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = OBSOLETE [ver=%x net=%x]\"",
            "version",
            "netfs->version"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "are_leaves_removable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "698-757",
          "snippet": "static int are_leaves_removable(struct tree_balance *tb, int lfree, int rfree)\n{\n\tstruct virtual_node *vn = tb->tb_vn;\n\tint ih_size;\n\tstruct buffer_head *S0;\n\n\tS0 = PATH_H_PBUFFER(tb->tb_path, 0);\n\n\tih_size = 0;\n\tif (vn->vn_nr_item) {\n\t\tif (vn->vn_vi[0].vi_type & VI_TYPE_LEFT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\n\t\tif (vn->vn_vi[vn->vn_nr_item - 1].\n\t\t    vi_type & VI_TYPE_RIGHT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\t} else {\n\t\t/* there was only one item and it will be deleted */\n\t\tstruct item_head *ih;\n\n\t\tRFALSE(B_NR_ITEMS(S0) != 1,\n\t\t       \"vs-8125: item number must be 1: it is %d\",\n\t\t       B_NR_ITEMS(S0));\n\n\t\tih = item_head(S0, 0);\n\t\tif (tb->CFR[0]\n\t\t    && !comp_short_le_keys(&ih->ih_key,\n\t\t\t\t\t   internal_key(tb->CFR[0],\n\t\t\t\t\t\t\t  tb->rkey[0])))\n\t\t\t/*\n\t\t\t * Directory must be in correct state here: that is\n\t\t\t * somewhere at the left side should exist first\n\t\t\t * directory item. But the item being deleted can\n\t\t\t * not be that first one because its right neighbor\n\t\t\t * is item of the same directory. (But first item\n\t\t\t * always gets deleted in last turn). So, neighbors\n\t\t\t * of deleted item can be merged, so we can save\n\t\t\t * ih_size\n\t\t\t */\n\t\t\tif (is_direntry_le_ih(ih)) {\n\t\t\t\tih_size = IH_SIZE;\n\n\t\t\t\t/*\n\t\t\t\t * we might check that left neighbor exists\n\t\t\t\t * and is of the same directory\n\t\t\t\t */\n\t\t\t\tRFALSE(le_ih_k_offset(ih) == DOT_OFFSET,\n\t\t\t\t       \"vs-8130: first directory item can not be removed until directory is not empty\");\n\t\t\t}\n\n\t}\n\n\tif (MAX_CHILD_SIZE(S0) + vn->vn_size <= rfree + lfree + ih_size) {\n\t\tset_parameters(tb, 0, -1, -1, -1, NULL, -1, -1);\n\t\tPROC_INFO_INC(tb->tb_sb, leaves_removable);\n\t\treturn 1;\n\t}\n\treturn 0;\n\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic int are_leaves_removable(struct tree_balance *tb, int lfree, int rfree)\n{\n\tstruct virtual_node *vn = tb->tb_vn;\n\tint ih_size;\n\tstruct buffer_head *S0;\n\n\tS0 = PATH_H_PBUFFER(tb->tb_path, 0);\n\n\tih_size = 0;\n\tif (vn->vn_nr_item) {\n\t\tif (vn->vn_vi[0].vi_type & VI_TYPE_LEFT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\n\t\tif (vn->vn_vi[vn->vn_nr_item - 1].\n\t\t    vi_type & VI_TYPE_RIGHT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\t} else {\n\t\t/* there was only one item and it will be deleted */\n\t\tstruct item_head *ih;\n\n\t\tRFALSE(B_NR_ITEMS(S0) != 1,\n\t\t       \"vs-8125: item number must be 1: it is %d\",\n\t\t       B_NR_ITEMS(S0));\n\n\t\tih = item_head(S0, 0);\n\t\tif (tb->CFR[0]\n\t\t    && !comp_short_le_keys(&ih->ih_key,\n\t\t\t\t\t   internal_key(tb->CFR[0],\n\t\t\t\t\t\t\t  tb->rkey[0])))\n\t\t\t/*\n\t\t\t * Directory must be in correct state here: that is\n\t\t\t * somewhere at the left side should exist first\n\t\t\t * directory item. But the item being deleted can\n\t\t\t * not be that first one because its right neighbor\n\t\t\t * is item of the same directory. (But first item\n\t\t\t * always gets deleted in last turn). So, neighbors\n\t\t\t * of deleted item can be merged, so we can save\n\t\t\t * ih_size\n\t\t\t */\n\t\t\tif (is_direntry_le_ih(ih)) {\n\t\t\t\tih_size = IH_SIZE;\n\n\t\t\t\t/*\n\t\t\t\t * we might check that left neighbor exists\n\t\t\t\t * and is of the same directory\n\t\t\t\t */\n\t\t\t\tRFALSE(le_ih_k_offset(ih) == DOT_OFFSET,\n\t\t\t\t       \"vs-8130: first directory item can not be removed until directory is not empty\");\n\t\t\t}\n\n\t}\n\n\tif (MAX_CHILD_SIZE(S0) + vn->vn_size <= rfree + lfree + ih_size) {\n\t\tset_parameters(tb, 0, -1, -1, -1, NULL, -1, -1);\n\t\tPROC_INFO_INC(tb->tb_sb, leaves_removable);\n\t\treturn 1;\n\t}\n\treturn 0;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&version",
            "data",
            "sizeof(version)"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%s},,%hu\"",
            "netfs->name",
            "datalen"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n\nstatic\nenum fscache_checkaux fscache_fsdef_netfs_check_aux(void *cookie_netfs_data,\n\t\t\t\t\t\t    const void *data,\n\t\t\t\t\t\t    uint16_t datalen);\n\nstatic enum fscache_checkaux fscache_fsdef_netfs_check_aux(\n\tvoid *cookie_netfs_data,\n\tconst void *data,\n\tuint16_t datalen)\n{\n\tstruct fscache_netfs *netfs = cookie_netfs_data;\n\tuint32_t version;\n\n\t_enter(\"{%s},,%hu\", netfs->name, datalen);\n\n\tif (datalen != sizeof(version)) {\n\t\t_leave(\" = OBSOLETE [dl=%d v=%zu]\", datalen, sizeof(version));\n\t\treturn FSCACHE_CHECKAUX_OBSOLETE;\n\t}\n\n\tmemcpy(&version, data, sizeof(version));\n\tif (version != netfs->version) {\n\t\t_leave(\" = OBSOLETE [ver=%x net=%x]\", version, netfs->version);\n\t\treturn FSCACHE_CHECKAUX_OBSOLETE;\n\t}\n\n\t_leave(\" = OKAY\");\n\treturn FSCACHE_CHECKAUX_OKAY;\n}"
  },
  {
    "function_name": "fscache_fsdef_netfs_get_aux",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/fsdef.c",
    "lines": "103-117",
    "snippet": "static uint16_t fscache_fsdef_netfs_get_aux(const void *cookie_netfs_data,\n\t\t\t\t\t    void *buffer, uint16_t bufmax)\n{\n\tconst struct fscache_netfs *netfs = cookie_netfs_data;\n\tunsigned dlen;\n\n\t_enter(\"{%s.%u},\", netfs->name, netfs->version);\n\n\tdlen = sizeof(uint32_t);\n\tif (dlen > bufmax)\n\t\treturn 0;\n\n\tmemcpy(buffer, &netfs->version, dlen);\n\treturn dlen;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static uint16_t fscache_fsdef_netfs_get_key(const void *cookie_netfs_data,\n\t\t\t\t\t    void *buffer, uint16_t bufmax);",
      "static uint16_t fscache_fsdef_netfs_get_aux(const void *cookie_netfs_data,\n\t\t\t\t\t    void *buffer, uint16_t bufmax);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buffer",
            "&netfs->version",
            "dlen"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%s.%u},\"",
            "netfs->name",
            "netfs->version"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n\nstatic uint16_t fscache_fsdef_netfs_get_key(const void *cookie_netfs_data,\n\t\t\t\t\t    void *buffer, uint16_t bufmax);\nstatic uint16_t fscache_fsdef_netfs_get_aux(const void *cookie_netfs_data,\n\t\t\t\t\t    void *buffer, uint16_t bufmax);\n\nstatic uint16_t fscache_fsdef_netfs_get_aux(const void *cookie_netfs_data,\n\t\t\t\t\t    void *buffer, uint16_t bufmax)\n{\n\tconst struct fscache_netfs *netfs = cookie_netfs_data;\n\tunsigned dlen;\n\n\t_enter(\"{%s.%u},\", netfs->name, netfs->version);\n\n\tdlen = sizeof(uint32_t);\n\tif (dlen > bufmax)\n\t\treturn 0;\n\n\tmemcpy(buffer, &netfs->version, dlen);\n\treturn dlen;\n}"
  },
  {
    "function_name": "fscache_fsdef_netfs_get_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/fsdef.c",
    "lines": "83-97",
    "snippet": "static uint16_t fscache_fsdef_netfs_get_key(const void *cookie_netfs_data,\n\t\t\t\t\t    void *buffer, uint16_t bufmax)\n{\n\tconst struct fscache_netfs *netfs = cookie_netfs_data;\n\tunsigned klen;\n\n\t_enter(\"{%s.%u},\", netfs->name, netfs->version);\n\n\tklen = strlen(netfs->name);\n\tif (klen > bufmax)\n\t\treturn 0;\n\n\tmemcpy(buffer, netfs->name, klen);\n\treturn klen;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static uint16_t fscache_fsdef_netfs_get_key(const void *cookie_netfs_data,\n\t\t\t\t\t    void *buffer, uint16_t bufmax);",
      "static uint16_t fscache_fsdef_netfs_get_aux(const void *cookie_netfs_data,\n\t\t\t\t\t    void *buffer, uint16_t bufmax);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buffer",
            "netfs->name",
            "klen"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "netfs->name"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%s.%u},\"",
            "netfs->name",
            "netfs->version"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n\nstatic uint16_t fscache_fsdef_netfs_get_key(const void *cookie_netfs_data,\n\t\t\t\t\t    void *buffer, uint16_t bufmax);\nstatic uint16_t fscache_fsdef_netfs_get_aux(const void *cookie_netfs_data,\n\t\t\t\t\t    void *buffer, uint16_t bufmax);\n\nstatic uint16_t fscache_fsdef_netfs_get_key(const void *cookie_netfs_data,\n\t\t\t\t\t    void *buffer, uint16_t bufmax)\n{\n\tconst struct fscache_netfs *netfs = cookie_netfs_data;\n\tunsigned klen;\n\n\t_enter(\"{%s.%u},\", netfs->name, netfs->version);\n\n\tklen = strlen(netfs->name);\n\tif (klen > bufmax)\n\t\treturn 0;\n\n\tmemcpy(buffer, netfs->name, klen);\n\treturn klen;\n}"
  }
]