[
  {
    "function_name": "ocfs2_put_slot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/slot_map.c",
    "lines": "513-537",
    "snippet": "void ocfs2_put_slot(struct ocfs2_super *osb)\n{\n\tint status, slot_num;\n\tstruct ocfs2_slot_info *si = osb->slot_info;\n\n\tif (!si)\n\t\treturn;\n\n\tspin_lock(&osb->osb_lock);\n\tocfs2_update_slot_info(si);\n\n\tslot_num = osb->slot_num;\n\tocfs2_invalidate_slot(si, osb->slot_num);\n\tosb->slot_num = OCFS2_INVALID_SLOT;\n\tspin_unlock(&osb->osb_lock);\n\n\tstatus = ocfs2_update_disk_slot(osb, si, slot_num);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\nbail:\n\tocfs2_free_slot_info(osb);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_free_slot_info",
          "args": [
            "osb"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_slot_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/slot_map.c",
          "lines": "461-467",
          "snippet": "void ocfs2_free_slot_info(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_slot_info *si = osb->slot_info;\n\n\tosb->slot_info = NULL;\n\t__ocfs2_free_slot_info(si);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nvoid ocfs2_free_slot_info(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_slot_info *si = osb->slot_info;\n\n\tosb->slot_info = NULL;\n\t__ocfs2_free_slot_info(si);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_update_disk_slot",
          "args": [
            "osb",
            "si",
            "slot_num"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_update_disk_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/slot_map.c",
          "lines": "201-220",
          "snippet": "static int ocfs2_update_disk_slot(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_slot_info *si,\n\t\t\t\t  int slot_num)\n{\n\tint status;\n\tstruct buffer_head *bh;\n\n\tspin_lock(&osb->osb_lock);\n\tif (si->si_extended)\n\t\tocfs2_update_disk_slot_extended(si, slot_num, &bh);\n\telse\n\t\tocfs2_update_disk_slot_old(si, slot_num, &bh);\n\tspin_unlock(&osb->osb_lock);\n\n\tstatus = ocfs2_write_block(osb, bh, INODE_CACHE(si->si_inode));\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_update_disk_slot(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_slot_info *si,\n\t\t\t\t  int slot_num)\n{\n\tint status;\n\tstruct buffer_head *bh;\n\n\tspin_lock(&osb->osb_lock);\n\tif (si->si_extended)\n\t\tocfs2_update_disk_slot_extended(si, slot_num, &bh);\n\telse\n\t\tocfs2_update_disk_slot_old(si, slot_num, &bh);\n\tspin_unlock(&osb->osb_lock);\n\n\tstatus = ocfs2_write_block(osb, bh, INODE_CACHE(si->si_inode));\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_invalidate_slot",
          "args": [
            "si",
            "osb->slot_num"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_invalidate_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/slot_map.c",
          "lines": "65-70",
          "snippet": "static void ocfs2_invalidate_slot(struct ocfs2_slot_info *si,\n\t\t\t\t  int slot_num)\n{\n\tBUG_ON((slot_num < 0) || (slot_num >= si->si_num_slots));\n\tsi->si_slots[slot_num].sl_valid = 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void ocfs2_invalidate_slot(struct ocfs2_slot_info *si,\n\t\t\t\t  int slot_num)\n{\n\tBUG_ON((slot_num < 0) || (slot_num >= si->si_num_slots));\n\tsi->si_slots[slot_num].sl_valid = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_update_slot_info",
          "args": [
            "si"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_update_slot_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/slot_map.c",
          "lines": "122-132",
          "snippet": "static void ocfs2_update_slot_info(struct ocfs2_slot_info *si)\n{\n\t/*\n\t * The slot data will have been refreshed when ocfs2_super_lock\n\t * was taken.\n\t */\n\tif (si->si_extended)\n\t\tocfs2_update_slot_info_extended(si);\n\telse\n\t\tocfs2_update_slot_info_old(si);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void ocfs2_update_slot_info(struct ocfs2_slot_info *si)\n{\n\t/*\n\t * The slot data will have been refreshed when ocfs2_super_lock\n\t * was taken.\n\t */\n\tif (si->si_extended)\n\t\tocfs2_update_slot_info_extended(si);\n\telse\n\t\tocfs2_update_slot_info_old(si);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nvoid ocfs2_put_slot(struct ocfs2_super *osb)\n{\n\tint status, slot_num;\n\tstruct ocfs2_slot_info *si = osb->slot_info;\n\n\tif (!si)\n\t\treturn;\n\n\tspin_lock(&osb->osb_lock);\n\tocfs2_update_slot_info(si);\n\n\tslot_num = osb->slot_num;\n\tocfs2_invalidate_slot(si, osb->slot_num);\n\tosb->slot_num = OCFS2_INVALID_SLOT;\n\tspin_unlock(&osb->osb_lock);\n\n\tstatus = ocfs2_update_disk_slot(osb, si, slot_num);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\nbail:\n\tocfs2_free_slot_info(osb);\n}"
  },
  {
    "function_name": "ocfs2_find_slot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/slot_map.c",
    "lines": "469-511",
    "snippet": "int ocfs2_find_slot(struct ocfs2_super *osb)\n{\n\tint status;\n\tint slot;\n\tstruct ocfs2_slot_info *si;\n\n\tsi = osb->slot_info;\n\n\tspin_lock(&osb->osb_lock);\n\tocfs2_update_slot_info(si);\n\n\t/* search for ourselves first and take the slot if it already\n\t * exists. Perhaps we need to mark this in a variable for our\n\t * own journal recovery? Possibly not, though we certainly\n\t * need to warn to the user */\n\tslot = __ocfs2_node_num_to_slot(si, osb->node_num);\n\tif (slot < 0) {\n\t\t/* if no slot yet, then just take 1st available\n\t\t * one. */\n\t\tslot = __ocfs2_find_empty_slot(si, osb->preferred_slot);\n\t\tif (slot < 0) {\n\t\t\tspin_unlock(&osb->osb_lock);\n\t\t\tmlog(ML_ERROR, \"no free slots available!\\n\");\n\t\t\tstatus = -EINVAL;\n\t\t\tgoto bail;\n\t\t}\n\t} else\n\t\tprintk(KERN_INFO \"ocfs2: Slot %d on device (%s) was already \"\n\t\t       \"allocated to this node!\\n\", slot, osb->dev_str);\n\n\tocfs2_set_slot(si, slot, osb->node_num);\n\tosb->slot_num = slot;\n\tspin_unlock(&osb->osb_lock);\n\n\ttrace_ocfs2_find_slot(osb->slot_num);\n\n\tstatus = ocfs2_update_disk_slot(osb, si, osb->slot_num);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\nbail:\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __ocfs2_node_num_to_slot(struct ocfs2_slot_info *si,\n\t\t\t\t    unsigned int node_num);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_update_disk_slot",
          "args": [
            "osb",
            "si",
            "osb->slot_num"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_update_disk_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/slot_map.c",
          "lines": "201-220",
          "snippet": "static int ocfs2_update_disk_slot(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_slot_info *si,\n\t\t\t\t  int slot_num)\n{\n\tint status;\n\tstruct buffer_head *bh;\n\n\tspin_lock(&osb->osb_lock);\n\tif (si->si_extended)\n\t\tocfs2_update_disk_slot_extended(si, slot_num, &bh);\n\telse\n\t\tocfs2_update_disk_slot_old(si, slot_num, &bh);\n\tspin_unlock(&osb->osb_lock);\n\n\tstatus = ocfs2_write_block(osb, bh, INODE_CACHE(si->si_inode));\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_update_disk_slot(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_slot_info *si,\n\t\t\t\t  int slot_num)\n{\n\tint status;\n\tstruct buffer_head *bh;\n\n\tspin_lock(&osb->osb_lock);\n\tif (si->si_extended)\n\t\tocfs2_update_disk_slot_extended(si, slot_num, &bh);\n\telse\n\t\tocfs2_update_disk_slot_old(si, slot_num, &bh);\n\tspin_unlock(&osb->osb_lock);\n\n\tstatus = ocfs2_write_block(osb, bh, INODE_CACHE(si->si_inode));\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_find_slot",
          "args": [
            "osb->slot_num"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_set_slot",
          "args": [
            "si",
            "slot",
            "osb->node_num"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/slot_map.c",
          "lines": "72-79",
          "snippet": "static void ocfs2_set_slot(struct ocfs2_slot_info *si,\n\t\t\t   int slot_num, unsigned int node_num)\n{\n\tBUG_ON((slot_num < 0) || (slot_num >= si->si_num_slots));\n\n\tsi->si_slots[slot_num].sl_valid = 1;\n\tsi->si_slots[slot_num].sl_node_num = node_num;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __ocfs2_node_num_to_slot(struct ocfs2_slot_info *si,\n\t\t\t\t    unsigned int node_num);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int __ocfs2_node_num_to_slot(struct ocfs2_slot_info *si,\n\t\t\t\t    unsigned int node_num);\n\nstatic void ocfs2_set_slot(struct ocfs2_slot_info *si,\n\t\t\t   int slot_num, unsigned int node_num)\n{\n\tBUG_ON((slot_num < 0) || (slot_num >= si->si_num_slots));\n\n\tsi->si_slots[slot_num].sl_valid = 1;\n\tsi->si_slots[slot_num].sl_node_num = node_num;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"ocfs2: Slot %d on device (%s) was already \"\n\t\t       \"allocated to this node!\\n\"",
            "slot",
            "osb->dev_str"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"no free slots available!\\n\""
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_mask_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "36-48",
          "snippet": "static ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);",
            "struct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstruct mlog_bits mlog_and_bits = MLOG_BITS_RHS(MLOG_INITIAL_AND_MASK);\nstruct mlog_bits mlog_not_bits = MLOG_BITS_RHS(0);\n\nstatic ssize_t mlog_mask_show(u64 mask, char *buf)\n{\n\tchar *state;\n\n\tif (__mlog_test_u64(mask, mlog_and_bits))\n\t\tstate = \"allow\";\n\telse if (__mlog_test_u64(mask, mlog_not_bits))\n\t\tstate = \"deny\";\n\telse\n\t\tstate = \"off\";\n\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ocfs2_find_empty_slot",
          "args": [
            "si",
            "osb->preferred_slot"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_find_empty_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/slot_map.c",
          "lines": "267-287",
          "snippet": "static int __ocfs2_find_empty_slot(struct ocfs2_slot_info *si,\n\t\t\t\t   int preferred)\n{\n\tint i, ret = -ENOSPC;\n\n\tif ((preferred >= 0) && (preferred < si->si_num_slots)) {\n\t\tif (!si->si_slots[preferred].sl_valid) {\n\t\t\tret = preferred;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfor(i = 0; i < si->si_num_slots; i++) {\n\t\tif (!si->si_slots[i].sl_valid) {\n\t\t\tret = i;\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int __ocfs2_find_empty_slot(struct ocfs2_slot_info *si,\n\t\t\t\t   int preferred)\n{\n\tint i, ret = -ENOSPC;\n\n\tif ((preferred >= 0) && (preferred < si->si_num_slots)) {\n\t\tif (!si->si_slots[preferred].sl_valid) {\n\t\t\tret = preferred;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfor(i = 0; i < si->si_num_slots; i++) {\n\t\tif (!si->si_slots[i].sl_valid) {\n\t\t\tret = i;\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ocfs2_node_num_to_slot",
          "args": [
            "si",
            "osb->node_num"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_node_num_to_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/slot_map.c",
          "lines": "251-265",
          "snippet": "static int __ocfs2_node_num_to_slot(struct ocfs2_slot_info *si,\n\t\t\t\t    unsigned int node_num)\n{\n\tint i, ret = -ENOENT;\n\n\tfor(i = 0; i < si->si_num_slots; i++) {\n\t\tif (si->si_slots[i].sl_valid &&\n\t\t    (node_num == si->si_slots[i].sl_node_num)) {\n\t\t\tret = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __ocfs2_node_num_to_slot(struct ocfs2_slot_info *si,\n\t\t\t\t    unsigned int node_num);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int __ocfs2_node_num_to_slot(struct ocfs2_slot_info *si,\n\t\t\t\t    unsigned int node_num);\n\nstatic int __ocfs2_node_num_to_slot(struct ocfs2_slot_info *si,\n\t\t\t\t    unsigned int node_num)\n{\n\tint i, ret = -ENOENT;\n\n\tfor(i = 0; i < si->si_num_slots; i++) {\n\t\tif (si->si_slots[i].sl_valid &&\n\t\t    (node_num == si->si_slots[i].sl_node_num)) {\n\t\t\tret = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_update_slot_info",
          "args": [
            "si"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_update_slot_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/slot_map.c",
          "lines": "122-132",
          "snippet": "static void ocfs2_update_slot_info(struct ocfs2_slot_info *si)\n{\n\t/*\n\t * The slot data will have been refreshed when ocfs2_super_lock\n\t * was taken.\n\t */\n\tif (si->si_extended)\n\t\tocfs2_update_slot_info_extended(si);\n\telse\n\t\tocfs2_update_slot_info_old(si);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void ocfs2_update_slot_info(struct ocfs2_slot_info *si)\n{\n\t/*\n\t * The slot data will have been refreshed when ocfs2_super_lock\n\t * was taken.\n\t */\n\tif (si->si_extended)\n\t\tocfs2_update_slot_info_extended(si);\n\telse\n\t\tocfs2_update_slot_info_old(si);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int __ocfs2_node_num_to_slot(struct ocfs2_slot_info *si,\n\t\t\t\t    unsigned int node_num);\n\nint ocfs2_find_slot(struct ocfs2_super *osb)\n{\n\tint status;\n\tint slot;\n\tstruct ocfs2_slot_info *si;\n\n\tsi = osb->slot_info;\n\n\tspin_lock(&osb->osb_lock);\n\tocfs2_update_slot_info(si);\n\n\t/* search for ourselves first and take the slot if it already\n\t * exists. Perhaps we need to mark this in a variable for our\n\t * own journal recovery? Possibly not, though we certainly\n\t * need to warn to the user */\n\tslot = __ocfs2_node_num_to_slot(si, osb->node_num);\n\tif (slot < 0) {\n\t\t/* if no slot yet, then just take 1st available\n\t\t * one. */\n\t\tslot = __ocfs2_find_empty_slot(si, osb->preferred_slot);\n\t\tif (slot < 0) {\n\t\t\tspin_unlock(&osb->osb_lock);\n\t\t\tmlog(ML_ERROR, \"no free slots available!\\n\");\n\t\t\tstatus = -EINVAL;\n\t\t\tgoto bail;\n\t\t}\n\t} else\n\t\tprintk(KERN_INFO \"ocfs2: Slot %d on device (%s) was already \"\n\t\t       \"allocated to this node!\\n\", slot, osb->dev_str);\n\n\tocfs2_set_slot(si, slot, osb->node_num);\n\tosb->slot_num = slot;\n\tspin_unlock(&osb->osb_lock);\n\n\ttrace_ocfs2_find_slot(osb->slot_num);\n\n\tstatus = ocfs2_update_disk_slot(osb, si, osb->slot_num);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\nbail:\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_free_slot_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/slot_map.c",
    "lines": "461-467",
    "snippet": "void ocfs2_free_slot_info(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_slot_info *si = osb->slot_info;\n\n\tosb->slot_info = NULL;\n\t__ocfs2_free_slot_info(si);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ocfs2_free_slot_info",
          "args": [
            "si"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_free_slot_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/slot_map.c",
          "lines": "318-338",
          "snippet": "static void __ocfs2_free_slot_info(struct ocfs2_slot_info *si)\n{\n\tunsigned int i;\n\n\tif (si == NULL)\n\t\treturn;\n\n\tif (si->si_inode)\n\t\tiput(si->si_inode);\n\tif (si->si_bh) {\n\t\tfor (i = 0; i < si->si_blocks; i++) {\n\t\t\tif (si->si_bh[i]) {\n\t\t\t\tbrelse(si->si_bh[i]);\n\t\t\t\tsi->si_bh[i] = NULL;\n\t\t\t}\n\t\t}\n\t\tkfree(si->si_bh);\n\t}\n\n\tkfree(si);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void __ocfs2_free_slot_info(struct ocfs2_slot_info *si)\n{\n\tunsigned int i;\n\n\tif (si == NULL)\n\t\treturn;\n\n\tif (si->si_inode)\n\t\tiput(si->si_inode);\n\tif (si->si_bh) {\n\t\tfor (i = 0; i < si->si_blocks; i++) {\n\t\t\tif (si->si_bh[i]) {\n\t\t\t\tbrelse(si->si_bh[i]);\n\t\t\t\tsi->si_bh[i] = NULL;\n\t\t\t}\n\t\t}\n\t\tkfree(si->si_bh);\n\t}\n\n\tkfree(si);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nvoid ocfs2_free_slot_info(struct ocfs2_super *osb)\n{\n\tstruct ocfs2_slot_info *si = osb->slot_info;\n\n\tosb->slot_info = NULL;\n\t__ocfs2_free_slot_info(si);\n}"
  },
  {
    "function_name": "ocfs2_init_slot_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/slot_map.c",
    "lines": "418-459",
    "snippet": "int ocfs2_init_slot_info(struct ocfs2_super *osb)\n{\n\tint status;\n\tstruct inode *inode = NULL;\n\tstruct ocfs2_slot_info *si;\n\n\tsi = kzalloc(sizeof(struct ocfs2_slot_info) +\n\t\t     (sizeof(struct ocfs2_slot) * osb->max_slots),\n\t\t     GFP_KERNEL);\n\tif (!si) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tsi->si_extended = ocfs2_uses_extended_slot_map(osb);\n\tsi->si_num_slots = osb->max_slots;\n\tsi->si_slots = (struct ocfs2_slot *)((char *)si +\n\t\t\t\t\t     sizeof(struct ocfs2_slot_info));\n\n\tinode = ocfs2_get_system_file_inode(osb, SLOT_MAP_SYSTEM_INODE,\n\t\t\t\t\t    OCFS2_INVALID_SLOT);\n\tif (!inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tsi->si_inode = inode;\n\tstatus = ocfs2_map_slot_buffers(osb, si);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tosb->slot_info = (struct ocfs2_slot_info *)si;\nbail:\n\tif (status < 0 && si)\n\t\t__ocfs2_free_slot_info(si);\n\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ocfs2_free_slot_info",
          "args": [
            "si"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_free_slot_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/slot_map.c",
          "lines": "318-338",
          "snippet": "static void __ocfs2_free_slot_info(struct ocfs2_slot_info *si)\n{\n\tunsigned int i;\n\n\tif (si == NULL)\n\t\treturn;\n\n\tif (si->si_inode)\n\t\tiput(si->si_inode);\n\tif (si->si_bh) {\n\t\tfor (i = 0; i < si->si_blocks; i++) {\n\t\t\tif (si->si_bh[i]) {\n\t\t\t\tbrelse(si->si_bh[i]);\n\t\t\t\tsi->si_bh[i] = NULL;\n\t\t\t}\n\t\t}\n\t\tkfree(si->si_bh);\n\t}\n\n\tkfree(si);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void __ocfs2_free_slot_info(struct ocfs2_slot_info *si)\n{\n\tunsigned int i;\n\n\tif (si == NULL)\n\t\treturn;\n\n\tif (si->si_inode)\n\t\tiput(si->si_inode);\n\tif (si->si_bh) {\n\t\tfor (i = 0; i < si->si_blocks; i++) {\n\t\t\tif (si->si_bh[i]) {\n\t\t\t\tbrelse(si->si_bh[i]);\n\t\t\t\tsi->si_bh[i] = NULL;\n\t\t\t}\n\t\t}\n\t\tkfree(si->si_bh);\n\t}\n\n\tkfree(si);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_map_slot_buffers",
          "args": [
            "osb",
            "si"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_map_slot_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/slot_map.c",
          "lines": "354-416",
          "snippet": "static int ocfs2_map_slot_buffers(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_slot_info *si)\n{\n\tint status = 0;\n\tu64 blkno;\n\tunsigned long long blocks, bytes = 0;\n\tunsigned int i;\n\tstruct buffer_head *bh;\n\n\tstatus = ocfs2_slot_map_physical_size(osb, si->si_inode, &bytes);\n\tif (status)\n\t\tgoto bail;\n\n\tblocks = ocfs2_blocks_for_bytes(si->si_inode->i_sb, bytes);\n\tBUG_ON(blocks > UINT_MAX);\n\tsi->si_blocks = blocks;\n\tif (!si->si_blocks)\n\t\tgoto bail;\n\n\tif (si->si_extended)\n\t\tsi->si_slots_per_block =\n\t\t\t(osb->sb->s_blocksize /\n\t\t\t sizeof(struct ocfs2_extended_slot));\n\telse\n\t\tsi->si_slots_per_block = osb->sb->s_blocksize / sizeof(__le16);\n\n\t/* The size checks above should ensure this */\n\tBUG_ON((osb->max_slots / si->si_slots_per_block) > blocks);\n\n\ttrace_ocfs2_map_slot_buffers(bytes, si->si_blocks);\n\n\tsi->si_bh = kcalloc(si->si_blocks, sizeof(struct buffer_head *),\n\t\t\t    GFP_KERNEL);\n\tif (!si->si_bh) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tfor (i = 0; i < si->si_blocks; i++) {\n\t\tstatus = ocfs2_extent_map_get_blocks(si->si_inode, i,\n\t\t\t\t\t\t     &blkno, NULL, NULL);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\ttrace_ocfs2_map_slot_buffers_block((unsigned long long)blkno, i);\n\n\t\tbh = NULL;  /* Acquire a fresh bh */\n\t\tstatus = ocfs2_read_blocks(INODE_CACHE(si->si_inode), blkno,\n\t\t\t\t\t   1, &bh, OCFS2_BH_IGNORE_CACHE, NULL);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tsi->si_bh[i] = bh;\n\t}\n\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_map_slot_buffers(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_slot_info *si)\n{\n\tint status = 0;\n\tu64 blkno;\n\tunsigned long long blocks, bytes = 0;\n\tunsigned int i;\n\tstruct buffer_head *bh;\n\n\tstatus = ocfs2_slot_map_physical_size(osb, si->si_inode, &bytes);\n\tif (status)\n\t\tgoto bail;\n\n\tblocks = ocfs2_blocks_for_bytes(si->si_inode->i_sb, bytes);\n\tBUG_ON(blocks > UINT_MAX);\n\tsi->si_blocks = blocks;\n\tif (!si->si_blocks)\n\t\tgoto bail;\n\n\tif (si->si_extended)\n\t\tsi->si_slots_per_block =\n\t\t\t(osb->sb->s_blocksize /\n\t\t\t sizeof(struct ocfs2_extended_slot));\n\telse\n\t\tsi->si_slots_per_block = osb->sb->s_blocksize / sizeof(__le16);\n\n\t/* The size checks above should ensure this */\n\tBUG_ON((osb->max_slots / si->si_slots_per_block) > blocks);\n\n\ttrace_ocfs2_map_slot_buffers(bytes, si->si_blocks);\n\n\tsi->si_bh = kcalloc(si->si_blocks, sizeof(struct buffer_head *),\n\t\t\t    GFP_KERNEL);\n\tif (!si->si_bh) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tfor (i = 0; i < si->si_blocks; i++) {\n\t\tstatus = ocfs2_extent_map_get_blocks(si->si_inode, i,\n\t\t\t\t\t\t     &blkno, NULL, NULL);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\ttrace_ocfs2_map_slot_buffers_block((unsigned long long)blkno, i);\n\n\t\tbh = NULL;  /* Acquire a fresh bh */\n\t\tstatus = ocfs2_read_blocks(INODE_CACHE(si->si_inode), blkno,\n\t\t\t\t\t   1, &bh, OCFS2_BH_IGNORE_CACHE, NULL);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tsi->si_bh[i] = bh;\n\t}\n\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_system_file_inode",
          "args": [
            "osb",
            "SLOT_MAP_SYSTEM_INODE",
            "OCFS2_INVALID_SLOT"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "_ocfs2_get_system_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/sysfile.c",
          "lines": "138-181",
          "snippet": "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_uses_extended_slot_map",
          "args": [
            "osb"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_uses_extended_slot_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "673-677",
          "snippet": "static inline int ocfs2_uses_extended_slot_map(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat &\n\t\tOCFS2_FEATURE_INCOMPAT_EXTENDED_SLOT_MAP);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_uses_extended_slot_map(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat &\n\t\tOCFS2_FEATURE_INCOMPAT_EXTENDED_SLOT_MAP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct ocfs2_slot_info) +\n\t\t     (sizeof(struct ocfs2_slot) * osb->max_slots)",
            "GFP_KERNEL"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nint ocfs2_init_slot_info(struct ocfs2_super *osb)\n{\n\tint status;\n\tstruct inode *inode = NULL;\n\tstruct ocfs2_slot_info *si;\n\n\tsi = kzalloc(sizeof(struct ocfs2_slot_info) +\n\t\t     (sizeof(struct ocfs2_slot) * osb->max_slots),\n\t\t     GFP_KERNEL);\n\tif (!si) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tsi->si_extended = ocfs2_uses_extended_slot_map(osb);\n\tsi->si_num_slots = osb->max_slots;\n\tsi->si_slots = (struct ocfs2_slot *)((char *)si +\n\t\t\t\t\t     sizeof(struct ocfs2_slot_info));\n\n\tinode = ocfs2_get_system_file_inode(osb, SLOT_MAP_SYSTEM_INODE,\n\t\t\t\t\t    OCFS2_INVALID_SLOT);\n\tif (!inode) {\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tsi->si_inode = inode;\n\tstatus = ocfs2_map_slot_buffers(osb, si);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tosb->slot_info = (struct ocfs2_slot_info *)si;\nbail:\n\tif (status < 0 && si)\n\t\t__ocfs2_free_slot_info(si);\n\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_map_slot_buffers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/slot_map.c",
    "lines": "354-416",
    "snippet": "static int ocfs2_map_slot_buffers(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_slot_info *si)\n{\n\tint status = 0;\n\tu64 blkno;\n\tunsigned long long blocks, bytes = 0;\n\tunsigned int i;\n\tstruct buffer_head *bh;\n\n\tstatus = ocfs2_slot_map_physical_size(osb, si->si_inode, &bytes);\n\tif (status)\n\t\tgoto bail;\n\n\tblocks = ocfs2_blocks_for_bytes(si->si_inode->i_sb, bytes);\n\tBUG_ON(blocks > UINT_MAX);\n\tsi->si_blocks = blocks;\n\tif (!si->si_blocks)\n\t\tgoto bail;\n\n\tif (si->si_extended)\n\t\tsi->si_slots_per_block =\n\t\t\t(osb->sb->s_blocksize /\n\t\t\t sizeof(struct ocfs2_extended_slot));\n\telse\n\t\tsi->si_slots_per_block = osb->sb->s_blocksize / sizeof(__le16);\n\n\t/* The size checks above should ensure this */\n\tBUG_ON((osb->max_slots / si->si_slots_per_block) > blocks);\n\n\ttrace_ocfs2_map_slot_buffers(bytes, si->si_blocks);\n\n\tsi->si_bh = kcalloc(si->si_blocks, sizeof(struct buffer_head *),\n\t\t\t    GFP_KERNEL);\n\tif (!si->si_bh) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tfor (i = 0; i < si->si_blocks; i++) {\n\t\tstatus = ocfs2_extent_map_get_blocks(si->si_inode, i,\n\t\t\t\t\t\t     &blkno, NULL, NULL);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\ttrace_ocfs2_map_slot_buffers_block((unsigned long long)blkno, i);\n\n\t\tbh = NULL;  /* Acquire a fresh bh */\n\t\tstatus = ocfs2_read_blocks(INODE_CACHE(si->si_inode), blkno,\n\t\t\t\t\t   1, &bh, OCFS2_BH_IGNORE_CACHE, NULL);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tsi->si_bh[i] = bh;\n\t}\n\nbail:\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_blocks",
          "args": [
            "INODE_CACHE(si->si_inode)",
            "blkno",
            "1",
            "&bh",
            "OCFS2_BH_IGNORE_CACHE",
            "NULL"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/buffer_head_io.c",
          "lines": "176-366",
          "snippet": "int ocfs2_read_blocks(struct ocfs2_caching_info *ci, u64 block, int nr,\n\t\t      struct buffer_head *bhs[], int flags,\n\t\t      int (*validate)(struct super_block *sb,\n\t\t\t\t      struct buffer_head *bh))\n{\n\tint status = 0;\n\tint i, ignore_cache = 0;\n\tstruct buffer_head *bh;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\n\n\ttrace_ocfs2_read_blocks_begin(ci, (unsigned long long)block, nr, flags);\n\n\tBUG_ON(!ci);\n\tBUG_ON((flags & OCFS2_BH_READAHEAD) &&\n\t       (flags & OCFS2_BH_IGNORE_CACHE));\n\n\tif (bhs == NULL) {\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tif (nr < 0) {\n\t\tmlog(ML_ERROR, \"asked to read %d blocks!\\n\", nr);\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tif (nr == 0) {\n\t\tstatus = 0;\n\t\tgoto bail;\n\t}\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tfor (i = 0 ; i < nr ; i++) {\n\t\tif (bhs[i] == NULL) {\n\t\t\tbhs[i] = sb_getblk(sb, block++);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tocfs2_metadata_cache_io_unlock(ci);\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tbh = bhs[i];\n\t\tignore_cache = (flags & OCFS2_BH_IGNORE_CACHE);\n\n\t\t/* There are three read-ahead cases here which we need to\n\t\t * be concerned with. All three assume a buffer has\n\t\t * previously been submitted with OCFS2_BH_READAHEAD\n\t\t * and it hasn't yet completed I/O.\n\t\t *\n\t\t * 1) The current request is sync to disk. This rarely\n\t\t *    happens these days, and never when performance\n\t\t *    matters - the code can just wait on the buffer\n\t\t *    lock and re-submit.\n\t\t *\n\t\t * 2) The current request is cached, but not\n\t\t *    readahead. ocfs2_buffer_uptodate() will return\n\t\t *    false anyway, so we'll wind up waiting on the\n\t\t *    buffer lock to do I/O. We re-check the request\n\t\t *    with after getting the lock to avoid a re-submit.\n\t\t *\n\t\t * 3) The current request is readahead (and so must\n\t\t *    also be a caching one). We short circuit if the\n\t\t *    buffer is locked (under I/O) and if it's in the\n\t\t *    uptodate cache. The re-check from #2 catches the\n\t\t *    case that the previous read-ahead completes just\n\t\t *    before our is-it-in-flight check.\n\t\t */\n\n\t\tif (!ignore_cache && !ocfs2_buffer_uptodate(ci, bh)) {\n\t\t\ttrace_ocfs2_read_blocks_from_disk(\n\t\t\t     (unsigned long long)bh->b_blocknr,\n\t\t\t     (unsigned long long)ocfs2_metadata_cache_owner(ci));\n\t\t\t/* We're using ignore_cache here to say\n\t\t\t * \"go to disk\" */\n\t\t\tignore_cache = 1;\n\t\t}\n\n\t\ttrace_ocfs2_read_blocks_bh((unsigned long long)bh->b_blocknr,\n\t\t\tignore_cache, buffer_jbd(bh), buffer_dirty(bh));\n\n\t\tif (buffer_jbd(bh)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ignore_cache) {\n\t\t\tif (buffer_dirty(bh)) {\n\t\t\t\t/* This should probably be a BUG, or\n\t\t\t\t * at least return an error. */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* A read-ahead request was made - if the\n\t\t\t * buffer is already under read-ahead from a\n\t\t\t * previously submitted request than we are\n\t\t\t * done here. */\n\t\t\tif ((flags & OCFS2_BH_READAHEAD)\n\t\t\t    && ocfs2_buffer_read_ahead(ci, bh))\n\t\t\t\tcontinue;\n\n\t\t\tlock_buffer(bh);\n\t\t\tif (buffer_jbd(bh)) {\n#ifdef CATCH_BH_JBD_RACES\n\t\t\t\tmlog(ML_ERROR, \"block %llu had the JBD bit set \"\n\t\t\t\t\t       \"while I was in lock_buffer!\",\n\t\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\t\tBUG();\n#else\n\t\t\t\tunlock_buffer(bh);\n\t\t\t\tcontinue;\n#endif\n\t\t\t}\n\n\t\t\t/* Re-check ocfs2_buffer_uptodate() as a\n\t\t\t * previously read-ahead buffer may have\n\t\t\t * completed I/O while we were waiting for the\n\t\t\t * buffer lock. */\n\t\t\tif (!(flags & OCFS2_BH_IGNORE_CACHE)\n\t\t\t    && !(flags & OCFS2_BH_READAHEAD)\n\t\t\t    && ocfs2_buffer_uptodate(ci, bh)) {\n\t\t\t\tunlock_buffer(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tclear_buffer_uptodate(bh);\n\t\t\tget_bh(bh); /* for end_buffer_read_sync() */\n\t\t\tif (validate)\n\t\t\t\tset_buffer_needs_validate(bh);\n\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\tsubmit_bh(READ, bh);\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tstatus = 0;\n\n\tfor (i = (nr - 1); i >= 0; i--) {\n\t\tbh = bhs[i];\n\n\t\tif (!(flags & OCFS2_BH_READAHEAD)) {\n\t\t\t/* We know this can't have changed as we hold the\n\t\t\t * owner sem. Avoid doing any work on the bh if the\n\t\t\t * journal has it. */\n\t\t\tif (!buffer_jbd(bh))\n\t\t\t\twait_on_buffer(bh);\n\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\t/* Status won't be cleared from here on out,\n\t\t\t\t * so we can safely record this and loop back\n\t\t\t\t * to cleanup the other buffers. Don't need to\n\t\t\t\t * remove the clustered uptodate information\n\t\t\t\t * for this bh as it's not marked locally\n\t\t\t\t * uptodate. */\n\t\t\t\tstatus = -EIO;\n\t\t\t\tput_bh(bh);\n\t\t\t\tbhs[i] = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (buffer_needs_validate(bh)) {\n\t\t\t\t/* We never set NeedsValidate if the\n\t\t\t\t * buffer was held by the journal, so\n\t\t\t\t * that better not have changed */\n\t\t\t\tBUG_ON(buffer_jbd(bh));\n\t\t\t\tclear_buffer_needs_validate(bh);\n\t\t\t\tstatus = validate(sb, bh);\n\t\t\t\tif (status) {\n\t\t\t\t\tput_bh(bh);\n\t\t\t\t\tbhs[i] = NULL;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Always set the buffer in the cache, even if it was\n\t\t * a forced read, or read-ahead which hasn't yet\n\t\t * completed. */\n\t\tocfs2_set_buffer_uptodate(ci, bh);\n\t}\n\tocfs2_metadata_cache_io_unlock(ci);\n\n\ttrace_ocfs2_read_blocks_end((unsigned long long)block, nr,\n\t\t\t\t    flags, ignore_cache);\n\nbail:\n\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_blocks(struct ocfs2_caching_info *ci, u64 block, int nr,\n\t\t      struct buffer_head *bhs[], int flags,\n\t\t      int (*validate)(struct super_block *sb,\n\t\t\t\t      struct buffer_head *bh))\n{\n\tint status = 0;\n\tint i, ignore_cache = 0;\n\tstruct buffer_head *bh;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\n\n\ttrace_ocfs2_read_blocks_begin(ci, (unsigned long long)block, nr, flags);\n\n\tBUG_ON(!ci);\n\tBUG_ON((flags & OCFS2_BH_READAHEAD) &&\n\t       (flags & OCFS2_BH_IGNORE_CACHE));\n\n\tif (bhs == NULL) {\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tif (nr < 0) {\n\t\tmlog(ML_ERROR, \"asked to read %d blocks!\\n\", nr);\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tif (nr == 0) {\n\t\tstatus = 0;\n\t\tgoto bail;\n\t}\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tfor (i = 0 ; i < nr ; i++) {\n\t\tif (bhs[i] == NULL) {\n\t\t\tbhs[i] = sb_getblk(sb, block++);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tocfs2_metadata_cache_io_unlock(ci);\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tbh = bhs[i];\n\t\tignore_cache = (flags & OCFS2_BH_IGNORE_CACHE);\n\n\t\t/* There are three read-ahead cases here which we need to\n\t\t * be concerned with. All three assume a buffer has\n\t\t * previously been submitted with OCFS2_BH_READAHEAD\n\t\t * and it hasn't yet completed I/O.\n\t\t *\n\t\t * 1) The current request is sync to disk. This rarely\n\t\t *    happens these days, and never when performance\n\t\t *    matters - the code can just wait on the buffer\n\t\t *    lock and re-submit.\n\t\t *\n\t\t * 2) The current request is cached, but not\n\t\t *    readahead. ocfs2_buffer_uptodate() will return\n\t\t *    false anyway, so we'll wind up waiting on the\n\t\t *    buffer lock to do I/O. We re-check the request\n\t\t *    with after getting the lock to avoid a re-submit.\n\t\t *\n\t\t * 3) The current request is readahead (and so must\n\t\t *    also be a caching one). We short circuit if the\n\t\t *    buffer is locked (under I/O) and if it's in the\n\t\t *    uptodate cache. The re-check from #2 catches the\n\t\t *    case that the previous read-ahead completes just\n\t\t *    before our is-it-in-flight check.\n\t\t */\n\n\t\tif (!ignore_cache && !ocfs2_buffer_uptodate(ci, bh)) {\n\t\t\ttrace_ocfs2_read_blocks_from_disk(\n\t\t\t     (unsigned long long)bh->b_blocknr,\n\t\t\t     (unsigned long long)ocfs2_metadata_cache_owner(ci));\n\t\t\t/* We're using ignore_cache here to say\n\t\t\t * \"go to disk\" */\n\t\t\tignore_cache = 1;\n\t\t}\n\n\t\ttrace_ocfs2_read_blocks_bh((unsigned long long)bh->b_blocknr,\n\t\t\tignore_cache, buffer_jbd(bh), buffer_dirty(bh));\n\n\t\tif (buffer_jbd(bh)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ignore_cache) {\n\t\t\tif (buffer_dirty(bh)) {\n\t\t\t\t/* This should probably be a BUG, or\n\t\t\t\t * at least return an error. */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* A read-ahead request was made - if the\n\t\t\t * buffer is already under read-ahead from a\n\t\t\t * previously submitted request than we are\n\t\t\t * done here. */\n\t\t\tif ((flags & OCFS2_BH_READAHEAD)\n\t\t\t    && ocfs2_buffer_read_ahead(ci, bh))\n\t\t\t\tcontinue;\n\n\t\t\tlock_buffer(bh);\n\t\t\tif (buffer_jbd(bh)) {\n#ifdef CATCH_BH_JBD_RACES\n\t\t\t\tmlog(ML_ERROR, \"block %llu had the JBD bit set \"\n\t\t\t\t\t       \"while I was in lock_buffer!\",\n\t\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\t\tBUG();\n#else\n\t\t\t\tunlock_buffer(bh);\n\t\t\t\tcontinue;\n#endif\n\t\t\t}\n\n\t\t\t/* Re-check ocfs2_buffer_uptodate() as a\n\t\t\t * previously read-ahead buffer may have\n\t\t\t * completed I/O while we were waiting for the\n\t\t\t * buffer lock. */\n\t\t\tif (!(flags & OCFS2_BH_IGNORE_CACHE)\n\t\t\t    && !(flags & OCFS2_BH_READAHEAD)\n\t\t\t    && ocfs2_buffer_uptodate(ci, bh)) {\n\t\t\t\tunlock_buffer(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tclear_buffer_uptodate(bh);\n\t\t\tget_bh(bh); /* for end_buffer_read_sync() */\n\t\t\tif (validate)\n\t\t\t\tset_buffer_needs_validate(bh);\n\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\tsubmit_bh(READ, bh);\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tstatus = 0;\n\n\tfor (i = (nr - 1); i >= 0; i--) {\n\t\tbh = bhs[i];\n\n\t\tif (!(flags & OCFS2_BH_READAHEAD)) {\n\t\t\t/* We know this can't have changed as we hold the\n\t\t\t * owner sem. Avoid doing any work on the bh if the\n\t\t\t * journal has it. */\n\t\t\tif (!buffer_jbd(bh))\n\t\t\t\twait_on_buffer(bh);\n\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\t/* Status won't be cleared from here on out,\n\t\t\t\t * so we can safely record this and loop back\n\t\t\t\t * to cleanup the other buffers. Don't need to\n\t\t\t\t * remove the clustered uptodate information\n\t\t\t\t * for this bh as it's not marked locally\n\t\t\t\t * uptodate. */\n\t\t\t\tstatus = -EIO;\n\t\t\t\tput_bh(bh);\n\t\t\t\tbhs[i] = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (buffer_needs_validate(bh)) {\n\t\t\t\t/* We never set NeedsValidate if the\n\t\t\t\t * buffer was held by the journal, so\n\t\t\t\t * that better not have changed */\n\t\t\t\tBUG_ON(buffer_jbd(bh));\n\t\t\t\tclear_buffer_needs_validate(bh);\n\t\t\t\tstatus = validate(sb, bh);\n\t\t\t\tif (status) {\n\t\t\t\t\tput_bh(bh);\n\t\t\t\t\tbhs[i] = NULL;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Always set the buffer in the cache, even if it was\n\t\t * a forced read, or read-ahead which hasn't yet\n\t\t * completed. */\n\t\tocfs2_set_buffer_uptodate(ci, bh);\n\t}\n\tocfs2_metadata_cache_io_unlock(ci);\n\n\ttrace_ocfs2_read_blocks_end((unsigned long long)block, nr,\n\t\t\t\t    flags, ignore_cache);\n\nbail:\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "si->si_inode"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_map_slot_buffers_block",
          "args": [
            "(unsigned long long)blkno",
            "i"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_extent_map_get_blocks",
          "args": [
            "si->si_inode",
            "i",
            "&blkno",
            "NULL",
            "NULL"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extent_map_get_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
          "lines": "671-705",
          "snippet": "int ocfs2_extent_map_get_blocks(struct inode *inode, u64 v_blkno, u64 *p_blkno,\n\t\t\t\tu64 *ret_count, unsigned int *extent_flags)\n{\n\tint ret;\n\tint bpc = ocfs2_clusters_to_blocks(inode->i_sb, 1);\n\tu32 cpos, num_clusters, p_cluster;\n\tu64 boff = 0;\n\n\tcpos = ocfs2_blocks_to_clusters(inode->i_sb, v_blkno);\n\n\tret = ocfs2_get_clusters(inode, cpos, &p_cluster, &num_clusters,\n\t\t\t\t extent_flags);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * p_cluster == 0 indicates a hole.\n\t */\n\tif (p_cluster) {\n\t\tboff = ocfs2_clusters_to_blocks(inode->i_sb, p_cluster);\n\t\tboff += (v_blkno & (u64)(bpc - 1));\n\t}\n\n\t*p_blkno = boff;\n\n\tif (ret_count) {\n\t\t*ret_count = ocfs2_clusters_to_blocks(inode->i_sb, num_clusters);\n\t\t*ret_count -= v_blkno & (u64)(bpc - 1);\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nint ocfs2_extent_map_get_blocks(struct inode *inode, u64 v_blkno, u64 *p_blkno,\n\t\t\t\tu64 *ret_count, unsigned int *extent_flags)\n{\n\tint ret;\n\tint bpc = ocfs2_clusters_to_blocks(inode->i_sb, 1);\n\tu32 cpos, num_clusters, p_cluster;\n\tu64 boff = 0;\n\n\tcpos = ocfs2_blocks_to_clusters(inode->i_sb, v_blkno);\n\n\tret = ocfs2_get_clusters(inode, cpos, &p_cluster, &num_clusters,\n\t\t\t\t extent_flags);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * p_cluster == 0 indicates a hole.\n\t */\n\tif (p_cluster) {\n\t\tboff = ocfs2_clusters_to_blocks(inode->i_sb, p_cluster);\n\t\tboff += (v_blkno & (u64)(bpc - 1));\n\t}\n\n\t*p_blkno = boff;\n\n\tif (ret_count) {\n\t\t*ret_count = ocfs2_clusters_to_blocks(inode->i_sb, num_clusters);\n\t\t*ret_count -= v_blkno & (u64)(bpc - 1);\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "si->si_blocks",
            "sizeof(struct buffer_head *)",
            "GFP_KERNEL"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_map_slot_buffers",
          "args": [
            "bytes",
            "si->si_blocks"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "(osb->max_slots / si->si_slots_per_block) > blocks"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "blocks > UINT_MAX"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_blocks_for_bytes",
          "args": [
            "si->si_inode->i_sb",
            "bytes"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_blocks_for_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "752-757",
          "snippet": "static inline u64 ocfs2_blocks_for_bytes(struct super_block *sb,\n\t\t\t\t\t u64 bytes)\n{\n\tbytes += sb->s_blocksize - 1;\n\treturn bytes >> sb->s_blocksize_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_blocks_for_bytes(struct super_block *sb,\n\t\t\t\t\t u64 bytes)\n{\n\tbytes += sb->s_blocksize - 1;\n\treturn bytes >> sb->s_blocksize_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_slot_map_physical_size",
          "args": [
            "osb",
            "si->si_inode",
            "&bytes"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_slot_map_physical_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/slot_map.c",
          "lines": "226-247",
          "snippet": "static int ocfs2_slot_map_physical_size(struct ocfs2_super *osb,\n\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\tunsigned long long *bytes)\n{\n\tunsigned long long bytes_needed;\n\n\tif (ocfs2_uses_extended_slot_map(osb)) {\n\t\tbytes_needed = osb->max_slots *\n\t\t\tsizeof(struct ocfs2_extended_slot);\n\t} else {\n\t\tbytes_needed = osb->max_slots * sizeof(__le16);\n\t}\n\tif (bytes_needed > i_size_read(inode)) {\n\t\tmlog(ML_ERROR,\n\t\t     \"Slot map file is too small!  (size %llu, needed %llu)\\n\",\n\t\t     i_size_read(inode), bytes_needed);\n\t\treturn -ENOSPC;\n\t}\n\n\t*bytes = bytes_needed;\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_slot_map_physical_size(struct ocfs2_super *osb,\n\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\tunsigned long long *bytes)\n{\n\tunsigned long long bytes_needed;\n\n\tif (ocfs2_uses_extended_slot_map(osb)) {\n\t\tbytes_needed = osb->max_slots *\n\t\t\tsizeof(struct ocfs2_extended_slot);\n\t} else {\n\t\tbytes_needed = osb->max_slots * sizeof(__le16);\n\t}\n\tif (bytes_needed > i_size_read(inode)) {\n\t\tmlog(ML_ERROR,\n\t\t     \"Slot map file is too small!  (size %llu, needed %llu)\\n\",\n\t\t     i_size_read(inode), bytes_needed);\n\t\treturn -ENOSPC;\n\t}\n\n\t*bytes = bytes_needed;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_map_slot_buffers(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_slot_info *si)\n{\n\tint status = 0;\n\tu64 blkno;\n\tunsigned long long blocks, bytes = 0;\n\tunsigned int i;\n\tstruct buffer_head *bh;\n\n\tstatus = ocfs2_slot_map_physical_size(osb, si->si_inode, &bytes);\n\tif (status)\n\t\tgoto bail;\n\n\tblocks = ocfs2_blocks_for_bytes(si->si_inode->i_sb, bytes);\n\tBUG_ON(blocks > UINT_MAX);\n\tsi->si_blocks = blocks;\n\tif (!si->si_blocks)\n\t\tgoto bail;\n\n\tif (si->si_extended)\n\t\tsi->si_slots_per_block =\n\t\t\t(osb->sb->s_blocksize /\n\t\t\t sizeof(struct ocfs2_extended_slot));\n\telse\n\t\tsi->si_slots_per_block = osb->sb->s_blocksize / sizeof(__le16);\n\n\t/* The size checks above should ensure this */\n\tBUG_ON((osb->max_slots / si->si_slots_per_block) > blocks);\n\n\ttrace_ocfs2_map_slot_buffers(bytes, si->si_blocks);\n\n\tsi->si_bh = kcalloc(si->si_blocks, sizeof(struct buffer_head *),\n\t\t\t    GFP_KERNEL);\n\tif (!si->si_bh) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tfor (i = 0; i < si->si_blocks; i++) {\n\t\tstatus = ocfs2_extent_map_get_blocks(si->si_inode, i,\n\t\t\t\t\t\t     &blkno, NULL, NULL);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\ttrace_ocfs2_map_slot_buffers_block((unsigned long long)blkno, i);\n\n\t\tbh = NULL;  /* Acquire a fresh bh */\n\t\tstatus = ocfs2_read_blocks(INODE_CACHE(si->si_inode), blkno,\n\t\t\t\t\t   1, &bh, OCFS2_BH_IGNORE_CACHE, NULL);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tsi->si_bh[i] = bh;\n\t}\n\nbail:\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_clear_slot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/slot_map.c",
    "lines": "340-352",
    "snippet": "int ocfs2_clear_slot(struct ocfs2_super *osb, int slot_num)\n{\n\tstruct ocfs2_slot_info *si = osb->slot_info;\n\n\tif (si == NULL)\n\t\treturn 0;\n\n\tspin_lock(&osb->osb_lock);\n\tocfs2_invalidate_slot(si, slot_num);\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ocfs2_update_disk_slot(osb, osb->slot_info, slot_num);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_update_disk_slot",
          "args": [
            "osb",
            "osb->slot_info",
            "slot_num"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_update_disk_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/slot_map.c",
          "lines": "201-220",
          "snippet": "static int ocfs2_update_disk_slot(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_slot_info *si,\n\t\t\t\t  int slot_num)\n{\n\tint status;\n\tstruct buffer_head *bh;\n\n\tspin_lock(&osb->osb_lock);\n\tif (si->si_extended)\n\t\tocfs2_update_disk_slot_extended(si, slot_num, &bh);\n\telse\n\t\tocfs2_update_disk_slot_old(si, slot_num, &bh);\n\tspin_unlock(&osb->osb_lock);\n\n\tstatus = ocfs2_write_block(osb, bh, INODE_CACHE(si->si_inode));\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_update_disk_slot(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_slot_info *si,\n\t\t\t\t  int slot_num)\n{\n\tint status;\n\tstruct buffer_head *bh;\n\n\tspin_lock(&osb->osb_lock);\n\tif (si->si_extended)\n\t\tocfs2_update_disk_slot_extended(si, slot_num, &bh);\n\telse\n\t\tocfs2_update_disk_slot_old(si, slot_num, &bh);\n\tspin_unlock(&osb->osb_lock);\n\n\tstatus = ocfs2_write_block(osb, bh, INODE_CACHE(si->si_inode));\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_invalidate_slot",
          "args": [
            "si",
            "slot_num"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_invalidate_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/slot_map.c",
          "lines": "65-70",
          "snippet": "static void ocfs2_invalidate_slot(struct ocfs2_slot_info *si,\n\t\t\t\t  int slot_num)\n{\n\tBUG_ON((slot_num < 0) || (slot_num >= si->si_num_slots));\n\tsi->si_slots[slot_num].sl_valid = 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void ocfs2_invalidate_slot(struct ocfs2_slot_info *si,\n\t\t\t\t  int slot_num)\n{\n\tBUG_ON((slot_num < 0) || (slot_num >= si->si_num_slots));\n\tsi->si_slots[slot_num].sl_valid = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nint ocfs2_clear_slot(struct ocfs2_super *osb, int slot_num)\n{\n\tstruct ocfs2_slot_info *si = osb->slot_info;\n\n\tif (si == NULL)\n\t\treturn 0;\n\n\tspin_lock(&osb->osb_lock);\n\tocfs2_invalidate_slot(si, slot_num);\n\tspin_unlock(&osb->osb_lock);\n\n\treturn ocfs2_update_disk_slot(osb, osb->slot_info, slot_num);\n}"
  },
  {
    "function_name": "__ocfs2_free_slot_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/slot_map.c",
    "lines": "318-338",
    "snippet": "static void __ocfs2_free_slot_info(struct ocfs2_slot_info *si)\n{\n\tunsigned int i;\n\n\tif (si == NULL)\n\t\treturn;\n\n\tif (si->si_inode)\n\t\tiput(si->si_inode);\n\tif (si->si_bh) {\n\t\tfor (i = 0; i < si->si_blocks; i++) {\n\t\t\tif (si->si_bh[i]) {\n\t\t\t\tbrelse(si->si_bh[i]);\n\t\t\t\tsi->si_bh[i] = NULL;\n\t\t\t}\n\t\t}\n\t\tkfree(si->si_bh);\n\t}\n\n\tkfree(si);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "si"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "si->si_bh"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "si->si_bh[i]"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "si->si_inode"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void __ocfs2_free_slot_info(struct ocfs2_slot_info *si)\n{\n\tunsigned int i;\n\n\tif (si == NULL)\n\t\treturn;\n\n\tif (si->si_inode)\n\t\tiput(si->si_inode);\n\tif (si->si_bh) {\n\t\tfor (i = 0; i < si->si_blocks; i++) {\n\t\t\tif (si->si_bh[i]) {\n\t\t\t\tbrelse(si->si_bh[i]);\n\t\t\t\tsi->si_bh[i] = NULL;\n\t\t\t}\n\t\t}\n\t\tkfree(si->si_bh);\n\t}\n\n\tkfree(si);\n}"
  },
  {
    "function_name": "ocfs2_slot_to_node_num_locked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/slot_map.c",
    "lines": "301-316",
    "snippet": "int ocfs2_slot_to_node_num_locked(struct ocfs2_super *osb, int slot_num,\n\t\t\t\t  unsigned int *node_num)\n{\n\tstruct ocfs2_slot_info *si = osb->slot_info;\n\n\tassert_spin_locked(&osb->osb_lock);\n\n\tBUG_ON(slot_num < 0);\n\tBUG_ON(slot_num >= osb->max_slots);\n\n\tif (!si->si_slots[slot_num].sl_valid)\n\t\treturn -ENOENT;\n\n\t*node_num = si->si_slots[slot_num].sl_node_num;\n\treturn 0;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __ocfs2_node_num_to_slot(struct ocfs2_slot_info *si,\n\t\t\t\t    unsigned int node_num);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "slot_num >= osb->max_slots"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "slot_num < 0"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int __ocfs2_node_num_to_slot(struct ocfs2_slot_info *si,\n\t\t\t\t    unsigned int node_num);\n\nint ocfs2_slot_to_node_num_locked(struct ocfs2_super *osb, int slot_num,\n\t\t\t\t  unsigned int *node_num)\n{\n\tstruct ocfs2_slot_info *si = osb->slot_info;\n\n\tassert_spin_locked(&osb->osb_lock);\n\n\tBUG_ON(slot_num < 0);\n\tBUG_ON(slot_num >= osb->max_slots);\n\n\tif (!si->si_slots[slot_num].sl_valid)\n\t\treturn -ENOENT;\n\n\t*node_num = si->si_slots[slot_num].sl_node_num;\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_node_num_to_slot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/slot_map.c",
    "lines": "289-299",
    "snippet": "int ocfs2_node_num_to_slot(struct ocfs2_super *osb, unsigned int node_num)\n{\n\tint slot;\n\tstruct ocfs2_slot_info *si = osb->slot_info;\n\n\tspin_lock(&osb->osb_lock);\n\tslot = __ocfs2_node_num_to_slot(si, node_num);\n\tspin_unlock(&osb->osb_lock);\n\n\treturn slot;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __ocfs2_node_num_to_slot(struct ocfs2_slot_info *si,\n\t\t\t\t    unsigned int node_num);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ocfs2_node_num_to_slot",
          "args": [
            "si",
            "node_num"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_node_num_to_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/slot_map.c",
          "lines": "251-265",
          "snippet": "static int __ocfs2_node_num_to_slot(struct ocfs2_slot_info *si,\n\t\t\t\t    unsigned int node_num)\n{\n\tint i, ret = -ENOENT;\n\n\tfor(i = 0; i < si->si_num_slots; i++) {\n\t\tif (si->si_slots[i].sl_valid &&\n\t\t    (node_num == si->si_slots[i].sl_node_num)) {\n\t\t\tret = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __ocfs2_node_num_to_slot(struct ocfs2_slot_info *si,\n\t\t\t\t    unsigned int node_num);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int __ocfs2_node_num_to_slot(struct ocfs2_slot_info *si,\n\t\t\t\t    unsigned int node_num);\n\nstatic int __ocfs2_node_num_to_slot(struct ocfs2_slot_info *si,\n\t\t\t\t    unsigned int node_num)\n{\n\tint i, ret = -ENOENT;\n\n\tfor(i = 0; i < si->si_num_slots; i++) {\n\t\tif (si->si_slots[i].sl_valid &&\n\t\t    (node_num == si->si_slots[i].sl_node_num)) {\n\t\t\tret = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int __ocfs2_node_num_to_slot(struct ocfs2_slot_info *si,\n\t\t\t\t    unsigned int node_num);\n\nint ocfs2_node_num_to_slot(struct ocfs2_super *osb, unsigned int node_num)\n{\n\tint slot;\n\tstruct ocfs2_slot_info *si = osb->slot_info;\n\n\tspin_lock(&osb->osb_lock);\n\tslot = __ocfs2_node_num_to_slot(si, node_num);\n\tspin_unlock(&osb->osb_lock);\n\n\treturn slot;\n}"
  },
  {
    "function_name": "__ocfs2_find_empty_slot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/slot_map.c",
    "lines": "267-287",
    "snippet": "static int __ocfs2_find_empty_slot(struct ocfs2_slot_info *si,\n\t\t\t\t   int preferred)\n{\n\tint i, ret = -ENOSPC;\n\n\tif ((preferred >= 0) && (preferred < si->si_num_slots)) {\n\t\tif (!si->si_slots[preferred].sl_valid) {\n\t\t\tret = preferred;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfor(i = 0; i < si->si_num_slots; i++) {\n\t\tif (!si->si_slots[i].sl_valid) {\n\t\t\tret = i;\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int __ocfs2_find_empty_slot(struct ocfs2_slot_info *si,\n\t\t\t\t   int preferred)\n{\n\tint i, ret = -ENOSPC;\n\n\tif ((preferred >= 0) && (preferred < si->si_num_slots)) {\n\t\tif (!si->si_slots[preferred].sl_valid) {\n\t\t\tret = preferred;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfor(i = 0; i < si->si_num_slots; i++) {\n\t\tif (!si->si_slots[i].sl_valid) {\n\t\t\tret = i;\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "__ocfs2_node_num_to_slot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/slot_map.c",
    "lines": "251-265",
    "snippet": "static int __ocfs2_node_num_to_slot(struct ocfs2_slot_info *si,\n\t\t\t\t    unsigned int node_num)\n{\n\tint i, ret = -ENOENT;\n\n\tfor(i = 0; i < si->si_num_slots; i++) {\n\t\tif (si->si_slots[i].sl_valid &&\n\t\t    (node_num == si->si_slots[i].sl_node_num)) {\n\t\t\tret = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __ocfs2_node_num_to_slot(struct ocfs2_slot_info *si,\n\t\t\t\t    unsigned int node_num);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int __ocfs2_node_num_to_slot(struct ocfs2_slot_info *si,\n\t\t\t\t    unsigned int node_num);\n\nstatic int __ocfs2_node_num_to_slot(struct ocfs2_slot_info *si,\n\t\t\t\t    unsigned int node_num)\n{\n\tint i, ret = -ENOENT;\n\n\tfor(i = 0; i < si->si_num_slots; i++) {\n\t\tif (si->si_slots[i].sl_valid &&\n\t\t    (node_num == si->si_slots[i].sl_node_num)) {\n\t\t\tret = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_slot_map_physical_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/slot_map.c",
    "lines": "226-247",
    "snippet": "static int ocfs2_slot_map_physical_size(struct ocfs2_super *osb,\n\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\tunsigned long long *bytes)\n{\n\tunsigned long long bytes_needed;\n\n\tif (ocfs2_uses_extended_slot_map(osb)) {\n\t\tbytes_needed = osb->max_slots *\n\t\t\tsizeof(struct ocfs2_extended_slot);\n\t} else {\n\t\tbytes_needed = osb->max_slots * sizeof(__le16);\n\t}\n\tif (bytes_needed > i_size_read(inode)) {\n\t\tmlog(ML_ERROR,\n\t\t     \"Slot map file is too small!  (size %llu, needed %llu)\\n\",\n\t\t     i_size_read(inode), bytes_needed);\n\t\treturn -ENOSPC;\n\t}\n\n\t*bytes = bytes_needed;\n\treturn 0;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Slot map file is too small!  (size %llu, needed %llu)\\n\"",
            "i_size_read(inode)",
            "bytes_needed"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_store",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "115-121",
          "snippet": "static ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_store(struct kobject *obj, struct attribute *attr,\n\t\t\t  const char *buf, size_t count)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_store(mlog_attr->mask, buf, count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_uses_extended_slot_map",
          "args": [
            "osb"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_uses_extended_slot_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "673-677",
          "snippet": "static inline int ocfs2_uses_extended_slot_map(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat &\n\t\tOCFS2_FEATURE_INCOMPAT_EXTENDED_SLOT_MAP);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_uses_extended_slot_map(struct ocfs2_super *osb)\n{\n\treturn (osb->s_feature_incompat &\n\t\tOCFS2_FEATURE_INCOMPAT_EXTENDED_SLOT_MAP);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_slot_map_physical_size(struct ocfs2_super *osb,\n\t\t\t\t\tstruct inode *inode,\n\t\t\t\t\tunsigned long long *bytes)\n{\n\tunsigned long long bytes_needed;\n\n\tif (ocfs2_uses_extended_slot_map(osb)) {\n\t\tbytes_needed = osb->max_slots *\n\t\t\tsizeof(struct ocfs2_extended_slot);\n\t} else {\n\t\tbytes_needed = osb->max_slots * sizeof(__le16);\n\t}\n\tif (bytes_needed > i_size_read(inode)) {\n\t\tmlog(ML_ERROR,\n\t\t     \"Slot map file is too small!  (size %llu, needed %llu)\\n\",\n\t\t     i_size_read(inode), bytes_needed);\n\t\treturn -ENOSPC;\n\t}\n\n\t*bytes = bytes_needed;\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_update_disk_slot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/slot_map.c",
    "lines": "201-220",
    "snippet": "static int ocfs2_update_disk_slot(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_slot_info *si,\n\t\t\t\t  int slot_num)\n{\n\tint status;\n\tstruct buffer_head *bh;\n\n\tspin_lock(&osb->osb_lock);\n\tif (si->si_extended)\n\t\tocfs2_update_disk_slot_extended(si, slot_num, &bh);\n\telse\n\t\tocfs2_update_disk_slot_old(si, slot_num, &bh);\n\tspin_unlock(&osb->osb_lock);\n\n\tstatus = ocfs2_write_block(osb, bh, INODE_CACHE(si->si_inode));\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\treturn status;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "status"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_write_block",
          "args": [
            "osb",
            "bh",
            "INODE_CACHE(si->si_inode)"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_write_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/buffer_head_io.c",
          "lines": "53-99",
          "snippet": "int ocfs2_write_block(struct ocfs2_super *osb, struct buffer_head *bh,\n\t\t      struct ocfs2_caching_info *ci)\n{\n\tint ret = 0;\n\n\ttrace_ocfs2_write_block((unsigned long long)bh->b_blocknr, ci);\n\n\tBUG_ON(bh->b_blocknr < OCFS2_SUPER_BLOCK_BLKNO);\n\tBUG_ON(buffer_jbd(bh));\n\n\t/* No need to check for a soft readonly file system here. non\n\t * journalled writes are only ever done on system files which\n\t * can get modified during recovery even if read-only. */\n\tif (ocfs2_is_hard_readonly(osb)) {\n\t\tret = -EROFS;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_metadata_cache_io_lock(ci);\n\n\tlock_buffer(bh);\n\tset_buffer_uptodate(bh);\n\n\t/* remove from dirty list before I/O. */\n\tclear_buffer_dirty(bh);\n\n\tget_bh(bh); /* for end_buffer_write_sync() */\n\tbh->b_end_io = end_buffer_write_sync;\n\tsubmit_bh(WRITE, bh);\n\n\twait_on_buffer(bh);\n\n\tif (buffer_uptodate(bh)) {\n\t\tocfs2_set_buffer_uptodate(ci, bh);\n\t} else {\n\t\t/* We don't need to remove the clustered uptodate\n\t\t * information for this bh as it's not marked locally\n\t\t * uptodate. */\n\t\tret = -EIO;\n\t\tmlog_errno(ret);\n\t}\n\n\tocfs2_metadata_cache_io_unlock(ci);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_write_block(struct ocfs2_super *osb, struct buffer_head *bh,\n\t\t      struct ocfs2_caching_info *ci)\n{\n\tint ret = 0;\n\n\ttrace_ocfs2_write_block((unsigned long long)bh->b_blocknr, ci);\n\n\tBUG_ON(bh->b_blocknr < OCFS2_SUPER_BLOCK_BLKNO);\n\tBUG_ON(buffer_jbd(bh));\n\n\t/* No need to check for a soft readonly file system here. non\n\t * journalled writes are only ever done on system files which\n\t * can get modified during recovery even if read-only. */\n\tif (ocfs2_is_hard_readonly(osb)) {\n\t\tret = -EROFS;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_metadata_cache_io_lock(ci);\n\n\tlock_buffer(bh);\n\tset_buffer_uptodate(bh);\n\n\t/* remove from dirty list before I/O. */\n\tclear_buffer_dirty(bh);\n\n\tget_bh(bh); /* for end_buffer_write_sync() */\n\tbh->b_end_io = end_buffer_write_sync;\n\tsubmit_bh(WRITE, bh);\n\n\twait_on_buffer(bh);\n\n\tif (buffer_uptodate(bh)) {\n\t\tocfs2_set_buffer_uptodate(ci, bh);\n\t} else {\n\t\t/* We don't need to remove the clustered uptodate\n\t\t * information for this bh as it's not marked locally\n\t\t * uptodate. */\n\t\tret = -EIO;\n\t\tmlog_errno(ret);\n\t}\n\n\tocfs2_metadata_cache_io_unlock(ci);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "si->si_inode"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_update_disk_slot_old",
          "args": [
            "si",
            "slot_num",
            "&bh"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_update_disk_slot_old",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/slot_map.c",
          "lines": "183-199",
          "snippet": "static void ocfs2_update_disk_slot_old(struct ocfs2_slot_info *si,\n\t\t\t\t       int slot_num,\n\t\t\t\t       struct buffer_head **bh)\n{\n\tint i;\n\tstruct ocfs2_slot_map *sm;\n\n\tsm = (struct ocfs2_slot_map *)si->si_bh[0]->b_data;\n\tfor (i = 0; i < si->si_num_slots; i++) {\n\t\tif (si->si_slots[i].sl_valid)\n\t\t\tsm->sm_slots[i] =\n\t\t\t\tcpu_to_le16(si->si_slots[i].sl_node_num);\n\t\telse\n\t\t\tsm->sm_slots[i] = cpu_to_le16(OCFS2_INVALID_SLOT);\n\t}\n\t*bh = si->si_bh[0];\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void ocfs2_update_disk_slot_old(struct ocfs2_slot_info *si,\n\t\t\t\t       int slot_num,\n\t\t\t\t       struct buffer_head **bh)\n{\n\tint i;\n\tstruct ocfs2_slot_map *sm;\n\n\tsm = (struct ocfs2_slot_map *)si->si_bh[0]->b_data;\n\tfor (i = 0; i < si->si_num_slots; i++) {\n\t\tif (si->si_slots[i].sl_valid)\n\t\t\tsm->sm_slots[i] =\n\t\t\t\tcpu_to_le16(si->si_slots[i].sl_node_num);\n\t\telse\n\t\t\tsm->sm_slots[i] = cpu_to_le16(OCFS2_INVALID_SLOT);\n\t}\n\t*bh = si->si_bh[0];\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_update_disk_slot_extended",
          "args": [
            "si",
            "slot_num",
            "&bh"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_update_disk_slot_extended",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/slot_map.c",
          "lines": "165-181",
          "snippet": "static void ocfs2_update_disk_slot_extended(struct ocfs2_slot_info *si,\n\t\t\t\t\t    int slot_num,\n\t\t\t\t\t    struct buffer_head **bh)\n{\n\tint blkind = slot_num / si->si_slots_per_block;\n\tint slotno = slot_num % si->si_slots_per_block;\n\tstruct ocfs2_slot_map_extended *se;\n\n\tBUG_ON(blkind >= si->si_blocks);\n\n\tse = (struct ocfs2_slot_map_extended *)si->si_bh[blkind]->b_data;\n\tse->se_slots[slotno].es_valid = si->si_slots[slot_num].sl_valid;\n\tif (si->si_slots[slot_num].sl_valid)\n\t\tse->se_slots[slotno].es_node_num =\n\t\t\tcpu_to_le32(si->si_slots[slot_num].sl_node_num);\n\t*bh = si->si_bh[blkind];\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void ocfs2_update_disk_slot_extended(struct ocfs2_slot_info *si,\n\t\t\t\t\t    int slot_num,\n\t\t\t\t\t    struct buffer_head **bh)\n{\n\tint blkind = slot_num / si->si_slots_per_block;\n\tint slotno = slot_num % si->si_slots_per_block;\n\tstruct ocfs2_slot_map_extended *se;\n\n\tBUG_ON(blkind >= si->si_blocks);\n\n\tse = (struct ocfs2_slot_map_extended *)si->si_bh[blkind]->b_data;\n\tse->se_slots[slotno].es_valid = si->si_slots[slot_num].sl_valid;\n\tif (si->si_slots[slot_num].sl_valid)\n\t\tse->se_slots[slotno].es_node_num =\n\t\t\tcpu_to_le32(si->si_slots[slot_num].sl_node_num);\n\t*bh = si->si_bh[blkind];\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_update_disk_slot(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_slot_info *si,\n\t\t\t\t  int slot_num)\n{\n\tint status;\n\tstruct buffer_head *bh;\n\n\tspin_lock(&osb->osb_lock);\n\tif (si->si_extended)\n\t\tocfs2_update_disk_slot_extended(si, slot_num, &bh);\n\telse\n\t\tocfs2_update_disk_slot_old(si, slot_num, &bh);\n\tspin_unlock(&osb->osb_lock);\n\n\tstatus = ocfs2_write_block(osb, bh, INODE_CACHE(si->si_inode));\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\treturn status;\n}"
  },
  {
    "function_name": "ocfs2_update_disk_slot_old",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/slot_map.c",
    "lines": "183-199",
    "snippet": "static void ocfs2_update_disk_slot_old(struct ocfs2_slot_info *si,\n\t\t\t\t       int slot_num,\n\t\t\t\t       struct buffer_head **bh)\n{\n\tint i;\n\tstruct ocfs2_slot_map *sm;\n\n\tsm = (struct ocfs2_slot_map *)si->si_bh[0]->b_data;\n\tfor (i = 0; i < si->si_num_slots; i++) {\n\t\tif (si->si_slots[i].sl_valid)\n\t\t\tsm->sm_slots[i] =\n\t\t\t\tcpu_to_le16(si->si_slots[i].sl_node_num);\n\t\telse\n\t\t\tsm->sm_slots[i] = cpu_to_le16(OCFS2_INVALID_SLOT);\n\t}\n\t*bh = si->si_bh[0];\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "OCFS2_INVALID_SLOT"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "si->si_slots[i].sl_node_num"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void ocfs2_update_disk_slot_old(struct ocfs2_slot_info *si,\n\t\t\t\t       int slot_num,\n\t\t\t\t       struct buffer_head **bh)\n{\n\tint i;\n\tstruct ocfs2_slot_map *sm;\n\n\tsm = (struct ocfs2_slot_map *)si->si_bh[0]->b_data;\n\tfor (i = 0; i < si->si_num_slots; i++) {\n\t\tif (si->si_slots[i].sl_valid)\n\t\t\tsm->sm_slots[i] =\n\t\t\t\tcpu_to_le16(si->si_slots[i].sl_node_num);\n\t\telse\n\t\t\tsm->sm_slots[i] = cpu_to_le16(OCFS2_INVALID_SLOT);\n\t}\n\t*bh = si->si_bh[0];\n}"
  },
  {
    "function_name": "ocfs2_update_disk_slot_extended",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/slot_map.c",
    "lines": "165-181",
    "snippet": "static void ocfs2_update_disk_slot_extended(struct ocfs2_slot_info *si,\n\t\t\t\t\t    int slot_num,\n\t\t\t\t\t    struct buffer_head **bh)\n{\n\tint blkind = slot_num / si->si_slots_per_block;\n\tint slotno = slot_num % si->si_slots_per_block;\n\tstruct ocfs2_slot_map_extended *se;\n\n\tBUG_ON(blkind >= si->si_blocks);\n\n\tse = (struct ocfs2_slot_map_extended *)si->si_bh[blkind]->b_data;\n\tse->se_slots[slotno].es_valid = si->si_slots[slot_num].sl_valid;\n\tif (si->si_slots[slot_num].sl_valid)\n\t\tse->se_slots[slotno].es_node_num =\n\t\t\tcpu_to_le32(si->si_slots[slot_num].sl_node_num);\n\t*bh = si->si_bh[blkind];\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "si->si_slots[slot_num].sl_node_num"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "blkind >= si->si_blocks"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void ocfs2_update_disk_slot_extended(struct ocfs2_slot_info *si,\n\t\t\t\t\t    int slot_num,\n\t\t\t\t\t    struct buffer_head **bh)\n{\n\tint blkind = slot_num / si->si_slots_per_block;\n\tint slotno = slot_num % si->si_slots_per_block;\n\tstruct ocfs2_slot_map_extended *se;\n\n\tBUG_ON(blkind >= si->si_blocks);\n\n\tse = (struct ocfs2_slot_map_extended *)si->si_bh[blkind]->b_data;\n\tse->se_slots[slotno].es_valid = si->si_slots[slot_num].sl_valid;\n\tif (si->si_slots[slot_num].sl_valid)\n\t\tse->se_slots[slotno].es_node_num =\n\t\t\tcpu_to_le32(si->si_slots[slot_num].sl_node_num);\n\t*bh = si->si_bh[blkind];\n}"
  },
  {
    "function_name": "ocfs2_refresh_slot_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/slot_map.c",
    "lines": "134-161",
    "snippet": "int ocfs2_refresh_slot_info(struct ocfs2_super *osb)\n{\n\tint ret;\n\tstruct ocfs2_slot_info *si = osb->slot_info;\n\n\tif (si == NULL)\n\t\treturn 0;\n\n\tBUG_ON(si->si_blocks == 0);\n\tBUG_ON(si->si_bh == NULL);\n\n\ttrace_ocfs2_refresh_slot_info(si->si_blocks);\n\n\t/*\n\t * We pass -1 as blocknr because we expect all of si->si_bh to\n\t * be !NULL.  Thus, ocfs2_read_blocks() will ignore blocknr.  If\n\t * this is not true, the read of -1 (UINT64_MAX) will fail.\n\t */\n\tret = ocfs2_read_blocks(INODE_CACHE(si->si_inode), -1, si->si_blocks,\n\t\t\t\tsi->si_bh, OCFS2_BH_IGNORE_CACHE, NULL);\n\tif (ret == 0) {\n\t\tspin_lock(&osb->osb_lock);\n\t\tocfs2_update_slot_info(si);\n\t\tspin_unlock(&osb->osb_lock);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_update_slot_info",
          "args": [
            "si"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_update_slot_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/slot_map.c",
          "lines": "122-132",
          "snippet": "static void ocfs2_update_slot_info(struct ocfs2_slot_info *si)\n{\n\t/*\n\t * The slot data will have been refreshed when ocfs2_super_lock\n\t * was taken.\n\t */\n\tif (si->si_extended)\n\t\tocfs2_update_slot_info_extended(si);\n\telse\n\t\tocfs2_update_slot_info_old(si);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void ocfs2_update_slot_info(struct ocfs2_slot_info *si)\n{\n\t/*\n\t * The slot data will have been refreshed when ocfs2_super_lock\n\t * was taken.\n\t */\n\tif (si->si_extended)\n\t\tocfs2_update_slot_info_extended(si);\n\telse\n\t\tocfs2_update_slot_info_old(si);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_read_blocks",
          "args": [
            "INODE_CACHE(si->si_inode)",
            "-1",
            "si->si_blocks",
            "si->si_bh",
            "OCFS2_BH_IGNORE_CACHE",
            "NULL"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/buffer_head_io.c",
          "lines": "176-366",
          "snippet": "int ocfs2_read_blocks(struct ocfs2_caching_info *ci, u64 block, int nr,\n\t\t      struct buffer_head *bhs[], int flags,\n\t\t      int (*validate)(struct super_block *sb,\n\t\t\t\t      struct buffer_head *bh))\n{\n\tint status = 0;\n\tint i, ignore_cache = 0;\n\tstruct buffer_head *bh;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\n\n\ttrace_ocfs2_read_blocks_begin(ci, (unsigned long long)block, nr, flags);\n\n\tBUG_ON(!ci);\n\tBUG_ON((flags & OCFS2_BH_READAHEAD) &&\n\t       (flags & OCFS2_BH_IGNORE_CACHE));\n\n\tif (bhs == NULL) {\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tif (nr < 0) {\n\t\tmlog(ML_ERROR, \"asked to read %d blocks!\\n\", nr);\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tif (nr == 0) {\n\t\tstatus = 0;\n\t\tgoto bail;\n\t}\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tfor (i = 0 ; i < nr ; i++) {\n\t\tif (bhs[i] == NULL) {\n\t\t\tbhs[i] = sb_getblk(sb, block++);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tocfs2_metadata_cache_io_unlock(ci);\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tbh = bhs[i];\n\t\tignore_cache = (flags & OCFS2_BH_IGNORE_CACHE);\n\n\t\t/* There are three read-ahead cases here which we need to\n\t\t * be concerned with. All three assume a buffer has\n\t\t * previously been submitted with OCFS2_BH_READAHEAD\n\t\t * and it hasn't yet completed I/O.\n\t\t *\n\t\t * 1) The current request is sync to disk. This rarely\n\t\t *    happens these days, and never when performance\n\t\t *    matters - the code can just wait on the buffer\n\t\t *    lock and re-submit.\n\t\t *\n\t\t * 2) The current request is cached, but not\n\t\t *    readahead. ocfs2_buffer_uptodate() will return\n\t\t *    false anyway, so we'll wind up waiting on the\n\t\t *    buffer lock to do I/O. We re-check the request\n\t\t *    with after getting the lock to avoid a re-submit.\n\t\t *\n\t\t * 3) The current request is readahead (and so must\n\t\t *    also be a caching one). We short circuit if the\n\t\t *    buffer is locked (under I/O) and if it's in the\n\t\t *    uptodate cache. The re-check from #2 catches the\n\t\t *    case that the previous read-ahead completes just\n\t\t *    before our is-it-in-flight check.\n\t\t */\n\n\t\tif (!ignore_cache && !ocfs2_buffer_uptodate(ci, bh)) {\n\t\t\ttrace_ocfs2_read_blocks_from_disk(\n\t\t\t     (unsigned long long)bh->b_blocknr,\n\t\t\t     (unsigned long long)ocfs2_metadata_cache_owner(ci));\n\t\t\t/* We're using ignore_cache here to say\n\t\t\t * \"go to disk\" */\n\t\t\tignore_cache = 1;\n\t\t}\n\n\t\ttrace_ocfs2_read_blocks_bh((unsigned long long)bh->b_blocknr,\n\t\t\tignore_cache, buffer_jbd(bh), buffer_dirty(bh));\n\n\t\tif (buffer_jbd(bh)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ignore_cache) {\n\t\t\tif (buffer_dirty(bh)) {\n\t\t\t\t/* This should probably be a BUG, or\n\t\t\t\t * at least return an error. */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* A read-ahead request was made - if the\n\t\t\t * buffer is already under read-ahead from a\n\t\t\t * previously submitted request than we are\n\t\t\t * done here. */\n\t\t\tif ((flags & OCFS2_BH_READAHEAD)\n\t\t\t    && ocfs2_buffer_read_ahead(ci, bh))\n\t\t\t\tcontinue;\n\n\t\t\tlock_buffer(bh);\n\t\t\tif (buffer_jbd(bh)) {\n#ifdef CATCH_BH_JBD_RACES\n\t\t\t\tmlog(ML_ERROR, \"block %llu had the JBD bit set \"\n\t\t\t\t\t       \"while I was in lock_buffer!\",\n\t\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\t\tBUG();\n#else\n\t\t\t\tunlock_buffer(bh);\n\t\t\t\tcontinue;\n#endif\n\t\t\t}\n\n\t\t\t/* Re-check ocfs2_buffer_uptodate() as a\n\t\t\t * previously read-ahead buffer may have\n\t\t\t * completed I/O while we were waiting for the\n\t\t\t * buffer lock. */\n\t\t\tif (!(flags & OCFS2_BH_IGNORE_CACHE)\n\t\t\t    && !(flags & OCFS2_BH_READAHEAD)\n\t\t\t    && ocfs2_buffer_uptodate(ci, bh)) {\n\t\t\t\tunlock_buffer(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tclear_buffer_uptodate(bh);\n\t\t\tget_bh(bh); /* for end_buffer_read_sync() */\n\t\t\tif (validate)\n\t\t\t\tset_buffer_needs_validate(bh);\n\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\tsubmit_bh(READ, bh);\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tstatus = 0;\n\n\tfor (i = (nr - 1); i >= 0; i--) {\n\t\tbh = bhs[i];\n\n\t\tif (!(flags & OCFS2_BH_READAHEAD)) {\n\t\t\t/* We know this can't have changed as we hold the\n\t\t\t * owner sem. Avoid doing any work on the bh if the\n\t\t\t * journal has it. */\n\t\t\tif (!buffer_jbd(bh))\n\t\t\t\twait_on_buffer(bh);\n\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\t/* Status won't be cleared from here on out,\n\t\t\t\t * so we can safely record this and loop back\n\t\t\t\t * to cleanup the other buffers. Don't need to\n\t\t\t\t * remove the clustered uptodate information\n\t\t\t\t * for this bh as it's not marked locally\n\t\t\t\t * uptodate. */\n\t\t\t\tstatus = -EIO;\n\t\t\t\tput_bh(bh);\n\t\t\t\tbhs[i] = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (buffer_needs_validate(bh)) {\n\t\t\t\t/* We never set NeedsValidate if the\n\t\t\t\t * buffer was held by the journal, so\n\t\t\t\t * that better not have changed */\n\t\t\t\tBUG_ON(buffer_jbd(bh));\n\t\t\t\tclear_buffer_needs_validate(bh);\n\t\t\t\tstatus = validate(sb, bh);\n\t\t\t\tif (status) {\n\t\t\t\t\tput_bh(bh);\n\t\t\t\t\tbhs[i] = NULL;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Always set the buffer in the cache, even if it was\n\t\t * a forced read, or read-ahead which hasn't yet\n\t\t * completed. */\n\t\tocfs2_set_buffer_uptodate(ci, bh);\n\t}\n\tocfs2_metadata_cache_io_unlock(ci);\n\n\ttrace_ocfs2_read_blocks_end((unsigned long long)block, nr,\n\t\t\t\t    flags, ignore_cache);\n\nbail:\n\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_blocks(struct ocfs2_caching_info *ci, u64 block, int nr,\n\t\t      struct buffer_head *bhs[], int flags,\n\t\t      int (*validate)(struct super_block *sb,\n\t\t\t\t      struct buffer_head *bh))\n{\n\tint status = 0;\n\tint i, ignore_cache = 0;\n\tstruct buffer_head *bh;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\n\n\ttrace_ocfs2_read_blocks_begin(ci, (unsigned long long)block, nr, flags);\n\n\tBUG_ON(!ci);\n\tBUG_ON((flags & OCFS2_BH_READAHEAD) &&\n\t       (flags & OCFS2_BH_IGNORE_CACHE));\n\n\tif (bhs == NULL) {\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tif (nr < 0) {\n\t\tmlog(ML_ERROR, \"asked to read %d blocks!\\n\", nr);\n\t\tstatus = -EINVAL;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tif (nr == 0) {\n\t\tstatus = 0;\n\t\tgoto bail;\n\t}\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tfor (i = 0 ; i < nr ; i++) {\n\t\tif (bhs[i] == NULL) {\n\t\t\tbhs[i] = sb_getblk(sb, block++);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tocfs2_metadata_cache_io_unlock(ci);\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tbh = bhs[i];\n\t\tignore_cache = (flags & OCFS2_BH_IGNORE_CACHE);\n\n\t\t/* There are three read-ahead cases here which we need to\n\t\t * be concerned with. All three assume a buffer has\n\t\t * previously been submitted with OCFS2_BH_READAHEAD\n\t\t * and it hasn't yet completed I/O.\n\t\t *\n\t\t * 1) The current request is sync to disk. This rarely\n\t\t *    happens these days, and never when performance\n\t\t *    matters - the code can just wait on the buffer\n\t\t *    lock and re-submit.\n\t\t *\n\t\t * 2) The current request is cached, but not\n\t\t *    readahead. ocfs2_buffer_uptodate() will return\n\t\t *    false anyway, so we'll wind up waiting on the\n\t\t *    buffer lock to do I/O. We re-check the request\n\t\t *    with after getting the lock to avoid a re-submit.\n\t\t *\n\t\t * 3) The current request is readahead (and so must\n\t\t *    also be a caching one). We short circuit if the\n\t\t *    buffer is locked (under I/O) and if it's in the\n\t\t *    uptodate cache. The re-check from #2 catches the\n\t\t *    case that the previous read-ahead completes just\n\t\t *    before our is-it-in-flight check.\n\t\t */\n\n\t\tif (!ignore_cache && !ocfs2_buffer_uptodate(ci, bh)) {\n\t\t\ttrace_ocfs2_read_blocks_from_disk(\n\t\t\t     (unsigned long long)bh->b_blocknr,\n\t\t\t     (unsigned long long)ocfs2_metadata_cache_owner(ci));\n\t\t\t/* We're using ignore_cache here to say\n\t\t\t * \"go to disk\" */\n\t\t\tignore_cache = 1;\n\t\t}\n\n\t\ttrace_ocfs2_read_blocks_bh((unsigned long long)bh->b_blocknr,\n\t\t\tignore_cache, buffer_jbd(bh), buffer_dirty(bh));\n\n\t\tif (buffer_jbd(bh)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ignore_cache) {\n\t\t\tif (buffer_dirty(bh)) {\n\t\t\t\t/* This should probably be a BUG, or\n\t\t\t\t * at least return an error. */\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* A read-ahead request was made - if the\n\t\t\t * buffer is already under read-ahead from a\n\t\t\t * previously submitted request than we are\n\t\t\t * done here. */\n\t\t\tif ((flags & OCFS2_BH_READAHEAD)\n\t\t\t    && ocfs2_buffer_read_ahead(ci, bh))\n\t\t\t\tcontinue;\n\n\t\t\tlock_buffer(bh);\n\t\t\tif (buffer_jbd(bh)) {\n#ifdef CATCH_BH_JBD_RACES\n\t\t\t\tmlog(ML_ERROR, \"block %llu had the JBD bit set \"\n\t\t\t\t\t       \"while I was in lock_buffer!\",\n\t\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\t\tBUG();\n#else\n\t\t\t\tunlock_buffer(bh);\n\t\t\t\tcontinue;\n#endif\n\t\t\t}\n\n\t\t\t/* Re-check ocfs2_buffer_uptodate() as a\n\t\t\t * previously read-ahead buffer may have\n\t\t\t * completed I/O while we were waiting for the\n\t\t\t * buffer lock. */\n\t\t\tif (!(flags & OCFS2_BH_IGNORE_CACHE)\n\t\t\t    && !(flags & OCFS2_BH_READAHEAD)\n\t\t\t    && ocfs2_buffer_uptodate(ci, bh)) {\n\t\t\t\tunlock_buffer(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tclear_buffer_uptodate(bh);\n\t\t\tget_bh(bh); /* for end_buffer_read_sync() */\n\t\t\tif (validate)\n\t\t\t\tset_buffer_needs_validate(bh);\n\t\t\tbh->b_end_io = end_buffer_read_sync;\n\t\t\tsubmit_bh(READ, bh);\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tstatus = 0;\n\n\tfor (i = (nr - 1); i >= 0; i--) {\n\t\tbh = bhs[i];\n\n\t\tif (!(flags & OCFS2_BH_READAHEAD)) {\n\t\t\t/* We know this can't have changed as we hold the\n\t\t\t * owner sem. Avoid doing any work on the bh if the\n\t\t\t * journal has it. */\n\t\t\tif (!buffer_jbd(bh))\n\t\t\t\twait_on_buffer(bh);\n\n\t\t\tif (!buffer_uptodate(bh)) {\n\t\t\t\t/* Status won't be cleared from here on out,\n\t\t\t\t * so we can safely record this and loop back\n\t\t\t\t * to cleanup the other buffers. Don't need to\n\t\t\t\t * remove the clustered uptodate information\n\t\t\t\t * for this bh as it's not marked locally\n\t\t\t\t * uptodate. */\n\t\t\t\tstatus = -EIO;\n\t\t\t\tput_bh(bh);\n\t\t\t\tbhs[i] = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (buffer_needs_validate(bh)) {\n\t\t\t\t/* We never set NeedsValidate if the\n\t\t\t\t * buffer was held by the journal, so\n\t\t\t\t * that better not have changed */\n\t\t\t\tBUG_ON(buffer_jbd(bh));\n\t\t\t\tclear_buffer_needs_validate(bh);\n\t\t\t\tstatus = validate(sb, bh);\n\t\t\t\tif (status) {\n\t\t\t\t\tput_bh(bh);\n\t\t\t\t\tbhs[i] = NULL;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* Always set the buffer in the cache, even if it was\n\t\t * a forced read, or read-ahead which hasn't yet\n\t\t * completed. */\n\t\tocfs2_set_buffer_uptodate(ci, bh);\n\t}\n\tocfs2_metadata_cache_io_unlock(ci);\n\n\ttrace_ocfs2_read_blocks_end((unsigned long long)block, nr,\n\t\t\t\t    flags, ignore_cache);\n\nbail:\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "si->si_inode"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_refresh_slot_info",
          "args": [
            "si->si_blocks"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "si->si_bh == NULL"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "si->si_blocks == 0"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nint ocfs2_refresh_slot_info(struct ocfs2_super *osb)\n{\n\tint ret;\n\tstruct ocfs2_slot_info *si = osb->slot_info;\n\n\tif (si == NULL)\n\t\treturn 0;\n\n\tBUG_ON(si->si_blocks == 0);\n\tBUG_ON(si->si_bh == NULL);\n\n\ttrace_ocfs2_refresh_slot_info(si->si_blocks);\n\n\t/*\n\t * We pass -1 as blocknr because we expect all of si->si_bh to\n\t * be !NULL.  Thus, ocfs2_read_blocks() will ignore blocknr.  If\n\t * this is not true, the read of -1 (UINT64_MAX) will fail.\n\t */\n\tret = ocfs2_read_blocks(INODE_CACHE(si->si_inode), -1, si->si_blocks,\n\t\t\t\tsi->si_bh, OCFS2_BH_IGNORE_CACHE, NULL);\n\tif (ret == 0) {\n\t\tspin_lock(&osb->osb_lock);\n\t\tocfs2_update_slot_info(si);\n\t\tspin_unlock(&osb->osb_lock);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_update_slot_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/slot_map.c",
    "lines": "122-132",
    "snippet": "static void ocfs2_update_slot_info(struct ocfs2_slot_info *si)\n{\n\t/*\n\t * The slot data will have been refreshed when ocfs2_super_lock\n\t * was taken.\n\t */\n\tif (si->si_extended)\n\t\tocfs2_update_slot_info_extended(si);\n\telse\n\t\tocfs2_update_slot_info_old(si);\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_update_slot_info_old",
          "args": [
            "si"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_update_slot_info_old",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/slot_map.c",
          "lines": "107-120",
          "snippet": "static void ocfs2_update_slot_info_old(struct ocfs2_slot_info *si)\n{\n\tint i;\n\tstruct ocfs2_slot_map *sm;\n\n\tsm = (struct ocfs2_slot_map *)si->si_bh[0]->b_data;\n\n\tfor (i = 0; i < si->si_num_slots; i++) {\n\t\tif (le16_to_cpu(sm->sm_slots[i]) == (u16)OCFS2_INVALID_SLOT)\n\t\t\tocfs2_invalidate_slot(si, i);\n\t\telse\n\t\t\tocfs2_set_slot(si, i, le16_to_cpu(sm->sm_slots[i]));\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void ocfs2_update_slot_info_old(struct ocfs2_slot_info *si)\n{\n\tint i;\n\tstruct ocfs2_slot_map *sm;\n\n\tsm = (struct ocfs2_slot_map *)si->si_bh[0]->b_data;\n\n\tfor (i = 0; i < si->si_num_slots; i++) {\n\t\tif (le16_to_cpu(sm->sm_slots[i]) == (u16)OCFS2_INVALID_SLOT)\n\t\t\tocfs2_invalidate_slot(si, i);\n\t\telse\n\t\t\tocfs2_set_slot(si, i, le16_to_cpu(sm->sm_slots[i]));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_update_slot_info_extended",
          "args": [
            "si"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_update_slot_info_extended",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/slot_map.c",
          "lines": "82-101",
          "snippet": "static void ocfs2_update_slot_info_extended(struct ocfs2_slot_info *si)\n{\n\tint b, i, slotno;\n\tstruct ocfs2_slot_map_extended *se;\n\n\tslotno = 0;\n\tfor (b = 0; b < si->si_blocks; b++) {\n\t\tse = (struct ocfs2_slot_map_extended *)si->si_bh[b]->b_data;\n\t\tfor (i = 0;\n\t\t     (i < si->si_slots_per_block) &&\n\t\t     (slotno < si->si_num_slots);\n\t\t     i++, slotno++) {\n\t\t\tif (se->se_slots[i].es_valid)\n\t\t\t\tocfs2_set_slot(si, slotno,\n\t\t\t\t\t       le32_to_cpu(se->se_slots[i].es_node_num));\n\t\t\telse\n\t\t\t\tocfs2_invalidate_slot(si, slotno);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void ocfs2_update_slot_info_extended(struct ocfs2_slot_info *si)\n{\n\tint b, i, slotno;\n\tstruct ocfs2_slot_map_extended *se;\n\n\tslotno = 0;\n\tfor (b = 0; b < si->si_blocks; b++) {\n\t\tse = (struct ocfs2_slot_map_extended *)si->si_bh[b]->b_data;\n\t\tfor (i = 0;\n\t\t     (i < si->si_slots_per_block) &&\n\t\t     (slotno < si->si_num_slots);\n\t\t     i++, slotno++) {\n\t\t\tif (se->se_slots[i].es_valid)\n\t\t\t\tocfs2_set_slot(si, slotno,\n\t\t\t\t\t       le32_to_cpu(se->se_slots[i].es_node_num));\n\t\t\telse\n\t\t\t\tocfs2_invalidate_slot(si, slotno);\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void ocfs2_update_slot_info(struct ocfs2_slot_info *si)\n{\n\t/*\n\t * The slot data will have been refreshed when ocfs2_super_lock\n\t * was taken.\n\t */\n\tif (si->si_extended)\n\t\tocfs2_update_slot_info_extended(si);\n\telse\n\t\tocfs2_update_slot_info_old(si);\n}"
  },
  {
    "function_name": "ocfs2_update_slot_info_old",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/slot_map.c",
    "lines": "107-120",
    "snippet": "static void ocfs2_update_slot_info_old(struct ocfs2_slot_info *si)\n{\n\tint i;\n\tstruct ocfs2_slot_map *sm;\n\n\tsm = (struct ocfs2_slot_map *)si->si_bh[0]->b_data;\n\n\tfor (i = 0; i < si->si_num_slots; i++) {\n\t\tif (le16_to_cpu(sm->sm_slots[i]) == (u16)OCFS2_INVALID_SLOT)\n\t\t\tocfs2_invalidate_slot(si, i);\n\t\telse\n\t\t\tocfs2_set_slot(si, i, le16_to_cpu(sm->sm_slots[i]));\n\t}\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_set_slot",
          "args": [
            "si",
            "i",
            "le16_to_cpu(sm->sm_slots[i])"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/slot_map.c",
          "lines": "72-79",
          "snippet": "static void ocfs2_set_slot(struct ocfs2_slot_info *si,\n\t\t\t   int slot_num, unsigned int node_num)\n{\n\tBUG_ON((slot_num < 0) || (slot_num >= si->si_num_slots));\n\n\tsi->si_slots[slot_num].sl_valid = 1;\n\tsi->si_slots[slot_num].sl_node_num = node_num;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __ocfs2_node_num_to_slot(struct ocfs2_slot_info *si,\n\t\t\t\t    unsigned int node_num);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int __ocfs2_node_num_to_slot(struct ocfs2_slot_info *si,\n\t\t\t\t    unsigned int node_num);\n\nstatic void ocfs2_set_slot(struct ocfs2_slot_info *si,\n\t\t\t   int slot_num, unsigned int node_num)\n{\n\tBUG_ON((slot_num < 0) || (slot_num >= si->si_num_slots));\n\n\tsi->si_slots[slot_num].sl_valid = 1;\n\tsi->si_slots[slot_num].sl_node_num = node_num;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "sm->sm_slots[i]"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_invalidate_slot",
          "args": [
            "si",
            "i"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_invalidate_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/slot_map.c",
          "lines": "65-70",
          "snippet": "static void ocfs2_invalidate_slot(struct ocfs2_slot_info *si,\n\t\t\t\t  int slot_num)\n{\n\tBUG_ON((slot_num < 0) || (slot_num >= si->si_num_slots));\n\tsi->si_slots[slot_num].sl_valid = 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void ocfs2_invalidate_slot(struct ocfs2_slot_info *si,\n\t\t\t\t  int slot_num)\n{\n\tBUG_ON((slot_num < 0) || (slot_num >= si->si_num_slots));\n\tsi->si_slots[slot_num].sl_valid = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void ocfs2_update_slot_info_old(struct ocfs2_slot_info *si)\n{\n\tint i;\n\tstruct ocfs2_slot_map *sm;\n\n\tsm = (struct ocfs2_slot_map *)si->si_bh[0]->b_data;\n\n\tfor (i = 0; i < si->si_num_slots; i++) {\n\t\tif (le16_to_cpu(sm->sm_slots[i]) == (u16)OCFS2_INVALID_SLOT)\n\t\t\tocfs2_invalidate_slot(si, i);\n\t\telse\n\t\t\tocfs2_set_slot(si, i, le16_to_cpu(sm->sm_slots[i]));\n\t}\n}"
  },
  {
    "function_name": "ocfs2_update_slot_info_extended",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/slot_map.c",
    "lines": "82-101",
    "snippet": "static void ocfs2_update_slot_info_extended(struct ocfs2_slot_info *si)\n{\n\tint b, i, slotno;\n\tstruct ocfs2_slot_map_extended *se;\n\n\tslotno = 0;\n\tfor (b = 0; b < si->si_blocks; b++) {\n\t\tse = (struct ocfs2_slot_map_extended *)si->si_bh[b]->b_data;\n\t\tfor (i = 0;\n\t\t     (i < si->si_slots_per_block) &&\n\t\t     (slotno < si->si_num_slots);\n\t\t     i++, slotno++) {\n\t\t\tif (se->se_slots[i].es_valid)\n\t\t\t\tocfs2_set_slot(si, slotno,\n\t\t\t\t\t       le32_to_cpu(se->se_slots[i].es_node_num));\n\t\t\telse\n\t\t\t\tocfs2_invalidate_slot(si, slotno);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_invalidate_slot",
          "args": [
            "si",
            "slotno"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_invalidate_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/slot_map.c",
          "lines": "65-70",
          "snippet": "static void ocfs2_invalidate_slot(struct ocfs2_slot_info *si,\n\t\t\t\t  int slot_num)\n{\n\tBUG_ON((slot_num < 0) || (slot_num >= si->si_num_slots));\n\tsi->si_slots[slot_num].sl_valid = 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void ocfs2_invalidate_slot(struct ocfs2_slot_info *si,\n\t\t\t\t  int slot_num)\n{\n\tBUG_ON((slot_num < 0) || (slot_num >= si->si_num_slots));\n\tsi->si_slots[slot_num].sl_valid = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_set_slot",
          "args": [
            "si",
            "slotno",
            "le32_to_cpu(se->se_slots[i].es_node_num)"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_slot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/slot_map.c",
          "lines": "72-79",
          "snippet": "static void ocfs2_set_slot(struct ocfs2_slot_info *si,\n\t\t\t   int slot_num, unsigned int node_num)\n{\n\tBUG_ON((slot_num < 0) || (slot_num >= si->si_num_slots));\n\n\tsi->si_slots[slot_num].sl_valid = 1;\n\tsi->si_slots[slot_num].sl_node_num = node_num;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __ocfs2_node_num_to_slot(struct ocfs2_slot_info *si,\n\t\t\t\t    unsigned int node_num);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int __ocfs2_node_num_to_slot(struct ocfs2_slot_info *si,\n\t\t\t\t    unsigned int node_num);\n\nstatic void ocfs2_set_slot(struct ocfs2_slot_info *si,\n\t\t\t   int slot_num, unsigned int node_num)\n{\n\tBUG_ON((slot_num < 0) || (slot_num >= si->si_num_slots));\n\n\tsi->si_slots[slot_num].sl_valid = 1;\n\tsi->si_slots[slot_num].sl_node_num = node_num;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "se->se_slots[i].es_node_num"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void ocfs2_update_slot_info_extended(struct ocfs2_slot_info *si)\n{\n\tint b, i, slotno;\n\tstruct ocfs2_slot_map_extended *se;\n\n\tslotno = 0;\n\tfor (b = 0; b < si->si_blocks; b++) {\n\t\tse = (struct ocfs2_slot_map_extended *)si->si_bh[b]->b_data;\n\t\tfor (i = 0;\n\t\t     (i < si->si_slots_per_block) &&\n\t\t     (slotno < si->si_num_slots);\n\t\t     i++, slotno++) {\n\t\t\tif (se->se_slots[i].es_valid)\n\t\t\t\tocfs2_set_slot(si, slotno,\n\t\t\t\t\t       le32_to_cpu(se->se_slots[i].es_node_num));\n\t\t\telse\n\t\t\t\tocfs2_invalidate_slot(si, slotno);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "ocfs2_set_slot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/slot_map.c",
    "lines": "72-79",
    "snippet": "static void ocfs2_set_slot(struct ocfs2_slot_info *si,\n\t\t\t   int slot_num, unsigned int node_num)\n{\n\tBUG_ON((slot_num < 0) || (slot_num >= si->si_num_slots));\n\n\tsi->si_slots[slot_num].sl_valid = 1;\n\tsi->si_slots[slot_num].sl_node_num = node_num;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int __ocfs2_node_num_to_slot(struct ocfs2_slot_info *si,\n\t\t\t\t    unsigned int node_num);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "(slot_num < 0) || (slot_num >= si->si_num_slots)"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int __ocfs2_node_num_to_slot(struct ocfs2_slot_info *si,\n\t\t\t\t    unsigned int node_num);\n\nstatic void ocfs2_set_slot(struct ocfs2_slot_info *si,\n\t\t\t   int slot_num, unsigned int node_num)\n{\n\tBUG_ON((slot_num < 0) || (slot_num >= si->si_num_slots));\n\n\tsi->si_slots[slot_num].sl_valid = 1;\n\tsi->si_slots[slot_num].sl_node_num = node_num;\n}"
  },
  {
    "function_name": "ocfs2_invalidate_slot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/slot_map.c",
    "lines": "65-70",
    "snippet": "static void ocfs2_invalidate_slot(struct ocfs2_slot_info *si,\n\t\t\t\t  int slot_num)\n{\n\tBUG_ON((slot_num < 0) || (slot_num >= si->si_num_slots));\n\tsi->si_slots[slot_num].sl_valid = 0;\n}",
    "includes": [
      "#include \"buffer_head_io.h\"",
      "#include \"ocfs2_trace.h\"",
      "#include \"sysfile.h\"",
      "#include \"super.h\"",
      "#include \"slot_map.h\"",
      "#include \"inode.h\"",
      "#include \"heartbeat.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/highmem.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "(slot_num < 0) || (slot_num >= si->si_num_slots)"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic void ocfs2_invalidate_slot(struct ocfs2_slot_info *si,\n\t\t\t\t  int slot_num)\n{\n\tBUG_ON((slot_num < 0) || (slot_num >= si->si_num_slots));\n\tsi->si_slots[slot_num].sl_valid = 0;\n}"
  }
]