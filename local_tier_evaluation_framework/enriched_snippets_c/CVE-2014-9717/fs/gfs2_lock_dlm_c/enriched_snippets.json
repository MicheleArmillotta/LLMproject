[
  {
    "function_name": "gdlm_unmount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lock_dlm.c",
    "lines": "1293-1315",
    "snippet": "static void gdlm_unmount(struct gfs2_sbd *sdp)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\n\tif (test_bit(DFL_NO_DLM_OPS, &ls->ls_recover_flags))\n\t\tgoto release;\n\n\t/* wait for gfs2_control_wq to be done with this mount */\n\n\tspin_lock(&ls->ls_recover_spin);\n\tset_bit(DFL_UNMOUNT, &ls->ls_recover_flags);\n\tspin_unlock(&ls->ls_recover_spin);\n\tflush_delayed_work(&sdp->sd_control_work);\n\n\t/* mounted_lock and control_lock will be purged in dlm recovery */\nrelease:\n\tif (ls->ls_dlm) {\n\t\tdlm_release_lockspace(ls->ls_dlm, 2);\n\t\tls->ls_dlm = NULL;\n\t}\n\n\tfree_recover_size(ls);\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"sys.h\"",
      "#include \"util.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/dlm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern struct workqueue_struct *gfs2_control_wq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_recover_size",
          "args": [
            "ls"
          ],
          "line": 1314
        },
        "resolved": true,
        "details": {
          "function_name": "free_recover_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lock_dlm.c",
          "lines": "1053-1061",
          "snippet": "static void free_recover_size(struct lm_lockstruct *ls)\n{\n\tkfree(ls->ls_lvb_bits);\n\tkfree(ls->ls_recover_submit);\n\tkfree(ls->ls_recover_result);\n\tls->ls_recover_submit = NULL;\n\tls->ls_recover_result = NULL;\n\tls->ls_recover_size = 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/dlm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/dlm.h>\n#include <linux/fs.h>\n\nstatic void free_recover_size(struct lm_lockstruct *ls)\n{\n\tkfree(ls->ls_lvb_bits);\n\tkfree(ls->ls_recover_submit);\n\tkfree(ls->ls_recover_result);\n\tls->ls_recover_submit = NULL;\n\tls->ls_recover_result = NULL;\n\tls->ls_recover_size = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_release_lockspace",
          "args": [
            "ls->ls_dlm",
            "2"
          ],
          "line": 1310
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_release_lockspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
          "lines": "873-892",
          "snippet": "int dlm_release_lockspace(void *lockspace, int force)\n{\n\tstruct dlm_ls *ls;\n\tint error;\n\n\tls = dlm_find_lockspace_local(lockspace);\n\tif (!ls)\n\t\treturn -EINVAL;\n\tdlm_put_lockspace(ls);\n\n\tmutex_lock(&ls_lock);\n\terror = release_lockspace(ls, force);\n\tif (!error)\n\t\tls_count--;\n\tif (!ls_count)\n\t\tthreads_stop();\n\tmutex_unlock(&ls_lock);\n\n\treturn error;\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"requestqueue.h\"",
            "#include \"recover.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dir.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t\t\tls_count;",
            "static struct mutex\t\tls_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int\t\t\tls_count;\nstatic struct mutex\t\tls_lock;\n\nint dlm_release_lockspace(void *lockspace, int force)\n{\n\tstruct dlm_ls *ls;\n\tint error;\n\n\tls = dlm_find_lockspace_local(lockspace);\n\tif (!ls)\n\t\treturn -EINVAL;\n\tdlm_put_lockspace(ls);\n\n\tmutex_lock(&ls_lock);\n\terror = release_lockspace(ls, force);\n\tif (!error)\n\t\tls_count--;\n\tif (!ls_count)\n\t\tthreads_stop();\n\tmutex_unlock(&ls_lock);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_delayed_work",
          "args": [
            "&sdp->sd_control_work"
          ],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ls->ls_recover_spin"
          ],
          "line": 1304
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "DFL_UNMOUNT",
            "&ls->ls_recover_flags"
          ],
          "line": 1303
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ls->ls_recover_spin"
          ],
          "line": 1302
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "DFL_NO_DLM_OPS",
            "&ls->ls_recover_flags"
          ],
          "line": 1297
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/dlm.h>\n#include <linux/fs.h>\n\nextern struct workqueue_struct *gfs2_control_wq;\n\nstatic void gdlm_unmount(struct gfs2_sbd *sdp)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\n\tif (test_bit(DFL_NO_DLM_OPS, &ls->ls_recover_flags))\n\t\tgoto release;\n\n\t/* wait for gfs2_control_wq to be done with this mount */\n\n\tspin_lock(&ls->ls_recover_spin);\n\tset_bit(DFL_UNMOUNT, &ls->ls_recover_flags);\n\tspin_unlock(&ls->ls_recover_spin);\n\tflush_delayed_work(&sdp->sd_control_work);\n\n\t/* mounted_lock and control_lock will be purged in dlm recovery */\nrelease:\n\tif (ls->ls_dlm) {\n\t\tdlm_release_lockspace(ls->ls_dlm, 2);\n\t\tls->ls_dlm = NULL;\n\t}\n\n\tfree_recover_size(ls);\n}"
  },
  {
    "function_name": "gdlm_first_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lock_dlm.c",
    "lines": "1280-1291",
    "snippet": "static void gdlm_first_done(struct gfs2_sbd *sdp)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tint error;\n\n\tif (test_bit(DFL_NO_DLM_OPS, &ls->ls_recover_flags))\n\t\treturn;\n\n\terror = control_first_done(sdp);\n\tif (error)\n\t\tfs_err(sdp, \"mount first_done error %d\\n\", error);\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"sys.h\"",
      "#include \"util.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/dlm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs_err",
          "args": [
            "sdp",
            "\"mount first_done error %d\\n\"",
            "error"
          ],
          "line": 1290
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_vfs_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_debug.c",
          "lines": "43-56",
          "snippet": "void cifs_vfs_err(const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"CIFS VFS: %pV\", &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"cifsfs.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n\nvoid cifs_vfs_err(const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"CIFS VFS: %pV\", &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "control_first_done",
          "args": [
            "sdp"
          ],
          "line": 1288
        },
        "resolved": true,
        "details": {
          "function_name": "control_first_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lock_dlm.c",
          "lines": "939-995",
          "snippet": "static int control_first_done(struct gfs2_sbd *sdp)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tuint32_t start_gen, block_gen;\n\tint error;\n\nrestart:\n\tspin_lock(&ls->ls_recover_spin);\n\tstart_gen = ls->ls_recover_start;\n\tblock_gen = ls->ls_recover_block;\n\n\tif (test_bit(DFL_BLOCK_LOCKS, &ls->ls_recover_flags) ||\n\t    !test_bit(DFL_MOUNT_DONE, &ls->ls_recover_flags) ||\n\t    !test_bit(DFL_FIRST_MOUNT, &ls->ls_recover_flags)) {\n\t\t/* sanity check, should not happen */\n\t\tfs_err(sdp, \"control_first_done start %u block %u flags %lx\\n\",\n\t\t       start_gen, block_gen, ls->ls_recover_flags);\n\t\tspin_unlock(&ls->ls_recover_spin);\n\t\tcontrol_unlock(sdp);\n\t\treturn -1;\n\t}\n\n\tif (start_gen == block_gen) {\n\t\t/*\n\t\t * Wait for the end of a dlm recovery cycle to switch from\n\t\t * first mounter recovery.  We can ignore any recover_slot\n\t\t * callbacks between the recover_prep and next recover_done\n\t\t * because we are still the first mounter and any failed nodes\n\t\t * have not fully mounted, so they don't need recovery.\n\t\t */\n\t\tspin_unlock(&ls->ls_recover_spin);\n\t\tfs_info(sdp, \"control_first_done wait gen %u\\n\", start_gen);\n\n\t\twait_on_bit(&ls->ls_recover_flags, DFL_DLM_RECOVERY,\n\t\t\t    TASK_UNINTERRUPTIBLE);\n\t\tgoto restart;\n\t}\n\n\tclear_bit(DFL_FIRST_MOUNT, &ls->ls_recover_flags);\n\tset_bit(DFL_FIRST_MOUNT_DONE, &ls->ls_recover_flags);\n\tmemset(ls->ls_recover_submit, 0, ls->ls_recover_size*sizeof(uint32_t));\n\tmemset(ls->ls_recover_result, 0, ls->ls_recover_size*sizeof(uint32_t));\n\tspin_unlock(&ls->ls_recover_spin);\n\n\tmemset(ls->ls_lvb_bits, 0, GDLM_LVB_SIZE);\n\tcontrol_lvb_write(ls, start_gen, ls->ls_lvb_bits);\n\n\terror = mounted_lock(sdp, DLM_LOCK_PR, DLM_LKF_CONVERT);\n\tif (error)\n\t\tfs_err(sdp, \"control_first_done mounted PR error %d\\n\", error);\n\n\terror = control_lock(sdp, DLM_LOCK_NL, DLM_LKF_CONVERT|DLM_LKF_VALBLK);\n\tif (error)\n\t\tfs_err(sdp, \"control_first_done control NL error %d\\n\", error);\n\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/dlm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/dlm.h>\n#include <linux/fs.h>\n\nstatic int control_first_done(struct gfs2_sbd *sdp)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tuint32_t start_gen, block_gen;\n\tint error;\n\nrestart:\n\tspin_lock(&ls->ls_recover_spin);\n\tstart_gen = ls->ls_recover_start;\n\tblock_gen = ls->ls_recover_block;\n\n\tif (test_bit(DFL_BLOCK_LOCKS, &ls->ls_recover_flags) ||\n\t    !test_bit(DFL_MOUNT_DONE, &ls->ls_recover_flags) ||\n\t    !test_bit(DFL_FIRST_MOUNT, &ls->ls_recover_flags)) {\n\t\t/* sanity check, should not happen */\n\t\tfs_err(sdp, \"control_first_done start %u block %u flags %lx\\n\",\n\t\t       start_gen, block_gen, ls->ls_recover_flags);\n\t\tspin_unlock(&ls->ls_recover_spin);\n\t\tcontrol_unlock(sdp);\n\t\treturn -1;\n\t}\n\n\tif (start_gen == block_gen) {\n\t\t/*\n\t\t * Wait for the end of a dlm recovery cycle to switch from\n\t\t * first mounter recovery.  We can ignore any recover_slot\n\t\t * callbacks between the recover_prep and next recover_done\n\t\t * because we are still the first mounter and any failed nodes\n\t\t * have not fully mounted, so they don't need recovery.\n\t\t */\n\t\tspin_unlock(&ls->ls_recover_spin);\n\t\tfs_info(sdp, \"control_first_done wait gen %u\\n\", start_gen);\n\n\t\twait_on_bit(&ls->ls_recover_flags, DFL_DLM_RECOVERY,\n\t\t\t    TASK_UNINTERRUPTIBLE);\n\t\tgoto restart;\n\t}\n\n\tclear_bit(DFL_FIRST_MOUNT, &ls->ls_recover_flags);\n\tset_bit(DFL_FIRST_MOUNT_DONE, &ls->ls_recover_flags);\n\tmemset(ls->ls_recover_submit, 0, ls->ls_recover_size*sizeof(uint32_t));\n\tmemset(ls->ls_recover_result, 0, ls->ls_recover_size*sizeof(uint32_t));\n\tspin_unlock(&ls->ls_recover_spin);\n\n\tmemset(ls->ls_lvb_bits, 0, GDLM_LVB_SIZE);\n\tcontrol_lvb_write(ls, start_gen, ls->ls_lvb_bits);\n\n\terror = mounted_lock(sdp, DLM_LOCK_PR, DLM_LKF_CONVERT);\n\tif (error)\n\t\tfs_err(sdp, \"control_first_done mounted PR error %d\\n\", error);\n\n\terror = control_lock(sdp, DLM_LOCK_NL, DLM_LKF_CONVERT|DLM_LKF_VALBLK);\n\tif (error)\n\t\tfs_err(sdp, \"control_first_done control NL error %d\\n\", error);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "DFL_NO_DLM_OPS",
            "&ls->ls_recover_flags"
          ],
          "line": 1285
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/dlm.h>\n#include <linux/fs.h>\n\nstatic void gdlm_first_done(struct gfs2_sbd *sdp)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tint error;\n\n\tif (test_bit(DFL_NO_DLM_OPS, &ls->ls_recover_flags))\n\t\treturn;\n\n\terror = control_first_done(sdp);\n\tif (error)\n\t\tfs_err(sdp, \"mount first_done error %d\\n\", error);\n}"
  },
  {
    "function_name": "gdlm_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lock_dlm.c",
    "lines": "1183-1278",
    "snippet": "static int gdlm_mount(struct gfs2_sbd *sdp, const char *table)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tchar cluster[GFS2_LOCKNAME_LEN];\n\tconst char *fsname;\n\tuint32_t flags;\n\tint error, ops_result;\n\n\t/*\n\t * initialize everything\n\t */\n\n\tINIT_DELAYED_WORK(&sdp->sd_control_work, gfs2_control_func);\n\tspin_lock_init(&ls->ls_recover_spin);\n\tls->ls_recover_flags = 0;\n\tls->ls_recover_mount = 0;\n\tls->ls_recover_start = 0;\n\tls->ls_recover_block = 0;\n\tls->ls_recover_size = 0;\n\tls->ls_recover_submit = NULL;\n\tls->ls_recover_result = NULL;\n\tls->ls_lvb_bits = NULL;\n\n\terror = set_recover_size(sdp, NULL, 0);\n\tif (error)\n\t\tgoto fail;\n\n\t/*\n\t * prepare dlm_new_lockspace args\n\t */\n\n\tfsname = strchr(table, ':');\n\tif (!fsname) {\n\t\tfs_info(sdp, \"no fsname found\\n\");\n\t\terror = -EINVAL;\n\t\tgoto fail_free;\n\t}\n\tmemset(cluster, 0, sizeof(cluster));\n\tmemcpy(cluster, table, strlen(table) - strlen(fsname));\n\tfsname++;\n\n\tflags = DLM_LSFL_FS | DLM_LSFL_NEWEXCL;\n\n\t/*\n\t * create/join lockspace\n\t */\n\n\terror = dlm_new_lockspace(fsname, cluster, flags, GDLM_LVB_SIZE,\n\t\t\t\t  &gdlm_lockspace_ops, sdp, &ops_result,\n\t\t\t\t  &ls->ls_dlm);\n\tif (error) {\n\t\tfs_err(sdp, \"dlm_new_lockspace error %d\\n\", error);\n\t\tgoto fail_free;\n\t}\n\n\tif (ops_result < 0) {\n\t\t/*\n\t\t * dlm does not support ops callbacks,\n\t\t * old dlm_controld/gfs_controld are used, try without ops.\n\t\t */\n\t\tfs_info(sdp, \"dlm lockspace ops not used\\n\");\n\t\tfree_recover_size(ls);\n\t\tset_bit(DFL_NO_DLM_OPS, &ls->ls_recover_flags);\n\t\treturn 0;\n\t}\n\n\tif (!test_bit(SDF_NOJOURNALID, &sdp->sd_flags)) {\n\t\tfs_err(sdp, \"dlm lockspace ops disallow jid preset\\n\");\n\t\terror = -EINVAL;\n\t\tgoto fail_release;\n\t}\n\n\t/*\n\t * control_mount() uses control_lock to determine first mounter,\n\t * and for later mounts, waits for any recoveries to be cleared.\n\t */\n\n\terror = control_mount(sdp);\n\tif (error) {\n\t\tfs_err(sdp, \"mount control error %d\\n\", error);\n\t\tgoto fail_release;\n\t}\n\n\tls->ls_first = !!test_bit(DFL_FIRST_MOUNT, &ls->ls_recover_flags);\n\tclear_bit(SDF_NOJOURNALID, &sdp->sd_flags);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&sdp->sd_flags, SDF_NOJOURNALID);\n\treturn 0;\n\nfail_release:\n\tdlm_release_lockspace(ls->ls_dlm, 2);\nfail_free:\n\tfree_recover_size(ls);\nfail:\n\treturn error;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"sys.h\"",
      "#include \"util.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/dlm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct dlm_lockspace_ops gdlm_lockspace_ops = {\n\t.recover_prep = gdlm_recover_prep,\n\t.recover_slot = gdlm_recover_slot,\n\t.recover_done = gdlm_recover_done,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_recover_size",
          "args": [
            "ls"
          ],
          "line": 1275
        },
        "resolved": true,
        "details": {
          "function_name": "free_recover_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lock_dlm.c",
          "lines": "1053-1061",
          "snippet": "static void free_recover_size(struct lm_lockstruct *ls)\n{\n\tkfree(ls->ls_lvb_bits);\n\tkfree(ls->ls_recover_submit);\n\tkfree(ls->ls_recover_result);\n\tls->ls_recover_submit = NULL;\n\tls->ls_recover_result = NULL;\n\tls->ls_recover_size = 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/dlm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/dlm.h>\n#include <linux/fs.h>\n\nstatic void free_recover_size(struct lm_lockstruct *ls)\n{\n\tkfree(ls->ls_lvb_bits);\n\tkfree(ls->ls_recover_submit);\n\tkfree(ls->ls_recover_result);\n\tls->ls_recover_submit = NULL;\n\tls->ls_recover_result = NULL;\n\tls->ls_recover_size = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_release_lockspace",
          "args": [
            "ls->ls_dlm",
            "2"
          ],
          "line": 1273
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_release_lockspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
          "lines": "873-892",
          "snippet": "int dlm_release_lockspace(void *lockspace, int force)\n{\n\tstruct dlm_ls *ls;\n\tint error;\n\n\tls = dlm_find_lockspace_local(lockspace);\n\tif (!ls)\n\t\treturn -EINVAL;\n\tdlm_put_lockspace(ls);\n\n\tmutex_lock(&ls_lock);\n\terror = release_lockspace(ls, force);\n\tif (!error)\n\t\tls_count--;\n\tif (!ls_count)\n\t\tthreads_stop();\n\tmutex_unlock(&ls_lock);\n\n\treturn error;\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"requestqueue.h\"",
            "#include \"recover.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dir.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t\t\tls_count;",
            "static struct mutex\t\tls_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int\t\t\tls_count;\nstatic struct mutex\t\tls_lock;\n\nint dlm_release_lockspace(void *lockspace, int force)\n{\n\tstruct dlm_ls *ls;\n\tint error;\n\n\tls = dlm_find_lockspace_local(lockspace);\n\tif (!ls)\n\t\treturn -EINVAL;\n\tdlm_put_lockspace(ls);\n\n\tmutex_lock(&ls_lock);\n\terror = release_lockspace(ls, force);\n\tif (!error)\n\t\tls_count--;\n\tif (!ls_count)\n\t\tthreads_stop();\n\tmutex_unlock(&ls_lock);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_bit",
          "args": [
            "&sdp->sd_flags",
            "SDF_NOJOURNALID"
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb__after_atomic",
          "args": [],
          "line": 1268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "SDF_NOJOURNALID",
            "&sdp->sd_flags"
          ],
          "line": 1267
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "DFL_FIRST_MOUNT",
            "&ls->ls_recover_flags"
          ],
          "line": 1266
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_err",
          "args": [
            "sdp",
            "\"mount control error %d\\n\"",
            "error"
          ],
          "line": 1262
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_vfs_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_debug.c",
          "lines": "43-56",
          "snippet": "void cifs_vfs_err(const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"CIFS VFS: %pV\", &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"cifsfs.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n\nvoid cifs_vfs_err(const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"CIFS VFS: %pV\", &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "control_mount",
          "args": [
            "sdp"
          ],
          "line": 1260
        },
        "resolved": true,
        "details": {
          "function_name": "control_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lock_dlm.c",
          "lines": "755-937",
          "snippet": "static int control_mount(struct gfs2_sbd *sdp)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tuint32_t start_gen, block_gen, mount_gen, lvb_gen;\n\tint mounted_mode;\n\tint retries = 0;\n\tint error;\n\n\tmemset(&ls->ls_mounted_lksb, 0, sizeof(struct dlm_lksb));\n\tmemset(&ls->ls_control_lksb, 0, sizeof(struct dlm_lksb));\n\tmemset(&ls->ls_control_lvb, 0, GDLM_LVB_SIZE);\n\tls->ls_control_lksb.sb_lvbptr = ls->ls_control_lvb;\n\tinit_completion(&ls->ls_sync_wait);\n\n\tset_bit(DFL_BLOCK_LOCKS, &ls->ls_recover_flags);\n\n\terror = control_lock(sdp, DLM_LOCK_NL, DLM_LKF_VALBLK);\n\tif (error) {\n\t\tfs_err(sdp, \"control_mount control_lock NL error %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = mounted_lock(sdp, DLM_LOCK_NL, 0);\n\tif (error) {\n\t\tfs_err(sdp, \"control_mount mounted_lock NL error %d\\n\", error);\n\t\tcontrol_unlock(sdp);\n\t\treturn error;\n\t}\n\tmounted_mode = DLM_LOCK_NL;\n\nrestart:\n\tif (retries++ && signal_pending(current)) {\n\t\terror = -EINTR;\n\t\tgoto fail;\n\t}\n\n\t/*\n\t * We always start with both locks in NL. control_lock is\n\t * demoted to NL below so we don't need to do it here.\n\t */\n\n\tif (mounted_mode != DLM_LOCK_NL) {\n\t\terror = mounted_lock(sdp, DLM_LOCK_NL, DLM_LKF_CONVERT);\n\t\tif (error)\n\t\t\tgoto fail;\n\t\tmounted_mode = DLM_LOCK_NL;\n\t}\n\n\t/*\n\t * Other nodes need to do some work in dlm recovery and gfs2_control\n\t * before the recover_done and control_lock will be ready for us below.\n\t * A delay here is not required but often avoids having to retry.\n\t */\n\n\tmsleep_interruptible(500);\n\n\t/*\n\t * Acquire control_lock in EX and mounted_lock in either EX or PR.\n\t * control_lock lvb keeps track of any pending journal recoveries.\n\t * mounted_lock indicates if any other nodes have the fs mounted.\n\t */\n\n\terror = control_lock(sdp, DLM_LOCK_EX, DLM_LKF_CONVERT|DLM_LKF_NOQUEUE|DLM_LKF_VALBLK);\n\tif (error == -EAGAIN) {\n\t\tgoto restart;\n\t} else if (error) {\n\t\tfs_err(sdp, \"control_mount control_lock EX error %d\\n\", error);\n\t\tgoto fail;\n\t}\n\n\terror = mounted_lock(sdp, DLM_LOCK_EX, DLM_LKF_CONVERT|DLM_LKF_NOQUEUE);\n\tif (!error) {\n\t\tmounted_mode = DLM_LOCK_EX;\n\t\tgoto locks_done;\n\t} else if (error != -EAGAIN) {\n\t\tfs_err(sdp, \"control_mount mounted_lock EX error %d\\n\", error);\n\t\tgoto fail;\n\t}\n\n\terror = mounted_lock(sdp, DLM_LOCK_PR, DLM_LKF_CONVERT|DLM_LKF_NOQUEUE);\n\tif (!error) {\n\t\tmounted_mode = DLM_LOCK_PR;\n\t\tgoto locks_done;\n\t} else {\n\t\t/* not even -EAGAIN should happen here */\n\t\tfs_err(sdp, \"control_mount mounted_lock PR error %d\\n\", error);\n\t\tgoto fail;\n\t}\n\nlocks_done:\n\t/*\n\t * If we got both locks above in EX, then we're the first mounter.\n\t * If not, then we need to wait for the control_lock lvb to be\n\t * updated by other mounted nodes to reflect our mount generation.\n\t *\n\t * In simple first mounter cases, first mounter will see zero lvb_gen,\n\t * but in cases where all existing nodes leave/fail before mounting\n\t * nodes finish control_mount, then all nodes will be mounting and\n\t * lvb_gen will be non-zero.\n\t */\n\n\tcontrol_lvb_read(ls, &lvb_gen, ls->ls_lvb_bits);\n\n\tif (lvb_gen == 0xFFFFFFFF) {\n\t\t/* special value to force mount attempts to fail */\n\t\tfs_err(sdp, \"control_mount control_lock disabled\\n\");\n\t\terror = -EINVAL;\n\t\tgoto fail;\n\t}\n\n\tif (mounted_mode == DLM_LOCK_EX) {\n\t\t/* first mounter, keep both EX while doing first recovery */\n\t\tspin_lock(&ls->ls_recover_spin);\n\t\tclear_bit(DFL_BLOCK_LOCKS, &ls->ls_recover_flags);\n\t\tset_bit(DFL_MOUNT_DONE, &ls->ls_recover_flags);\n\t\tset_bit(DFL_FIRST_MOUNT, &ls->ls_recover_flags);\n\t\tspin_unlock(&ls->ls_recover_spin);\n\t\tfs_info(sdp, \"first mounter control generation %u\\n\", lvb_gen);\n\t\treturn 0;\n\t}\n\n\terror = control_lock(sdp, DLM_LOCK_NL, DLM_LKF_CONVERT);\n\tif (error)\n\t\tgoto fail;\n\n\t/*\n\t * We are not first mounter, now we need to wait for the control_lock\n\t * lvb generation to be >= the generation from our first recover_done\n\t * and all lvb bits to be clear (no pending journal recoveries.)\n\t */\n\n\tif (!all_jid_bits_clear(ls->ls_lvb_bits)) {\n\t\t/* journals need recovery, wait until all are clear */\n\t\tfs_info(sdp, \"control_mount wait for journal recovery\\n\");\n\t\tgoto restart;\n\t}\n\n\tspin_lock(&ls->ls_recover_spin);\n\tblock_gen = ls->ls_recover_block;\n\tstart_gen = ls->ls_recover_start;\n\tmount_gen = ls->ls_recover_mount;\n\n\tif (lvb_gen < mount_gen) {\n\t\t/* wait for mounted nodes to update control_lock lvb to our\n\t\t   generation, which might include new recovery bits set */\n\t\tfs_info(sdp, \"control_mount wait1 block %u start %u mount %u \"\n\t\t\t\"lvb %u flags %lx\\n\", block_gen, start_gen, mount_gen,\n\t\t\tlvb_gen, ls->ls_recover_flags);\n\t\tspin_unlock(&ls->ls_recover_spin);\n\t\tgoto restart;\n\t}\n\n\tif (lvb_gen != start_gen) {\n\t\t/* wait for mounted nodes to update control_lock lvb to the\n\t\t   latest recovery generation */\n\t\tfs_info(sdp, \"control_mount wait2 block %u start %u mount %u \"\n\t\t\t\"lvb %u flags %lx\\n\", block_gen, start_gen, mount_gen,\n\t\t\tlvb_gen, ls->ls_recover_flags);\n\t\tspin_unlock(&ls->ls_recover_spin);\n\t\tgoto restart;\n\t}\n\n\tif (block_gen == start_gen) {\n\t\t/* dlm recovery in progress, wait for it to finish */\n\t\tfs_info(sdp, \"control_mount wait3 block %u start %u mount %u \"\n\t\t\t\"lvb %u flags %lx\\n\", block_gen, start_gen, mount_gen,\n\t\t\tlvb_gen, ls->ls_recover_flags);\n\t\tspin_unlock(&ls->ls_recover_spin);\n\t\tgoto restart;\n\t}\n\n\tclear_bit(DFL_BLOCK_LOCKS, &ls->ls_recover_flags);\n\tset_bit(DFL_MOUNT_DONE, &ls->ls_recover_flags);\n\tmemset(ls->ls_recover_submit, 0, ls->ls_recover_size*sizeof(uint32_t));\n\tmemset(ls->ls_recover_result, 0, ls->ls_recover_size*sizeof(uint32_t));\n\tspin_unlock(&ls->ls_recover_spin);\n\treturn 0;\n\nfail:\n\tmounted_unlock(sdp);\n\tcontrol_unlock(sdp);\n\treturn error;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/dlm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/dlm.h>\n#include <linux/fs.h>\n\nstatic int control_mount(struct gfs2_sbd *sdp)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tuint32_t start_gen, block_gen, mount_gen, lvb_gen;\n\tint mounted_mode;\n\tint retries = 0;\n\tint error;\n\n\tmemset(&ls->ls_mounted_lksb, 0, sizeof(struct dlm_lksb));\n\tmemset(&ls->ls_control_lksb, 0, sizeof(struct dlm_lksb));\n\tmemset(&ls->ls_control_lvb, 0, GDLM_LVB_SIZE);\n\tls->ls_control_lksb.sb_lvbptr = ls->ls_control_lvb;\n\tinit_completion(&ls->ls_sync_wait);\n\n\tset_bit(DFL_BLOCK_LOCKS, &ls->ls_recover_flags);\n\n\terror = control_lock(sdp, DLM_LOCK_NL, DLM_LKF_VALBLK);\n\tif (error) {\n\t\tfs_err(sdp, \"control_mount control_lock NL error %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = mounted_lock(sdp, DLM_LOCK_NL, 0);\n\tif (error) {\n\t\tfs_err(sdp, \"control_mount mounted_lock NL error %d\\n\", error);\n\t\tcontrol_unlock(sdp);\n\t\treturn error;\n\t}\n\tmounted_mode = DLM_LOCK_NL;\n\nrestart:\n\tif (retries++ && signal_pending(current)) {\n\t\terror = -EINTR;\n\t\tgoto fail;\n\t}\n\n\t/*\n\t * We always start with both locks in NL. control_lock is\n\t * demoted to NL below so we don't need to do it here.\n\t */\n\n\tif (mounted_mode != DLM_LOCK_NL) {\n\t\terror = mounted_lock(sdp, DLM_LOCK_NL, DLM_LKF_CONVERT);\n\t\tif (error)\n\t\t\tgoto fail;\n\t\tmounted_mode = DLM_LOCK_NL;\n\t}\n\n\t/*\n\t * Other nodes need to do some work in dlm recovery and gfs2_control\n\t * before the recover_done and control_lock will be ready for us below.\n\t * A delay here is not required but often avoids having to retry.\n\t */\n\n\tmsleep_interruptible(500);\n\n\t/*\n\t * Acquire control_lock in EX and mounted_lock in either EX or PR.\n\t * control_lock lvb keeps track of any pending journal recoveries.\n\t * mounted_lock indicates if any other nodes have the fs mounted.\n\t */\n\n\terror = control_lock(sdp, DLM_LOCK_EX, DLM_LKF_CONVERT|DLM_LKF_NOQUEUE|DLM_LKF_VALBLK);\n\tif (error == -EAGAIN) {\n\t\tgoto restart;\n\t} else if (error) {\n\t\tfs_err(sdp, \"control_mount control_lock EX error %d\\n\", error);\n\t\tgoto fail;\n\t}\n\n\terror = mounted_lock(sdp, DLM_LOCK_EX, DLM_LKF_CONVERT|DLM_LKF_NOQUEUE);\n\tif (!error) {\n\t\tmounted_mode = DLM_LOCK_EX;\n\t\tgoto locks_done;\n\t} else if (error != -EAGAIN) {\n\t\tfs_err(sdp, \"control_mount mounted_lock EX error %d\\n\", error);\n\t\tgoto fail;\n\t}\n\n\terror = mounted_lock(sdp, DLM_LOCK_PR, DLM_LKF_CONVERT|DLM_LKF_NOQUEUE);\n\tif (!error) {\n\t\tmounted_mode = DLM_LOCK_PR;\n\t\tgoto locks_done;\n\t} else {\n\t\t/* not even -EAGAIN should happen here */\n\t\tfs_err(sdp, \"control_mount mounted_lock PR error %d\\n\", error);\n\t\tgoto fail;\n\t}\n\nlocks_done:\n\t/*\n\t * If we got both locks above in EX, then we're the first mounter.\n\t * If not, then we need to wait for the control_lock lvb to be\n\t * updated by other mounted nodes to reflect our mount generation.\n\t *\n\t * In simple first mounter cases, first mounter will see zero lvb_gen,\n\t * but in cases where all existing nodes leave/fail before mounting\n\t * nodes finish control_mount, then all nodes will be mounting and\n\t * lvb_gen will be non-zero.\n\t */\n\n\tcontrol_lvb_read(ls, &lvb_gen, ls->ls_lvb_bits);\n\n\tif (lvb_gen == 0xFFFFFFFF) {\n\t\t/* special value to force mount attempts to fail */\n\t\tfs_err(sdp, \"control_mount control_lock disabled\\n\");\n\t\terror = -EINVAL;\n\t\tgoto fail;\n\t}\n\n\tif (mounted_mode == DLM_LOCK_EX) {\n\t\t/* first mounter, keep both EX while doing first recovery */\n\t\tspin_lock(&ls->ls_recover_spin);\n\t\tclear_bit(DFL_BLOCK_LOCKS, &ls->ls_recover_flags);\n\t\tset_bit(DFL_MOUNT_DONE, &ls->ls_recover_flags);\n\t\tset_bit(DFL_FIRST_MOUNT, &ls->ls_recover_flags);\n\t\tspin_unlock(&ls->ls_recover_spin);\n\t\tfs_info(sdp, \"first mounter control generation %u\\n\", lvb_gen);\n\t\treturn 0;\n\t}\n\n\terror = control_lock(sdp, DLM_LOCK_NL, DLM_LKF_CONVERT);\n\tif (error)\n\t\tgoto fail;\n\n\t/*\n\t * We are not first mounter, now we need to wait for the control_lock\n\t * lvb generation to be >= the generation from our first recover_done\n\t * and all lvb bits to be clear (no pending journal recoveries.)\n\t */\n\n\tif (!all_jid_bits_clear(ls->ls_lvb_bits)) {\n\t\t/* journals need recovery, wait until all are clear */\n\t\tfs_info(sdp, \"control_mount wait for journal recovery\\n\");\n\t\tgoto restart;\n\t}\n\n\tspin_lock(&ls->ls_recover_spin);\n\tblock_gen = ls->ls_recover_block;\n\tstart_gen = ls->ls_recover_start;\n\tmount_gen = ls->ls_recover_mount;\n\n\tif (lvb_gen < mount_gen) {\n\t\t/* wait for mounted nodes to update control_lock lvb to our\n\t\t   generation, which might include new recovery bits set */\n\t\tfs_info(sdp, \"control_mount wait1 block %u start %u mount %u \"\n\t\t\t\"lvb %u flags %lx\\n\", block_gen, start_gen, mount_gen,\n\t\t\tlvb_gen, ls->ls_recover_flags);\n\t\tspin_unlock(&ls->ls_recover_spin);\n\t\tgoto restart;\n\t}\n\n\tif (lvb_gen != start_gen) {\n\t\t/* wait for mounted nodes to update control_lock lvb to the\n\t\t   latest recovery generation */\n\t\tfs_info(sdp, \"control_mount wait2 block %u start %u mount %u \"\n\t\t\t\"lvb %u flags %lx\\n\", block_gen, start_gen, mount_gen,\n\t\t\tlvb_gen, ls->ls_recover_flags);\n\t\tspin_unlock(&ls->ls_recover_spin);\n\t\tgoto restart;\n\t}\n\n\tif (block_gen == start_gen) {\n\t\t/* dlm recovery in progress, wait for it to finish */\n\t\tfs_info(sdp, \"control_mount wait3 block %u start %u mount %u \"\n\t\t\t\"lvb %u flags %lx\\n\", block_gen, start_gen, mount_gen,\n\t\t\tlvb_gen, ls->ls_recover_flags);\n\t\tspin_unlock(&ls->ls_recover_spin);\n\t\tgoto restart;\n\t}\n\n\tclear_bit(DFL_BLOCK_LOCKS, &ls->ls_recover_flags);\n\tset_bit(DFL_MOUNT_DONE, &ls->ls_recover_flags);\n\tmemset(ls->ls_recover_submit, 0, ls->ls_recover_size*sizeof(uint32_t));\n\tmemset(ls->ls_recover_result, 0, ls->ls_recover_size*sizeof(uint32_t));\n\tspin_unlock(&ls->ls_recover_spin);\n\treturn 0;\n\nfail:\n\tmounted_unlock(sdp);\n\tcontrol_unlock(sdp);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "DFL_NO_DLM_OPS",
            "&ls->ls_recover_flags"
          ],
          "line": 1245
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_info",
          "args": [
            "sdp",
            "\"dlm lockspace ops not used\\n\""
          ],
          "line": 1243
        },
        "resolved": true,
        "details": {
          "function_name": "copy_fs_info_to_kstatfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "2426-2436",
          "snippet": "static void\ncopy_fs_info_to_kstatfs(struct smb2_fs_full_size_info *pfs_inf,\n\t\t\tstruct kstatfs *kst)\n{\n\tkst->f_bsize = le32_to_cpu(pfs_inf->BytesPerSector) *\n\t\t\t  le32_to_cpu(pfs_inf->SectorsPerAllocationUnit);\n\tkst->f_blocks = le64_to_cpu(pfs_inf->TotalAllocationUnits);\n\tkst->f_bfree  = le64_to_cpu(pfs_inf->ActualAvailableAllocationUnits);\n\tkst->f_bavail = le64_to_cpu(pfs_inf->CallerAvailableAllocationUnits);\n\treturn;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic void\ncopy_fs_info_to_kstatfs(struct smb2_fs_full_size_info *pfs_inf,\n\t\t\tstruct kstatfs *kst)\n{\n\tkst->f_bsize = le32_to_cpu(pfs_inf->BytesPerSector) *\n\t\t\t  le32_to_cpu(pfs_inf->SectorsPerAllocationUnit);\n\tkst->f_blocks = le64_to_cpu(pfs_inf->TotalAllocationUnits);\n\tkst->f_bfree  = le64_to_cpu(pfs_inf->ActualAvailableAllocationUnits);\n\tkst->f_bavail = le64_to_cpu(pfs_inf->CallerAvailableAllocationUnits);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_new_lockspace",
          "args": [
            "fsname",
            "cluster",
            "flags",
            "GDLM_LVB_SIZE",
            "&gdlm_lockspace_ops",
            "sdp",
            "&ops_result",
            "&ls->ls_dlm"
          ],
          "line": 1230
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_new_lockspace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lockspace.c",
          "lines": "692-716",
          "snippet": "int dlm_new_lockspace(const char *name, const char *cluster,\n\t\t      uint32_t flags, int lvblen,\n\t\t      const struct dlm_lockspace_ops *ops, void *ops_arg,\n\t\t      int *ops_result, dlm_lockspace_t **lockspace)\n{\n\tint error = 0;\n\n\tmutex_lock(&ls_lock);\n\tif (!ls_count)\n\t\terror = threads_start();\n\tif (error)\n\t\tgoto out;\n\n\terror = new_lockspace(name, cluster, flags, lvblen, ops, ops_arg,\n\t\t\t      ops_result, lockspace);\n\tif (!error)\n\t\tls_count++;\n\tif (error > 0)\n\t\terror = 0;\n\tif (!ls_count)\n\t\tthreads_stop();\n out:\n\tmutex_unlock(&ls_lock);\n\treturn error;\n}",
          "includes": [
            "#include \"ast.h\"",
            "#include \"user.h\"",
            "#include \"requestqueue.h\"",
            "#include \"recover.h\"",
            "#include \"lock.h\"",
            "#include \"memory.h\"",
            "#include \"config.h\"",
            "#include \"lowcomms.h\"",
            "#include \"dir.h\"",
            "#include \"recoverd.h\"",
            "#include \"member.h\"",
            "#include \"lockspace.h\"",
            "#include \"dlm_internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t\t\tls_count;",
            "static struct mutex\t\tls_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ast.h\"\n#include \"user.h\"\n#include \"requestqueue.h\"\n#include \"recover.h\"\n#include \"lock.h\"\n#include \"memory.h\"\n#include \"config.h\"\n#include \"lowcomms.h\"\n#include \"dir.h\"\n#include \"recoverd.h\"\n#include \"member.h\"\n#include \"lockspace.h\"\n#include \"dlm_internal.h\"\n\nstatic int\t\t\tls_count;\nstatic struct mutex\t\tls_lock;\n\nint dlm_new_lockspace(const char *name, const char *cluster,\n\t\t      uint32_t flags, int lvblen,\n\t\t      const struct dlm_lockspace_ops *ops, void *ops_arg,\n\t\t      int *ops_result, dlm_lockspace_t **lockspace)\n{\n\tint error = 0;\n\n\tmutex_lock(&ls_lock);\n\tif (!ls_count)\n\t\terror = threads_start();\n\tif (error)\n\t\tgoto out;\n\n\terror = new_lockspace(name, cluster, flags, lvblen, ops, ops_arg,\n\t\t\t      ops_result, lockspace);\n\tif (!error)\n\t\tls_count++;\n\tif (error > 0)\n\t\terror = 0;\n\tif (!ls_count)\n\t\tthreads_stop();\n out:\n\tmutex_unlock(&ls_lock);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "cluster",
            "table",
            "strlen(table) - strlen(fsname)"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "fsname"
          ],
          "line": 1221
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "cluster",
            "0",
            "sizeof(cluster)"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "table",
            "':'"
          ],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_recover_size",
          "args": [
            "sdp",
            "NULL",
            "0"
          ],
          "line": 1206
        },
        "resolved": true,
        "details": {
          "function_name": "set_recover_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lock_dlm.c",
          "lines": "1005-1051",
          "snippet": "static int set_recover_size(struct gfs2_sbd *sdp, struct dlm_slot *slots,\n\t\t\t    int num_slots)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tuint32_t *submit = NULL;\n\tuint32_t *result = NULL;\n\tuint32_t old_size, new_size;\n\tint i, max_jid;\n\n\tif (!ls->ls_lvb_bits) {\n\t\tls->ls_lvb_bits = kzalloc(GDLM_LVB_SIZE, GFP_NOFS);\n\t\tif (!ls->ls_lvb_bits)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tmax_jid = 0;\n\tfor (i = 0; i < num_slots; i++) {\n\t\tif (max_jid < slots[i].slot - 1)\n\t\t\tmax_jid = slots[i].slot - 1;\n\t}\n\n\told_size = ls->ls_recover_size;\n\n\tif (old_size >= max_jid + 1)\n\t\treturn 0;\n\n\tnew_size = old_size + RECOVER_SIZE_INC;\n\n\tsubmit = kcalloc(new_size, sizeof(uint32_t), GFP_NOFS);\n\tresult = kcalloc(new_size, sizeof(uint32_t), GFP_NOFS);\n\tif (!submit || !result) {\n\t\tkfree(submit);\n\t\tkfree(result);\n\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock(&ls->ls_recover_spin);\n\tmemcpy(submit, ls->ls_recover_submit, old_size * sizeof(uint32_t));\n\tmemcpy(result, ls->ls_recover_result, old_size * sizeof(uint32_t));\n\tkfree(ls->ls_recover_submit);\n\tkfree(ls->ls_recover_result);\n\tls->ls_recover_submit = submit;\n\tls->ls_recover_result = result;\n\tls->ls_recover_size = new_size;\n\tspin_unlock(&ls->ls_recover_spin);\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/dlm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define RECOVER_SIZE_INC 16"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/dlm.h>\n#include <linux/fs.h>\n\n#define RECOVER_SIZE_INC 16\n\nstatic int set_recover_size(struct gfs2_sbd *sdp, struct dlm_slot *slots,\n\t\t\t    int num_slots)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tuint32_t *submit = NULL;\n\tuint32_t *result = NULL;\n\tuint32_t old_size, new_size;\n\tint i, max_jid;\n\n\tif (!ls->ls_lvb_bits) {\n\t\tls->ls_lvb_bits = kzalloc(GDLM_LVB_SIZE, GFP_NOFS);\n\t\tif (!ls->ls_lvb_bits)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tmax_jid = 0;\n\tfor (i = 0; i < num_slots; i++) {\n\t\tif (max_jid < slots[i].slot - 1)\n\t\t\tmax_jid = slots[i].slot - 1;\n\t}\n\n\told_size = ls->ls_recover_size;\n\n\tif (old_size >= max_jid + 1)\n\t\treturn 0;\n\n\tnew_size = old_size + RECOVER_SIZE_INC;\n\n\tsubmit = kcalloc(new_size, sizeof(uint32_t), GFP_NOFS);\n\tresult = kcalloc(new_size, sizeof(uint32_t), GFP_NOFS);\n\tif (!submit || !result) {\n\t\tkfree(submit);\n\t\tkfree(result);\n\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock(&ls->ls_recover_spin);\n\tmemcpy(submit, ls->ls_recover_submit, old_size * sizeof(uint32_t));\n\tmemcpy(result, ls->ls_recover_result, old_size * sizeof(uint32_t));\n\tkfree(ls->ls_recover_submit);\n\tkfree(ls->ls_recover_result);\n\tls->ls_recover_submit = submit;\n\tls->ls_recover_result = result;\n\tls->ls_recover_size = new_size;\n\tspin_unlock(&ls->ls_recover_spin);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&ls->ls_recover_spin"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_DELAYED_WORK",
          "args": [
            "&sdp->sd_control_work",
            "gfs2_control_func"
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/dlm.h>\n#include <linux/fs.h>\n\nconst struct dlm_lockspace_ops gdlm_lockspace_ops = {\n\t.recover_prep = gdlm_recover_prep,\n\t.recover_slot = gdlm_recover_slot,\n\t.recover_done = gdlm_recover_done,\n};\n\nstatic int gdlm_mount(struct gfs2_sbd *sdp, const char *table)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tchar cluster[GFS2_LOCKNAME_LEN];\n\tconst char *fsname;\n\tuint32_t flags;\n\tint error, ops_result;\n\n\t/*\n\t * initialize everything\n\t */\n\n\tINIT_DELAYED_WORK(&sdp->sd_control_work, gfs2_control_func);\n\tspin_lock_init(&ls->ls_recover_spin);\n\tls->ls_recover_flags = 0;\n\tls->ls_recover_mount = 0;\n\tls->ls_recover_start = 0;\n\tls->ls_recover_block = 0;\n\tls->ls_recover_size = 0;\n\tls->ls_recover_submit = NULL;\n\tls->ls_recover_result = NULL;\n\tls->ls_lvb_bits = NULL;\n\n\terror = set_recover_size(sdp, NULL, 0);\n\tif (error)\n\t\tgoto fail;\n\n\t/*\n\t * prepare dlm_new_lockspace args\n\t */\n\n\tfsname = strchr(table, ':');\n\tif (!fsname) {\n\t\tfs_info(sdp, \"no fsname found\\n\");\n\t\terror = -EINVAL;\n\t\tgoto fail_free;\n\t}\n\tmemset(cluster, 0, sizeof(cluster));\n\tmemcpy(cluster, table, strlen(table) - strlen(fsname));\n\tfsname++;\n\n\tflags = DLM_LSFL_FS | DLM_LSFL_NEWEXCL;\n\n\t/*\n\t * create/join lockspace\n\t */\n\n\terror = dlm_new_lockspace(fsname, cluster, flags, GDLM_LVB_SIZE,\n\t\t\t\t  &gdlm_lockspace_ops, sdp, &ops_result,\n\t\t\t\t  &ls->ls_dlm);\n\tif (error) {\n\t\tfs_err(sdp, \"dlm_new_lockspace error %d\\n\", error);\n\t\tgoto fail_free;\n\t}\n\n\tif (ops_result < 0) {\n\t\t/*\n\t\t * dlm does not support ops callbacks,\n\t\t * old dlm_controld/gfs_controld are used, try without ops.\n\t\t */\n\t\tfs_info(sdp, \"dlm lockspace ops not used\\n\");\n\t\tfree_recover_size(ls);\n\t\tset_bit(DFL_NO_DLM_OPS, &ls->ls_recover_flags);\n\t\treturn 0;\n\t}\n\n\tif (!test_bit(SDF_NOJOURNALID, &sdp->sd_flags)) {\n\t\tfs_err(sdp, \"dlm lockspace ops disallow jid preset\\n\");\n\t\terror = -EINVAL;\n\t\tgoto fail_release;\n\t}\n\n\t/*\n\t * control_mount() uses control_lock to determine first mounter,\n\t * and for later mounts, waits for any recoveries to be cleared.\n\t */\n\n\terror = control_mount(sdp);\n\tif (error) {\n\t\tfs_err(sdp, \"mount control error %d\\n\", error);\n\t\tgoto fail_release;\n\t}\n\n\tls->ls_first = !!test_bit(DFL_FIRST_MOUNT, &ls->ls_recover_flags);\n\tclear_bit(SDF_NOJOURNALID, &sdp->sd_flags);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&sdp->sd_flags, SDF_NOJOURNALID);\n\treturn 0;\n\nfail_release:\n\tdlm_release_lockspace(ls->ls_dlm, 2);\nfail_free:\n\tfree_recover_size(ls);\nfail:\n\treturn error;\n}"
  },
  {
    "function_name": "gdlm_recovery_result",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lock_dlm.c",
    "lines": "1138-1175",
    "snippet": "static void gdlm_recovery_result(struct gfs2_sbd *sdp, unsigned int jid,\n\t\t\t\t unsigned int result)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\n\tif (test_bit(DFL_NO_DLM_OPS, &ls->ls_recover_flags))\n\t\treturn;\n\n\t/* don't care about the recovery of own journal during mount */\n\tif (jid == ls->ls_jid)\n\t\treturn;\n\n\tspin_lock(&ls->ls_recover_spin);\n\tif (test_bit(DFL_FIRST_MOUNT, &ls->ls_recover_flags)) {\n\t\tspin_unlock(&ls->ls_recover_spin);\n\t\treturn;\n\t}\n\tif (ls->ls_recover_size < jid + 1) {\n\t\tfs_err(sdp, \"recovery_result jid %d short size %d\",\n\t\t       jid, ls->ls_recover_size);\n\t\tspin_unlock(&ls->ls_recover_spin);\n\t\treturn;\n\t}\n\n\tfs_info(sdp, \"recover jid %d result %s\\n\", jid,\n\t\tresult == LM_RD_GAVEUP ? \"busy\" : \"success\");\n\n\tls->ls_recover_result[jid] = result;\n\n\t/* GAVEUP means another node is recovering the journal; delay our\n\t   next attempt to recover it, to give the other node a chance to\n\t   finish before trying again */\n\n\tif (!test_bit(DFL_UNMOUNT, &ls->ls_recover_flags))\n\t\tqueue_delayed_work(gfs2_control_wq, &sdp->sd_control_work,\n\t\t\t\t   result == LM_RD_GAVEUP ? HZ : 0);\n\tspin_unlock(&ls->ls_recover_spin);\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"sys.h\"",
      "#include \"util.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/dlm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern struct workqueue_struct *gfs2_control_wq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ls->ls_recover_spin"
          ],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_delayed_work",
          "args": [
            "gfs2_control_wq",
            "&sdp->sd_control_work",
            "result == LM_RD_GAVEUP ? HZ : 0"
          ],
          "line": 1172
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_sc_queue_delayed_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "481-488",
          "snippet": "static void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\tstruct delayed_work *work,\n\t\t\t\t\tint delay)\n{\n\tsc_get(sc);\n\tif (!queue_delayed_work(o2net_wq, work, delay))\n\t\tsc_put(sc);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *o2net_wq;",
            "static void o2net_sc_connect_completed(struct work_struct *work);",
            "static void o2net_rx_until_empty(struct work_struct *work);",
            "static void o2net_shutdown_sc(struct work_struct *work);",
            "static void o2net_sc_send_keep_req(struct work_struct *work);",
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct workqueue_struct *o2net_wq;\nstatic void o2net_sc_connect_completed(struct work_struct *work);\nstatic void o2net_rx_until_empty(struct work_struct *work);\nstatic void o2net_shutdown_sc(struct work_struct *work);\nstatic void o2net_sc_send_keep_req(struct work_struct *work);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\tstruct delayed_work *work,\n\t\t\t\t\tint delay)\n{\n\tsc_get(sc);\n\tif (!queue_delayed_work(o2net_wq, work, delay))\n\t\tsc_put(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "DFL_UNMOUNT",
            "&ls->ls_recover_flags"
          ],
          "line": 1171
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_info",
          "args": [
            "sdp",
            "\"recover jid %d result %s\\n\"",
            "jid",
            "result == LM_RD_GAVEUP ? \"busy\" : \"success\""
          ],
          "line": 1162
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "280-288",
          "snippet": "void reiserfs_info(struct super_block *sb, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_NOTICE \"REISERFS (device %s): %s\",\n\t\t       sb->s_id, error_buf);\n\telse\n\t\tprintk(KERN_NOTICE \"REISERFS %s:\", error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid reiserfs_info(struct super_block *sb, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_NOTICE \"REISERFS (device %s): %s\",\n\t\t       sb->s_id, error_buf);\n\telse\n\t\tprintk(KERN_NOTICE \"REISERFS %s:\", error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_err",
          "args": [
            "sdp",
            "\"recovery_result jid %d short size %d\"",
            "jid",
            "ls->ls_recover_size"
          ],
          "line": 1156
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_vfs_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_debug.c",
          "lines": "43-56",
          "snippet": "void cifs_vfs_err(const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"CIFS VFS: %pV\", &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"cifsfs.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n\nvoid cifs_vfs_err(const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"CIFS VFS: %pV\", &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ls->ls_recover_spin"
          ],
          "line": 1150
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/dlm.h>\n#include <linux/fs.h>\n\nextern struct workqueue_struct *gfs2_control_wq;\n\nstatic void gdlm_recovery_result(struct gfs2_sbd *sdp, unsigned int jid,\n\t\t\t\t unsigned int result)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\n\tif (test_bit(DFL_NO_DLM_OPS, &ls->ls_recover_flags))\n\t\treturn;\n\n\t/* don't care about the recovery of own journal during mount */\n\tif (jid == ls->ls_jid)\n\t\treturn;\n\n\tspin_lock(&ls->ls_recover_spin);\n\tif (test_bit(DFL_FIRST_MOUNT, &ls->ls_recover_flags)) {\n\t\tspin_unlock(&ls->ls_recover_spin);\n\t\treturn;\n\t}\n\tif (ls->ls_recover_size < jid + 1) {\n\t\tfs_err(sdp, \"recovery_result jid %d short size %d\",\n\t\t       jid, ls->ls_recover_size);\n\t\tspin_unlock(&ls->ls_recover_spin);\n\t\treturn;\n\t}\n\n\tfs_info(sdp, \"recover jid %d result %s\\n\", jid,\n\t\tresult == LM_RD_GAVEUP ? \"busy\" : \"success\");\n\n\tls->ls_recover_result[jid] = result;\n\n\t/* GAVEUP means another node is recovering the journal; delay our\n\t   next attempt to recover it, to give the other node a chance to\n\t   finish before trying again */\n\n\tif (!test_bit(DFL_UNMOUNT, &ls->ls_recover_flags))\n\t\tqueue_delayed_work(gfs2_control_wq, &sdp->sd_control_work,\n\t\t\t\t   result == LM_RD_GAVEUP ? HZ : 0);\n\tspin_unlock(&ls->ls_recover_spin);\n}"
  },
  {
    "function_name": "gdlm_recover_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lock_dlm.c",
    "lines": "1110-1134",
    "snippet": "static void gdlm_recover_done(void *arg, struct dlm_slot *slots, int num_slots,\n\t\t\t      int our_slot, uint32_t generation)\n{\n\tstruct gfs2_sbd *sdp = arg;\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\n\t/* ensure the ls jid arrays are large enough */\n\tset_recover_size(sdp, slots, num_slots);\n\n\tspin_lock(&ls->ls_recover_spin);\n\tls->ls_recover_start = generation;\n\n\tif (!ls->ls_recover_mount) {\n\t\tls->ls_recover_mount = generation;\n\t\tls->ls_jid = our_slot - 1;\n\t}\n\n\tif (!test_bit(DFL_UNMOUNT, &ls->ls_recover_flags))\n\t\tqueue_delayed_work(gfs2_control_wq, &sdp->sd_control_work, 0);\n\n\tclear_bit(DFL_DLM_RECOVERY, &ls->ls_recover_flags);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&ls->ls_recover_flags, DFL_DLM_RECOVERY);\n\tspin_unlock(&ls->ls_recover_spin);\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"sys.h\"",
      "#include \"util.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/dlm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern struct workqueue_struct *gfs2_control_wq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ls->ls_recover_spin"
          ],
          "line": 1133
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_bit",
          "args": [
            "&ls->ls_recover_flags",
            "DFL_DLM_RECOVERY"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_mb__after_atomic",
          "args": [],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "DFL_DLM_RECOVERY",
            "&ls->ls_recover_flags"
          ],
          "line": 1130
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_delayed_work",
          "args": [
            "gfs2_control_wq",
            "&sdp->sd_control_work",
            "0"
          ],
          "line": 1128
        },
        "resolved": true,
        "details": {
          "function_name": "o2net_sc_queue_delayed_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/tcp.c",
          "lines": "481-488",
          "snippet": "static void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\tstruct delayed_work *work,\n\t\t\t\t\tint delay)\n{\n\tsc_get(sc);\n\tif (!queue_delayed_work(o2net_wq, work, delay))\n\t\tsc_put(sc);\n}",
          "includes": [
            "#include \"tcp_internal.h\"",
            "#include \"quorum.h\"",
            "#include \"masklog.h\"",
            "#include \"nodemanager.h\"",
            "#include \"tcp.h\"",
            "#include \"heartbeat.h\"",
            "#include <asm/uaccess.h>",
            "#include <net/tcp.h>",
            "#include <linux/export.h>",
            "#include <linux/net.h>",
            "#include <linux/kref.h>",
            "#include <linux/idr.h>",
            "#include <linux/slab.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *o2net_wq;",
            "static void o2net_sc_connect_completed(struct work_struct *work);",
            "static void o2net_rx_until_empty(struct work_struct *work);",
            "static void o2net_shutdown_sc(struct work_struct *work);",
            "static void o2net_sc_send_keep_req(struct work_struct *work);",
            "static void o2net_sc_postpone_idle(struct o2net_sock_container *sc);",
            "static void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tcp_internal.h\"\n#include \"quorum.h\"\n#include \"masklog.h\"\n#include \"nodemanager.h\"\n#include \"tcp.h\"\n#include \"heartbeat.h\"\n#include <asm/uaccess.h>\n#include <net/tcp.h>\n#include <linux/export.h>\n#include <linux/net.h>\n#include <linux/kref.h>\n#include <linux/idr.h>\n#include <linux/slab.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n\nstatic struct workqueue_struct *o2net_wq;\nstatic void o2net_sc_connect_completed(struct work_struct *work);\nstatic void o2net_rx_until_empty(struct work_struct *work);\nstatic void o2net_shutdown_sc(struct work_struct *work);\nstatic void o2net_sc_send_keep_req(struct work_struct *work);\nstatic void o2net_sc_postpone_idle(struct o2net_sock_container *sc);\nstatic void o2net_sc_reset_idle_timer(struct o2net_sock_container *sc);\n\nstatic void o2net_sc_queue_delayed_work(struct o2net_sock_container *sc,\n\t\t\t\t\tstruct delayed_work *work,\n\t\t\t\t\tint delay)\n{\n\tsc_get(sc);\n\tif (!queue_delayed_work(o2net_wq, work, delay))\n\t\tsc_put(sc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "DFL_UNMOUNT",
            "&ls->ls_recover_flags"
          ],
          "line": 1127
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ls->ls_recover_spin"
          ],
          "line": 1119
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_recover_size",
          "args": [
            "sdp",
            "slots",
            "num_slots"
          ],
          "line": 1117
        },
        "resolved": true,
        "details": {
          "function_name": "set_recover_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lock_dlm.c",
          "lines": "1005-1051",
          "snippet": "static int set_recover_size(struct gfs2_sbd *sdp, struct dlm_slot *slots,\n\t\t\t    int num_slots)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tuint32_t *submit = NULL;\n\tuint32_t *result = NULL;\n\tuint32_t old_size, new_size;\n\tint i, max_jid;\n\n\tif (!ls->ls_lvb_bits) {\n\t\tls->ls_lvb_bits = kzalloc(GDLM_LVB_SIZE, GFP_NOFS);\n\t\tif (!ls->ls_lvb_bits)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tmax_jid = 0;\n\tfor (i = 0; i < num_slots; i++) {\n\t\tif (max_jid < slots[i].slot - 1)\n\t\t\tmax_jid = slots[i].slot - 1;\n\t}\n\n\told_size = ls->ls_recover_size;\n\n\tif (old_size >= max_jid + 1)\n\t\treturn 0;\n\n\tnew_size = old_size + RECOVER_SIZE_INC;\n\n\tsubmit = kcalloc(new_size, sizeof(uint32_t), GFP_NOFS);\n\tresult = kcalloc(new_size, sizeof(uint32_t), GFP_NOFS);\n\tif (!submit || !result) {\n\t\tkfree(submit);\n\t\tkfree(result);\n\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock(&ls->ls_recover_spin);\n\tmemcpy(submit, ls->ls_recover_submit, old_size * sizeof(uint32_t));\n\tmemcpy(result, ls->ls_recover_result, old_size * sizeof(uint32_t));\n\tkfree(ls->ls_recover_submit);\n\tkfree(ls->ls_recover_result);\n\tls->ls_recover_submit = submit;\n\tls->ls_recover_result = result;\n\tls->ls_recover_size = new_size;\n\tspin_unlock(&ls->ls_recover_spin);\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/dlm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define RECOVER_SIZE_INC 16"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/dlm.h>\n#include <linux/fs.h>\n\n#define RECOVER_SIZE_INC 16\n\nstatic int set_recover_size(struct gfs2_sbd *sdp, struct dlm_slot *slots,\n\t\t\t    int num_slots)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tuint32_t *submit = NULL;\n\tuint32_t *result = NULL;\n\tuint32_t old_size, new_size;\n\tint i, max_jid;\n\n\tif (!ls->ls_lvb_bits) {\n\t\tls->ls_lvb_bits = kzalloc(GDLM_LVB_SIZE, GFP_NOFS);\n\t\tif (!ls->ls_lvb_bits)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tmax_jid = 0;\n\tfor (i = 0; i < num_slots; i++) {\n\t\tif (max_jid < slots[i].slot - 1)\n\t\t\tmax_jid = slots[i].slot - 1;\n\t}\n\n\told_size = ls->ls_recover_size;\n\n\tif (old_size >= max_jid + 1)\n\t\treturn 0;\n\n\tnew_size = old_size + RECOVER_SIZE_INC;\n\n\tsubmit = kcalloc(new_size, sizeof(uint32_t), GFP_NOFS);\n\tresult = kcalloc(new_size, sizeof(uint32_t), GFP_NOFS);\n\tif (!submit || !result) {\n\t\tkfree(submit);\n\t\tkfree(result);\n\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock(&ls->ls_recover_spin);\n\tmemcpy(submit, ls->ls_recover_submit, old_size * sizeof(uint32_t));\n\tmemcpy(result, ls->ls_recover_result, old_size * sizeof(uint32_t));\n\tkfree(ls->ls_recover_submit);\n\tkfree(ls->ls_recover_result);\n\tls->ls_recover_submit = submit;\n\tls->ls_recover_result = result;\n\tls->ls_recover_size = new_size;\n\tspin_unlock(&ls->ls_recover_spin);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/dlm.h>\n#include <linux/fs.h>\n\nextern struct workqueue_struct *gfs2_control_wq;\n\nstatic void gdlm_recover_done(void *arg, struct dlm_slot *slots, int num_slots,\n\t\t\t      int our_slot, uint32_t generation)\n{\n\tstruct gfs2_sbd *sdp = arg;\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\n\t/* ensure the ls jid arrays are large enough */\n\tset_recover_size(sdp, slots, num_slots);\n\n\tspin_lock(&ls->ls_recover_spin);\n\tls->ls_recover_start = generation;\n\n\tif (!ls->ls_recover_mount) {\n\t\tls->ls_recover_mount = generation;\n\t\tls->ls_jid = our_slot - 1;\n\t}\n\n\tif (!test_bit(DFL_UNMOUNT, &ls->ls_recover_flags))\n\t\tqueue_delayed_work(gfs2_control_wq, &sdp->sd_control_work, 0);\n\n\tclear_bit(DFL_DLM_RECOVERY, &ls->ls_recover_flags);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&ls->ls_recover_flags, DFL_DLM_RECOVERY);\n\tspin_unlock(&ls->ls_recover_spin);\n}"
  },
  {
    "function_name": "gdlm_recover_slot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lock_dlm.c",
    "lines": "1086-1106",
    "snippet": "static void gdlm_recover_slot(void *arg, struct dlm_slot *slot)\n{\n\tstruct gfs2_sbd *sdp = arg;\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tint jid = slot->slot - 1;\n\n\tspin_lock(&ls->ls_recover_spin);\n\tif (ls->ls_recover_size < jid + 1) {\n\t\tfs_err(sdp, \"recover_slot jid %d gen %u short size %d\",\n\t\t       jid, ls->ls_recover_block, ls->ls_recover_size);\n\t\tspin_unlock(&ls->ls_recover_spin);\n\t\treturn;\n\t}\n\n\tif (ls->ls_recover_submit[jid]) {\n\t\tfs_info(sdp, \"recover_slot jid %d gen %u prev %u\\n\",\n\t\t\tjid, ls->ls_recover_block, ls->ls_recover_submit[jid]);\n\t}\n\tls->ls_recover_submit[jid] = ls->ls_recover_block;\n\tspin_unlock(&ls->ls_recover_spin);\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"sys.h\"",
      "#include \"util.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/dlm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ls->ls_recover_spin"
          ],
          "line": 1105
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_info",
          "args": [
            "sdp",
            "\"recover_slot jid %d gen %u prev %u\\n\"",
            "jid",
            "ls->ls_recover_block",
            "ls->ls_recover_submit[jid]"
          ],
          "line": 1101
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "280-288",
          "snippet": "void reiserfs_info(struct super_block *sb, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_NOTICE \"REISERFS (device %s): %s\",\n\t\t       sb->s_id, error_buf);\n\telse\n\t\tprintk(KERN_NOTICE \"REISERFS %s:\", error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid reiserfs_info(struct super_block *sb, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_NOTICE \"REISERFS (device %s): %s\",\n\t\t       sb->s_id, error_buf);\n\telse\n\t\tprintk(KERN_NOTICE \"REISERFS %s:\", error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_err",
          "args": [
            "sdp",
            "\"recover_slot jid %d gen %u short size %d\"",
            "jid",
            "ls->ls_recover_block",
            "ls->ls_recover_size"
          ],
          "line": 1094
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_vfs_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_debug.c",
          "lines": "43-56",
          "snippet": "void cifs_vfs_err(const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"CIFS VFS: %pV\", &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"cifsfs.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n\nvoid cifs_vfs_err(const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"CIFS VFS: %pV\", &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ls->ls_recover_spin"
          ],
          "line": 1092
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/dlm.h>\n#include <linux/fs.h>\n\nstatic void gdlm_recover_slot(void *arg, struct dlm_slot *slot)\n{\n\tstruct gfs2_sbd *sdp = arg;\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tint jid = slot->slot - 1;\n\n\tspin_lock(&ls->ls_recover_spin);\n\tif (ls->ls_recover_size < jid + 1) {\n\t\tfs_err(sdp, \"recover_slot jid %d gen %u short size %d\",\n\t\t       jid, ls->ls_recover_block, ls->ls_recover_size);\n\t\tspin_unlock(&ls->ls_recover_spin);\n\t\treturn;\n\t}\n\n\tif (ls->ls_recover_submit[jid]) {\n\t\tfs_info(sdp, \"recover_slot jid %d gen %u prev %u\\n\",\n\t\t\tjid, ls->ls_recover_block, ls->ls_recover_submit[jid]);\n\t}\n\tls->ls_recover_submit[jid] = ls->ls_recover_block;\n\tspin_unlock(&ls->ls_recover_spin);\n}"
  },
  {
    "function_name": "gdlm_recover_prep",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lock_dlm.c",
    "lines": "1065-1081",
    "snippet": "static void gdlm_recover_prep(void *arg)\n{\n\tstruct gfs2_sbd *sdp = arg;\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\n\tspin_lock(&ls->ls_recover_spin);\n\tls->ls_recover_block = ls->ls_recover_start;\n\tset_bit(DFL_DLM_RECOVERY, &ls->ls_recover_flags);\n\n\tif (!test_bit(DFL_MOUNT_DONE, &ls->ls_recover_flags) ||\n\t     test_bit(DFL_FIRST_MOUNT, &ls->ls_recover_flags)) {\n\t\tspin_unlock(&ls->ls_recover_spin);\n\t\treturn;\n\t}\n\tset_bit(DFL_BLOCK_LOCKS, &ls->ls_recover_flags);\n\tspin_unlock(&ls->ls_recover_spin);\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"sys.h\"",
      "#include \"util.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/dlm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ls->ls_recover_spin"
          ],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "DFL_BLOCK_LOCKS",
            "&ls->ls_recover_flags"
          ],
          "line": 1079
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "DFL_FIRST_MOUNT",
            "&ls->ls_recover_flags"
          ],
          "line": 1075
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ls->ls_recover_spin"
          ],
          "line": 1070
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/dlm.h>\n#include <linux/fs.h>\n\nstatic void gdlm_recover_prep(void *arg)\n{\n\tstruct gfs2_sbd *sdp = arg;\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\n\tspin_lock(&ls->ls_recover_spin);\n\tls->ls_recover_block = ls->ls_recover_start;\n\tset_bit(DFL_DLM_RECOVERY, &ls->ls_recover_flags);\n\n\tif (!test_bit(DFL_MOUNT_DONE, &ls->ls_recover_flags) ||\n\t     test_bit(DFL_FIRST_MOUNT, &ls->ls_recover_flags)) {\n\t\tspin_unlock(&ls->ls_recover_spin);\n\t\treturn;\n\t}\n\tset_bit(DFL_BLOCK_LOCKS, &ls->ls_recover_flags);\n\tspin_unlock(&ls->ls_recover_spin);\n}"
  },
  {
    "function_name": "free_recover_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lock_dlm.c",
    "lines": "1053-1061",
    "snippet": "static void free_recover_size(struct lm_lockstruct *ls)\n{\n\tkfree(ls->ls_lvb_bits);\n\tkfree(ls->ls_recover_submit);\n\tkfree(ls->ls_recover_result);\n\tls->ls_recover_submit = NULL;\n\tls->ls_recover_result = NULL;\n\tls->ls_recover_size = 0;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"sys.h\"",
      "#include \"util.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/dlm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ls->ls_recover_result"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ls->ls_recover_submit"
          ],
          "line": 1056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ls->ls_lvb_bits"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/dlm.h>\n#include <linux/fs.h>\n\nstatic void free_recover_size(struct lm_lockstruct *ls)\n{\n\tkfree(ls->ls_lvb_bits);\n\tkfree(ls->ls_recover_submit);\n\tkfree(ls->ls_recover_result);\n\tls->ls_recover_submit = NULL;\n\tls->ls_recover_result = NULL;\n\tls->ls_recover_size = 0;\n}"
  },
  {
    "function_name": "set_recover_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lock_dlm.c",
    "lines": "1005-1051",
    "snippet": "static int set_recover_size(struct gfs2_sbd *sdp, struct dlm_slot *slots,\n\t\t\t    int num_slots)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tuint32_t *submit = NULL;\n\tuint32_t *result = NULL;\n\tuint32_t old_size, new_size;\n\tint i, max_jid;\n\n\tif (!ls->ls_lvb_bits) {\n\t\tls->ls_lvb_bits = kzalloc(GDLM_LVB_SIZE, GFP_NOFS);\n\t\tif (!ls->ls_lvb_bits)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tmax_jid = 0;\n\tfor (i = 0; i < num_slots; i++) {\n\t\tif (max_jid < slots[i].slot - 1)\n\t\t\tmax_jid = slots[i].slot - 1;\n\t}\n\n\told_size = ls->ls_recover_size;\n\n\tif (old_size >= max_jid + 1)\n\t\treturn 0;\n\n\tnew_size = old_size + RECOVER_SIZE_INC;\n\n\tsubmit = kcalloc(new_size, sizeof(uint32_t), GFP_NOFS);\n\tresult = kcalloc(new_size, sizeof(uint32_t), GFP_NOFS);\n\tif (!submit || !result) {\n\t\tkfree(submit);\n\t\tkfree(result);\n\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock(&ls->ls_recover_spin);\n\tmemcpy(submit, ls->ls_recover_submit, old_size * sizeof(uint32_t));\n\tmemcpy(result, ls->ls_recover_result, old_size * sizeof(uint32_t));\n\tkfree(ls->ls_recover_submit);\n\tkfree(ls->ls_recover_result);\n\tls->ls_recover_submit = submit;\n\tls->ls_recover_result = result;\n\tls->ls_recover_size = new_size;\n\tspin_unlock(&ls->ls_recover_spin);\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"sys.h\"",
      "#include \"util.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/dlm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define RECOVER_SIZE_INC 16"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ls->ls_recover_spin"
          ],
          "line": 1049
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ls->ls_recover_result"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ls->ls_recover_submit"
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "result",
            "ls->ls_recover_result",
            "old_size * sizeof(uint32_t)"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "submit",
            "ls->ls_recover_submit",
            "old_size * sizeof(uint32_t)"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ls->ls_recover_spin"
          ],
          "line": 1041
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "result"
          ],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "submit"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "new_size",
            "sizeof(uint32_t)",
            "GFP_NOFS"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "new_size",
            "sizeof(uint32_t)",
            "GFP_NOFS"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "GDLM_LVB_SIZE",
            "GFP_NOFS"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/dlm.h>\n#include <linux/fs.h>\n\n#define RECOVER_SIZE_INC 16\n\nstatic int set_recover_size(struct gfs2_sbd *sdp, struct dlm_slot *slots,\n\t\t\t    int num_slots)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tuint32_t *submit = NULL;\n\tuint32_t *result = NULL;\n\tuint32_t old_size, new_size;\n\tint i, max_jid;\n\n\tif (!ls->ls_lvb_bits) {\n\t\tls->ls_lvb_bits = kzalloc(GDLM_LVB_SIZE, GFP_NOFS);\n\t\tif (!ls->ls_lvb_bits)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tmax_jid = 0;\n\tfor (i = 0; i < num_slots; i++) {\n\t\tif (max_jid < slots[i].slot - 1)\n\t\t\tmax_jid = slots[i].slot - 1;\n\t}\n\n\told_size = ls->ls_recover_size;\n\n\tif (old_size >= max_jid + 1)\n\t\treturn 0;\n\n\tnew_size = old_size + RECOVER_SIZE_INC;\n\n\tsubmit = kcalloc(new_size, sizeof(uint32_t), GFP_NOFS);\n\tresult = kcalloc(new_size, sizeof(uint32_t), GFP_NOFS);\n\tif (!submit || !result) {\n\t\tkfree(submit);\n\t\tkfree(result);\n\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock(&ls->ls_recover_spin);\n\tmemcpy(submit, ls->ls_recover_submit, old_size * sizeof(uint32_t));\n\tmemcpy(result, ls->ls_recover_result, old_size * sizeof(uint32_t));\n\tkfree(ls->ls_recover_submit);\n\tkfree(ls->ls_recover_result);\n\tls->ls_recover_submit = submit;\n\tls->ls_recover_result = result;\n\tls->ls_recover_size = new_size;\n\tspin_unlock(&ls->ls_recover_spin);\n\treturn 0;\n}"
  },
  {
    "function_name": "control_first_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lock_dlm.c",
    "lines": "939-995",
    "snippet": "static int control_first_done(struct gfs2_sbd *sdp)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tuint32_t start_gen, block_gen;\n\tint error;\n\nrestart:\n\tspin_lock(&ls->ls_recover_spin);\n\tstart_gen = ls->ls_recover_start;\n\tblock_gen = ls->ls_recover_block;\n\n\tif (test_bit(DFL_BLOCK_LOCKS, &ls->ls_recover_flags) ||\n\t    !test_bit(DFL_MOUNT_DONE, &ls->ls_recover_flags) ||\n\t    !test_bit(DFL_FIRST_MOUNT, &ls->ls_recover_flags)) {\n\t\t/* sanity check, should not happen */\n\t\tfs_err(sdp, \"control_first_done start %u block %u flags %lx\\n\",\n\t\t       start_gen, block_gen, ls->ls_recover_flags);\n\t\tspin_unlock(&ls->ls_recover_spin);\n\t\tcontrol_unlock(sdp);\n\t\treturn -1;\n\t}\n\n\tif (start_gen == block_gen) {\n\t\t/*\n\t\t * Wait for the end of a dlm recovery cycle to switch from\n\t\t * first mounter recovery.  We can ignore any recover_slot\n\t\t * callbacks between the recover_prep and next recover_done\n\t\t * because we are still the first mounter and any failed nodes\n\t\t * have not fully mounted, so they don't need recovery.\n\t\t */\n\t\tspin_unlock(&ls->ls_recover_spin);\n\t\tfs_info(sdp, \"control_first_done wait gen %u\\n\", start_gen);\n\n\t\twait_on_bit(&ls->ls_recover_flags, DFL_DLM_RECOVERY,\n\t\t\t    TASK_UNINTERRUPTIBLE);\n\t\tgoto restart;\n\t}\n\n\tclear_bit(DFL_FIRST_MOUNT, &ls->ls_recover_flags);\n\tset_bit(DFL_FIRST_MOUNT_DONE, &ls->ls_recover_flags);\n\tmemset(ls->ls_recover_submit, 0, ls->ls_recover_size*sizeof(uint32_t));\n\tmemset(ls->ls_recover_result, 0, ls->ls_recover_size*sizeof(uint32_t));\n\tspin_unlock(&ls->ls_recover_spin);\n\n\tmemset(ls->ls_lvb_bits, 0, GDLM_LVB_SIZE);\n\tcontrol_lvb_write(ls, start_gen, ls->ls_lvb_bits);\n\n\terror = mounted_lock(sdp, DLM_LOCK_PR, DLM_LKF_CONVERT);\n\tif (error)\n\t\tfs_err(sdp, \"control_first_done mounted PR error %d\\n\", error);\n\n\terror = control_lock(sdp, DLM_LOCK_NL, DLM_LKF_CONVERT|DLM_LKF_VALBLK);\n\tif (error)\n\t\tfs_err(sdp, \"control_first_done control NL error %d\\n\", error);\n\n\treturn error;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"sys.h\"",
      "#include \"util.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/dlm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs_err",
          "args": [
            "sdp",
            "\"control_first_done control NL error %d\\n\"",
            "error"
          ],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_vfs_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_debug.c",
          "lines": "43-56",
          "snippet": "void cifs_vfs_err(const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"CIFS VFS: %pV\", &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"cifsfs.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n\nvoid cifs_vfs_err(const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"CIFS VFS: %pV\", &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "control_lock",
          "args": [
            "sdp",
            "DLM_LOCK_NL",
            "DLM_LKF_CONVERT|DLM_LKF_VALBLK"
          ],
          "line": 990
        },
        "resolved": true,
        "details": {
          "function_name": "control_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lock_dlm.c",
          "lines": "570-575",
          "snippet": "static int control_lock(struct gfs2_sbd *sdp, int mode, uint32_t flags)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\treturn sync_lock(sdp, mode, flags, GFS2_CONTROL_LOCK,\n\t\t\t &ls->ls_control_lksb, \"control_lock\");\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/dlm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/dlm.h>\n#include <linux/fs.h>\n\nstatic int control_lock(struct gfs2_sbd *sdp, int mode, uint32_t flags)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\treturn sync_lock(sdp, mode, flags, GFS2_CONTROL_LOCK,\n\t\t\t &ls->ls_control_lksb, \"control_lock\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mounted_lock",
          "args": [
            "sdp",
            "DLM_LOCK_PR",
            "DLM_LKF_CONVERT"
          ],
          "line": 986
        },
        "resolved": true,
        "details": {
          "function_name": "mounted_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lock_dlm.c",
          "lines": "557-562",
          "snippet": "static int mounted_lock(struct gfs2_sbd *sdp, int mode, uint32_t flags)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\treturn sync_lock(sdp, mode, flags, GFS2_MOUNTED_LOCK,\n\t\t\t &ls->ls_mounted_lksb, \"mounted_lock\");\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/dlm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/dlm.h>\n#include <linux/fs.h>\n\nstatic int mounted_lock(struct gfs2_sbd *sdp, int mode, uint32_t flags)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\treturn sync_lock(sdp, mode, flags, GFS2_MOUNTED_LOCK,\n\t\t\t &ls->ls_mounted_lksb, \"mounted_lock\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "control_lvb_write",
          "args": [
            "ls",
            "start_gen",
            "ls->ls_lvb_bits"
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "control_lvb_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lock_dlm.c",
          "lines": "477-484",
          "snippet": "static void control_lvb_write(struct lm_lockstruct *ls, uint32_t lvb_gen,\n\t\t\t      char *lvb_bits)\n{\n\t__le32 gen;\n\tmemcpy(ls->ls_control_lvb, lvb_bits, GDLM_LVB_SIZE);\n\tgen = cpu_to_le32(lvb_gen);\n\tmemcpy(ls->ls_control_lvb, &gen, sizeof(__le32));\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/dlm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/dlm.h>\n#include <linux/fs.h>\n\nstatic void control_lvb_write(struct lm_lockstruct *ls, uint32_t lvb_gen,\n\t\t\t      char *lvb_bits)\n{\n\t__le32 gen;\n\tmemcpy(ls->ls_control_lvb, lvb_bits, GDLM_LVB_SIZE);\n\tgen = cpu_to_le32(lvb_gen);\n\tmemcpy(ls->ls_control_lvb, &gen, sizeof(__le32));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ls->ls_lvb_bits",
            "0",
            "GDLM_LVB_SIZE"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ls->ls_recover_spin"
          ],
          "line": 981
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ls->ls_recover_result",
            "0",
            "ls->ls_recover_size*sizeof(uint32_t)"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ls->ls_recover_submit",
            "0",
            "ls->ls_recover_size*sizeof(uint32_t)"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "DFL_FIRST_MOUNT_DONE",
            "&ls->ls_recover_flags"
          ],
          "line": 978
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "DFL_FIRST_MOUNT",
            "&ls->ls_recover_flags"
          ],
          "line": 977
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_on_bit",
          "args": [
            "&ls->ls_recover_flags",
            "DFL_DLM_RECOVERY",
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_info",
          "args": [
            "sdp",
            "\"control_first_done wait gen %u\\n\"",
            "start_gen"
          ],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "280-288",
          "snippet": "void reiserfs_info(struct super_block *sb, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_NOTICE \"REISERFS (device %s): %s\",\n\t\t       sb->s_id, error_buf);\n\telse\n\t\tprintk(KERN_NOTICE \"REISERFS %s:\", error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid reiserfs_info(struct super_block *sb, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_NOTICE \"REISERFS (device %s): %s\",\n\t\t       sb->s_id, error_buf);\n\telse\n\t\tprintk(KERN_NOTICE \"REISERFS %s:\", error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "control_unlock",
          "args": [
            "sdp"
          ],
          "line": 957
        },
        "resolved": true,
        "details": {
          "function_name": "control_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lock_dlm.c",
          "lines": "564-568",
          "snippet": "static int control_unlock(struct gfs2_sbd *sdp)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\treturn sync_unlock(sdp, &ls->ls_control_lksb, \"control_lock\");\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/dlm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/dlm.h>\n#include <linux/fs.h>\n\nstatic int control_unlock(struct gfs2_sbd *sdp)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\treturn sync_unlock(sdp, &ls->ls_control_lksb, \"control_lock\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "DFL_FIRST_MOUNT",
            "&ls->ls_recover_flags"
          ],
          "line": 952
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ls->ls_recover_spin"
          ],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/dlm.h>\n#include <linux/fs.h>\n\nstatic int control_first_done(struct gfs2_sbd *sdp)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tuint32_t start_gen, block_gen;\n\tint error;\n\nrestart:\n\tspin_lock(&ls->ls_recover_spin);\n\tstart_gen = ls->ls_recover_start;\n\tblock_gen = ls->ls_recover_block;\n\n\tif (test_bit(DFL_BLOCK_LOCKS, &ls->ls_recover_flags) ||\n\t    !test_bit(DFL_MOUNT_DONE, &ls->ls_recover_flags) ||\n\t    !test_bit(DFL_FIRST_MOUNT, &ls->ls_recover_flags)) {\n\t\t/* sanity check, should not happen */\n\t\tfs_err(sdp, \"control_first_done start %u block %u flags %lx\\n\",\n\t\t       start_gen, block_gen, ls->ls_recover_flags);\n\t\tspin_unlock(&ls->ls_recover_spin);\n\t\tcontrol_unlock(sdp);\n\t\treturn -1;\n\t}\n\n\tif (start_gen == block_gen) {\n\t\t/*\n\t\t * Wait for the end of a dlm recovery cycle to switch from\n\t\t * first mounter recovery.  We can ignore any recover_slot\n\t\t * callbacks between the recover_prep and next recover_done\n\t\t * because we are still the first mounter and any failed nodes\n\t\t * have not fully mounted, so they don't need recovery.\n\t\t */\n\t\tspin_unlock(&ls->ls_recover_spin);\n\t\tfs_info(sdp, \"control_first_done wait gen %u\\n\", start_gen);\n\n\t\twait_on_bit(&ls->ls_recover_flags, DFL_DLM_RECOVERY,\n\t\t\t    TASK_UNINTERRUPTIBLE);\n\t\tgoto restart;\n\t}\n\n\tclear_bit(DFL_FIRST_MOUNT, &ls->ls_recover_flags);\n\tset_bit(DFL_FIRST_MOUNT_DONE, &ls->ls_recover_flags);\n\tmemset(ls->ls_recover_submit, 0, ls->ls_recover_size*sizeof(uint32_t));\n\tmemset(ls->ls_recover_result, 0, ls->ls_recover_size*sizeof(uint32_t));\n\tspin_unlock(&ls->ls_recover_spin);\n\n\tmemset(ls->ls_lvb_bits, 0, GDLM_LVB_SIZE);\n\tcontrol_lvb_write(ls, start_gen, ls->ls_lvb_bits);\n\n\terror = mounted_lock(sdp, DLM_LOCK_PR, DLM_LKF_CONVERT);\n\tif (error)\n\t\tfs_err(sdp, \"control_first_done mounted PR error %d\\n\", error);\n\n\terror = control_lock(sdp, DLM_LOCK_NL, DLM_LKF_CONVERT|DLM_LKF_VALBLK);\n\tif (error)\n\t\tfs_err(sdp, \"control_first_done control NL error %d\\n\", error);\n\n\treturn error;\n}"
  },
  {
    "function_name": "control_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lock_dlm.c",
    "lines": "755-937",
    "snippet": "static int control_mount(struct gfs2_sbd *sdp)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tuint32_t start_gen, block_gen, mount_gen, lvb_gen;\n\tint mounted_mode;\n\tint retries = 0;\n\tint error;\n\n\tmemset(&ls->ls_mounted_lksb, 0, sizeof(struct dlm_lksb));\n\tmemset(&ls->ls_control_lksb, 0, sizeof(struct dlm_lksb));\n\tmemset(&ls->ls_control_lvb, 0, GDLM_LVB_SIZE);\n\tls->ls_control_lksb.sb_lvbptr = ls->ls_control_lvb;\n\tinit_completion(&ls->ls_sync_wait);\n\n\tset_bit(DFL_BLOCK_LOCKS, &ls->ls_recover_flags);\n\n\terror = control_lock(sdp, DLM_LOCK_NL, DLM_LKF_VALBLK);\n\tif (error) {\n\t\tfs_err(sdp, \"control_mount control_lock NL error %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = mounted_lock(sdp, DLM_LOCK_NL, 0);\n\tif (error) {\n\t\tfs_err(sdp, \"control_mount mounted_lock NL error %d\\n\", error);\n\t\tcontrol_unlock(sdp);\n\t\treturn error;\n\t}\n\tmounted_mode = DLM_LOCK_NL;\n\nrestart:\n\tif (retries++ && signal_pending(current)) {\n\t\terror = -EINTR;\n\t\tgoto fail;\n\t}\n\n\t/*\n\t * We always start with both locks in NL. control_lock is\n\t * demoted to NL below so we don't need to do it here.\n\t */\n\n\tif (mounted_mode != DLM_LOCK_NL) {\n\t\terror = mounted_lock(sdp, DLM_LOCK_NL, DLM_LKF_CONVERT);\n\t\tif (error)\n\t\t\tgoto fail;\n\t\tmounted_mode = DLM_LOCK_NL;\n\t}\n\n\t/*\n\t * Other nodes need to do some work in dlm recovery and gfs2_control\n\t * before the recover_done and control_lock will be ready for us below.\n\t * A delay here is not required but often avoids having to retry.\n\t */\n\n\tmsleep_interruptible(500);\n\n\t/*\n\t * Acquire control_lock in EX and mounted_lock in either EX or PR.\n\t * control_lock lvb keeps track of any pending journal recoveries.\n\t * mounted_lock indicates if any other nodes have the fs mounted.\n\t */\n\n\terror = control_lock(sdp, DLM_LOCK_EX, DLM_LKF_CONVERT|DLM_LKF_NOQUEUE|DLM_LKF_VALBLK);\n\tif (error == -EAGAIN) {\n\t\tgoto restart;\n\t} else if (error) {\n\t\tfs_err(sdp, \"control_mount control_lock EX error %d\\n\", error);\n\t\tgoto fail;\n\t}\n\n\terror = mounted_lock(sdp, DLM_LOCK_EX, DLM_LKF_CONVERT|DLM_LKF_NOQUEUE);\n\tif (!error) {\n\t\tmounted_mode = DLM_LOCK_EX;\n\t\tgoto locks_done;\n\t} else if (error != -EAGAIN) {\n\t\tfs_err(sdp, \"control_mount mounted_lock EX error %d\\n\", error);\n\t\tgoto fail;\n\t}\n\n\terror = mounted_lock(sdp, DLM_LOCK_PR, DLM_LKF_CONVERT|DLM_LKF_NOQUEUE);\n\tif (!error) {\n\t\tmounted_mode = DLM_LOCK_PR;\n\t\tgoto locks_done;\n\t} else {\n\t\t/* not even -EAGAIN should happen here */\n\t\tfs_err(sdp, \"control_mount mounted_lock PR error %d\\n\", error);\n\t\tgoto fail;\n\t}\n\nlocks_done:\n\t/*\n\t * If we got both locks above in EX, then we're the first mounter.\n\t * If not, then we need to wait for the control_lock lvb to be\n\t * updated by other mounted nodes to reflect our mount generation.\n\t *\n\t * In simple first mounter cases, first mounter will see zero lvb_gen,\n\t * but in cases where all existing nodes leave/fail before mounting\n\t * nodes finish control_mount, then all nodes will be mounting and\n\t * lvb_gen will be non-zero.\n\t */\n\n\tcontrol_lvb_read(ls, &lvb_gen, ls->ls_lvb_bits);\n\n\tif (lvb_gen == 0xFFFFFFFF) {\n\t\t/* special value to force mount attempts to fail */\n\t\tfs_err(sdp, \"control_mount control_lock disabled\\n\");\n\t\terror = -EINVAL;\n\t\tgoto fail;\n\t}\n\n\tif (mounted_mode == DLM_LOCK_EX) {\n\t\t/* first mounter, keep both EX while doing first recovery */\n\t\tspin_lock(&ls->ls_recover_spin);\n\t\tclear_bit(DFL_BLOCK_LOCKS, &ls->ls_recover_flags);\n\t\tset_bit(DFL_MOUNT_DONE, &ls->ls_recover_flags);\n\t\tset_bit(DFL_FIRST_MOUNT, &ls->ls_recover_flags);\n\t\tspin_unlock(&ls->ls_recover_spin);\n\t\tfs_info(sdp, \"first mounter control generation %u\\n\", lvb_gen);\n\t\treturn 0;\n\t}\n\n\terror = control_lock(sdp, DLM_LOCK_NL, DLM_LKF_CONVERT);\n\tif (error)\n\t\tgoto fail;\n\n\t/*\n\t * We are not first mounter, now we need to wait for the control_lock\n\t * lvb generation to be >= the generation from our first recover_done\n\t * and all lvb bits to be clear (no pending journal recoveries.)\n\t */\n\n\tif (!all_jid_bits_clear(ls->ls_lvb_bits)) {\n\t\t/* journals need recovery, wait until all are clear */\n\t\tfs_info(sdp, \"control_mount wait for journal recovery\\n\");\n\t\tgoto restart;\n\t}\n\n\tspin_lock(&ls->ls_recover_spin);\n\tblock_gen = ls->ls_recover_block;\n\tstart_gen = ls->ls_recover_start;\n\tmount_gen = ls->ls_recover_mount;\n\n\tif (lvb_gen < mount_gen) {\n\t\t/* wait for mounted nodes to update control_lock lvb to our\n\t\t   generation, which might include new recovery bits set */\n\t\tfs_info(sdp, \"control_mount wait1 block %u start %u mount %u \"\n\t\t\t\"lvb %u flags %lx\\n\", block_gen, start_gen, mount_gen,\n\t\t\tlvb_gen, ls->ls_recover_flags);\n\t\tspin_unlock(&ls->ls_recover_spin);\n\t\tgoto restart;\n\t}\n\n\tif (lvb_gen != start_gen) {\n\t\t/* wait for mounted nodes to update control_lock lvb to the\n\t\t   latest recovery generation */\n\t\tfs_info(sdp, \"control_mount wait2 block %u start %u mount %u \"\n\t\t\t\"lvb %u flags %lx\\n\", block_gen, start_gen, mount_gen,\n\t\t\tlvb_gen, ls->ls_recover_flags);\n\t\tspin_unlock(&ls->ls_recover_spin);\n\t\tgoto restart;\n\t}\n\n\tif (block_gen == start_gen) {\n\t\t/* dlm recovery in progress, wait for it to finish */\n\t\tfs_info(sdp, \"control_mount wait3 block %u start %u mount %u \"\n\t\t\t\"lvb %u flags %lx\\n\", block_gen, start_gen, mount_gen,\n\t\t\tlvb_gen, ls->ls_recover_flags);\n\t\tspin_unlock(&ls->ls_recover_spin);\n\t\tgoto restart;\n\t}\n\n\tclear_bit(DFL_BLOCK_LOCKS, &ls->ls_recover_flags);\n\tset_bit(DFL_MOUNT_DONE, &ls->ls_recover_flags);\n\tmemset(ls->ls_recover_submit, 0, ls->ls_recover_size*sizeof(uint32_t));\n\tmemset(ls->ls_recover_result, 0, ls->ls_recover_size*sizeof(uint32_t));\n\tspin_unlock(&ls->ls_recover_spin);\n\treturn 0;\n\nfail:\n\tmounted_unlock(sdp);\n\tcontrol_unlock(sdp);\n\treturn error;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"sys.h\"",
      "#include \"util.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/dlm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "control_unlock",
          "args": [
            "sdp"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "control_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lock_dlm.c",
          "lines": "564-568",
          "snippet": "static int control_unlock(struct gfs2_sbd *sdp)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\treturn sync_unlock(sdp, &ls->ls_control_lksb, \"control_lock\");\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/dlm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/dlm.h>\n#include <linux/fs.h>\n\nstatic int control_unlock(struct gfs2_sbd *sdp)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\treturn sync_unlock(sdp, &ls->ls_control_lksb, \"control_lock\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mounted_unlock",
          "args": [
            "sdp"
          ],
          "line": 934
        },
        "resolved": true,
        "details": {
          "function_name": "mounted_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lock_dlm.c",
          "lines": "551-555",
          "snippet": "static int mounted_unlock(struct gfs2_sbd *sdp)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\treturn sync_unlock(sdp, &ls->ls_mounted_lksb, \"mounted_lock\");\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/dlm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/dlm.h>\n#include <linux/fs.h>\n\nstatic int mounted_unlock(struct gfs2_sbd *sdp)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\treturn sync_unlock(sdp, &ls->ls_mounted_lksb, \"mounted_lock\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ls->ls_recover_spin"
          ],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ls->ls_recover_result",
            "0",
            "ls->ls_recover_size*sizeof(uint32_t)"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ls->ls_recover_submit",
            "0",
            "ls->ls_recover_size*sizeof(uint32_t)"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "DFL_MOUNT_DONE",
            "&ls->ls_recover_flags"
          ],
          "line": 927
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "DFL_BLOCK_LOCKS",
            "&ls->ls_recover_flags"
          ],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_info",
          "args": [
            "sdp",
            "\"control_mount wait3 block %u start %u mount %u \"\n\t\t\t\"lvb %u flags %lx\\n\"",
            "block_gen",
            "start_gen",
            "mount_gen",
            "lvb_gen",
            "ls->ls_recover_flags"
          ],
          "line": 919
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "280-288",
          "snippet": "void reiserfs_info(struct super_block *sb, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_NOTICE \"REISERFS (device %s): %s\",\n\t\t       sb->s_id, error_buf);\n\telse\n\t\tprintk(KERN_NOTICE \"REISERFS %s:\", error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid reiserfs_info(struct super_block *sb, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_NOTICE \"REISERFS (device %s): %s\",\n\t\t       sb->s_id, error_buf);\n\telse\n\t\tprintk(KERN_NOTICE \"REISERFS %s:\", error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ls->ls_recover_spin"
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_info",
          "args": [
            "sdp",
            "\"control_mount wait for journal recovery\\n\""
          ],
          "line": 888
        },
        "resolved": true,
        "details": {
          "function_name": "copy_fs_info_to_kstatfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/smb2pdu.c",
          "lines": "2426-2436",
          "snippet": "static void\ncopy_fs_info_to_kstatfs(struct smb2_fs_full_size_info *pfs_inf,\n\t\t\tstruct kstatfs *kst)\n{\n\tkst->f_bsize = le32_to_cpu(pfs_inf->BytesPerSector) *\n\t\t\t  le32_to_cpu(pfs_inf->SectorsPerAllocationUnit);\n\tkst->f_blocks = le64_to_cpu(pfs_inf->TotalAllocationUnits);\n\tkst->f_bfree  = le64_to_cpu(pfs_inf->ActualAvailableAllocationUnits);\n\tkst->f_bavail = le64_to_cpu(pfs_inf->CallerAvailableAllocationUnits);\n\treturn;\n}",
          "includes": [
            "#include \"cifspdu.h\"",
            "#include \"smb2glob.h\"",
            "#include \"smb2status.h\"",
            "#include \"ntlmssp.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifs_unicode.h\"",
            "#include \"smb2proto.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsacl.h\"",
            "#include \"cifsglob.h\"",
            "#include \"smb2pdu.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifspdu.h\"\n#include \"smb2glob.h\"\n#include \"smb2status.h\"\n#include \"ntlmssp.h\"\n#include \"cifs_debug.h\"\n#include \"cifs_unicode.h\"\n#include \"smb2proto.h\"\n#include \"cifsproto.h\"\n#include \"cifsacl.h\"\n#include \"cifsglob.h\"\n#include \"smb2pdu.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/uaccess.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/vfs.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n\nstatic void\ncopy_fs_info_to_kstatfs(struct smb2_fs_full_size_info *pfs_inf,\n\t\t\tstruct kstatfs *kst)\n{\n\tkst->f_bsize = le32_to_cpu(pfs_inf->BytesPerSector) *\n\t\t\t  le32_to_cpu(pfs_inf->SectorsPerAllocationUnit);\n\tkst->f_blocks = le64_to_cpu(pfs_inf->TotalAllocationUnits);\n\tkst->f_bfree  = le64_to_cpu(pfs_inf->ActualAvailableAllocationUnits);\n\tkst->f_bavail = le64_to_cpu(pfs_inf->CallerAvailableAllocationUnits);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "all_jid_bits_clear",
          "args": [
            "ls->ls_lvb_bits"
          ],
          "line": 886
        },
        "resolved": true,
        "details": {
          "function_name": "all_jid_bits_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lock_dlm.c",
          "lines": "486-490",
          "snippet": "static int all_jid_bits_clear(char *lvb)\n{\n\treturn !memchr_inv(lvb + JID_BITMAP_OFFSET, 0,\n\t\t\tGDLM_LVB_SIZE - JID_BITMAP_OFFSET);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/dlm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define JID_BITMAP_OFFSET 8 /* 4 byte generation number + 4 byte unused */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/dlm.h>\n#include <linux/fs.h>\n\n#define JID_BITMAP_OFFSET 8 /* 4 byte generation number + 4 byte unused */\n\nstatic int all_jid_bits_clear(char *lvb)\n{\n\treturn !memchr_inv(lvb + JID_BITMAP_OFFSET, 0,\n\t\t\tGDLM_LVB_SIZE - JID_BITMAP_OFFSET);\n}"
        }
      },
      {
        "call_info": {
          "callee": "control_lock",
          "args": [
            "sdp",
            "DLM_LOCK_NL",
            "DLM_LKF_CONVERT"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "control_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lock_dlm.c",
          "lines": "570-575",
          "snippet": "static int control_lock(struct gfs2_sbd *sdp, int mode, uint32_t flags)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\treturn sync_lock(sdp, mode, flags, GFS2_CONTROL_LOCK,\n\t\t\t &ls->ls_control_lksb, \"control_lock\");\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/dlm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/dlm.h>\n#include <linux/fs.h>\n\nstatic int control_lock(struct gfs2_sbd *sdp, int mode, uint32_t flags)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\treturn sync_lock(sdp, mode, flags, GFS2_CONTROL_LOCK,\n\t\t\t &ls->ls_control_lksb, \"control_lock\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_err",
          "args": [
            "sdp",
            "\"control_mount control_lock disabled\\n\""
          ],
          "line": 860
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_vfs_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_debug.c",
          "lines": "43-56",
          "snippet": "void cifs_vfs_err(const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"CIFS VFS: %pV\", &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"cifsfs.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n\nvoid cifs_vfs_err(const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"CIFS VFS: %pV\", &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "control_lvb_read",
          "args": [
            "ls",
            "&lvb_gen",
            "ls->ls_lvb_bits"
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "control_lvb_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lock_dlm.c",
          "lines": "468-475",
          "snippet": "static void control_lvb_read(struct lm_lockstruct *ls, uint32_t *lvb_gen,\n\t\t\t     char *lvb_bits)\n{\n\t__le32 gen;\n\tmemcpy(lvb_bits, ls->ls_control_lvb, GDLM_LVB_SIZE);\n\tmemcpy(&gen, lvb_bits, sizeof(__le32));\n\t*lvb_gen = le32_to_cpu(gen);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/dlm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/dlm.h>\n#include <linux/fs.h>\n\nstatic void control_lvb_read(struct lm_lockstruct *ls, uint32_t *lvb_gen,\n\t\t\t     char *lvb_bits)\n{\n\t__le32 gen;\n\tmemcpy(lvb_bits, ls->ls_control_lvb, GDLM_LVB_SIZE);\n\tmemcpy(&gen, lvb_bits, sizeof(__le32));\n\t*lvb_gen = le32_to_cpu(gen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mounted_lock",
          "args": [
            "sdp",
            "DLM_LOCK_PR",
            "DLM_LKF_CONVERT|DLM_LKF_NOQUEUE"
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "mounted_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lock_dlm.c",
          "lines": "557-562",
          "snippet": "static int mounted_lock(struct gfs2_sbd *sdp, int mode, uint32_t flags)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\treturn sync_lock(sdp, mode, flags, GFS2_MOUNTED_LOCK,\n\t\t\t &ls->ls_mounted_lksb, \"mounted_lock\");\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/dlm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/dlm.h>\n#include <linux/fs.h>\n\nstatic int mounted_lock(struct gfs2_sbd *sdp, int mode, uint32_t flags)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\treturn sync_lock(sdp, mode, flags, GFS2_MOUNTED_LOCK,\n\t\t\t &ls->ls_mounted_lksb, \"mounted_lock\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "msleep_interruptible",
          "args": [
            "500"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&ls->ls_sync_wait"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ls->ls_control_lvb",
            "0",
            "GDLM_LVB_SIZE"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ls->ls_control_lksb",
            "0",
            "sizeof(struct dlm_lksb)"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ls->ls_mounted_lksb",
            "0",
            "sizeof(struct dlm_lksb)"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/dlm.h>\n#include <linux/fs.h>\n\nstatic int control_mount(struct gfs2_sbd *sdp)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tuint32_t start_gen, block_gen, mount_gen, lvb_gen;\n\tint mounted_mode;\n\tint retries = 0;\n\tint error;\n\n\tmemset(&ls->ls_mounted_lksb, 0, sizeof(struct dlm_lksb));\n\tmemset(&ls->ls_control_lksb, 0, sizeof(struct dlm_lksb));\n\tmemset(&ls->ls_control_lvb, 0, GDLM_LVB_SIZE);\n\tls->ls_control_lksb.sb_lvbptr = ls->ls_control_lvb;\n\tinit_completion(&ls->ls_sync_wait);\n\n\tset_bit(DFL_BLOCK_LOCKS, &ls->ls_recover_flags);\n\n\terror = control_lock(sdp, DLM_LOCK_NL, DLM_LKF_VALBLK);\n\tif (error) {\n\t\tfs_err(sdp, \"control_mount control_lock NL error %d\\n\", error);\n\t\treturn error;\n\t}\n\n\terror = mounted_lock(sdp, DLM_LOCK_NL, 0);\n\tif (error) {\n\t\tfs_err(sdp, \"control_mount mounted_lock NL error %d\\n\", error);\n\t\tcontrol_unlock(sdp);\n\t\treturn error;\n\t}\n\tmounted_mode = DLM_LOCK_NL;\n\nrestart:\n\tif (retries++ && signal_pending(current)) {\n\t\terror = -EINTR;\n\t\tgoto fail;\n\t}\n\n\t/*\n\t * We always start with both locks in NL. control_lock is\n\t * demoted to NL below so we don't need to do it here.\n\t */\n\n\tif (mounted_mode != DLM_LOCK_NL) {\n\t\terror = mounted_lock(sdp, DLM_LOCK_NL, DLM_LKF_CONVERT);\n\t\tif (error)\n\t\t\tgoto fail;\n\t\tmounted_mode = DLM_LOCK_NL;\n\t}\n\n\t/*\n\t * Other nodes need to do some work in dlm recovery and gfs2_control\n\t * before the recover_done and control_lock will be ready for us below.\n\t * A delay here is not required but often avoids having to retry.\n\t */\n\n\tmsleep_interruptible(500);\n\n\t/*\n\t * Acquire control_lock in EX and mounted_lock in either EX or PR.\n\t * control_lock lvb keeps track of any pending journal recoveries.\n\t * mounted_lock indicates if any other nodes have the fs mounted.\n\t */\n\n\terror = control_lock(sdp, DLM_LOCK_EX, DLM_LKF_CONVERT|DLM_LKF_NOQUEUE|DLM_LKF_VALBLK);\n\tif (error == -EAGAIN) {\n\t\tgoto restart;\n\t} else if (error) {\n\t\tfs_err(sdp, \"control_mount control_lock EX error %d\\n\", error);\n\t\tgoto fail;\n\t}\n\n\terror = mounted_lock(sdp, DLM_LOCK_EX, DLM_LKF_CONVERT|DLM_LKF_NOQUEUE);\n\tif (!error) {\n\t\tmounted_mode = DLM_LOCK_EX;\n\t\tgoto locks_done;\n\t} else if (error != -EAGAIN) {\n\t\tfs_err(sdp, \"control_mount mounted_lock EX error %d\\n\", error);\n\t\tgoto fail;\n\t}\n\n\terror = mounted_lock(sdp, DLM_LOCK_PR, DLM_LKF_CONVERT|DLM_LKF_NOQUEUE);\n\tif (!error) {\n\t\tmounted_mode = DLM_LOCK_PR;\n\t\tgoto locks_done;\n\t} else {\n\t\t/* not even -EAGAIN should happen here */\n\t\tfs_err(sdp, \"control_mount mounted_lock PR error %d\\n\", error);\n\t\tgoto fail;\n\t}\n\nlocks_done:\n\t/*\n\t * If we got both locks above in EX, then we're the first mounter.\n\t * If not, then we need to wait for the control_lock lvb to be\n\t * updated by other mounted nodes to reflect our mount generation.\n\t *\n\t * In simple first mounter cases, first mounter will see zero lvb_gen,\n\t * but in cases where all existing nodes leave/fail before mounting\n\t * nodes finish control_mount, then all nodes will be mounting and\n\t * lvb_gen will be non-zero.\n\t */\n\n\tcontrol_lvb_read(ls, &lvb_gen, ls->ls_lvb_bits);\n\n\tif (lvb_gen == 0xFFFFFFFF) {\n\t\t/* special value to force mount attempts to fail */\n\t\tfs_err(sdp, \"control_mount control_lock disabled\\n\");\n\t\terror = -EINVAL;\n\t\tgoto fail;\n\t}\n\n\tif (mounted_mode == DLM_LOCK_EX) {\n\t\t/* first mounter, keep both EX while doing first recovery */\n\t\tspin_lock(&ls->ls_recover_spin);\n\t\tclear_bit(DFL_BLOCK_LOCKS, &ls->ls_recover_flags);\n\t\tset_bit(DFL_MOUNT_DONE, &ls->ls_recover_flags);\n\t\tset_bit(DFL_FIRST_MOUNT, &ls->ls_recover_flags);\n\t\tspin_unlock(&ls->ls_recover_spin);\n\t\tfs_info(sdp, \"first mounter control generation %u\\n\", lvb_gen);\n\t\treturn 0;\n\t}\n\n\terror = control_lock(sdp, DLM_LOCK_NL, DLM_LKF_CONVERT);\n\tif (error)\n\t\tgoto fail;\n\n\t/*\n\t * We are not first mounter, now we need to wait for the control_lock\n\t * lvb generation to be >= the generation from our first recover_done\n\t * and all lvb bits to be clear (no pending journal recoveries.)\n\t */\n\n\tif (!all_jid_bits_clear(ls->ls_lvb_bits)) {\n\t\t/* journals need recovery, wait until all are clear */\n\t\tfs_info(sdp, \"control_mount wait for journal recovery\\n\");\n\t\tgoto restart;\n\t}\n\n\tspin_lock(&ls->ls_recover_spin);\n\tblock_gen = ls->ls_recover_block;\n\tstart_gen = ls->ls_recover_start;\n\tmount_gen = ls->ls_recover_mount;\n\n\tif (lvb_gen < mount_gen) {\n\t\t/* wait for mounted nodes to update control_lock lvb to our\n\t\t   generation, which might include new recovery bits set */\n\t\tfs_info(sdp, \"control_mount wait1 block %u start %u mount %u \"\n\t\t\t\"lvb %u flags %lx\\n\", block_gen, start_gen, mount_gen,\n\t\t\tlvb_gen, ls->ls_recover_flags);\n\t\tspin_unlock(&ls->ls_recover_spin);\n\t\tgoto restart;\n\t}\n\n\tif (lvb_gen != start_gen) {\n\t\t/* wait for mounted nodes to update control_lock lvb to the\n\t\t   latest recovery generation */\n\t\tfs_info(sdp, \"control_mount wait2 block %u start %u mount %u \"\n\t\t\t\"lvb %u flags %lx\\n\", block_gen, start_gen, mount_gen,\n\t\t\tlvb_gen, ls->ls_recover_flags);\n\t\tspin_unlock(&ls->ls_recover_spin);\n\t\tgoto restart;\n\t}\n\n\tif (block_gen == start_gen) {\n\t\t/* dlm recovery in progress, wait for it to finish */\n\t\tfs_info(sdp, \"control_mount wait3 block %u start %u mount %u \"\n\t\t\t\"lvb %u flags %lx\\n\", block_gen, start_gen, mount_gen,\n\t\t\tlvb_gen, ls->ls_recover_flags);\n\t\tspin_unlock(&ls->ls_recover_spin);\n\t\tgoto restart;\n\t}\n\n\tclear_bit(DFL_BLOCK_LOCKS, &ls->ls_recover_flags);\n\tset_bit(DFL_MOUNT_DONE, &ls->ls_recover_flags);\n\tmemset(ls->ls_recover_submit, 0, ls->ls_recover_size*sizeof(uint32_t));\n\tmemset(ls->ls_recover_result, 0, ls->ls_recover_size*sizeof(uint32_t));\n\tspin_unlock(&ls->ls_recover_spin);\n\treturn 0;\n\nfail:\n\tmounted_unlock(sdp);\n\tcontrol_unlock(sdp);\n\treturn error;\n}"
  },
  {
    "function_name": "gfs2_control_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lock_dlm.c",
    "lines": "577-753",
    "snippet": "static void gfs2_control_func(struct work_struct *work)\n{\n\tstruct gfs2_sbd *sdp = container_of(work, struct gfs2_sbd, sd_control_work.work);\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tuint32_t block_gen, start_gen, lvb_gen, flags;\n\tint recover_set = 0;\n\tint write_lvb = 0;\n\tint recover_size;\n\tint i, error;\n\n\tspin_lock(&ls->ls_recover_spin);\n\t/*\n\t * No MOUNT_DONE means we're still mounting; control_mount()\n\t * will set this flag, after which this thread will take over\n\t * all further clearing of BLOCK_LOCKS.\n\t *\n\t * FIRST_MOUNT means this node is doing first mounter recovery,\n\t * for which recovery control is handled by\n\t * control_mount()/control_first_done(), not this thread.\n\t */\n\tif (!test_bit(DFL_MOUNT_DONE, &ls->ls_recover_flags) ||\n\t     test_bit(DFL_FIRST_MOUNT, &ls->ls_recover_flags)) {\n\t\tspin_unlock(&ls->ls_recover_spin);\n\t\treturn;\n\t}\n\tblock_gen = ls->ls_recover_block;\n\tstart_gen = ls->ls_recover_start;\n\tspin_unlock(&ls->ls_recover_spin);\n\n\t/*\n\t * Equal block_gen and start_gen implies we are between\n\t * recover_prep and recover_done callbacks, which means\n\t * dlm recovery is in progress and dlm locking is blocked.\n\t * There's no point trying to do any work until recover_done.\n\t */\n\n\tif (block_gen == start_gen)\n\t\treturn;\n\n\t/*\n\t * Propagate recover_submit[] and recover_result[] to lvb:\n\t * dlm_recoverd adds to recover_submit[] jids needing recovery\n\t * gfs2_recover adds to recover_result[] journal recovery results\n\t *\n\t * set lvb bit for jids in recover_submit[] if the lvb has not\n\t * yet been updated for the generation of the failure\n\t *\n\t * clear lvb bit for jids in recover_result[] if the result of\n\t * the journal recovery is SUCCESS\n\t */\n\n\terror = control_lock(sdp, DLM_LOCK_EX, DLM_LKF_CONVERT|DLM_LKF_VALBLK);\n\tif (error) {\n\t\tfs_err(sdp, \"control lock EX error %d\\n\", error);\n\t\treturn;\n\t}\n\n\tcontrol_lvb_read(ls, &lvb_gen, ls->ls_lvb_bits);\n\n\tspin_lock(&ls->ls_recover_spin);\n\tif (block_gen != ls->ls_recover_block ||\n\t    start_gen != ls->ls_recover_start) {\n\t\tfs_info(sdp, \"recover generation %u block1 %u %u\\n\",\n\t\t\tstart_gen, block_gen, ls->ls_recover_block);\n\t\tspin_unlock(&ls->ls_recover_spin);\n\t\tcontrol_lock(sdp, DLM_LOCK_NL, DLM_LKF_CONVERT);\n\t\treturn;\n\t}\n\n\trecover_size = ls->ls_recover_size;\n\n\tif (lvb_gen <= start_gen) {\n\t\t/*\n\t\t * Clear lvb bits for jids we've successfully recovered.\n\t\t * Because all nodes attempt to recover failed journals,\n\t\t * a journal can be recovered multiple times successfully\n\t\t * in succession.  Only the first will really do recovery,\n\t\t * the others find it clean, but still report a successful\n\t\t * recovery.  So, another node may have already recovered\n\t\t * the jid and cleared the lvb bit for it.\n\t\t */\n\t\tfor (i = 0; i < recover_size; i++) {\n\t\t\tif (ls->ls_recover_result[i] != LM_RD_SUCCESS)\n\t\t\t\tcontinue;\n\n\t\t\tls->ls_recover_result[i] = 0;\n\n\t\t\tif (!test_bit_le(i, ls->ls_lvb_bits + JID_BITMAP_OFFSET))\n\t\t\t\tcontinue;\n\n\t\t\t__clear_bit_le(i, ls->ls_lvb_bits + JID_BITMAP_OFFSET);\n\t\t\twrite_lvb = 1;\n\t\t}\n\t}\n\n\tif (lvb_gen == start_gen) {\n\t\t/*\n\t\t * Failed slots before start_gen are already set in lvb.\n\t\t */\n\t\tfor (i = 0; i < recover_size; i++) {\n\t\t\tif (!ls->ls_recover_submit[i])\n\t\t\t\tcontinue;\n\t\t\tif (ls->ls_recover_submit[i] < lvb_gen)\n\t\t\t\tls->ls_recover_submit[i] = 0;\n\t\t}\n\t} else if (lvb_gen < start_gen) {\n\t\t/*\n\t\t * Failed slots before start_gen are not yet set in lvb.\n\t\t */\n\t\tfor (i = 0; i < recover_size; i++) {\n\t\t\tif (!ls->ls_recover_submit[i])\n\t\t\t\tcontinue;\n\t\t\tif (ls->ls_recover_submit[i] < start_gen) {\n\t\t\t\tls->ls_recover_submit[i] = 0;\n\t\t\t\t__set_bit_le(i, ls->ls_lvb_bits + JID_BITMAP_OFFSET);\n\t\t\t}\n\t\t}\n\t\t/* even if there are no bits to set, we need to write the\n\t\t   latest generation to the lvb */\n\t\twrite_lvb = 1;\n\t} else {\n\t\t/*\n\t\t * we should be getting a recover_done() for lvb_gen soon\n\t\t */\n\t}\n\tspin_unlock(&ls->ls_recover_spin);\n\n\tif (write_lvb) {\n\t\tcontrol_lvb_write(ls, start_gen, ls->ls_lvb_bits);\n\t\tflags = DLM_LKF_CONVERT | DLM_LKF_VALBLK;\n\t} else {\n\t\tflags = DLM_LKF_CONVERT;\n\t}\n\n\terror = control_lock(sdp, DLM_LOCK_NL, flags);\n\tif (error) {\n\t\tfs_err(sdp, \"control lock NL error %d\\n\", error);\n\t\treturn;\n\t}\n\n\t/*\n\t * Everyone will see jid bits set in the lvb, run gfs2_recover_set(),\n\t * and clear a jid bit in the lvb if the recovery is a success.\n\t * Eventually all journals will be recovered, all jid bits will\n\t * be cleared in the lvb, and everyone will clear BLOCK_LOCKS.\n\t */\n\n\tfor (i = 0; i < recover_size; i++) {\n\t\tif (test_bit_le(i, ls->ls_lvb_bits + JID_BITMAP_OFFSET)) {\n\t\t\tfs_info(sdp, \"recover generation %u jid %d\\n\",\n\t\t\t\tstart_gen, i);\n\t\t\tgfs2_recover_set(sdp, i);\n\t\t\trecover_set++;\n\t\t}\n\t}\n\tif (recover_set)\n\t\treturn;\n\n\t/*\n\t * No more jid bits set in lvb, all recovery is done, unblock locks\n\t * (unless a new recover_prep callback has occured blocking locks\n\t * again while working above)\n\t */\n\n\tspin_lock(&ls->ls_recover_spin);\n\tif (ls->ls_recover_block == block_gen &&\n\t    ls->ls_recover_start == start_gen) {\n\t\tclear_bit(DFL_BLOCK_LOCKS, &ls->ls_recover_flags);\n\t\tspin_unlock(&ls->ls_recover_spin);\n\t\tfs_info(sdp, \"recover generation %u done\\n\", start_gen);\n\t\tgfs2_glock_thaw(sdp);\n\t} else {\n\t\tfs_info(sdp, \"recover generation %u block2 %u %u\\n\",\n\t\t\tstart_gen, block_gen, ls->ls_recover_block);\n\t\tspin_unlock(&ls->ls_recover_spin);\n\t}\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"sys.h\"",
      "#include \"util.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/dlm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define JID_BITMAP_OFFSET 8 /* 4 byte generation number + 4 byte unused */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ls->ls_recover_spin"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "spin_unlock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "104-107",
          "snippet": "static inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_unlock_bucket(unsigned int hash)\n{\n        hlist_bl_unlock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fs_info",
          "args": [
            "sdp",
            "\"recover generation %u block2 %u %u\\n\"",
            "start_gen",
            "block_gen",
            "ls->ls_recover_block"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/prints.c",
          "lines": "280-288",
          "snippet": "void reiserfs_info(struct super_block *sb, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_NOTICE \"REISERFS (device %s): %s\",\n\t\t       sb->s_id, error_buf);\n\telse\n\t\tprintk(KERN_NOTICE \"REISERFS %s:\", error_buf);\n}",
          "includes": [
            "#include <stdarg.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/string.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdarg.h>\n#include <linux/buffer_head.h>\n#include <linux/string.h>\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic char error_buf[1024];\n\nvoid reiserfs_info(struct super_block *sb, const char *fmt, ...)\n{\n\tdo_reiserfs_warning(fmt);\n\tif (sb)\n\t\tprintk(KERN_NOTICE \"REISERFS (device %s): %s\",\n\t\t       sb->s_id, error_buf);\n\telse\n\t\tprintk(KERN_NOTICE \"REISERFS %s:\", error_buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_thaw",
          "args": [
            "sdp"
          ],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_thaw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1530-1533",
          "snippet": "void gfs2_glock_thaw(struct gfs2_sbd *sdp)\n{\n\tglock_hash_walk(thaw_glock, sdp);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_thaw(struct gfs2_sbd *sdp)\n{\n\tglock_hash_walk(thaw_glock, sdp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "DFL_BLOCK_LOCKS",
            "&ls->ls_recover_flags"
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ls->ls_recover_spin"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "spin_lock_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/quota.c",
          "lines": "99-102",
          "snippet": "static inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"inode.h\"",
            "#include \"trans.h\"",
            "#include \"super.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"log.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"bmap.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/jhash.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/lockref.h>",
            "#include <linux/dqblk_xfs.h>",
            "#include <linux/quota.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/bio.h>",
            "#include <linux/fs.h>",
            "#include <linux/sort.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"inode.h\"\n#include \"trans.h\"\n#include \"super.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"log.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"bmap.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/vmalloc.h>\n#include <linux/jhash.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/list_lru.h>\n#include <linux/lockref.h>\n#include <linux/dqblk_xfs.h>\n#include <linux/quota.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/bio.h>\n#include <linux/fs.h>\n#include <linux/sort.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct hlist_bl_head qd_hash_table[GFS2_QD_HASH_SIZE];\n\nstatic inline void spin_lock_bucket(unsigned int hash)\n{\n        hlist_bl_lock(&qd_hash_table[hash]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_recover_set",
          "args": [
            "sdp",
            "i"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_recover_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/sys.c",
          "lines": "405-427",
          "snippet": "int gfs2_recover_set(struct gfs2_sbd *sdp, unsigned jid)\n{\n\tstruct gfs2_jdesc *jd;\n\tint rv;\n\n\t/* Wait for our primary journal to be initialized */\n\twait_for_completion(&sdp->sd_journal_ready);\n\n\tspin_lock(&sdp->sd_jindex_spin);\n\trv = -EBUSY;\n\tif (sdp->sd_jdesc->jd_jid == jid)\n\t\tgoto out;\n\trv = -ENOENT;\n\tlist_for_each_entry(jd, &sdp->sd_jindex_list, jd_list) {\n\t\tif (jd->jd_jid != jid)\n\t\t\tcontinue;\n\t\trv = gfs2_recover_journal(jd, false);\n\t\tbreak;\n\t}\nout:\n\tspin_unlock(&sdp->sd_jindex_spin);\n\treturn rv;\n}",
          "includes": [
            "#include \"recovery.h\"",
            "#include \"glops.h\"",
            "#include \"util.h\"",
            "#include \"quota.h\"",
            "#include \"glock.h\"",
            "#include \"super.h\"",
            "#include \"sys.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/genhd.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/kobject.h>",
            "#include <linux/module.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recovery.h\"\n#include \"glops.h\"\n#include \"util.h\"\n#include \"quota.h\"\n#include \"glock.h\"\n#include \"super.h\"\n#include \"sys.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/genhd.h>\n#include <linux/gfs2_ondisk.h>\n#include <asm/uaccess.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n\nint gfs2_recover_set(struct gfs2_sbd *sdp, unsigned jid)\n{\n\tstruct gfs2_jdesc *jd;\n\tint rv;\n\n\t/* Wait for our primary journal to be initialized */\n\twait_for_completion(&sdp->sd_journal_ready);\n\n\tspin_lock(&sdp->sd_jindex_spin);\n\trv = -EBUSY;\n\tif (sdp->sd_jdesc->jd_jid == jid)\n\t\tgoto out;\n\trv = -ENOENT;\n\tlist_for_each_entry(jd, &sdp->sd_jindex_list, jd_list) {\n\t\tif (jd->jd_jid != jid)\n\t\t\tcontinue;\n\t\trv = gfs2_recover_journal(jd, false);\n\t\tbreak;\n\t}\nout:\n\tspin_unlock(&sdp->sd_jindex_spin);\n\treturn rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit_le",
          "args": [
            "i",
            "ls->ls_lvb_bits + JID_BITMAP_OFFSET"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs_err",
          "args": [
            "sdp",
            "\"control lock NL error %d\\n\"",
            "error"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_vfs_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_debug.c",
          "lines": "43-56",
          "snippet": "void cifs_vfs_err(const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"CIFS VFS: %pV\", &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"cifsfs.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n\nvoid cifs_vfs_err(const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"CIFS VFS: %pV\", &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "control_lock",
          "args": [
            "sdp",
            "DLM_LOCK_NL",
            "flags"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "control_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lock_dlm.c",
          "lines": "570-575",
          "snippet": "static int control_lock(struct gfs2_sbd *sdp, int mode, uint32_t flags)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\treturn sync_lock(sdp, mode, flags, GFS2_CONTROL_LOCK,\n\t\t\t &ls->ls_control_lksb, \"control_lock\");\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/dlm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/dlm.h>\n#include <linux/fs.h>\n\nstatic int control_lock(struct gfs2_sbd *sdp, int mode, uint32_t flags)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\treturn sync_lock(sdp, mode, flags, GFS2_CONTROL_LOCK,\n\t\t\t &ls->ls_control_lksb, \"control_lock\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "control_lvb_write",
          "args": [
            "ls",
            "start_gen",
            "ls->ls_lvb_bits"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "control_lvb_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lock_dlm.c",
          "lines": "477-484",
          "snippet": "static void control_lvb_write(struct lm_lockstruct *ls, uint32_t lvb_gen,\n\t\t\t      char *lvb_bits)\n{\n\t__le32 gen;\n\tmemcpy(ls->ls_control_lvb, lvb_bits, GDLM_LVB_SIZE);\n\tgen = cpu_to_le32(lvb_gen);\n\tmemcpy(ls->ls_control_lvb, &gen, sizeof(__le32));\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/dlm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/dlm.h>\n#include <linux/fs.h>\n\nstatic void control_lvb_write(struct lm_lockstruct *ls, uint32_t lvb_gen,\n\t\t\t      char *lvb_bits)\n{\n\t__le32 gen;\n\tmemcpy(ls->ls_control_lvb, lvb_bits, GDLM_LVB_SIZE);\n\tgen = cpu_to_le32(lvb_gen);\n\tmemcpy(ls->ls_control_lvb, &gen, sizeof(__le32));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_bit_le",
          "args": [
            "i",
            "ls->ls_lvb_bits + JID_BITMAP_OFFSET"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__clear_bit_le",
          "args": [
            "i",
            "ls->ls_lvb_bits + JID_BITMAP_OFFSET"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit_le",
          "args": [
            "i",
            "ls->ls_lvb_bits + JID_BITMAP_OFFSET"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "control_lvb_read",
          "args": [
            "ls",
            "&lvb_gen",
            "ls->ls_lvb_bits"
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "control_lvb_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lock_dlm.c",
          "lines": "468-475",
          "snippet": "static void control_lvb_read(struct lm_lockstruct *ls, uint32_t *lvb_gen,\n\t\t\t     char *lvb_bits)\n{\n\t__le32 gen;\n\tmemcpy(lvb_bits, ls->ls_control_lvb, GDLM_LVB_SIZE);\n\tmemcpy(&gen, lvb_bits, sizeof(__le32));\n\t*lvb_gen = le32_to_cpu(gen);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/dlm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/dlm.h>\n#include <linux/fs.h>\n\nstatic void control_lvb_read(struct lm_lockstruct *ls, uint32_t *lvb_gen,\n\t\t\t     char *lvb_bits)\n{\n\t__le32 gen;\n\tmemcpy(lvb_bits, ls->ls_control_lvb, GDLM_LVB_SIZE);\n\tmemcpy(&gen, lvb_bits, sizeof(__le32));\n\t*lvb_gen = le32_to_cpu(gen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "DFL_FIRST_MOUNT",
            "&ls->ls_recover_flags"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structgfs2_sbd",
            "sd_control_work.work"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/dlm.h>\n#include <linux/fs.h>\n\n#define JID_BITMAP_OFFSET 8 /* 4 byte generation number + 4 byte unused */\n\nstatic void gfs2_control_func(struct work_struct *work)\n{\n\tstruct gfs2_sbd *sdp = container_of(work, struct gfs2_sbd, sd_control_work.work);\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tuint32_t block_gen, start_gen, lvb_gen, flags;\n\tint recover_set = 0;\n\tint write_lvb = 0;\n\tint recover_size;\n\tint i, error;\n\n\tspin_lock(&ls->ls_recover_spin);\n\t/*\n\t * No MOUNT_DONE means we're still mounting; control_mount()\n\t * will set this flag, after which this thread will take over\n\t * all further clearing of BLOCK_LOCKS.\n\t *\n\t * FIRST_MOUNT means this node is doing first mounter recovery,\n\t * for which recovery control is handled by\n\t * control_mount()/control_first_done(), not this thread.\n\t */\n\tif (!test_bit(DFL_MOUNT_DONE, &ls->ls_recover_flags) ||\n\t     test_bit(DFL_FIRST_MOUNT, &ls->ls_recover_flags)) {\n\t\tspin_unlock(&ls->ls_recover_spin);\n\t\treturn;\n\t}\n\tblock_gen = ls->ls_recover_block;\n\tstart_gen = ls->ls_recover_start;\n\tspin_unlock(&ls->ls_recover_spin);\n\n\t/*\n\t * Equal block_gen and start_gen implies we are between\n\t * recover_prep and recover_done callbacks, which means\n\t * dlm recovery is in progress and dlm locking is blocked.\n\t * There's no point trying to do any work until recover_done.\n\t */\n\n\tif (block_gen == start_gen)\n\t\treturn;\n\n\t/*\n\t * Propagate recover_submit[] and recover_result[] to lvb:\n\t * dlm_recoverd adds to recover_submit[] jids needing recovery\n\t * gfs2_recover adds to recover_result[] journal recovery results\n\t *\n\t * set lvb bit for jids in recover_submit[] if the lvb has not\n\t * yet been updated for the generation of the failure\n\t *\n\t * clear lvb bit for jids in recover_result[] if the result of\n\t * the journal recovery is SUCCESS\n\t */\n\n\terror = control_lock(sdp, DLM_LOCK_EX, DLM_LKF_CONVERT|DLM_LKF_VALBLK);\n\tif (error) {\n\t\tfs_err(sdp, \"control lock EX error %d\\n\", error);\n\t\treturn;\n\t}\n\n\tcontrol_lvb_read(ls, &lvb_gen, ls->ls_lvb_bits);\n\n\tspin_lock(&ls->ls_recover_spin);\n\tif (block_gen != ls->ls_recover_block ||\n\t    start_gen != ls->ls_recover_start) {\n\t\tfs_info(sdp, \"recover generation %u block1 %u %u\\n\",\n\t\t\tstart_gen, block_gen, ls->ls_recover_block);\n\t\tspin_unlock(&ls->ls_recover_spin);\n\t\tcontrol_lock(sdp, DLM_LOCK_NL, DLM_LKF_CONVERT);\n\t\treturn;\n\t}\n\n\trecover_size = ls->ls_recover_size;\n\n\tif (lvb_gen <= start_gen) {\n\t\t/*\n\t\t * Clear lvb bits for jids we've successfully recovered.\n\t\t * Because all nodes attempt to recover failed journals,\n\t\t * a journal can be recovered multiple times successfully\n\t\t * in succession.  Only the first will really do recovery,\n\t\t * the others find it clean, but still report a successful\n\t\t * recovery.  So, another node may have already recovered\n\t\t * the jid and cleared the lvb bit for it.\n\t\t */\n\t\tfor (i = 0; i < recover_size; i++) {\n\t\t\tif (ls->ls_recover_result[i] != LM_RD_SUCCESS)\n\t\t\t\tcontinue;\n\n\t\t\tls->ls_recover_result[i] = 0;\n\n\t\t\tif (!test_bit_le(i, ls->ls_lvb_bits + JID_BITMAP_OFFSET))\n\t\t\t\tcontinue;\n\n\t\t\t__clear_bit_le(i, ls->ls_lvb_bits + JID_BITMAP_OFFSET);\n\t\t\twrite_lvb = 1;\n\t\t}\n\t}\n\n\tif (lvb_gen == start_gen) {\n\t\t/*\n\t\t * Failed slots before start_gen are already set in lvb.\n\t\t */\n\t\tfor (i = 0; i < recover_size; i++) {\n\t\t\tif (!ls->ls_recover_submit[i])\n\t\t\t\tcontinue;\n\t\t\tif (ls->ls_recover_submit[i] < lvb_gen)\n\t\t\t\tls->ls_recover_submit[i] = 0;\n\t\t}\n\t} else if (lvb_gen < start_gen) {\n\t\t/*\n\t\t * Failed slots before start_gen are not yet set in lvb.\n\t\t */\n\t\tfor (i = 0; i < recover_size; i++) {\n\t\t\tif (!ls->ls_recover_submit[i])\n\t\t\t\tcontinue;\n\t\t\tif (ls->ls_recover_submit[i] < start_gen) {\n\t\t\t\tls->ls_recover_submit[i] = 0;\n\t\t\t\t__set_bit_le(i, ls->ls_lvb_bits + JID_BITMAP_OFFSET);\n\t\t\t}\n\t\t}\n\t\t/* even if there are no bits to set, we need to write the\n\t\t   latest generation to the lvb */\n\t\twrite_lvb = 1;\n\t} else {\n\t\t/*\n\t\t * we should be getting a recover_done() for lvb_gen soon\n\t\t */\n\t}\n\tspin_unlock(&ls->ls_recover_spin);\n\n\tif (write_lvb) {\n\t\tcontrol_lvb_write(ls, start_gen, ls->ls_lvb_bits);\n\t\tflags = DLM_LKF_CONVERT | DLM_LKF_VALBLK;\n\t} else {\n\t\tflags = DLM_LKF_CONVERT;\n\t}\n\n\terror = control_lock(sdp, DLM_LOCK_NL, flags);\n\tif (error) {\n\t\tfs_err(sdp, \"control lock NL error %d\\n\", error);\n\t\treturn;\n\t}\n\n\t/*\n\t * Everyone will see jid bits set in the lvb, run gfs2_recover_set(),\n\t * and clear a jid bit in the lvb if the recovery is a success.\n\t * Eventually all journals will be recovered, all jid bits will\n\t * be cleared in the lvb, and everyone will clear BLOCK_LOCKS.\n\t */\n\n\tfor (i = 0; i < recover_size; i++) {\n\t\tif (test_bit_le(i, ls->ls_lvb_bits + JID_BITMAP_OFFSET)) {\n\t\t\tfs_info(sdp, \"recover generation %u jid %d\\n\",\n\t\t\t\tstart_gen, i);\n\t\t\tgfs2_recover_set(sdp, i);\n\t\t\trecover_set++;\n\t\t}\n\t}\n\tif (recover_set)\n\t\treturn;\n\n\t/*\n\t * No more jid bits set in lvb, all recovery is done, unblock locks\n\t * (unless a new recover_prep callback has occured blocking locks\n\t * again while working above)\n\t */\n\n\tspin_lock(&ls->ls_recover_spin);\n\tif (ls->ls_recover_block == block_gen &&\n\t    ls->ls_recover_start == start_gen) {\n\t\tclear_bit(DFL_BLOCK_LOCKS, &ls->ls_recover_flags);\n\t\tspin_unlock(&ls->ls_recover_spin);\n\t\tfs_info(sdp, \"recover generation %u done\\n\", start_gen);\n\t\tgfs2_glock_thaw(sdp);\n\t} else {\n\t\tfs_info(sdp, \"recover generation %u block2 %u %u\\n\",\n\t\t\tstart_gen, block_gen, ls->ls_recover_block);\n\t\tspin_unlock(&ls->ls_recover_spin);\n\t}\n}"
  },
  {
    "function_name": "control_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lock_dlm.c",
    "lines": "570-575",
    "snippet": "static int control_lock(struct gfs2_sbd *sdp, int mode, uint32_t flags)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\treturn sync_lock(sdp, mode, flags, GFS2_CONTROL_LOCK,\n\t\t\t &ls->ls_control_lksb, \"control_lock\");\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"sys.h\"",
      "#include \"util.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/dlm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sync_lock",
          "args": [
            "sdp",
            "mode",
            "flags",
            "GFS2_CONTROL_LOCK",
            "&ls->ls_control_lksb",
            "\"control_lock\""
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "sync_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lock_dlm.c",
          "lines": "520-549",
          "snippet": "static int sync_lock(struct gfs2_sbd *sdp, int mode, uint32_t flags,\n\t\t     unsigned int num, struct dlm_lksb *lksb, char *name)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tchar strname[GDLM_STRNAME_BYTES];\n\tint error, status;\n\n\tmemset(strname, 0, GDLM_STRNAME_BYTES);\n\tsnprintf(strname, GDLM_STRNAME_BYTES, \"%8x%16x\", LM_TYPE_NONDISK, num);\n\n\terror = dlm_lock(ls->ls_dlm, mode, lksb, flags,\n\t\t\t strname, GDLM_STRNAME_BYTES - 1,\n\t\t\t 0, sync_wait_cb, ls, NULL);\n\tif (error) {\n\t\tfs_err(sdp, \"%s lkid %x flags %x mode %d error %d\\n\",\n\t\t       name, lksb->sb_lkid, flags, mode, error);\n\t\treturn error;\n\t}\n\n\twait_for_completion(&ls->ls_sync_wait);\n\n\tstatus = lksb->sb_status;\n\n\tif (status && status != -EAGAIN) {\n\t\tfs_err(sdp, \"%s lkid %x flags %x mode %d status %d\\n\",\n\t\t       name, lksb->sb_lkid, flags, mode, status);\n\t}\n\n\treturn status;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/dlm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/dlm.h>\n#include <linux/fs.h>\n\nstatic int sync_lock(struct gfs2_sbd *sdp, int mode, uint32_t flags,\n\t\t     unsigned int num, struct dlm_lksb *lksb, char *name)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tchar strname[GDLM_STRNAME_BYTES];\n\tint error, status;\n\n\tmemset(strname, 0, GDLM_STRNAME_BYTES);\n\tsnprintf(strname, GDLM_STRNAME_BYTES, \"%8x%16x\", LM_TYPE_NONDISK, num);\n\n\terror = dlm_lock(ls->ls_dlm, mode, lksb, flags,\n\t\t\t strname, GDLM_STRNAME_BYTES - 1,\n\t\t\t 0, sync_wait_cb, ls, NULL);\n\tif (error) {\n\t\tfs_err(sdp, \"%s lkid %x flags %x mode %d error %d\\n\",\n\t\t       name, lksb->sb_lkid, flags, mode, error);\n\t\treturn error;\n\t}\n\n\twait_for_completion(&ls->ls_sync_wait);\n\n\tstatus = lksb->sb_status;\n\n\tif (status && status != -EAGAIN) {\n\t\tfs_err(sdp, \"%s lkid %x flags %x mode %d status %d\\n\",\n\t\t       name, lksb->sb_lkid, flags, mode, status);\n\t}\n\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/dlm.h>\n#include <linux/fs.h>\n\nstatic int control_lock(struct gfs2_sbd *sdp, int mode, uint32_t flags)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\treturn sync_lock(sdp, mode, flags, GFS2_CONTROL_LOCK,\n\t\t\t &ls->ls_control_lksb, \"control_lock\");\n}"
  },
  {
    "function_name": "control_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lock_dlm.c",
    "lines": "564-568",
    "snippet": "static int control_unlock(struct gfs2_sbd *sdp)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\treturn sync_unlock(sdp, &ls->ls_control_lksb, \"control_lock\");\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"sys.h\"",
      "#include \"util.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/dlm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sync_unlock",
          "args": [
            "sdp",
            "&ls->ls_control_lksb",
            "\"control_lock\""
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "sync_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lock_dlm.c",
          "lines": "498-518",
          "snippet": "static int sync_unlock(struct gfs2_sbd *sdp, struct dlm_lksb *lksb, char *name)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tint error;\n\n\terror = dlm_unlock(ls->ls_dlm, lksb->sb_lkid, 0, lksb, ls);\n\tif (error) {\n\t\tfs_err(sdp, \"%s lkid %x error %d\\n\",\n\t\t       name, lksb->sb_lkid, error);\n\t\treturn error;\n\t}\n\n\twait_for_completion(&ls->ls_sync_wait);\n\n\tif (lksb->sb_status != -DLM_EUNLOCK) {\n\t\tfs_err(sdp, \"%s lkid %x status %d\\n\",\n\t\t       name, lksb->sb_lkid, lksb->sb_status);\n\t\treturn -1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/dlm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/dlm.h>\n#include <linux/fs.h>\n\nstatic int sync_unlock(struct gfs2_sbd *sdp, struct dlm_lksb *lksb, char *name)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tint error;\n\n\terror = dlm_unlock(ls->ls_dlm, lksb->sb_lkid, 0, lksb, ls);\n\tif (error) {\n\t\tfs_err(sdp, \"%s lkid %x error %d\\n\",\n\t\t       name, lksb->sb_lkid, error);\n\t\treturn error;\n\t}\n\n\twait_for_completion(&ls->ls_sync_wait);\n\n\tif (lksb->sb_status != -DLM_EUNLOCK) {\n\t\tfs_err(sdp, \"%s lkid %x status %d\\n\",\n\t\t       name, lksb->sb_lkid, lksb->sb_status);\n\t\treturn -1;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/dlm.h>\n#include <linux/fs.h>\n\nstatic int control_unlock(struct gfs2_sbd *sdp)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\treturn sync_unlock(sdp, &ls->ls_control_lksb, \"control_lock\");\n}"
  },
  {
    "function_name": "mounted_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lock_dlm.c",
    "lines": "557-562",
    "snippet": "static int mounted_lock(struct gfs2_sbd *sdp, int mode, uint32_t flags)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\treturn sync_lock(sdp, mode, flags, GFS2_MOUNTED_LOCK,\n\t\t\t &ls->ls_mounted_lksb, \"mounted_lock\");\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"sys.h\"",
      "#include \"util.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/dlm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sync_lock",
          "args": [
            "sdp",
            "mode",
            "flags",
            "GFS2_MOUNTED_LOCK",
            "&ls->ls_mounted_lksb",
            "\"mounted_lock\""
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "sync_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lock_dlm.c",
          "lines": "520-549",
          "snippet": "static int sync_lock(struct gfs2_sbd *sdp, int mode, uint32_t flags,\n\t\t     unsigned int num, struct dlm_lksb *lksb, char *name)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tchar strname[GDLM_STRNAME_BYTES];\n\tint error, status;\n\n\tmemset(strname, 0, GDLM_STRNAME_BYTES);\n\tsnprintf(strname, GDLM_STRNAME_BYTES, \"%8x%16x\", LM_TYPE_NONDISK, num);\n\n\terror = dlm_lock(ls->ls_dlm, mode, lksb, flags,\n\t\t\t strname, GDLM_STRNAME_BYTES - 1,\n\t\t\t 0, sync_wait_cb, ls, NULL);\n\tif (error) {\n\t\tfs_err(sdp, \"%s lkid %x flags %x mode %d error %d\\n\",\n\t\t       name, lksb->sb_lkid, flags, mode, error);\n\t\treturn error;\n\t}\n\n\twait_for_completion(&ls->ls_sync_wait);\n\n\tstatus = lksb->sb_status;\n\n\tif (status && status != -EAGAIN) {\n\t\tfs_err(sdp, \"%s lkid %x flags %x mode %d status %d\\n\",\n\t\t       name, lksb->sb_lkid, flags, mode, status);\n\t}\n\n\treturn status;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/dlm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/dlm.h>\n#include <linux/fs.h>\n\nstatic int sync_lock(struct gfs2_sbd *sdp, int mode, uint32_t flags,\n\t\t     unsigned int num, struct dlm_lksb *lksb, char *name)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tchar strname[GDLM_STRNAME_BYTES];\n\tint error, status;\n\n\tmemset(strname, 0, GDLM_STRNAME_BYTES);\n\tsnprintf(strname, GDLM_STRNAME_BYTES, \"%8x%16x\", LM_TYPE_NONDISK, num);\n\n\terror = dlm_lock(ls->ls_dlm, mode, lksb, flags,\n\t\t\t strname, GDLM_STRNAME_BYTES - 1,\n\t\t\t 0, sync_wait_cb, ls, NULL);\n\tif (error) {\n\t\tfs_err(sdp, \"%s lkid %x flags %x mode %d error %d\\n\",\n\t\t       name, lksb->sb_lkid, flags, mode, error);\n\t\treturn error;\n\t}\n\n\twait_for_completion(&ls->ls_sync_wait);\n\n\tstatus = lksb->sb_status;\n\n\tif (status && status != -EAGAIN) {\n\t\tfs_err(sdp, \"%s lkid %x flags %x mode %d status %d\\n\",\n\t\t       name, lksb->sb_lkid, flags, mode, status);\n\t}\n\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/dlm.h>\n#include <linux/fs.h>\n\nstatic int mounted_lock(struct gfs2_sbd *sdp, int mode, uint32_t flags)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\treturn sync_lock(sdp, mode, flags, GFS2_MOUNTED_LOCK,\n\t\t\t &ls->ls_mounted_lksb, \"mounted_lock\");\n}"
  },
  {
    "function_name": "mounted_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lock_dlm.c",
    "lines": "551-555",
    "snippet": "static int mounted_unlock(struct gfs2_sbd *sdp)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\treturn sync_unlock(sdp, &ls->ls_mounted_lksb, \"mounted_lock\");\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"sys.h\"",
      "#include \"util.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/dlm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sync_unlock",
          "args": [
            "sdp",
            "&ls->ls_mounted_lksb",
            "\"mounted_lock\""
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "sync_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lock_dlm.c",
          "lines": "498-518",
          "snippet": "static int sync_unlock(struct gfs2_sbd *sdp, struct dlm_lksb *lksb, char *name)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tint error;\n\n\terror = dlm_unlock(ls->ls_dlm, lksb->sb_lkid, 0, lksb, ls);\n\tif (error) {\n\t\tfs_err(sdp, \"%s lkid %x error %d\\n\",\n\t\t       name, lksb->sb_lkid, error);\n\t\treturn error;\n\t}\n\n\twait_for_completion(&ls->ls_sync_wait);\n\n\tif (lksb->sb_status != -DLM_EUNLOCK) {\n\t\tfs_err(sdp, \"%s lkid %x status %d\\n\",\n\t\t       name, lksb->sb_lkid, lksb->sb_status);\n\t\treturn -1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/dlm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/dlm.h>\n#include <linux/fs.h>\n\nstatic int sync_unlock(struct gfs2_sbd *sdp, struct dlm_lksb *lksb, char *name)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tint error;\n\n\terror = dlm_unlock(ls->ls_dlm, lksb->sb_lkid, 0, lksb, ls);\n\tif (error) {\n\t\tfs_err(sdp, \"%s lkid %x error %d\\n\",\n\t\t       name, lksb->sb_lkid, error);\n\t\treturn error;\n\t}\n\n\twait_for_completion(&ls->ls_sync_wait);\n\n\tif (lksb->sb_status != -DLM_EUNLOCK) {\n\t\tfs_err(sdp, \"%s lkid %x status %d\\n\",\n\t\t       name, lksb->sb_lkid, lksb->sb_status);\n\t\treturn -1;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/dlm.h>\n#include <linux/fs.h>\n\nstatic int mounted_unlock(struct gfs2_sbd *sdp)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\treturn sync_unlock(sdp, &ls->ls_mounted_lksb, \"mounted_lock\");\n}"
  },
  {
    "function_name": "sync_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lock_dlm.c",
    "lines": "520-549",
    "snippet": "static int sync_lock(struct gfs2_sbd *sdp, int mode, uint32_t flags,\n\t\t     unsigned int num, struct dlm_lksb *lksb, char *name)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tchar strname[GDLM_STRNAME_BYTES];\n\tint error, status;\n\n\tmemset(strname, 0, GDLM_STRNAME_BYTES);\n\tsnprintf(strname, GDLM_STRNAME_BYTES, \"%8x%16x\", LM_TYPE_NONDISK, num);\n\n\terror = dlm_lock(ls->ls_dlm, mode, lksb, flags,\n\t\t\t strname, GDLM_STRNAME_BYTES - 1,\n\t\t\t 0, sync_wait_cb, ls, NULL);\n\tif (error) {\n\t\tfs_err(sdp, \"%s lkid %x flags %x mode %d error %d\\n\",\n\t\t       name, lksb->sb_lkid, flags, mode, error);\n\t\treturn error;\n\t}\n\n\twait_for_completion(&ls->ls_sync_wait);\n\n\tstatus = lksb->sb_status;\n\n\tif (status && status != -EAGAIN) {\n\t\tfs_err(sdp, \"%s lkid %x flags %x mode %d status %d\\n\",\n\t\t       name, lksb->sb_lkid, flags, mode, status);\n\t}\n\n\treturn status;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"sys.h\"",
      "#include \"util.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/dlm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs_err",
          "args": [
            "sdp",
            "\"%s lkid %x flags %x mode %d status %d\\n\"",
            "name",
            "lksb->sb_lkid",
            "flags",
            "mode",
            "status"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_vfs_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_debug.c",
          "lines": "43-56",
          "snippet": "void cifs_vfs_err(const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"CIFS VFS: %pV\", &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"cifsfs.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n\nvoid cifs_vfs_err(const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"CIFS VFS: %pV\", &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&ls->ls_sync_wait"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_wait_for_completion_rpc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4proc.c",
          "lines": "1116-1122",
          "snippet": "static int nfs4_wait_for_completion_rpc_task(struct rpc_task *task)\n{\n\tint ret;\n\n\tret = rpc_wait_for_completion_task(task);\n\treturn ret;\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4session.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"callback.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/xattr.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"fscache.h\"\n#include \"nfs4session.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"callback.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/xattr.h>\n#include <linux/nfs_idmap.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n\nstatic int nfs4_wait_for_completion_rpc_task(struct rpc_task *task)\n{\n\tint ret;\n\n\tret = rpc_wait_for_completion_task(task);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_lock",
          "args": [
            "ls->ls_dlm",
            "mode",
            "lksb",
            "flags",
            "strname",
            "GDLM_STRNAME_BYTES - 1",
            "0",
            "sync_wait_cb",
            "ls",
            "NULL"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3409-3460",
          "snippet": "int dlm_lock(dlm_lockspace_t *lockspace,\n\t     int mode,\n\t     struct dlm_lksb *lksb,\n\t     uint32_t flags,\n\t     void *name,\n\t     unsigned int namelen,\n\t     uint32_t parent_lkid,\n\t     void (*ast) (void *astarg),\n\t     void *astarg,\n\t     void (*bast) (void *astarg, int mode))\n{\n\tstruct dlm_ls *ls;\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_args args;\n\tint error, convert = flags & DLM_LKF_CONVERT;\n\n\tls = dlm_find_lockspace_local(lockspace);\n\tif (!ls)\n\t\treturn -EINVAL;\n\n\tdlm_lock_recovery(ls);\n\n\tif (convert)\n\t\terror = find_lkb(ls, lksb->sb_lkid, &lkb);\n\telse\n\t\terror = create_lkb(ls, &lkb);\n\n\tif (error)\n\t\tgoto out;\n\n\terror = set_lock_args(mode, lksb, flags, namelen, 0, ast,\n\t\t\t      astarg, bast, &args);\n\tif (error)\n\t\tgoto out_put;\n\n\tif (convert)\n\t\terror = convert_lock(ls, lkb, &args);\n\telse\n\t\terror = request_lock(ls, lkb, name, namelen, &args);\n\n\tif (error == -EINPROGRESS)\n\t\terror = 0;\n out_put:\n\tif (convert || error)\n\t\t__put_lkb(ls, lkb);\n\tif (error == -EAGAIN || error == -EDEADLK)\n\t\terror = 0;\n out:\n\tdlm_unlock_recovery(ls);\n\tdlm_put_lockspace(ls);\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nint dlm_lock(dlm_lockspace_t *lockspace,\n\t     int mode,\n\t     struct dlm_lksb *lksb,\n\t     uint32_t flags,\n\t     void *name,\n\t     unsigned int namelen,\n\t     uint32_t parent_lkid,\n\t     void (*ast) (void *astarg),\n\t     void *astarg,\n\t     void (*bast) (void *astarg, int mode))\n{\n\tstruct dlm_ls *ls;\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_args args;\n\tint error, convert = flags & DLM_LKF_CONVERT;\n\n\tls = dlm_find_lockspace_local(lockspace);\n\tif (!ls)\n\t\treturn -EINVAL;\n\n\tdlm_lock_recovery(ls);\n\n\tif (convert)\n\t\terror = find_lkb(ls, lksb->sb_lkid, &lkb);\n\telse\n\t\terror = create_lkb(ls, &lkb);\n\n\tif (error)\n\t\tgoto out;\n\n\terror = set_lock_args(mode, lksb, flags, namelen, 0, ast,\n\t\t\t      astarg, bast, &args);\n\tif (error)\n\t\tgoto out_put;\n\n\tif (convert)\n\t\terror = convert_lock(ls, lkb, &args);\n\telse\n\t\terror = request_lock(ls, lkb, name, namelen, &args);\n\n\tif (error == -EINPROGRESS)\n\t\terror = 0;\n out_put:\n\tif (convert || error)\n\t\t__put_lkb(ls, lkb);\n\tif (error == -EAGAIN || error == -EDEADLK)\n\t\terror = 0;\n out:\n\tdlm_unlock_recovery(ls);\n\tdlm_put_lockspace(ls);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "strname",
            "GDLM_STRNAME_BYTES",
            "\"%8x%16x\"",
            "LM_TYPE_NONDISK",
            "num"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "strname",
            "0",
            "GDLM_STRNAME_BYTES"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/dlm.h>\n#include <linux/fs.h>\n\nstatic int sync_lock(struct gfs2_sbd *sdp, int mode, uint32_t flags,\n\t\t     unsigned int num, struct dlm_lksb *lksb, char *name)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tchar strname[GDLM_STRNAME_BYTES];\n\tint error, status;\n\n\tmemset(strname, 0, GDLM_STRNAME_BYTES);\n\tsnprintf(strname, GDLM_STRNAME_BYTES, \"%8x%16x\", LM_TYPE_NONDISK, num);\n\n\terror = dlm_lock(ls->ls_dlm, mode, lksb, flags,\n\t\t\t strname, GDLM_STRNAME_BYTES - 1,\n\t\t\t 0, sync_wait_cb, ls, NULL);\n\tif (error) {\n\t\tfs_err(sdp, \"%s lkid %x flags %x mode %d error %d\\n\",\n\t\t       name, lksb->sb_lkid, flags, mode, error);\n\t\treturn error;\n\t}\n\n\twait_for_completion(&ls->ls_sync_wait);\n\n\tstatus = lksb->sb_status;\n\n\tif (status && status != -EAGAIN) {\n\t\tfs_err(sdp, \"%s lkid %x flags %x mode %d status %d\\n\",\n\t\t       name, lksb->sb_lkid, flags, mode, status);\n\t}\n\n\treturn status;\n}"
  },
  {
    "function_name": "sync_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lock_dlm.c",
    "lines": "498-518",
    "snippet": "static int sync_unlock(struct gfs2_sbd *sdp, struct dlm_lksb *lksb, char *name)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tint error;\n\n\terror = dlm_unlock(ls->ls_dlm, lksb->sb_lkid, 0, lksb, ls);\n\tif (error) {\n\t\tfs_err(sdp, \"%s lkid %x error %d\\n\",\n\t\t       name, lksb->sb_lkid, error);\n\t\treturn error;\n\t}\n\n\twait_for_completion(&ls->ls_sync_wait);\n\n\tif (lksb->sb_status != -DLM_EUNLOCK) {\n\t\tfs_err(sdp, \"%s lkid %x status %d\\n\",\n\t\t       name, lksb->sb_lkid, lksb->sb_status);\n\t\treturn -1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"sys.h\"",
      "#include \"util.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/dlm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fs_err",
          "args": [
            "sdp",
            "\"%s lkid %x status %d\\n\"",
            "name",
            "lksb->sb_lkid",
            "lksb->sb_status"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "cifs_vfs_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/cifs/cifs_debug.c",
          "lines": "43-56",
          "snippet": "void cifs_vfs_err(const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"CIFS VFS: %pV\", &vaf);\n\n\tva_end(args);\n}",
          "includes": [
            "#include \"cifsfs.h\"",
            "#include \"cifs_debug.h\"",
            "#include \"cifsproto.h\"",
            "#include \"cifsglob.h\"",
            "#include \"cifspdu.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cifsfs.h\"\n#include \"cifs_debug.h\"\n#include \"cifsproto.h\"\n#include \"cifsglob.h\"\n#include \"cifspdu.h\"\n#include <asm/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n\nvoid cifs_vfs_err(const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tpr_err(\"CIFS VFS: %pV\", &vaf);\n\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&ls->ls_sync_wait"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "nfs4_wait_for_completion_rpc_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/nfs4proc.c",
          "lines": "1116-1122",
          "snippet": "static int nfs4_wait_for_completion_rpc_task(struct rpc_task *task)\n{\n\tint ret;\n\n\tret = rpc_wait_for_completion_task(task);\n\treturn ret;\n}",
          "includes": [
            "#include \"nfs4trace.h\"",
            "#include \"fscache.h\"",
            "#include \"nfs4session.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include \"callback.h\"",
            "#include \"iostat.h\"",
            "#include \"internal.h\"",
            "#include \"delegation.h\"",
            "#include \"nfs4_fs.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/xattr.h>",
            "#include <linux/nfs_idmap.h>",
            "#include <linux/module.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/nfs_mount.h>",
            "#include <linux/nfs_page.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/nfs4.h>",
            "#include <linux/nfs.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/slab.h>",
            "#include <linux/printk.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"nfs4trace.h\"\n#include \"fscache.h\"\n#include \"nfs4session.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include \"callback.h\"\n#include \"iostat.h\"\n#include \"internal.h\"\n#include \"delegation.h\"\n#include \"nfs4_fs.h\"\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/xattr.h>\n#include <linux/nfs_idmap.h>\n#include <linux/module.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/nfs_mount.h>\n#include <linux/nfs_page.h>\n#include <linux/nfs_fs.h>\n#include <linux/nfs4.h>\n#include <linux/nfs.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/slab.h>\n#include <linux/printk.h>\n#include <linux/ratelimit.h>\n#include <linux/string.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n\nstatic int nfs4_wait_for_completion_rpc_task(struct rpc_task *task)\n{\n\tint ret;\n\n\tret = rpc_wait_for_completion_task(task);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dlm_unlock",
          "args": [
            "ls->ls_dlm",
            "lksb->sb_lkid",
            "0",
            "lksb",
            "ls"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3462-3502",
          "snippet": "int dlm_unlock(dlm_lockspace_t *lockspace,\n\t       uint32_t lkid,\n\t       uint32_t flags,\n\t       struct dlm_lksb *lksb,\n\t       void *astarg)\n{\n\tstruct dlm_ls *ls;\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_args args;\n\tint error;\n\n\tls = dlm_find_lockspace_local(lockspace);\n\tif (!ls)\n\t\treturn -EINVAL;\n\n\tdlm_lock_recovery(ls);\n\n\terror = find_lkb(ls, lkid, &lkb);\n\tif (error)\n\t\tgoto out;\n\n\terror = set_unlock_args(flags, astarg, &args);\n\tif (error)\n\t\tgoto out_put;\n\n\tif (flags & DLM_LKF_CANCEL)\n\t\terror = cancel_lock(ls, lkb, &args);\n\telse\n\t\terror = unlock_lock(ls, lkb, &args);\n\n\tif (error == -DLM_EUNLOCK || error == -DLM_ECANCEL)\n\t\terror = 0;\n\tif (error == -EBUSY && (flags & (DLM_LKF_CANCEL | DLM_LKF_FORCEUNLOCK)))\n\t\terror = 0;\n out_put:\n\tdlm_put_lkb(lkb);\n out:\n\tdlm_unlock_recovery(ls);\n\tdlm_put_lockspace(ls);\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nint dlm_unlock(dlm_lockspace_t *lockspace,\n\t       uint32_t lkid,\n\t       uint32_t flags,\n\t       struct dlm_lksb *lksb,\n\t       void *astarg)\n{\n\tstruct dlm_ls *ls;\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_args args;\n\tint error;\n\n\tls = dlm_find_lockspace_local(lockspace);\n\tif (!ls)\n\t\treturn -EINVAL;\n\n\tdlm_lock_recovery(ls);\n\n\terror = find_lkb(ls, lkid, &lkb);\n\tif (error)\n\t\tgoto out;\n\n\terror = set_unlock_args(flags, astarg, &args);\n\tif (error)\n\t\tgoto out_put;\n\n\tif (flags & DLM_LKF_CANCEL)\n\t\terror = cancel_lock(ls, lkb, &args);\n\telse\n\t\terror = unlock_lock(ls, lkb, &args);\n\n\tif (error == -DLM_EUNLOCK || error == -DLM_ECANCEL)\n\t\terror = 0;\n\tif (error == -EBUSY && (flags & (DLM_LKF_CANCEL | DLM_LKF_FORCEUNLOCK)))\n\t\terror = 0;\n out_put:\n\tdlm_put_lkb(lkb);\n out:\n\tdlm_unlock_recovery(ls);\n\tdlm_put_lockspace(ls);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/dlm.h>\n#include <linux/fs.h>\n\nstatic int sync_unlock(struct gfs2_sbd *sdp, struct dlm_lksb *lksb, char *name)\n{\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tint error;\n\n\terror = dlm_unlock(ls->ls_dlm, lksb->sb_lkid, 0, lksb, ls);\n\tif (error) {\n\t\tfs_err(sdp, \"%s lkid %x error %d\\n\",\n\t\t       name, lksb->sb_lkid, error);\n\t\treturn error;\n\t}\n\n\twait_for_completion(&ls->ls_sync_wait);\n\n\tif (lksb->sb_status != -DLM_EUNLOCK) {\n\t\tfs_err(sdp, \"%s lkid %x status %d\\n\",\n\t\t       name, lksb->sb_lkid, lksb->sb_status);\n\t\treturn -1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "sync_wait_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lock_dlm.c",
    "lines": "492-496",
    "snippet": "static void sync_wait_cb(void *arg)\n{\n\tstruct lm_lockstruct *ls = arg;\n\tcomplete(&ls->ls_sync_wait);\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"sys.h\"",
      "#include \"util.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/dlm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "&ls->ls_sync_wait"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "dio_aio_complete_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/direct-io.c",
          "lines": "275-280",
          "snippet": "static void dio_aio_complete_work(struct work_struct *work)\n{\n\tstruct dio *dio = container_of(work, struct dio, complete_work);\n\n\tdio_complete(dio, dio->iocb->ki_pos, 0, true);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/atomic.h>",
            "#include <linux/uio.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/err.h>",
            "#include <linux/wait.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/prefetch.h>\n#include <linux/atomic.h>\n#include <linux/uio.h>\n#include <linux/rwsem.h>\n#include <linux/buffer_head.h>\n#include <linux/blkdev.h>\n#include <linux/err.h>\n#include <linux/wait.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic void dio_aio_complete_work(struct work_struct *work)\n{\n\tstruct dio *dio = container_of(work, struct dio, complete_work);\n\n\tdio_complete(dio, dio->iocb->ki_pos, 0, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/dlm.h>\n#include <linux/fs.h>\n\nstatic void sync_wait_cb(void *arg)\n{\n\tstruct lm_lockstruct *ls = arg;\n\tcomplete(&ls->ls_sync_wait);\n}"
  },
  {
    "function_name": "all_jid_bits_clear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lock_dlm.c",
    "lines": "486-490",
    "snippet": "static int all_jid_bits_clear(char *lvb)\n{\n\treturn !memchr_inv(lvb + JID_BITMAP_OFFSET, 0,\n\t\t\tGDLM_LVB_SIZE - JID_BITMAP_OFFSET);\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"sys.h\"",
      "#include \"util.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/dlm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [
      "#define JID_BITMAP_OFFSET 8 /* 4 byte generation number + 4 byte unused */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memchr_inv",
          "args": [
            "lvb + JID_BITMAP_OFFSET",
            "0",
            "GDLM_LVB_SIZE - JID_BITMAP_OFFSET"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/dlm.h>\n#include <linux/fs.h>\n\n#define JID_BITMAP_OFFSET 8 /* 4 byte generation number + 4 byte unused */\n\nstatic int all_jid_bits_clear(char *lvb)\n{\n\treturn !memchr_inv(lvb + JID_BITMAP_OFFSET, 0,\n\t\t\tGDLM_LVB_SIZE - JID_BITMAP_OFFSET);\n}"
  },
  {
    "function_name": "control_lvb_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lock_dlm.c",
    "lines": "477-484",
    "snippet": "static void control_lvb_write(struct lm_lockstruct *ls, uint32_t lvb_gen,\n\t\t\t      char *lvb_bits)\n{\n\t__le32 gen;\n\tmemcpy(ls->ls_control_lvb, lvb_bits, GDLM_LVB_SIZE);\n\tgen = cpu_to_le32(lvb_gen);\n\tmemcpy(ls->ls_control_lvb, &gen, sizeof(__le32));\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"sys.h\"",
      "#include \"util.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/dlm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ls->ls_control_lvb",
            "&gen",
            "sizeof(__le32)"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "lvb_gen"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ls->ls_control_lvb",
            "lvb_bits",
            "GDLM_LVB_SIZE"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/dlm.h>\n#include <linux/fs.h>\n\nstatic void control_lvb_write(struct lm_lockstruct *ls, uint32_t lvb_gen,\n\t\t\t      char *lvb_bits)\n{\n\t__le32 gen;\n\tmemcpy(ls->ls_control_lvb, lvb_bits, GDLM_LVB_SIZE);\n\tgen = cpu_to_le32(lvb_gen);\n\tmemcpy(ls->ls_control_lvb, &gen, sizeof(__le32));\n}"
  },
  {
    "function_name": "control_lvb_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lock_dlm.c",
    "lines": "468-475",
    "snippet": "static void control_lvb_read(struct lm_lockstruct *ls, uint32_t *lvb_gen,\n\t\t\t     char *lvb_bits)\n{\n\t__le32 gen;\n\tmemcpy(lvb_bits, ls->ls_control_lvb, GDLM_LVB_SIZE);\n\tmemcpy(&gen, lvb_bits, sizeof(__le32));\n\t*lvb_gen = le32_to_cpu(gen);\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"sys.h\"",
      "#include \"util.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/dlm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "gen"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&gen",
            "lvb_bits",
            "sizeof(__le32)"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "lvb_bits",
            "ls->ls_control_lvb",
            "GDLM_LVB_SIZE"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/dlm.h>\n#include <linux/fs.h>\n\nstatic void control_lvb_read(struct lm_lockstruct *ls, uint32_t *lvb_gen,\n\t\t\t     char *lvb_bits)\n{\n\t__le32 gen;\n\tmemcpy(lvb_bits, ls->ls_control_lvb, GDLM_LVB_SIZE);\n\tmemcpy(&gen, lvb_bits, sizeof(__le32));\n\t*lvb_gen = le32_to_cpu(gen);\n}"
  },
  {
    "function_name": "gdlm_cancel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lock_dlm.c",
    "lines": "320-324",
    "snippet": "static void gdlm_cancel(struct gfs2_glock *gl)\n{\n\tstruct lm_lockstruct *ls = &gl->gl_sbd->sd_lockstruct;\n\tdlm_unlock(ls->ls_dlm, gl->gl_lksb.sb_lkid, DLM_LKF_CANCEL, NULL, gl);\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"sys.h\"",
      "#include \"util.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/dlm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_unlock",
          "args": [
            "ls->ls_dlm",
            "gl->gl_lksb.sb_lkid",
            "DLM_LKF_CANCEL",
            "NULL",
            "gl"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3462-3502",
          "snippet": "int dlm_unlock(dlm_lockspace_t *lockspace,\n\t       uint32_t lkid,\n\t       uint32_t flags,\n\t       struct dlm_lksb *lksb,\n\t       void *astarg)\n{\n\tstruct dlm_ls *ls;\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_args args;\n\tint error;\n\n\tls = dlm_find_lockspace_local(lockspace);\n\tif (!ls)\n\t\treturn -EINVAL;\n\n\tdlm_lock_recovery(ls);\n\n\terror = find_lkb(ls, lkid, &lkb);\n\tif (error)\n\t\tgoto out;\n\n\terror = set_unlock_args(flags, astarg, &args);\n\tif (error)\n\t\tgoto out_put;\n\n\tif (flags & DLM_LKF_CANCEL)\n\t\terror = cancel_lock(ls, lkb, &args);\n\telse\n\t\terror = unlock_lock(ls, lkb, &args);\n\n\tif (error == -DLM_EUNLOCK || error == -DLM_ECANCEL)\n\t\terror = 0;\n\tif (error == -EBUSY && (flags & (DLM_LKF_CANCEL | DLM_LKF_FORCEUNLOCK)))\n\t\terror = 0;\n out_put:\n\tdlm_put_lkb(lkb);\n out:\n\tdlm_unlock_recovery(ls);\n\tdlm_put_lockspace(ls);\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nint dlm_unlock(dlm_lockspace_t *lockspace,\n\t       uint32_t lkid,\n\t       uint32_t flags,\n\t       struct dlm_lksb *lksb,\n\t       void *astarg)\n{\n\tstruct dlm_ls *ls;\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_args args;\n\tint error;\n\n\tls = dlm_find_lockspace_local(lockspace);\n\tif (!ls)\n\t\treturn -EINVAL;\n\n\tdlm_lock_recovery(ls);\n\n\terror = find_lkb(ls, lkid, &lkb);\n\tif (error)\n\t\tgoto out;\n\n\terror = set_unlock_args(flags, astarg, &args);\n\tif (error)\n\t\tgoto out_put;\n\n\tif (flags & DLM_LKF_CANCEL)\n\t\terror = cancel_lock(ls, lkb, &args);\n\telse\n\t\terror = unlock_lock(ls, lkb, &args);\n\n\tif (error == -DLM_EUNLOCK || error == -DLM_ECANCEL)\n\t\terror = 0;\n\tif (error == -EBUSY && (flags & (DLM_LKF_CANCEL | DLM_LKF_FORCEUNLOCK)))\n\t\terror = 0;\n out_put:\n\tdlm_put_lkb(lkb);\n out:\n\tdlm_unlock_recovery(ls);\n\tdlm_put_lockspace(ls);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/dlm.h>\n#include <linux/fs.h>\n\nstatic void gdlm_cancel(struct gfs2_glock *gl)\n{\n\tstruct lm_lockstruct *ls = &gl->gl_sbd->sd_lockstruct;\n\tdlm_unlock(ls->ls_dlm, gl->gl_lksb.sb_lkid, DLM_LKF_CANCEL, NULL, gl);\n}"
  },
  {
    "function_name": "gdlm_put_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lock_dlm.c",
    "lines": "282-318",
    "snippet": "static void gdlm_put_lock(struct gfs2_glock *gl)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tint lvb_needs_unlock = 0;\n\tint error;\n\n\tif (gl->gl_lksb.sb_lkid == 0) {\n\t\tgfs2_glock_free(gl);\n\t\treturn;\n\t}\n\n\tclear_bit(GLF_BLOCKING, &gl->gl_flags);\n\tgfs2_glstats_inc(gl, GFS2_LKS_DCOUNT);\n\tgfs2_sbstats_inc(gl, GFS2_LKS_DCOUNT);\n\tgfs2_update_request_times(gl);\n\n\t/* don't want to skip dlm_unlock writing the lvb when lock is ex */\n\n\tif (gl->gl_lksb.sb_lvbptr && (gl->gl_state == LM_ST_EXCLUSIVE))\n\t\tlvb_needs_unlock = 1;\n\n\tif (test_bit(SDF_SKIP_DLM_UNLOCK, &sdp->sd_flags) &&\n\t    !lvb_needs_unlock) {\n\t\tgfs2_glock_free(gl);\n\t\treturn;\n\t}\n\n\terror = dlm_unlock(ls->ls_dlm, gl->gl_lksb.sb_lkid, DLM_LKF_VALBLK,\n\t\t\t   NULL, gl);\n\tif (error) {\n\t\tpr_err(\"gdlm_unlock %x,%llx err=%d\\n\",\n\t\t       gl->gl_name.ln_type,\n\t\t       (unsigned long long)gl->gl_name.ln_number, error);\n\t\treturn;\n\t}\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"sys.h\"",
      "#include \"util.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/dlm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"gdlm_unlock %x,%llx err=%d\\n\"",
            "gl->gl_name.ln_type",
            "(unsigned long long)gl->gl_name.ln_number",
            "error"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlm_unlock",
          "args": [
            "ls->ls_dlm",
            "gl->gl_lksb.sb_lkid",
            "DLM_LKF_VALBLK",
            "NULL",
            "gl"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3462-3502",
          "snippet": "int dlm_unlock(dlm_lockspace_t *lockspace,\n\t       uint32_t lkid,\n\t       uint32_t flags,\n\t       struct dlm_lksb *lksb,\n\t       void *astarg)\n{\n\tstruct dlm_ls *ls;\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_args args;\n\tint error;\n\n\tls = dlm_find_lockspace_local(lockspace);\n\tif (!ls)\n\t\treturn -EINVAL;\n\n\tdlm_lock_recovery(ls);\n\n\terror = find_lkb(ls, lkid, &lkb);\n\tif (error)\n\t\tgoto out;\n\n\terror = set_unlock_args(flags, astarg, &args);\n\tif (error)\n\t\tgoto out_put;\n\n\tif (flags & DLM_LKF_CANCEL)\n\t\terror = cancel_lock(ls, lkb, &args);\n\telse\n\t\terror = unlock_lock(ls, lkb, &args);\n\n\tif (error == -DLM_EUNLOCK || error == -DLM_ECANCEL)\n\t\terror = 0;\n\tif (error == -EBUSY && (flags & (DLM_LKF_CANCEL | DLM_LKF_FORCEUNLOCK)))\n\t\terror = 0;\n out_put:\n\tdlm_put_lkb(lkb);\n out:\n\tdlm_unlock_recovery(ls);\n\tdlm_put_lockspace(ls);\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nint dlm_unlock(dlm_lockspace_t *lockspace,\n\t       uint32_t lkid,\n\t       uint32_t flags,\n\t       struct dlm_lksb *lksb,\n\t       void *astarg)\n{\n\tstruct dlm_ls *ls;\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_args args;\n\tint error;\n\n\tls = dlm_find_lockspace_local(lockspace);\n\tif (!ls)\n\t\treturn -EINVAL;\n\n\tdlm_lock_recovery(ls);\n\n\terror = find_lkb(ls, lkid, &lkb);\n\tif (error)\n\t\tgoto out;\n\n\terror = set_unlock_args(flags, astarg, &args);\n\tif (error)\n\t\tgoto out_put;\n\n\tif (flags & DLM_LKF_CANCEL)\n\t\terror = cancel_lock(ls, lkb, &args);\n\telse\n\t\terror = unlock_lock(ls, lkb, &args);\n\n\tif (error == -DLM_EUNLOCK || error == -DLM_ECANCEL)\n\t\terror = 0;\n\tif (error == -EBUSY && (flags & (DLM_LKF_CANCEL | DLM_LKF_FORCEUNLOCK)))\n\t\terror = 0;\n out_put:\n\tdlm_put_lkb(lkb);\n out:\n\tdlm_unlock_recovery(ls);\n\tdlm_put_lockspace(ls);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glock_free",
          "args": [
            "gl"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "120-127",
          "snippet": "void gfs2_glock_free(struct gfs2_glock *gl)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\n\tcall_rcu(&gl->gl_rcu, gfs2_glock_dealloc);\n\tif (atomic_dec_and_test(&sdp->sd_glock_disposal))\n\t\twake_up(&sdp->sd_glock_wait);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_free(struct gfs2_glock *gl)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\n\tcall_rcu(&gl->gl_rcu, gfs2_glock_dealloc);\n\tif (atomic_dec_and_test(&sdp->sd_glock_disposal))\n\t\twake_up(&sdp->sd_glock_wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "SDF_SKIP_DLM_UNLOCK",
            "&sdp->sd_flags"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_update_request_times",
          "args": [
            "gl"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_update_request_times",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lock_dlm.c",
          "lines": "100-115",
          "snippet": "static inline void gfs2_update_request_times(struct gfs2_glock *gl)\n{\n\tstruct gfs2_pcpu_lkstats *lks;\n\tconst unsigned gltype = gl->gl_name.ln_type;\n\tktime_t dstamp;\n\ts64 irt;\n\n\tpreempt_disable();\n\tdstamp = gl->gl_dstamp;\n\tgl->gl_dstamp = ktime_get_real();\n\tirt = ktime_to_ns(ktime_sub(gl->gl_dstamp, dstamp));\n\tlks = this_cpu_ptr(gl->gl_sbd->sd_lkstats);\n\tgfs2_update_stats(&gl->gl_stats, GFS2_LKS_SIRT, irt);\t\t/* Local */\n\tgfs2_update_stats(&lks->lkstats[gltype], GFS2_LKS_SIRT, irt);\t/* Global */\n\tpreempt_enable();\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/dlm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/dlm.h>\n#include <linux/fs.h>\n\nstatic inline void gfs2_update_request_times(struct gfs2_glock *gl)\n{\n\tstruct gfs2_pcpu_lkstats *lks;\n\tconst unsigned gltype = gl->gl_name.ln_type;\n\tktime_t dstamp;\n\ts64 irt;\n\n\tpreempt_disable();\n\tdstamp = gl->gl_dstamp;\n\tgl->gl_dstamp = ktime_get_real();\n\tirt = ktime_to_ns(ktime_sub(gl->gl_dstamp, dstamp));\n\tlks = this_cpu_ptr(gl->gl_sbd->sd_lkstats);\n\tgfs2_update_stats(&gl->gl_stats, GFS2_LKS_SIRT, irt);\t\t/* Local */\n\tgfs2_update_stats(&lks->lkstats[gltype], GFS2_LKS_SIRT, irt);\t/* Global */\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_sbstats_inc",
          "args": [
            "gl",
            "GFS2_LKS_DCOUNT"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_sbstats_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "832-838",
          "snippet": "static inline void gfs2_sbstats_inc(const struct gfs2_glock *gl, int which)\n{\n\tconst struct gfs2_sbd *sdp = gl->gl_sbd;\n\tpreempt_disable();\n\tthis_cpu_ptr(sdp->sd_lkstats)->lkstats[gl->gl_name.ln_type].stats[which]++;\n\tpreempt_enable();\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline void gfs2_sbstats_inc(const struct gfs2_glock *gl, int which)\n{\n\tconst struct gfs2_sbd *sdp = gl->gl_sbd;\n\tpreempt_disable();\n\tthis_cpu_ptr(sdp->sd_lkstats)->lkstats[gl->gl_name.ln_type].stats[which]++;\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glstats_inc",
          "args": [
            "gl",
            "GFS2_LKS_DCOUNT"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glstats_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "827-830",
          "snippet": "static inline void gfs2_glstats_inc(struct gfs2_glock *gl, int which)\n{\n\tgl->gl_stats.stats[which]++;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline void gfs2_glstats_inc(struct gfs2_glock *gl, int which)\n{\n\tgl->gl_stats.stats[which]++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "GLF_BLOCKING",
            "&gl->gl_flags"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "892-896",
          "snippet": "static inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_clear_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_clear_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/dlm.h>\n#include <linux/fs.h>\n\nstatic void gdlm_put_lock(struct gfs2_glock *gl)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\tstruct lm_lockstruct *ls = &sdp->sd_lockstruct;\n\tint lvb_needs_unlock = 0;\n\tint error;\n\n\tif (gl->gl_lksb.sb_lkid == 0) {\n\t\tgfs2_glock_free(gl);\n\t\treturn;\n\t}\n\n\tclear_bit(GLF_BLOCKING, &gl->gl_flags);\n\tgfs2_glstats_inc(gl, GFS2_LKS_DCOUNT);\n\tgfs2_sbstats_inc(gl, GFS2_LKS_DCOUNT);\n\tgfs2_update_request_times(gl);\n\n\t/* don't want to skip dlm_unlock writing the lvb when lock is ex */\n\n\tif (gl->gl_lksb.sb_lvbptr && (gl->gl_state == LM_ST_EXCLUSIVE))\n\t\tlvb_needs_unlock = 1;\n\n\tif (test_bit(SDF_SKIP_DLM_UNLOCK, &sdp->sd_flags) &&\n\t    !lvb_needs_unlock) {\n\t\tgfs2_glock_free(gl);\n\t\treturn;\n\t}\n\n\terror = dlm_unlock(ls->ls_dlm, gl->gl_lksb.sb_lkid, DLM_LKF_VALBLK,\n\t\t\t   NULL, gl);\n\tif (error) {\n\t\tpr_err(\"gdlm_unlock %x,%llx err=%d\\n\",\n\t\t       gl->gl_name.ln_type,\n\t\t       (unsigned long long)gl->gl_name.ln_number, error);\n\t\treturn;\n\t}\n}"
  },
  {
    "function_name": "gdlm_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lock_dlm.c",
    "lines": "253-280",
    "snippet": "static int gdlm_lock(struct gfs2_glock *gl, unsigned int req_state,\n\t\t     unsigned int flags)\n{\n\tstruct lm_lockstruct *ls = &gl->gl_sbd->sd_lockstruct;\n\tint req;\n\tu32 lkf;\n\tchar strname[GDLM_STRNAME_BYTES] = \"\";\n\n\treq = make_mode(req_state);\n\tlkf = make_flags(gl, flags, req);\n\tgfs2_glstats_inc(gl, GFS2_LKS_DCOUNT);\n\tgfs2_sbstats_inc(gl, GFS2_LKS_DCOUNT);\n\tif (gl->gl_lksb.sb_lkid) {\n\t\tgfs2_update_request_times(gl);\n\t} else {\n\t\tmemset(strname, ' ', GDLM_STRNAME_BYTES - 1);\n\t\tstrname[GDLM_STRNAME_BYTES - 1] = '\\0';\n\t\tgfs2_reverse_hex(strname + 7, gl->gl_name.ln_type);\n\t\tgfs2_reverse_hex(strname + 23, gl->gl_name.ln_number);\n\t\tgl->gl_dstamp = ktime_get_real();\n\t}\n\t/*\n\t * Submit the actual lock request.\n\t */\n\n\treturn dlm_lock(ls->ls_dlm, req, &gl->gl_lksb, lkf, strname,\n\t\t\tGDLM_STRNAME_BYTES - 1, 0, gdlm_ast, gl, gdlm_bast);\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"sys.h\"",
      "#include \"util.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/dlm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dlm_lock",
          "args": [
            "ls->ls_dlm",
            "req",
            "&gl->gl_lksb",
            "lkf",
            "strname",
            "GDLM_STRNAME_BYTES - 1",
            "0",
            "gdlm_ast",
            "gl",
            "gdlm_bast"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dlm/lock.c",
          "lines": "3409-3460",
          "snippet": "int dlm_lock(dlm_lockspace_t *lockspace,\n\t     int mode,\n\t     struct dlm_lksb *lksb,\n\t     uint32_t flags,\n\t     void *name,\n\t     unsigned int namelen,\n\t     uint32_t parent_lkid,\n\t     void (*ast) (void *astarg),\n\t     void *astarg,\n\t     void (*bast) (void *astarg, int mode))\n{\n\tstruct dlm_ls *ls;\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_args args;\n\tint error, convert = flags & DLM_LKF_CONVERT;\n\n\tls = dlm_find_lockspace_local(lockspace);\n\tif (!ls)\n\t\treturn -EINVAL;\n\n\tdlm_lock_recovery(ls);\n\n\tif (convert)\n\t\terror = find_lkb(ls, lksb->sb_lkid, &lkb);\n\telse\n\t\terror = create_lkb(ls, &lkb);\n\n\tif (error)\n\t\tgoto out;\n\n\terror = set_lock_args(mode, lksb, flags, namelen, 0, ast,\n\t\t\t      astarg, bast, &args);\n\tif (error)\n\t\tgoto out_put;\n\n\tif (convert)\n\t\terror = convert_lock(ls, lkb, &args);\n\telse\n\t\terror = request_lock(ls, lkb, name, namelen, &args);\n\n\tif (error == -EINPROGRESS)\n\t\terror = 0;\n out_put:\n\tif (convert || error)\n\t\t__put_lkb(ls, lkb);\n\tif (error == -EAGAIN || error == -EDEADLK)\n\t\terror = 0;\n out:\n\tdlm_unlock_recovery(ls);\n\tdlm_put_lockspace(ls);\n\treturn error;\n}",
          "includes": [
            "#include \"config.h\"",
            "#include \"user.h\"",
            "#include \"lvb_table.h\"",
            "#include \"recover.h\"",
            "#include \"rcom.h\"",
            "#include \"lock.h\"",
            "#include \"ast.h\"",
            "#include \"lockspace.h\"",
            "#include \"member.h\"",
            "#include \"dir.h\"",
            "#include \"util.h\"",
            "#include \"requestqueue.h\"",
            "#include \"lowcomms.h\"",
            "#include \"memory.h\"",
            "#include <linux/dlm_device.h>",
            "#include \"dlm_internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);",
            "static int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);",
            "static void del_timeout(struct dlm_lkb *lkb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"config.h\"\n#include \"user.h\"\n#include \"lvb_table.h\"\n#include \"recover.h\"\n#include \"rcom.h\"\n#include \"lock.h\"\n#include \"ast.h\"\n#include \"lockspace.h\"\n#include \"member.h\"\n#include \"dir.h\"\n#include \"util.h\"\n#include \"requestqueue.h\"\n#include \"lowcomms.h\"\n#include \"memory.h\"\n#include <linux/dlm_device.h>\n#include \"dlm_internal.h\"\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/types.h>\n\nstatic int send_request(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_convert(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_unlock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_cancel(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_grant(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int send_bast(struct dlm_rsb *r, struct dlm_lkb *lkb, int mode);\nstatic int send_lookup(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _request_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic int _cancel_lock(struct dlm_rsb *r, struct dlm_lkb *lkb);\nstatic void del_timeout(struct dlm_lkb *lkb);\n\nint dlm_lock(dlm_lockspace_t *lockspace,\n\t     int mode,\n\t     struct dlm_lksb *lksb,\n\t     uint32_t flags,\n\t     void *name,\n\t     unsigned int namelen,\n\t     uint32_t parent_lkid,\n\t     void (*ast) (void *astarg),\n\t     void *astarg,\n\t     void (*bast) (void *astarg, int mode))\n{\n\tstruct dlm_ls *ls;\n\tstruct dlm_lkb *lkb;\n\tstruct dlm_args args;\n\tint error, convert = flags & DLM_LKF_CONVERT;\n\n\tls = dlm_find_lockspace_local(lockspace);\n\tif (!ls)\n\t\treturn -EINVAL;\n\n\tdlm_lock_recovery(ls);\n\n\tif (convert)\n\t\terror = find_lkb(ls, lksb->sb_lkid, &lkb);\n\telse\n\t\terror = create_lkb(ls, &lkb);\n\n\tif (error)\n\t\tgoto out;\n\n\terror = set_lock_args(mode, lksb, flags, namelen, 0, ast,\n\t\t\t      astarg, bast, &args);\n\tif (error)\n\t\tgoto out_put;\n\n\tif (convert)\n\t\terror = convert_lock(ls, lkb, &args);\n\telse\n\t\terror = request_lock(ls, lkb, name, namelen, &args);\n\n\tif (error == -EINPROGRESS)\n\t\terror = 0;\n out_put:\n\tif (convert || error)\n\t\t__put_lkb(ls, lkb);\n\tif (error == -EAGAIN || error == -EDEADLK)\n\t\terror = 0;\n out:\n\tdlm_unlock_recovery(ls);\n\tdlm_put_lockspace(ls);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_get_real",
          "args": [],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_reverse_hex",
          "args": [
            "strname + 23",
            "gl->gl_name.ln_number"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_reverse_hex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lock_dlm.c",
          "lines": "244-251",
          "snippet": "static void gfs2_reverse_hex(char *c, u64 value)\n{\n\t*c = '0';\n\twhile (value) {\n\t\t*c-- = hex_asc[value & 0x0f];\n\t\tvalue >>= 4;\n\t}\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/dlm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/dlm.h>\n#include <linux/fs.h>\n\nstatic void gfs2_reverse_hex(char *c, u64 value)\n{\n\t*c = '0';\n\twhile (value) {\n\t\t*c-- = hex_asc[value & 0x0f];\n\t\tvalue >>= 4;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "strname",
            "' '",
            "GDLM_STRNAME_BYTES - 1"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_update_request_times",
          "args": [
            "gl"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_update_request_times",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lock_dlm.c",
          "lines": "100-115",
          "snippet": "static inline void gfs2_update_request_times(struct gfs2_glock *gl)\n{\n\tstruct gfs2_pcpu_lkstats *lks;\n\tconst unsigned gltype = gl->gl_name.ln_type;\n\tktime_t dstamp;\n\ts64 irt;\n\n\tpreempt_disable();\n\tdstamp = gl->gl_dstamp;\n\tgl->gl_dstamp = ktime_get_real();\n\tirt = ktime_to_ns(ktime_sub(gl->gl_dstamp, dstamp));\n\tlks = this_cpu_ptr(gl->gl_sbd->sd_lkstats);\n\tgfs2_update_stats(&gl->gl_stats, GFS2_LKS_SIRT, irt);\t\t/* Local */\n\tgfs2_update_stats(&lks->lkstats[gltype], GFS2_LKS_SIRT, irt);\t/* Global */\n\tpreempt_enable();\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/dlm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/dlm.h>\n#include <linux/fs.h>\n\nstatic inline void gfs2_update_request_times(struct gfs2_glock *gl)\n{\n\tstruct gfs2_pcpu_lkstats *lks;\n\tconst unsigned gltype = gl->gl_name.ln_type;\n\tktime_t dstamp;\n\ts64 irt;\n\n\tpreempt_disable();\n\tdstamp = gl->gl_dstamp;\n\tgl->gl_dstamp = ktime_get_real();\n\tirt = ktime_to_ns(ktime_sub(gl->gl_dstamp, dstamp));\n\tlks = this_cpu_ptr(gl->gl_sbd->sd_lkstats);\n\tgfs2_update_stats(&gl->gl_stats, GFS2_LKS_SIRT, irt);\t\t/* Local */\n\tgfs2_update_stats(&lks->lkstats[gltype], GFS2_LKS_SIRT, irt);\t/* Global */\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_sbstats_inc",
          "args": [
            "gl",
            "GFS2_LKS_DCOUNT"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_sbstats_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "832-838",
          "snippet": "static inline void gfs2_sbstats_inc(const struct gfs2_glock *gl, int which)\n{\n\tconst struct gfs2_sbd *sdp = gl->gl_sbd;\n\tpreempt_disable();\n\tthis_cpu_ptr(sdp->sd_lkstats)->lkstats[gl->gl_name.ln_type].stats[which]++;\n\tpreempt_enable();\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline void gfs2_sbstats_inc(const struct gfs2_glock *gl, int which)\n{\n\tconst struct gfs2_sbd *sdp = gl->gl_sbd;\n\tpreempt_disable();\n\tthis_cpu_ptr(sdp->sd_lkstats)->lkstats[gl->gl_name.ln_type].stats[which]++;\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfs2_glstats_inc",
          "args": [
            "gl",
            "GFS2_LKS_DCOUNT"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glstats_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/incore.h",
          "lines": "827-830",
          "snippet": "static inline void gfs2_glstats_inc(struct gfs2_glock *gl, int which)\n{\n\tgl->gl_stats.stats[which]++;\n}",
          "includes": [
            "#include <linux/lockref.h>",
            "#include <linux/percpu.h>",
            "#include <linux/ktime.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/completion.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/dlm.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockref.h>\n#include <linux/percpu.h>\n#include <linux/ktime.h>\n#include <linux/rbtree.h>\n#include <linux/completion.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/buffer_head.h>\n#include <linux/dlm.h>\n#include <linux/workqueue.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n\nstatic inline void gfs2_glstats_inc(struct gfs2_glock *gl, int which)\n{\n\tgl->gl_stats.stats[which]++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_flags",
          "args": [
            "gl",
            "flags",
            "req"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "make_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lock_dlm.c",
          "lines": "205-242",
          "snippet": "static u32 make_flags(struct gfs2_glock *gl, const unsigned int gfs_flags,\n\t\t      const int req)\n{\n\tu32 lkf = 0;\n\n\tif (gl->gl_lksb.sb_lvbptr)\n\t\tlkf |= DLM_LKF_VALBLK;\n\n\tif (gfs_flags & LM_FLAG_TRY)\n\t\tlkf |= DLM_LKF_NOQUEUE;\n\n\tif (gfs_flags & LM_FLAG_TRY_1CB) {\n\t\tlkf |= DLM_LKF_NOQUEUE;\n\t\tlkf |= DLM_LKF_NOQUEUEBAST;\n\t}\n\n\tif (gfs_flags & LM_FLAG_PRIORITY) {\n\t\tlkf |= DLM_LKF_NOORDER;\n\t\tlkf |= DLM_LKF_HEADQUE;\n\t}\n\n\tif (gfs_flags & LM_FLAG_ANY) {\n\t\tif (req == DLM_LOCK_PR)\n\t\t\tlkf |= DLM_LKF_ALTCW;\n\t\telse if (req == DLM_LOCK_CW)\n\t\t\tlkf |= DLM_LKF_ALTPR;\n\t\telse\n\t\t\tBUG();\n\t}\n\n\tif (gl->gl_lksb.sb_lkid != 0) {\n\t\tlkf |= DLM_LKF_CONVERT;\n\t\tif (test_bit(GLF_BLOCKING, &gl->gl_flags))\n\t\t\tlkf |= DLM_LKF_QUECVT;\n\t}\n\n\treturn lkf;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/dlm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/dlm.h>\n#include <linux/fs.h>\n\nstatic u32 make_flags(struct gfs2_glock *gl, const unsigned int gfs_flags,\n\t\t      const int req)\n{\n\tu32 lkf = 0;\n\n\tif (gl->gl_lksb.sb_lvbptr)\n\t\tlkf |= DLM_LKF_VALBLK;\n\n\tif (gfs_flags & LM_FLAG_TRY)\n\t\tlkf |= DLM_LKF_NOQUEUE;\n\n\tif (gfs_flags & LM_FLAG_TRY_1CB) {\n\t\tlkf |= DLM_LKF_NOQUEUE;\n\t\tlkf |= DLM_LKF_NOQUEUEBAST;\n\t}\n\n\tif (gfs_flags & LM_FLAG_PRIORITY) {\n\t\tlkf |= DLM_LKF_NOORDER;\n\t\tlkf |= DLM_LKF_HEADQUE;\n\t}\n\n\tif (gfs_flags & LM_FLAG_ANY) {\n\t\tif (req == DLM_LOCK_PR)\n\t\t\tlkf |= DLM_LKF_ALTCW;\n\t\telse if (req == DLM_LOCK_CW)\n\t\t\tlkf |= DLM_LKF_ALTPR;\n\t\telse\n\t\t\tBUG();\n\t}\n\n\tif (gl->gl_lksb.sb_lkid != 0) {\n\t\tlkf |= DLM_LKF_CONVERT;\n\t\tif (test_bit(GLF_BLOCKING, &gl->gl_flags))\n\t\t\tlkf |= DLM_LKF_QUECVT;\n\t}\n\n\treturn lkf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_mode",
          "args": [
            "req_state"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "make_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lock_dlm.c",
          "lines": "188-203",
          "snippet": "static int make_mode(const unsigned int lmstate)\n{\n\tswitch (lmstate) {\n\tcase LM_ST_UNLOCKED:\n\t\treturn DLM_LOCK_NL;\n\tcase LM_ST_EXCLUSIVE:\n\t\treturn DLM_LOCK_EX;\n\tcase LM_ST_DEFERRED:\n\t\treturn DLM_LOCK_CW;\n\tcase LM_ST_SHARED:\n\t\treturn DLM_LOCK_PR;\n\t}\n\tpr_err(\"unknown LM state %d\\n\", lmstate);\n\tBUG();\n\treturn -1;\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/dlm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/dlm.h>\n#include <linux/fs.h>\n\nstatic int make_mode(const unsigned int lmstate)\n{\n\tswitch (lmstate) {\n\tcase LM_ST_UNLOCKED:\n\t\treturn DLM_LOCK_NL;\n\tcase LM_ST_EXCLUSIVE:\n\t\treturn DLM_LOCK_EX;\n\tcase LM_ST_DEFERRED:\n\t\treturn DLM_LOCK_CW;\n\tcase LM_ST_SHARED:\n\t\treturn DLM_LOCK_PR;\n\t}\n\tpr_err(\"unknown LM state %d\\n\", lmstate);\n\tBUG();\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/dlm.h>\n#include <linux/fs.h>\n\nstatic int gdlm_lock(struct gfs2_glock *gl, unsigned int req_state,\n\t\t     unsigned int flags)\n{\n\tstruct lm_lockstruct *ls = &gl->gl_sbd->sd_lockstruct;\n\tint req;\n\tu32 lkf;\n\tchar strname[GDLM_STRNAME_BYTES] = \"\";\n\n\treq = make_mode(req_state);\n\tlkf = make_flags(gl, flags, req);\n\tgfs2_glstats_inc(gl, GFS2_LKS_DCOUNT);\n\tgfs2_sbstats_inc(gl, GFS2_LKS_DCOUNT);\n\tif (gl->gl_lksb.sb_lkid) {\n\t\tgfs2_update_request_times(gl);\n\t} else {\n\t\tmemset(strname, ' ', GDLM_STRNAME_BYTES - 1);\n\t\tstrname[GDLM_STRNAME_BYTES - 1] = '\\0';\n\t\tgfs2_reverse_hex(strname + 7, gl->gl_name.ln_type);\n\t\tgfs2_reverse_hex(strname + 23, gl->gl_name.ln_number);\n\t\tgl->gl_dstamp = ktime_get_real();\n\t}\n\t/*\n\t * Submit the actual lock request.\n\t */\n\n\treturn dlm_lock(ls->ls_dlm, req, &gl->gl_lksb, lkf, strname,\n\t\t\tGDLM_STRNAME_BYTES - 1, 0, gdlm_ast, gl, gdlm_bast);\n}"
  },
  {
    "function_name": "gfs2_reverse_hex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lock_dlm.c",
    "lines": "244-251",
    "snippet": "static void gfs2_reverse_hex(char *c, u64 value)\n{\n\t*c = '0';\n\twhile (value) {\n\t\t*c-- = hex_asc[value & 0x0f];\n\t\tvalue >>= 4;\n\t}\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"sys.h\"",
      "#include \"util.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/dlm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/dlm.h>\n#include <linux/fs.h>\n\nstatic void gfs2_reverse_hex(char *c, u64 value)\n{\n\t*c = '0';\n\twhile (value) {\n\t\t*c-- = hex_asc[value & 0x0f];\n\t\tvalue >>= 4;\n\t}\n}"
  },
  {
    "function_name": "make_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lock_dlm.c",
    "lines": "205-242",
    "snippet": "static u32 make_flags(struct gfs2_glock *gl, const unsigned int gfs_flags,\n\t\t      const int req)\n{\n\tu32 lkf = 0;\n\n\tif (gl->gl_lksb.sb_lvbptr)\n\t\tlkf |= DLM_LKF_VALBLK;\n\n\tif (gfs_flags & LM_FLAG_TRY)\n\t\tlkf |= DLM_LKF_NOQUEUE;\n\n\tif (gfs_flags & LM_FLAG_TRY_1CB) {\n\t\tlkf |= DLM_LKF_NOQUEUE;\n\t\tlkf |= DLM_LKF_NOQUEUEBAST;\n\t}\n\n\tif (gfs_flags & LM_FLAG_PRIORITY) {\n\t\tlkf |= DLM_LKF_NOORDER;\n\t\tlkf |= DLM_LKF_HEADQUE;\n\t}\n\n\tif (gfs_flags & LM_FLAG_ANY) {\n\t\tif (req == DLM_LOCK_PR)\n\t\t\tlkf |= DLM_LKF_ALTCW;\n\t\telse if (req == DLM_LOCK_CW)\n\t\t\tlkf |= DLM_LKF_ALTPR;\n\t\telse\n\t\t\tBUG();\n\t}\n\n\tif (gl->gl_lksb.sb_lkid != 0) {\n\t\tlkf |= DLM_LKF_CONVERT;\n\t\tif (test_bit(GLF_BLOCKING, &gl->gl_flags))\n\t\t\tlkf |= DLM_LKF_QUECVT;\n\t}\n\n\treturn lkf;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"sys.h\"",
      "#include \"util.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/dlm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "GLF_BLOCKING",
            "&gl->gl_flags"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/dlm.h>\n#include <linux/fs.h>\n\nstatic u32 make_flags(struct gfs2_glock *gl, const unsigned int gfs_flags,\n\t\t      const int req)\n{\n\tu32 lkf = 0;\n\n\tif (gl->gl_lksb.sb_lvbptr)\n\t\tlkf |= DLM_LKF_VALBLK;\n\n\tif (gfs_flags & LM_FLAG_TRY)\n\t\tlkf |= DLM_LKF_NOQUEUE;\n\n\tif (gfs_flags & LM_FLAG_TRY_1CB) {\n\t\tlkf |= DLM_LKF_NOQUEUE;\n\t\tlkf |= DLM_LKF_NOQUEUEBAST;\n\t}\n\n\tif (gfs_flags & LM_FLAG_PRIORITY) {\n\t\tlkf |= DLM_LKF_NOORDER;\n\t\tlkf |= DLM_LKF_HEADQUE;\n\t}\n\n\tif (gfs_flags & LM_FLAG_ANY) {\n\t\tif (req == DLM_LOCK_PR)\n\t\t\tlkf |= DLM_LKF_ALTCW;\n\t\telse if (req == DLM_LOCK_CW)\n\t\t\tlkf |= DLM_LKF_ALTPR;\n\t\telse\n\t\t\tBUG();\n\t}\n\n\tif (gl->gl_lksb.sb_lkid != 0) {\n\t\tlkf |= DLM_LKF_CONVERT;\n\t\tif (test_bit(GLF_BLOCKING, &gl->gl_flags))\n\t\t\tlkf |= DLM_LKF_QUECVT;\n\t}\n\n\treturn lkf;\n}"
  },
  {
    "function_name": "make_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lock_dlm.c",
    "lines": "188-203",
    "snippet": "static int make_mode(const unsigned int lmstate)\n{\n\tswitch (lmstate) {\n\tcase LM_ST_UNLOCKED:\n\t\treturn DLM_LOCK_NL;\n\tcase LM_ST_EXCLUSIVE:\n\t\treturn DLM_LOCK_EX;\n\tcase LM_ST_DEFERRED:\n\t\treturn DLM_LOCK_CW;\n\tcase LM_ST_SHARED:\n\t\treturn DLM_LOCK_PR;\n\t}\n\tpr_err(\"unknown LM state %d\\n\", lmstate);\n\tBUG();\n\treturn -1;\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"sys.h\"",
      "#include \"util.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/dlm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"unknown LM state %d\\n\"",
            "lmstate"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/dlm.h>\n#include <linux/fs.h>\n\nstatic int make_mode(const unsigned int lmstate)\n{\n\tswitch (lmstate) {\n\tcase LM_ST_UNLOCKED:\n\t\treturn DLM_LOCK_NL;\n\tcase LM_ST_EXCLUSIVE:\n\t\treturn DLM_LOCK_EX;\n\tcase LM_ST_DEFERRED:\n\t\treturn DLM_LOCK_CW;\n\tcase LM_ST_SHARED:\n\t\treturn DLM_LOCK_PR;\n\t}\n\tpr_err(\"unknown LM state %d\\n\", lmstate);\n\tBUG();\n\treturn -1;\n}"
  },
  {
    "function_name": "gdlm_bast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lock_dlm.c",
    "lines": "166-184",
    "snippet": "static void gdlm_bast(void *arg, int mode)\n{\n\tstruct gfs2_glock *gl = arg;\n\n\tswitch (mode) {\n\tcase DLM_LOCK_EX:\n\t\tgfs2_glock_cb(gl, LM_ST_UNLOCKED);\n\t\tbreak;\n\tcase DLM_LOCK_CW:\n\t\tgfs2_glock_cb(gl, LM_ST_DEFERRED);\n\t\tbreak;\n\tcase DLM_LOCK_PR:\n\t\tgfs2_glock_cb(gl, LM_ST_SHARED);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"unknown bast mode %d\\n\", mode);\n\t\tBUG();\n\t}\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"sys.h\"",
      "#include \"util.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/dlm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"unknown bast mode %d\\n\"",
            "mode"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_glock_cb",
          "args": [
            "gl",
            "LM_ST_SHARED"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_cb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1251-1272",
          "snippet": "void gfs2_glock_cb(struct gfs2_glock *gl, unsigned int state)\n{\n\tunsigned long delay = 0;\n\tunsigned long holdtime;\n\tunsigned long now = jiffies;\n\n\tgfs2_glock_hold(gl);\n\tholdtime = gl->gl_tchange + gl->gl_hold_time;\n\tif (test_bit(GLF_QUEUED, &gl->gl_flags) &&\n\t    gl->gl_name.ln_type == LM_TYPE_INODE) {\n\t\tif (time_before(now, holdtime))\n\t\t\tdelay = holdtime - now;\n\t\tif (test_bit(GLF_REPLY_PENDING, &gl->gl_flags))\n\t\t\tdelay = gl->gl_hold_time;\n\t}\n\n\tspin_lock(&gl->gl_spin);\n\thandle_callback(gl, state, delay, true);\n\tspin_unlock(&gl->gl_spin);\n\tif (queue_delayed_work(glock_workqueue, &gl->gl_work, delay) == 0)\n\t\tgfs2_glock_put(gl);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *glock_workqueue;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct workqueue_struct *glock_workqueue;\n\nvoid gfs2_glock_cb(struct gfs2_glock *gl, unsigned int state)\n{\n\tunsigned long delay = 0;\n\tunsigned long holdtime;\n\tunsigned long now = jiffies;\n\n\tgfs2_glock_hold(gl);\n\tholdtime = gl->gl_tchange + gl->gl_hold_time;\n\tif (test_bit(GLF_QUEUED, &gl->gl_flags) &&\n\t    gl->gl_name.ln_type == LM_TYPE_INODE) {\n\t\tif (time_before(now, holdtime))\n\t\t\tdelay = holdtime - now;\n\t\tif (test_bit(GLF_REPLY_PENDING, &gl->gl_flags))\n\t\t\tdelay = gl->gl_hold_time;\n\t}\n\n\tspin_lock(&gl->gl_spin);\n\thandle_callback(gl, state, delay, true);\n\tspin_unlock(&gl->gl_spin);\n\tif (queue_delayed_work(glock_workqueue, &gl->gl_work, delay) == 0)\n\t\tgfs2_glock_put(gl);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/dlm.h>\n#include <linux/fs.h>\n\nstatic void gdlm_bast(void *arg, int mode)\n{\n\tstruct gfs2_glock *gl = arg;\n\n\tswitch (mode) {\n\tcase DLM_LOCK_EX:\n\t\tgfs2_glock_cb(gl, LM_ST_UNLOCKED);\n\t\tbreak;\n\tcase DLM_LOCK_CW:\n\t\tgfs2_glock_cb(gl, LM_ST_DEFERRED);\n\t\tbreak;\n\tcase DLM_LOCK_PR:\n\t\tgfs2_glock_cb(gl, LM_ST_SHARED);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"unknown bast mode %d\\n\", mode);\n\t\tBUG();\n\t}\n}"
  },
  {
    "function_name": "gdlm_ast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lock_dlm.c",
    "lines": "117-164",
    "snippet": "static void gdlm_ast(void *arg)\n{\n\tstruct gfs2_glock *gl = arg;\n\tunsigned ret = gl->gl_state;\n\n\tgfs2_update_reply_times(gl);\n\tBUG_ON(gl->gl_lksb.sb_flags & DLM_SBF_DEMOTED);\n\n\tif ((gl->gl_lksb.sb_flags & DLM_SBF_VALNOTVALID) && gl->gl_lksb.sb_lvbptr)\n\t\tmemset(gl->gl_lksb.sb_lvbptr, 0, GDLM_LVB_SIZE);\n\n\tswitch (gl->gl_lksb.sb_status) {\n\tcase -DLM_EUNLOCK: /* Unlocked, so glock can be freed */\n\t\tgfs2_glock_free(gl);\n\t\treturn;\n\tcase -DLM_ECANCEL: /* Cancel while getting lock */\n\t\tret |= LM_OUT_CANCELED;\n\t\tgoto out;\n\tcase -EAGAIN: /* Try lock fails */\n\tcase -EDEADLK: /* Deadlock detected */\n\t\tgoto out;\n\tcase -ETIMEDOUT: /* Canceled due to timeout */\n\t\tret |= LM_OUT_ERROR;\n\t\tgoto out;\n\tcase 0: /* Success */\n\t\tbreak;\n\tdefault: /* Something unexpected */\n\t\tBUG();\n\t}\n\n\tret = gl->gl_req;\n\tif (gl->gl_lksb.sb_flags & DLM_SBF_ALTMODE) {\n\t\tif (gl->gl_req == LM_ST_SHARED)\n\t\t\tret = LM_ST_DEFERRED;\n\t\telse if (gl->gl_req == LM_ST_DEFERRED)\n\t\t\tret = LM_ST_SHARED;\n\t\telse\n\t\t\tBUG();\n\t}\n\n\tset_bit(GLF_INITIAL, &gl->gl_flags);\n\tgfs2_glock_complete(gl, ret);\n\treturn;\nout:\n\tif (!test_bit(GLF_INITIAL, &gl->gl_flags))\n\t\tgl->gl_lksb.sb_lkid = 0;\n\tgfs2_glock_complete(gl, ret);\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"sys.h\"",
      "#include \"util.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/dlm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfs2_glock_complete",
          "args": [
            "gl",
            "ret"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_complete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "1313-1334",
          "snippet": "void gfs2_glock_complete(struct gfs2_glock *gl, int ret)\n{\n\tstruct lm_lockstruct *ls = &gl->gl_sbd->sd_lockstruct;\n\n\tspin_lock(&gl->gl_spin);\n\tgl->gl_reply = ret;\n\n\tif (unlikely(test_bit(DFL_BLOCK_LOCKS, &ls->ls_recover_flags))) {\n\t\tif (gfs2_should_freeze(gl)) {\n\t\t\tset_bit(GLF_FROZEN, &gl->gl_flags);\n\t\t\tspin_unlock(&gl->gl_spin);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tgl->gl_lockref.count++;\n\tset_bit(GLF_REPLY_PENDING, &gl->gl_flags);\n\tspin_unlock(&gl->gl_spin);\n\n\tif (queue_delayed_work(glock_workqueue, &gl->gl_work, 0) == 0)\n\t\tgfs2_glock_put(gl);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct workqueue_struct *glock_workqueue;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic struct workqueue_struct *glock_workqueue;\n\nvoid gfs2_glock_complete(struct gfs2_glock *gl, int ret)\n{\n\tstruct lm_lockstruct *ls = &gl->gl_sbd->sd_lockstruct;\n\n\tspin_lock(&gl->gl_spin);\n\tgl->gl_reply = ret;\n\n\tif (unlikely(test_bit(DFL_BLOCK_LOCKS, &ls->ls_recover_flags))) {\n\t\tif (gfs2_should_freeze(gl)) {\n\t\t\tset_bit(GLF_FROZEN, &gl->gl_flags);\n\t\t\tspin_unlock(&gl->gl_spin);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tgl->gl_lockref.count++;\n\tset_bit(GLF_REPLY_PENDING, &gl->gl_flags);\n\tspin_unlock(&gl->gl_spin);\n\n\tif (queue_delayed_work(glock_workqueue, &gl->gl_work, 0) == 0)\n\t\tgfs2_glock_put(gl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "GLF_INITIAL",
            "&gl->gl_flags"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "GLF_INITIAL",
            "&gl->gl_flags"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_glock_free",
          "args": [
            "gl"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_glock_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/glock.c",
          "lines": "120-127",
          "snippet": "void gfs2_glock_free(struct gfs2_glock *gl)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\n\tcall_rcu(&gl->gl_rcu, gfs2_glock_dealloc);\n\tif (atomic_dec_and_test(&sdp->sd_glock_disposal))\n\t\twake_up(&sdp->sd_glock_wait);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"bmap.h\"",
            "#include \"util.h\"",
            "#include \"super.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"lops.h\"",
            "#include \"inode.h\"",
            "#include \"glops.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/lockref.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/seq_file.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/module.h>",
            "#include <linux/wait.h>",
            "#include <linux/list.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/jhash.h>",
            "#include <linux/sort.h>",
            "#include <linux/delay.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"bmap.h\"\n#include \"util.h\"\n#include \"super.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"lops.h\"\n#include \"inode.h\"\n#include \"glops.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/lockref.h>\n#include <linux/list_sort.h>\n#include <linux/percpu.h>\n#include <linux/bit_spinlock.h>\n#include <linux/rculist_bl.h>\n#include <linux/rcupdate.h>\n#include <linux/jiffies.h>\n#include <linux/workqueue.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <asm/uaccess.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/list.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/kallsyms.h>\n#include <linux/jhash.h>\n#include <linux/sort.h>\n#include <linux/delay.h>\n#include <linux/buffer_head.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nvoid gfs2_glock_free(struct gfs2_glock *gl)\n{\n\tstruct gfs2_sbd *sdp = gl->gl_sbd;\n\n\tcall_rcu(&gl->gl_rcu, gfs2_glock_dealloc);\n\tif (atomic_dec_and_test(&sdp->sd_glock_disposal))\n\t\twake_up(&sdp->sd_glock_wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "gl->gl_lksb.sb_lvbptr",
            "0",
            "GDLM_LVB_SIZE"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "gl->gl_lksb.sb_flags & DLM_SBF_DEMOTED"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_update_reply_times",
          "args": [
            "gl"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_update_reply_times",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lock_dlm.c",
          "lines": "73-89",
          "snippet": "static inline void gfs2_update_reply_times(struct gfs2_glock *gl)\n{\n\tstruct gfs2_pcpu_lkstats *lks;\n\tconst unsigned gltype = gl->gl_name.ln_type;\n\tunsigned index = test_bit(GLF_BLOCKING, &gl->gl_flags) ?\n\t\t\t GFS2_LKS_SRTTB : GFS2_LKS_SRTT;\n\ts64 rtt;\n\n\tpreempt_disable();\n\trtt = ktime_to_ns(ktime_sub(ktime_get_real(), gl->gl_dstamp));\n\tlks = this_cpu_ptr(gl->gl_sbd->sd_lkstats);\n\tgfs2_update_stats(&gl->gl_stats, index, rtt);\t\t/* Local */\n\tgfs2_update_stats(&lks->lkstats[gltype], index, rtt);\t/* Global */\n\tpreempt_enable();\n\n\ttrace_gfs2_glock_lock_time(gl, rtt);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/dlm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/dlm.h>\n#include <linux/fs.h>\n\nstatic inline void gfs2_update_reply_times(struct gfs2_glock *gl)\n{\n\tstruct gfs2_pcpu_lkstats *lks;\n\tconst unsigned gltype = gl->gl_name.ln_type;\n\tunsigned index = test_bit(GLF_BLOCKING, &gl->gl_flags) ?\n\t\t\t GFS2_LKS_SRTTB : GFS2_LKS_SRTT;\n\ts64 rtt;\n\n\tpreempt_disable();\n\trtt = ktime_to_ns(ktime_sub(ktime_get_real(), gl->gl_dstamp));\n\tlks = this_cpu_ptr(gl->gl_sbd->sd_lkstats);\n\tgfs2_update_stats(&gl->gl_stats, index, rtt);\t\t/* Local */\n\tgfs2_update_stats(&lks->lkstats[gltype], index, rtt);\t/* Global */\n\tpreempt_enable();\n\n\ttrace_gfs2_glock_lock_time(gl, rtt);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/dlm.h>\n#include <linux/fs.h>\n\nstatic void gdlm_ast(void *arg)\n{\n\tstruct gfs2_glock *gl = arg;\n\tunsigned ret = gl->gl_state;\n\n\tgfs2_update_reply_times(gl);\n\tBUG_ON(gl->gl_lksb.sb_flags & DLM_SBF_DEMOTED);\n\n\tif ((gl->gl_lksb.sb_flags & DLM_SBF_VALNOTVALID) && gl->gl_lksb.sb_lvbptr)\n\t\tmemset(gl->gl_lksb.sb_lvbptr, 0, GDLM_LVB_SIZE);\n\n\tswitch (gl->gl_lksb.sb_status) {\n\tcase -DLM_EUNLOCK: /* Unlocked, so glock can be freed */\n\t\tgfs2_glock_free(gl);\n\t\treturn;\n\tcase -DLM_ECANCEL: /* Cancel while getting lock */\n\t\tret |= LM_OUT_CANCELED;\n\t\tgoto out;\n\tcase -EAGAIN: /* Try lock fails */\n\tcase -EDEADLK: /* Deadlock detected */\n\t\tgoto out;\n\tcase -ETIMEDOUT: /* Canceled due to timeout */\n\t\tret |= LM_OUT_ERROR;\n\t\tgoto out;\n\tcase 0: /* Success */\n\t\tbreak;\n\tdefault: /* Something unexpected */\n\t\tBUG();\n\t}\n\n\tret = gl->gl_req;\n\tif (gl->gl_lksb.sb_flags & DLM_SBF_ALTMODE) {\n\t\tif (gl->gl_req == LM_ST_SHARED)\n\t\t\tret = LM_ST_DEFERRED;\n\t\telse if (gl->gl_req == LM_ST_DEFERRED)\n\t\t\tret = LM_ST_SHARED;\n\t\telse\n\t\t\tBUG();\n\t}\n\n\tset_bit(GLF_INITIAL, &gl->gl_flags);\n\tgfs2_glock_complete(gl, ret);\n\treturn;\nout:\n\tif (!test_bit(GLF_INITIAL, &gl->gl_flags))\n\t\tgl->gl_lksb.sb_lkid = 0;\n\tgfs2_glock_complete(gl, ret);\n}"
  },
  {
    "function_name": "gfs2_update_request_times",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lock_dlm.c",
    "lines": "100-115",
    "snippet": "static inline void gfs2_update_request_times(struct gfs2_glock *gl)\n{\n\tstruct gfs2_pcpu_lkstats *lks;\n\tconst unsigned gltype = gl->gl_name.ln_type;\n\tktime_t dstamp;\n\ts64 irt;\n\n\tpreempt_disable();\n\tdstamp = gl->gl_dstamp;\n\tgl->gl_dstamp = ktime_get_real();\n\tirt = ktime_to_ns(ktime_sub(gl->gl_dstamp, dstamp));\n\tlks = this_cpu_ptr(gl->gl_sbd->sd_lkstats);\n\tgfs2_update_stats(&gl->gl_stats, GFS2_LKS_SIRT, irt);\t\t/* Local */\n\tgfs2_update_stats(&lks->lkstats[gltype], GFS2_LKS_SIRT, irt);\t/* Global */\n\tpreempt_enable();\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"sys.h\"",
      "#include \"util.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/dlm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_update_stats",
          "args": [
            "&lks->lkstats[gltype]",
            "GFS2_LKS_SIRT",
            "irt"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_update_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lock_dlm.c",
          "lines": "47-54",
          "snippet": "static inline void gfs2_update_stats(struct gfs2_lkstats *s, unsigned index,\n\t\t\t\t     s64 sample)\n{\n\ts64 delta = sample - s->stats[index];\n\ts->stats[index] += (delta >> 3);\n\tindex++;\n\ts->stats[index] += ((abs64(delta) - s->stats[index]) >> 2);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/dlm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/dlm.h>\n#include <linux/fs.h>\n\nstatic inline void gfs2_update_stats(struct gfs2_lkstats *s, unsigned index,\n\t\t\t\t     s64 sample)\n{\n\ts64 delta = sample - s->stats[index];\n\ts->stats[index] += (delta >> 3);\n\tindex++;\n\ts->stats[index] += ((abs64(delta) - s->stats[index]) >> 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "gl->gl_sbd->sd_lkstats"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "ktime_sub(gl->gl_dstamp, dstamp)"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "gl->gl_dstamp",
            "dstamp"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get_real",
          "args": [],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/dlm.h>\n#include <linux/fs.h>\n\nstatic inline void gfs2_update_request_times(struct gfs2_glock *gl)\n{\n\tstruct gfs2_pcpu_lkstats *lks;\n\tconst unsigned gltype = gl->gl_name.ln_type;\n\tktime_t dstamp;\n\ts64 irt;\n\n\tpreempt_disable();\n\tdstamp = gl->gl_dstamp;\n\tgl->gl_dstamp = ktime_get_real();\n\tirt = ktime_to_ns(ktime_sub(gl->gl_dstamp, dstamp));\n\tlks = this_cpu_ptr(gl->gl_sbd->sd_lkstats);\n\tgfs2_update_stats(&gl->gl_stats, GFS2_LKS_SIRT, irt);\t\t/* Local */\n\tgfs2_update_stats(&lks->lkstats[gltype], GFS2_LKS_SIRT, irt);\t/* Global */\n\tpreempt_enable();\n}"
  },
  {
    "function_name": "gfs2_update_reply_times",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lock_dlm.c",
    "lines": "73-89",
    "snippet": "static inline void gfs2_update_reply_times(struct gfs2_glock *gl)\n{\n\tstruct gfs2_pcpu_lkstats *lks;\n\tconst unsigned gltype = gl->gl_name.ln_type;\n\tunsigned index = test_bit(GLF_BLOCKING, &gl->gl_flags) ?\n\t\t\t GFS2_LKS_SRTTB : GFS2_LKS_SRTT;\n\ts64 rtt;\n\n\tpreempt_disable();\n\trtt = ktime_to_ns(ktime_sub(ktime_get_real(), gl->gl_dstamp));\n\tlks = this_cpu_ptr(gl->gl_sbd->sd_lkstats);\n\tgfs2_update_stats(&gl->gl_stats, index, rtt);\t\t/* Local */\n\tgfs2_update_stats(&lks->lkstats[gltype], index, rtt);\t/* Global */\n\tpreempt_enable();\n\n\ttrace_gfs2_glock_lock_time(gl, rtt);\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"sys.h\"",
      "#include \"util.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/dlm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_gfs2_glock_lock_time",
          "args": [
            "gl",
            "rtt"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfs2_update_stats",
          "args": [
            "&lks->lkstats[gltype]",
            "index",
            "rtt"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_update_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lock_dlm.c",
          "lines": "47-54",
          "snippet": "static inline void gfs2_update_stats(struct gfs2_lkstats *s, unsigned index,\n\t\t\t\t     s64 sample)\n{\n\ts64 delta = sample - s->stats[index];\n\ts->stats[index] += (delta >> 3);\n\tindex++;\n\ts->stats[index] += ((abs64(delta) - s->stats[index]) >> 2);\n}",
          "includes": [
            "#include \"trace_gfs2.h\"",
            "#include \"sys.h\"",
            "#include \"util.h\"",
            "#include \"glock.h\"",
            "#include \"incore.h\"",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/delay.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/dlm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/dlm.h>\n#include <linux/fs.h>\n\nstatic inline void gfs2_update_stats(struct gfs2_lkstats *s, unsigned index,\n\t\t\t\t     s64 sample)\n{\n\ts64 delta = sample - s->stats[index];\n\ts->stats[index] += (delta >> 3);\n\tindex++;\n\ts->stats[index] += ((abs64(delta) - s->stats[index]) >> 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "gl->gl_sbd->sd_lkstats"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "ktime_sub(ktime_get_real(), gl->gl_dstamp)"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_sub",
          "args": [
            "ktime_get_real()",
            "gl->gl_dstamp"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get_real",
          "args": [],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "GLF_BLOCKING",
            "&gl->gl_flags"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/dlm.h>\n#include <linux/fs.h>\n\nstatic inline void gfs2_update_reply_times(struct gfs2_glock *gl)\n{\n\tstruct gfs2_pcpu_lkstats *lks;\n\tconst unsigned gltype = gl->gl_name.ln_type;\n\tunsigned index = test_bit(GLF_BLOCKING, &gl->gl_flags) ?\n\t\t\t GFS2_LKS_SRTTB : GFS2_LKS_SRTT;\n\ts64 rtt;\n\n\tpreempt_disable();\n\trtt = ktime_to_ns(ktime_sub(ktime_get_real(), gl->gl_dstamp));\n\tlks = this_cpu_ptr(gl->gl_sbd->sd_lkstats);\n\tgfs2_update_stats(&gl->gl_stats, index, rtt);\t\t/* Local */\n\tgfs2_update_stats(&lks->lkstats[gltype], index, rtt);\t/* Global */\n\tpreempt_enable();\n\n\ttrace_gfs2_glock_lock_time(gl, rtt);\n}"
  },
  {
    "function_name": "gfs2_update_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/lock_dlm.c",
    "lines": "47-54",
    "snippet": "static inline void gfs2_update_stats(struct gfs2_lkstats *s, unsigned index,\n\t\t\t\t     s64 sample)\n{\n\ts64 delta = sample - s->stats[index];\n\ts->stats[index] += (delta >> 3);\n\tindex++;\n\ts->stats[index] += ((abs64(delta) - s->stats[index]) >> 2);\n}",
    "includes": [
      "#include \"trace_gfs2.h\"",
      "#include \"sys.h\"",
      "#include \"util.h\"",
      "#include \"glock.h\"",
      "#include \"incore.h\"",
      "#include <linux/gfs2_ondisk.h>",
      "#include <linux/delay.h>",
      "#include <linux/types.h>",
      "#include <linux/slab.h>",
      "#include <linux/dlm.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "abs64",
          "args": [
            "delta"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_gfs2.h\"\n#include \"sys.h\"\n#include \"util.h\"\n#include \"glock.h\"\n#include \"incore.h\"\n#include <linux/gfs2_ondisk.h>\n#include <linux/delay.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/dlm.h>\n#include <linux/fs.h>\n\nstatic inline void gfs2_update_stats(struct gfs2_lkstats *s, unsigned index,\n\t\t\t\t     s64 sample)\n{\n\ts64 delta = sample - s->stats[index];\n\ts->stats[index] += (delta >> 3);\n\tindex++;\n\ts->stats[index] += ((abs64(delta) - s->stats[index]) >> 2);\n}"
  }
]