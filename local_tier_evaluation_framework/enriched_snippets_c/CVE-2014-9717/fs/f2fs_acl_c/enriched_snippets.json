[
  {
    "function_name": "f2fs_init_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/acl.c",
    "lines": "383-406",
    "snippet": "int f2fs_init_acl(struct inode *inode, struct inode *dir, struct page *ipage,\n\t\t\t\t\t\t\tstruct page *dpage)\n{\n\tstruct posix_acl *default_acl = NULL, *acl = NULL;\n\tint error = 0;\n\n\terror = f2fs_acl_create(dir, &inode->i_mode, &default_acl, &acl, dpage);\n\tif (error)\n\t\treturn error;\n\n\tif (default_acl) {\n\t\terror = __f2fs_set_acl(inode, ACL_TYPE_DEFAULT, default_acl,\n\t\t\t\t       ipage);\n\t\tposix_acl_release(default_acl);\n\t}\n\tif (acl) {\n\t\tif (!error)\n\t\t\terror = __f2fs_set_acl(inode, ACL_TYPE_ACCESS, acl,\n\t\t\t\t\t       ipage);\n\t\tposix_acl_release(acl);\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/f2fs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "acl"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__f2fs_set_acl",
          "args": [
            "inode",
            "ACL_TYPE_ACCESS",
            "acl",
            "ipage"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "__f2fs_set_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/acl.c",
          "lines": "204-252",
          "snippet": "static int __f2fs_set_acl(struct inode *inode, int type,\n\t\t\tstruct posix_acl *acl, struct page *ipage)\n{\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tint name_index;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint error;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t\tset_acl_inode(fi, inode->i_mode);\n\t\t\tif (error == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tbreak;\n\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = F2FS_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tvalue = f2fs_acl_to_disk(acl, &size);\n\t\tif (IS_ERR(value)) {\n\t\t\tclear_inode_flag(fi, FI_ACL_MODE);\n\t\t\treturn (int)PTR_ERR(value);\n\t\t}\n\t}\n\n\terror = f2fs_setxattr(inode, name_index, \"\", value, size, ipage, 0);\n\n\tkfree(value);\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\n\tclear_inode_flag(fi, FI_ACL_MODE);\n\treturn error;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n\nstatic int __f2fs_set_acl(struct inode *inode, int type,\n\t\t\tstruct posix_acl *acl, struct page *ipage)\n{\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tint name_index;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint error;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t\tset_acl_inode(fi, inode->i_mode);\n\t\t\tif (error == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tbreak;\n\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = F2FS_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tvalue = f2fs_acl_to_disk(acl, &size);\n\t\tif (IS_ERR(value)) {\n\t\t\tclear_inode_flag(fi, FI_ACL_MODE);\n\t\t\treturn (int)PTR_ERR(value);\n\t\t}\n\t}\n\n\terror = f2fs_setxattr(inode, name_index, \"\", value, size, ipage, 0);\n\n\tkfree(value);\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\n\tclear_inode_flag(fi, FI_ACL_MODE);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "default_acl"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_acl_create",
          "args": [
            "dir",
            "&inode->i_mode",
            "&default_acl",
            "&acl",
            "dpage"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_acl_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/acl.c",
          "lines": "332-381",
          "snippet": "static int f2fs_acl_create(struct inode *dir, umode_t *mode,\n\t\tstruct posix_acl **default_acl, struct posix_acl **acl,\n\t\tstruct page *dpage)\n{\n\tstruct posix_acl *p;\n\tint ret;\n\n\tif (S_ISLNK(*mode) || !IS_POSIXACL(dir))\n\t\tgoto no_acl;\n\n\tp = __f2fs_get_acl(dir, ACL_TYPE_DEFAULT, dpage);\n\tif (IS_ERR(p)) {\n\t\tif (p == ERR_PTR(-EOPNOTSUPP))\n\t\t\tgoto apply_umask;\n\t\treturn PTR_ERR(p);\n\t}\n\n\tif (!p)\n\t\tgoto apply_umask;\n\n\t*acl = f2fs_acl_clone(p, GFP_NOFS);\n\tif (!*acl)\n\t\treturn -ENOMEM;\n\n\tret = f2fs_acl_create_masq(*acl, mode);\n\tif (ret < 0) {\n\t\tposix_acl_release(*acl);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (ret == 0) {\n\t\tposix_acl_release(*acl);\n\t\t*acl = NULL;\n\t}\n\n\tif (!S_ISDIR(*mode)) {\n\t\tposix_acl_release(p);\n\t\t*default_acl = NULL;\n\t} else {\n\t\t*default_acl = p;\n\t}\n\treturn 0;\n\napply_umask:\n\t*mode &= ~current_umask();\nno_acl:\n\t*default_acl = NULL;\n\t*acl = NULL;\n\treturn 0;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n\nstatic int f2fs_acl_create(struct inode *dir, umode_t *mode,\n\t\tstruct posix_acl **default_acl, struct posix_acl **acl,\n\t\tstruct page *dpage)\n{\n\tstruct posix_acl *p;\n\tint ret;\n\n\tif (S_ISLNK(*mode) || !IS_POSIXACL(dir))\n\t\tgoto no_acl;\n\n\tp = __f2fs_get_acl(dir, ACL_TYPE_DEFAULT, dpage);\n\tif (IS_ERR(p)) {\n\t\tif (p == ERR_PTR(-EOPNOTSUPP))\n\t\t\tgoto apply_umask;\n\t\treturn PTR_ERR(p);\n\t}\n\n\tif (!p)\n\t\tgoto apply_umask;\n\n\t*acl = f2fs_acl_clone(p, GFP_NOFS);\n\tif (!*acl)\n\t\treturn -ENOMEM;\n\n\tret = f2fs_acl_create_masq(*acl, mode);\n\tif (ret < 0) {\n\t\tposix_acl_release(*acl);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (ret == 0) {\n\t\tposix_acl_release(*acl);\n\t\t*acl = NULL;\n\t}\n\n\tif (!S_ISDIR(*mode)) {\n\t\tposix_acl_release(p);\n\t\t*default_acl = NULL;\n\t} else {\n\t\t*default_acl = p;\n\t}\n\treturn 0;\n\napply_umask:\n\t*mode &= ~current_umask();\nno_acl:\n\t*default_acl = NULL;\n\t*acl = NULL;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n\nint f2fs_init_acl(struct inode *inode, struct inode *dir, struct page *ipage,\n\t\t\t\t\t\t\tstruct page *dpage)\n{\n\tstruct posix_acl *default_acl = NULL, *acl = NULL;\n\tint error = 0;\n\n\terror = f2fs_acl_create(dir, &inode->i_mode, &default_acl, &acl, dpage);\n\tif (error)\n\t\treturn error;\n\n\tif (default_acl) {\n\t\terror = __f2fs_set_acl(inode, ACL_TYPE_DEFAULT, default_acl,\n\t\t\t\t       ipage);\n\t\tposix_acl_release(default_acl);\n\t}\n\tif (acl) {\n\t\tif (!error)\n\t\t\terror = __f2fs_set_acl(inode, ACL_TYPE_ACCESS, acl,\n\t\t\t\t\t       ipage);\n\t\tposix_acl_release(acl);\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "f2fs_acl_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/acl.c",
    "lines": "332-381",
    "snippet": "static int f2fs_acl_create(struct inode *dir, umode_t *mode,\n\t\tstruct posix_acl **default_acl, struct posix_acl **acl,\n\t\tstruct page *dpage)\n{\n\tstruct posix_acl *p;\n\tint ret;\n\n\tif (S_ISLNK(*mode) || !IS_POSIXACL(dir))\n\t\tgoto no_acl;\n\n\tp = __f2fs_get_acl(dir, ACL_TYPE_DEFAULT, dpage);\n\tif (IS_ERR(p)) {\n\t\tif (p == ERR_PTR(-EOPNOTSUPP))\n\t\t\tgoto apply_umask;\n\t\treturn PTR_ERR(p);\n\t}\n\n\tif (!p)\n\t\tgoto apply_umask;\n\n\t*acl = f2fs_acl_clone(p, GFP_NOFS);\n\tif (!*acl)\n\t\treturn -ENOMEM;\n\n\tret = f2fs_acl_create_masq(*acl, mode);\n\tif (ret < 0) {\n\t\tposix_acl_release(*acl);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (ret == 0) {\n\t\tposix_acl_release(*acl);\n\t\t*acl = NULL;\n\t}\n\n\tif (!S_ISDIR(*mode)) {\n\t\tposix_acl_release(p);\n\t\t*default_acl = NULL;\n\t} else {\n\t\t*default_acl = p;\n\t}\n\treturn 0;\n\napply_umask:\n\t*mode &= ~current_umask();\nno_acl:\n\t*default_acl = NULL;\n\t*acl = NULL;\n\treturn 0;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/f2fs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "current_umask",
          "args": [],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "current_umask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs_struct.c",
          "lines": "154-157",
          "snippet": "int current_umask(void)\n{\n\treturn current->fs->umask;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/fs_struct.h>",
            "#include <linux/slab.h>",
            "#include <linux/path.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/fs_struct.h>\n#include <linux/slab.h>\n#include <linux/path.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n\nint current_umask(void)\n{\n\treturn current->fs->umask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "p"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "*mode"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "*acl"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "*acl"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_acl_create_masq",
          "args": [
            "*acl",
            "mode"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_acl_create_masq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/acl.c",
          "lines": "278-330",
          "snippet": "static int f2fs_acl_create_masq(struct posix_acl *acl, umode_t *mode_p)\n{\n\tstruct posix_acl_entry *pa, *pe;\n\tstruct posix_acl_entry *group_obj = NULL, *mask_obj = NULL;\n\tumode_t mode = *mode_p;\n\tint not_equiv = 0;\n\n\t/* assert(atomic_read(acl->a_refcount) == 1); */\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tswitch(pa->e_tag) {\n\t\tcase ACL_USER_OBJ:\n\t\t\tpa->e_perm &= (mode >> 6) | ~S_IRWXO;\n\t\t\tmode &= (pa->e_perm << 6) | ~S_IRWXU;\n\t\t\tbreak;\n\n\t\tcase ACL_USER:\n\t\tcase ACL_GROUP:\n\t\t\tnot_equiv = 1;\n\t\t\tbreak;\n\n\t\tcase ACL_GROUP_OBJ:\n\t\t\tgroup_obj = pa;\n\t\t\tbreak;\n\n\t\tcase ACL_OTHER:\n\t\t\tpa->e_perm &= mode | ~S_IRWXO;\n\t\t\tmode &= pa->e_perm | ~S_IRWXO;\n\t\t\tbreak;\n\n\t\tcase ACL_MASK:\n\t\t\tmask_obj = pa;\n\t\t\tnot_equiv = 1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tif (mask_obj) {\n\t\tmask_obj->e_perm &= (mode >> 3) | ~S_IRWXO;\n\t\tmode &= (mask_obj->e_perm << 3) | ~S_IRWXG;\n\t} else {\n\t\tif (!group_obj)\n\t\t\treturn -EIO;\n\t\tgroup_obj->e_perm &= (mode >> 3) | ~S_IRWXO;\n\t\tmode &= (group_obj->e_perm << 3) | ~S_IRWXG;\n\t}\n\n\t*mode_p = (*mode_p & ~S_IRWXUGO) | mode;\n        return not_equiv;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n\nstatic int f2fs_acl_create_masq(struct posix_acl *acl, umode_t *mode_p)\n{\n\tstruct posix_acl_entry *pa, *pe;\n\tstruct posix_acl_entry *group_obj = NULL, *mask_obj = NULL;\n\tumode_t mode = *mode_p;\n\tint not_equiv = 0;\n\n\t/* assert(atomic_read(acl->a_refcount) == 1); */\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tswitch(pa->e_tag) {\n\t\tcase ACL_USER_OBJ:\n\t\t\tpa->e_perm &= (mode >> 6) | ~S_IRWXO;\n\t\t\tmode &= (pa->e_perm << 6) | ~S_IRWXU;\n\t\t\tbreak;\n\n\t\tcase ACL_USER:\n\t\tcase ACL_GROUP:\n\t\t\tnot_equiv = 1;\n\t\t\tbreak;\n\n\t\tcase ACL_GROUP_OBJ:\n\t\t\tgroup_obj = pa;\n\t\t\tbreak;\n\n\t\tcase ACL_OTHER:\n\t\t\tpa->e_perm &= mode | ~S_IRWXO;\n\t\t\tmode &= pa->e_perm | ~S_IRWXO;\n\t\t\tbreak;\n\n\t\tcase ACL_MASK:\n\t\t\tmask_obj = pa;\n\t\t\tnot_equiv = 1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tif (mask_obj) {\n\t\tmask_obj->e_perm &= (mode >> 3) | ~S_IRWXO;\n\t\tmode &= (mask_obj->e_perm << 3) | ~S_IRWXG;\n\t} else {\n\t\tif (!group_obj)\n\t\t\treturn -EIO;\n\t\tgroup_obj->e_perm &= (mode >> 3) | ~S_IRWXO;\n\t\tmode &= (group_obj->e_perm << 3) | ~S_IRWXG;\n\t}\n\n\t*mode_p = (*mode_p & ~S_IRWXUGO) | mode;\n        return not_equiv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_acl_clone",
          "args": [
            "p",
            "GFP_NOFS"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_acl_clone",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/acl.c",
          "lines": "263-276",
          "snippet": "static struct posix_acl *f2fs_acl_clone(const struct posix_acl *acl,\n\t\t\t\t\t\t\tgfp_t flags)\n{\n\tstruct posix_acl *clone = NULL;\n\n\tif (acl) {\n\t\tint size = sizeof(struct posix_acl) + acl->a_count *\n\t\t\t\tsizeof(struct posix_acl_entry);\n\t\tclone = kmemdup(acl, size, flags);\n\t\tif (clone)\n\t\t\tatomic_set(&clone->a_refcount, 1);\n\t}\n\treturn clone;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n\nstatic struct posix_acl *f2fs_acl_clone(const struct posix_acl *acl,\n\t\t\t\t\t\t\tgfp_t flags)\n{\n\tstruct posix_acl *clone = NULL;\n\n\tif (acl) {\n\t\tint size = sizeof(struct posix_acl) + acl->a_count *\n\t\t\t\tsizeof(struct posix_acl_entry);\n\t\tclone = kmemdup(acl, size, flags);\n\t\tif (clone)\n\t\t\tatomic_set(&clone->a_refcount, 1);\n\t}\n\treturn clone;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "p"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EOPNOTSUPP"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "p"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__f2fs_get_acl",
          "args": [
            "dir",
            "ACL_TYPE_DEFAULT",
            "dpage"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "__f2fs_get_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/acl.c",
          "lines": "165-197",
          "snippet": "static struct posix_acl *__f2fs_get_acl(struct inode *inode, int type,\n\t\t\t\t\t\tstruct page *dpage)\n{\n\tint name_index = F2FS_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\tvoid *value = NULL;\n\tstruct posix_acl *acl;\n\tint retval;\n\n\tif (type == ACL_TYPE_ACCESS)\n\t\tname_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS;\n\n\tretval = f2fs_getxattr(inode, name_index, \"\", NULL, 0, dpage);\n\tif (retval > 0) {\n\t\tvalue = kmalloc(retval, GFP_F2FS_ZERO);\n\t\tif (!value)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tretval = f2fs_getxattr(inode, name_index, \"\", value,\n\t\t\t\t\t\t\tretval, dpage);\n\t}\n\n\tif (retval > 0)\n\t\tacl = f2fs_acl_from_disk(value, retval);\n\telse if (retval == -ENODATA)\n\t\tacl = NULL;\n\telse\n\t\tacl = ERR_PTR(retval);\n\tkfree(value);\n\n\tif (!IS_ERR(acl))\n\t\tset_cached_acl(inode, type, acl);\n\n\treturn acl;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n\nstatic struct posix_acl *__f2fs_get_acl(struct inode *inode, int type,\n\t\t\t\t\t\tstruct page *dpage)\n{\n\tint name_index = F2FS_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\tvoid *value = NULL;\n\tstruct posix_acl *acl;\n\tint retval;\n\n\tif (type == ACL_TYPE_ACCESS)\n\t\tname_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS;\n\n\tretval = f2fs_getxattr(inode, name_index, \"\", NULL, 0, dpage);\n\tif (retval > 0) {\n\t\tvalue = kmalloc(retval, GFP_F2FS_ZERO);\n\t\tif (!value)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tretval = f2fs_getxattr(inode, name_index, \"\", value,\n\t\t\t\t\t\t\tretval, dpage);\n\t}\n\n\tif (retval > 0)\n\t\tacl = f2fs_acl_from_disk(value, retval);\n\telse if (retval == -ENODATA)\n\t\tacl = NULL;\n\telse\n\t\tacl = ERR_PTR(retval);\n\tkfree(value);\n\n\tif (!IS_ERR(acl))\n\t\tset_cached_acl(inode, type, acl);\n\n\treturn acl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_POSIXACL",
          "args": [
            "dir"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "*mode"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n\nstatic int f2fs_acl_create(struct inode *dir, umode_t *mode,\n\t\tstruct posix_acl **default_acl, struct posix_acl **acl,\n\t\tstruct page *dpage)\n{\n\tstruct posix_acl *p;\n\tint ret;\n\n\tif (S_ISLNK(*mode) || !IS_POSIXACL(dir))\n\t\tgoto no_acl;\n\n\tp = __f2fs_get_acl(dir, ACL_TYPE_DEFAULT, dpage);\n\tif (IS_ERR(p)) {\n\t\tif (p == ERR_PTR(-EOPNOTSUPP))\n\t\t\tgoto apply_umask;\n\t\treturn PTR_ERR(p);\n\t}\n\n\tif (!p)\n\t\tgoto apply_umask;\n\n\t*acl = f2fs_acl_clone(p, GFP_NOFS);\n\tif (!*acl)\n\t\treturn -ENOMEM;\n\n\tret = f2fs_acl_create_masq(*acl, mode);\n\tif (ret < 0) {\n\t\tposix_acl_release(*acl);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (ret == 0) {\n\t\tposix_acl_release(*acl);\n\t\t*acl = NULL;\n\t}\n\n\tif (!S_ISDIR(*mode)) {\n\t\tposix_acl_release(p);\n\t\t*default_acl = NULL;\n\t} else {\n\t\t*default_acl = p;\n\t}\n\treturn 0;\n\napply_umask:\n\t*mode &= ~current_umask();\nno_acl:\n\t*default_acl = NULL;\n\t*acl = NULL;\n\treturn 0;\n}"
  },
  {
    "function_name": "f2fs_acl_create_masq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/acl.c",
    "lines": "278-330",
    "snippet": "static int f2fs_acl_create_masq(struct posix_acl *acl, umode_t *mode_p)\n{\n\tstruct posix_acl_entry *pa, *pe;\n\tstruct posix_acl_entry *group_obj = NULL, *mask_obj = NULL;\n\tumode_t mode = *mode_p;\n\tint not_equiv = 0;\n\n\t/* assert(atomic_read(acl->a_refcount) == 1); */\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tswitch(pa->e_tag) {\n\t\tcase ACL_USER_OBJ:\n\t\t\tpa->e_perm &= (mode >> 6) | ~S_IRWXO;\n\t\t\tmode &= (pa->e_perm << 6) | ~S_IRWXU;\n\t\t\tbreak;\n\n\t\tcase ACL_USER:\n\t\tcase ACL_GROUP:\n\t\t\tnot_equiv = 1;\n\t\t\tbreak;\n\n\t\tcase ACL_GROUP_OBJ:\n\t\t\tgroup_obj = pa;\n\t\t\tbreak;\n\n\t\tcase ACL_OTHER:\n\t\t\tpa->e_perm &= mode | ~S_IRWXO;\n\t\t\tmode &= pa->e_perm | ~S_IRWXO;\n\t\t\tbreak;\n\n\t\tcase ACL_MASK:\n\t\t\tmask_obj = pa;\n\t\t\tnot_equiv = 1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tif (mask_obj) {\n\t\tmask_obj->e_perm &= (mode >> 3) | ~S_IRWXO;\n\t\tmode &= (mask_obj->e_perm << 3) | ~S_IRWXG;\n\t} else {\n\t\tif (!group_obj)\n\t\t\treturn -EIO;\n\t\tgroup_obj->e_perm &= (mode >> 3) | ~S_IRWXO;\n\t\tmode &= (group_obj->e_perm << 3) | ~S_IRWXG;\n\t}\n\n\t*mode_p = (*mode_p & ~S_IRWXUGO) | mode;\n        return not_equiv;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/f2fs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "FOREACH_ACL_ENTRY",
          "args": [
            "pa",
            "acl",
            "pe"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n\nstatic int f2fs_acl_create_masq(struct posix_acl *acl, umode_t *mode_p)\n{\n\tstruct posix_acl_entry *pa, *pe;\n\tstruct posix_acl_entry *group_obj = NULL, *mask_obj = NULL;\n\tumode_t mode = *mode_p;\n\tint not_equiv = 0;\n\n\t/* assert(atomic_read(acl->a_refcount) == 1); */\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tswitch(pa->e_tag) {\n\t\tcase ACL_USER_OBJ:\n\t\t\tpa->e_perm &= (mode >> 6) | ~S_IRWXO;\n\t\t\tmode &= (pa->e_perm << 6) | ~S_IRWXU;\n\t\t\tbreak;\n\n\t\tcase ACL_USER:\n\t\tcase ACL_GROUP:\n\t\t\tnot_equiv = 1;\n\t\t\tbreak;\n\n\t\tcase ACL_GROUP_OBJ:\n\t\t\tgroup_obj = pa;\n\t\t\tbreak;\n\n\t\tcase ACL_OTHER:\n\t\t\tpa->e_perm &= mode | ~S_IRWXO;\n\t\t\tmode &= pa->e_perm | ~S_IRWXO;\n\t\t\tbreak;\n\n\t\tcase ACL_MASK:\n\t\t\tmask_obj = pa;\n\t\t\tnot_equiv = 1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tif (mask_obj) {\n\t\tmask_obj->e_perm &= (mode >> 3) | ~S_IRWXO;\n\t\tmode &= (mask_obj->e_perm << 3) | ~S_IRWXG;\n\t} else {\n\t\tif (!group_obj)\n\t\t\treturn -EIO;\n\t\tgroup_obj->e_perm &= (mode >> 3) | ~S_IRWXO;\n\t\tmode &= (group_obj->e_perm << 3) | ~S_IRWXG;\n\t}\n\n\t*mode_p = (*mode_p & ~S_IRWXUGO) | mode;\n        return not_equiv;\n}"
  },
  {
    "function_name": "f2fs_acl_clone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/acl.c",
    "lines": "263-276",
    "snippet": "static struct posix_acl *f2fs_acl_clone(const struct posix_acl *acl,\n\t\t\t\t\t\t\tgfp_t flags)\n{\n\tstruct posix_acl *clone = NULL;\n\n\tif (acl) {\n\t\tint size = sizeof(struct posix_acl) + acl->a_count *\n\t\t\t\tsizeof(struct posix_acl_entry);\n\t\tclone = kmemdup(acl, size, flags);\n\t\tif (clone)\n\t\t\tatomic_set(&clone->a_refcount, 1);\n\t}\n\treturn clone;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/f2fs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&clone->a_refcount",
            "1"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmemdup",
          "args": [
            "acl",
            "size",
            "flags"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n\nstatic struct posix_acl *f2fs_acl_clone(const struct posix_acl *acl,\n\t\t\t\t\t\t\tgfp_t flags)\n{\n\tstruct posix_acl *clone = NULL;\n\n\tif (acl) {\n\t\tint size = sizeof(struct posix_acl) + acl->a_count *\n\t\t\t\tsizeof(struct posix_acl_entry);\n\t\tclone = kmemdup(acl, size, flags);\n\t\tif (clone)\n\t\t\tatomic_set(&clone->a_refcount, 1);\n\t}\n\treturn clone;\n}"
  },
  {
    "function_name": "f2fs_set_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/acl.c",
    "lines": "254-257",
    "snippet": "int f2fs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\treturn __f2fs_set_acl(inode, type, acl, NULL);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/f2fs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__f2fs_set_acl",
          "args": [
            "inode",
            "type",
            "acl",
            "NULL"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "__f2fs_set_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/acl.c",
          "lines": "204-252",
          "snippet": "static int __f2fs_set_acl(struct inode *inode, int type,\n\t\t\tstruct posix_acl *acl, struct page *ipage)\n{\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tint name_index;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint error;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t\tset_acl_inode(fi, inode->i_mode);\n\t\t\tif (error == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tbreak;\n\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = F2FS_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tvalue = f2fs_acl_to_disk(acl, &size);\n\t\tif (IS_ERR(value)) {\n\t\t\tclear_inode_flag(fi, FI_ACL_MODE);\n\t\t\treturn (int)PTR_ERR(value);\n\t\t}\n\t}\n\n\terror = f2fs_setxattr(inode, name_index, \"\", value, size, ipage, 0);\n\n\tkfree(value);\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\n\tclear_inode_flag(fi, FI_ACL_MODE);\n\treturn error;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n\nstatic int __f2fs_set_acl(struct inode *inode, int type,\n\t\t\tstruct posix_acl *acl, struct page *ipage)\n{\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tint name_index;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint error;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t\tset_acl_inode(fi, inode->i_mode);\n\t\t\tif (error == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tbreak;\n\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = F2FS_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tvalue = f2fs_acl_to_disk(acl, &size);\n\t\tif (IS_ERR(value)) {\n\t\t\tclear_inode_flag(fi, FI_ACL_MODE);\n\t\t\treturn (int)PTR_ERR(value);\n\t\t}\n\t}\n\n\terror = f2fs_setxattr(inode, name_index, \"\", value, size, ipage, 0);\n\n\tkfree(value);\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\n\tclear_inode_flag(fi, FI_ACL_MODE);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n\nint f2fs_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n\treturn __f2fs_set_acl(inode, type, acl, NULL);\n}"
  },
  {
    "function_name": "__f2fs_set_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/acl.c",
    "lines": "204-252",
    "snippet": "static int __f2fs_set_acl(struct inode *inode, int type,\n\t\t\tstruct posix_acl *acl, struct page *ipage)\n{\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tint name_index;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint error;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t\tset_acl_inode(fi, inode->i_mode);\n\t\t\tif (error == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tbreak;\n\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = F2FS_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tvalue = f2fs_acl_to_disk(acl, &size);\n\t\tif (IS_ERR(value)) {\n\t\t\tclear_inode_flag(fi, FI_ACL_MODE);\n\t\t\treturn (int)PTR_ERR(value);\n\t\t}\n\t}\n\n\terror = f2fs_setxattr(inode, name_index, \"\", value, size, ipage, 0);\n\n\tkfree(value);\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\n\tclear_inode_flag(fi, FI_ACL_MODE);\n\treturn error;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/f2fs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_inode_flag",
          "args": [
            "fi",
            "FI_ACL_MODE"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "clear_inode_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1184-1188",
          "snippet": "static inline void clear_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (test_bit(flag, &fi->flags))\n\t\tclear_bit(flag, &fi->flags);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void clear_inode_flag(struct f2fs_inode_info *fi, int flag)\n{\n\tif (test_bit(flag, &fi->flags))\n\t\tclear_bit(flag, &fi->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_cached_acl",
          "args": [
            "inode",
            "type",
            "acl"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_set_cached_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/acl.c",
          "lines": "32-41",
          "snippet": "static inline void ceph_set_cached_acl(struct inode *inode,\n\t\t\t\t\tint type, struct posix_acl *acl)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (__ceph_caps_issued_mask(ci, CEPH_CAP_XATTR_SHARED, 0))\n\t\tset_cached_acl(inode, type, acl);\n\tspin_unlock(&ci->i_ceph_lock);\n}",
          "includes": [
            "#include \"super.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/posix_acl.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline void ceph_set_cached_acl(struct inode *inode,\n\t\t\t\t\tint type, struct posix_acl *acl)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (__ceph_caps_issued_mask(ci, CEPH_CAP_XATTR_SHARED, 0))\n\t\tset_cached_acl(inode, type, acl);\n\tspin_unlock(&ci->i_ceph_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "value"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_setxattr",
          "args": [
            "inode",
            "name_index",
            "\"\"",
            "value",
            "size",
            "ipage",
            "0"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_setxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/xattr.c",
          "lines": "595-616",
          "snippet": "int f2fs_setxattr(struct inode *inode, int index, const char *name,\n\t\t\t\tconst void *value, size_t size,\n\t\t\t\tstruct page *ipage, int flags)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tint err;\n\n\t/* this case is only from init_inode_metadata */\n\tif (ipage)\n\t\treturn __f2fs_setxattr(inode, index, name, value,\n\t\t\t\t\t\tsize, ipage, flags);\n\tf2fs_balance_fs(sbi);\n\n\tf2fs_lock_op(sbi);\n\t/* protect xattr_ver */\n\tdown_write(&F2FS_I(inode)->i_sem);\n\terr = __f2fs_setxattr(inode, index, name, value, size, ipage, flags);\n\tup_write(&F2FS_I(inode)->i_sem);\n\tf2fs_unlock_op(sbi);\n\n\treturn err;\n}",
          "includes": [
            "#include \"xattr.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/f2fs_fs.h>",
            "#include <linux/rwsem.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xattr.h\"\n#include \"f2fs.h\"\n#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/f2fs_fs.h>\n#include <linux/rwsem.h>\n\nint f2fs_setxattr(struct inode *inode, int index, const char *name,\n\t\t\t\tconst void *value, size_t size,\n\t\t\t\tstruct page *ipage, int flags)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tint err;\n\n\t/* this case is only from init_inode_metadata */\n\tif (ipage)\n\t\treturn __f2fs_setxattr(inode, index, name, value,\n\t\t\t\t\t\tsize, ipage, flags);\n\tf2fs_balance_fs(sbi);\n\n\tf2fs_lock_op(sbi);\n\t/* protect xattr_ver */\n\tdown_write(&F2FS_I(inode)->i_sem);\n\terr = __f2fs_setxattr(inode, index, name, value, size, ipage, flags);\n\tup_write(&F2FS_I(inode)->i_sem);\n\tf2fs_unlock_op(sbi);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "value"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "value"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_acl_to_disk",
          "args": [
            "acl",
            "&size"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_acl_to_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/acl.c",
          "lines": "112-163",
          "snippet": "static void *f2fs_acl_to_disk(const struct posix_acl *acl, size_t *size)\n{\n\tstruct f2fs_acl_header *f2fs_acl;\n\tstruct f2fs_acl_entry *entry;\n\tint i;\n\n\tf2fs_acl = kmalloc(sizeof(struct f2fs_acl_header) + acl->a_count *\n\t\t\tsizeof(struct f2fs_acl_entry), GFP_NOFS);\n\tif (!f2fs_acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tf2fs_acl->a_version = cpu_to_le32(F2FS_ACL_VERSION);\n\tentry = (struct f2fs_acl_entry *)(f2fs_acl + 1);\n\n\tfor (i = 0; i < acl->a_count; i++) {\n\n\t\tentry->e_tag  = cpu_to_le16(acl->a_entries[i].e_tag);\n\t\tentry->e_perm = cpu_to_le16(acl->a_entries[i].e_perm);\n\n\t\tswitch (acl->a_entries[i].e_tag) {\n\t\tcase ACL_USER:\n\t\t\tentry->e_id = cpu_to_le32(\n\t\t\t\t\tfrom_kuid(&init_user_ns,\n\t\t\t\t\t\tacl->a_entries[i].e_uid));\n\t\t\tentry = (struct f2fs_acl_entry *)((char *)entry +\n\t\t\t\t\tsizeof(struct f2fs_acl_entry));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tentry->e_id = cpu_to_le32(\n\t\t\t\t\tfrom_kgid(&init_user_ns,\n\t\t\t\t\t\tacl->a_entries[i].e_gid));\n\t\t\tentry = (struct f2fs_acl_entry *)((char *)entry +\n\t\t\t\t\tsizeof(struct f2fs_acl_entry));\n\t\t\tbreak;\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\tentry = (struct f2fs_acl_entry *)((char *)entry +\n\t\t\t\t\tsizeof(struct f2fs_acl_entry_short));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\t*size = f2fs_acl_size(acl->a_count);\n\treturn (void *)f2fs_acl;\n\nfail:\n\tkfree(f2fs_acl);\n\treturn ERR_PTR(-EINVAL);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n\nstatic void *f2fs_acl_to_disk(const struct posix_acl *acl, size_t *size)\n{\n\tstruct f2fs_acl_header *f2fs_acl;\n\tstruct f2fs_acl_entry *entry;\n\tint i;\n\n\tf2fs_acl = kmalloc(sizeof(struct f2fs_acl_header) + acl->a_count *\n\t\t\tsizeof(struct f2fs_acl_entry), GFP_NOFS);\n\tif (!f2fs_acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tf2fs_acl->a_version = cpu_to_le32(F2FS_ACL_VERSION);\n\tentry = (struct f2fs_acl_entry *)(f2fs_acl + 1);\n\n\tfor (i = 0; i < acl->a_count; i++) {\n\n\t\tentry->e_tag  = cpu_to_le16(acl->a_entries[i].e_tag);\n\t\tentry->e_perm = cpu_to_le16(acl->a_entries[i].e_perm);\n\n\t\tswitch (acl->a_entries[i].e_tag) {\n\t\tcase ACL_USER:\n\t\t\tentry->e_id = cpu_to_le32(\n\t\t\t\t\tfrom_kuid(&init_user_ns,\n\t\t\t\t\t\tacl->a_entries[i].e_uid));\n\t\t\tentry = (struct f2fs_acl_entry *)((char *)entry +\n\t\t\t\t\tsizeof(struct f2fs_acl_entry));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tentry->e_id = cpu_to_le32(\n\t\t\t\t\tfrom_kgid(&init_user_ns,\n\t\t\t\t\t\tacl->a_entries[i].e_gid));\n\t\t\tentry = (struct f2fs_acl_entry *)((char *)entry +\n\t\t\t\t\tsizeof(struct f2fs_acl_entry));\n\t\t\tbreak;\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\tentry = (struct f2fs_acl_entry *)((char *)entry +\n\t\t\t\t\tsizeof(struct f2fs_acl_entry_short));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\t*size = f2fs_acl_size(acl->a_count);\n\treturn (void *)f2fs_acl;\n\nfail:\n\tkfree(f2fs_acl);\n\treturn ERR_PTR(-EINVAL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_acl_inode",
          "args": [
            "fi",
            "inode->i_mode"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "set_acl_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1190-1194",
          "snippet": "static inline void set_acl_inode(struct f2fs_inode_info *fi, umode_t mode)\n{\n\tfi->i_acl_mode = mode;\n\tset_inode_flag(fi, FI_ACL_MODE);\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void set_acl_inode(struct f2fs_inode_info *fi, umode_t mode)\n{\n\tfi->i_acl_mode = mode;\n\tset_inode_flag(fi, FI_ACL_MODE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_acl_equiv_mode",
          "args": [
            "acl",
            "&inode->i_mode"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_equiv_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "242-282",
          "snippet": "int\nposix_acl_equiv_mode(const struct posix_acl *acl, umode_t *mode_p)\n{\n\tconst struct posix_acl_entry *pa, *pe;\n\tumode_t mode = 0;\n\tint not_equiv = 0;\n\n\t/*\n\t * A null ACL can always be presented as mode bits.\n\t */\n\tif (!acl)\n\t\treturn 0;\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tswitch (pa->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\t\tmode |= (pa->e_perm & S_IRWXO) << 6;\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\t\tmode |= (pa->e_perm & S_IRWXO) << 3;\n\t\t\t\tbreak;\n\t\t\tcase ACL_OTHER:\n\t\t\t\tmode |= pa->e_perm & S_IRWXO;\n\t\t\t\tbreak;\n\t\t\tcase ACL_MASK:\n\t\t\t\tmode = (mode & ~S_IRWXG) |\n\t\t\t\t       ((pa->e_perm & S_IRWXO) << 3);\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\t\t\tcase ACL_USER:\n\t\t\tcase ACL_GROUP:\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n        if (mode_p)\n                *mode_p = (*mode_p & ~S_IRWXUGO) | mode;\n        return not_equiv;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint\nposix_acl_equiv_mode(const struct posix_acl *acl, umode_t *mode_p)\n{\n\tconst struct posix_acl_entry *pa, *pe;\n\tumode_t mode = 0;\n\tint not_equiv = 0;\n\n\t/*\n\t * A null ACL can always be presented as mode bits.\n\t */\n\tif (!acl)\n\t\treturn 0;\n\n\tFOREACH_ACL_ENTRY(pa, acl, pe) {\n\t\tswitch (pa->e_tag) {\n\t\t\tcase ACL_USER_OBJ:\n\t\t\t\tmode |= (pa->e_perm & S_IRWXO) << 6;\n\t\t\t\tbreak;\n\t\t\tcase ACL_GROUP_OBJ:\n\t\t\t\tmode |= (pa->e_perm & S_IRWXO) << 3;\n\t\t\t\tbreak;\n\t\t\tcase ACL_OTHER:\n\t\t\t\tmode |= pa->e_perm & S_IRWXO;\n\t\t\t\tbreak;\n\t\t\tcase ACL_MASK:\n\t\t\t\tmode = (mode & ~S_IRWXG) |\n\t\t\t\t       ((pa->e_perm & S_IRWXO) << 3);\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\t\t\tcase ACL_USER:\n\t\t\tcase ACL_GROUP:\n\t\t\t\tnot_equiv = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n        if (mode_p)\n                *mode_p = (*mode_p & ~S_IRWXUGO) | mode;\n        return not_equiv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "F2FS_I",
          "args": [
            "inode"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "F2FS_INODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "675-678",
          "snippet": "static inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline struct f2fs_inode *F2FS_INODE(struct page *page)\n{\n\treturn &((struct f2fs_node *)page_address(page))->i;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n\nstatic int __f2fs_set_acl(struct inode *inode, int type,\n\t\t\tstruct posix_acl *acl, struct page *ipage)\n{\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tint name_index;\n\tvoid *value = NULL;\n\tsize_t size = 0;\n\tint error;\n\n\tswitch (type) {\n\tcase ACL_TYPE_ACCESS:\n\t\tname_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS;\n\t\tif (acl) {\n\t\t\terror = posix_acl_equiv_mode(acl, &inode->i_mode);\n\t\t\tif (error < 0)\n\t\t\t\treturn error;\n\t\t\tset_acl_inode(fi, inode->i_mode);\n\t\t\tif (error == 0)\n\t\t\t\tacl = NULL;\n\t\t}\n\t\tbreak;\n\n\tcase ACL_TYPE_DEFAULT:\n\t\tname_index = F2FS_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\t\tif (!S_ISDIR(inode->i_mode))\n\t\t\treturn acl ? -EACCES : 0;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (acl) {\n\t\tvalue = f2fs_acl_to_disk(acl, &size);\n\t\tif (IS_ERR(value)) {\n\t\t\tclear_inode_flag(fi, FI_ACL_MODE);\n\t\t\treturn (int)PTR_ERR(value);\n\t\t}\n\t}\n\n\terror = f2fs_setxattr(inode, name_index, \"\", value, size, ipage, 0);\n\n\tkfree(value);\n\tif (!error)\n\t\tset_cached_acl(inode, type, acl);\n\n\tclear_inode_flag(fi, FI_ACL_MODE);\n\treturn error;\n}"
  },
  {
    "function_name": "f2fs_get_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/acl.c",
    "lines": "199-202",
    "snippet": "struct posix_acl *f2fs_get_acl(struct inode *inode, int type)\n{\n\treturn __f2fs_get_acl(inode, type, NULL);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/f2fs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__f2fs_get_acl",
          "args": [
            "inode",
            "type",
            "NULL"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "__f2fs_get_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/acl.c",
          "lines": "165-197",
          "snippet": "static struct posix_acl *__f2fs_get_acl(struct inode *inode, int type,\n\t\t\t\t\t\tstruct page *dpage)\n{\n\tint name_index = F2FS_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\tvoid *value = NULL;\n\tstruct posix_acl *acl;\n\tint retval;\n\n\tif (type == ACL_TYPE_ACCESS)\n\t\tname_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS;\n\n\tretval = f2fs_getxattr(inode, name_index, \"\", NULL, 0, dpage);\n\tif (retval > 0) {\n\t\tvalue = kmalloc(retval, GFP_F2FS_ZERO);\n\t\tif (!value)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tretval = f2fs_getxattr(inode, name_index, \"\", value,\n\t\t\t\t\t\t\tretval, dpage);\n\t}\n\n\tif (retval > 0)\n\t\tacl = f2fs_acl_from_disk(value, retval);\n\telse if (retval == -ENODATA)\n\t\tacl = NULL;\n\telse\n\t\tacl = ERR_PTR(retval);\n\tkfree(value);\n\n\tif (!IS_ERR(acl))\n\t\tset_cached_acl(inode, type, acl);\n\n\treturn acl;\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n\nstatic struct posix_acl *__f2fs_get_acl(struct inode *inode, int type,\n\t\t\t\t\t\tstruct page *dpage)\n{\n\tint name_index = F2FS_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\tvoid *value = NULL;\n\tstruct posix_acl *acl;\n\tint retval;\n\n\tif (type == ACL_TYPE_ACCESS)\n\t\tname_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS;\n\n\tretval = f2fs_getxattr(inode, name_index, \"\", NULL, 0, dpage);\n\tif (retval > 0) {\n\t\tvalue = kmalloc(retval, GFP_F2FS_ZERO);\n\t\tif (!value)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tretval = f2fs_getxattr(inode, name_index, \"\", value,\n\t\t\t\t\t\t\tretval, dpage);\n\t}\n\n\tif (retval > 0)\n\t\tacl = f2fs_acl_from_disk(value, retval);\n\telse if (retval == -ENODATA)\n\t\tacl = NULL;\n\telse\n\t\tacl = ERR_PTR(retval);\n\tkfree(value);\n\n\tif (!IS_ERR(acl))\n\t\tset_cached_acl(inode, type, acl);\n\n\treturn acl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n\nstruct posix_acl *f2fs_get_acl(struct inode *inode, int type)\n{\n\treturn __f2fs_get_acl(inode, type, NULL);\n}"
  },
  {
    "function_name": "__f2fs_get_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/acl.c",
    "lines": "165-197",
    "snippet": "static struct posix_acl *__f2fs_get_acl(struct inode *inode, int type,\n\t\t\t\t\t\tstruct page *dpage)\n{\n\tint name_index = F2FS_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\tvoid *value = NULL;\n\tstruct posix_acl *acl;\n\tint retval;\n\n\tif (type == ACL_TYPE_ACCESS)\n\t\tname_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS;\n\n\tretval = f2fs_getxattr(inode, name_index, \"\", NULL, 0, dpage);\n\tif (retval > 0) {\n\t\tvalue = kmalloc(retval, GFP_F2FS_ZERO);\n\t\tif (!value)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tretval = f2fs_getxattr(inode, name_index, \"\", value,\n\t\t\t\t\t\t\tretval, dpage);\n\t}\n\n\tif (retval > 0)\n\t\tacl = f2fs_acl_from_disk(value, retval);\n\telse if (retval == -ENODATA)\n\t\tacl = NULL;\n\telse\n\t\tacl = ERR_PTR(retval);\n\tkfree(value);\n\n\tif (!IS_ERR(acl))\n\t\tset_cached_acl(inode, type, acl);\n\n\treturn acl;\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/f2fs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_cached_acl",
          "args": [
            "inode",
            "type",
            "acl"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "ceph_set_cached_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ceph/acl.c",
          "lines": "32-41",
          "snippet": "static inline void ceph_set_cached_acl(struct inode *inode,\n\t\t\t\t\tint type, struct posix_acl *acl)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (__ceph_caps_issued_mask(ci, CEPH_CAP_XATTR_SHARED, 0))\n\t\tset_cached_acl(inode, type, acl);\n\tspin_unlock(&ci->i_ceph_lock);\n}",
          "includes": [
            "#include \"super.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/xattr.h>",
            "#include <linux/string.h>",
            "#include <linux/fs.h>",
            "#include <linux/ceph/ceph_debug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"super.h\"\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/posix_acl.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/xattr.h>\n#include <linux/string.h>\n#include <linux/fs.h>\n#include <linux/ceph/ceph_debug.h>\n\nstatic inline void ceph_set_cached_acl(struct inode *inode,\n\t\t\t\t\tint type, struct posix_acl *acl)\n{\n\tstruct ceph_inode_info *ci = ceph_inode(inode);\n\n\tspin_lock(&ci->i_ceph_lock);\n\tif (__ceph_caps_issued_mask(ci, CEPH_CAP_XATTR_SHARED, 0))\n\t\tset_cached_acl(inode, type, acl);\n\tspin_unlock(&ci->i_ceph_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "acl"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "value"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "retval"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_acl_from_disk",
          "args": [
            "value",
            "retval"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_acl_from_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/acl.c",
          "lines": "48-110",
          "snippet": "static struct posix_acl *f2fs_acl_from_disk(const char *value, size_t size)\n{\n\tint i, count;\n\tstruct posix_acl *acl;\n\tstruct f2fs_acl_header *hdr = (struct f2fs_acl_header *)value;\n\tstruct f2fs_acl_entry *entry = (struct f2fs_acl_entry *)(hdr + 1);\n\tconst char *end = value + size;\n\n\tif (hdr->a_version != cpu_to_le32(F2FS_ACL_VERSION))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tcount = f2fs_acl_count(size);\n\tif (count < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (count == 0)\n\t\treturn NULL;\n\n\tacl = posix_acl_alloc(count, GFP_NOFS);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (i = 0; i < count; i++) {\n\n\t\tif ((char *)entry > end)\n\t\t\tgoto fail;\n\n\t\tacl->a_entries[i].e_tag  = le16_to_cpu(entry->e_tag);\n\t\tacl->a_entries[i].e_perm = le16_to_cpu(entry->e_perm);\n\n\t\tswitch (acl->a_entries[i].e_tag) {\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\tentry = (struct f2fs_acl_entry *)((char *)entry +\n\t\t\t\t\tsizeof(struct f2fs_acl_entry_short));\n\t\t\tbreak;\n\n\t\tcase ACL_USER:\n\t\t\tacl->a_entries[i].e_uid =\n\t\t\t\tmake_kuid(&init_user_ns,\n\t\t\t\t\t\tle32_to_cpu(entry->e_id));\n\t\t\tentry = (struct f2fs_acl_entry *)((char *)entry +\n\t\t\t\t\tsizeof(struct f2fs_acl_entry));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tacl->a_entries[i].e_gid =\n\t\t\t\tmake_kgid(&init_user_ns,\n\t\t\t\t\t\tle32_to_cpu(entry->e_id));\n\t\t\tentry = (struct f2fs_acl_entry *)((char *)entry +\n\t\t\t\t\tsizeof(struct f2fs_acl_entry));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tif ((char *)entry != end)\n\t\tgoto fail;\n\treturn acl;\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n\nstatic struct posix_acl *f2fs_acl_from_disk(const char *value, size_t size)\n{\n\tint i, count;\n\tstruct posix_acl *acl;\n\tstruct f2fs_acl_header *hdr = (struct f2fs_acl_header *)value;\n\tstruct f2fs_acl_entry *entry = (struct f2fs_acl_entry *)(hdr + 1);\n\tconst char *end = value + size;\n\n\tif (hdr->a_version != cpu_to_le32(F2FS_ACL_VERSION))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tcount = f2fs_acl_count(size);\n\tif (count < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (count == 0)\n\t\treturn NULL;\n\n\tacl = posix_acl_alloc(count, GFP_NOFS);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (i = 0; i < count; i++) {\n\n\t\tif ((char *)entry > end)\n\t\t\tgoto fail;\n\n\t\tacl->a_entries[i].e_tag  = le16_to_cpu(entry->e_tag);\n\t\tacl->a_entries[i].e_perm = le16_to_cpu(entry->e_perm);\n\n\t\tswitch (acl->a_entries[i].e_tag) {\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\tentry = (struct f2fs_acl_entry *)((char *)entry +\n\t\t\t\t\tsizeof(struct f2fs_acl_entry_short));\n\t\t\tbreak;\n\n\t\tcase ACL_USER:\n\t\t\tacl->a_entries[i].e_uid =\n\t\t\t\tmake_kuid(&init_user_ns,\n\t\t\t\t\t\tle32_to_cpu(entry->e_id));\n\t\t\tentry = (struct f2fs_acl_entry *)((char *)entry +\n\t\t\t\t\tsizeof(struct f2fs_acl_entry));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tacl->a_entries[i].e_gid =\n\t\t\t\tmake_kgid(&init_user_ns,\n\t\t\t\t\t\tle32_to_cpu(entry->e_id));\n\t\t\tentry = (struct f2fs_acl_entry *)((char *)entry +\n\t\t\t\t\tsizeof(struct f2fs_acl_entry));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tif ((char *)entry != end)\n\t\tgoto fail;\n\treturn acl;\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "f2fs_getxattr",
          "args": [
            "inode",
            "name_index",
            "\"\"",
            "value",
            "retval",
            "dpage"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_getxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/xattr.h",
          "lines": "129-134",
          "snippet": "static inline int f2fs_getxattr(struct inode *inode, int index,\n\t\t\tconst char *name, void *buffer,\n\t\t\tsize_t buffer_size, struct page *dpage)\n{\n\treturn -EOPNOTSUPP;\n}",
          "includes": [
            "#include <linux/xattr.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/xattr.h>\n#include <linux/init.h>\n\nstatic inline int f2fs_getxattr(struct inode *inode, int index,\n\t\t\tconst char *name, void *buffer,\n\t\t\tsize_t buffer_size, struct page *dpage)\n{\n\treturn -EOPNOTSUPP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "retval",
            "GFP_F2FS_ZERO"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n\nstatic struct posix_acl *__f2fs_get_acl(struct inode *inode, int type,\n\t\t\t\t\t\tstruct page *dpage)\n{\n\tint name_index = F2FS_XATTR_INDEX_POSIX_ACL_DEFAULT;\n\tvoid *value = NULL;\n\tstruct posix_acl *acl;\n\tint retval;\n\n\tif (type == ACL_TYPE_ACCESS)\n\t\tname_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS;\n\n\tretval = f2fs_getxattr(inode, name_index, \"\", NULL, 0, dpage);\n\tif (retval > 0) {\n\t\tvalue = kmalloc(retval, GFP_F2FS_ZERO);\n\t\tif (!value)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tretval = f2fs_getxattr(inode, name_index, \"\", value,\n\t\t\t\t\t\t\tretval, dpage);\n\t}\n\n\tif (retval > 0)\n\t\tacl = f2fs_acl_from_disk(value, retval);\n\telse if (retval == -ENODATA)\n\t\tacl = NULL;\n\telse\n\t\tacl = ERR_PTR(retval);\n\tkfree(value);\n\n\tif (!IS_ERR(acl))\n\t\tset_cached_acl(inode, type, acl);\n\n\treturn acl;\n}"
  },
  {
    "function_name": "f2fs_acl_to_disk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/acl.c",
    "lines": "112-163",
    "snippet": "static void *f2fs_acl_to_disk(const struct posix_acl *acl, size_t *size)\n{\n\tstruct f2fs_acl_header *f2fs_acl;\n\tstruct f2fs_acl_entry *entry;\n\tint i;\n\n\tf2fs_acl = kmalloc(sizeof(struct f2fs_acl_header) + acl->a_count *\n\t\t\tsizeof(struct f2fs_acl_entry), GFP_NOFS);\n\tif (!f2fs_acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tf2fs_acl->a_version = cpu_to_le32(F2FS_ACL_VERSION);\n\tentry = (struct f2fs_acl_entry *)(f2fs_acl + 1);\n\n\tfor (i = 0; i < acl->a_count; i++) {\n\n\t\tentry->e_tag  = cpu_to_le16(acl->a_entries[i].e_tag);\n\t\tentry->e_perm = cpu_to_le16(acl->a_entries[i].e_perm);\n\n\t\tswitch (acl->a_entries[i].e_tag) {\n\t\tcase ACL_USER:\n\t\t\tentry->e_id = cpu_to_le32(\n\t\t\t\t\tfrom_kuid(&init_user_ns,\n\t\t\t\t\t\tacl->a_entries[i].e_uid));\n\t\t\tentry = (struct f2fs_acl_entry *)((char *)entry +\n\t\t\t\t\tsizeof(struct f2fs_acl_entry));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tentry->e_id = cpu_to_le32(\n\t\t\t\t\tfrom_kgid(&init_user_ns,\n\t\t\t\t\t\tacl->a_entries[i].e_gid));\n\t\t\tentry = (struct f2fs_acl_entry *)((char *)entry +\n\t\t\t\t\tsizeof(struct f2fs_acl_entry));\n\t\t\tbreak;\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\tentry = (struct f2fs_acl_entry *)((char *)entry +\n\t\t\t\t\tsizeof(struct f2fs_acl_entry_short));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\t*size = f2fs_acl_size(acl->a_count);\n\treturn (void *)f2fs_acl;\n\nfail:\n\tkfree(f2fs_acl);\n\treturn ERR_PTR(-EINVAL);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/f2fs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "f2fs_acl"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_acl_size",
          "args": [
            "acl->a_count"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_acl_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/acl.c",
          "lines": "20-30",
          "snippet": "static inline size_t f2fs_acl_size(int count)\n{\n\tif (count <= 4) {\n\t\treturn sizeof(struct f2fs_acl_header) +\n\t\t\tcount * sizeof(struct f2fs_acl_entry_short);\n\t} else {\n\t\treturn sizeof(struct f2fs_acl_header) +\n\t\t\t4 * sizeof(struct f2fs_acl_entry_short) +\n\t\t\t(count - 4) * sizeof(struct f2fs_acl_entry);\n\t}\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n\nstatic inline size_t f2fs_acl_size(int count)\n{\n\tif (count <= 4) {\n\t\treturn sizeof(struct f2fs_acl_header) +\n\t\t\tcount * sizeof(struct f2fs_acl_entry_short);\n\t} else {\n\t\treturn sizeof(struct f2fs_acl_header) +\n\t\t\t4 * sizeof(struct f2fs_acl_entry_short) +\n\t\t\t(count - 4) * sizeof(struct f2fs_acl_entry);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "from_kgid(&init_user_ns,\n\t\t\t\t\t\tacl->a_entries[i].e_gid)"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kgid",
          "args": [
            "&init_user_ns",
            "acl->a_entries[i].e_gid"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "from_kuid(&init_user_ns,\n\t\t\t\t\t\tacl->a_entries[i].e_uid)"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "acl->a_entries[i].e_uid"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "acl->a_entries[i].e_perm"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "acl->a_entries[i].e_tag"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "F2FS_ACL_VERSION"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct f2fs_acl_header) + acl->a_count *\n\t\t\tsizeof(struct f2fs_acl_entry)",
            "GFP_NOFS"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n\nstatic void *f2fs_acl_to_disk(const struct posix_acl *acl, size_t *size)\n{\n\tstruct f2fs_acl_header *f2fs_acl;\n\tstruct f2fs_acl_entry *entry;\n\tint i;\n\n\tf2fs_acl = kmalloc(sizeof(struct f2fs_acl_header) + acl->a_count *\n\t\t\tsizeof(struct f2fs_acl_entry), GFP_NOFS);\n\tif (!f2fs_acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tf2fs_acl->a_version = cpu_to_le32(F2FS_ACL_VERSION);\n\tentry = (struct f2fs_acl_entry *)(f2fs_acl + 1);\n\n\tfor (i = 0; i < acl->a_count; i++) {\n\n\t\tentry->e_tag  = cpu_to_le16(acl->a_entries[i].e_tag);\n\t\tentry->e_perm = cpu_to_le16(acl->a_entries[i].e_perm);\n\n\t\tswitch (acl->a_entries[i].e_tag) {\n\t\tcase ACL_USER:\n\t\t\tentry->e_id = cpu_to_le32(\n\t\t\t\t\tfrom_kuid(&init_user_ns,\n\t\t\t\t\t\tacl->a_entries[i].e_uid));\n\t\t\tentry = (struct f2fs_acl_entry *)((char *)entry +\n\t\t\t\t\tsizeof(struct f2fs_acl_entry));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tentry->e_id = cpu_to_le32(\n\t\t\t\t\tfrom_kgid(&init_user_ns,\n\t\t\t\t\t\tacl->a_entries[i].e_gid));\n\t\t\tentry = (struct f2fs_acl_entry *)((char *)entry +\n\t\t\t\t\tsizeof(struct f2fs_acl_entry));\n\t\t\tbreak;\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\tentry = (struct f2fs_acl_entry *)((char *)entry +\n\t\t\t\t\tsizeof(struct f2fs_acl_entry_short));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\t*size = f2fs_acl_size(acl->a_count);\n\treturn (void *)f2fs_acl;\n\nfail:\n\tkfree(f2fs_acl);\n\treturn ERR_PTR(-EINVAL);\n}"
  },
  {
    "function_name": "f2fs_acl_from_disk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/acl.c",
    "lines": "48-110",
    "snippet": "static struct posix_acl *f2fs_acl_from_disk(const char *value, size_t size)\n{\n\tint i, count;\n\tstruct posix_acl *acl;\n\tstruct f2fs_acl_header *hdr = (struct f2fs_acl_header *)value;\n\tstruct f2fs_acl_entry *entry = (struct f2fs_acl_entry *)(hdr + 1);\n\tconst char *end = value + size;\n\n\tif (hdr->a_version != cpu_to_le32(F2FS_ACL_VERSION))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tcount = f2fs_acl_count(size);\n\tif (count < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (count == 0)\n\t\treturn NULL;\n\n\tacl = posix_acl_alloc(count, GFP_NOFS);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (i = 0; i < count; i++) {\n\n\t\tif ((char *)entry > end)\n\t\t\tgoto fail;\n\n\t\tacl->a_entries[i].e_tag  = le16_to_cpu(entry->e_tag);\n\t\tacl->a_entries[i].e_perm = le16_to_cpu(entry->e_perm);\n\n\t\tswitch (acl->a_entries[i].e_tag) {\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\tentry = (struct f2fs_acl_entry *)((char *)entry +\n\t\t\t\t\tsizeof(struct f2fs_acl_entry_short));\n\t\t\tbreak;\n\n\t\tcase ACL_USER:\n\t\t\tacl->a_entries[i].e_uid =\n\t\t\t\tmake_kuid(&init_user_ns,\n\t\t\t\t\t\tle32_to_cpu(entry->e_id));\n\t\t\tentry = (struct f2fs_acl_entry *)((char *)entry +\n\t\t\t\t\tsizeof(struct f2fs_acl_entry));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tacl->a_entries[i].e_gid =\n\t\t\t\tmake_kgid(&init_user_ns,\n\t\t\t\t\t\tle32_to_cpu(entry->e_id));\n\t\t\tentry = (struct f2fs_acl_entry *)((char *)entry +\n\t\t\t\t\tsizeof(struct f2fs_acl_entry));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tif ((char *)entry != end)\n\t\tgoto fail;\n\treturn acl;\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/f2fs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "acl"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kgid",
          "args": [
            "&init_user_ns",
            "le32_to_cpu(entry->e_id)"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "entry->e_id"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "&init_user_ns",
            "le32_to_cpu(entry->e_id)"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "entry->e_perm"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_alloc",
          "args": [
            "count",
            "GFP_NOFS"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "140-149",
          "snippet": "struct posix_acl *\nposix_acl_alloc(int count, gfp_t flags)\n{\n\tconst size_t size = sizeof(struct posix_acl) +\n\t                    count * sizeof(struct posix_acl_entry);\n\tstruct posix_acl *acl = kmalloc(size, flags);\n\tif (acl)\n\t\tposix_acl_init(acl, count);\n\treturn acl;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct posix_acl *\nposix_acl_alloc(int count, gfp_t flags)\n{\n\tconst size_t size = sizeof(struct posix_acl) +\n\t                    count * sizeof(struct posix_acl_entry);\n\tstruct posix_acl *acl = kmalloc(size, flags);\n\tif (acl)\n\t\tposix_acl_init(acl, count);\n\treturn acl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f2fs_acl_count",
          "args": [
            "size"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_acl_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/acl.c",
          "lines": "32-46",
          "snippet": "static inline int f2fs_acl_count(size_t size)\n{\n\tssize_t s;\n\tsize -= sizeof(struct f2fs_acl_header);\n\ts = size - 4 * sizeof(struct f2fs_acl_entry_short);\n\tif (s < 0) {\n\t\tif (size % sizeof(struct f2fs_acl_entry_short))\n\t\t\treturn -1;\n\t\treturn size / sizeof(struct f2fs_acl_entry_short);\n\t} else {\n\t\tif (s % sizeof(struct f2fs_acl_entry))\n\t\t\treturn -1;\n\t\treturn s / sizeof(struct f2fs_acl_entry) + 4;\n\t}\n}",
          "includes": [
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"f2fs.h\"",
            "#include <linux/f2fs_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n\nstatic inline int f2fs_acl_count(size_t size)\n{\n\tssize_t s;\n\tsize -= sizeof(struct f2fs_acl_header);\n\ts = size - 4 * sizeof(struct f2fs_acl_entry_short);\n\tif (s < 0) {\n\t\tif (size % sizeof(struct f2fs_acl_entry_short))\n\t\t\treturn -1;\n\t\treturn size / sizeof(struct f2fs_acl_entry_short);\n\t} else {\n\t\tif (s % sizeof(struct f2fs_acl_entry))\n\t\t\treturn -1;\n\t\treturn s / sizeof(struct f2fs_acl_entry) + 4;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "F2FS_ACL_VERSION"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n\nstatic struct posix_acl *f2fs_acl_from_disk(const char *value, size_t size)\n{\n\tint i, count;\n\tstruct posix_acl *acl;\n\tstruct f2fs_acl_header *hdr = (struct f2fs_acl_header *)value;\n\tstruct f2fs_acl_entry *entry = (struct f2fs_acl_entry *)(hdr + 1);\n\tconst char *end = value + size;\n\n\tif (hdr->a_version != cpu_to_le32(F2FS_ACL_VERSION))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tcount = f2fs_acl_count(size);\n\tif (count < 0)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (count == 0)\n\t\treturn NULL;\n\n\tacl = posix_acl_alloc(count, GFP_NOFS);\n\tif (!acl)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor (i = 0; i < count; i++) {\n\n\t\tif ((char *)entry > end)\n\t\t\tgoto fail;\n\n\t\tacl->a_entries[i].e_tag  = le16_to_cpu(entry->e_tag);\n\t\tacl->a_entries[i].e_perm = le16_to_cpu(entry->e_perm);\n\n\t\tswitch (acl->a_entries[i].e_tag) {\n\t\tcase ACL_USER_OBJ:\n\t\tcase ACL_GROUP_OBJ:\n\t\tcase ACL_MASK:\n\t\tcase ACL_OTHER:\n\t\t\tentry = (struct f2fs_acl_entry *)((char *)entry +\n\t\t\t\t\tsizeof(struct f2fs_acl_entry_short));\n\t\t\tbreak;\n\n\t\tcase ACL_USER:\n\t\t\tacl->a_entries[i].e_uid =\n\t\t\t\tmake_kuid(&init_user_ns,\n\t\t\t\t\t\tle32_to_cpu(entry->e_id));\n\t\t\tentry = (struct f2fs_acl_entry *)((char *)entry +\n\t\t\t\t\tsizeof(struct f2fs_acl_entry));\n\t\t\tbreak;\n\t\tcase ACL_GROUP:\n\t\t\tacl->a_entries[i].e_gid =\n\t\t\t\tmake_kgid(&init_user_ns,\n\t\t\t\t\t\tle32_to_cpu(entry->e_id));\n\t\t\tentry = (struct f2fs_acl_entry *)((char *)entry +\n\t\t\t\t\tsizeof(struct f2fs_acl_entry));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tif ((char *)entry != end)\n\t\tgoto fail;\n\treturn acl;\nfail:\n\tposix_acl_release(acl);\n\treturn ERR_PTR(-EINVAL);\n}"
  },
  {
    "function_name": "f2fs_acl_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/acl.c",
    "lines": "32-46",
    "snippet": "static inline int f2fs_acl_count(size_t size)\n{\n\tssize_t s;\n\tsize -= sizeof(struct f2fs_acl_header);\n\ts = size - 4 * sizeof(struct f2fs_acl_entry_short);\n\tif (s < 0) {\n\t\tif (size % sizeof(struct f2fs_acl_entry_short))\n\t\t\treturn -1;\n\t\treturn size / sizeof(struct f2fs_acl_entry_short);\n\t} else {\n\t\tif (s % sizeof(struct f2fs_acl_entry))\n\t\t\treturn -1;\n\t\treturn s / sizeof(struct f2fs_acl_entry) + 4;\n\t}\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/f2fs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n\nstatic inline int f2fs_acl_count(size_t size)\n{\n\tssize_t s;\n\tsize -= sizeof(struct f2fs_acl_header);\n\ts = size - 4 * sizeof(struct f2fs_acl_entry_short);\n\tif (s < 0) {\n\t\tif (size % sizeof(struct f2fs_acl_entry_short))\n\t\t\treturn -1;\n\t\treturn size / sizeof(struct f2fs_acl_entry_short);\n\t} else {\n\t\tif (s % sizeof(struct f2fs_acl_entry))\n\t\t\treturn -1;\n\t\treturn s / sizeof(struct f2fs_acl_entry) + 4;\n\t}\n}"
  },
  {
    "function_name": "f2fs_acl_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/acl.c",
    "lines": "20-30",
    "snippet": "static inline size_t f2fs_acl_size(int count)\n{\n\tif (count <= 4) {\n\t\treturn sizeof(struct f2fs_acl_header) +\n\t\t\tcount * sizeof(struct f2fs_acl_entry_short);\n\t} else {\n\t\treturn sizeof(struct f2fs_acl_header) +\n\t\t\t4 * sizeof(struct f2fs_acl_entry_short) +\n\t\t\t(count - 4) * sizeof(struct f2fs_acl_entry);\n\t}\n}",
    "includes": [
      "#include \"acl.h\"",
      "#include \"xattr.h\"",
      "#include \"f2fs.h\"",
      "#include <linux/f2fs_fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"acl.h\"\n#include \"xattr.h\"\n#include \"f2fs.h\"\n#include <linux/f2fs_fs.h>\n\nstatic inline size_t f2fs_acl_size(int count)\n{\n\tif (count <= 4) {\n\t\treturn sizeof(struct f2fs_acl_header) +\n\t\t\tcount * sizeof(struct f2fs_acl_entry_short);\n\t} else {\n\t\treturn sizeof(struct f2fs_acl_header) +\n\t\t\t4 * sizeof(struct f2fs_acl_entry_short) +\n\t\t\t(count - 4) * sizeof(struct f2fs_acl_entry);\n\t}\n}"
  }
]