[
  {
    "function_name": "eventpoll_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
    "lines": "2093-2132",
    "snippet": "static int __init eventpoll_init(void)\n{\n\tstruct sysinfo si;\n\n\tsi_meminfo(&si);\n\t/*\n\t * Allows top 4% of lomem to be allocated for epoll watches (per user).\n\t */\n\tmax_user_watches = (((si.totalram - si.totalhigh) / 25) << PAGE_SHIFT) /\n\t\tEP_ITEM_COST;\n\tBUG_ON(max_user_watches < 0);\n\n\t/*\n\t * Initialize the structure used to perform epoll file descriptor\n\t * inclusion loops checks.\n\t */\n\tep_nested_calls_init(&poll_loop_ncalls);\n\n\t/* Initialize the structure used to perform safe poll wait head wake ups */\n\tep_nested_calls_init(&poll_safewake_ncalls);\n\n\t/* Initialize the structure used to perform file's f_op->poll() calls */\n\tep_nested_calls_init(&poll_readywalk_ncalls);\n\n\t/*\n\t * We can have many thousands of epitems, so prevent this from\n\t * using an extra cache line on 64-bit (and smaller) CPUs\n\t */\n\tBUILD_BUG_ON(sizeof(void *) <= 8 && sizeof(struct epitem) > 128);\n\n\t/* Allocates slab cache used to allocate \"struct epitem\" items */\n\tepi_cache = kmem_cache_create(\"eventpoll_epi\", sizeof(struct epitem),\n\t\t\t0, SLAB_HWCACHE_ALIGN | SLAB_PANIC, NULL);\n\n\t/* Allocates slab cache used to allocate \"struct eppoll_entry\" */\n\tpwq_cache = kmem_cache_create(\"eventpoll_pwq\",\n\t\t\tsizeof(struct eppoll_entry), 0, SLAB_PANIC, NULL);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define EP_ITEM_COST (sizeof(struct epitem) + sizeof(struct eppoll_entry))"
    ],
    "globals_used": [
      "static struct nested_calls poll_loop_ncalls;",
      "static struct nested_calls poll_safewake_ncalls;",
      "static struct nested_calls poll_readywalk_ncalls;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"eventpoll_pwq\"",
            "sizeof(struct eppoll_entry)",
            "0",
            "SLAB_PANIC",
            "NULL"
          ],
          "line": 2128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"eventpoll_epi\"",
            "sizeof(struct epitem)",
            "0",
            "SLAB_HWCACHE_ALIGN | SLAB_PANIC",
            "NULL"
          ],
          "line": 2124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "sizeof(void *) <= 8 && sizeof(struct epitem) > 128"
          ],
          "line": 2121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_nested_calls_init",
          "args": [
            "&poll_readywalk_ncalls"
          ],
          "line": 2115
        },
        "resolved": true,
        "details": {
          "function_name": "ep_nested_calls_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
          "lines": "363-367",
          "snippet": "static void ep_nested_calls_init(struct nested_calls *ncalls)\n{\n\tINIT_LIST_HEAD(&ncalls->tasks_call_list);\n\tspin_lock_init(&ncalls->lock);\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void ep_nested_calls_init(struct nested_calls *ncalls)\n{\n\tINIT_LIST_HEAD(&ncalls->tasks_call_list);\n\tspin_lock_init(&ncalls->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "max_user_watches < 0"
          ],
          "line": 2103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "si_meminfo",
          "args": [
            "&si"
          ],
          "line": 2097
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define EP_ITEM_COST (sizeof(struct epitem) + sizeof(struct eppoll_entry))\n\nstatic struct nested_calls poll_loop_ncalls;\nstatic struct nested_calls poll_safewake_ncalls;\nstatic struct nested_calls poll_readywalk_ncalls;\n\nstatic int __init eventpoll_init(void)\n{\n\tstruct sysinfo si;\n\n\tsi_meminfo(&si);\n\t/*\n\t * Allows top 4% of lomem to be allocated for epoll watches (per user).\n\t */\n\tmax_user_watches = (((si.totalram - si.totalhigh) / 25) << PAGE_SHIFT) /\n\t\tEP_ITEM_COST;\n\tBUG_ON(max_user_watches < 0);\n\n\t/*\n\t * Initialize the structure used to perform epoll file descriptor\n\t * inclusion loops checks.\n\t */\n\tep_nested_calls_init(&poll_loop_ncalls);\n\n\t/* Initialize the structure used to perform safe poll wait head wake ups */\n\tep_nested_calls_init(&poll_safewake_ncalls);\n\n\t/* Initialize the structure used to perform file's f_op->poll() calls */\n\tep_nested_calls_init(&poll_readywalk_ncalls);\n\n\t/*\n\t * We can have many thousands of epitems, so prevent this from\n\t * using an extra cache line on 64-bit (and smaller) CPUs\n\t */\n\tBUILD_BUG_ON(sizeof(void *) <= 8 && sizeof(struct epitem) > 128);\n\n\t/* Allocates slab cache used to allocate \"struct epitem\" items */\n\tepi_cache = kmem_cache_create(\"eventpoll_epi\", sizeof(struct epitem),\n\t\t\t0, SLAB_HWCACHE_ALIGN | SLAB_PANIC, NULL);\n\n\t/* Allocates slab cache used to allocate \"struct eppoll_entry\" */\n\tpwq_cache = kmem_cache_create(\"eventpoll_pwq\",\n\t\t\tsizeof(struct eppoll_entry), 0, SLAB_PANIC, NULL);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "clear_tfile_check_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
    "lines": "1748-1759",
    "snippet": "static void clear_tfile_check_list(void)\n{\n\tstruct file *file;\n\n\t/* first clear the tfile_check_list */\n\twhile (!list_empty(&tfile_check_list)) {\n\t\tfile = list_first_entry(&tfile_check_list, struct file,\n\t\t\t\t\tf_tfile_llink);\n\t\tlist_del_init(&file->f_tfile_llink);\n\t}\n\tINIT_LIST_HEAD(&tfile_check_list);\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(tfile_check_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&tfile_check_list"
          ],
          "line": 1758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&file->f_tfile_llink"
          ],
          "line": 1756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&tfile_check_list",
            "structfile",
            "f_tfile_llink"
          ],
          "line": 1754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&tfile_check_list"
          ],
          "line": 1753
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic LIST_HEAD(tfile_check_list);\n\nstatic void clear_tfile_check_list(void)\n{\n\tstruct file *file;\n\n\t/* first clear the tfile_check_list */\n\twhile (!list_empty(&tfile_check_list)) {\n\t\tfile = list_first_entry(&tfile_check_list, struct file,\n\t\t\t\t\tf_tfile_llink);\n\t\tlist_del_init(&file->f_tfile_llink);\n\t}\n\tINIT_LIST_HEAD(&tfile_check_list);\n}"
  },
  {
    "function_name": "ep_loop_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
    "lines": "1732-1746",
    "snippet": "static int ep_loop_check(struct eventpoll *ep, struct file *file)\n{\n\tint ret;\n\tstruct eventpoll *ep_cur, *ep_next;\n\n\tret = ep_call_nested(&poll_loop_ncalls, EP_MAX_NESTS,\n\t\t\t      ep_loop_check_proc, file, ep, current);\n\t/* clear visited list */\n\tlist_for_each_entry_safe(ep_cur, ep_next, &visited_list,\n\t\t\t\t\t\t\tvisited_list_link) {\n\t\tep_cur->visited = 0;\n\t\tlist_del(&ep_cur->visited_list_link);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define EP_MAX_NESTS 4"
    ],
    "globals_used": [
      "static struct nested_calls poll_loop_ncalls;",
      "static LIST_HEAD(visited_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&ep_cur->visited_list_link"
          ],
          "line": 1743
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "ep_cur",
            "ep_next",
            "&visited_list",
            "visited_list_link"
          ],
          "line": 1740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_call_nested",
          "args": [
            "&poll_loop_ncalls",
            "EP_MAX_NESTS",
            "ep_loop_check_proc",
            "file",
            "ep",
            "current"
          ],
          "line": 1737
        },
        "resolved": true,
        "details": {
          "function_name": "ep_call_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
          "lines": "398-444",
          "snippet": "static int ep_call_nested(struct nested_calls *ncalls, int max_nests,\n\t\t\t  int (*nproc)(void *, void *, int), void *priv,\n\t\t\t  void *cookie, void *ctx)\n{\n\tint error, call_nests = 0;\n\tunsigned long flags;\n\tstruct list_head *lsthead = &ncalls->tasks_call_list;\n\tstruct nested_call_node *tncur;\n\tstruct nested_call_node tnode;\n\n\tspin_lock_irqsave(&ncalls->lock, flags);\n\n\t/*\n\t * Try to see if the current task is already inside this wakeup call.\n\t * We use a list here, since the population inside this set is always\n\t * very much limited.\n\t */\n\tlist_for_each_entry(tncur, lsthead, llink) {\n\t\tif (tncur->ctx == ctx &&\n\t\t    (tncur->cookie == cookie || ++call_nests > max_nests)) {\n\t\t\t/*\n\t\t\t * Ops ... loop detected or maximum nest level reached.\n\t\t\t * We abort this wake by breaking the cycle itself.\n\t\t\t */\n\t\t\terror = -1;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\t/* Add the current task and cookie to the list */\n\ttnode.ctx = ctx;\n\ttnode.cookie = cookie;\n\tlist_add(&tnode.llink, lsthead);\n\n\tspin_unlock_irqrestore(&ncalls->lock, flags);\n\n\t/* Call the nested function */\n\terror = (*nproc)(priv, cookie, call_nests);\n\n\t/* Remove the current task from the list */\n\tspin_lock_irqsave(&ncalls->lock, flags);\n\tlist_del(&tnode.llink);\nout_unlock:\n\tspin_unlock_irqrestore(&ncalls->lock, flags);\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int ep_call_nested(struct nested_calls *ncalls, int max_nests,\n\t\t\t  int (*nproc)(void *, void *, int), void *priv,\n\t\t\t  void *cookie, void *ctx)\n{\n\tint error, call_nests = 0;\n\tunsigned long flags;\n\tstruct list_head *lsthead = &ncalls->tasks_call_list;\n\tstruct nested_call_node *tncur;\n\tstruct nested_call_node tnode;\n\n\tspin_lock_irqsave(&ncalls->lock, flags);\n\n\t/*\n\t * Try to see if the current task is already inside this wakeup call.\n\t * We use a list here, since the population inside this set is always\n\t * very much limited.\n\t */\n\tlist_for_each_entry(tncur, lsthead, llink) {\n\t\tif (tncur->ctx == ctx &&\n\t\t    (tncur->cookie == cookie || ++call_nests > max_nests)) {\n\t\t\t/*\n\t\t\t * Ops ... loop detected or maximum nest level reached.\n\t\t\t * We abort this wake by breaking the cycle itself.\n\t\t\t */\n\t\t\terror = -1;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\t/* Add the current task and cookie to the list */\n\ttnode.ctx = ctx;\n\ttnode.cookie = cookie;\n\tlist_add(&tnode.llink, lsthead);\n\n\tspin_unlock_irqrestore(&ncalls->lock, flags);\n\n\t/* Call the nested function */\n\terror = (*nproc)(priv, cookie, call_nests);\n\n\t/* Remove the current task from the list */\n\tspin_lock_irqsave(&ncalls->lock, flags);\n\tlist_del(&tnode.llink);\nout_unlock:\n\tspin_unlock_irqrestore(&ncalls->lock, flags);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define EP_MAX_NESTS 4\n\nstatic struct nested_calls poll_loop_ncalls;\nstatic LIST_HEAD(visited_list);\n\nstatic int ep_loop_check(struct eventpoll *ep, struct file *file)\n{\n\tint ret;\n\tstruct eventpoll *ep_cur, *ep_next;\n\n\tret = ep_call_nested(&poll_loop_ncalls, EP_MAX_NESTS,\n\t\t\t      ep_loop_check_proc, file, ep, current);\n\t/* clear visited list */\n\tlist_for_each_entry_safe(ep_cur, ep_next, &visited_list,\n\t\t\t\t\t\t\tvisited_list_link) {\n\t\tep_cur->visited = 0;\n\t\tlist_del(&ep_cur->visited_list_link);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "ep_loop_check_proc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
    "lines": "1679-1719",
    "snippet": "static int ep_loop_check_proc(void *priv, void *cookie, int call_nests)\n{\n\tint error = 0;\n\tstruct file *file = priv;\n\tstruct eventpoll *ep = file->private_data;\n\tstruct eventpoll *ep_tovisit;\n\tstruct rb_node *rbp;\n\tstruct epitem *epi;\n\n\tmutex_lock_nested(&ep->mtx, call_nests + 1);\n\tep->visited = 1;\n\tlist_add(&ep->visited_list_link, &visited_list);\n\tfor (rbp = rb_first(&ep->rbr); rbp; rbp = rb_next(rbp)) {\n\t\tepi = rb_entry(rbp, struct epitem, rbn);\n\t\tif (unlikely(is_file_epoll(epi->ffd.file))) {\n\t\t\tep_tovisit = epi->ffd.file->private_data;\n\t\t\tif (ep_tovisit->visited)\n\t\t\t\tcontinue;\n\t\t\terror = ep_call_nested(&poll_loop_ncalls, EP_MAX_NESTS,\n\t\t\t\t\tep_loop_check_proc, epi->ffd.file,\n\t\t\t\t\tep_tovisit, current);\n\t\t\tif (error != 0)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\t/*\n\t\t\t * If we've reached a file that is not associated with\n\t\t\t * an ep, then we need to check if the newly added\n\t\t\t * links are going to add too many wakeup paths. We do\n\t\t\t * this by adding it to the tfile_check_list, if it's\n\t\t\t * not already there, and calling reverse_path_check()\n\t\t\t * during ep_insert().\n\t\t\t */\n\t\t\tif (list_empty(&epi->ffd.file->f_tfile_llink))\n\t\t\t\tlist_add(&epi->ffd.file->f_tfile_llink,\n\t\t\t\t\t &tfile_check_list);\n\t\t}\n\t}\n\tmutex_unlock(&ep->mtx);\n\n\treturn error;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define EP_MAX_NESTS 4"
    ],
    "globals_used": [
      "static struct nested_calls poll_loop_ncalls;",
      "static LIST_HEAD(visited_list);",
      "static LIST_HEAD(tfile_check_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ep->mtx"
          ],
          "line": 1716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&epi->ffd.file->f_tfile_llink",
            "&tfile_check_list"
          ],
          "line": 1712
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&epi->ffd.file->f_tfile_llink"
          ],
          "line": 1711
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ep_call_nested",
          "args": [
            "&poll_loop_ncalls",
            "EP_MAX_NESTS",
            "ep_loop_check_proc",
            "epi->ffd.file",
            "ep_tovisit",
            "current"
          ],
          "line": 1697
        },
        "resolved": true,
        "details": {
          "function_name": "ep_call_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
          "lines": "398-444",
          "snippet": "static int ep_call_nested(struct nested_calls *ncalls, int max_nests,\n\t\t\t  int (*nproc)(void *, void *, int), void *priv,\n\t\t\t  void *cookie, void *ctx)\n{\n\tint error, call_nests = 0;\n\tunsigned long flags;\n\tstruct list_head *lsthead = &ncalls->tasks_call_list;\n\tstruct nested_call_node *tncur;\n\tstruct nested_call_node tnode;\n\n\tspin_lock_irqsave(&ncalls->lock, flags);\n\n\t/*\n\t * Try to see if the current task is already inside this wakeup call.\n\t * We use a list here, since the population inside this set is always\n\t * very much limited.\n\t */\n\tlist_for_each_entry(tncur, lsthead, llink) {\n\t\tif (tncur->ctx == ctx &&\n\t\t    (tncur->cookie == cookie || ++call_nests > max_nests)) {\n\t\t\t/*\n\t\t\t * Ops ... loop detected or maximum nest level reached.\n\t\t\t * We abort this wake by breaking the cycle itself.\n\t\t\t */\n\t\t\terror = -1;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\t/* Add the current task and cookie to the list */\n\ttnode.ctx = ctx;\n\ttnode.cookie = cookie;\n\tlist_add(&tnode.llink, lsthead);\n\n\tspin_unlock_irqrestore(&ncalls->lock, flags);\n\n\t/* Call the nested function */\n\terror = (*nproc)(priv, cookie, call_nests);\n\n\t/* Remove the current task from the list */\n\tspin_lock_irqsave(&ncalls->lock, flags);\n\tlist_del(&tnode.llink);\nout_unlock:\n\tspin_unlock_irqrestore(&ncalls->lock, flags);\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int ep_call_nested(struct nested_calls *ncalls, int max_nests,\n\t\t\t  int (*nproc)(void *, void *, int), void *priv,\n\t\t\t  void *cookie, void *ctx)\n{\n\tint error, call_nests = 0;\n\tunsigned long flags;\n\tstruct list_head *lsthead = &ncalls->tasks_call_list;\n\tstruct nested_call_node *tncur;\n\tstruct nested_call_node tnode;\n\n\tspin_lock_irqsave(&ncalls->lock, flags);\n\n\t/*\n\t * Try to see if the current task is already inside this wakeup call.\n\t * We use a list here, since the population inside this set is always\n\t * very much limited.\n\t */\n\tlist_for_each_entry(tncur, lsthead, llink) {\n\t\tif (tncur->ctx == ctx &&\n\t\t    (tncur->cookie == cookie || ++call_nests > max_nests)) {\n\t\t\t/*\n\t\t\t * Ops ... loop detected or maximum nest level reached.\n\t\t\t * We abort this wake by breaking the cycle itself.\n\t\t\t */\n\t\t\terror = -1;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\t/* Add the current task and cookie to the list */\n\ttnode.ctx = ctx;\n\ttnode.cookie = cookie;\n\tlist_add(&tnode.llink, lsthead);\n\n\tspin_unlock_irqrestore(&ncalls->lock, flags);\n\n\t/* Call the nested function */\n\terror = (*nproc)(priv, cookie, call_nests);\n\n\t/* Remove the current task from the list */\n\tspin_lock_irqsave(&ncalls->lock, flags);\n\tlist_del(&tnode.llink);\nout_unlock:\n\tspin_unlock_irqrestore(&ncalls->lock, flags);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "is_file_epoll(epi->ffd.file)"
          ],
          "line": 1693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_file_epoll",
          "args": [
            "epi->ffd.file"
          ],
          "line": 1693
        },
        "resolved": true,
        "details": {
          "function_name": "is_file_epoll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
          "lines": "312-315",
          "snippet": "static inline int is_file_epoll(struct file *f)\n{\n\treturn f->f_op == &eventpoll_fops;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations eventpoll_fops;",
            "static const struct file_operations eventpoll_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= ep_show_fdinfo,\n#endif\n\t.release\t= ep_eventpoll_release,\n\t.poll\t\t= ep_eventpoll_poll,\n\t.llseek\t\t= noop_llseek,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic const struct file_operations eventpoll_fops;\nstatic const struct file_operations eventpoll_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= ep_show_fdinfo,\n#endif\n\t.release\t= ep_eventpoll_release,\n\t.poll\t\t= ep_eventpoll_poll,\n\t.llseek\t\t= noop_llseek,\n};\n\nstatic inline int is_file_epoll(struct file *f)\n{\n\treturn f->f_op == &eventpoll_fops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "rbp",
            "structepitem",
            "rbn"
          ],
          "line": 1692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "rbp"
          ],
          "line": 1691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&ep->rbr"
          ],
          "line": 1691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&ep->mtx",
            "call_nests + 1"
          ],
          "line": 1688
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define EP_MAX_NESTS 4\n\nstatic struct nested_calls poll_loop_ncalls;\nstatic LIST_HEAD(visited_list);\nstatic LIST_HEAD(tfile_check_list);\n\nstatic int ep_loop_check_proc(void *priv, void *cookie, int call_nests)\n{\n\tint error = 0;\n\tstruct file *file = priv;\n\tstruct eventpoll *ep = file->private_data;\n\tstruct eventpoll *ep_tovisit;\n\tstruct rb_node *rbp;\n\tstruct epitem *epi;\n\n\tmutex_lock_nested(&ep->mtx, call_nests + 1);\n\tep->visited = 1;\n\tlist_add(&ep->visited_list_link, &visited_list);\n\tfor (rbp = rb_first(&ep->rbr); rbp; rbp = rb_next(rbp)) {\n\t\tepi = rb_entry(rbp, struct epitem, rbn);\n\t\tif (unlikely(is_file_epoll(epi->ffd.file))) {\n\t\t\tep_tovisit = epi->ffd.file->private_data;\n\t\t\tif (ep_tovisit->visited)\n\t\t\t\tcontinue;\n\t\t\terror = ep_call_nested(&poll_loop_ncalls, EP_MAX_NESTS,\n\t\t\t\t\tep_loop_check_proc, epi->ffd.file,\n\t\t\t\t\tep_tovisit, current);\n\t\t\tif (error != 0)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\t/*\n\t\t\t * If we've reached a file that is not associated with\n\t\t\t * an ep, then we need to check if the newly added\n\t\t\t * links are going to add too many wakeup paths. We do\n\t\t\t * this by adding it to the tfile_check_list, if it's\n\t\t\t * not already there, and calling reverse_path_check()\n\t\t\t * during ep_insert().\n\t\t\t */\n\t\t\tif (list_empty(&epi->ffd.file->f_tfile_llink))\n\t\t\t\tlist_add(&epi->ffd.file->f_tfile_llink,\n\t\t\t\t\t &tfile_check_list);\n\t\t}\n\t}\n\tmutex_unlock(&ep->mtx);\n\n\treturn error;\n}"
  },
  {
    "function_name": "ep_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
    "lines": "1585-1662",
    "snippet": "static int ep_poll(struct eventpoll *ep, struct epoll_event __user *events,\n\t\t   int maxevents, long timeout)\n{\n\tint res = 0, eavail, timed_out = 0;\n\tunsigned long flags;\n\tlong slack = 0;\n\twait_queue_t wait;\n\tktime_t expires, *to = NULL;\n\n\tif (timeout > 0) {\n\t\tstruct timespec end_time = ep_set_mstimeout(timeout);\n\n\t\tslack = select_estimate_accuracy(&end_time);\n\t\tto = &expires;\n\t\t*to = timespec_to_ktime(end_time);\n\t} else if (timeout == 0) {\n\t\t/*\n\t\t * Avoid the unnecessary trip to the wait queue loop, if the\n\t\t * caller specified a non blocking operation.\n\t\t */\n\t\ttimed_out = 1;\n\t\tspin_lock_irqsave(&ep->lock, flags);\n\t\tgoto check_events;\n\t}\n\nfetch_events:\n\tspin_lock_irqsave(&ep->lock, flags);\n\n\tif (!ep_events_available(ep)) {\n\t\t/*\n\t\t * We don't have any available event to return to the caller.\n\t\t * We need to sleep here, and we will be wake up by\n\t\t * ep_poll_callback() when events will become available.\n\t\t */\n\t\tinit_waitqueue_entry(&wait, current);\n\t\t__add_wait_queue_exclusive(&ep->wq, &wait);\n\n\t\tfor (;;) {\n\t\t\t/*\n\t\t\t * We don't want to sleep if the ep_poll_callback() sends us\n\t\t\t * a wakeup in between. That's why we set the task state\n\t\t\t * to TASK_INTERRUPTIBLE before doing the checks.\n\t\t\t */\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tif (ep_events_available(ep) || timed_out)\n\t\t\t\tbreak;\n\t\t\tif (signal_pending(current)) {\n\t\t\t\tres = -EINTR;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tspin_unlock_irqrestore(&ep->lock, flags);\n\t\t\tif (!schedule_hrtimeout_range(to, slack, HRTIMER_MODE_ABS))\n\t\t\t\ttimed_out = 1;\n\n\t\t\tspin_lock_irqsave(&ep->lock, flags);\n\t\t}\n\n\t\t__remove_wait_queue(&ep->wq, &wait);\n\t\t__set_current_state(TASK_RUNNING);\n\t}\ncheck_events:\n\t/* Is it worth to try to dig for events ? */\n\teavail = ep_events_available(ep);\n\n\tspin_unlock_irqrestore(&ep->lock, flags);\n\n\t/*\n\t * Try to transfer events to user space. In case we get 0 events and\n\t * there's still timeout left over, we go trying again in search of\n\t * more luck.\n\t */\n\tif (!res && eavail &&\n\t    !(res = ep_send_events(ep, events, maxevents)) && !timed_out)\n\t\tgoto fetch_events;\n\n\treturn res;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ep_send_events",
          "args": [
            "ep",
            "events",
            "maxevents"
          ],
          "line": 1658
        },
        "resolved": true,
        "details": {
          "function_name": "ep_send_events",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
          "lines": "1546-1555",
          "snippet": "static int ep_send_events(struct eventpoll *ep,\n\t\t\t  struct epoll_event __user *events, int maxevents)\n{\n\tstruct ep_send_events_data esed;\n\n\tesed.maxevents = maxevents;\n\tesed.events = events;\n\n\treturn ep_scan_ready_list(ep, ep_send_events_proc, &esed, 0, false);\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int ep_send_events(struct eventpoll *ep,\n\t\t\t  struct epoll_event __user *events, int maxevents)\n{\n\tstruct ep_send_events_data esed;\n\n\tesed.maxevents = maxevents;\n\tesed.events = events;\n\n\treturn ep_scan_ready_list(ep, ep_send_events_proc, &esed, 0, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&ep->lock",
            "flags"
          ],
          "line": 1650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_events_available",
          "args": [
            "ep"
          ],
          "line": 1648
        },
        "resolved": true,
        "details": {
          "function_name": "ep_events_available",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
          "lines": "377-380",
          "snippet": "static inline int ep_events_available(struct eventpoll *ep)\n{\n\treturn !list_empty(&ep->rdllist) || ep->ovflist != EP_UNACTIVE_PTR;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define EP_UNACTIVE_PTR ((void *) -1L)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define EP_UNACTIVE_PTR ((void *) -1L)\n\nstatic inline int ep_events_available(struct eventpoll *ep)\n{\n\treturn !list_empty(&ep->rdllist) || ep->ovflist != EP_UNACTIVE_PTR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 1644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__remove_wait_queue",
          "args": [
            "&ep->wq",
            "&wait"
          ],
          "line": 1643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&ep->lock",
            "flags"
          ],
          "line": 1640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_hrtimeout_range",
          "args": [
            "to",
            "slack",
            "HRTIMER_MODE_ABS"
          ],
          "line": 1637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&ep->lock",
            "flags"
          ],
          "line": 1636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 1631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_INTERRUPTIBLE"
          ],
          "line": 1628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__add_wait_queue_exclusive",
          "args": [
            "&ep->wq",
            "&wait"
          ],
          "line": 1620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_entry",
          "args": [
            "&wait",
            "current"
          ],
          "line": 1619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&ep->lock",
            "flags"
          ],
          "line": 1611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&ep->lock",
            "flags"
          ],
          "line": 1606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec_to_ktime",
          "args": [
            "end_time"
          ],
          "line": 1599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "select_estimate_accuracy",
          "args": [
            "&end_time"
          ],
          "line": 1597
        },
        "resolved": true,
        "details": {
          "function_name": "select_estimate_accuracy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/select.c",
          "lines": "73-91",
          "snippet": "long select_estimate_accuracy(struct timespec *tv)\n{\n\tunsigned long ret;\n\tstruct timespec now;\n\n\t/*\n\t * Realtime tasks get a slack of 0 for obvious reasons.\n\t */\n\n\tif (rt_task(current))\n\t\treturn 0;\n\n\tktime_get_ts(&now);\n\tnow = timespec_sub(*tv, now);\n\tret = __estimate_accuracy(&now);\n\tif (ret < current->timer_slack_ns)\n\t\treturn current->timer_slack_ns;\n\treturn ret;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <net/busy_poll.h>",
            "#include <linux/freezer.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/personality.h> /* for STICKY_TIMEOUTS */",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <net/busy_poll.h>\n#include <linux/freezer.h>\n#include <linux/sched/rt.h>\n#include <linux/hrtimer.h>\n#include <linux/rcupdate.h>\n#include <linux/fs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/personality.h> /* for STICKY_TIMEOUTS */\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nlong select_estimate_accuracy(struct timespec *tv)\n{\n\tunsigned long ret;\n\tstruct timespec now;\n\n\t/*\n\t * Realtime tasks get a slack of 0 for obvious reasons.\n\t */\n\n\tif (rt_task(current))\n\t\treturn 0;\n\n\tktime_get_ts(&now);\n\tnow = timespec_sub(*tv, now);\n\tret = __estimate_accuracy(&now);\n\tif (ret < current->timer_slack_ns)\n\t\treturn current->timer_slack_ns;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ep_set_mstimeout",
          "args": [
            "timeout"
          ],
          "line": 1595
        },
        "resolved": true,
        "details": {
          "function_name": "ep_set_mstimeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
          "lines": "1557-1566",
          "snippet": "static inline struct timespec ep_set_mstimeout(long ms)\n{\n\tstruct timespec now, ts = {\n\t\t.tv_sec = ms / MSEC_PER_SEC,\n\t\t.tv_nsec = NSEC_PER_MSEC * (ms % MSEC_PER_SEC),\n\t};\n\n\tktime_get_ts(&now);\n\treturn timespec_add_safe(now, ts);\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline struct timespec ep_set_mstimeout(long ms)\n{\n\tstruct timespec now, ts = {\n\t\t.tv_sec = ms / MSEC_PER_SEC,\n\t\t.tv_nsec = NSEC_PER_MSEC * (ms % MSEC_PER_SEC),\n\t};\n\n\tktime_get_ts(&now);\n\treturn timespec_add_safe(now, ts);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int ep_poll(struct eventpoll *ep, struct epoll_event __user *events,\n\t\t   int maxevents, long timeout)\n{\n\tint res = 0, eavail, timed_out = 0;\n\tunsigned long flags;\n\tlong slack = 0;\n\twait_queue_t wait;\n\tktime_t expires, *to = NULL;\n\n\tif (timeout > 0) {\n\t\tstruct timespec end_time = ep_set_mstimeout(timeout);\n\n\t\tslack = select_estimate_accuracy(&end_time);\n\t\tto = &expires;\n\t\t*to = timespec_to_ktime(end_time);\n\t} else if (timeout == 0) {\n\t\t/*\n\t\t * Avoid the unnecessary trip to the wait queue loop, if the\n\t\t * caller specified a non blocking operation.\n\t\t */\n\t\ttimed_out = 1;\n\t\tspin_lock_irqsave(&ep->lock, flags);\n\t\tgoto check_events;\n\t}\n\nfetch_events:\n\tspin_lock_irqsave(&ep->lock, flags);\n\n\tif (!ep_events_available(ep)) {\n\t\t/*\n\t\t * We don't have any available event to return to the caller.\n\t\t * We need to sleep here, and we will be wake up by\n\t\t * ep_poll_callback() when events will become available.\n\t\t */\n\t\tinit_waitqueue_entry(&wait, current);\n\t\t__add_wait_queue_exclusive(&ep->wq, &wait);\n\n\t\tfor (;;) {\n\t\t\t/*\n\t\t\t * We don't want to sleep if the ep_poll_callback() sends us\n\t\t\t * a wakeup in between. That's why we set the task state\n\t\t\t * to TASK_INTERRUPTIBLE before doing the checks.\n\t\t\t */\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tif (ep_events_available(ep) || timed_out)\n\t\t\t\tbreak;\n\t\t\tif (signal_pending(current)) {\n\t\t\t\tres = -EINTR;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tspin_unlock_irqrestore(&ep->lock, flags);\n\t\t\tif (!schedule_hrtimeout_range(to, slack, HRTIMER_MODE_ABS))\n\t\t\t\ttimed_out = 1;\n\n\t\t\tspin_lock_irqsave(&ep->lock, flags);\n\t\t}\n\n\t\t__remove_wait_queue(&ep->wq, &wait);\n\t\t__set_current_state(TASK_RUNNING);\n\t}\ncheck_events:\n\t/* Is it worth to try to dig for events ? */\n\teavail = ep_events_available(ep);\n\n\tspin_unlock_irqrestore(&ep->lock, flags);\n\n\t/*\n\t * Try to transfer events to user space. In case we get 0 events and\n\t * there's still timeout left over, we go trying again in search of\n\t * more luck.\n\t */\n\tif (!res && eavail &&\n\t    !(res = ep_send_events(ep, events, maxevents)) && !timed_out)\n\t\tgoto fetch_events;\n\n\treturn res;\n}"
  },
  {
    "function_name": "ep_set_mstimeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
    "lines": "1557-1566",
    "snippet": "static inline struct timespec ep_set_mstimeout(long ms)\n{\n\tstruct timespec now, ts = {\n\t\t.tv_sec = ms / MSEC_PER_SEC,\n\t\t.tv_nsec = NSEC_PER_MSEC * (ms % MSEC_PER_SEC),\n\t};\n\n\tktime_get_ts(&now);\n\treturn timespec_add_safe(now, ts);\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "timespec_add_safe",
          "args": [
            "now",
            "ts"
          ],
          "line": 1565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get_ts",
          "args": [
            "&now"
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline struct timespec ep_set_mstimeout(long ms)\n{\n\tstruct timespec now, ts = {\n\t\t.tv_sec = ms / MSEC_PER_SEC,\n\t\t.tv_nsec = NSEC_PER_MSEC * (ms % MSEC_PER_SEC),\n\t};\n\n\tktime_get_ts(&now);\n\treturn timespec_add_safe(now, ts);\n}"
  },
  {
    "function_name": "ep_send_events",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
    "lines": "1546-1555",
    "snippet": "static int ep_send_events(struct eventpoll *ep,\n\t\t\t  struct epoll_event __user *events, int maxevents)\n{\n\tstruct ep_send_events_data esed;\n\n\tesed.maxevents = maxevents;\n\tesed.events = events;\n\n\treturn ep_scan_ready_list(ep, ep_send_events_proc, &esed, 0, false);\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ep_scan_ready_list",
          "args": [
            "ep",
            "ep_send_events_proc",
            "&esed",
            "0",
            "false"
          ],
          "line": 1554
        },
        "resolved": true,
        "details": {
          "function_name": "ep_scan_ready_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
          "lines": "592-680",
          "snippet": "static int ep_scan_ready_list(struct eventpoll *ep,\n\t\t\t      int (*sproc)(struct eventpoll *,\n\t\t\t\t\t   struct list_head *, void *),\n\t\t\t      void *priv, int depth, bool ep_locked)\n{\n\tint error, pwake = 0;\n\tunsigned long flags;\n\tstruct epitem *epi, *nepi;\n\tLIST_HEAD(txlist);\n\n\t/*\n\t * We need to lock this because we could be hit by\n\t * eventpoll_release_file() and epoll_ctl().\n\t */\n\n\tif (!ep_locked)\n\t\tmutex_lock_nested(&ep->mtx, depth);\n\n\t/*\n\t * Steal the ready list, and re-init the original one to the\n\t * empty list. Also, set ep->ovflist to NULL so that events\n\t * happening while looping w/out locks, are not lost. We cannot\n\t * have the poll callback to queue directly on ep->rdllist,\n\t * because we want the \"sproc\" callback to be able to do it\n\t * in a lockless way.\n\t */\n\tspin_lock_irqsave(&ep->lock, flags);\n\tlist_splice_init(&ep->rdllist, &txlist);\n\tep->ovflist = NULL;\n\tspin_unlock_irqrestore(&ep->lock, flags);\n\n\t/*\n\t * Now call the callback function.\n\t */\n\terror = (*sproc)(ep, &txlist, priv);\n\n\tspin_lock_irqsave(&ep->lock, flags);\n\t/*\n\t * During the time we spent inside the \"sproc\" callback, some\n\t * other events might have been queued by the poll callback.\n\t * We re-insert them inside the main ready-list here.\n\t */\n\tfor (nepi = ep->ovflist; (epi = nepi) != NULL;\n\t     nepi = epi->next, epi->next = EP_UNACTIVE_PTR) {\n\t\t/*\n\t\t * We need to check if the item is already in the list.\n\t\t * During the \"sproc\" callback execution time, items are\n\t\t * queued into ->ovflist but the \"txlist\" might already\n\t\t * contain them, and the list_splice() below takes care of them.\n\t\t */\n\t\tif (!ep_is_linked(&epi->rdllink)) {\n\t\t\tlist_add_tail(&epi->rdllink, &ep->rdllist);\n\t\t\tep_pm_stay_awake(epi);\n\t\t}\n\t}\n\t/*\n\t * We need to set back ep->ovflist to EP_UNACTIVE_PTR, so that after\n\t * releasing the lock, events will be queued in the normal way inside\n\t * ep->rdllist.\n\t */\n\tep->ovflist = EP_UNACTIVE_PTR;\n\n\t/*\n\t * Quickly re-inject items left on \"txlist\".\n\t */\n\tlist_splice(&txlist, &ep->rdllist);\n\t__pm_relax(ep->ws);\n\n\tif (!list_empty(&ep->rdllist)) {\n\t\t/*\n\t\t * Wake up (if active) both the eventpoll wait list and\n\t\t * the ->poll() wait list (delayed after we release the lock).\n\t\t */\n\t\tif (waitqueue_active(&ep->wq))\n\t\t\twake_up_locked(&ep->wq);\n\t\tif (waitqueue_active(&ep->poll_wait))\n\t\t\tpwake++;\n\t}\n\tspin_unlock_irqrestore(&ep->lock, flags);\n\n\tif (!ep_locked)\n\t\tmutex_unlock(&ep->mtx);\n\n\t/* We have to call this outside the lock */\n\tif (pwake)\n\t\tep_poll_safewake(&ep->poll_wait);\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define EP_UNACTIVE_PTR ((void *) -1L)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define EP_UNACTIVE_PTR ((void *) -1L)\n\nstatic int ep_scan_ready_list(struct eventpoll *ep,\n\t\t\t      int (*sproc)(struct eventpoll *,\n\t\t\t\t\t   struct list_head *, void *),\n\t\t\t      void *priv, int depth, bool ep_locked)\n{\n\tint error, pwake = 0;\n\tunsigned long flags;\n\tstruct epitem *epi, *nepi;\n\tLIST_HEAD(txlist);\n\n\t/*\n\t * We need to lock this because we could be hit by\n\t * eventpoll_release_file() and epoll_ctl().\n\t */\n\n\tif (!ep_locked)\n\t\tmutex_lock_nested(&ep->mtx, depth);\n\n\t/*\n\t * Steal the ready list, and re-init the original one to the\n\t * empty list. Also, set ep->ovflist to NULL so that events\n\t * happening while looping w/out locks, are not lost. We cannot\n\t * have the poll callback to queue directly on ep->rdllist,\n\t * because we want the \"sproc\" callback to be able to do it\n\t * in a lockless way.\n\t */\n\tspin_lock_irqsave(&ep->lock, flags);\n\tlist_splice_init(&ep->rdllist, &txlist);\n\tep->ovflist = NULL;\n\tspin_unlock_irqrestore(&ep->lock, flags);\n\n\t/*\n\t * Now call the callback function.\n\t */\n\terror = (*sproc)(ep, &txlist, priv);\n\n\tspin_lock_irqsave(&ep->lock, flags);\n\t/*\n\t * During the time we spent inside the \"sproc\" callback, some\n\t * other events might have been queued by the poll callback.\n\t * We re-insert them inside the main ready-list here.\n\t */\n\tfor (nepi = ep->ovflist; (epi = nepi) != NULL;\n\t     nepi = epi->next, epi->next = EP_UNACTIVE_PTR) {\n\t\t/*\n\t\t * We need to check if the item is already in the list.\n\t\t * During the \"sproc\" callback execution time, items are\n\t\t * queued into ->ovflist but the \"txlist\" might already\n\t\t * contain them, and the list_splice() below takes care of them.\n\t\t */\n\t\tif (!ep_is_linked(&epi->rdllink)) {\n\t\t\tlist_add_tail(&epi->rdllink, &ep->rdllist);\n\t\t\tep_pm_stay_awake(epi);\n\t\t}\n\t}\n\t/*\n\t * We need to set back ep->ovflist to EP_UNACTIVE_PTR, so that after\n\t * releasing the lock, events will be queued in the normal way inside\n\t * ep->rdllist.\n\t */\n\tep->ovflist = EP_UNACTIVE_PTR;\n\n\t/*\n\t * Quickly re-inject items left on \"txlist\".\n\t */\n\tlist_splice(&txlist, &ep->rdllist);\n\t__pm_relax(ep->ws);\n\n\tif (!list_empty(&ep->rdllist)) {\n\t\t/*\n\t\t * Wake up (if active) both the eventpoll wait list and\n\t\t * the ->poll() wait list (delayed after we release the lock).\n\t\t */\n\t\tif (waitqueue_active(&ep->wq))\n\t\t\twake_up_locked(&ep->wq);\n\t\tif (waitqueue_active(&ep->poll_wait))\n\t\t\tpwake++;\n\t}\n\tspin_unlock_irqrestore(&ep->lock, flags);\n\n\tif (!ep_locked)\n\t\tmutex_unlock(&ep->mtx);\n\n\t/* We have to call this outside the lock */\n\tif (pwake)\n\t\tep_poll_safewake(&ep->poll_wait);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int ep_send_events(struct eventpoll *ep,\n\t\t\t  struct epoll_event __user *events, int maxevents)\n{\n\tstruct ep_send_events_data esed;\n\n\tesed.maxevents = maxevents;\n\tesed.events = events;\n\n\treturn ep_scan_ready_list(ep, ep_send_events_proc, &esed, 0, false);\n}"
  },
  {
    "function_name": "ep_send_events_proc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
    "lines": "1466-1544",
    "snippet": "static int ep_send_events_proc(struct eventpoll *ep, struct list_head *head,\n\t\t\t       void *priv)\n{\n\tstruct ep_send_events_data *esed = priv;\n\tint eventcnt;\n\tunsigned int revents;\n\tstruct epitem *epi;\n\tstruct epoll_event __user *uevent;\n\tstruct wakeup_source *ws;\n\tpoll_table pt;\n\n\tinit_poll_funcptr(&pt, NULL);\n\n\t/*\n\t * We can loop without lock because we are passed a task private list.\n\t * Items cannot vanish during the loop because ep_scan_ready_list() is\n\t * holding \"mtx\" during this call.\n\t */\n\tfor (eventcnt = 0, uevent = esed->events;\n\t     !list_empty(head) && eventcnt < esed->maxevents;) {\n\t\tepi = list_first_entry(head, struct epitem, rdllink);\n\n\t\t/*\n\t\t * Activate ep->ws before deactivating epi->ws to prevent\n\t\t * triggering auto-suspend here (in case we reactive epi->ws\n\t\t * below).\n\t\t *\n\t\t * This could be rearranged to delay the deactivation of epi->ws\n\t\t * instead, but then epi->ws would temporarily be out of sync\n\t\t * with ep_is_linked().\n\t\t */\n\t\tws = ep_wakeup_source(epi);\n\t\tif (ws) {\n\t\t\tif (ws->active)\n\t\t\t\t__pm_stay_awake(ep->ws);\n\t\t\t__pm_relax(ws);\n\t\t}\n\n\t\tlist_del_init(&epi->rdllink);\n\n\t\trevents = ep_item_poll(epi, &pt);\n\n\t\t/*\n\t\t * If the event mask intersect the caller-requested one,\n\t\t * deliver the event to userspace. Again, ep_scan_ready_list()\n\t\t * is holding \"mtx\", so no operations coming from userspace\n\t\t * can change the item.\n\t\t */\n\t\tif (revents) {\n\t\t\tif (__put_user(revents, &uevent->events) ||\n\t\t\t    __put_user(epi->event.data, &uevent->data)) {\n\t\t\t\tlist_add(&epi->rdllink, head);\n\t\t\t\tep_pm_stay_awake(epi);\n\t\t\t\treturn eventcnt ? eventcnt : -EFAULT;\n\t\t\t}\n\t\t\teventcnt++;\n\t\t\tuevent++;\n\t\t\tif (epi->event.events & EPOLLONESHOT)\n\t\t\t\tepi->event.events &= EP_PRIVATE_BITS;\n\t\t\telse if (!(epi->event.events & EPOLLET)) {\n\t\t\t\t/*\n\t\t\t\t * If this file has been added with Level\n\t\t\t\t * Trigger mode, we need to insert back inside\n\t\t\t\t * the ready list, so that the next call to\n\t\t\t\t * epoll_wait() will check again the events\n\t\t\t\t * availability. At this point, no one can insert\n\t\t\t\t * into ep->rdllist besides us. The epoll_ctl()\n\t\t\t\t * callers are locked out by\n\t\t\t\t * ep_scan_ready_list() holding \"mtx\" and the\n\t\t\t\t * poll callback will queue them in ep->ovflist.\n\t\t\t\t */\n\t\t\t\tlist_add_tail(&epi->rdllink, &ep->rdllist);\n\t\t\t\tep_pm_stay_awake(epi);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn eventcnt;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define EP_PRIVATE_BITS (EPOLLWAKEUP | EPOLLONESHOT | EPOLLET)"
    ],
    "globals_used": [
      "static void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,\n\t\t\t\t poll_table *pt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ep_pm_stay_awake",
          "args": [
            "epi"
          ],
          "line": 1538
        },
        "resolved": true,
        "details": {
          "function_name": "ep_pm_stay_awake_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
          "lines": "568-577",
          "snippet": "static inline void ep_pm_stay_awake_rcu(struct epitem *epi)\n{\n\tstruct wakeup_source *ws;\n\n\trcu_read_lock();\n\tws = rcu_dereference(epi->ws);\n\tif (ws)\n\t\t__pm_stay_awake(ws);\n\trcu_read_unlock();\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline void ep_pm_stay_awake_rcu(struct epitem *epi)\n{\n\tstruct wakeup_source *ws;\n\n\trcu_read_lock();\n\tws = rcu_dereference(epi->ws);\n\tif (ws)\n\t\t__pm_stay_awake(ws);\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&epi->rdllink",
            "&ep->rdllist"
          ],
          "line": 1537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&epi->rdllink",
            "head"
          ],
          "line": 1517
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "epi->event.data",
            "&uevent->data"
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "revents",
            "&uevent->events"
          ],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_item_poll",
          "args": [
            "epi",
            "&pt"
          ],
          "line": 1506
        },
        "resolved": true,
        "details": {
          "function_name": "ep_item_poll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
          "lines": "796-801",
          "snippet": "static inline unsigned int ep_item_poll(struct epitem *epi, poll_table *pt)\n{\n\tpt->_key = epi->event.events;\n\n\treturn epi->ffd.file->f_op->poll(epi->ffd.file, pt) & epi->event.events;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,\n\t\t\t\t poll_table *pt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,\n\t\t\t\t poll_table *pt);\n\nstatic inline unsigned int ep_item_poll(struct epitem *epi, poll_table *pt)\n{\n\tpt->_key = epi->event.events;\n\n\treturn epi->ffd.file->f_op->poll(epi->ffd.file, pt) & epi->event.events;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&epi->rdllink"
          ],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pm_relax",
          "args": [
            "ws"
          ],
          "line": 1501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pm_stay_awake",
          "args": [
            "ep->ws"
          ],
          "line": 1500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_wakeup_source",
          "args": [
            "epi"
          ],
          "line": 1497
        },
        "resolved": true,
        "details": {
          "function_name": "ep_wakeup_source",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
          "lines": "548-551",
          "snippet": "static inline struct wakeup_source *ep_wakeup_source(struct epitem *epi)\n{\n\treturn rcu_dereference_check(epi->ws, lockdep_is_held(&epi->ep->mtx));\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline struct wakeup_source *ep_wakeup_source(struct epitem *epi)\n{\n\treturn rcu_dereference_check(epi->ws, lockdep_is_held(&epi->ep->mtx));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "head",
            "structepitem",
            "rdllink"
          ],
          "line": 1486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "head"
          ],
          "line": 1485
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_poll_funcptr",
          "args": [
            "&pt",
            "NULL"
          ],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define EP_PRIVATE_BITS (EPOLLWAKEUP | EPOLLONESHOT | EPOLLET)\n\nstatic void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,\n\t\t\t\t poll_table *pt);\n\nstatic int ep_send_events_proc(struct eventpoll *ep, struct list_head *head,\n\t\t\t       void *priv)\n{\n\tstruct ep_send_events_data *esed = priv;\n\tint eventcnt;\n\tunsigned int revents;\n\tstruct epitem *epi;\n\tstruct epoll_event __user *uevent;\n\tstruct wakeup_source *ws;\n\tpoll_table pt;\n\n\tinit_poll_funcptr(&pt, NULL);\n\n\t/*\n\t * We can loop without lock because we are passed a task private list.\n\t * Items cannot vanish during the loop because ep_scan_ready_list() is\n\t * holding \"mtx\" during this call.\n\t */\n\tfor (eventcnt = 0, uevent = esed->events;\n\t     !list_empty(head) && eventcnt < esed->maxevents;) {\n\t\tepi = list_first_entry(head, struct epitem, rdllink);\n\n\t\t/*\n\t\t * Activate ep->ws before deactivating epi->ws to prevent\n\t\t * triggering auto-suspend here (in case we reactive epi->ws\n\t\t * below).\n\t\t *\n\t\t * This could be rearranged to delay the deactivation of epi->ws\n\t\t * instead, but then epi->ws would temporarily be out of sync\n\t\t * with ep_is_linked().\n\t\t */\n\t\tws = ep_wakeup_source(epi);\n\t\tif (ws) {\n\t\t\tif (ws->active)\n\t\t\t\t__pm_stay_awake(ep->ws);\n\t\t\t__pm_relax(ws);\n\t\t}\n\n\t\tlist_del_init(&epi->rdllink);\n\n\t\trevents = ep_item_poll(epi, &pt);\n\n\t\t/*\n\t\t * If the event mask intersect the caller-requested one,\n\t\t * deliver the event to userspace. Again, ep_scan_ready_list()\n\t\t * is holding \"mtx\", so no operations coming from userspace\n\t\t * can change the item.\n\t\t */\n\t\tif (revents) {\n\t\t\tif (__put_user(revents, &uevent->events) ||\n\t\t\t    __put_user(epi->event.data, &uevent->data)) {\n\t\t\t\tlist_add(&epi->rdllink, head);\n\t\t\t\tep_pm_stay_awake(epi);\n\t\t\t\treturn eventcnt ? eventcnt : -EFAULT;\n\t\t\t}\n\t\t\teventcnt++;\n\t\t\tuevent++;\n\t\t\tif (epi->event.events & EPOLLONESHOT)\n\t\t\t\tepi->event.events &= EP_PRIVATE_BITS;\n\t\t\telse if (!(epi->event.events & EPOLLET)) {\n\t\t\t\t/*\n\t\t\t\t * If this file has been added with Level\n\t\t\t\t * Trigger mode, we need to insert back inside\n\t\t\t\t * the ready list, so that the next call to\n\t\t\t\t * epoll_wait() will check again the events\n\t\t\t\t * availability. At this point, no one can insert\n\t\t\t\t * into ep->rdllist besides us. The epoll_ctl()\n\t\t\t\t * callers are locked out by\n\t\t\t\t * ep_scan_ready_list() holding \"mtx\" and the\n\t\t\t\t * poll callback will queue them in ep->ovflist.\n\t\t\t\t */\n\t\t\t\tlist_add_tail(&epi->rdllink, &ep->rdllist);\n\t\t\t\tep_pm_stay_awake(epi);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn eventcnt;\n}"
  },
  {
    "function_name": "ep_modify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
    "lines": "1392-1464",
    "snippet": "static int ep_modify(struct eventpoll *ep, struct epitem *epi, struct epoll_event *event)\n{\n\tint pwake = 0;\n\tunsigned int revents;\n\tpoll_table pt;\n\n\tinit_poll_funcptr(&pt, NULL);\n\n\t/*\n\t * Set the new event interest mask before calling f_op->poll();\n\t * otherwise we might miss an event that happens between the\n\t * f_op->poll() call and the new event set registering.\n\t */\n\tepi->event.events = event->events; /* need barrier below */\n\tepi->event.data = event->data; /* protected by mtx */\n\tif (epi->event.events & EPOLLWAKEUP) {\n\t\tif (!ep_has_wakeup_source(epi))\n\t\t\tep_create_wakeup_source(epi);\n\t} else if (ep_has_wakeup_source(epi)) {\n\t\tep_destroy_wakeup_source(epi);\n\t}\n\n\t/*\n\t * The following barrier has two effects:\n\t *\n\t * 1) Flush epi changes above to other CPUs.  This ensures\n\t *    we do not miss events from ep_poll_callback if an\n\t *    event occurs immediately after we call f_op->poll().\n\t *    We need this because we did not take ep->lock while\n\t *    changing epi above (but ep_poll_callback does take\n\t *    ep->lock).\n\t *\n\t * 2) We also need to ensure we do not miss _past_ events\n\t *    when calling f_op->poll().  This barrier also\n\t *    pairs with the barrier in wq_has_sleeper (see\n\t *    comments for wq_has_sleeper).\n\t *\n\t * This barrier will now guarantee ep_poll_callback or f_op->poll\n\t * (or both) will notice the readiness of an item.\n\t */\n\tsmp_mb();\n\n\t/*\n\t * Get current event bits. We can safely use the file* here because\n\t * its usage count has been increased by the caller of this function.\n\t */\n\trevents = ep_item_poll(epi, &pt);\n\n\t/*\n\t * If the item is \"hot\" and it is not registered inside the ready\n\t * list, push it inside.\n\t */\n\tif (revents & event->events) {\n\t\tspin_lock_irq(&ep->lock);\n\t\tif (!ep_is_linked(&epi->rdllink)) {\n\t\t\tlist_add_tail(&epi->rdllink, &ep->rdllist);\n\t\t\tep_pm_stay_awake(epi);\n\n\t\t\t/* Notify waiting tasks that events are available */\n\t\t\tif (waitqueue_active(&ep->wq))\n\t\t\t\twake_up_locked(&ep->wq);\n\t\t\tif (waitqueue_active(&ep->poll_wait))\n\t\t\t\tpwake++;\n\t\t}\n\t\tspin_unlock_irq(&ep->lock);\n\t}\n\n\t/* We have to call this outside the lock */\n\tif (pwake)\n\t\tep_poll_safewake(&ep->poll_wait);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,\n\t\t\t\t poll_table *pt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ep_poll_safewake",
          "args": [
            "&ep->poll_wait"
          ],
          "line": 1461
        },
        "resolved": true,
        "details": {
          "function_name": "ep_poll_safewake",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
          "lines": "506-514",
          "snippet": "static void ep_poll_safewake(wait_queue_head_t *wq)\n{\n\tint this_cpu = get_cpu();\n\n\tep_call_nested(&poll_safewake_ncalls, EP_MAX_NESTS,\n\t\t       ep_poll_wakeup_proc, NULL, wq, (void *) (long) this_cpu);\n\n\tput_cpu();\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define EP_MAX_NESTS 4"
          ],
          "globals_used": [
            "static struct nested_calls poll_safewake_ncalls;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define EP_MAX_NESTS 4\n\nstatic struct nested_calls poll_safewake_ncalls;\n\nstatic void ep_poll_safewake(wait_queue_head_t *wq)\n{\n\tint this_cpu = get_cpu();\n\n\tep_call_nested(&poll_safewake_ncalls, EP_MAX_NESTS,\n\t\t       ep_poll_wakeup_proc, NULL, wq, (void *) (long) this_cpu);\n\n\tput_cpu();\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&ep->lock"
          ],
          "line": 1456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&ep->poll_wait"
          ],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_locked",
          "args": [
            "&ep->wq"
          ],
          "line": 1452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&ep->wq"
          ],
          "line": 1451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_pm_stay_awake",
          "args": [
            "epi"
          ],
          "line": 1448
        },
        "resolved": true,
        "details": {
          "function_name": "ep_pm_stay_awake_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
          "lines": "568-577",
          "snippet": "static inline void ep_pm_stay_awake_rcu(struct epitem *epi)\n{\n\tstruct wakeup_source *ws;\n\n\trcu_read_lock();\n\tws = rcu_dereference(epi->ws);\n\tif (ws)\n\t\t__pm_stay_awake(ws);\n\trcu_read_unlock();\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline void ep_pm_stay_awake_rcu(struct epitem *epi)\n{\n\tstruct wakeup_source *ws;\n\n\trcu_read_lock();\n\tws = rcu_dereference(epi->ws);\n\tif (ws)\n\t\t__pm_stay_awake(ws);\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&epi->rdllink",
            "&ep->rdllist"
          ],
          "line": 1447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_is_linked",
          "args": [
            "&epi->rdllink"
          ],
          "line": 1446
        },
        "resolved": true,
        "details": {
          "function_name": "ep_is_linked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
          "lines": "334-337",
          "snippet": "static inline int ep_is_linked(struct list_head *p)\n{\n\treturn !list_empty(p);\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline int ep_is_linked(struct list_head *p)\n{\n\treturn !list_empty(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&ep->lock"
          ],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_item_poll",
          "args": [
            "epi",
            "&pt"
          ],
          "line": 1438
        },
        "resolved": true,
        "details": {
          "function_name": "ep_item_poll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
          "lines": "796-801",
          "snippet": "static inline unsigned int ep_item_poll(struct epitem *epi, poll_table *pt)\n{\n\tpt->_key = epi->event.events;\n\n\treturn epi->ffd.file->f_op->poll(epi->ffd.file, pt) & epi->event.events;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,\n\t\t\t\t poll_table *pt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,\n\t\t\t\t poll_table *pt);\n\nstatic inline unsigned int ep_item_poll(struct epitem *epi, poll_table *pt)\n{\n\tpt->_key = epi->event.events;\n\n\treturn epi->ffd.file->f_op->poll(epi->ffd.file, pt) & epi->event.events;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 1432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_destroy_wakeup_source",
          "args": [
            "epi"
          ],
          "line": 1411
        },
        "resolved": true,
        "details": {
          "function_name": "ep_destroy_wakeup_source",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
          "lines": "1246-1259",
          "snippet": "static noinline void ep_destroy_wakeup_source(struct epitem *epi)\n{\n\tstruct wakeup_source *ws = ep_wakeup_source(epi);\n\n\tRCU_INIT_POINTER(epi->ws, NULL);\n\n\t/*\n\t * wait for ep_pm_stay_awake_rcu to finish, synchronize_rcu is\n\t * used internally by wakeup_source_remove, too (called by\n\t * wakeup_source_unregister), so we cannot use call_rcu\n\t */\n\tsynchronize_rcu();\n\twakeup_source_unregister(ws);\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic noinline void ep_destroy_wakeup_source(struct epitem *epi)\n{\n\tstruct wakeup_source *ws = ep_wakeup_source(epi);\n\n\tRCU_INIT_POINTER(epi->ws, NULL);\n\n\t/*\n\t * wait for ep_pm_stay_awake_rcu to finish, synchronize_rcu is\n\t * used internally by wakeup_source_remove, too (called by\n\t * wakeup_source_unregister), so we cannot use call_rcu\n\t */\n\tsynchronize_rcu();\n\twakeup_source_unregister(ws);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ep_has_wakeup_source",
          "args": [
            "epi"
          ],
          "line": 1410
        },
        "resolved": true,
        "details": {
          "function_name": "ep_has_wakeup_source",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
          "lines": "562-565",
          "snippet": "static inline bool ep_has_wakeup_source(struct epitem *epi)\n{\n\treturn rcu_access_pointer(epi->ws) ? true : false;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline bool ep_has_wakeup_source(struct epitem *epi)\n{\n\treturn rcu_access_pointer(epi->ws) ? true : false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ep_create_wakeup_source",
          "args": [
            "epi"
          ],
          "line": 1409
        },
        "resolved": true,
        "details": {
          "function_name": "ep_create_wakeup_source",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
          "lines": "1224-1243",
          "snippet": "static int ep_create_wakeup_source(struct epitem *epi)\n{\n\tconst char *name;\n\tstruct wakeup_source *ws;\n\n\tif (!epi->ep->ws) {\n\t\tepi->ep->ws = wakeup_source_register(\"eventpoll\");\n\t\tif (!epi->ep->ws)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tname = epi->ffd.file->f_path.dentry->d_name.name;\n\tws = wakeup_source_register(name);\n\n\tif (!ws)\n\t\treturn -ENOMEM;\n\trcu_assign_pointer(epi->ws, ws);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int ep_create_wakeup_source(struct epitem *epi)\n{\n\tconst char *name;\n\tstruct wakeup_source *ws;\n\n\tif (!epi->ep->ws) {\n\t\tepi->ep->ws = wakeup_source_register(\"eventpoll\");\n\t\tif (!epi->ep->ws)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tname = epi->ffd.file->f_path.dentry->d_name.name;\n\tws = wakeup_source_register(name);\n\n\tif (!ws)\n\t\treturn -ENOMEM;\n\trcu_assign_pointer(epi->ws, ws);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_poll_funcptr",
          "args": [
            "&pt",
            "NULL"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,\n\t\t\t\t poll_table *pt);\n\nstatic int ep_modify(struct eventpoll *ep, struct epitem *epi, struct epoll_event *event)\n{\n\tint pwake = 0;\n\tunsigned int revents;\n\tpoll_table pt;\n\n\tinit_poll_funcptr(&pt, NULL);\n\n\t/*\n\t * Set the new event interest mask before calling f_op->poll();\n\t * otherwise we might miss an event that happens between the\n\t * f_op->poll() call and the new event set registering.\n\t */\n\tepi->event.events = event->events; /* need barrier below */\n\tepi->event.data = event->data; /* protected by mtx */\n\tif (epi->event.events & EPOLLWAKEUP) {\n\t\tif (!ep_has_wakeup_source(epi))\n\t\t\tep_create_wakeup_source(epi);\n\t} else if (ep_has_wakeup_source(epi)) {\n\t\tep_destroy_wakeup_source(epi);\n\t}\n\n\t/*\n\t * The following barrier has two effects:\n\t *\n\t * 1) Flush epi changes above to other CPUs.  This ensures\n\t *    we do not miss events from ep_poll_callback if an\n\t *    event occurs immediately after we call f_op->poll().\n\t *    We need this because we did not take ep->lock while\n\t *    changing epi above (but ep_poll_callback does take\n\t *    ep->lock).\n\t *\n\t * 2) We also need to ensure we do not miss _past_ events\n\t *    when calling f_op->poll().  This barrier also\n\t *    pairs with the barrier in wq_has_sleeper (see\n\t *    comments for wq_has_sleeper).\n\t *\n\t * This barrier will now guarantee ep_poll_callback or f_op->poll\n\t * (or both) will notice the readiness of an item.\n\t */\n\tsmp_mb();\n\n\t/*\n\t * Get current event bits. We can safely use the file* here because\n\t * its usage count has been increased by the caller of this function.\n\t */\n\trevents = ep_item_poll(epi, &pt);\n\n\t/*\n\t * If the item is \"hot\" and it is not registered inside the ready\n\t * list, push it inside.\n\t */\n\tif (revents & event->events) {\n\t\tspin_lock_irq(&ep->lock);\n\t\tif (!ep_is_linked(&epi->rdllink)) {\n\t\t\tlist_add_tail(&epi->rdllink, &ep->rdllist);\n\t\t\tep_pm_stay_awake(epi);\n\n\t\t\t/* Notify waiting tasks that events are available */\n\t\t\tif (waitqueue_active(&ep->wq))\n\t\t\t\twake_up_locked(&ep->wq);\n\t\t\tif (waitqueue_active(&ep->poll_wait))\n\t\t\t\tpwake++;\n\t\t}\n\t\tspin_unlock_irq(&ep->lock);\n\t}\n\n\t/* We have to call this outside the lock */\n\tif (pwake)\n\t\tep_poll_safewake(&ep->poll_wait);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ep_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
    "lines": "1264-1386",
    "snippet": "static int ep_insert(struct eventpoll *ep, struct epoll_event *event,\n\t\t     struct file *tfile, int fd, int full_check)\n{\n\tint error, revents, pwake = 0;\n\tunsigned long flags;\n\tlong user_watches;\n\tstruct epitem *epi;\n\tstruct ep_pqueue epq;\n\n\tuser_watches = atomic_long_read(&ep->user->epoll_watches);\n\tif (unlikely(user_watches >= max_user_watches))\n\t\treturn -ENOSPC;\n\tif (!(epi = kmem_cache_alloc(epi_cache, GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\n\t/* Item initialization follow here ... */\n\tINIT_LIST_HEAD(&epi->rdllink);\n\tINIT_LIST_HEAD(&epi->fllink);\n\tINIT_LIST_HEAD(&epi->pwqlist);\n\tepi->ep = ep;\n\tep_set_ffd(&epi->ffd, tfile, fd);\n\tepi->event = *event;\n\tepi->nwait = 0;\n\tepi->next = EP_UNACTIVE_PTR;\n\tif (epi->event.events & EPOLLWAKEUP) {\n\t\terror = ep_create_wakeup_source(epi);\n\t\tif (error)\n\t\t\tgoto error_create_wakeup_source;\n\t} else {\n\t\tRCU_INIT_POINTER(epi->ws, NULL);\n\t}\n\n\t/* Initialize the poll table using the queue callback */\n\tepq.epi = epi;\n\tinit_poll_funcptr(&epq.pt, ep_ptable_queue_proc);\n\n\t/*\n\t * Attach the item to the poll hooks and get current event bits.\n\t * We can safely use the file* here because its usage count has\n\t * been increased by the caller of this function. Note that after\n\t * this operation completes, the poll callback can start hitting\n\t * the new item.\n\t */\n\trevents = ep_item_poll(epi, &epq.pt);\n\n\t/*\n\t * We have to check if something went wrong during the poll wait queue\n\t * install process. Namely an allocation for a wait queue failed due\n\t * high memory pressure.\n\t */\n\terror = -ENOMEM;\n\tif (epi->nwait < 0)\n\t\tgoto error_unregister;\n\n\t/* Add the current item to the list of active epoll hook for this file */\n\tspin_lock(&tfile->f_lock);\n\tlist_add_tail_rcu(&epi->fllink, &tfile->f_ep_links);\n\tspin_unlock(&tfile->f_lock);\n\n\t/*\n\t * Add the current item to the RB tree. All RB tree operations are\n\t * protected by \"mtx\", and ep_insert() is called with \"mtx\" held.\n\t */\n\tep_rbtree_insert(ep, epi);\n\n\t/* now check if we've created too many backpaths */\n\terror = -EINVAL;\n\tif (full_check && reverse_path_check())\n\t\tgoto error_remove_epi;\n\n\t/* We have to drop the new item inside our item list to keep track of it */\n\tspin_lock_irqsave(&ep->lock, flags);\n\n\t/* If the file is already \"ready\" we drop it inside the ready list */\n\tif ((revents & event->events) && !ep_is_linked(&epi->rdllink)) {\n\t\tlist_add_tail(&epi->rdllink, &ep->rdllist);\n\t\tep_pm_stay_awake(epi);\n\n\t\t/* Notify waiting tasks that events are available */\n\t\tif (waitqueue_active(&ep->wq))\n\t\t\twake_up_locked(&ep->wq);\n\t\tif (waitqueue_active(&ep->poll_wait))\n\t\t\tpwake++;\n\t}\n\n\tspin_unlock_irqrestore(&ep->lock, flags);\n\n\tatomic_long_inc(&ep->user->epoll_watches);\n\n\t/* We have to call this outside the lock */\n\tif (pwake)\n\t\tep_poll_safewake(&ep->poll_wait);\n\n\treturn 0;\n\nerror_remove_epi:\n\tspin_lock(&tfile->f_lock);\n\tlist_del_rcu(&epi->fllink);\n\tspin_unlock(&tfile->f_lock);\n\n\trb_erase(&epi->rbn, &ep->rbr);\n\nerror_unregister:\n\tep_unregister_pollwait(ep, epi);\n\n\t/*\n\t * We need to do this because an event could have been arrived on some\n\t * allocated wait queue. Note that we don't care about the ep->ovflist\n\t * list, since that is used/cleaned only inside a section bound by \"mtx\".\n\t * And ep_insert() is called with \"mtx\" held.\n\t */\n\tspin_lock_irqsave(&ep->lock, flags);\n\tif (ep_is_linked(&epi->rdllink))\n\t\tlist_del_init(&epi->rdllink);\n\tspin_unlock_irqrestore(&ep->lock, flags);\n\n\twakeup_source_unregister(ep_wakeup_source(epi));\n\nerror_create_wakeup_source:\n\tkmem_cache_free(epi_cache, epi);\n\n\treturn error;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define EP_UNACTIVE_PTR ((void *) -1L)"
    ],
    "globals_used": [
      "static void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,\n\t\t\t\t poll_table *pt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "epi_cache",
            "epi"
          ],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakeup_source_unregister",
          "args": [
            "ep_wakeup_source(epi)"
          ],
          "line": 1380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_wakeup_source",
          "args": [
            "epi"
          ],
          "line": 1380
        },
        "resolved": true,
        "details": {
          "function_name": "ep_wakeup_source",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
          "lines": "548-551",
          "snippet": "static inline struct wakeup_source *ep_wakeup_source(struct epitem *epi)\n{\n\treturn rcu_dereference_check(epi->ws, lockdep_is_held(&epi->ep->mtx));\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline struct wakeup_source *ep_wakeup_source(struct epitem *epi)\n{\n\treturn rcu_dereference_check(epi->ws, lockdep_is_held(&epi->ep->mtx));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&ep->lock",
            "flags"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&epi->rdllink"
          ],
          "line": 1377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_is_linked",
          "args": [
            "&epi->rdllink"
          ],
          "line": 1376
        },
        "resolved": true,
        "details": {
          "function_name": "ep_is_linked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
          "lines": "334-337",
          "snippet": "static inline int ep_is_linked(struct list_head *p)\n{\n\treturn !list_empty(p);\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline int ep_is_linked(struct list_head *p)\n{\n\treturn !list_empty(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&ep->lock",
            "flags"
          ],
          "line": 1375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_unregister_pollwait",
          "args": [
            "ep",
            "epi"
          ],
          "line": 1367
        },
        "resolved": true,
        "details": {
          "function_name": "ep_unregister_pollwait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
          "lines": "533-545",
          "snippet": "static void ep_unregister_pollwait(struct eventpoll *ep, struct epitem *epi)\n{\n\tstruct list_head *lsthead = &epi->pwqlist;\n\tstruct eppoll_entry *pwq;\n\n\twhile (!list_empty(lsthead)) {\n\t\tpwq = list_first_entry(lsthead, struct eppoll_entry, llink);\n\n\t\tlist_del(&pwq->llink);\n\t\tep_remove_wait_queue(pwq);\n\t\tkmem_cache_free(pwq_cache, pwq);\n\t}\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void ep_unregister_pollwait(struct eventpoll *ep, struct epitem *epi)\n{\n\tstruct list_head *lsthead = &epi->pwqlist;\n\tstruct eppoll_entry *pwq;\n\n\twhile (!list_empty(lsthead)) {\n\t\tpwq = list_first_entry(lsthead, struct eppoll_entry, llink);\n\n\t\tlist_del(&pwq->llink);\n\t\tep_remove_wait_queue(pwq);\n\t\tkmem_cache_free(pwq_cache, pwq);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&epi->rbn",
            "&ep->rbr"
          ],
          "line": 1364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&tfile->f_lock"
          ],
          "line": 1362
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&epi->fllink"
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&tfile->f_lock"
          ],
          "line": 1360
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ep_poll_safewake",
          "args": [
            "&ep->poll_wait"
          ],
          "line": 1355
        },
        "resolved": true,
        "details": {
          "function_name": "ep_poll_safewake",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
          "lines": "506-514",
          "snippet": "static void ep_poll_safewake(wait_queue_head_t *wq)\n{\n\tint this_cpu = get_cpu();\n\n\tep_call_nested(&poll_safewake_ncalls, EP_MAX_NESTS,\n\t\t       ep_poll_wakeup_proc, NULL, wq, (void *) (long) this_cpu);\n\n\tput_cpu();\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define EP_MAX_NESTS 4"
          ],
          "globals_used": [
            "static struct nested_calls poll_safewake_ncalls;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define EP_MAX_NESTS 4\n\nstatic struct nested_calls poll_safewake_ncalls;\n\nstatic void ep_poll_safewake(wait_queue_head_t *wq)\n{\n\tint this_cpu = get_cpu();\n\n\tep_call_nested(&poll_safewake_ncalls, EP_MAX_NESTS,\n\t\t       ep_poll_wakeup_proc, NULL, wq, (void *) (long) this_cpu);\n\n\tput_cpu();\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_long_inc",
          "args": [
            "&ep->user->epoll_watches"
          ],
          "line": 1351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&ep->lock",
            "flags"
          ],
          "line": 1349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&ep->poll_wait"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_locked",
          "args": [
            "&ep->wq"
          ],
          "line": 1344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&ep->wq"
          ],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_pm_stay_awake",
          "args": [
            "epi"
          ],
          "line": 1340
        },
        "resolved": true,
        "details": {
          "function_name": "ep_pm_stay_awake_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
          "lines": "568-577",
          "snippet": "static inline void ep_pm_stay_awake_rcu(struct epitem *epi)\n{\n\tstruct wakeup_source *ws;\n\n\trcu_read_lock();\n\tws = rcu_dereference(epi->ws);\n\tif (ws)\n\t\t__pm_stay_awake(ws);\n\trcu_read_unlock();\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline void ep_pm_stay_awake_rcu(struct epitem *epi)\n{\n\tstruct wakeup_source *ws;\n\n\trcu_read_lock();\n\tws = rcu_dereference(epi->ws);\n\tif (ws)\n\t\t__pm_stay_awake(ws);\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&epi->rdllink",
            "&ep->rdllist"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&ep->lock",
            "flags"
          ],
          "line": 1335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reverse_path_check",
          "args": [],
          "line": 1331
        },
        "resolved": true,
        "details": {
          "function_name": "reverse_path_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
          "lines": "1207-1222",
          "snippet": "static int reverse_path_check(void)\n{\n\tint error = 0;\n\tstruct file *current_file;\n\n\t/* let's call this for all tfiles */\n\tlist_for_each_entry(current_file, &tfile_check_list, f_tfile_llink) {\n\t\tpath_count_init();\n\t\terror = ep_call_nested(&poll_loop_ncalls, EP_MAX_NESTS,\n\t\t\t\t\treverse_path_check_proc, current_file,\n\t\t\t\t\tcurrent_file, current);\n\t\tif (error)\n\t\t\tbreak;\n\t}\n\treturn error;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define EP_MAX_NESTS 4"
          ],
          "globals_used": [
            "static struct nested_calls poll_loop_ncalls;",
            "static LIST_HEAD(tfile_check_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define EP_MAX_NESTS 4\n\nstatic struct nested_calls poll_loop_ncalls;\nstatic LIST_HEAD(tfile_check_list);\n\nstatic int reverse_path_check(void)\n{\n\tint error = 0;\n\tstruct file *current_file;\n\n\t/* let's call this for all tfiles */\n\tlist_for_each_entry(current_file, &tfile_check_list, f_tfile_llink) {\n\t\tpath_count_init();\n\t\terror = ep_call_nested(&poll_loop_ncalls, EP_MAX_NESTS,\n\t\t\t\t\treverse_path_check_proc, current_file,\n\t\t\t\t\tcurrent_file, current);\n\t\tif (error)\n\t\t\tbreak;\n\t}\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ep_rbtree_insert",
          "args": [
            "ep",
            "epi"
          ],
          "line": 1327
        },
        "resolved": true,
        "details": {
          "function_name": "ep_rbtree_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
          "lines": "1107-1124",
          "snippet": "static void ep_rbtree_insert(struct eventpoll *ep, struct epitem *epi)\n{\n\tint kcmp;\n\tstruct rb_node **p = &ep->rbr.rb_node, *parent = NULL;\n\tstruct epitem *epic;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tepic = rb_entry(parent, struct epitem, rbn);\n\t\tkcmp = ep_cmp_ffd(&epi->ffd, &epic->ffd);\n\t\tif (kcmp > 0)\n\t\t\tp = &parent->rb_right;\n\t\telse\n\t\t\tp = &parent->rb_left;\n\t}\n\trb_link_node(&epi->rbn, parent, p);\n\trb_insert_color(&epi->rbn, &ep->rbr);\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void ep_rbtree_insert(struct eventpoll *ep, struct epitem *epi)\n{\n\tint kcmp;\n\tstruct rb_node **p = &ep->rbr.rb_node, *parent = NULL;\n\tstruct epitem *epic;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tepic = rb_entry(parent, struct epitem, rbn);\n\t\tkcmp = ep_cmp_ffd(&epi->ffd, &epic->ffd);\n\t\tif (kcmp > 0)\n\t\t\tp = &parent->rb_right;\n\t\telse\n\t\t\tp = &parent->rb_left;\n\t}\n\trb_link_node(&epi->rbn, parent, p);\n\trb_insert_color(&epi->rbn, &ep->rbr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail_rcu",
          "args": [
            "&epi->fllink",
            "&tfile->f_ep_links"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_item_poll",
          "args": [
            "epi",
            "&epq.pt"
          ],
          "line": 1307
        },
        "resolved": true,
        "details": {
          "function_name": "ep_item_poll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
          "lines": "796-801",
          "snippet": "static inline unsigned int ep_item_poll(struct epitem *epi, poll_table *pt)\n{\n\tpt->_key = epi->event.events;\n\n\treturn epi->ffd.file->f_op->poll(epi->ffd.file, pt) & epi->event.events;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,\n\t\t\t\t poll_table *pt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,\n\t\t\t\t poll_table *pt);\n\nstatic inline unsigned int ep_item_poll(struct epitem *epi, poll_table *pt)\n{\n\tpt->_key = epi->event.events;\n\n\treturn epi->ffd.file->f_op->poll(epi->ffd.file, pt) & epi->event.events;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_poll_funcptr",
          "args": [
            "&epq.pt",
            "ep_ptable_queue_proc"
          ],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RCU_INIT_POINTER",
          "args": [
            "epi->ws",
            "NULL"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_create_wakeup_source",
          "args": [
            "epi"
          ],
          "line": 1289
        },
        "resolved": true,
        "details": {
          "function_name": "ep_create_wakeup_source",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
          "lines": "1224-1243",
          "snippet": "static int ep_create_wakeup_source(struct epitem *epi)\n{\n\tconst char *name;\n\tstruct wakeup_source *ws;\n\n\tif (!epi->ep->ws) {\n\t\tepi->ep->ws = wakeup_source_register(\"eventpoll\");\n\t\tif (!epi->ep->ws)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tname = epi->ffd.file->f_path.dentry->d_name.name;\n\tws = wakeup_source_register(name);\n\n\tif (!ws)\n\t\treturn -ENOMEM;\n\trcu_assign_pointer(epi->ws, ws);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int ep_create_wakeup_source(struct epitem *epi)\n{\n\tconst char *name;\n\tstruct wakeup_source *ws;\n\n\tif (!epi->ep->ws) {\n\t\tepi->ep->ws = wakeup_source_register(\"eventpoll\");\n\t\tif (!epi->ep->ws)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tname = epi->ffd.file->f_path.dentry->d_name.name;\n\tws = wakeup_source_register(name);\n\n\tif (!ws)\n\t\treturn -ENOMEM;\n\trcu_assign_pointer(epi->ws, ws);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ep_set_ffd",
          "args": [
            "&epi->ffd",
            "tfile",
            "fd"
          ],
          "line": 1284
        },
        "resolved": true,
        "details": {
          "function_name": "ep_set_ffd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
          "lines": "318-323",
          "snippet": "static inline void ep_set_ffd(struct epoll_filefd *ffd,\n\t\t\t      struct file *file, int fd)\n{\n\tffd->file = file;\n\tffd->fd = fd;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline void ep_set_ffd(struct epoll_filefd *ffd,\n\t\t\t      struct file *file, int fd)\n{\n\tffd->file = file;\n\tffd->fd = fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&epi->pwqlist"
          ],
          "line": 1282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&epi->fllink"
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&epi->rdllink"
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "epi_cache",
            "GFP_KERNEL"
          ],
          "line": 1276
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "user_watches >= max_user_watches"
          ],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&ep->user->epoll_watches"
          ],
          "line": 1273
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define EP_UNACTIVE_PTR ((void *) -1L)\n\nstatic void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,\n\t\t\t\t poll_table *pt);\n\nstatic int ep_insert(struct eventpoll *ep, struct epoll_event *event,\n\t\t     struct file *tfile, int fd, int full_check)\n{\n\tint error, revents, pwake = 0;\n\tunsigned long flags;\n\tlong user_watches;\n\tstruct epitem *epi;\n\tstruct ep_pqueue epq;\n\n\tuser_watches = atomic_long_read(&ep->user->epoll_watches);\n\tif (unlikely(user_watches >= max_user_watches))\n\t\treturn -ENOSPC;\n\tif (!(epi = kmem_cache_alloc(epi_cache, GFP_KERNEL)))\n\t\treturn -ENOMEM;\n\n\t/* Item initialization follow here ... */\n\tINIT_LIST_HEAD(&epi->rdllink);\n\tINIT_LIST_HEAD(&epi->fllink);\n\tINIT_LIST_HEAD(&epi->pwqlist);\n\tepi->ep = ep;\n\tep_set_ffd(&epi->ffd, tfile, fd);\n\tepi->event = *event;\n\tepi->nwait = 0;\n\tepi->next = EP_UNACTIVE_PTR;\n\tif (epi->event.events & EPOLLWAKEUP) {\n\t\terror = ep_create_wakeup_source(epi);\n\t\tif (error)\n\t\t\tgoto error_create_wakeup_source;\n\t} else {\n\t\tRCU_INIT_POINTER(epi->ws, NULL);\n\t}\n\n\t/* Initialize the poll table using the queue callback */\n\tepq.epi = epi;\n\tinit_poll_funcptr(&epq.pt, ep_ptable_queue_proc);\n\n\t/*\n\t * Attach the item to the poll hooks and get current event bits.\n\t * We can safely use the file* here because its usage count has\n\t * been increased by the caller of this function. Note that after\n\t * this operation completes, the poll callback can start hitting\n\t * the new item.\n\t */\n\trevents = ep_item_poll(epi, &epq.pt);\n\n\t/*\n\t * We have to check if something went wrong during the poll wait queue\n\t * install process. Namely an allocation for a wait queue failed due\n\t * high memory pressure.\n\t */\n\terror = -ENOMEM;\n\tif (epi->nwait < 0)\n\t\tgoto error_unregister;\n\n\t/* Add the current item to the list of active epoll hook for this file */\n\tspin_lock(&tfile->f_lock);\n\tlist_add_tail_rcu(&epi->fllink, &tfile->f_ep_links);\n\tspin_unlock(&tfile->f_lock);\n\n\t/*\n\t * Add the current item to the RB tree. All RB tree operations are\n\t * protected by \"mtx\", and ep_insert() is called with \"mtx\" held.\n\t */\n\tep_rbtree_insert(ep, epi);\n\n\t/* now check if we've created too many backpaths */\n\terror = -EINVAL;\n\tif (full_check && reverse_path_check())\n\t\tgoto error_remove_epi;\n\n\t/* We have to drop the new item inside our item list to keep track of it */\n\tspin_lock_irqsave(&ep->lock, flags);\n\n\t/* If the file is already \"ready\" we drop it inside the ready list */\n\tif ((revents & event->events) && !ep_is_linked(&epi->rdllink)) {\n\t\tlist_add_tail(&epi->rdllink, &ep->rdllist);\n\t\tep_pm_stay_awake(epi);\n\n\t\t/* Notify waiting tasks that events are available */\n\t\tif (waitqueue_active(&ep->wq))\n\t\t\twake_up_locked(&ep->wq);\n\t\tif (waitqueue_active(&ep->poll_wait))\n\t\t\tpwake++;\n\t}\n\n\tspin_unlock_irqrestore(&ep->lock, flags);\n\n\tatomic_long_inc(&ep->user->epoll_watches);\n\n\t/* We have to call this outside the lock */\n\tif (pwake)\n\t\tep_poll_safewake(&ep->poll_wait);\n\n\treturn 0;\n\nerror_remove_epi:\n\tspin_lock(&tfile->f_lock);\n\tlist_del_rcu(&epi->fllink);\n\tspin_unlock(&tfile->f_lock);\n\n\trb_erase(&epi->rbn, &ep->rbr);\n\nerror_unregister:\n\tep_unregister_pollwait(ep, epi);\n\n\t/*\n\t * We need to do this because an event could have been arrived on some\n\t * allocated wait queue. Note that we don't care about the ep->ovflist\n\t * list, since that is used/cleaned only inside a section bound by \"mtx\".\n\t * And ep_insert() is called with \"mtx\" held.\n\t */\n\tspin_lock_irqsave(&ep->lock, flags);\n\tif (ep_is_linked(&epi->rdllink))\n\t\tlist_del_init(&epi->rdllink);\n\tspin_unlock_irqrestore(&ep->lock, flags);\n\n\twakeup_source_unregister(ep_wakeup_source(epi));\n\nerror_create_wakeup_source:\n\tkmem_cache_free(epi_cache, epi);\n\n\treturn error;\n}"
  },
  {
    "function_name": "ep_destroy_wakeup_source",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
    "lines": "1246-1259",
    "snippet": "static noinline void ep_destroy_wakeup_source(struct epitem *epi)\n{\n\tstruct wakeup_source *ws = ep_wakeup_source(epi);\n\n\tRCU_INIT_POINTER(epi->ws, NULL);\n\n\t/*\n\t * wait for ep_pm_stay_awake_rcu to finish, synchronize_rcu is\n\t * used internally by wakeup_source_remove, too (called by\n\t * wakeup_source_unregister), so we cannot use call_rcu\n\t */\n\tsynchronize_rcu();\n\twakeup_source_unregister(ws);\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wakeup_source_unregister",
          "args": [
            "ws"
          ],
          "line": 1258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synchronize_rcu",
          "args": [],
          "line": 1257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RCU_INIT_POINTER",
          "args": [
            "epi->ws",
            "NULL"
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_wakeup_source",
          "args": [
            "epi"
          ],
          "line": 1248
        },
        "resolved": true,
        "details": {
          "function_name": "ep_wakeup_source",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
          "lines": "548-551",
          "snippet": "static inline struct wakeup_source *ep_wakeup_source(struct epitem *epi)\n{\n\treturn rcu_dereference_check(epi->ws, lockdep_is_held(&epi->ep->mtx));\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline struct wakeup_source *ep_wakeup_source(struct epitem *epi)\n{\n\treturn rcu_dereference_check(epi->ws, lockdep_is_held(&epi->ep->mtx));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic noinline void ep_destroy_wakeup_source(struct epitem *epi)\n{\n\tstruct wakeup_source *ws = ep_wakeup_source(epi);\n\n\tRCU_INIT_POINTER(epi->ws, NULL);\n\n\t/*\n\t * wait for ep_pm_stay_awake_rcu to finish, synchronize_rcu is\n\t * used internally by wakeup_source_remove, too (called by\n\t * wakeup_source_unregister), so we cannot use call_rcu\n\t */\n\tsynchronize_rcu();\n\twakeup_source_unregister(ws);\n}"
  },
  {
    "function_name": "ep_create_wakeup_source",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
    "lines": "1224-1243",
    "snippet": "static int ep_create_wakeup_source(struct epitem *epi)\n{\n\tconst char *name;\n\tstruct wakeup_source *ws;\n\n\tif (!epi->ep->ws) {\n\t\tepi->ep->ws = wakeup_source_register(\"eventpoll\");\n\t\tif (!epi->ep->ws)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tname = epi->ffd.file->f_path.dentry->d_name.name;\n\tws = wakeup_source_register(name);\n\n\tif (!ws)\n\t\treturn -ENOMEM;\n\trcu_assign_pointer(epi->ws, ws);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "epi->ws",
            "ws"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakeup_source_register",
          "args": [
            "name"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakeup_source_register",
          "args": [
            "\"eventpoll\""
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int ep_create_wakeup_source(struct epitem *epi)\n{\n\tconst char *name;\n\tstruct wakeup_source *ws;\n\n\tif (!epi->ep->ws) {\n\t\tepi->ep->ws = wakeup_source_register(\"eventpoll\");\n\t\tif (!epi->ep->ws)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tname = epi->ffd.file->f_path.dentry->d_name.name;\n\tws = wakeup_source_register(name);\n\n\tif (!ws)\n\t\treturn -ENOMEM;\n\trcu_assign_pointer(epi->ws, ws);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "reverse_path_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
    "lines": "1207-1222",
    "snippet": "static int reverse_path_check(void)\n{\n\tint error = 0;\n\tstruct file *current_file;\n\n\t/* let's call this for all tfiles */\n\tlist_for_each_entry(current_file, &tfile_check_list, f_tfile_llink) {\n\t\tpath_count_init();\n\t\terror = ep_call_nested(&poll_loop_ncalls, EP_MAX_NESTS,\n\t\t\t\t\treverse_path_check_proc, current_file,\n\t\t\t\t\tcurrent_file, current);\n\t\tif (error)\n\t\t\tbreak;\n\t}\n\treturn error;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define EP_MAX_NESTS 4"
    ],
    "globals_used": [
      "static struct nested_calls poll_loop_ncalls;",
      "static LIST_HEAD(tfile_check_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ep_call_nested",
          "args": [
            "&poll_loop_ncalls",
            "EP_MAX_NESTS",
            "reverse_path_check_proc",
            "current_file",
            "current_file",
            "current"
          ],
          "line": 1215
        },
        "resolved": true,
        "details": {
          "function_name": "ep_call_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
          "lines": "398-444",
          "snippet": "static int ep_call_nested(struct nested_calls *ncalls, int max_nests,\n\t\t\t  int (*nproc)(void *, void *, int), void *priv,\n\t\t\t  void *cookie, void *ctx)\n{\n\tint error, call_nests = 0;\n\tunsigned long flags;\n\tstruct list_head *lsthead = &ncalls->tasks_call_list;\n\tstruct nested_call_node *tncur;\n\tstruct nested_call_node tnode;\n\n\tspin_lock_irqsave(&ncalls->lock, flags);\n\n\t/*\n\t * Try to see if the current task is already inside this wakeup call.\n\t * We use a list here, since the population inside this set is always\n\t * very much limited.\n\t */\n\tlist_for_each_entry(tncur, lsthead, llink) {\n\t\tif (tncur->ctx == ctx &&\n\t\t    (tncur->cookie == cookie || ++call_nests > max_nests)) {\n\t\t\t/*\n\t\t\t * Ops ... loop detected or maximum nest level reached.\n\t\t\t * We abort this wake by breaking the cycle itself.\n\t\t\t */\n\t\t\terror = -1;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\t/* Add the current task and cookie to the list */\n\ttnode.ctx = ctx;\n\ttnode.cookie = cookie;\n\tlist_add(&tnode.llink, lsthead);\n\n\tspin_unlock_irqrestore(&ncalls->lock, flags);\n\n\t/* Call the nested function */\n\terror = (*nproc)(priv, cookie, call_nests);\n\n\t/* Remove the current task from the list */\n\tspin_lock_irqsave(&ncalls->lock, flags);\n\tlist_del(&tnode.llink);\nout_unlock:\n\tspin_unlock_irqrestore(&ncalls->lock, flags);\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int ep_call_nested(struct nested_calls *ncalls, int max_nests,\n\t\t\t  int (*nproc)(void *, void *, int), void *priv,\n\t\t\t  void *cookie, void *ctx)\n{\n\tint error, call_nests = 0;\n\tunsigned long flags;\n\tstruct list_head *lsthead = &ncalls->tasks_call_list;\n\tstruct nested_call_node *tncur;\n\tstruct nested_call_node tnode;\n\n\tspin_lock_irqsave(&ncalls->lock, flags);\n\n\t/*\n\t * Try to see if the current task is already inside this wakeup call.\n\t * We use a list here, since the population inside this set is always\n\t * very much limited.\n\t */\n\tlist_for_each_entry(tncur, lsthead, llink) {\n\t\tif (tncur->ctx == ctx &&\n\t\t    (tncur->cookie == cookie || ++call_nests > max_nests)) {\n\t\t\t/*\n\t\t\t * Ops ... loop detected or maximum nest level reached.\n\t\t\t * We abort this wake by breaking the cycle itself.\n\t\t\t */\n\t\t\terror = -1;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\t/* Add the current task and cookie to the list */\n\ttnode.ctx = ctx;\n\ttnode.cookie = cookie;\n\tlist_add(&tnode.llink, lsthead);\n\n\tspin_unlock_irqrestore(&ncalls->lock, flags);\n\n\t/* Call the nested function */\n\terror = (*nproc)(priv, cookie, call_nests);\n\n\t/* Remove the current task from the list */\n\tspin_lock_irqsave(&ncalls->lock, flags);\n\tlist_del(&tnode.llink);\nout_unlock:\n\tspin_unlock_irqrestore(&ncalls->lock, flags);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_count_init",
          "args": [],
          "line": 1214
        },
        "resolved": true,
        "details": {
          "function_name": "path_count_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
          "lines": "1154-1160",
          "snippet": "static void path_count_init(void)\n{\n\tint i;\n\n\tfor (i = 0; i < PATH_ARR_SIZE; i++)\n\t\tpath_count[i] = 0;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define PATH_ARR_SIZE 5"
          ],
          "globals_used": [
            "static int path_count[PATH_ARR_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define PATH_ARR_SIZE 5\n\nstatic int path_count[PATH_ARR_SIZE];\n\nstatic void path_count_init(void)\n{\n\tint i;\n\n\tfor (i = 0; i < PATH_ARR_SIZE; i++)\n\t\tpath_count[i] = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "current_file",
            "&tfile_check_list",
            "f_tfile_llink"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define EP_MAX_NESTS 4\n\nstatic struct nested_calls poll_loop_ncalls;\nstatic LIST_HEAD(tfile_check_list);\n\nstatic int reverse_path_check(void)\n{\n\tint error = 0;\n\tstruct file *current_file;\n\n\t/* let's call this for all tfiles */\n\tlist_for_each_entry(current_file, &tfile_check_list, f_tfile_llink) {\n\t\tpath_count_init();\n\t\terror = ep_call_nested(&poll_loop_ncalls, EP_MAX_NESTS,\n\t\t\t\t\treverse_path_check_proc, current_file,\n\t\t\t\t\tcurrent_file, current);\n\t\tif (error)\n\t\t\tbreak;\n\t}\n\treturn error;\n}"
  },
  {
    "function_name": "reverse_path_check_proc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
    "lines": "1162-1195",
    "snippet": "static int reverse_path_check_proc(void *priv, void *cookie, int call_nests)\n{\n\tint error = 0;\n\tstruct file *file = priv;\n\tstruct file *child_file;\n\tstruct epitem *epi;\n\n\t/* CTL_DEL can remove links here, but that can't increase our count */\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(epi, &file->f_ep_links, fllink) {\n\t\tchild_file = epi->ep->file;\n\t\tif (is_file_epoll(child_file)) {\n\t\t\tif (list_empty(&child_file->f_ep_links)) {\n\t\t\t\tif (path_count_inc(call_nests)) {\n\t\t\t\t\terror = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\terror = ep_call_nested(&poll_loop_ncalls,\n\t\t\t\t\t\t\tEP_MAX_NESTS,\n\t\t\t\t\t\t\treverse_path_check_proc,\n\t\t\t\t\t\t\tchild_file, child_file,\n\t\t\t\t\t\t\tcurrent);\n\t\t\t}\n\t\t\tif (error != 0)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tprintk(KERN_ERR \"reverse_path_check_proc: \"\n\t\t\t\t\"file is not an ep!\\n\");\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn error;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define EP_MAX_NESTS 4"
    ],
    "globals_used": [
      "static struct nested_calls poll_loop_ncalls;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"reverse_path_check_proc: \"\n\t\t\t\t\"file is not an ep!\\n\""
          ],
          "line": 1189
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ep_call_nested",
          "args": [
            "&poll_loop_ncalls",
            "EP_MAX_NESTS",
            "reverse_path_check_proc",
            "child_file",
            "child_file",
            "current"
          ],
          "line": 1180
        },
        "resolved": true,
        "details": {
          "function_name": "ep_call_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
          "lines": "398-444",
          "snippet": "static int ep_call_nested(struct nested_calls *ncalls, int max_nests,\n\t\t\t  int (*nproc)(void *, void *, int), void *priv,\n\t\t\t  void *cookie, void *ctx)\n{\n\tint error, call_nests = 0;\n\tunsigned long flags;\n\tstruct list_head *lsthead = &ncalls->tasks_call_list;\n\tstruct nested_call_node *tncur;\n\tstruct nested_call_node tnode;\n\n\tspin_lock_irqsave(&ncalls->lock, flags);\n\n\t/*\n\t * Try to see if the current task is already inside this wakeup call.\n\t * We use a list here, since the population inside this set is always\n\t * very much limited.\n\t */\n\tlist_for_each_entry(tncur, lsthead, llink) {\n\t\tif (tncur->ctx == ctx &&\n\t\t    (tncur->cookie == cookie || ++call_nests > max_nests)) {\n\t\t\t/*\n\t\t\t * Ops ... loop detected or maximum nest level reached.\n\t\t\t * We abort this wake by breaking the cycle itself.\n\t\t\t */\n\t\t\terror = -1;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\t/* Add the current task and cookie to the list */\n\ttnode.ctx = ctx;\n\ttnode.cookie = cookie;\n\tlist_add(&tnode.llink, lsthead);\n\n\tspin_unlock_irqrestore(&ncalls->lock, flags);\n\n\t/* Call the nested function */\n\terror = (*nproc)(priv, cookie, call_nests);\n\n\t/* Remove the current task from the list */\n\tspin_lock_irqsave(&ncalls->lock, flags);\n\tlist_del(&tnode.llink);\nout_unlock:\n\tspin_unlock_irqrestore(&ncalls->lock, flags);\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int ep_call_nested(struct nested_calls *ncalls, int max_nests,\n\t\t\t  int (*nproc)(void *, void *, int), void *priv,\n\t\t\t  void *cookie, void *ctx)\n{\n\tint error, call_nests = 0;\n\tunsigned long flags;\n\tstruct list_head *lsthead = &ncalls->tasks_call_list;\n\tstruct nested_call_node *tncur;\n\tstruct nested_call_node tnode;\n\n\tspin_lock_irqsave(&ncalls->lock, flags);\n\n\t/*\n\t * Try to see if the current task is already inside this wakeup call.\n\t * We use a list here, since the population inside this set is always\n\t * very much limited.\n\t */\n\tlist_for_each_entry(tncur, lsthead, llink) {\n\t\tif (tncur->ctx == ctx &&\n\t\t    (tncur->cookie == cookie || ++call_nests > max_nests)) {\n\t\t\t/*\n\t\t\t * Ops ... loop detected or maximum nest level reached.\n\t\t\t * We abort this wake by breaking the cycle itself.\n\t\t\t */\n\t\t\terror = -1;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\t/* Add the current task and cookie to the list */\n\ttnode.ctx = ctx;\n\ttnode.cookie = cookie;\n\tlist_add(&tnode.llink, lsthead);\n\n\tspin_unlock_irqrestore(&ncalls->lock, flags);\n\n\t/* Call the nested function */\n\terror = (*nproc)(priv, cookie, call_nests);\n\n\t/* Remove the current task from the list */\n\tspin_lock_irqsave(&ncalls->lock, flags);\n\tlist_del(&tnode.llink);\nout_unlock:\n\tspin_unlock_irqrestore(&ncalls->lock, flags);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_count_inc",
          "args": [
            "call_nests"
          ],
          "line": 1175
        },
        "resolved": true,
        "details": {
          "function_name": "path_count_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
          "lines": "1143-1152",
          "snippet": "static int path_count_inc(int nests)\n{\n\t/* Allow an arbitrary number of depth 1 paths */\n\tif (nests == 0)\n\t\treturn 0;\n\n\tif (++path_count[nests] > path_limits[nests])\n\t\treturn -1;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const int path_limits[PATH_ARR_SIZE] = { 1000, 500, 100, 50, 10 };",
            "static int path_count[PATH_ARR_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic const int path_limits[PATH_ARR_SIZE] = { 1000, 500, 100, 50, 10 };\nstatic int path_count[PATH_ARR_SIZE];\n\nstatic int path_count_inc(int nests)\n{\n\t/* Allow an arbitrary number of depth 1 paths */\n\tif (nests == 0)\n\t\treturn 0;\n\n\tif (++path_count[nests] > path_limits[nests])\n\t\treturn -1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&child_file->f_ep_links"
          ],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_file_epoll",
          "args": [
            "child_file"
          ],
          "line": 1173
        },
        "resolved": true,
        "details": {
          "function_name": "is_file_epoll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
          "lines": "312-315",
          "snippet": "static inline int is_file_epoll(struct file *f)\n{\n\treturn f->f_op == &eventpoll_fops;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations eventpoll_fops;",
            "static const struct file_operations eventpoll_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= ep_show_fdinfo,\n#endif\n\t.release\t= ep_eventpoll_release,\n\t.poll\t\t= ep_eventpoll_poll,\n\t.llseek\t\t= noop_llseek,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic const struct file_operations eventpoll_fops;\nstatic const struct file_operations eventpoll_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= ep_show_fdinfo,\n#endif\n\t.release\t= ep_eventpoll_release,\n\t.poll\t\t= ep_eventpoll_poll,\n\t.llseek\t\t= noop_llseek,\n};\n\nstatic inline int is_file_epoll(struct file *f)\n{\n\treturn f->f_op == &eventpoll_fops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "epi",
            "&file->f_ep_links",
            "fllink"
          ],
          "line": 1171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define EP_MAX_NESTS 4\n\nstatic struct nested_calls poll_loop_ncalls;\n\nstatic int reverse_path_check_proc(void *priv, void *cookie, int call_nests)\n{\n\tint error = 0;\n\tstruct file *file = priv;\n\tstruct file *child_file;\n\tstruct epitem *epi;\n\n\t/* CTL_DEL can remove links here, but that can't increase our count */\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(epi, &file->f_ep_links, fllink) {\n\t\tchild_file = epi->ep->file;\n\t\tif (is_file_epoll(child_file)) {\n\t\t\tif (list_empty(&child_file->f_ep_links)) {\n\t\t\t\tif (path_count_inc(call_nests)) {\n\t\t\t\t\terror = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\terror = ep_call_nested(&poll_loop_ncalls,\n\t\t\t\t\t\t\tEP_MAX_NESTS,\n\t\t\t\t\t\t\treverse_path_check_proc,\n\t\t\t\t\t\t\tchild_file, child_file,\n\t\t\t\t\t\t\tcurrent);\n\t\t\t}\n\t\t\tif (error != 0)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tprintk(KERN_ERR \"reverse_path_check_proc: \"\n\t\t\t\t\"file is not an ep!\\n\");\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn error;\n}"
  },
  {
    "function_name": "path_count_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
    "lines": "1154-1160",
    "snippet": "static void path_count_init(void)\n{\n\tint i;\n\n\tfor (i = 0; i < PATH_ARR_SIZE; i++)\n\t\tpath_count[i] = 0;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define PATH_ARR_SIZE 5"
    ],
    "globals_used": [
      "static int path_count[PATH_ARR_SIZE];"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define PATH_ARR_SIZE 5\n\nstatic int path_count[PATH_ARR_SIZE];\n\nstatic void path_count_init(void)\n{\n\tint i;\n\n\tfor (i = 0; i < PATH_ARR_SIZE; i++)\n\t\tpath_count[i] = 0;\n}"
  },
  {
    "function_name": "path_count_inc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
    "lines": "1143-1152",
    "snippet": "static int path_count_inc(int nests)\n{\n\t/* Allow an arbitrary number of depth 1 paths */\n\tif (nests == 0)\n\t\treturn 0;\n\n\tif (++path_count[nests] > path_limits[nests])\n\t\treturn -1;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const int path_limits[PATH_ARR_SIZE] = { 1000, 500, 100, 50, 10 };",
      "static int path_count[PATH_ARR_SIZE];"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic const int path_limits[PATH_ARR_SIZE] = { 1000, 500, 100, 50, 10 };\nstatic int path_count[PATH_ARR_SIZE];\n\nstatic int path_count_inc(int nests)\n{\n\t/* Allow an arbitrary number of depth 1 paths */\n\tif (nests == 0)\n\t\treturn 0;\n\n\tif (++path_count[nests] > path_limits[nests])\n\t\treturn -1;\n\treturn 0;\n}"
  },
  {
    "function_name": "ep_rbtree_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
    "lines": "1107-1124",
    "snippet": "static void ep_rbtree_insert(struct eventpoll *ep, struct epitem *epi)\n{\n\tint kcmp;\n\tstruct rb_node **p = &ep->rbr.rb_node, *parent = NULL;\n\tstruct epitem *epic;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tepic = rb_entry(parent, struct epitem, rbn);\n\t\tkcmp = ep_cmp_ffd(&epi->ffd, &epic->ffd);\n\t\tif (kcmp > 0)\n\t\t\tp = &parent->rb_right;\n\t\telse\n\t\t\tp = &parent->rb_left;\n\t}\n\trb_link_node(&epi->rbn, parent, p);\n\trb_insert_color(&epi->rbn, &ep->rbr);\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "&epi->rbn",
            "&ep->rbr"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "&epi->rbn",
            "parent",
            "p"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_cmp_ffd",
          "args": [
            "&epi->ffd",
            "&epic->ffd"
          ],
          "line": 1116
        },
        "resolved": true,
        "details": {
          "function_name": "ep_cmp_ffd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
          "lines": "326-331",
          "snippet": "static inline int ep_cmp_ffd(struct epoll_filefd *p1,\n\t\t\t     struct epoll_filefd *p2)\n{\n\treturn (p1->file > p2->file ? +1:\n\t        (p1->file < p2->file ? -1 : p1->fd - p2->fd));\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline int ep_cmp_ffd(struct epoll_filefd *p1,\n\t\t\t     struct epoll_filefd *p2)\n{\n\treturn (p1->file > p2->file ? +1:\n\t        (p1->file < p2->file ? -1 : p1->fd - p2->fd));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "parent",
            "structepitem",
            "rbn"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void ep_rbtree_insert(struct eventpoll *ep, struct epitem *epi)\n{\n\tint kcmp;\n\tstruct rb_node **p = &ep->rbr.rb_node, *parent = NULL;\n\tstruct epitem *epic;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\tepic = rb_entry(parent, struct epitem, rbn);\n\t\tkcmp = ep_cmp_ffd(&epi->ffd, &epic->ffd);\n\t\tif (kcmp > 0)\n\t\t\tp = &parent->rb_right;\n\t\telse\n\t\t\tp = &parent->rb_left;\n\t}\n\trb_link_node(&epi->rbn, parent, p);\n\trb_insert_color(&epi->rbn, &ep->rbr);\n}"
  },
  {
    "function_name": "ep_ptable_queue_proc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
    "lines": "1088-1105",
    "snippet": "static void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,\n\t\t\t\t poll_table *pt)\n{\n\tstruct epitem *epi = ep_item_from_epqueue(pt);\n\tstruct eppoll_entry *pwq;\n\n\tif (epi->nwait >= 0 && (pwq = kmem_cache_alloc(pwq_cache, GFP_KERNEL))) {\n\t\tinit_waitqueue_func_entry(&pwq->wait, ep_poll_callback);\n\t\tpwq->whead = whead;\n\t\tpwq->base = epi;\n\t\tadd_wait_queue(whead, &pwq->wait);\n\t\tlist_add_tail(&pwq->llink, &epi->pwqlist);\n\t\tepi->nwait++;\n\t} else {\n\t\t/* We have to signal that an error occurred */\n\t\tepi->nwait = -1;\n\t}\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,\n\t\t\t\t poll_table *pt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&pwq->llink",
            "&epi->pwqlist"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_wait_queue",
          "args": [
            "whead",
            "&pwq->wait"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_func_entry",
          "args": [
            "&pwq->wait",
            "ep_poll_callback"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "pwq_cache",
            "GFP_KERNEL"
          ],
          "line": 1094
        },
        "resolved": true,
        "details": {
          "function_name": "f2fs_kmem_cache_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/f2fs/f2fs.h",
          "lines": "1064-1076",
          "snippet": "static inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}",
          "includes": [
            "#include <linux/sched.h>",
            "#include <linux/kobject.h>",
            "#include <linux/magic.h>",
            "#include <linux/crc32.h>",
            "#include <linux/slab.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/page-flags.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched.h>\n#include <linux/kobject.h>\n#include <linux/magic.h>\n#include <linux/crc32.h>\n#include <linux/slab.h>\n#include <linux/buffer_head.h>\n#include <linux/page-flags.h>\n#include <linux/types.h>\n\nstatic inline void *f2fs_kmem_cache_alloc(struct kmem_cache *cachep,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tvoid *entry;\nretry:\n\tentry = kmem_cache_alloc(cachep, flags);\n\tif (!entry) {\n\t\tcond_resched();\n\t\tgoto retry;\n\t}\n\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ep_item_from_epqueue",
          "args": [
            "pt"
          ],
          "line": 1091
        },
        "resolved": true,
        "details": {
          "function_name": "ep_item_from_epqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
          "lines": "351-354",
          "snippet": "static inline struct epitem *ep_item_from_epqueue(poll_table *p)\n{\n\treturn container_of(p, struct ep_pqueue, pt)->epi;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,\n\t\t\t\t poll_table *pt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,\n\t\t\t\t poll_table *pt);\n\nstatic inline struct epitem *ep_item_from_epqueue(poll_table *p)\n{\n\treturn container_of(p, struct ep_pqueue, pt)->epi;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,\n\t\t\t\t poll_table *pt);\n\nstatic void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,\n\t\t\t\t poll_table *pt)\n{\n\tstruct epitem *epi = ep_item_from_epqueue(pt);\n\tstruct eppoll_entry *pwq;\n\n\tif (epi->nwait >= 0 && (pwq = kmem_cache_alloc(pwq_cache, GFP_KERNEL))) {\n\t\tinit_waitqueue_func_entry(&pwq->wait, ep_poll_callback);\n\t\tpwq->whead = whead;\n\t\tpwq->base = epi;\n\t\tadd_wait_queue(whead, &pwq->wait);\n\t\tlist_add_tail(&pwq->llink, &epi->pwqlist);\n\t\tepi->nwait++;\n\t} else {\n\t\t/* We have to signal that an error occurred */\n\t\tepi->nwait = -1;\n\t}\n}"
  },
  {
    "function_name": "ep_poll_callback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
    "lines": "999-1082",
    "snippet": "static int ep_poll_callback(wait_queue_t *wait, unsigned mode, int sync, void *key)\n{\n\tint pwake = 0;\n\tunsigned long flags;\n\tstruct epitem *epi = ep_item_from_wait(wait);\n\tstruct eventpoll *ep = epi->ep;\n\n\tif ((unsigned long)key & POLLFREE) {\n\t\tep_pwq_from_wait(wait)->whead = NULL;\n\t\t/*\n\t\t * whead = NULL above can race with ep_remove_wait_queue()\n\t\t * which can do another remove_wait_queue() after us, so we\n\t\t * can't use __remove_wait_queue(). whead->lock is held by\n\t\t * the caller.\n\t\t */\n\t\tlist_del_init(&wait->task_list);\n\t}\n\n\tspin_lock_irqsave(&ep->lock, flags);\n\n\t/*\n\t * If the event mask does not contain any poll(2) event, we consider the\n\t * descriptor to be disabled. This condition is likely the effect of the\n\t * EPOLLONESHOT bit that disables the descriptor when an event is received,\n\t * until the next EPOLL_CTL_MOD will be issued.\n\t */\n\tif (!(epi->event.events & ~EP_PRIVATE_BITS))\n\t\tgoto out_unlock;\n\n\t/*\n\t * Check the events coming with the callback. At this stage, not\n\t * every device reports the events in the \"key\" parameter of the\n\t * callback. We need to be able to handle both cases here, hence the\n\t * test for \"key\" != NULL before the event match test.\n\t */\n\tif (key && !((unsigned long) key & epi->event.events))\n\t\tgoto out_unlock;\n\n\t/*\n\t * If we are transferring events to userspace, we can hold no locks\n\t * (because we're accessing user memory, and because of linux f_op->poll()\n\t * semantics). All the events that happen during that period of time are\n\t * chained in ep->ovflist and requeued later on.\n\t */\n\tif (unlikely(ep->ovflist != EP_UNACTIVE_PTR)) {\n\t\tif (epi->next == EP_UNACTIVE_PTR) {\n\t\t\tepi->next = ep->ovflist;\n\t\t\tep->ovflist = epi;\n\t\t\tif (epi->ws) {\n\t\t\t\t/*\n\t\t\t\t * Activate ep->ws since epi->ws may get\n\t\t\t\t * deactivated at any time.\n\t\t\t\t */\n\t\t\t\t__pm_stay_awake(ep->ws);\n\t\t\t}\n\n\t\t}\n\t\tgoto out_unlock;\n\t}\n\n\t/* If this file is already in the ready list we exit soon */\n\tif (!ep_is_linked(&epi->rdllink)) {\n\t\tlist_add_tail(&epi->rdllink, &ep->rdllist);\n\t\tep_pm_stay_awake_rcu(epi);\n\t}\n\n\t/*\n\t * Wake up ( if active ) both the eventpoll wait list and the ->poll()\n\t * wait list.\n\t */\n\tif (waitqueue_active(&ep->wq))\n\t\twake_up_locked(&ep->wq);\n\tif (waitqueue_active(&ep->poll_wait))\n\t\tpwake++;\n\nout_unlock:\n\tspin_unlock_irqrestore(&ep->lock, flags);\n\n\t/* We have to call this outside the lock */\n\tif (pwake)\n\t\tep_poll_safewake(&ep->poll_wait);\n\n\treturn 1;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define EP_UNACTIVE_PTR ((void *) -1L)",
      "#define EP_PRIVATE_BITS (EPOLLWAKEUP | EPOLLONESHOT | EPOLLET)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ep_poll_safewake",
          "args": [
            "&ep->poll_wait"
          ],
          "line": 1079
        },
        "resolved": true,
        "details": {
          "function_name": "ep_poll_safewake",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
          "lines": "506-514",
          "snippet": "static void ep_poll_safewake(wait_queue_head_t *wq)\n{\n\tint this_cpu = get_cpu();\n\n\tep_call_nested(&poll_safewake_ncalls, EP_MAX_NESTS,\n\t\t       ep_poll_wakeup_proc, NULL, wq, (void *) (long) this_cpu);\n\n\tput_cpu();\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define EP_MAX_NESTS 4"
          ],
          "globals_used": [
            "static struct nested_calls poll_safewake_ncalls;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define EP_MAX_NESTS 4\n\nstatic struct nested_calls poll_safewake_ncalls;\n\nstatic void ep_poll_safewake(wait_queue_head_t *wq)\n{\n\tint this_cpu = get_cpu();\n\n\tep_call_nested(&poll_safewake_ncalls, EP_MAX_NESTS,\n\t\t       ep_poll_wakeup_proc, NULL, wq, (void *) (long) this_cpu);\n\n\tput_cpu();\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&ep->lock",
            "flags"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&ep->poll_wait"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_locked",
          "args": [
            "&ep->wq"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&ep->wq"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_pm_stay_awake_rcu",
          "args": [
            "epi"
          ],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "ep_pm_stay_awake_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
          "lines": "568-577",
          "snippet": "static inline void ep_pm_stay_awake_rcu(struct epitem *epi)\n{\n\tstruct wakeup_source *ws;\n\n\trcu_read_lock();\n\tws = rcu_dereference(epi->ws);\n\tif (ws)\n\t\t__pm_stay_awake(ws);\n\trcu_read_unlock();\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline void ep_pm_stay_awake_rcu(struct epitem *epi)\n{\n\tstruct wakeup_source *ws;\n\n\trcu_read_lock();\n\tws = rcu_dereference(epi->ws);\n\tif (ws)\n\t\t__pm_stay_awake(ws);\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&epi->rdllink",
            "&ep->rdllist"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_is_linked",
          "args": [
            "&epi->rdllink"
          ],
          "line": 1060
        },
        "resolved": true,
        "details": {
          "function_name": "ep_is_linked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
          "lines": "334-337",
          "snippet": "static inline int ep_is_linked(struct list_head *p)\n{\n\treturn !list_empty(p);\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline int ep_is_linked(struct list_head *p)\n{\n\treturn !list_empty(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__pm_stay_awake",
          "args": [
            "ep->ws"
          ],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ep->ovflist != EP_UNACTIVE_PTR"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&ep->lock",
            "flags"
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&wait->task_list"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_pwq_from_wait",
          "args": [
            "wait"
          ],
          "line": 1007
        },
        "resolved": true,
        "details": {
          "function_name": "ep_pwq_from_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
          "lines": "339-342",
          "snippet": "static inline struct eppoll_entry *ep_pwq_from_wait(wait_queue_t *p)\n{\n\treturn container_of(p, struct eppoll_entry, wait);\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline struct eppoll_entry *ep_pwq_from_wait(wait_queue_t *p)\n{\n\treturn container_of(p, struct eppoll_entry, wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ep_item_from_wait",
          "args": [
            "wait"
          ],
          "line": 1003
        },
        "resolved": true,
        "details": {
          "function_name": "ep_item_from_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
          "lines": "345-348",
          "snippet": "static inline struct epitem *ep_item_from_wait(wait_queue_t *p)\n{\n\treturn container_of(p, struct eppoll_entry, wait)->base;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline struct epitem *ep_item_from_wait(wait_queue_t *p)\n{\n\treturn container_of(p, struct eppoll_entry, wait)->base;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define EP_UNACTIVE_PTR ((void *) -1L)\n#define EP_PRIVATE_BITS (EPOLLWAKEUP | EPOLLONESHOT | EPOLLET)\n\nstatic int ep_poll_callback(wait_queue_t *wait, unsigned mode, int sync, void *key)\n{\n\tint pwake = 0;\n\tunsigned long flags;\n\tstruct epitem *epi = ep_item_from_wait(wait);\n\tstruct eventpoll *ep = epi->ep;\n\n\tif ((unsigned long)key & POLLFREE) {\n\t\tep_pwq_from_wait(wait)->whead = NULL;\n\t\t/*\n\t\t * whead = NULL above can race with ep_remove_wait_queue()\n\t\t * which can do another remove_wait_queue() after us, so we\n\t\t * can't use __remove_wait_queue(). whead->lock is held by\n\t\t * the caller.\n\t\t */\n\t\tlist_del_init(&wait->task_list);\n\t}\n\n\tspin_lock_irqsave(&ep->lock, flags);\n\n\t/*\n\t * If the event mask does not contain any poll(2) event, we consider the\n\t * descriptor to be disabled. This condition is likely the effect of the\n\t * EPOLLONESHOT bit that disables the descriptor when an event is received,\n\t * until the next EPOLL_CTL_MOD will be issued.\n\t */\n\tif (!(epi->event.events & ~EP_PRIVATE_BITS))\n\t\tgoto out_unlock;\n\n\t/*\n\t * Check the events coming with the callback. At this stage, not\n\t * every device reports the events in the \"key\" parameter of the\n\t * callback. We need to be able to handle both cases here, hence the\n\t * test for \"key\" != NULL before the event match test.\n\t */\n\tif (key && !((unsigned long) key & epi->event.events))\n\t\tgoto out_unlock;\n\n\t/*\n\t * If we are transferring events to userspace, we can hold no locks\n\t * (because we're accessing user memory, and because of linux f_op->poll()\n\t * semantics). All the events that happen during that period of time are\n\t * chained in ep->ovflist and requeued later on.\n\t */\n\tif (unlikely(ep->ovflist != EP_UNACTIVE_PTR)) {\n\t\tif (epi->next == EP_UNACTIVE_PTR) {\n\t\t\tepi->next = ep->ovflist;\n\t\t\tep->ovflist = epi;\n\t\t\tif (epi->ws) {\n\t\t\t\t/*\n\t\t\t\t * Activate ep->ws since epi->ws may get\n\t\t\t\t * deactivated at any time.\n\t\t\t\t */\n\t\t\t\t__pm_stay_awake(ep->ws);\n\t\t\t}\n\n\t\t}\n\t\tgoto out_unlock;\n\t}\n\n\t/* If this file is already in the ready list we exit soon */\n\tif (!ep_is_linked(&epi->rdllink)) {\n\t\tlist_add_tail(&epi->rdllink, &ep->rdllist);\n\t\tep_pm_stay_awake_rcu(epi);\n\t}\n\n\t/*\n\t * Wake up ( if active ) both the eventpoll wait list and the ->poll()\n\t * wait list.\n\t */\n\tif (waitqueue_active(&ep->wq))\n\t\twake_up_locked(&ep->wq);\n\tif (waitqueue_active(&ep->poll_wait))\n\t\tpwake++;\n\nout_unlock:\n\tspin_unlock_irqrestore(&ep->lock, flags);\n\n\t/* We have to call this outside the lock */\n\tif (pwake)\n\t\tep_poll_safewake(&ep->poll_wait);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "ep_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
    "lines": "970-992",
    "snippet": "static struct epitem *ep_find(struct eventpoll *ep, struct file *file, int fd)\n{\n\tint kcmp;\n\tstruct rb_node *rbp;\n\tstruct epitem *epi, *epir = NULL;\n\tstruct epoll_filefd ffd;\n\n\tep_set_ffd(&ffd, file, fd);\n\tfor (rbp = ep->rbr.rb_node; rbp; ) {\n\t\tepi = rb_entry(rbp, struct epitem, rbn);\n\t\tkcmp = ep_cmp_ffd(&ffd, &epi->ffd);\n\t\tif (kcmp > 0)\n\t\t\trbp = rbp->rb_right;\n\t\telse if (kcmp < 0)\n\t\t\trbp = rbp->rb_left;\n\t\telse {\n\t\t\tepir = epi;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn epir;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ep_cmp_ffd",
          "args": [
            "&ffd",
            "&epi->ffd"
          ],
          "line": 980
        },
        "resolved": true,
        "details": {
          "function_name": "ep_cmp_ffd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
          "lines": "326-331",
          "snippet": "static inline int ep_cmp_ffd(struct epoll_filefd *p1,\n\t\t\t     struct epoll_filefd *p2)\n{\n\treturn (p1->file > p2->file ? +1:\n\t        (p1->file < p2->file ? -1 : p1->fd - p2->fd));\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline int ep_cmp_ffd(struct epoll_filefd *p1,\n\t\t\t     struct epoll_filefd *p2)\n{\n\treturn (p1->file > p2->file ? +1:\n\t        (p1->file < p2->file ? -1 : p1->fd - p2->fd));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "rbp",
            "structepitem",
            "rbn"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_set_ffd",
          "args": [
            "&ffd",
            "file",
            "fd"
          ],
          "line": 977
        },
        "resolved": true,
        "details": {
          "function_name": "ep_set_ffd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
          "lines": "318-323",
          "snippet": "static inline void ep_set_ffd(struct epoll_filefd *ffd,\n\t\t\t      struct file *file, int fd)\n{\n\tffd->file = file;\n\tffd->fd = fd;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline void ep_set_ffd(struct epoll_filefd *ffd,\n\t\t\t      struct file *file, int fd)\n{\n\tffd->file = file;\n\tffd->fd = fd;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic struct epitem *ep_find(struct eventpoll *ep, struct file *file, int fd)\n{\n\tint kcmp;\n\tstruct rb_node *rbp;\n\tstruct epitem *epi, *epir = NULL;\n\tstruct epoll_filefd ffd;\n\n\tep_set_ffd(&ffd, file, fd);\n\tfor (rbp = ep->rbr.rb_node; rbp; ) {\n\t\tepi = rb_entry(rbp, struct epitem, rbn);\n\t\tkcmp = ep_cmp_ffd(&ffd, &epi->ffd);\n\t\tif (kcmp > 0)\n\t\t\trbp = rbp->rb_right;\n\t\telse if (kcmp < 0)\n\t\t\trbp = rbp->rb_left;\n\t\telse {\n\t\t\tepir = epi;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn epir;\n}"
  },
  {
    "function_name": "ep_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
    "lines": "935-963",
    "snippet": "static int ep_alloc(struct eventpoll **pep)\n{\n\tint error;\n\tstruct user_struct *user;\n\tstruct eventpoll *ep;\n\n\tuser = get_current_user();\n\terror = -ENOMEM;\n\tep = kzalloc(sizeof(*ep), GFP_KERNEL);\n\tif (unlikely(!ep))\n\t\tgoto free_uid;\n\n\tspin_lock_init(&ep->lock);\n\tmutex_init(&ep->mtx);\n\tinit_waitqueue_head(&ep->wq);\n\tinit_waitqueue_head(&ep->poll_wait);\n\tINIT_LIST_HEAD(&ep->rdllist);\n\tep->rbr = RB_ROOT;\n\tep->ovflist = EP_UNACTIVE_PTR;\n\tep->user = user;\n\n\t*pep = ep;\n\n\treturn 0;\n\nfree_uid:\n\tfree_uid(user);\n\treturn error;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define EP_UNACTIVE_PTR ((void *) -1L)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_uid",
          "args": [
            "user"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ep->rdllist"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&ep->poll_wait"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&ep->wq"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&ep->mtx"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&ep->lock"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ep"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*ep)",
            "GFP_KERNEL"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_current_user",
          "args": [],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define EP_UNACTIVE_PTR ((void *) -1L)\n\nstatic int ep_alloc(struct eventpoll **pep)\n{\n\tint error;\n\tstruct user_struct *user;\n\tstruct eventpoll *ep;\n\n\tuser = get_current_user();\n\terror = -ENOMEM;\n\tep = kzalloc(sizeof(*ep), GFP_KERNEL);\n\tif (unlikely(!ep))\n\t\tgoto free_uid;\n\n\tspin_lock_init(&ep->lock);\n\tmutex_init(&ep->mtx);\n\tinit_waitqueue_head(&ep->wq);\n\tinit_waitqueue_head(&ep->poll_wait);\n\tINIT_LIST_HEAD(&ep->rdllist);\n\tep->rbr = RB_ROOT;\n\tep->ovflist = EP_UNACTIVE_PTR;\n\tep->user = user;\n\n\t*pep = ep;\n\n\treturn 0;\n\nfree_uid:\n\tfree_uid(user);\n\treturn error;\n}"
  },
  {
    "function_name": "eventpoll_release_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
    "lines": "907-933",
    "snippet": "void eventpoll_release_file(struct file *file)\n{\n\tstruct eventpoll *ep;\n\tstruct epitem *epi, *next;\n\n\t/*\n\t * We don't want to get \"file->f_lock\" because it is not\n\t * necessary. It is not necessary because we're in the \"struct file\"\n\t * cleanup path, and this means that no one is using this file anymore.\n\t * So, for example, epoll_ctl() cannot hit here since if we reach this\n\t * point, the file counter already went to zero and fget() would fail.\n\t * The only hit might come from ep_free() but by holding the mutex\n\t * will correctly serialize the operation. We do need to acquire\n\t * \"ep->mtx\" after \"epmutex\" because ep_remove() requires it when called\n\t * from anywhere but ep_free().\n\t *\n\t * Besides, ep_remove() acquires the lock, so we can't hold it here.\n\t */\n\tmutex_lock(&epmutex);\n\tlist_for_each_entry_safe(epi, next, &file->f_ep_links, fllink) {\n\t\tep = epi->ep;\n\t\tmutex_lock_nested(&ep->mtx, 0);\n\t\tep_remove(ep, epi);\n\t\tmutex_unlock(&ep->mtx);\n\t}\n\tmutex_unlock(&epmutex);\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(epmutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&epmutex"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ep->mtx"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_remove",
          "args": [
            "ep",
            "epi"
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "ep_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
          "lines": "692-732",
          "snippet": "static int ep_remove(struct eventpoll *ep, struct epitem *epi)\n{\n\tunsigned long flags;\n\tstruct file *file = epi->ffd.file;\n\n\t/*\n\t * Removes poll wait queue hooks. We _have_ to do this without holding\n\t * the \"ep->lock\" otherwise a deadlock might occur. This because of the\n\t * sequence of the lock acquisition. Here we do \"ep->lock\" then the wait\n\t * queue head lock when unregistering the wait queue. The wakeup callback\n\t * will run by holding the wait queue head lock and will call our callback\n\t * that will try to get \"ep->lock\".\n\t */\n\tep_unregister_pollwait(ep, epi);\n\n\t/* Remove the current item from the list of epoll hooks */\n\tspin_lock(&file->f_lock);\n\tlist_del_rcu(&epi->fllink);\n\tspin_unlock(&file->f_lock);\n\n\trb_erase(&epi->rbn, &ep->rbr);\n\n\tspin_lock_irqsave(&ep->lock, flags);\n\tif (ep_is_linked(&epi->rdllink))\n\t\tlist_del_init(&epi->rdllink);\n\tspin_unlock_irqrestore(&ep->lock, flags);\n\n\twakeup_source_unregister(ep_wakeup_source(epi));\n\t/*\n\t * At this point it is safe to free the eventpoll item. Use the union\n\t * field epi->rcu, since we are trying to minimize the size of\n\t * 'struct epitem'. The 'rbn' field is no longer in use. Protected by\n\t * ep->mtx. The rcu read side, reverse_path_check_proc(), does not make\n\t * use of the rbn field.\n\t */\n\tcall_rcu(&epi->rcu, epi_rcu_free);\n\n\tatomic_long_dec(&ep->user->epoll_watches);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int ep_remove(struct eventpoll *ep, struct epitem *epi)\n{\n\tunsigned long flags;\n\tstruct file *file = epi->ffd.file;\n\n\t/*\n\t * Removes poll wait queue hooks. We _have_ to do this without holding\n\t * the \"ep->lock\" otherwise a deadlock might occur. This because of the\n\t * sequence of the lock acquisition. Here we do \"ep->lock\" then the wait\n\t * queue head lock when unregistering the wait queue. The wakeup callback\n\t * will run by holding the wait queue head lock and will call our callback\n\t * that will try to get \"ep->lock\".\n\t */\n\tep_unregister_pollwait(ep, epi);\n\n\t/* Remove the current item from the list of epoll hooks */\n\tspin_lock(&file->f_lock);\n\tlist_del_rcu(&epi->fllink);\n\tspin_unlock(&file->f_lock);\n\n\trb_erase(&epi->rbn, &ep->rbr);\n\n\tspin_lock_irqsave(&ep->lock, flags);\n\tif (ep_is_linked(&epi->rdllink))\n\t\tlist_del_init(&epi->rdllink);\n\tspin_unlock_irqrestore(&ep->lock, flags);\n\n\twakeup_source_unregister(ep_wakeup_source(epi));\n\t/*\n\t * At this point it is safe to free the eventpoll item. Use the union\n\t * field epi->rcu, since we are trying to minimize the size of\n\t * 'struct epitem'. The 'rbn' field is no longer in use. Protected by\n\t * ep->mtx. The rcu read side, reverse_path_check_proc(), does not make\n\t * use of the rbn field.\n\t */\n\tcall_rcu(&epi->rcu, epi_rcu_free);\n\n\tatomic_long_dec(&ep->user->epoll_watches);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&ep->mtx",
            "0"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "epi",
            "next",
            "&file->f_ep_links",
            "fllink"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&epmutex"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic DEFINE_MUTEX(epmutex);\n\nvoid eventpoll_release_file(struct file *file)\n{\n\tstruct eventpoll *ep;\n\tstruct epitem *epi, *next;\n\n\t/*\n\t * We don't want to get \"file->f_lock\" because it is not\n\t * necessary. It is not necessary because we're in the \"struct file\"\n\t * cleanup path, and this means that no one is using this file anymore.\n\t * So, for example, epoll_ctl() cannot hit here since if we reach this\n\t * point, the file counter already went to zero and fget() would fail.\n\t * The only hit might come from ep_free() but by holding the mutex\n\t * will correctly serialize the operation. We do need to acquire\n\t * \"ep->mtx\" after \"epmutex\" because ep_remove() requires it when called\n\t * from anywhere but ep_free().\n\t *\n\t * Besides, ep_remove() acquires the lock, so we can't hold it here.\n\t */\n\tmutex_lock(&epmutex);\n\tlist_for_each_entry_safe(epi, next, &file->f_ep_links, fllink) {\n\t\tep = epi->ep;\n\t\tmutex_lock_nested(&ep->mtx, 0);\n\t\tep_remove(ep, epi);\n\t\tmutex_unlock(&ep->mtx);\n\t}\n\tmutex_unlock(&epmutex);\n}"
  },
  {
    "function_name": "ep_show_fdinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
    "lines": "873-889",
    "snippet": "static void ep_show_fdinfo(struct seq_file *m, struct file *f)\n{\n\tstruct eventpoll *ep = f->private_data;\n\tstruct rb_node *rbp;\n\n\tmutex_lock(&ep->mtx);\n\tfor (rbp = rb_first(&ep->rbr); rbp; rbp = rb_next(rbp)) {\n\t\tstruct epitem *epi = rb_entry(rbp, struct epitem, rbn);\n\n\t\tseq_printf(m, \"tfd: %8d events: %8x data: %16llx\\n\",\n\t\t\t   epi->ffd.fd, epi->event.events,\n\t\t\t   (long long)epi->event.data);\n\t\tif (seq_has_overflowed(m))\n\t\t\tbreak;\n\t}\n\tmutex_unlock(&ep->mtx);\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ep->mtx"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_has_overflowed",
          "args": [
            "m"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"tfd: %8d events: %8x data: %16llx\\n\"",
            "epi->ffd.fd",
            "epi->event.events",
            "(long long)epi->event.data"
          ],
          "line": 882
        },
        "resolved": true,
        "details": {
          "function_name": "seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/seq_file.c",
          "lines": "416-426",
          "snippet": "int seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}",
          "includes": [
            "#include <asm/page.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/mm.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/page.h>\n#include <asm/uaccess.h>\n#include <linux/mm.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nint seq_printf(struct seq_file *m, const char *f, ...)\n{\n\tint ret;\n\tva_list args;\n\n\tva_start(args, f);\n\tret = seq_vprintf(m, f, args);\n\tva_end(args);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "rbp",
            "structepitem",
            "rbn"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "rbp"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&ep->rbr"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ep->mtx"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void ep_show_fdinfo(struct seq_file *m, struct file *f)\n{\n\tstruct eventpoll *ep = f->private_data;\n\tstruct rb_node *rbp;\n\n\tmutex_lock(&ep->mtx);\n\tfor (rbp = rb_first(&ep->rbr); rbp; rbp = rb_next(rbp)) {\n\t\tstruct epitem *epi = rb_entry(rbp, struct epitem, rbn);\n\n\t\tseq_printf(m, \"tfd: %8d events: %8x data: %16llx\\n\",\n\t\t\t   epi->ffd.fd, epi->event.events,\n\t\t\t   (long long)epi->event.data);\n\t\tif (seq_has_overflowed(m))\n\t\t\tbreak;\n\t}\n\tmutex_unlock(&ep->mtx);\n}"
  },
  {
    "function_name": "ep_eventpoll_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
    "lines": "844-870",
    "snippet": "static unsigned int ep_eventpoll_poll(struct file *file, poll_table *wait)\n{\n\tint pollflags;\n\tstruct eventpoll *ep = file->private_data;\n\tstruct readyevents_arg arg;\n\n\t/*\n\t * During ep_insert() we already hold the ep->mtx for the tfile.\n\t * Prevent re-aquisition.\n\t */\n\targ.locked = wait && (wait->_qproc == ep_ptable_queue_proc);\n\targ.ep = ep;\n\n\t/* Insert inside our poll wait queue */\n\tpoll_wait(file, &ep->poll_wait, wait);\n\n\t/*\n\t * Proceed to find out if wanted events are really available inside\n\t * the ready list. This need to be done under ep_call_nested()\n\t * supervision, since the call to f_op->poll() done on listed files\n\t * could re-enter here.\n\t */\n\tpollflags = ep_call_nested(&poll_readywalk_ncalls, EP_MAX_NESTS,\n\t\t\t\t   ep_poll_readyevents_proc, &arg, ep, current);\n\n\treturn pollflags != -1 ? pollflags : 0;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define EP_MAX_NESTS 4"
    ],
    "globals_used": [
      "static struct nested_calls poll_readywalk_ncalls;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ep_call_nested",
          "args": [
            "&poll_readywalk_ncalls",
            "EP_MAX_NESTS",
            "ep_poll_readyevents_proc",
            "&arg",
            "ep",
            "current"
          ],
          "line": 866
        },
        "resolved": true,
        "details": {
          "function_name": "ep_call_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
          "lines": "398-444",
          "snippet": "static int ep_call_nested(struct nested_calls *ncalls, int max_nests,\n\t\t\t  int (*nproc)(void *, void *, int), void *priv,\n\t\t\t  void *cookie, void *ctx)\n{\n\tint error, call_nests = 0;\n\tunsigned long flags;\n\tstruct list_head *lsthead = &ncalls->tasks_call_list;\n\tstruct nested_call_node *tncur;\n\tstruct nested_call_node tnode;\n\n\tspin_lock_irqsave(&ncalls->lock, flags);\n\n\t/*\n\t * Try to see if the current task is already inside this wakeup call.\n\t * We use a list here, since the population inside this set is always\n\t * very much limited.\n\t */\n\tlist_for_each_entry(tncur, lsthead, llink) {\n\t\tif (tncur->ctx == ctx &&\n\t\t    (tncur->cookie == cookie || ++call_nests > max_nests)) {\n\t\t\t/*\n\t\t\t * Ops ... loop detected or maximum nest level reached.\n\t\t\t * We abort this wake by breaking the cycle itself.\n\t\t\t */\n\t\t\terror = -1;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\t/* Add the current task and cookie to the list */\n\ttnode.ctx = ctx;\n\ttnode.cookie = cookie;\n\tlist_add(&tnode.llink, lsthead);\n\n\tspin_unlock_irqrestore(&ncalls->lock, flags);\n\n\t/* Call the nested function */\n\terror = (*nproc)(priv, cookie, call_nests);\n\n\t/* Remove the current task from the list */\n\tspin_lock_irqsave(&ncalls->lock, flags);\n\tlist_del(&tnode.llink);\nout_unlock:\n\tspin_unlock_irqrestore(&ncalls->lock, flags);\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int ep_call_nested(struct nested_calls *ncalls, int max_nests,\n\t\t\t  int (*nproc)(void *, void *, int), void *priv,\n\t\t\t  void *cookie, void *ctx)\n{\n\tint error, call_nests = 0;\n\tunsigned long flags;\n\tstruct list_head *lsthead = &ncalls->tasks_call_list;\n\tstruct nested_call_node *tncur;\n\tstruct nested_call_node tnode;\n\n\tspin_lock_irqsave(&ncalls->lock, flags);\n\n\t/*\n\t * Try to see if the current task is already inside this wakeup call.\n\t * We use a list here, since the population inside this set is always\n\t * very much limited.\n\t */\n\tlist_for_each_entry(tncur, lsthead, llink) {\n\t\tif (tncur->ctx == ctx &&\n\t\t    (tncur->cookie == cookie || ++call_nests > max_nests)) {\n\t\t\t/*\n\t\t\t * Ops ... loop detected or maximum nest level reached.\n\t\t\t * We abort this wake by breaking the cycle itself.\n\t\t\t */\n\t\t\terror = -1;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\t/* Add the current task and cookie to the list */\n\ttnode.ctx = ctx;\n\ttnode.cookie = cookie;\n\tlist_add(&tnode.llink, lsthead);\n\n\tspin_unlock_irqrestore(&ncalls->lock, flags);\n\n\t/* Call the nested function */\n\terror = (*nproc)(priv, cookie, call_nests);\n\n\t/* Remove the current task from the list */\n\tspin_lock_irqsave(&ncalls->lock, flags);\n\tlist_del(&tnode.llink);\nout_unlock:\n\tspin_unlock_irqrestore(&ncalls->lock, flags);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "poll_wait",
          "args": [
            "file",
            "&ep->poll_wait",
            "wait"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define EP_MAX_NESTS 4\n\nstatic struct nested_calls poll_readywalk_ncalls;\n\nstatic unsigned int ep_eventpoll_poll(struct file *file, poll_table *wait)\n{\n\tint pollflags;\n\tstruct eventpoll *ep = file->private_data;\n\tstruct readyevents_arg arg;\n\n\t/*\n\t * During ep_insert() we already hold the ep->mtx for the tfile.\n\t * Prevent re-aquisition.\n\t */\n\targ.locked = wait && (wait->_qproc == ep_ptable_queue_proc);\n\targ.ep = ep;\n\n\t/* Insert inside our poll wait queue */\n\tpoll_wait(file, &ep->poll_wait, wait);\n\n\t/*\n\t * Proceed to find out if wanted events are really available inside\n\t * the ready list. This need to be done under ep_call_nested()\n\t * supervision, since the call to f_op->poll() done on listed files\n\t * could re-enter here.\n\t */\n\tpollflags = ep_call_nested(&poll_readywalk_ncalls, EP_MAX_NESTS,\n\t\t\t\t   ep_poll_readyevents_proc, &arg, ep, current);\n\n\treturn pollflags != -1 ? pollflags : 0;\n}"
  },
  {
    "function_name": "ep_poll_readyevents_proc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
    "lines": "836-842",
    "snippet": "static int ep_poll_readyevents_proc(void *priv, void *cookie, int call_nests)\n{\n\tstruct readyevents_arg *arg = priv;\n\n\treturn ep_scan_ready_list(arg->ep, ep_read_events_proc, NULL,\n\t\t\t\t  call_nests + 1, arg->locked);\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ep_scan_ready_list",
          "args": [
            "arg->ep",
            "ep_read_events_proc",
            "NULL",
            "call_nests + 1",
            "arg->locked"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "ep_scan_ready_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
          "lines": "592-680",
          "snippet": "static int ep_scan_ready_list(struct eventpoll *ep,\n\t\t\t      int (*sproc)(struct eventpoll *,\n\t\t\t\t\t   struct list_head *, void *),\n\t\t\t      void *priv, int depth, bool ep_locked)\n{\n\tint error, pwake = 0;\n\tunsigned long flags;\n\tstruct epitem *epi, *nepi;\n\tLIST_HEAD(txlist);\n\n\t/*\n\t * We need to lock this because we could be hit by\n\t * eventpoll_release_file() and epoll_ctl().\n\t */\n\n\tif (!ep_locked)\n\t\tmutex_lock_nested(&ep->mtx, depth);\n\n\t/*\n\t * Steal the ready list, and re-init the original one to the\n\t * empty list. Also, set ep->ovflist to NULL so that events\n\t * happening while looping w/out locks, are not lost. We cannot\n\t * have the poll callback to queue directly on ep->rdllist,\n\t * because we want the \"sproc\" callback to be able to do it\n\t * in a lockless way.\n\t */\n\tspin_lock_irqsave(&ep->lock, flags);\n\tlist_splice_init(&ep->rdllist, &txlist);\n\tep->ovflist = NULL;\n\tspin_unlock_irqrestore(&ep->lock, flags);\n\n\t/*\n\t * Now call the callback function.\n\t */\n\terror = (*sproc)(ep, &txlist, priv);\n\n\tspin_lock_irqsave(&ep->lock, flags);\n\t/*\n\t * During the time we spent inside the \"sproc\" callback, some\n\t * other events might have been queued by the poll callback.\n\t * We re-insert them inside the main ready-list here.\n\t */\n\tfor (nepi = ep->ovflist; (epi = nepi) != NULL;\n\t     nepi = epi->next, epi->next = EP_UNACTIVE_PTR) {\n\t\t/*\n\t\t * We need to check if the item is already in the list.\n\t\t * During the \"sproc\" callback execution time, items are\n\t\t * queued into ->ovflist but the \"txlist\" might already\n\t\t * contain them, and the list_splice() below takes care of them.\n\t\t */\n\t\tif (!ep_is_linked(&epi->rdllink)) {\n\t\t\tlist_add_tail(&epi->rdllink, &ep->rdllist);\n\t\t\tep_pm_stay_awake(epi);\n\t\t}\n\t}\n\t/*\n\t * We need to set back ep->ovflist to EP_UNACTIVE_PTR, so that after\n\t * releasing the lock, events will be queued in the normal way inside\n\t * ep->rdllist.\n\t */\n\tep->ovflist = EP_UNACTIVE_PTR;\n\n\t/*\n\t * Quickly re-inject items left on \"txlist\".\n\t */\n\tlist_splice(&txlist, &ep->rdllist);\n\t__pm_relax(ep->ws);\n\n\tif (!list_empty(&ep->rdllist)) {\n\t\t/*\n\t\t * Wake up (if active) both the eventpoll wait list and\n\t\t * the ->poll() wait list (delayed after we release the lock).\n\t\t */\n\t\tif (waitqueue_active(&ep->wq))\n\t\t\twake_up_locked(&ep->wq);\n\t\tif (waitqueue_active(&ep->poll_wait))\n\t\t\tpwake++;\n\t}\n\tspin_unlock_irqrestore(&ep->lock, flags);\n\n\tif (!ep_locked)\n\t\tmutex_unlock(&ep->mtx);\n\n\t/* We have to call this outside the lock */\n\tif (pwake)\n\t\tep_poll_safewake(&ep->poll_wait);\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define EP_UNACTIVE_PTR ((void *) -1L)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define EP_UNACTIVE_PTR ((void *) -1L)\n\nstatic int ep_scan_ready_list(struct eventpoll *ep,\n\t\t\t      int (*sproc)(struct eventpoll *,\n\t\t\t\t\t   struct list_head *, void *),\n\t\t\t      void *priv, int depth, bool ep_locked)\n{\n\tint error, pwake = 0;\n\tunsigned long flags;\n\tstruct epitem *epi, *nepi;\n\tLIST_HEAD(txlist);\n\n\t/*\n\t * We need to lock this because we could be hit by\n\t * eventpoll_release_file() and epoll_ctl().\n\t */\n\n\tif (!ep_locked)\n\t\tmutex_lock_nested(&ep->mtx, depth);\n\n\t/*\n\t * Steal the ready list, and re-init the original one to the\n\t * empty list. Also, set ep->ovflist to NULL so that events\n\t * happening while looping w/out locks, are not lost. We cannot\n\t * have the poll callback to queue directly on ep->rdllist,\n\t * because we want the \"sproc\" callback to be able to do it\n\t * in a lockless way.\n\t */\n\tspin_lock_irqsave(&ep->lock, flags);\n\tlist_splice_init(&ep->rdllist, &txlist);\n\tep->ovflist = NULL;\n\tspin_unlock_irqrestore(&ep->lock, flags);\n\n\t/*\n\t * Now call the callback function.\n\t */\n\terror = (*sproc)(ep, &txlist, priv);\n\n\tspin_lock_irqsave(&ep->lock, flags);\n\t/*\n\t * During the time we spent inside the \"sproc\" callback, some\n\t * other events might have been queued by the poll callback.\n\t * We re-insert them inside the main ready-list here.\n\t */\n\tfor (nepi = ep->ovflist; (epi = nepi) != NULL;\n\t     nepi = epi->next, epi->next = EP_UNACTIVE_PTR) {\n\t\t/*\n\t\t * We need to check if the item is already in the list.\n\t\t * During the \"sproc\" callback execution time, items are\n\t\t * queued into ->ovflist but the \"txlist\" might already\n\t\t * contain them, and the list_splice() below takes care of them.\n\t\t */\n\t\tif (!ep_is_linked(&epi->rdllink)) {\n\t\t\tlist_add_tail(&epi->rdllink, &ep->rdllist);\n\t\t\tep_pm_stay_awake(epi);\n\t\t}\n\t}\n\t/*\n\t * We need to set back ep->ovflist to EP_UNACTIVE_PTR, so that after\n\t * releasing the lock, events will be queued in the normal way inside\n\t * ep->rdllist.\n\t */\n\tep->ovflist = EP_UNACTIVE_PTR;\n\n\t/*\n\t * Quickly re-inject items left on \"txlist\".\n\t */\n\tlist_splice(&txlist, &ep->rdllist);\n\t__pm_relax(ep->ws);\n\n\tif (!list_empty(&ep->rdllist)) {\n\t\t/*\n\t\t * Wake up (if active) both the eventpoll wait list and\n\t\t * the ->poll() wait list (delayed after we release the lock).\n\t\t */\n\t\tif (waitqueue_active(&ep->wq))\n\t\t\twake_up_locked(&ep->wq);\n\t\tif (waitqueue_active(&ep->poll_wait))\n\t\t\tpwake++;\n\t}\n\tspin_unlock_irqrestore(&ep->lock, flags);\n\n\tif (!ep_locked)\n\t\tmutex_unlock(&ep->mtx);\n\n\t/* We have to call this outside the lock */\n\tif (pwake)\n\t\tep_poll_safewake(&ep->poll_wait);\n\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int ep_poll_readyevents_proc(void *priv, void *cookie, int call_nests)\n{\n\tstruct readyevents_arg *arg = priv;\n\n\treturn ep_scan_ready_list(arg->ep, ep_read_events_proc, NULL,\n\t\t\t\t  call_nests + 1, arg->locked);\n}"
  },
  {
    "function_name": "ep_read_events_proc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
    "lines": "803-826",
    "snippet": "static int ep_read_events_proc(struct eventpoll *ep, struct list_head *head,\n\t\t\t       void *priv)\n{\n\tstruct epitem *epi, *tmp;\n\tpoll_table pt;\n\n\tinit_poll_funcptr(&pt, NULL);\n\n\tlist_for_each_entry_safe(epi, tmp, head, rdllink) {\n\t\tif (ep_item_poll(epi, &pt))\n\t\t\treturn POLLIN | POLLRDNORM;\n\t\telse {\n\t\t\t/*\n\t\t\t * Item has been dropped into the ready list by the poll\n\t\t\t * callback, but it's not actually ready, as far as\n\t\t\t * caller requested events goes. We can remove it here.\n\t\t\t */\n\t\t\t__pm_relax(ep_wakeup_source(epi));\n\t\t\tlist_del_init(&epi->rdllink);\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,\n\t\t\t\t poll_table *pt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&epi->rdllink"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pm_relax",
          "args": [
            "ep_wakeup_source(epi)"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_wakeup_source",
          "args": [
            "epi"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "ep_wakeup_source",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
          "lines": "548-551",
          "snippet": "static inline struct wakeup_source *ep_wakeup_source(struct epitem *epi)\n{\n\treturn rcu_dereference_check(epi->ws, lockdep_is_held(&epi->ep->mtx));\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline struct wakeup_source *ep_wakeup_source(struct epitem *epi)\n{\n\treturn rcu_dereference_check(epi->ws, lockdep_is_held(&epi->ep->mtx));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ep_item_poll",
          "args": [
            "epi",
            "&pt"
          ],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "ep_item_poll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
          "lines": "796-801",
          "snippet": "static inline unsigned int ep_item_poll(struct epitem *epi, poll_table *pt)\n{\n\tpt->_key = epi->event.events;\n\n\treturn epi->ffd.file->f_op->poll(epi->ffd.file, pt) & epi->event.events;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,\n\t\t\t\t poll_table *pt);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,\n\t\t\t\t poll_table *pt);\n\nstatic inline unsigned int ep_item_poll(struct epitem *epi, poll_table *pt)\n{\n\tpt->_key = epi->event.events;\n\n\treturn epi->ffd.file->f_op->poll(epi->ffd.file, pt) & epi->event.events;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "epi",
            "tmp",
            "head",
            "rdllink"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_poll_funcptr",
          "args": [
            "&pt",
            "NULL"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,\n\t\t\t\t poll_table *pt);\n\nstatic int ep_read_events_proc(struct eventpoll *ep, struct list_head *head,\n\t\t\t       void *priv)\n{\n\tstruct epitem *epi, *tmp;\n\tpoll_table pt;\n\n\tinit_poll_funcptr(&pt, NULL);\n\n\tlist_for_each_entry_safe(epi, tmp, head, rdllink) {\n\t\tif (ep_item_poll(epi, &pt))\n\t\t\treturn POLLIN | POLLRDNORM;\n\t\telse {\n\t\t\t/*\n\t\t\t * Item has been dropped into the ready list by the poll\n\t\t\t * callback, but it's not actually ready, as far as\n\t\t\t * caller requested events goes. We can remove it here.\n\t\t\t */\n\t\t\t__pm_relax(ep_wakeup_source(epi));\n\t\t\tlist_del_init(&epi->rdllink);\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ep_item_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
    "lines": "796-801",
    "snippet": "static inline unsigned int ep_item_poll(struct epitem *epi, poll_table *pt)\n{\n\tpt->_key = epi->event.events;\n\n\treturn epi->ffd.file->f_op->poll(epi->ffd.file, pt) & epi->event.events;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,\n\t\t\t\t poll_table *pt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "epi->ffd.file->f_op->poll",
          "args": [
            "epi->ffd.file",
            "pt"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,\n\t\t\t\t poll_table *pt);\n\nstatic inline unsigned int ep_item_poll(struct epitem *epi, poll_table *pt)\n{\n\tpt->_key = epi->event.events;\n\n\treturn epi->ffd.file->f_op->poll(epi->ffd.file, pt) & epi->event.events;\n}"
  },
  {
    "function_name": "ep_eventpoll_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
    "lines": "786-794",
    "snippet": "static int ep_eventpoll_release(struct inode *inode, struct file *file)\n{\n\tstruct eventpoll *ep = file->private_data;\n\n\tif (ep)\n\t\tep_free(ep);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ep_free",
          "args": [
            "ep"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "ep_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
          "lines": "734-784",
          "snippet": "static void ep_free(struct eventpoll *ep)\n{\n\tstruct rb_node *rbp;\n\tstruct epitem *epi;\n\n\t/* We need to release all tasks waiting for these file */\n\tif (waitqueue_active(&ep->poll_wait))\n\t\tep_poll_safewake(&ep->poll_wait);\n\n\t/*\n\t * We need to lock this because we could be hit by\n\t * eventpoll_release_file() while we're freeing the \"struct eventpoll\".\n\t * We do not need to hold \"ep->mtx\" here because the epoll file\n\t * is on the way to be removed and no one has references to it\n\t * anymore. The only hit might come from eventpoll_release_file() but\n\t * holding \"epmutex\" is sufficient here.\n\t */\n\tmutex_lock(&epmutex);\n\n\t/*\n\t * Walks through the whole tree by unregistering poll callbacks.\n\t */\n\tfor (rbp = rb_first(&ep->rbr); rbp; rbp = rb_next(rbp)) {\n\t\tepi = rb_entry(rbp, struct epitem, rbn);\n\n\t\tep_unregister_pollwait(ep, epi);\n\t\tcond_resched();\n\t}\n\n\t/*\n\t * Walks through the whole tree by freeing each \"struct epitem\". At this\n\t * point we are sure no poll callbacks will be lingering around, and also by\n\t * holding \"epmutex\" we can be sure that no file cleanup code will hit\n\t * us during this operation. So we can avoid the lock on \"ep->lock\".\n\t * We do not need to lock ep->mtx, either, we only do it to prevent\n\t * a lockdep warning.\n\t */\n\tmutex_lock(&ep->mtx);\n\twhile ((rbp = rb_first(&ep->rbr)) != NULL) {\n\t\tepi = rb_entry(rbp, struct epitem, rbn);\n\t\tep_remove(ep, epi);\n\t\tcond_resched();\n\t}\n\tmutex_unlock(&ep->mtx);\n\n\tmutex_unlock(&epmutex);\n\tmutex_destroy(&ep->mtx);\n\tfree_uid(ep->user);\n\twakeup_source_unregister(ep->ws);\n\tkfree(ep);\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(epmutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic DEFINE_MUTEX(epmutex);\n\nstatic void ep_free(struct eventpoll *ep)\n{\n\tstruct rb_node *rbp;\n\tstruct epitem *epi;\n\n\t/* We need to release all tasks waiting for these file */\n\tif (waitqueue_active(&ep->poll_wait))\n\t\tep_poll_safewake(&ep->poll_wait);\n\n\t/*\n\t * We need to lock this because we could be hit by\n\t * eventpoll_release_file() while we're freeing the \"struct eventpoll\".\n\t * We do not need to hold \"ep->mtx\" here because the epoll file\n\t * is on the way to be removed and no one has references to it\n\t * anymore. The only hit might come from eventpoll_release_file() but\n\t * holding \"epmutex\" is sufficient here.\n\t */\n\tmutex_lock(&epmutex);\n\n\t/*\n\t * Walks through the whole tree by unregistering poll callbacks.\n\t */\n\tfor (rbp = rb_first(&ep->rbr); rbp; rbp = rb_next(rbp)) {\n\t\tepi = rb_entry(rbp, struct epitem, rbn);\n\n\t\tep_unregister_pollwait(ep, epi);\n\t\tcond_resched();\n\t}\n\n\t/*\n\t * Walks through the whole tree by freeing each \"struct epitem\". At this\n\t * point we are sure no poll callbacks will be lingering around, and also by\n\t * holding \"epmutex\" we can be sure that no file cleanup code will hit\n\t * us during this operation. So we can avoid the lock on \"ep->lock\".\n\t * We do not need to lock ep->mtx, either, we only do it to prevent\n\t * a lockdep warning.\n\t */\n\tmutex_lock(&ep->mtx);\n\twhile ((rbp = rb_first(&ep->rbr)) != NULL) {\n\t\tepi = rb_entry(rbp, struct epitem, rbn);\n\t\tep_remove(ep, epi);\n\t\tcond_resched();\n\t}\n\tmutex_unlock(&ep->mtx);\n\n\tmutex_unlock(&epmutex);\n\tmutex_destroy(&ep->mtx);\n\tfree_uid(ep->user);\n\twakeup_source_unregister(ep->ws);\n\tkfree(ep);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int ep_eventpoll_release(struct inode *inode, struct file *file)\n{\n\tstruct eventpoll *ep = file->private_data;\n\n\tif (ep)\n\t\tep_free(ep);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ep_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
    "lines": "734-784",
    "snippet": "static void ep_free(struct eventpoll *ep)\n{\n\tstruct rb_node *rbp;\n\tstruct epitem *epi;\n\n\t/* We need to release all tasks waiting for these file */\n\tif (waitqueue_active(&ep->poll_wait))\n\t\tep_poll_safewake(&ep->poll_wait);\n\n\t/*\n\t * We need to lock this because we could be hit by\n\t * eventpoll_release_file() while we're freeing the \"struct eventpoll\".\n\t * We do not need to hold \"ep->mtx\" here because the epoll file\n\t * is on the way to be removed and no one has references to it\n\t * anymore. The only hit might come from eventpoll_release_file() but\n\t * holding \"epmutex\" is sufficient here.\n\t */\n\tmutex_lock(&epmutex);\n\n\t/*\n\t * Walks through the whole tree by unregistering poll callbacks.\n\t */\n\tfor (rbp = rb_first(&ep->rbr); rbp; rbp = rb_next(rbp)) {\n\t\tepi = rb_entry(rbp, struct epitem, rbn);\n\n\t\tep_unregister_pollwait(ep, epi);\n\t\tcond_resched();\n\t}\n\n\t/*\n\t * Walks through the whole tree by freeing each \"struct epitem\". At this\n\t * point we are sure no poll callbacks will be lingering around, and also by\n\t * holding \"epmutex\" we can be sure that no file cleanup code will hit\n\t * us during this operation. So we can avoid the lock on \"ep->lock\".\n\t * We do not need to lock ep->mtx, either, we only do it to prevent\n\t * a lockdep warning.\n\t */\n\tmutex_lock(&ep->mtx);\n\twhile ((rbp = rb_first(&ep->rbr)) != NULL) {\n\t\tepi = rb_entry(rbp, struct epitem, rbn);\n\t\tep_remove(ep, epi);\n\t\tcond_resched();\n\t}\n\tmutex_unlock(&ep->mtx);\n\n\tmutex_unlock(&epmutex);\n\tmutex_destroy(&ep->mtx);\n\tfree_uid(ep->user);\n\twakeup_source_unregister(ep->ws);\n\tkfree(ep);\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(epmutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ep"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakeup_source_unregister",
          "args": [
            "ep->ws"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_uid",
          "args": [
            "ep->user"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_destroy",
          "args": [
            "&ep->mtx"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&epmutex"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ep->mtx"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_remove",
          "args": [
            "ep",
            "epi"
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "ep_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
          "lines": "692-732",
          "snippet": "static int ep_remove(struct eventpoll *ep, struct epitem *epi)\n{\n\tunsigned long flags;\n\tstruct file *file = epi->ffd.file;\n\n\t/*\n\t * Removes poll wait queue hooks. We _have_ to do this without holding\n\t * the \"ep->lock\" otherwise a deadlock might occur. This because of the\n\t * sequence of the lock acquisition. Here we do \"ep->lock\" then the wait\n\t * queue head lock when unregistering the wait queue. The wakeup callback\n\t * will run by holding the wait queue head lock and will call our callback\n\t * that will try to get \"ep->lock\".\n\t */\n\tep_unregister_pollwait(ep, epi);\n\n\t/* Remove the current item from the list of epoll hooks */\n\tspin_lock(&file->f_lock);\n\tlist_del_rcu(&epi->fllink);\n\tspin_unlock(&file->f_lock);\n\n\trb_erase(&epi->rbn, &ep->rbr);\n\n\tspin_lock_irqsave(&ep->lock, flags);\n\tif (ep_is_linked(&epi->rdllink))\n\t\tlist_del_init(&epi->rdllink);\n\tspin_unlock_irqrestore(&ep->lock, flags);\n\n\twakeup_source_unregister(ep_wakeup_source(epi));\n\t/*\n\t * At this point it is safe to free the eventpoll item. Use the union\n\t * field epi->rcu, since we are trying to minimize the size of\n\t * 'struct epitem'. The 'rbn' field is no longer in use. Protected by\n\t * ep->mtx. The rcu read side, reverse_path_check_proc(), does not make\n\t * use of the rbn field.\n\t */\n\tcall_rcu(&epi->rcu, epi_rcu_free);\n\n\tatomic_long_dec(&ep->user->epoll_watches);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int ep_remove(struct eventpoll *ep, struct epitem *epi)\n{\n\tunsigned long flags;\n\tstruct file *file = epi->ffd.file;\n\n\t/*\n\t * Removes poll wait queue hooks. We _have_ to do this without holding\n\t * the \"ep->lock\" otherwise a deadlock might occur. This because of the\n\t * sequence of the lock acquisition. Here we do \"ep->lock\" then the wait\n\t * queue head lock when unregistering the wait queue. The wakeup callback\n\t * will run by holding the wait queue head lock and will call our callback\n\t * that will try to get \"ep->lock\".\n\t */\n\tep_unregister_pollwait(ep, epi);\n\n\t/* Remove the current item from the list of epoll hooks */\n\tspin_lock(&file->f_lock);\n\tlist_del_rcu(&epi->fllink);\n\tspin_unlock(&file->f_lock);\n\n\trb_erase(&epi->rbn, &ep->rbr);\n\n\tspin_lock_irqsave(&ep->lock, flags);\n\tif (ep_is_linked(&epi->rdllink))\n\t\tlist_del_init(&epi->rdllink);\n\tspin_unlock_irqrestore(&ep->lock, flags);\n\n\twakeup_source_unregister(ep_wakeup_source(epi));\n\t/*\n\t * At this point it is safe to free the eventpoll item. Use the union\n\t * field epi->rcu, since we are trying to minimize the size of\n\t * 'struct epitem'. The 'rbn' field is no longer in use. Protected by\n\t * ep->mtx. The rcu read side, reverse_path_check_proc(), does not make\n\t * use of the rbn field.\n\t */\n\tcall_rcu(&epi->rcu, epi_rcu_free);\n\n\tatomic_long_dec(&ep->user->epoll_watches);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "rbp",
            "structepitem",
            "rbn"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&ep->rbr"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ep->mtx"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_unregister_pollwait",
          "args": [
            "ep",
            "epi"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "ep_unregister_pollwait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
          "lines": "533-545",
          "snippet": "static void ep_unregister_pollwait(struct eventpoll *ep, struct epitem *epi)\n{\n\tstruct list_head *lsthead = &epi->pwqlist;\n\tstruct eppoll_entry *pwq;\n\n\twhile (!list_empty(lsthead)) {\n\t\tpwq = list_first_entry(lsthead, struct eppoll_entry, llink);\n\n\t\tlist_del(&pwq->llink);\n\t\tep_remove_wait_queue(pwq);\n\t\tkmem_cache_free(pwq_cache, pwq);\n\t}\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void ep_unregister_pollwait(struct eventpoll *ep, struct epitem *epi)\n{\n\tstruct list_head *lsthead = &epi->pwqlist;\n\tstruct eppoll_entry *pwq;\n\n\twhile (!list_empty(lsthead)) {\n\t\tpwq = list_first_entry(lsthead, struct eppoll_entry, llink);\n\n\t\tlist_del(&pwq->llink);\n\t\tep_remove_wait_queue(pwq);\n\t\tkmem_cache_free(pwq_cache, pwq);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "rbp",
            "structepitem",
            "rbn"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "rbp"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "&ep->rbr"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&epmutex"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_poll_safewake",
          "args": [
            "&ep->poll_wait"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "ep_poll_safewake",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
          "lines": "506-514",
          "snippet": "static void ep_poll_safewake(wait_queue_head_t *wq)\n{\n\tint this_cpu = get_cpu();\n\n\tep_call_nested(&poll_safewake_ncalls, EP_MAX_NESTS,\n\t\t       ep_poll_wakeup_proc, NULL, wq, (void *) (long) this_cpu);\n\n\tput_cpu();\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define EP_MAX_NESTS 4"
          ],
          "globals_used": [
            "static struct nested_calls poll_safewake_ncalls;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define EP_MAX_NESTS 4\n\nstatic struct nested_calls poll_safewake_ncalls;\n\nstatic void ep_poll_safewake(wait_queue_head_t *wq)\n{\n\tint this_cpu = get_cpu();\n\n\tep_call_nested(&poll_safewake_ncalls, EP_MAX_NESTS,\n\t\t       ep_poll_wakeup_proc, NULL, wq, (void *) (long) this_cpu);\n\n\tput_cpu();\n}"
        }
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&ep->poll_wait"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic DEFINE_MUTEX(epmutex);\n\nstatic void ep_free(struct eventpoll *ep)\n{\n\tstruct rb_node *rbp;\n\tstruct epitem *epi;\n\n\t/* We need to release all tasks waiting for these file */\n\tif (waitqueue_active(&ep->poll_wait))\n\t\tep_poll_safewake(&ep->poll_wait);\n\n\t/*\n\t * We need to lock this because we could be hit by\n\t * eventpoll_release_file() while we're freeing the \"struct eventpoll\".\n\t * We do not need to hold \"ep->mtx\" here because the epoll file\n\t * is on the way to be removed and no one has references to it\n\t * anymore. The only hit might come from eventpoll_release_file() but\n\t * holding \"epmutex\" is sufficient here.\n\t */\n\tmutex_lock(&epmutex);\n\n\t/*\n\t * Walks through the whole tree by unregistering poll callbacks.\n\t */\n\tfor (rbp = rb_first(&ep->rbr); rbp; rbp = rb_next(rbp)) {\n\t\tepi = rb_entry(rbp, struct epitem, rbn);\n\n\t\tep_unregister_pollwait(ep, epi);\n\t\tcond_resched();\n\t}\n\n\t/*\n\t * Walks through the whole tree by freeing each \"struct epitem\". At this\n\t * point we are sure no poll callbacks will be lingering around, and also by\n\t * holding \"epmutex\" we can be sure that no file cleanup code will hit\n\t * us during this operation. So we can avoid the lock on \"ep->lock\".\n\t * We do not need to lock ep->mtx, either, we only do it to prevent\n\t * a lockdep warning.\n\t */\n\tmutex_lock(&ep->mtx);\n\twhile ((rbp = rb_first(&ep->rbr)) != NULL) {\n\t\tepi = rb_entry(rbp, struct epitem, rbn);\n\t\tep_remove(ep, epi);\n\t\tcond_resched();\n\t}\n\tmutex_unlock(&ep->mtx);\n\n\tmutex_unlock(&epmutex);\n\tmutex_destroy(&ep->mtx);\n\tfree_uid(ep->user);\n\twakeup_source_unregister(ep->ws);\n\tkfree(ep);\n}"
  },
  {
    "function_name": "ep_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
    "lines": "692-732",
    "snippet": "static int ep_remove(struct eventpoll *ep, struct epitem *epi)\n{\n\tunsigned long flags;\n\tstruct file *file = epi->ffd.file;\n\n\t/*\n\t * Removes poll wait queue hooks. We _have_ to do this without holding\n\t * the \"ep->lock\" otherwise a deadlock might occur. This because of the\n\t * sequence of the lock acquisition. Here we do \"ep->lock\" then the wait\n\t * queue head lock when unregistering the wait queue. The wakeup callback\n\t * will run by holding the wait queue head lock and will call our callback\n\t * that will try to get \"ep->lock\".\n\t */\n\tep_unregister_pollwait(ep, epi);\n\n\t/* Remove the current item from the list of epoll hooks */\n\tspin_lock(&file->f_lock);\n\tlist_del_rcu(&epi->fllink);\n\tspin_unlock(&file->f_lock);\n\n\trb_erase(&epi->rbn, &ep->rbr);\n\n\tspin_lock_irqsave(&ep->lock, flags);\n\tif (ep_is_linked(&epi->rdllink))\n\t\tlist_del_init(&epi->rdllink);\n\tspin_unlock_irqrestore(&ep->lock, flags);\n\n\twakeup_source_unregister(ep_wakeup_source(epi));\n\t/*\n\t * At this point it is safe to free the eventpoll item. Use the union\n\t * field epi->rcu, since we are trying to minimize the size of\n\t * 'struct epitem'. The 'rbn' field is no longer in use. Protected by\n\t * ep->mtx. The rcu read side, reverse_path_check_proc(), does not make\n\t * use of the rbn field.\n\t */\n\tcall_rcu(&epi->rcu, epi_rcu_free);\n\n\tatomic_long_dec(&ep->user->epoll_watches);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_long_dec",
          "args": [
            "&ep->user->epoll_watches"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&epi->rcu",
            "epi_rcu_free"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wakeup_source_unregister",
          "args": [
            "ep_wakeup_source(epi)"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_wakeup_source",
          "args": [
            "epi"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "ep_wakeup_source",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
          "lines": "548-551",
          "snippet": "static inline struct wakeup_source *ep_wakeup_source(struct epitem *epi)\n{\n\treturn rcu_dereference_check(epi->ws, lockdep_is_held(&epi->ep->mtx));\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline struct wakeup_source *ep_wakeup_source(struct epitem *epi)\n{\n\treturn rcu_dereference_check(epi->ws, lockdep_is_held(&epi->ep->mtx));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&ep->lock",
            "flags"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&epi->rdllink"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_is_linked",
          "args": [
            "&epi->rdllink"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "ep_is_linked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
          "lines": "334-337",
          "snippet": "static inline int ep_is_linked(struct list_head *p)\n{\n\treturn !list_empty(p);\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline int ep_is_linked(struct list_head *p)\n{\n\treturn !list_empty(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&ep->lock",
            "flags"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&epi->rbn",
            "&ep->rbr"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&file->f_lock"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&epi->fllink"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&file->f_lock"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ep_unregister_pollwait",
          "args": [
            "ep",
            "epi"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "ep_unregister_pollwait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
          "lines": "533-545",
          "snippet": "static void ep_unregister_pollwait(struct eventpoll *ep, struct epitem *epi)\n{\n\tstruct list_head *lsthead = &epi->pwqlist;\n\tstruct eppoll_entry *pwq;\n\n\twhile (!list_empty(lsthead)) {\n\t\tpwq = list_first_entry(lsthead, struct eppoll_entry, llink);\n\n\t\tlist_del(&pwq->llink);\n\t\tep_remove_wait_queue(pwq);\n\t\tkmem_cache_free(pwq_cache, pwq);\n\t}\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void ep_unregister_pollwait(struct eventpoll *ep, struct epitem *epi)\n{\n\tstruct list_head *lsthead = &epi->pwqlist;\n\tstruct eppoll_entry *pwq;\n\n\twhile (!list_empty(lsthead)) {\n\t\tpwq = list_first_entry(lsthead, struct eppoll_entry, llink);\n\n\t\tlist_del(&pwq->llink);\n\t\tep_remove_wait_queue(pwq);\n\t\tkmem_cache_free(pwq_cache, pwq);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int ep_remove(struct eventpoll *ep, struct epitem *epi)\n{\n\tunsigned long flags;\n\tstruct file *file = epi->ffd.file;\n\n\t/*\n\t * Removes poll wait queue hooks. We _have_ to do this without holding\n\t * the \"ep->lock\" otherwise a deadlock might occur. This because of the\n\t * sequence of the lock acquisition. Here we do \"ep->lock\" then the wait\n\t * queue head lock when unregistering the wait queue. The wakeup callback\n\t * will run by holding the wait queue head lock and will call our callback\n\t * that will try to get \"ep->lock\".\n\t */\n\tep_unregister_pollwait(ep, epi);\n\n\t/* Remove the current item from the list of epoll hooks */\n\tspin_lock(&file->f_lock);\n\tlist_del_rcu(&epi->fllink);\n\tspin_unlock(&file->f_lock);\n\n\trb_erase(&epi->rbn, &ep->rbr);\n\n\tspin_lock_irqsave(&ep->lock, flags);\n\tif (ep_is_linked(&epi->rdllink))\n\t\tlist_del_init(&epi->rdllink);\n\tspin_unlock_irqrestore(&ep->lock, flags);\n\n\twakeup_source_unregister(ep_wakeup_source(epi));\n\t/*\n\t * At this point it is safe to free the eventpoll item. Use the union\n\t * field epi->rcu, since we are trying to minimize the size of\n\t * 'struct epitem'. The 'rbn' field is no longer in use. Protected by\n\t * ep->mtx. The rcu read side, reverse_path_check_proc(), does not make\n\t * use of the rbn field.\n\t */\n\tcall_rcu(&epi->rcu, epi_rcu_free);\n\n\tatomic_long_dec(&ep->user->epoll_watches);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "epi_rcu_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
    "lines": "682-686",
    "snippet": "static void epi_rcu_free(struct rcu_head *head)\n{\n\tstruct epitem *epi = container_of(head, struct epitem, rcu);\n\tkmem_cache_free(epi_cache, epi);\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "epi_cache",
            "epi"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "head",
            "structepitem",
            "rcu"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void epi_rcu_free(struct rcu_head *head)\n{\n\tstruct epitem *epi = container_of(head, struct epitem, rcu);\n\tkmem_cache_free(epi_cache, epi);\n}"
  },
  {
    "function_name": "ep_scan_ready_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
    "lines": "592-680",
    "snippet": "static int ep_scan_ready_list(struct eventpoll *ep,\n\t\t\t      int (*sproc)(struct eventpoll *,\n\t\t\t\t\t   struct list_head *, void *),\n\t\t\t      void *priv, int depth, bool ep_locked)\n{\n\tint error, pwake = 0;\n\tunsigned long flags;\n\tstruct epitem *epi, *nepi;\n\tLIST_HEAD(txlist);\n\n\t/*\n\t * We need to lock this because we could be hit by\n\t * eventpoll_release_file() and epoll_ctl().\n\t */\n\n\tif (!ep_locked)\n\t\tmutex_lock_nested(&ep->mtx, depth);\n\n\t/*\n\t * Steal the ready list, and re-init the original one to the\n\t * empty list. Also, set ep->ovflist to NULL so that events\n\t * happening while looping w/out locks, are not lost. We cannot\n\t * have the poll callback to queue directly on ep->rdllist,\n\t * because we want the \"sproc\" callback to be able to do it\n\t * in a lockless way.\n\t */\n\tspin_lock_irqsave(&ep->lock, flags);\n\tlist_splice_init(&ep->rdllist, &txlist);\n\tep->ovflist = NULL;\n\tspin_unlock_irqrestore(&ep->lock, flags);\n\n\t/*\n\t * Now call the callback function.\n\t */\n\terror = (*sproc)(ep, &txlist, priv);\n\n\tspin_lock_irqsave(&ep->lock, flags);\n\t/*\n\t * During the time we spent inside the \"sproc\" callback, some\n\t * other events might have been queued by the poll callback.\n\t * We re-insert them inside the main ready-list here.\n\t */\n\tfor (nepi = ep->ovflist; (epi = nepi) != NULL;\n\t     nepi = epi->next, epi->next = EP_UNACTIVE_PTR) {\n\t\t/*\n\t\t * We need to check if the item is already in the list.\n\t\t * During the \"sproc\" callback execution time, items are\n\t\t * queued into ->ovflist but the \"txlist\" might already\n\t\t * contain them, and the list_splice() below takes care of them.\n\t\t */\n\t\tif (!ep_is_linked(&epi->rdllink)) {\n\t\t\tlist_add_tail(&epi->rdllink, &ep->rdllist);\n\t\t\tep_pm_stay_awake(epi);\n\t\t}\n\t}\n\t/*\n\t * We need to set back ep->ovflist to EP_UNACTIVE_PTR, so that after\n\t * releasing the lock, events will be queued in the normal way inside\n\t * ep->rdllist.\n\t */\n\tep->ovflist = EP_UNACTIVE_PTR;\n\n\t/*\n\t * Quickly re-inject items left on \"txlist\".\n\t */\n\tlist_splice(&txlist, &ep->rdllist);\n\t__pm_relax(ep->ws);\n\n\tif (!list_empty(&ep->rdllist)) {\n\t\t/*\n\t\t * Wake up (if active) both the eventpoll wait list and\n\t\t * the ->poll() wait list (delayed after we release the lock).\n\t\t */\n\t\tif (waitqueue_active(&ep->wq))\n\t\t\twake_up_locked(&ep->wq);\n\t\tif (waitqueue_active(&ep->poll_wait))\n\t\t\tpwake++;\n\t}\n\tspin_unlock_irqrestore(&ep->lock, flags);\n\n\tif (!ep_locked)\n\t\tmutex_unlock(&ep->mtx);\n\n\t/* We have to call this outside the lock */\n\tif (pwake)\n\t\tep_poll_safewake(&ep->poll_wait);\n\n\treturn error;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define EP_UNACTIVE_PTR ((void *) -1L)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ep_poll_safewake",
          "args": [
            "&ep->poll_wait"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "ep_poll_safewake",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
          "lines": "506-514",
          "snippet": "static void ep_poll_safewake(wait_queue_head_t *wq)\n{\n\tint this_cpu = get_cpu();\n\n\tep_call_nested(&poll_safewake_ncalls, EP_MAX_NESTS,\n\t\t       ep_poll_wakeup_proc, NULL, wq, (void *) (long) this_cpu);\n\n\tput_cpu();\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define EP_MAX_NESTS 4"
          ],
          "globals_used": [
            "static struct nested_calls poll_safewake_ncalls;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define EP_MAX_NESTS 4\n\nstatic struct nested_calls poll_safewake_ncalls;\n\nstatic void ep_poll_safewake(wait_queue_head_t *wq)\n{\n\tint this_cpu = get_cpu();\n\n\tep_call_nested(&poll_safewake_ncalls, EP_MAX_NESTS,\n\t\t       ep_poll_wakeup_proc, NULL, wq, (void *) (long) this_cpu);\n\n\tput_cpu();\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ep->mtx"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&ep->lock",
            "flags"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&ep->poll_wait"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_locked",
          "args": [
            "&ep->wq"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitqueue_active",
          "args": [
            "&ep->wq"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ep->rdllist"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__pm_relax",
          "args": [
            "ep->ws"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_splice",
          "args": [
            "&txlist",
            "&ep->rdllist"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_pm_stay_awake",
          "args": [
            "epi"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "ep_pm_stay_awake_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
          "lines": "568-577",
          "snippet": "static inline void ep_pm_stay_awake_rcu(struct epitem *epi)\n{\n\tstruct wakeup_source *ws;\n\n\trcu_read_lock();\n\tws = rcu_dereference(epi->ws);\n\tif (ws)\n\t\t__pm_stay_awake(ws);\n\trcu_read_unlock();\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline void ep_pm_stay_awake_rcu(struct epitem *epi)\n{\n\tstruct wakeup_source *ws;\n\n\trcu_read_lock();\n\tws = rcu_dereference(epi->ws);\n\tif (ws)\n\t\t__pm_stay_awake(ws);\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&epi->rdllink",
            "&ep->rdllist"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_is_linked",
          "args": [
            "&epi->rdllink"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "ep_is_linked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
          "lines": "334-337",
          "snippet": "static inline int ep_is_linked(struct list_head *p)\n{\n\treturn !list_empty(p);\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline int ep_is_linked(struct list_head *p)\n{\n\treturn !list_empty(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&ep->lock",
            "flags"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "ep",
            "&txlist",
            "priv"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&ep->lock",
            "flags"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_splice_init",
          "args": [
            "&ep->rdllist",
            "&txlist"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&ep->lock",
            "flags"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&ep->mtx",
            "depth"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "txlist"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define EP_UNACTIVE_PTR ((void *) -1L)\n\nstatic int ep_scan_ready_list(struct eventpoll *ep,\n\t\t\t      int (*sproc)(struct eventpoll *,\n\t\t\t\t\t   struct list_head *, void *),\n\t\t\t      void *priv, int depth, bool ep_locked)\n{\n\tint error, pwake = 0;\n\tunsigned long flags;\n\tstruct epitem *epi, *nepi;\n\tLIST_HEAD(txlist);\n\n\t/*\n\t * We need to lock this because we could be hit by\n\t * eventpoll_release_file() and epoll_ctl().\n\t */\n\n\tif (!ep_locked)\n\t\tmutex_lock_nested(&ep->mtx, depth);\n\n\t/*\n\t * Steal the ready list, and re-init the original one to the\n\t * empty list. Also, set ep->ovflist to NULL so that events\n\t * happening while looping w/out locks, are not lost. We cannot\n\t * have the poll callback to queue directly on ep->rdllist,\n\t * because we want the \"sproc\" callback to be able to do it\n\t * in a lockless way.\n\t */\n\tspin_lock_irqsave(&ep->lock, flags);\n\tlist_splice_init(&ep->rdllist, &txlist);\n\tep->ovflist = NULL;\n\tspin_unlock_irqrestore(&ep->lock, flags);\n\n\t/*\n\t * Now call the callback function.\n\t */\n\terror = (*sproc)(ep, &txlist, priv);\n\n\tspin_lock_irqsave(&ep->lock, flags);\n\t/*\n\t * During the time we spent inside the \"sproc\" callback, some\n\t * other events might have been queued by the poll callback.\n\t * We re-insert them inside the main ready-list here.\n\t */\n\tfor (nepi = ep->ovflist; (epi = nepi) != NULL;\n\t     nepi = epi->next, epi->next = EP_UNACTIVE_PTR) {\n\t\t/*\n\t\t * We need to check if the item is already in the list.\n\t\t * During the \"sproc\" callback execution time, items are\n\t\t * queued into ->ovflist but the \"txlist\" might already\n\t\t * contain them, and the list_splice() below takes care of them.\n\t\t */\n\t\tif (!ep_is_linked(&epi->rdllink)) {\n\t\t\tlist_add_tail(&epi->rdllink, &ep->rdllist);\n\t\t\tep_pm_stay_awake(epi);\n\t\t}\n\t}\n\t/*\n\t * We need to set back ep->ovflist to EP_UNACTIVE_PTR, so that after\n\t * releasing the lock, events will be queued in the normal way inside\n\t * ep->rdllist.\n\t */\n\tep->ovflist = EP_UNACTIVE_PTR;\n\n\t/*\n\t * Quickly re-inject items left on \"txlist\".\n\t */\n\tlist_splice(&txlist, &ep->rdllist);\n\t__pm_relax(ep->ws);\n\n\tif (!list_empty(&ep->rdllist)) {\n\t\t/*\n\t\t * Wake up (if active) both the eventpoll wait list and\n\t\t * the ->poll() wait list (delayed after we release the lock).\n\t\t */\n\t\tif (waitqueue_active(&ep->wq))\n\t\t\twake_up_locked(&ep->wq);\n\t\tif (waitqueue_active(&ep->poll_wait))\n\t\t\tpwake++;\n\t}\n\tspin_unlock_irqrestore(&ep->lock, flags);\n\n\tif (!ep_locked)\n\t\tmutex_unlock(&ep->mtx);\n\n\t/* We have to call this outside the lock */\n\tif (pwake)\n\t\tep_poll_safewake(&ep->poll_wait);\n\n\treturn error;\n}"
  },
  {
    "function_name": "ep_pm_stay_awake_rcu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
    "lines": "568-577",
    "snippet": "static inline void ep_pm_stay_awake_rcu(struct epitem *epi)\n{\n\tstruct wakeup_source *ws;\n\n\trcu_read_lock();\n\tws = rcu_dereference(epi->ws);\n\tif (ws)\n\t\t__pm_stay_awake(ws);\n\trcu_read_unlock();\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pm_stay_awake",
          "args": [
            "ws"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "epi->ws"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline void ep_pm_stay_awake_rcu(struct epitem *epi)\n{\n\tstruct wakeup_source *ws;\n\n\trcu_read_lock();\n\tws = rcu_dereference(epi->ws);\n\tif (ws)\n\t\t__pm_stay_awake(ws);\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "ep_has_wakeup_source",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
    "lines": "562-565",
    "snippet": "static inline bool ep_has_wakeup_source(struct epitem *epi)\n{\n\treturn rcu_access_pointer(epi->ws) ? true : false;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_access_pointer",
          "args": [
            "epi->ws"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline bool ep_has_wakeup_source(struct epitem *epi)\n{\n\treturn rcu_access_pointer(epi->ws) ? true : false;\n}"
  },
  {
    "function_name": "ep_pm_stay_awake",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
    "lines": "554-560",
    "snippet": "static inline void ep_pm_stay_awake(struct epitem *epi)\n{\n\tstruct wakeup_source *ws = ep_wakeup_source(epi);\n\n\tif (ws)\n\t\t__pm_stay_awake(ws);\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__pm_stay_awake",
          "args": [
            "ws"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_wakeup_source",
          "args": [
            "epi"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "ep_wakeup_source",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
          "lines": "548-551",
          "snippet": "static inline struct wakeup_source *ep_wakeup_source(struct epitem *epi)\n{\n\treturn rcu_dereference_check(epi->ws, lockdep_is_held(&epi->ep->mtx));\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline struct wakeup_source *ep_wakeup_source(struct epitem *epi)\n{\n\treturn rcu_dereference_check(epi->ws, lockdep_is_held(&epi->ep->mtx));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline void ep_pm_stay_awake(struct epitem *epi)\n{\n\tstruct wakeup_source *ws = ep_wakeup_source(epi);\n\n\tif (ws)\n\t\t__pm_stay_awake(ws);\n}"
  },
  {
    "function_name": "ep_wakeup_source",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
    "lines": "548-551",
    "snippet": "static inline struct wakeup_source *ep_wakeup_source(struct epitem *epi)\n{\n\treturn rcu_dereference_check(epi->ws, lockdep_is_held(&epi->ep->mtx));\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_dereference_check",
          "args": [
            "epi->ws",
            "lockdep_is_held(&epi->ep->mtx)"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&epi->ep->mtx"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline struct wakeup_source *ep_wakeup_source(struct epitem *epi)\n{\n\treturn rcu_dereference_check(epi->ws, lockdep_is_held(&epi->ep->mtx));\n}"
  },
  {
    "function_name": "ep_unregister_pollwait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
    "lines": "533-545",
    "snippet": "static void ep_unregister_pollwait(struct eventpoll *ep, struct epitem *epi)\n{\n\tstruct list_head *lsthead = &epi->pwqlist;\n\tstruct eppoll_entry *pwq;\n\n\twhile (!list_empty(lsthead)) {\n\t\tpwq = list_first_entry(lsthead, struct eppoll_entry, llink);\n\n\t\tlist_del(&pwq->llink);\n\t\tep_remove_wait_queue(pwq);\n\t\tkmem_cache_free(pwq_cache, pwq);\n\t}\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "pwq_cache",
            "pwq"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_remove_wait_queue",
          "args": [
            "pwq"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "ep_remove_wait_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
          "lines": "516-526",
          "snippet": "static void ep_remove_wait_queue(struct eppoll_entry *pwq)\n{\n\twait_queue_head_t *whead;\n\n\trcu_read_lock();\n\t/* If it is cleared by POLLFREE, it should be rcu-safe */\n\twhead = rcu_dereference(pwq->whead);\n\tif (whead)\n\t\tremove_wait_queue(whead, &pwq->wait);\n\trcu_read_unlock();\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void ep_remove_wait_queue(struct eppoll_entry *pwq)\n{\n\twait_queue_head_t *whead;\n\n\trcu_read_lock();\n\t/* If it is cleared by POLLFREE, it should be rcu-safe */\n\twhead = rcu_dereference(pwq->whead);\n\tif (whead)\n\t\tremove_wait_queue(whead, &pwq->wait);\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&pwq->llink"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "lsthead",
            "structeppoll_entry",
            "llink"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "lsthead"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void ep_unregister_pollwait(struct eventpoll *ep, struct epitem *epi)\n{\n\tstruct list_head *lsthead = &epi->pwqlist;\n\tstruct eppoll_entry *pwq;\n\n\twhile (!list_empty(lsthead)) {\n\t\tpwq = list_first_entry(lsthead, struct eppoll_entry, llink);\n\n\t\tlist_del(&pwq->llink);\n\t\tep_remove_wait_queue(pwq);\n\t\tkmem_cache_free(pwq_cache, pwq);\n\t}\n}"
  },
  {
    "function_name": "ep_remove_wait_queue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
    "lines": "516-526",
    "snippet": "static void ep_remove_wait_queue(struct eppoll_entry *pwq)\n{\n\twait_queue_head_t *whead;\n\n\trcu_read_lock();\n\t/* If it is cleared by POLLFREE, it should be rcu-safe */\n\twhead = rcu_dereference(pwq->whead);\n\tif (whead)\n\t\tremove_wait_queue(whead, &pwq->wait);\n\trcu_read_unlock();\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_wait_queue",
          "args": [
            "whead",
            "&pwq->wait"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "pwq->whead"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void ep_remove_wait_queue(struct eppoll_entry *pwq)\n{\n\twait_queue_head_t *whead;\n\n\trcu_read_lock();\n\t/* If it is cleared by POLLFREE, it should be rcu-safe */\n\twhead = rcu_dereference(pwq->whead);\n\tif (whead)\n\t\tremove_wait_queue(whead, &pwq->wait);\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "ep_poll_safewake",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
    "lines": "506-514",
    "snippet": "static void ep_poll_safewake(wait_queue_head_t *wq)\n{\n\tint this_cpu = get_cpu();\n\n\tep_call_nested(&poll_safewake_ncalls, EP_MAX_NESTS,\n\t\t       ep_poll_wakeup_proc, NULL, wq, (void *) (long) this_cpu);\n\n\tput_cpu();\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define EP_MAX_NESTS 4"
    ],
    "globals_used": [
      "static struct nested_calls poll_safewake_ncalls;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_cpu",
          "args": [],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ep_call_nested",
          "args": [
            "&poll_safewake_ncalls",
            "EP_MAX_NESTS",
            "ep_poll_wakeup_proc",
            "NULL",
            "wq",
            "(void *) (long) this_cpu"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "ep_call_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
          "lines": "398-444",
          "snippet": "static int ep_call_nested(struct nested_calls *ncalls, int max_nests,\n\t\t\t  int (*nproc)(void *, void *, int), void *priv,\n\t\t\t  void *cookie, void *ctx)\n{\n\tint error, call_nests = 0;\n\tunsigned long flags;\n\tstruct list_head *lsthead = &ncalls->tasks_call_list;\n\tstruct nested_call_node *tncur;\n\tstruct nested_call_node tnode;\n\n\tspin_lock_irqsave(&ncalls->lock, flags);\n\n\t/*\n\t * Try to see if the current task is already inside this wakeup call.\n\t * We use a list here, since the population inside this set is always\n\t * very much limited.\n\t */\n\tlist_for_each_entry(tncur, lsthead, llink) {\n\t\tif (tncur->ctx == ctx &&\n\t\t    (tncur->cookie == cookie || ++call_nests > max_nests)) {\n\t\t\t/*\n\t\t\t * Ops ... loop detected or maximum nest level reached.\n\t\t\t * We abort this wake by breaking the cycle itself.\n\t\t\t */\n\t\t\terror = -1;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\t/* Add the current task and cookie to the list */\n\ttnode.ctx = ctx;\n\ttnode.cookie = cookie;\n\tlist_add(&tnode.llink, lsthead);\n\n\tspin_unlock_irqrestore(&ncalls->lock, flags);\n\n\t/* Call the nested function */\n\terror = (*nproc)(priv, cookie, call_nests);\n\n\t/* Remove the current task from the list */\n\tspin_lock_irqsave(&ncalls->lock, flags);\n\tlist_del(&tnode.llink);\nout_unlock:\n\tspin_unlock_irqrestore(&ncalls->lock, flags);\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int ep_call_nested(struct nested_calls *ncalls, int max_nests,\n\t\t\t  int (*nproc)(void *, void *, int), void *priv,\n\t\t\t  void *cookie, void *ctx)\n{\n\tint error, call_nests = 0;\n\tunsigned long flags;\n\tstruct list_head *lsthead = &ncalls->tasks_call_list;\n\tstruct nested_call_node *tncur;\n\tstruct nested_call_node tnode;\n\n\tspin_lock_irqsave(&ncalls->lock, flags);\n\n\t/*\n\t * Try to see if the current task is already inside this wakeup call.\n\t * We use a list here, since the population inside this set is always\n\t * very much limited.\n\t */\n\tlist_for_each_entry(tncur, lsthead, llink) {\n\t\tif (tncur->ctx == ctx &&\n\t\t    (tncur->cookie == cookie || ++call_nests > max_nests)) {\n\t\t\t/*\n\t\t\t * Ops ... loop detected or maximum nest level reached.\n\t\t\t * We abort this wake by breaking the cycle itself.\n\t\t\t */\n\t\t\terror = -1;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\t/* Add the current task and cookie to the list */\n\ttnode.ctx = ctx;\n\ttnode.cookie = cookie;\n\tlist_add(&tnode.llink, lsthead);\n\n\tspin_unlock_irqrestore(&ncalls->lock, flags);\n\n\t/* Call the nested function */\n\terror = (*nproc)(priv, cookie, call_nests);\n\n\t/* Remove the current task from the list */\n\tspin_lock_irqsave(&ncalls->lock, flags);\n\tlist_del(&tnode.llink);\nout_unlock:\n\tspin_unlock_irqrestore(&ncalls->lock, flags);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_cpu",
          "args": [],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define EP_MAX_NESTS 4\n\nstatic struct nested_calls poll_safewake_ncalls;\n\nstatic void ep_poll_safewake(wait_queue_head_t *wq)\n{\n\tint this_cpu = get_cpu();\n\n\tep_call_nested(&poll_safewake_ncalls, EP_MAX_NESTS,\n\t\t       ep_poll_wakeup_proc, NULL, wq, (void *) (long) this_cpu);\n\n\tput_cpu();\n}"
  },
  {
    "function_name": "ep_poll_wakeup_proc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
    "lines": "489-494",
    "snippet": "static int ep_poll_wakeup_proc(void *priv, void *cookie, int call_nests)\n{\n\tep_wake_up_nested((wait_queue_head_t *) cookie, POLLIN,\n\t\t\t  1 + call_nests);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ep_wake_up_nested",
          "args": [
            "(wait_queue_head_t *) cookie",
            "POLLIN",
            "1 + call_nests"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "ep_wake_up_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
          "lines": "482-486",
          "snippet": "static inline void ep_wake_up_nested(wait_queue_head_t *wqueue,\n\t\t\t\t     unsigned long events, int subclass)\n{\n\twake_up_poll(wqueue, events);\n}",
          "includes": [
            "#include <linux/sysctl.h>",
            "#include <linux/rculist.h>",
            "#include <linux/compat.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/mman.h>",
            "#include <asm/io.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/device.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mutex.h>",
            "#include <linux/bitops.h>",
            "#include <linux/mount.h>",
            "#include <linux/eventpoll.h>",
            "#include <linux/wait.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/poll.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/errno.h>",
            "#include <linux/signal.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline void ep_wake_up_nested(wait_queue_head_t *wqueue,\n\t\t\t\t     unsigned long events, int subclass)\n{\n\twake_up_poll(wqueue, events);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int ep_poll_wakeup_proc(void *priv, void *cookie, int call_nests)\n{\n\tep_wake_up_nested((wait_queue_head_t *) cookie, POLLIN,\n\t\t\t  1 + call_nests);\n\treturn 0;\n}"
  },
  {
    "function_name": "ep_wake_up_nested",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
    "lines": "482-486",
    "snippet": "static inline void ep_wake_up_nested(wait_queue_head_t *wqueue,\n\t\t\t\t     unsigned long events, int subclass)\n{\n\twake_up_poll(wqueue, events);\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_poll",
          "args": [
            "wqueue",
            "events"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline void ep_wake_up_nested(wait_queue_head_t *wqueue,\n\t\t\t\t     unsigned long events, int subclass)\n{\n\twake_up_poll(wqueue, events);\n}"
  },
  {
    "function_name": "ep_wake_up_nested",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
    "lines": "472-480",
    "snippet": "static inline void ep_wake_up_nested(wait_queue_head_t *wqueue,\n\t\t\t\t     unsigned long events, int subclass)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave_nested(&wqueue->lock, flags, subclass);\n\twake_up_locked_poll(wqueue, events);\n\tspin_unlock_irqrestore(&wqueue->lock, flags);\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&wqueue->lock",
            "flags"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_locked_poll",
          "args": [
            "wqueue",
            "events"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave_nested",
          "args": [
            "&wqueue->lock",
            "flags",
            "subclass"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline void ep_wake_up_nested(wait_queue_head_t *wqueue,\n\t\t\t\t     unsigned long events, int subclass)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave_nested(&wqueue->lock, flags, subclass);\n\twake_up_locked_poll(wqueue, events);\n\tspin_unlock_irqrestore(&wqueue->lock, flags);\n}"
  },
  {
    "function_name": "ep_call_nested",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
    "lines": "398-444",
    "snippet": "static int ep_call_nested(struct nested_calls *ncalls, int max_nests,\n\t\t\t  int (*nproc)(void *, void *, int), void *priv,\n\t\t\t  void *cookie, void *ctx)\n{\n\tint error, call_nests = 0;\n\tunsigned long flags;\n\tstruct list_head *lsthead = &ncalls->tasks_call_list;\n\tstruct nested_call_node *tncur;\n\tstruct nested_call_node tnode;\n\n\tspin_lock_irqsave(&ncalls->lock, flags);\n\n\t/*\n\t * Try to see if the current task is already inside this wakeup call.\n\t * We use a list here, since the population inside this set is always\n\t * very much limited.\n\t */\n\tlist_for_each_entry(tncur, lsthead, llink) {\n\t\tif (tncur->ctx == ctx &&\n\t\t    (tncur->cookie == cookie || ++call_nests > max_nests)) {\n\t\t\t/*\n\t\t\t * Ops ... loop detected or maximum nest level reached.\n\t\t\t * We abort this wake by breaking the cycle itself.\n\t\t\t */\n\t\t\terror = -1;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\t/* Add the current task and cookie to the list */\n\ttnode.ctx = ctx;\n\ttnode.cookie = cookie;\n\tlist_add(&tnode.llink, lsthead);\n\n\tspin_unlock_irqrestore(&ncalls->lock, flags);\n\n\t/* Call the nested function */\n\terror = (*nproc)(priv, cookie, call_nests);\n\n\t/* Remove the current task from the list */\n\tspin_lock_irqsave(&ncalls->lock, flags);\n\tlist_del(&tnode.llink);\nout_unlock:\n\tspin_unlock_irqrestore(&ncalls->lock, flags);\n\n\treturn error;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&ncalls->lock",
            "flags"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&tnode.llink"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sb_list_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "433-440",
          "snippet": "static inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n__cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_sb_list_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstatic inline void inode_sb_list_del(struct inode *inode)\n{\n\tif (!list_empty(&inode->i_sb_list)) {\n\t\tspin_lock(&inode_sb_list_lock);\n\t\tlist_del_init(&inode->i_sb_list);\n\t\tspin_unlock(&inode_sb_list_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&ncalls->lock",
            "flags"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "priv",
            "cookie",
            "call_nests"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&ncalls->lock",
            "flags"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&tnode.llink",
            "lsthead"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "simple_xattr_list_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xattr.c",
          "lines": "966-972",
          "snippet": "void simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/audit.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/evm.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/xattr.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/vmalloc.h>\n#include <linux/audit.h>\n#include <linux/fsnotify.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n#include <linux/evm.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/xattr.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nvoid simple_xattr_list_add(struct simple_xattrs *xattrs,\n\t\t\t   struct simple_xattr *new_xattr)\n{\n\tspin_lock(&xattrs->lock);\n\tlist_add(&new_xattr->list, &xattrs->head);\n\tspin_unlock(&xattrs->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tncur",
            "lsthead",
            "llink"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&ncalls->lock",
            "flags"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic int ep_call_nested(struct nested_calls *ncalls, int max_nests,\n\t\t\t  int (*nproc)(void *, void *, int), void *priv,\n\t\t\t  void *cookie, void *ctx)\n{\n\tint error, call_nests = 0;\n\tunsigned long flags;\n\tstruct list_head *lsthead = &ncalls->tasks_call_list;\n\tstruct nested_call_node *tncur;\n\tstruct nested_call_node tnode;\n\n\tspin_lock_irqsave(&ncalls->lock, flags);\n\n\t/*\n\t * Try to see if the current task is already inside this wakeup call.\n\t * We use a list here, since the population inside this set is always\n\t * very much limited.\n\t */\n\tlist_for_each_entry(tncur, lsthead, llink) {\n\t\tif (tncur->ctx == ctx &&\n\t\t    (tncur->cookie == cookie || ++call_nests > max_nests)) {\n\t\t\t/*\n\t\t\t * Ops ... loop detected or maximum nest level reached.\n\t\t\t * We abort this wake by breaking the cycle itself.\n\t\t\t */\n\t\t\terror = -1;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\t/* Add the current task and cookie to the list */\n\ttnode.ctx = ctx;\n\ttnode.cookie = cookie;\n\tlist_add(&tnode.llink, lsthead);\n\n\tspin_unlock_irqrestore(&ncalls->lock, flags);\n\n\t/* Call the nested function */\n\terror = (*nproc)(priv, cookie, call_nests);\n\n\t/* Remove the current task from the list */\n\tspin_lock_irqsave(&ncalls->lock, flags);\n\tlist_del(&tnode.llink);\nout_unlock:\n\tspin_unlock_irqrestore(&ncalls->lock, flags);\n\n\treturn error;\n}"
  },
  {
    "function_name": "ep_events_available",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
    "lines": "377-380",
    "snippet": "static inline int ep_events_available(struct eventpoll *ep)\n{\n\treturn !list_empty(&ep->rdllist) || ep->ovflist != EP_UNACTIVE_PTR;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define EP_UNACTIVE_PTR ((void *) -1L)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ep->rdllist"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n#define EP_UNACTIVE_PTR ((void *) -1L)\n\nstatic inline int ep_events_available(struct eventpoll *ep)\n{\n\treturn !list_empty(&ep->rdllist) || ep->ovflist != EP_UNACTIVE_PTR;\n}"
  },
  {
    "function_name": "ep_nested_calls_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
    "lines": "363-367",
    "snippet": "static void ep_nested_calls_init(struct nested_calls *ncalls)\n{\n\tINIT_LIST_HEAD(&ncalls->tasks_call_list);\n\tspin_lock_init(&ncalls->lock);\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&ncalls->lock"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ncalls->tasks_call_list"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void ep_nested_calls_init(struct nested_calls *ncalls)\n{\n\tINIT_LIST_HEAD(&ncalls->tasks_call_list);\n\tspin_lock_init(&ncalls->lock);\n}"
  },
  {
    "function_name": "ep_op_has_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
    "lines": "357-360",
    "snippet": "static inline int ep_op_has_event(int op)\n{\n\treturn op != EPOLL_CTL_DEL;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline int ep_op_has_event(int op)\n{\n\treturn op != EPOLL_CTL_DEL;\n}"
  },
  {
    "function_name": "ep_item_from_epqueue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
    "lines": "351-354",
    "snippet": "static inline struct epitem *ep_item_from_epqueue(poll_table *p)\n{\n\treturn container_of(p, struct ep_pqueue, pt)->epi;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,\n\t\t\t\t poll_table *pt);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "p",
            "structep_pqueue",
            "pt"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead,\n\t\t\t\t poll_table *pt);\n\nstatic inline struct epitem *ep_item_from_epqueue(poll_table *p)\n{\n\treturn container_of(p, struct ep_pqueue, pt)->epi;\n}"
  },
  {
    "function_name": "ep_item_from_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
    "lines": "345-348",
    "snippet": "static inline struct epitem *ep_item_from_wait(wait_queue_t *p)\n{\n\treturn container_of(p, struct eppoll_entry, wait)->base;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "p",
            "structeppoll_entry",
            "wait"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline struct epitem *ep_item_from_wait(wait_queue_t *p)\n{\n\treturn container_of(p, struct eppoll_entry, wait)->base;\n}"
  },
  {
    "function_name": "ep_pwq_from_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
    "lines": "339-342",
    "snippet": "static inline struct eppoll_entry *ep_pwq_from_wait(wait_queue_t *p)\n{\n\treturn container_of(p, struct eppoll_entry, wait);\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "p",
            "structeppoll_entry",
            "wait"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline struct eppoll_entry *ep_pwq_from_wait(wait_queue_t *p)\n{\n\treturn container_of(p, struct eppoll_entry, wait);\n}"
  },
  {
    "function_name": "ep_is_linked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
    "lines": "334-337",
    "snippet": "static inline int ep_is_linked(struct list_head *p)\n{\n\treturn !list_empty(p);\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "p"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "dlm_dirty_list_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlm/dlmthread.c",
          "lines": "505-514",
          "snippet": "static int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}",
          "includes": [
            "#include \"cluster/masklog.h\"",
            "#include \"dlmdomain.h\"",
            "#include \"dlmcommon.h\"",
            "#include \"dlmapi.h\"",
            "#include \"cluster/tcp.h\"",
            "#include \"cluster/nodemanager.h\"",
            "#include \"cluster/heartbeat.h\"",
            "#include <linux/delay.h>",
            "#include <linux/kthread.h>",
            "#include <linux/timer.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/random.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void dlm_flush_asts(struct dlm_ctxt *dlm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"cluster/masklog.h\"\n#include \"dlmdomain.h\"\n#include \"dlmcommon.h\"\n#include \"dlmapi.h\"\n#include \"cluster/tcp.h\"\n#include \"cluster/nodemanager.h\"\n#include \"cluster/heartbeat.h\"\n#include <linux/delay.h>\n#include <linux/kthread.h>\n#include <linux/timer.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/random.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void dlm_flush_asts(struct dlm_ctxt *dlm);\n\nstatic int dlm_dirty_list_empty(struct dlm_ctxt *dlm)\n{\n\tint empty;\n\n\tspin_lock(&dlm->spinlock);\n\tempty = list_empty(&dlm->dirty_list);\n\tspin_unlock(&dlm->spinlock);\n\n\treturn empty;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline int ep_is_linked(struct list_head *p)\n{\n\treturn !list_empty(p);\n}"
  },
  {
    "function_name": "ep_cmp_ffd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
    "lines": "326-331",
    "snippet": "static inline int ep_cmp_ffd(struct epoll_filefd *p1,\n\t\t\t     struct epoll_filefd *p2)\n{\n\treturn (p1->file > p2->file ? +1:\n\t        (p1->file < p2->file ? -1 : p1->fd - p2->fd));\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline int ep_cmp_ffd(struct epoll_filefd *p1,\n\t\t\t     struct epoll_filefd *p2)\n{\n\treturn (p1->file > p2->file ? +1:\n\t        (p1->file < p2->file ? -1 : p1->fd - p2->fd));\n}"
  },
  {
    "function_name": "ep_set_ffd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
    "lines": "318-323",
    "snippet": "static inline void ep_set_ffd(struct epoll_filefd *ffd,\n\t\t\t      struct file *file, int fd)\n{\n\tffd->file = file;\n\tffd->fd = fd;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic inline void ep_set_ffd(struct epoll_filefd *ffd,\n\t\t\t      struct file *file, int fd)\n{\n\tffd->file = file;\n\tffd->fd = fd;\n}"
  },
  {
    "function_name": "is_file_epoll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/eventpoll.c",
    "lines": "312-315",
    "snippet": "static inline int is_file_epoll(struct file *f)\n{\n\treturn f->f_op == &eventpoll_fops;\n}",
    "includes": [
      "#include <linux/sysctl.h>",
      "#include <linux/rculist.h>",
      "#include <linux/compat.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/mman.h>",
      "#include <asm/io.h>",
      "#include <asm/uaccess.h>",
      "#include <linux/device.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mutex.h>",
      "#include <linux/bitops.h>",
      "#include <linux/mount.h>",
      "#include <linux/eventpoll.h>",
      "#include <linux/wait.h>",
      "#include <linux/rbtree.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/hash.h>",
      "#include <linux/list.h>",
      "#include <linux/string.h>",
      "#include <linux/poll.h>",
      "#include <linux/slab.h>",
      "#include <linux/mm.h>",
      "#include <linux/errno.h>",
      "#include <linux/signal.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/kernel.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations eventpoll_fops;",
      "static const struct file_operations eventpoll_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= ep_show_fdinfo,\n#endif\n\t.release\t= ep_eventpoll_release,\n\t.poll\t\t= ep_eventpoll_poll,\n\t.llseek\t\t= noop_llseek,\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sysctl.h>\n#include <linux/rculist.h>\n#include <linux/compat.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/atomic.h>\n#include <asm/mman.h>\n#include <asm/io.h>\n#include <asm/uaccess.h>\n#include <linux/device.h>\n#include <linux/anon_inodes.h>\n#include <linux/mutex.h>\n#include <linux/bitops.h>\n#include <linux/mount.h>\n#include <linux/eventpoll.h>\n#include <linux/wait.h>\n#include <linux/rbtree.h>\n#include <linux/syscalls.h>\n#include <linux/spinlock.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/poll.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/errno.h>\n#include <linux/signal.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\nstatic const struct file_operations eventpoll_fops;\nstatic const struct file_operations eventpoll_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= ep_show_fdinfo,\n#endif\n\t.release\t= ep_eventpoll_release,\n\t.poll\t\t= ep_eventpoll_poll,\n\t.llseek\t\t= noop_llseek,\n};\n\nstatic inline int is_file_epoll(struct file *f)\n{\n\treturn f->f_op == &eventpoll_fops;\n}"
  }
]