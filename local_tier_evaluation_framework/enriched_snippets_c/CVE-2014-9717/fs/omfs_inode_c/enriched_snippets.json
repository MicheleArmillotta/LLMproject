[
  {
    "function_name": "exit_omfs_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/inode.c",
    "lines": "586-589",
    "snippet": "static void __exit exit_omfs_fs(void)\n{\n\tunregister_filesystem(&omfs_fs_type);\n}",
    "includes": [
      "#include \"omfs.h\"",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type omfs_fs_type = {\n\t.owner = THIS_MODULE,\n\t.name = \"omfs\",\n\t.mount = omfs_mount,\n\t.kill_sb = kill_block_super,\n\t.fs_flags = FS_REQUIRES_DEV,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_filesystem",
          "args": [
            "&omfs_fs_type"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"omfs.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/writeback.h>\n#include <linux/vmalloc.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic struct file_system_type omfs_fs_type = {\n\t.owner = THIS_MODULE,\n\t.name = \"omfs\",\n\t.mount = omfs_mount,\n\t.kill_sb = kill_block_super,\n\t.fs_flags = FS_REQUIRES_DEV,\n};\n\nstatic void __exit exit_omfs_fs(void)\n{\n\tunregister_filesystem(&omfs_fs_type);\n}"
  },
  {
    "function_name": "init_omfs_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/inode.c",
    "lines": "581-584",
    "snippet": "static int __init init_omfs_fs(void)\n{\n\treturn register_filesystem(&omfs_fs_type);\n}",
    "includes": [
      "#include \"omfs.h\"",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type omfs_fs_type = {\n\t.owner = THIS_MODULE,\n\t.name = \"omfs\",\n\t.mount = omfs_mount,\n\t.kill_sb = kill_block_super,\n\t.fs_flags = FS_REQUIRES_DEV,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_filesystem",
          "args": [
            "&omfs_fs_type"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"omfs.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/writeback.h>\n#include <linux/vmalloc.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic struct file_system_type omfs_fs_type = {\n\t.owner = THIS_MODULE,\n\t.name = \"omfs\",\n\t.mount = omfs_mount,\n\t.kill_sb = kill_block_super,\n\t.fs_flags = FS_REQUIRES_DEV,\n};\n\nstatic int __init init_omfs_fs(void)\n{\n\treturn register_filesystem(&omfs_fs_type);\n}"
  },
  {
    "function_name": "omfs_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/inode.c",
    "lines": "566-570",
    "snippet": "static struct dentry *omfs_mount(struct file_system_type *fs_type,\n\t\t\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, omfs_fill_super);\n}",
    "includes": [
      "#include \"omfs.h\"",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mount_bdev",
          "args": [
            "fs_type",
            "flags",
            "dev_name",
            "data",
            "omfs_fill_super"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"omfs.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/writeback.h>\n#include <linux/vmalloc.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic struct dentry *omfs_mount(struct file_system_type *fs_type,\n\t\t\tint flags, const char *dev_name, void *data)\n{\n\treturn mount_bdev(fs_type, flags, dev_name, data, omfs_fill_super);\n}"
  },
  {
    "function_name": "omfs_fill_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/inode.c",
    "lines": "425-564",
    "snippet": "static int omfs_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct buffer_head *bh, *bh2;\n\tstruct omfs_super_block *omfs_sb;\n\tstruct omfs_root_block *omfs_rb;\n\tstruct omfs_sb_info *sbi;\n\tstruct inode *root;\n\tint ret = -EINVAL;\n\n\tsave_mount_options(sb, (char *) data);\n\n\tsbi = kzalloc(sizeof(struct omfs_sb_info), GFP_KERNEL);\n\tif (!sbi)\n\t\treturn -ENOMEM;\n\n\tsb->s_fs_info = sbi;\n\n\tsbi->s_uid = current_uid();\n\tsbi->s_gid = current_gid();\n\tsbi->s_dmask = sbi->s_fmask = current_umask();\n\n\tif (!parse_options((char *) data, sbi))\n\t\tgoto end;\n\n\tsb->s_maxbytes = 0xffffffff;\n\n\tsb_set_blocksize(sb, 0x200);\n\n\tbh = sb_bread(sb, 0);\n\tif (!bh)\n\t\tgoto end;\n\n\tomfs_sb = (struct omfs_super_block *)bh->b_data;\n\n\tif (omfs_sb->s_magic != cpu_to_be32(OMFS_MAGIC)) {\n\t\tif (!silent)\n\t\t\tprintk(KERN_ERR \"omfs: Invalid superblock (%x)\\n\",\n\t\t\t\t   omfs_sb->s_magic);\n\t\tgoto out_brelse_bh;\n\t}\n\tsb->s_magic = OMFS_MAGIC;\n\n\tsbi->s_num_blocks = be64_to_cpu(omfs_sb->s_num_blocks);\n\tsbi->s_blocksize = be32_to_cpu(omfs_sb->s_blocksize);\n\tsbi->s_mirrors = be32_to_cpu(omfs_sb->s_mirrors);\n\tsbi->s_root_ino = be64_to_cpu(omfs_sb->s_root_block);\n\tsbi->s_sys_blocksize = be32_to_cpu(omfs_sb->s_sys_blocksize);\n\tmutex_init(&sbi->s_bitmap_lock);\n\n\tif (sbi->s_num_blocks > OMFS_MAX_BLOCKS) {\n\t\tprintk(KERN_ERR \"omfs: sysblock number (%llx) is out of range\\n\",\n\t\t       (unsigned long long)sbi->s_num_blocks);\n\t\tgoto out_brelse_bh;\n\t}\n\n\tif (sbi->s_sys_blocksize > PAGE_SIZE) {\n\t\tprintk(KERN_ERR \"omfs: sysblock size (%d) is out of range\\n\",\n\t\t\tsbi->s_sys_blocksize);\n\t\tgoto out_brelse_bh;\n\t}\n\n\tif (sbi->s_blocksize < sbi->s_sys_blocksize ||\n\t    sbi->s_blocksize > OMFS_MAX_BLOCK_SIZE) {\n\t\tprintk(KERN_ERR \"omfs: block size (%d) is out of range\\n\",\n\t\t\tsbi->s_blocksize);\n\t\tgoto out_brelse_bh;\n\t}\n\n\t/*\n\t * Use sys_blocksize as the fs block since it is smaller than a\n\t * page while the fs blocksize can be larger.\n\t */\n\tsb_set_blocksize(sb, sbi->s_sys_blocksize);\n\n\t/*\n\t * ...and the difference goes into a shift.  sys_blocksize is always\n\t * a power of two factor of blocksize.\n\t */\n\tsbi->s_block_shift = get_bitmask_order(sbi->s_blocksize) -\n\t\tget_bitmask_order(sbi->s_sys_blocksize);\n\n\tbh2 = omfs_bread(sb, be64_to_cpu(omfs_sb->s_root_block));\n\tif (!bh2)\n\t\tgoto out_brelse_bh;\n\n\tomfs_rb = (struct omfs_root_block *)bh2->b_data;\n\n\tsbi->s_bitmap_ino = be64_to_cpu(omfs_rb->r_bitmap);\n\tsbi->s_clustersize = be32_to_cpu(omfs_rb->r_clustersize);\n\n\tif (sbi->s_num_blocks != be64_to_cpu(omfs_rb->r_num_blocks)) {\n\t\tprintk(KERN_ERR \"omfs: block count discrepancy between \"\n\t\t\t\"super and root blocks (%llx, %llx)\\n\",\n\t\t\t(unsigned long long)sbi->s_num_blocks,\n\t\t\t(unsigned long long)be64_to_cpu(omfs_rb->r_num_blocks));\n\t\tgoto out_brelse_bh2;\n\t}\n\n\tif (sbi->s_bitmap_ino != ~0ULL &&\n\t    sbi->s_bitmap_ino > sbi->s_num_blocks) {\n\t\tprintk(KERN_ERR \"omfs: free space bitmap location is corrupt \"\n\t\t\t\"(%llx, total blocks %llx)\\n\",\n\t\t\t(unsigned long long) sbi->s_bitmap_ino,\n\t\t\t(unsigned long long) sbi->s_num_blocks);\n\t\tgoto out_brelse_bh2;\n\t}\n\tif (sbi->s_clustersize < 1 ||\n\t    sbi->s_clustersize > OMFS_MAX_CLUSTER_SIZE) {\n\t\tprintk(KERN_ERR \"omfs: cluster size out of range (%d)\",\n\t\t\tsbi->s_clustersize);\n\t\tgoto out_brelse_bh2;\n\t}\n\n\tret = omfs_get_imap(sb);\n\tif (ret)\n\t\tgoto out_brelse_bh2;\n\n\tsb->s_op = &omfs_sops;\n\n\troot = omfs_iget(sb, be64_to_cpu(omfs_rb->r_root_dir));\n\tif (IS_ERR(root)) {\n\t\tret = PTR_ERR(root);\n\t\tgoto out_brelse_bh2;\n\t}\n\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root)\n\t\tgoto out_brelse_bh2;\n\tprintk(KERN_DEBUG \"omfs: Mounted volume %s\\n\", omfs_rb->r_name);\n\n\tret = 0;\nout_brelse_bh2:\n\tbrelse(bh2);\nout_brelse_bh:\n\tbrelse(bh);\nend:\n\tif (ret)\n\t\tkfree(sbi);\n\treturn ret;\n}",
    "includes": [
      "#include \"omfs.h\"",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct super_operations omfs_sops = {\n\t.write_inode\t= omfs_write_inode,\n\t.evict_inode\t= omfs_evict_inode,\n\t.put_super\t= omfs_put_super,\n\t.statfs\t\t= omfs_statfs,\n\t.show_options\t= generic_show_options,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"omfs: Mounted volume %s\\n\"",
            "omfs_rb->r_name"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_make_root",
          "args": [
            "root"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "d_make_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1857-1871",
          "snippet": "struct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_make_root(struct inode *root_inode)\n{\n\tstruct dentry *res = NULL;\n\n\tif (root_inode) {\n\t\tstatic const struct qstr name = QSTR_INIT(\"/\", 1);\n\n\t\tres = __d_alloc(root_inode->i_sb, &name);\n\t\tif (res)\n\t\t\td_instantiate(res, root_inode);\n\t\telse\n\t\t\tiput(root_inode);\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "root"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "root"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "omfs_iget",
          "args": [
            "sb",
            "be64_to_cpu(omfs_rb->r_root_dir)"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "omfs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/inode.c",
          "lines": "200-262",
          "snippet": "struct inode *omfs_iget(struct super_block *sb, ino_t ino)\n{\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tstruct omfs_inode *oi;\n\tstruct buffer_head *bh;\n\tu64 ctime;\n\tunsigned long nsecs;\n\tstruct inode *inode;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tbh = omfs_bread(inode->i_sb, ino);\n\tif (!bh)\n\t\tgoto iget_failed;\n\n\toi = (struct omfs_inode *)bh->b_data;\n\n\t/* check self */\n\tif (ino != be64_to_cpu(oi->i_head.h_self))\n\t\tgoto fail_bh;\n\n\tinode->i_uid = sbi->s_uid;\n\tinode->i_gid = sbi->s_gid;\n\n\tctime = be64_to_cpu(oi->i_ctime);\n\tnsecs = do_div(ctime, 1000) * 1000L;\n\n\tinode->i_atime.tv_sec = ctime;\n\tinode->i_mtime.tv_sec = ctime;\n\tinode->i_ctime.tv_sec = ctime;\n\tinode->i_atime.tv_nsec = nsecs;\n\tinode->i_mtime.tv_nsec = nsecs;\n\tinode->i_ctime.tv_nsec = nsecs;\n\n\tinode->i_mapping->a_ops = &omfs_aops;\n\n\tswitch (oi->i_type) {\n\tcase OMFS_DIR:\n\t\tinode->i_mode = S_IFDIR | (S_IRWXUGO & ~sbi->s_dmask);\n\t\tinode->i_op = &omfs_dir_inops;\n\t\tinode->i_fop = &omfs_dir_operations;\n\t\tinode->i_size = sbi->s_sys_blocksize;\n\t\tinc_nlink(inode);\n\t\tbreak;\n\tcase OMFS_FILE:\n\t\tinode->i_mode = S_IFREG | (S_IRWXUGO & ~sbi->s_fmask);\n\t\tinode->i_fop = &omfs_file_operations;\n\t\tinode->i_size = be64_to_cpu(oi->i_size);\n\t\tbreak;\n\t}\n\tbrelse(bh);\n\tunlock_new_inode(inode);\n\treturn inode;\nfail_bh:\n\tbrelse(bh);\niget_failed:\n\tiget_failed(inode);\n\treturn ERR_PTR(-EIO);\n}",
          "includes": [
            "#include \"omfs.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/writeback.h>\n#include <linux/vmalloc.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstruct inode *omfs_iget(struct super_block *sb, ino_t ino)\n{\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tstruct omfs_inode *oi;\n\tstruct buffer_head *bh;\n\tu64 ctime;\n\tunsigned long nsecs;\n\tstruct inode *inode;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tbh = omfs_bread(inode->i_sb, ino);\n\tif (!bh)\n\t\tgoto iget_failed;\n\n\toi = (struct omfs_inode *)bh->b_data;\n\n\t/* check self */\n\tif (ino != be64_to_cpu(oi->i_head.h_self))\n\t\tgoto fail_bh;\n\n\tinode->i_uid = sbi->s_uid;\n\tinode->i_gid = sbi->s_gid;\n\n\tctime = be64_to_cpu(oi->i_ctime);\n\tnsecs = do_div(ctime, 1000) * 1000L;\n\n\tinode->i_atime.tv_sec = ctime;\n\tinode->i_mtime.tv_sec = ctime;\n\tinode->i_ctime.tv_sec = ctime;\n\tinode->i_atime.tv_nsec = nsecs;\n\tinode->i_mtime.tv_nsec = nsecs;\n\tinode->i_ctime.tv_nsec = nsecs;\n\n\tinode->i_mapping->a_ops = &omfs_aops;\n\n\tswitch (oi->i_type) {\n\tcase OMFS_DIR:\n\t\tinode->i_mode = S_IFDIR | (S_IRWXUGO & ~sbi->s_dmask);\n\t\tinode->i_op = &omfs_dir_inops;\n\t\tinode->i_fop = &omfs_dir_operations;\n\t\tinode->i_size = sbi->s_sys_blocksize;\n\t\tinc_nlink(inode);\n\t\tbreak;\n\tcase OMFS_FILE:\n\t\tinode->i_mode = S_IFREG | (S_IRWXUGO & ~sbi->s_fmask);\n\t\tinode->i_fop = &omfs_file_operations;\n\t\tinode->i_size = be64_to_cpu(oi->i_size);\n\t\tbreak;\n\t}\n\tbrelse(bh);\n\tunlock_new_inode(inode);\n\treturn inode;\nfail_bh:\n\tbrelse(bh);\niget_failed:\n\tiget_failed(inode);\n\treturn ERR_PTR(-EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "omfs_rb->r_root_dir"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "omfs_get_imap",
          "args": [
            "sb"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "omfs_get_imap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/inode.c",
          "lines": "307-359",
          "snippet": "static int omfs_get_imap(struct super_block *sb)\n{\n\tunsigned int bitmap_size, count, array_size;\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tstruct buffer_head *bh;\n\tunsigned long **ptr;\n\tsector_t block;\n\n\tbitmap_size = DIV_ROUND_UP(sbi->s_num_blocks, 8);\n\tarray_size = DIV_ROUND_UP(bitmap_size, sb->s_blocksize);\n\n\tif (sbi->s_bitmap_ino == ~0ULL)\n\t\tgoto out;\n\n\tsbi->s_imap_size = array_size;\n\tsbi->s_imap = kcalloc(array_size, sizeof(unsigned long *), GFP_KERNEL);\n\tif (!sbi->s_imap)\n\t\tgoto nomem;\n\n\tblock = clus_to_blk(sbi, sbi->s_bitmap_ino);\n\tif (block >= sbi->s_num_blocks)\n\t\tgoto nomem;\n\n\tptr = sbi->s_imap;\n\tfor (count = bitmap_size; count > 0; count -= sb->s_blocksize) {\n\t\tbh = sb_bread(sb, block++);\n\t\tif (!bh)\n\t\t\tgoto nomem_free;\n\t\t*ptr = kmalloc(sb->s_blocksize, GFP_KERNEL);\n\t\tif (!*ptr) {\n\t\t\tbrelse(bh);\n\t\t\tgoto nomem_free;\n\t\t}\n\t\tmemcpy(*ptr, bh->b_data, sb->s_blocksize);\n\t\tif (count < sb->s_blocksize)\n\t\t\tmemset((void *)*ptr + count, 0xff,\n\t\t\t\tsb->s_blocksize - count);\n\t\tbrelse(bh);\n\t\tptr++;\n\t}\nout:\n\treturn 0;\n\nnomem_free:\n\tfor (count = 0; count < array_size; count++)\n\t\tkfree(sbi->s_imap[count]);\n\n\tkfree(sbi->s_imap);\nnomem:\n\tsbi->s_imap = NULL;\n\tsbi->s_imap_size = 0;\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"omfs.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/writeback.h>\n#include <linux/vmalloc.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic int omfs_get_imap(struct super_block *sb)\n{\n\tunsigned int bitmap_size, count, array_size;\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tstruct buffer_head *bh;\n\tunsigned long **ptr;\n\tsector_t block;\n\n\tbitmap_size = DIV_ROUND_UP(sbi->s_num_blocks, 8);\n\tarray_size = DIV_ROUND_UP(bitmap_size, sb->s_blocksize);\n\n\tif (sbi->s_bitmap_ino == ~0ULL)\n\t\tgoto out;\n\n\tsbi->s_imap_size = array_size;\n\tsbi->s_imap = kcalloc(array_size, sizeof(unsigned long *), GFP_KERNEL);\n\tif (!sbi->s_imap)\n\t\tgoto nomem;\n\n\tblock = clus_to_blk(sbi, sbi->s_bitmap_ino);\n\tif (block >= sbi->s_num_blocks)\n\t\tgoto nomem;\n\n\tptr = sbi->s_imap;\n\tfor (count = bitmap_size; count > 0; count -= sb->s_blocksize) {\n\t\tbh = sb_bread(sb, block++);\n\t\tif (!bh)\n\t\t\tgoto nomem_free;\n\t\t*ptr = kmalloc(sb->s_blocksize, GFP_KERNEL);\n\t\tif (!*ptr) {\n\t\t\tbrelse(bh);\n\t\t\tgoto nomem_free;\n\t\t}\n\t\tmemcpy(*ptr, bh->b_data, sb->s_blocksize);\n\t\tif (count < sb->s_blocksize)\n\t\t\tmemset((void *)*ptr + count, 0xff,\n\t\t\t\tsb->s_blocksize - count);\n\t\tbrelse(bh);\n\t\tptr++;\n\t}\nout:\n\treturn 0;\n\nnomem_free:\n\tfor (count = 0; count < array_size; count++)\n\t\tkfree(sbi->s_imap[count]);\n\n\tkfree(sbi->s_imap);\nnomem:\n\tsbi->s_imap = NULL;\n\tsbi->s_imap_size = 0;\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "omfs_rb->r_num_blocks"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "omfs_rb->r_num_blocks"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "omfs_rb->r_clustersize"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "omfs_rb->r_bitmap"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "omfs_bread",
          "args": [
            "sb",
            "be64_to_cpu(omfs_sb->s_root_block)"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "omfs_bread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/inode.c",
          "lines": "22-29",
          "snippet": "struct buffer_head *omfs_bread(struct super_block *sb, sector_t block)\n{\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tif (block >= sbi->s_num_blocks)\n\t\treturn NULL;\n\n\treturn sb_bread(sb, clus_to_blk(sbi, block));\n}",
          "includes": [
            "#include \"omfs.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/writeback.h>\n#include <linux/vmalloc.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstruct buffer_head *omfs_bread(struct super_block *sb, sector_t block)\n{\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tif (block >= sbi->s_num_blocks)\n\t\treturn NULL;\n\n\treturn sb_bread(sb, clus_to_blk(sbi, block));\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "omfs_sb->s_root_block"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bitmask_order",
          "args": [
            "sbi->s_sys_blocksize"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bitmask_order",
          "args": [
            "sbi->s_blocksize"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_set_blocksize",
          "args": [
            "sb",
            "sbi->s_sys_blocksize"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "sb_set_blocksize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/block_dev.c",
          "lines": "116-125",
          "snippet": "int sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/cleancache.h>",
            "#include <linux/log2.h>",
            "#include <linux/namei.h>",
            "#include <linux/uio.h>",
            "#include <linux/mount.h>",
            "#include <linux/mpage.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/swap.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/magic.h>",
            "#include <linux/blkpg.h>",
            "#include <linux/module.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/highmem.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/major.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/cleancache.h>\n#include <linux/log2.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/mount.h>\n#include <linux/mpage.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/swap.h>\n#include <linux/buffer_head.h>\n#include <linux/magic.h>\n#include <linux/blkpg.h>\n#include <linux/module.h>\n#include <linux/blkdev.h>\n#include <linux/highmem.h>\n#include <linux/device_cgroup.h>\n#include <linux/major.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n\nint sb_set_blocksize(struct super_block *sb, int size)\n{\n\tif (set_blocksize(sb->s_bdev, size))\n\t\treturn 0;\n\t/* If we get here, we know size is power of two\n\t * and it's value is between 512 and PAGE_SIZE */\n\tsb->s_blocksize = size;\n\tsb->s_blocksize_bits = blksize_bits(size);\n\treturn sb->s_blocksize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&sbi->s_bitmap_lock"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "omfs_sb->s_sys_blocksize"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "omfs_sb->s_root_block"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "omfs_sb->s_mirrors"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "omfs_sb->s_blocksize"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "omfs_sb->s_num_blocks"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "OMFS_MAGIC"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "0"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_options",
          "args": [
            "(char *) data",
            "sbi"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "parse_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/inode.c",
          "lines": "373-423",
          "snippet": "static int parse_options(char *options, struct omfs_sb_info *sbi)\n{\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint option;\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_uid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tsbi->s_uid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(sbi->s_uid))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tsbi->s_gid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(sbi->s_gid))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_umask:\n\t\t\tif (match_octal(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tsbi->s_fmask = sbi->s_dmask = option;\n\t\t\tbreak;\n\t\tcase Opt_dmask:\n\t\t\tif (match_octal(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tsbi->s_dmask = option;\n\t\t\tbreak;\n\t\tcase Opt_fmask:\n\t\t\tif (match_octal(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tsbi->s_fmask = option;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"omfs.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const match_table_t tokens = {\n\t{Opt_uid, \"uid=%u\"},\n\t{Opt_gid, \"gid=%u\"},\n\t{Opt_umask, \"umask=%o\"},\n\t{Opt_dmask, \"dmask=%o\"},\n\t{Opt_fmask, \"fmask=%o\"},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/writeback.h>\n#include <linux/vmalloc.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic const match_table_t tokens = {\n\t{Opt_uid, \"uid=%u\"},\n\t{Opt_gid, \"gid=%u\"},\n\t{Opt_umask, \"umask=%o\"},\n\t{Opt_dmask, \"dmask=%o\"},\n\t{Opt_fmask, \"fmask=%o\"},\n};\n\nstatic int parse_options(char *options, struct omfs_sb_info *sbi)\n{\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint option;\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_uid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tsbi->s_uid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(sbi->s_uid))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tsbi->s_gid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(sbi->s_gid))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_umask:\n\t\t\tif (match_octal(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tsbi->s_fmask = sbi->s_dmask = option;\n\t\t\tbreak;\n\t\tcase Opt_dmask:\n\t\t\tif (match_octal(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tsbi->s_dmask = option;\n\t\t\tbreak;\n\t\tcase Opt_fmask:\n\t\t\tif (match_octal(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tsbi->s_fmask = option;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_umask",
          "args": [],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "current_umask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs_struct.c",
          "lines": "154-157",
          "snippet": "int current_umask(void)\n{\n\treturn current->fs->umask;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/fs_struct.h>",
            "#include <linux/slab.h>",
            "#include <linux/path.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/fs_struct.h>\n#include <linux/slab.h>\n#include <linux/path.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n\nint current_umask(void)\n{\n\treturn current->fs->umask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_gid",
          "args": [],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_uid",
          "args": [],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct omfs_sb_info)",
            "GFP_KERNEL"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "save_mount_options",
          "args": [
            "sb",
            "(char *) data"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "save_mount_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namespace.c",
          "lines": "1189-1193",
          "snippet": "void save_mount_options(struct super_block *sb, char *options)\n{\n\tBUG_ON(sb->s_options);\n\trcu_assign_pointer(sb->s_options, kstrdup(options, GFP_KERNEL));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"pnode.h\"",
            "#include <linux/task_work.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/magic.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */",
            "#include <linux/fs_struct.h>\t/* get_fs_root et.al. */",
            "#include <linux/init.h>\t\t/* init_rootfs */",
            "#include <linux/idr.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/mnt_namespace.h>",
            "#include <linux/capability.h>",
            "#include <linux/export.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"pnode.h\"\n#include <linux/task_work.h>\n#include <linux/bootmem.h>\n#include <linux/magic.h>\n#include <linux/proc_ns.h>\n#include <linux/uaccess.h>\n#include <linux/fsnotify.h>\t/* fsnotify_vfsmount_delete */\n#include <linux/fs_struct.h>\t/* get_fs_root et.al. */\n#include <linux/init.h>\t\t/* init_rootfs */\n#include <linux/idr.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/user_namespace.h>\n#include <linux/mnt_namespace.h>\n#include <linux/capability.h>\n#include <linux/export.h>\n#include <linux/syscalls.h>\n\nvoid save_mount_options(struct super_block *sb, char *options)\n{\n\tBUG_ON(sb->s_options);\n\trcu_assign_pointer(sb->s_options, kstrdup(options, GFP_KERNEL));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"omfs.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/writeback.h>\n#include <linux/vmalloc.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic const struct super_operations omfs_sops = {\n\t.write_inode\t= omfs_write_inode,\n\t.evict_inode\t= omfs_evict_inode,\n\t.put_super\t= omfs_put_super,\n\t.statfs\t\t= omfs_statfs,\n\t.show_options\t= generic_show_options,\n};\n\nstatic int omfs_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct buffer_head *bh, *bh2;\n\tstruct omfs_super_block *omfs_sb;\n\tstruct omfs_root_block *omfs_rb;\n\tstruct omfs_sb_info *sbi;\n\tstruct inode *root;\n\tint ret = -EINVAL;\n\n\tsave_mount_options(sb, (char *) data);\n\n\tsbi = kzalloc(sizeof(struct omfs_sb_info), GFP_KERNEL);\n\tif (!sbi)\n\t\treturn -ENOMEM;\n\n\tsb->s_fs_info = sbi;\n\n\tsbi->s_uid = current_uid();\n\tsbi->s_gid = current_gid();\n\tsbi->s_dmask = sbi->s_fmask = current_umask();\n\n\tif (!parse_options((char *) data, sbi))\n\t\tgoto end;\n\n\tsb->s_maxbytes = 0xffffffff;\n\n\tsb_set_blocksize(sb, 0x200);\n\n\tbh = sb_bread(sb, 0);\n\tif (!bh)\n\t\tgoto end;\n\n\tomfs_sb = (struct omfs_super_block *)bh->b_data;\n\n\tif (omfs_sb->s_magic != cpu_to_be32(OMFS_MAGIC)) {\n\t\tif (!silent)\n\t\t\tprintk(KERN_ERR \"omfs: Invalid superblock (%x)\\n\",\n\t\t\t\t   omfs_sb->s_magic);\n\t\tgoto out_brelse_bh;\n\t}\n\tsb->s_magic = OMFS_MAGIC;\n\n\tsbi->s_num_blocks = be64_to_cpu(omfs_sb->s_num_blocks);\n\tsbi->s_blocksize = be32_to_cpu(omfs_sb->s_blocksize);\n\tsbi->s_mirrors = be32_to_cpu(omfs_sb->s_mirrors);\n\tsbi->s_root_ino = be64_to_cpu(omfs_sb->s_root_block);\n\tsbi->s_sys_blocksize = be32_to_cpu(omfs_sb->s_sys_blocksize);\n\tmutex_init(&sbi->s_bitmap_lock);\n\n\tif (sbi->s_num_blocks > OMFS_MAX_BLOCKS) {\n\t\tprintk(KERN_ERR \"omfs: sysblock number (%llx) is out of range\\n\",\n\t\t       (unsigned long long)sbi->s_num_blocks);\n\t\tgoto out_brelse_bh;\n\t}\n\n\tif (sbi->s_sys_blocksize > PAGE_SIZE) {\n\t\tprintk(KERN_ERR \"omfs: sysblock size (%d) is out of range\\n\",\n\t\t\tsbi->s_sys_blocksize);\n\t\tgoto out_brelse_bh;\n\t}\n\n\tif (sbi->s_blocksize < sbi->s_sys_blocksize ||\n\t    sbi->s_blocksize > OMFS_MAX_BLOCK_SIZE) {\n\t\tprintk(KERN_ERR \"omfs: block size (%d) is out of range\\n\",\n\t\t\tsbi->s_blocksize);\n\t\tgoto out_brelse_bh;\n\t}\n\n\t/*\n\t * Use sys_blocksize as the fs block since it is smaller than a\n\t * page while the fs blocksize can be larger.\n\t */\n\tsb_set_blocksize(sb, sbi->s_sys_blocksize);\n\n\t/*\n\t * ...and the difference goes into a shift.  sys_blocksize is always\n\t * a power of two factor of blocksize.\n\t */\n\tsbi->s_block_shift = get_bitmask_order(sbi->s_blocksize) -\n\t\tget_bitmask_order(sbi->s_sys_blocksize);\n\n\tbh2 = omfs_bread(sb, be64_to_cpu(omfs_sb->s_root_block));\n\tif (!bh2)\n\t\tgoto out_brelse_bh;\n\n\tomfs_rb = (struct omfs_root_block *)bh2->b_data;\n\n\tsbi->s_bitmap_ino = be64_to_cpu(omfs_rb->r_bitmap);\n\tsbi->s_clustersize = be32_to_cpu(omfs_rb->r_clustersize);\n\n\tif (sbi->s_num_blocks != be64_to_cpu(omfs_rb->r_num_blocks)) {\n\t\tprintk(KERN_ERR \"omfs: block count discrepancy between \"\n\t\t\t\"super and root blocks (%llx, %llx)\\n\",\n\t\t\t(unsigned long long)sbi->s_num_blocks,\n\t\t\t(unsigned long long)be64_to_cpu(omfs_rb->r_num_blocks));\n\t\tgoto out_brelse_bh2;\n\t}\n\n\tif (sbi->s_bitmap_ino != ~0ULL &&\n\t    sbi->s_bitmap_ino > sbi->s_num_blocks) {\n\t\tprintk(KERN_ERR \"omfs: free space bitmap location is corrupt \"\n\t\t\t\"(%llx, total blocks %llx)\\n\",\n\t\t\t(unsigned long long) sbi->s_bitmap_ino,\n\t\t\t(unsigned long long) sbi->s_num_blocks);\n\t\tgoto out_brelse_bh2;\n\t}\n\tif (sbi->s_clustersize < 1 ||\n\t    sbi->s_clustersize > OMFS_MAX_CLUSTER_SIZE) {\n\t\tprintk(KERN_ERR \"omfs: cluster size out of range (%d)\",\n\t\t\tsbi->s_clustersize);\n\t\tgoto out_brelse_bh2;\n\t}\n\n\tret = omfs_get_imap(sb);\n\tif (ret)\n\t\tgoto out_brelse_bh2;\n\n\tsb->s_op = &omfs_sops;\n\n\troot = omfs_iget(sb, be64_to_cpu(omfs_rb->r_root_dir));\n\tif (IS_ERR(root)) {\n\t\tret = PTR_ERR(root);\n\t\tgoto out_brelse_bh2;\n\t}\n\n\tsb->s_root = d_make_root(root);\n\tif (!sb->s_root)\n\t\tgoto out_brelse_bh2;\n\tprintk(KERN_DEBUG \"omfs: Mounted volume %s\\n\", omfs_rb->r_name);\n\n\tret = 0;\nout_brelse_bh2:\n\tbrelse(bh2);\nout_brelse_bh:\n\tbrelse(bh);\nend:\n\tif (ret)\n\t\tkfree(sbi);\n\treturn ret;\n}"
  },
  {
    "function_name": "parse_options",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/inode.c",
    "lines": "373-423",
    "snippet": "static int parse_options(char *options, struct omfs_sb_info *sbi)\n{\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint option;\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_uid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tsbi->s_uid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(sbi->s_uid))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tsbi->s_gid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(sbi->s_gid))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_umask:\n\t\t\tif (match_octal(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tsbi->s_fmask = sbi->s_dmask = option;\n\t\t\tbreak;\n\t\tcase Opt_dmask:\n\t\t\tif (match_octal(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tsbi->s_dmask = option;\n\t\t\tbreak;\n\t\tcase Opt_fmask:\n\t\t\tif (match_octal(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tsbi->s_fmask = option;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"omfs.h\"",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const match_table_t tokens = {\n\t{Opt_uid, \"uid=%u\"},\n\t{Opt_gid, \"gid=%u\"},\n\t{Opt_umask, \"umask=%o\"},\n\t{Opt_dmask, \"dmask=%o\"},\n\t{Opt_fmask, \"fmask=%o\"},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "match_octal",
          "args": [
            "&args[0]",
            "&option"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_octal",
          "args": [
            "&args[0]",
            "&option"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_octal",
          "args": [
            "&args[0]",
            "&option"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_valid",
          "args": [
            "sbi->s_gid"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kgid",
          "args": [
            "current_user_ns()",
            "option"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "&args[0]",
            "&option"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_valid",
          "args": [
            "sbi->s_uid"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_uuid_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/sys.c",
          "lines": "73-82",
          "snippet": "static int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"recovery.h\"",
            "#include \"glops.h\"",
            "#include \"util.h\"",
            "#include \"quota.h\"",
            "#include \"glock.h\"",
            "#include \"super.h\"",
            "#include \"sys.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <linux/genhd.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/kobject.h>",
            "#include <linux/module.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"recovery.h\"\n#include \"glops.h\"\n#include \"util.h\"\n#include \"quota.h\"\n#include \"glock.h\"\n#include \"super.h\"\n#include \"sys.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <linux/genhd.h>\n#include <linux/gfs2_ondisk.h>\n#include <asm/uaccess.h>\n#include <linux/kobject.h>\n#include <linux/module.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n\nstatic int gfs2_uuid_valid(const u8 *uuid)\n{\n\tint i;\n\n\tfor (i = 0; i < 16; i++) {\n\t\tif (uuid[i])\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "current_user_ns()",
            "option"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_int",
          "args": [
            "&args[0]",
            "&option"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_token",
          "args": [
            "p",
            "tokens",
            "args"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&options",
            "\",\""
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"omfs.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/writeback.h>\n#include <linux/vmalloc.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic const match_table_t tokens = {\n\t{Opt_uid, \"uid=%u\"},\n\t{Opt_gid, \"gid=%u\"},\n\t{Opt_umask, \"umask=%o\"},\n\t{Opt_dmask, \"dmask=%o\"},\n\t{Opt_fmask, \"fmask=%o\"},\n};\n\nstatic int parse_options(char *options, struct omfs_sb_info *sbi)\n{\n\tchar *p;\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint option;\n\n\tif (!options)\n\t\treturn 1;\n\n\twhile ((p = strsep(&options, \",\")) != NULL) {\n\t\tint token;\n\t\tif (!*p)\n\t\t\tcontinue;\n\n\t\ttoken = match_token(p, tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_uid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tsbi->s_uid = make_kuid(current_user_ns(), option);\n\t\t\tif (!uid_valid(sbi->s_uid))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_gid:\n\t\t\tif (match_int(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tsbi->s_gid = make_kgid(current_user_ns(), option);\n\t\t\tif (!gid_valid(sbi->s_gid))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\tcase Opt_umask:\n\t\t\tif (match_octal(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tsbi->s_fmask = sbi->s_dmask = option;\n\t\t\tbreak;\n\t\tcase Opt_dmask:\n\t\t\tif (match_octal(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tsbi->s_dmask = option;\n\t\t\tbreak;\n\t\tcase Opt_fmask:\n\t\t\tif (match_octal(&args[0], &option))\n\t\t\t\treturn 0;\n\t\t\tsbi->s_fmask = option;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "omfs_get_imap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/inode.c",
    "lines": "307-359",
    "snippet": "static int omfs_get_imap(struct super_block *sb)\n{\n\tunsigned int bitmap_size, count, array_size;\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tstruct buffer_head *bh;\n\tunsigned long **ptr;\n\tsector_t block;\n\n\tbitmap_size = DIV_ROUND_UP(sbi->s_num_blocks, 8);\n\tarray_size = DIV_ROUND_UP(bitmap_size, sb->s_blocksize);\n\n\tif (sbi->s_bitmap_ino == ~0ULL)\n\t\tgoto out;\n\n\tsbi->s_imap_size = array_size;\n\tsbi->s_imap = kcalloc(array_size, sizeof(unsigned long *), GFP_KERNEL);\n\tif (!sbi->s_imap)\n\t\tgoto nomem;\n\n\tblock = clus_to_blk(sbi, sbi->s_bitmap_ino);\n\tif (block >= sbi->s_num_blocks)\n\t\tgoto nomem;\n\n\tptr = sbi->s_imap;\n\tfor (count = bitmap_size; count > 0; count -= sb->s_blocksize) {\n\t\tbh = sb_bread(sb, block++);\n\t\tif (!bh)\n\t\t\tgoto nomem_free;\n\t\t*ptr = kmalloc(sb->s_blocksize, GFP_KERNEL);\n\t\tif (!*ptr) {\n\t\t\tbrelse(bh);\n\t\t\tgoto nomem_free;\n\t\t}\n\t\tmemcpy(*ptr, bh->b_data, sb->s_blocksize);\n\t\tif (count < sb->s_blocksize)\n\t\t\tmemset((void *)*ptr + count, 0xff,\n\t\t\t\tsb->s_blocksize - count);\n\t\tbrelse(bh);\n\t\tptr++;\n\t}\nout:\n\treturn 0;\n\nnomem_free:\n\tfor (count = 0; count < array_size; count++)\n\t\tkfree(sbi->s_imap[count]);\n\n\tkfree(sbi->s_imap);\nnomem:\n\tsbi->s_imap = NULL;\n\tsbi->s_imap_size = 0;\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"omfs.h\"",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi->s_imap"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi->s_imap[count]"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(void *)*ptr + count",
            "0xff",
            "sb->s_blocksize - count"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "*ptr",
            "bh->b_data",
            "sb->s_blocksize"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sb->s_blocksize",
            "GFP_KERNEL"
          ],
          "line": 335
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "block++"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clus_to_blk",
          "args": [
            "sbi",
            "sbi->s_bitmap_ino"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "clus_to_blk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/omfs.h",
          "lines": "29-32",
          "snippet": "static inline sector_t clus_to_blk(struct omfs_sb_info *sbi, sector_t block)\n{\n\treturn block << sbi->s_block_shift;\n}",
          "includes": [
            "#include \"omfs_fs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs_fs.h\"\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline sector_t clus_to_blk(struct omfs_sb_info *sbi, sector_t block)\n{\n\treturn block << sbi->s_block_shift;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "array_size",
            "sizeof(unsigned long *)",
            "GFP_KERNEL"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "bitmap_size",
            "sb->s_blocksize"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "sbi->s_num_blocks",
            "8"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OMFS_SB",
          "args": [
            "sb"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "OMFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/omfs.h",
          "lines": "34-37",
          "snippet": "static inline struct omfs_sb_info *OMFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"omfs_fs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs_fs.h\"\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline struct omfs_sb_info *OMFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"omfs.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/writeback.h>\n#include <linux/vmalloc.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic int omfs_get_imap(struct super_block *sb)\n{\n\tunsigned int bitmap_size, count, array_size;\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tstruct buffer_head *bh;\n\tunsigned long **ptr;\n\tsector_t block;\n\n\tbitmap_size = DIV_ROUND_UP(sbi->s_num_blocks, 8);\n\tarray_size = DIV_ROUND_UP(bitmap_size, sb->s_blocksize);\n\n\tif (sbi->s_bitmap_ino == ~0ULL)\n\t\tgoto out;\n\n\tsbi->s_imap_size = array_size;\n\tsbi->s_imap = kcalloc(array_size, sizeof(unsigned long *), GFP_KERNEL);\n\tif (!sbi->s_imap)\n\t\tgoto nomem;\n\n\tblock = clus_to_blk(sbi, sbi->s_bitmap_ino);\n\tif (block >= sbi->s_num_blocks)\n\t\tgoto nomem;\n\n\tptr = sbi->s_imap;\n\tfor (count = bitmap_size; count > 0; count -= sb->s_blocksize) {\n\t\tbh = sb_bread(sb, block++);\n\t\tif (!bh)\n\t\t\tgoto nomem_free;\n\t\t*ptr = kmalloc(sb->s_blocksize, GFP_KERNEL);\n\t\tif (!*ptr) {\n\t\t\tbrelse(bh);\n\t\t\tgoto nomem_free;\n\t\t}\n\t\tmemcpy(*ptr, bh->b_data, sb->s_blocksize);\n\t\tif (count < sb->s_blocksize)\n\t\t\tmemset((void *)*ptr + count, 0xff,\n\t\t\t\tsb->s_blocksize - count);\n\t\tbrelse(bh);\n\t\tptr++;\n\t}\nout:\n\treturn 0;\n\nnomem_free:\n\tfor (count = 0; count < array_size; count++)\n\t\tkfree(sbi->s_imap[count]);\n\n\tkfree(sbi->s_imap);\nnomem:\n\tsbi->s_imap = NULL;\n\tsbi->s_imap_size = 0;\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "omfs_statfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/inode.c",
    "lines": "272-290",
    "snippet": "static int omfs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *s = dentry->d_sb;\n\tstruct omfs_sb_info *sbi = OMFS_SB(s);\n\tu64 id = huge_encode_dev(s->s_bdev->bd_dev);\n\n\tbuf->f_type = OMFS_MAGIC;\n\tbuf->f_bsize = sbi->s_blocksize;\n\tbuf->f_blocks = sbi->s_num_blocks;\n\tbuf->f_files = sbi->s_num_blocks;\n\tbuf->f_namelen = OMFS_NAMELEN;\n\tbuf->f_fsid.val[0] = (u32)id;\n\tbuf->f_fsid.val[1] = (u32)(id >> 32);\n\n\tbuf->f_bfree = buf->f_bavail = buf->f_ffree =\n\t\tomfs_count_free(s);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"omfs.h\"",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "omfs_count_free",
          "args": [
            "s"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "omfs_count_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/bitmap.c",
          "lines": "7-18",
          "snippet": "unsigned long omfs_count_free(struct super_block *sb)\n{\n\tunsigned int i;\n\tunsigned long sum = 0;\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tint nbits = sb->s_blocksize * 8;\n\n\tfor (i = 0; i < sbi->s_imap_size; i++)\n\t\tsum += nbits - bitmap_weight(sbi->s_imap[i], nbits);\n\n\treturn sum;\n}",
          "includes": [
            "#include \"omfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs.h\"\n#include <asm/div64.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nunsigned long omfs_count_free(struct super_block *sb)\n{\n\tunsigned int i;\n\tunsigned long sum = 0;\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tint nbits = sb->s_blocksize * 8;\n\n\tfor (i = 0; i < sbi->s_imap_size; i++)\n\t\tsum += nbits - bitmap_weight(sbi->s_imap[i], nbits);\n\n\treturn sum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "id >> 32"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "huge_encode_dev",
          "args": [
            "s->s_bdev->bd_dev"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OMFS_SB",
          "args": [
            "s"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "OMFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/omfs.h",
          "lines": "34-37",
          "snippet": "static inline struct omfs_sb_info *OMFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"omfs_fs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs_fs.h\"\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline struct omfs_sb_info *OMFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"omfs.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/writeback.h>\n#include <linux/vmalloc.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic int omfs_statfs(struct dentry *dentry, struct kstatfs *buf)\n{\n\tstruct super_block *s = dentry->d_sb;\n\tstruct omfs_sb_info *sbi = OMFS_SB(s);\n\tu64 id = huge_encode_dev(s->s_bdev->bd_dev);\n\n\tbuf->f_type = OMFS_MAGIC;\n\tbuf->f_bsize = sbi->s_blocksize;\n\tbuf->f_blocks = sbi->s_num_blocks;\n\tbuf->f_files = sbi->s_num_blocks;\n\tbuf->f_namelen = OMFS_NAMELEN;\n\tbuf->f_fsid.val[0] = (u32)id;\n\tbuf->f_fsid.val[1] = (u32)(id >> 32);\n\n\tbuf->f_bfree = buf->f_bavail = buf->f_ffree =\n\t\tomfs_count_free(s);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "omfs_put_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/inode.c",
    "lines": "264-270",
    "snippet": "static void omfs_put_super(struct super_block *sb)\n{\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tkfree(sbi->s_imap);\n\tkfree(sbi);\n\tsb->s_fs_info = NULL;\n}",
    "includes": [
      "#include \"omfs.h\"",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sbi->s_imap"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OMFS_SB",
          "args": [
            "sb"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "OMFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/omfs.h",
          "lines": "34-37",
          "snippet": "static inline struct omfs_sb_info *OMFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"omfs_fs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs_fs.h\"\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline struct omfs_sb_info *OMFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"omfs.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/writeback.h>\n#include <linux/vmalloc.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic void omfs_put_super(struct super_block *sb)\n{\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tkfree(sbi->s_imap);\n\tkfree(sbi);\n\tsb->s_fs_info = NULL;\n}"
  },
  {
    "function_name": "omfs_iget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/inode.c",
    "lines": "200-262",
    "snippet": "struct inode *omfs_iget(struct super_block *sb, ino_t ino)\n{\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tstruct omfs_inode *oi;\n\tstruct buffer_head *bh;\n\tu64 ctime;\n\tunsigned long nsecs;\n\tstruct inode *inode;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tbh = omfs_bread(inode->i_sb, ino);\n\tif (!bh)\n\t\tgoto iget_failed;\n\n\toi = (struct omfs_inode *)bh->b_data;\n\n\t/* check self */\n\tif (ino != be64_to_cpu(oi->i_head.h_self))\n\t\tgoto fail_bh;\n\n\tinode->i_uid = sbi->s_uid;\n\tinode->i_gid = sbi->s_gid;\n\n\tctime = be64_to_cpu(oi->i_ctime);\n\tnsecs = do_div(ctime, 1000) * 1000L;\n\n\tinode->i_atime.tv_sec = ctime;\n\tinode->i_mtime.tv_sec = ctime;\n\tinode->i_ctime.tv_sec = ctime;\n\tinode->i_atime.tv_nsec = nsecs;\n\tinode->i_mtime.tv_nsec = nsecs;\n\tinode->i_ctime.tv_nsec = nsecs;\n\n\tinode->i_mapping->a_ops = &omfs_aops;\n\n\tswitch (oi->i_type) {\n\tcase OMFS_DIR:\n\t\tinode->i_mode = S_IFDIR | (S_IRWXUGO & ~sbi->s_dmask);\n\t\tinode->i_op = &omfs_dir_inops;\n\t\tinode->i_fop = &omfs_dir_operations;\n\t\tinode->i_size = sbi->s_sys_blocksize;\n\t\tinc_nlink(inode);\n\t\tbreak;\n\tcase OMFS_FILE:\n\t\tinode->i_mode = S_IFREG | (S_IRWXUGO & ~sbi->s_fmask);\n\t\tinode->i_fop = &omfs_file_operations;\n\t\tinode->i_size = be64_to_cpu(oi->i_size);\n\t\tbreak;\n\t}\n\tbrelse(bh);\n\tunlock_new_inode(inode);\n\treturn inode;\nfail_bh:\n\tbrelse(bh);\niget_failed:\n\tiget_failed(inode);\n\treturn ERR_PTR(-EIO);\n}",
    "includes": [
      "#include \"omfs.h\"",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iget_failed",
          "args": [
            "inode"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "iget_failed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "208-213",
          "snippet": "void iget_failed(struct inode *inode)\n{\n\tmake_bad_inode(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nvoid iget_failed(struct inode *inode)\n{\n\tmake_bad_inode(inode);\n\tunlock_new_inode(inode);\n\tiput(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_new_inode",
          "args": [
            "inode"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "oi->i_size"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "inode"
          ],
          "line": 246
        },
        "resolved": true,
        "details": {
          "function_name": "inc_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "327-335",
          "snippet": "void inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "ctime",
            "1000"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "oi->i_ctime"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "oi->i_head.h_self"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "omfs_bread",
          "args": [
            "inode->i_sb",
            "ino"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "omfs_bread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/inode.c",
          "lines": "22-29",
          "snippet": "struct buffer_head *omfs_bread(struct super_block *sb, sector_t block)\n{\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tif (block >= sbi->s_num_blocks)\n\t\treturn NULL;\n\n\treturn sb_bread(sb, clus_to_blk(sbi, block));\n}",
          "includes": [
            "#include \"omfs.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/writeback.h>\n#include <linux/vmalloc.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstruct buffer_head *omfs_bread(struct super_block *sb, sector_t block)\n{\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tif (block >= sbi->s_num_blocks)\n\t\treturn NULL;\n\n\treturn sb_bread(sb, clus_to_blk(sbi, block));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iget_locked",
          "args": [
            "sb",
            "ino"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "iget_locked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1063-1109",
          "snippet": "struct inode *iget_locked(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode_fast(sb, head, ino);\n\tspin_unlock(&inode_hash_lock);\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode_fast(sb, head, ino);\n\t\tif (!old) {\n\t\t\tinode->i_ino = ino;\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hlist_head *inode_hashtable",
            "static __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);",
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic struct hlist_head *inode_hashtable;\nstatic __cacheline_aligned_in_smp DEFINE_SPINLOCK(inode_hash_lock);\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nstruct inode *iget_locked(struct super_block *sb, unsigned long ino)\n{\n\tstruct hlist_head *head = inode_hashtable + hash(sb, ino);\n\tstruct inode *inode;\n\n\tspin_lock(&inode_hash_lock);\n\tinode = find_inode_fast(sb, head, ino);\n\tspin_unlock(&inode_hash_lock);\n\tif (inode) {\n\t\twait_on_inode(inode);\n\t\treturn inode;\n\t}\n\n\tinode = alloc_inode(sb);\n\tif (inode) {\n\t\tstruct inode *old;\n\n\t\tspin_lock(&inode_hash_lock);\n\t\t/* We released the lock, so.. */\n\t\told = find_inode_fast(sb, head, ino);\n\t\tif (!old) {\n\t\t\tinode->i_ino = ino;\n\t\t\tspin_lock(&inode->i_lock);\n\t\t\tinode->i_state = I_NEW;\n\t\t\thlist_add_head(&inode->i_hash, head);\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\tinode_sb_list_add(inode);\n\t\t\tspin_unlock(&inode_hash_lock);\n\n\t\t\t/* Return the locked inode with I_NEW set, the\n\t\t\t * caller is responsible for filling in the contents\n\t\t\t */\n\t\t\treturn inode;\n\t\t}\n\n\t\t/*\n\t\t * Uhhuh, somebody else created the same inode under\n\t\t * us. Use the old inode instead of the one we just\n\t\t * allocated.\n\t\t */\n\t\tspin_unlock(&inode_hash_lock);\n\t\tdestroy_inode(inode);\n\t\tinode = old;\n\t\twait_on_inode(inode);\n\t}\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OMFS_SB",
          "args": [
            "sb"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "OMFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/omfs.h",
          "lines": "34-37",
          "snippet": "static inline struct omfs_sb_info *OMFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"omfs_fs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs_fs.h\"\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline struct omfs_sb_info *OMFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"omfs.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/writeback.h>\n#include <linux/vmalloc.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstruct inode *omfs_iget(struct super_block *sb, ino_t ino)\n{\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tstruct omfs_inode *oi;\n\tstruct buffer_head *bh;\n\tu64 ctime;\n\tunsigned long nsecs;\n\tstruct inode *inode;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tbh = omfs_bread(inode->i_sb, ino);\n\tif (!bh)\n\t\tgoto iget_failed;\n\n\toi = (struct omfs_inode *)bh->b_data;\n\n\t/* check self */\n\tif (ino != be64_to_cpu(oi->i_head.h_self))\n\t\tgoto fail_bh;\n\n\tinode->i_uid = sbi->s_uid;\n\tinode->i_gid = sbi->s_gid;\n\n\tctime = be64_to_cpu(oi->i_ctime);\n\tnsecs = do_div(ctime, 1000) * 1000L;\n\n\tinode->i_atime.tv_sec = ctime;\n\tinode->i_mtime.tv_sec = ctime;\n\tinode->i_ctime.tv_sec = ctime;\n\tinode->i_atime.tv_nsec = nsecs;\n\tinode->i_mtime.tv_nsec = nsecs;\n\tinode->i_ctime.tv_nsec = nsecs;\n\n\tinode->i_mapping->a_ops = &omfs_aops;\n\n\tswitch (oi->i_type) {\n\tcase OMFS_DIR:\n\t\tinode->i_mode = S_IFDIR | (S_IRWXUGO & ~sbi->s_dmask);\n\t\tinode->i_op = &omfs_dir_inops;\n\t\tinode->i_fop = &omfs_dir_operations;\n\t\tinode->i_size = sbi->s_sys_blocksize;\n\t\tinc_nlink(inode);\n\t\tbreak;\n\tcase OMFS_FILE:\n\t\tinode->i_mode = S_IFREG | (S_IRWXUGO & ~sbi->s_fmask);\n\t\tinode->i_fop = &omfs_file_operations;\n\t\tinode->i_size = be64_to_cpu(oi->i_size);\n\t\tbreak;\n\t}\n\tbrelse(bh);\n\tunlock_new_inode(inode);\n\treturn inode;\nfail_bh:\n\tbrelse(bh);\niget_failed:\n\tiget_failed(inode);\n\treturn ERR_PTR(-EIO);\n}"
  },
  {
    "function_name": "omfs_evict_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/inode.c",
    "lines": "184-198",
    "snippet": "static void omfs_evict_inode(struct inode *inode)\n{\n\ttruncate_inode_pages_final(&inode->i_data);\n\tclear_inode(inode);\n\n\tif (inode->i_nlink)\n\t\treturn;\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_size = 0;\n\t\tomfs_shrink_inode(inode);\n\t}\n\n\tomfs_clear_range(inode->i_sb, inode->i_ino, 2);\n}",
    "includes": [
      "#include \"omfs.h\"",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "omfs_clear_range",
          "args": [
            "inode->i_sb",
            "inode->i_ino",
            "2"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "omfs_clear_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/bitmap.c",
          "lines": "174-193",
          "snippet": "int omfs_clear_range(struct super_block *sb, u64 block, int count)\n{\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tint bits_per_entry = 8 * sb->s_blocksize;\n\tu64 tmp;\n\tunsigned int map, bit;\n\tint ret;\n\n\ttmp = block;\n\tbit = do_div(tmp, bits_per_entry);\n\tmap = tmp;\n\n\tif (map >= sbi->s_imap_size)\n\t\treturn 0;\n\n\tmutex_lock(&sbi->s_bitmap_lock);\n\tret = set_run(sb, map, bits_per_entry, bit, count, 0);\n\tmutex_unlock(&sbi->s_bitmap_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"omfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs.h\"\n#include <asm/div64.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nint omfs_clear_range(struct super_block *sb, u64 block, int count)\n{\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tint bits_per_entry = 8 * sb->s_blocksize;\n\tu64 tmp;\n\tunsigned int map, bit;\n\tint ret;\n\n\ttmp = block;\n\tbit = do_div(tmp, bits_per_entry);\n\tmap = tmp;\n\n\tif (map >= sbi->s_imap_size)\n\t\treturn 0;\n\n\tmutex_lock(&sbi->s_bitmap_lock);\n\tret = set_run(sb, map, bits_per_entry, bit, count, 0);\n\tmutex_unlock(&sbi->s_bitmap_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "omfs_shrink_inode",
          "args": [
            "inode"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "omfs_shrink_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/file.c",
          "lines": "31-104",
          "snippet": "int omfs_shrink_inode(struct inode *inode)\n{\n\tstruct omfs_sb_info *sbi = OMFS_SB(inode->i_sb);\n\tstruct omfs_extent *oe;\n\tstruct omfs_extent_entry *entry;\n\tstruct buffer_head *bh;\n\tu64 next, last;\n\tu32 extent_count;\n\tu32 max_extents;\n\tint ret;\n\n\t/* traverse extent table, freeing each entry that is greater\n\t * than inode->i_size;\n\t */\n\tnext = inode->i_ino;\n\n\t/* only support truncate -> 0 for now */\n\tret = -EIO;\n\tif (inode->i_size != 0)\n\t\tgoto out;\n\n\tbh = omfs_bread(inode->i_sb, next);\n\tif (!bh)\n\t\tgoto out;\n\n\toe = (struct omfs_extent *)(&bh->b_data[OMFS_EXTENT_START]);\n\tmax_extents = omfs_max_extents(sbi, OMFS_EXTENT_START);\n\n\tfor (;;) {\n\n\t\tif (omfs_is_bad(sbi, (struct omfs_header *) bh->b_data, next))\n\t\t\tgoto out_brelse;\n\n\t\textent_count = be32_to_cpu(oe->e_extent_count);\n\n\t\tif (extent_count > max_extents)\n\t\t\tgoto out_brelse;\n\n\t\tlast = next;\n\t\tnext = be64_to_cpu(oe->e_next);\n\t\tentry = &oe->e_entry;\n\n\t\t/* ignore last entry as it is the terminator */\n\t\tfor (; extent_count > 1; extent_count--) {\n\t\t\tu64 start, count;\n\t\t\tstart = be64_to_cpu(entry->e_cluster);\n\t\t\tcount = be64_to_cpu(entry->e_blocks);\n\n\t\t\tomfs_clear_range(inode->i_sb, start, (int) count);\n\t\t\tentry++;\n\t\t}\n\t\tomfs_make_empty_table(bh, (char *) oe - bh->b_data);\n\t\tmark_buffer_dirty(bh);\n\t\tbrelse(bh);\n\n\t\tif (last != inode->i_ino)\n\t\t\tomfs_clear_range(inode->i_sb, last, sbi->s_mirrors);\n\n\t\tif (next == ~0)\n\t\t\tbreak;\n\n\t\tbh = omfs_bread(inode->i_sb, next);\n\t\tif (!bh)\n\t\t\tgoto out;\n\t\toe = (struct omfs_extent *) (&bh->b_data[OMFS_EXTENT_CONT]);\n\t\tmax_extents = omfs_max_extents(sbi, OMFS_EXTENT_CONT);\n\t}\n\tret = 0;\nout:\n\treturn ret;\nout_brelse:\n\tbrelse(bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"omfs.h\"",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs.h\"\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nint omfs_shrink_inode(struct inode *inode)\n{\n\tstruct omfs_sb_info *sbi = OMFS_SB(inode->i_sb);\n\tstruct omfs_extent *oe;\n\tstruct omfs_extent_entry *entry;\n\tstruct buffer_head *bh;\n\tu64 next, last;\n\tu32 extent_count;\n\tu32 max_extents;\n\tint ret;\n\n\t/* traverse extent table, freeing each entry that is greater\n\t * than inode->i_size;\n\t */\n\tnext = inode->i_ino;\n\n\t/* only support truncate -> 0 for now */\n\tret = -EIO;\n\tif (inode->i_size != 0)\n\t\tgoto out;\n\n\tbh = omfs_bread(inode->i_sb, next);\n\tif (!bh)\n\t\tgoto out;\n\n\toe = (struct omfs_extent *)(&bh->b_data[OMFS_EXTENT_START]);\n\tmax_extents = omfs_max_extents(sbi, OMFS_EXTENT_START);\n\n\tfor (;;) {\n\n\t\tif (omfs_is_bad(sbi, (struct omfs_header *) bh->b_data, next))\n\t\t\tgoto out_brelse;\n\n\t\textent_count = be32_to_cpu(oe->e_extent_count);\n\n\t\tif (extent_count > max_extents)\n\t\t\tgoto out_brelse;\n\n\t\tlast = next;\n\t\tnext = be64_to_cpu(oe->e_next);\n\t\tentry = &oe->e_entry;\n\n\t\t/* ignore last entry as it is the terminator */\n\t\tfor (; extent_count > 1; extent_count--) {\n\t\t\tu64 start, count;\n\t\t\tstart = be64_to_cpu(entry->e_cluster);\n\t\t\tcount = be64_to_cpu(entry->e_blocks);\n\n\t\t\tomfs_clear_range(inode->i_sb, start, (int) count);\n\t\t\tentry++;\n\t\t}\n\t\tomfs_make_empty_table(bh, (char *) oe - bh->b_data);\n\t\tmark_buffer_dirty(bh);\n\t\tbrelse(bh);\n\n\t\tif (last != inode->i_ino)\n\t\t\tomfs_clear_range(inode->i_sb, last, sbi->s_mirrors);\n\n\t\tif (next == ~0)\n\t\t\tbreak;\n\n\t\tbh = omfs_bread(inode->i_sb, next);\n\t\tif (!bh)\n\t\t\tgoto out;\n\t\toe = (struct omfs_extent *) (&bh->b_data[OMFS_EXTENT_CONT]);\n\t\tmax_extents = omfs_max_extents(sbi, OMFS_EXTENT_CONT);\n\t}\n\tret = 0;\nout:\n\treturn ret;\nout_brelse:\n\tbrelse(bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_inode",
          "args": [
            "inode"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "clear_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "488-505",
          "snippet": "void clear_inode(struct inode *inode)\n{\n\tmight_sleep();\n\t/*\n\t * We have to cycle tree_lock here because reclaim can be still in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free mapping under it.\n\t */\n\tspin_lock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrshadows);\n\tspin_unlock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_inode(struct inode *inode)\n{\n\tmight_sleep();\n\t/*\n\t * We have to cycle tree_lock here because reclaim can be still in the\n\t * process of removing the last page (in __delete_from_page_cache())\n\t * and we must not free mapping under it.\n\t */\n\tspin_lock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(inode->i_data.nrpages);\n\tBUG_ON(inode->i_data.nrshadows);\n\tspin_unlock_irq(&inode->i_data.tree_lock);\n\tBUG_ON(!list_empty(&inode->i_data.private_list));\n\tBUG_ON(!(inode->i_state & I_FREEING));\n\tBUG_ON(inode->i_state & I_CLEAR);\n\t/* don't need i_lock here, no concurrent mods to i_state */\n\tinode->i_state = I_FREEING | I_CLEAR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages_final",
          "args": [
            "&inode->i_data"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"omfs.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/writeback.h>\n#include <linux/vmalloc.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic void omfs_evict_inode(struct inode *inode)\n{\n\ttruncate_inode_pages_final(&inode->i_data);\n\tclear_inode(inode);\n\n\tif (inode->i_nlink)\n\t\treturn;\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_size = 0;\n\t\tomfs_shrink_inode(inode);\n\t}\n\n\tomfs_clear_range(inode->i_sb, inode->i_ino, 2);\n}"
  },
  {
    "function_name": "omfs_sync_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/inode.c",
    "lines": "175-178",
    "snippet": "int omfs_sync_inode(struct inode *inode)\n{\n\treturn __omfs_write_inode(inode, 1);\n}",
    "includes": [
      "#include \"omfs.h\"",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__omfs_write_inode",
          "args": [
            "inode",
            "1"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "__omfs_write_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/inode.c",
          "lines": "100-168",
          "snippet": "static int __omfs_write_inode(struct inode *inode, int wait)\n{\n\tstruct omfs_inode *oi;\n\tstruct omfs_sb_info *sbi = OMFS_SB(inode->i_sb);\n\tstruct buffer_head *bh, *bh2;\n\tu64 ctime;\n\tint i;\n\tint ret = -EIO;\n\tint sync_failed = 0;\n\n\t/* get current inode since we may have written sibling ptrs etc. */\n\tbh = omfs_bread(inode->i_sb, inode->i_ino);\n\tif (!bh)\n\t\tgoto out;\n\n\toi = (struct omfs_inode *) bh->b_data;\n\n\toi->i_head.h_self = cpu_to_be64(inode->i_ino);\n\tif (S_ISDIR(inode->i_mode))\n\t\toi->i_type = OMFS_DIR;\n\telse if (S_ISREG(inode->i_mode))\n\t\toi->i_type = OMFS_FILE;\n\telse {\n\t\tprintk(KERN_WARNING \"omfs: unknown file type: %d\\n\",\n\t\t\tinode->i_mode);\n\t\tgoto out_brelse;\n\t}\n\n\toi->i_head.h_body_size = cpu_to_be32(sbi->s_sys_blocksize -\n\t\tsizeof(struct omfs_header));\n\toi->i_head.h_version = 1;\n\toi->i_head.h_type = OMFS_INODE_NORMAL;\n\toi->i_head.h_magic = OMFS_IMAGIC;\n\toi->i_size = cpu_to_be64(inode->i_size);\n\n\tctime = inode->i_ctime.tv_sec * 1000LL +\n\t\t((inode->i_ctime.tv_nsec + 999)/1000);\n\toi->i_ctime = cpu_to_be64(ctime);\n\n\tomfs_update_checksums(oi);\n\n\tmark_buffer_dirty(bh);\n\tif (wait) {\n\t\tsync_dirty_buffer(bh);\n\t\tif (buffer_req(bh) && !buffer_uptodate(bh))\n\t\t\tsync_failed = 1;\n\t}\n\n\t/* if mirroring writes, copy to next fsblock */\n\tfor (i = 1; i < sbi->s_mirrors; i++) {\n\t\tbh2 = omfs_bread(inode->i_sb, inode->i_ino + i);\n\t\tif (!bh2)\n\t\t\tgoto out_brelse;\n\n\t\tmemcpy(bh2->b_data, bh->b_data, bh->b_size);\n\t\tmark_buffer_dirty(bh2);\n\t\tif (wait) {\n\t\t\tsync_dirty_buffer(bh2);\n\t\t\tif (buffer_req(bh2) && !buffer_uptodate(bh2))\n\t\t\t\tsync_failed = 1;\n\t\t}\n\t\tbrelse(bh2);\n\t}\n\tret = (sync_failed) ? -EIO : 0;\nout_brelse:\n\tbrelse(bh);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"omfs.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/writeback.h>\n#include <linux/vmalloc.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic int __omfs_write_inode(struct inode *inode, int wait)\n{\n\tstruct omfs_inode *oi;\n\tstruct omfs_sb_info *sbi = OMFS_SB(inode->i_sb);\n\tstruct buffer_head *bh, *bh2;\n\tu64 ctime;\n\tint i;\n\tint ret = -EIO;\n\tint sync_failed = 0;\n\n\t/* get current inode since we may have written sibling ptrs etc. */\n\tbh = omfs_bread(inode->i_sb, inode->i_ino);\n\tif (!bh)\n\t\tgoto out;\n\n\toi = (struct omfs_inode *) bh->b_data;\n\n\toi->i_head.h_self = cpu_to_be64(inode->i_ino);\n\tif (S_ISDIR(inode->i_mode))\n\t\toi->i_type = OMFS_DIR;\n\telse if (S_ISREG(inode->i_mode))\n\t\toi->i_type = OMFS_FILE;\n\telse {\n\t\tprintk(KERN_WARNING \"omfs: unknown file type: %d\\n\",\n\t\t\tinode->i_mode);\n\t\tgoto out_brelse;\n\t}\n\n\toi->i_head.h_body_size = cpu_to_be32(sbi->s_sys_blocksize -\n\t\tsizeof(struct omfs_header));\n\toi->i_head.h_version = 1;\n\toi->i_head.h_type = OMFS_INODE_NORMAL;\n\toi->i_head.h_magic = OMFS_IMAGIC;\n\toi->i_size = cpu_to_be64(inode->i_size);\n\n\tctime = inode->i_ctime.tv_sec * 1000LL +\n\t\t((inode->i_ctime.tv_nsec + 999)/1000);\n\toi->i_ctime = cpu_to_be64(ctime);\n\n\tomfs_update_checksums(oi);\n\n\tmark_buffer_dirty(bh);\n\tif (wait) {\n\t\tsync_dirty_buffer(bh);\n\t\tif (buffer_req(bh) && !buffer_uptodate(bh))\n\t\t\tsync_failed = 1;\n\t}\n\n\t/* if mirroring writes, copy to next fsblock */\n\tfor (i = 1; i < sbi->s_mirrors; i++) {\n\t\tbh2 = omfs_bread(inode->i_sb, inode->i_ino + i);\n\t\tif (!bh2)\n\t\t\tgoto out_brelse;\n\n\t\tmemcpy(bh2->b_data, bh->b_data, bh->b_size);\n\t\tmark_buffer_dirty(bh2);\n\t\tif (wait) {\n\t\t\tsync_dirty_buffer(bh2);\n\t\t\tif (buffer_req(bh2) && !buffer_uptodate(bh2))\n\t\t\t\tsync_failed = 1;\n\t\t}\n\t\tbrelse(bh2);\n\t}\n\tret = (sync_failed) ? -EIO : 0;\nout_brelse:\n\tbrelse(bh);\nout:\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"omfs.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/writeback.h>\n#include <linux/vmalloc.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nint omfs_sync_inode(struct inode *inode)\n{\n\treturn __omfs_write_inode(inode, 1);\n}"
  },
  {
    "function_name": "omfs_write_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/inode.c",
    "lines": "170-173",
    "snippet": "static int omfs_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\treturn __omfs_write_inode(inode, wbc->sync_mode == WB_SYNC_ALL);\n}",
    "includes": [
      "#include \"omfs.h\"",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__omfs_write_inode",
          "args": [
            "inode",
            "wbc->sync_mode == WB_SYNC_ALL"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "__omfs_write_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/inode.c",
          "lines": "100-168",
          "snippet": "static int __omfs_write_inode(struct inode *inode, int wait)\n{\n\tstruct omfs_inode *oi;\n\tstruct omfs_sb_info *sbi = OMFS_SB(inode->i_sb);\n\tstruct buffer_head *bh, *bh2;\n\tu64 ctime;\n\tint i;\n\tint ret = -EIO;\n\tint sync_failed = 0;\n\n\t/* get current inode since we may have written sibling ptrs etc. */\n\tbh = omfs_bread(inode->i_sb, inode->i_ino);\n\tif (!bh)\n\t\tgoto out;\n\n\toi = (struct omfs_inode *) bh->b_data;\n\n\toi->i_head.h_self = cpu_to_be64(inode->i_ino);\n\tif (S_ISDIR(inode->i_mode))\n\t\toi->i_type = OMFS_DIR;\n\telse if (S_ISREG(inode->i_mode))\n\t\toi->i_type = OMFS_FILE;\n\telse {\n\t\tprintk(KERN_WARNING \"omfs: unknown file type: %d\\n\",\n\t\t\tinode->i_mode);\n\t\tgoto out_brelse;\n\t}\n\n\toi->i_head.h_body_size = cpu_to_be32(sbi->s_sys_blocksize -\n\t\tsizeof(struct omfs_header));\n\toi->i_head.h_version = 1;\n\toi->i_head.h_type = OMFS_INODE_NORMAL;\n\toi->i_head.h_magic = OMFS_IMAGIC;\n\toi->i_size = cpu_to_be64(inode->i_size);\n\n\tctime = inode->i_ctime.tv_sec * 1000LL +\n\t\t((inode->i_ctime.tv_nsec + 999)/1000);\n\toi->i_ctime = cpu_to_be64(ctime);\n\n\tomfs_update_checksums(oi);\n\n\tmark_buffer_dirty(bh);\n\tif (wait) {\n\t\tsync_dirty_buffer(bh);\n\t\tif (buffer_req(bh) && !buffer_uptodate(bh))\n\t\t\tsync_failed = 1;\n\t}\n\n\t/* if mirroring writes, copy to next fsblock */\n\tfor (i = 1; i < sbi->s_mirrors; i++) {\n\t\tbh2 = omfs_bread(inode->i_sb, inode->i_ino + i);\n\t\tif (!bh2)\n\t\t\tgoto out_brelse;\n\n\t\tmemcpy(bh2->b_data, bh->b_data, bh->b_size);\n\t\tmark_buffer_dirty(bh2);\n\t\tif (wait) {\n\t\t\tsync_dirty_buffer(bh2);\n\t\t\tif (buffer_req(bh2) && !buffer_uptodate(bh2))\n\t\t\t\tsync_failed = 1;\n\t\t}\n\t\tbrelse(bh2);\n\t}\n\tret = (sync_failed) ? -EIO : 0;\nout_brelse:\n\tbrelse(bh);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"omfs.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/writeback.h>\n#include <linux/vmalloc.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic int __omfs_write_inode(struct inode *inode, int wait)\n{\n\tstruct omfs_inode *oi;\n\tstruct omfs_sb_info *sbi = OMFS_SB(inode->i_sb);\n\tstruct buffer_head *bh, *bh2;\n\tu64 ctime;\n\tint i;\n\tint ret = -EIO;\n\tint sync_failed = 0;\n\n\t/* get current inode since we may have written sibling ptrs etc. */\n\tbh = omfs_bread(inode->i_sb, inode->i_ino);\n\tif (!bh)\n\t\tgoto out;\n\n\toi = (struct omfs_inode *) bh->b_data;\n\n\toi->i_head.h_self = cpu_to_be64(inode->i_ino);\n\tif (S_ISDIR(inode->i_mode))\n\t\toi->i_type = OMFS_DIR;\n\telse if (S_ISREG(inode->i_mode))\n\t\toi->i_type = OMFS_FILE;\n\telse {\n\t\tprintk(KERN_WARNING \"omfs: unknown file type: %d\\n\",\n\t\t\tinode->i_mode);\n\t\tgoto out_brelse;\n\t}\n\n\toi->i_head.h_body_size = cpu_to_be32(sbi->s_sys_blocksize -\n\t\tsizeof(struct omfs_header));\n\toi->i_head.h_version = 1;\n\toi->i_head.h_type = OMFS_INODE_NORMAL;\n\toi->i_head.h_magic = OMFS_IMAGIC;\n\toi->i_size = cpu_to_be64(inode->i_size);\n\n\tctime = inode->i_ctime.tv_sec * 1000LL +\n\t\t((inode->i_ctime.tv_nsec + 999)/1000);\n\toi->i_ctime = cpu_to_be64(ctime);\n\n\tomfs_update_checksums(oi);\n\n\tmark_buffer_dirty(bh);\n\tif (wait) {\n\t\tsync_dirty_buffer(bh);\n\t\tif (buffer_req(bh) && !buffer_uptodate(bh))\n\t\t\tsync_failed = 1;\n\t}\n\n\t/* if mirroring writes, copy to next fsblock */\n\tfor (i = 1; i < sbi->s_mirrors; i++) {\n\t\tbh2 = omfs_bread(inode->i_sb, inode->i_ino + i);\n\t\tif (!bh2)\n\t\t\tgoto out_brelse;\n\n\t\tmemcpy(bh2->b_data, bh->b_data, bh->b_size);\n\t\tmark_buffer_dirty(bh2);\n\t\tif (wait) {\n\t\t\tsync_dirty_buffer(bh2);\n\t\t\tif (buffer_req(bh2) && !buffer_uptodate(bh2))\n\t\t\t\tsync_failed = 1;\n\t\t}\n\t\tbrelse(bh2);\n\t}\n\tret = (sync_failed) ? -EIO : 0;\nout_brelse:\n\tbrelse(bh);\nout:\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"omfs.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/writeback.h>\n#include <linux/vmalloc.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic int omfs_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\treturn __omfs_write_inode(inode, wbc->sync_mode == WB_SYNC_ALL);\n}"
  },
  {
    "function_name": "__omfs_write_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/inode.c",
    "lines": "100-168",
    "snippet": "static int __omfs_write_inode(struct inode *inode, int wait)\n{\n\tstruct omfs_inode *oi;\n\tstruct omfs_sb_info *sbi = OMFS_SB(inode->i_sb);\n\tstruct buffer_head *bh, *bh2;\n\tu64 ctime;\n\tint i;\n\tint ret = -EIO;\n\tint sync_failed = 0;\n\n\t/* get current inode since we may have written sibling ptrs etc. */\n\tbh = omfs_bread(inode->i_sb, inode->i_ino);\n\tif (!bh)\n\t\tgoto out;\n\n\toi = (struct omfs_inode *) bh->b_data;\n\n\toi->i_head.h_self = cpu_to_be64(inode->i_ino);\n\tif (S_ISDIR(inode->i_mode))\n\t\toi->i_type = OMFS_DIR;\n\telse if (S_ISREG(inode->i_mode))\n\t\toi->i_type = OMFS_FILE;\n\telse {\n\t\tprintk(KERN_WARNING \"omfs: unknown file type: %d\\n\",\n\t\t\tinode->i_mode);\n\t\tgoto out_brelse;\n\t}\n\n\toi->i_head.h_body_size = cpu_to_be32(sbi->s_sys_blocksize -\n\t\tsizeof(struct omfs_header));\n\toi->i_head.h_version = 1;\n\toi->i_head.h_type = OMFS_INODE_NORMAL;\n\toi->i_head.h_magic = OMFS_IMAGIC;\n\toi->i_size = cpu_to_be64(inode->i_size);\n\n\tctime = inode->i_ctime.tv_sec * 1000LL +\n\t\t((inode->i_ctime.tv_nsec + 999)/1000);\n\toi->i_ctime = cpu_to_be64(ctime);\n\n\tomfs_update_checksums(oi);\n\n\tmark_buffer_dirty(bh);\n\tif (wait) {\n\t\tsync_dirty_buffer(bh);\n\t\tif (buffer_req(bh) && !buffer_uptodate(bh))\n\t\t\tsync_failed = 1;\n\t}\n\n\t/* if mirroring writes, copy to next fsblock */\n\tfor (i = 1; i < sbi->s_mirrors; i++) {\n\t\tbh2 = omfs_bread(inode->i_sb, inode->i_ino + i);\n\t\tif (!bh2)\n\t\t\tgoto out_brelse;\n\n\t\tmemcpy(bh2->b_data, bh->b_data, bh->b_size);\n\t\tmark_buffer_dirty(bh2);\n\t\tif (wait) {\n\t\t\tsync_dirty_buffer(bh2);\n\t\t\tif (buffer_req(bh2) && !buffer_uptodate(bh2))\n\t\t\t\tsync_failed = 1;\n\t\t}\n\t\tbrelse(bh2);\n\t}\n\tret = (sync_failed) ? -EIO : 0;\nout_brelse:\n\tbrelse(bh);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"omfs.h\"",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh2"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_req",
          "args": [
            "bh2"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sync_dirty_buffer",
          "args": [
            "bh2"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "sync_dirty_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "3153-3156",
          "snippet": "int sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint sync_dirty_buffer(struct buffer_head *bh)\n{\n\treturn __sync_dirty_buffer(bh, WRITE_SYNC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_buffer_dirty",
          "args": [
            "bh2"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "bh2->b_data",
            "bh->b_data",
            "bh->b_size"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "omfs_bread",
          "args": [
            "inode->i_sb",
            "inode->i_ino + i"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "omfs_bread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/inode.c",
          "lines": "22-29",
          "snippet": "struct buffer_head *omfs_bread(struct super_block *sb, sector_t block)\n{\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tif (block >= sbi->s_num_blocks)\n\t\treturn NULL;\n\n\treturn sb_bread(sb, clus_to_blk(sbi, block));\n}",
          "includes": [
            "#include \"omfs.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/writeback.h>\n#include <linux/vmalloc.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstruct buffer_head *omfs_bread(struct super_block *sb, sector_t block)\n{\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tif (block >= sbi->s_num_blocks)\n\t\treturn NULL;\n\n\treturn sb_bread(sb, clus_to_blk(sbi, block));\n}"
        }
      },
      {
        "call_info": {
          "callee": "buffer_req",
          "args": [
            "bh"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "omfs_update_checksums",
          "args": [
            "oi"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "omfs_update_checksums",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/inode.c",
          "lines": "81-98",
          "snippet": "static void omfs_update_checksums(struct omfs_inode *oi)\n{\n\tint xor, i, ofs = 0, count;\n\tu16 crc = 0;\n\tunsigned char *ptr = (unsigned char *) oi;\n\n\tcount = be32_to_cpu(oi->i_head.h_body_size);\n\tofs = sizeof(struct omfs_header);\n\n\tcrc = crc_itu_t(crc, ptr + ofs, count);\n\toi->i_head.h_crc = cpu_to_be16(crc);\n\n\txor = ptr[0];\n\tfor (i = 1; i < OMFS_XOR_COUNT; i++)\n\t\txor ^= ptr[i];\n\n\toi->i_head.h_check_xor = xor;\n}",
          "includes": [
            "#include \"omfs.h\"",
            "#include <linux/crc-itu-t.h>",
            "#include <linux/writeback.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/parser.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/writeback.h>\n#include <linux/vmalloc.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic void omfs_update_checksums(struct omfs_inode *oi)\n{\n\tint xor, i, ofs = 0, count;\n\tu16 crc = 0;\n\tunsigned char *ptr = (unsigned char *) oi;\n\n\tcount = be32_to_cpu(oi->i_head.h_body_size);\n\tofs = sizeof(struct omfs_header);\n\n\tcrc = crc_itu_t(crc, ptr + ofs, count);\n\toi->i_head.h_crc = cpu_to_be16(crc);\n\n\txor = ptr[0];\n\tfor (i = 1; i < OMFS_XOR_COUNT; i++)\n\t\txor ^= ptr[i];\n\n\toi->i_head.h_check_xor = xor;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "ctime"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "inode->i_size"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "sbi->s_sys_blocksize -\n\t\tsizeof(struct omfs_header)"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"omfs: unknown file type: %d\\n\"",
            "inode->i_mode"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->i_mode"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "inode->i_ino"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OMFS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "OMFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/omfs.h",
          "lines": "34-37",
          "snippet": "static inline struct omfs_sb_info *OMFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"omfs_fs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs_fs.h\"\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline struct omfs_sb_info *OMFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"omfs.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/writeback.h>\n#include <linux/vmalloc.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic int __omfs_write_inode(struct inode *inode, int wait)\n{\n\tstruct omfs_inode *oi;\n\tstruct omfs_sb_info *sbi = OMFS_SB(inode->i_sb);\n\tstruct buffer_head *bh, *bh2;\n\tu64 ctime;\n\tint i;\n\tint ret = -EIO;\n\tint sync_failed = 0;\n\n\t/* get current inode since we may have written sibling ptrs etc. */\n\tbh = omfs_bread(inode->i_sb, inode->i_ino);\n\tif (!bh)\n\t\tgoto out;\n\n\toi = (struct omfs_inode *) bh->b_data;\n\n\toi->i_head.h_self = cpu_to_be64(inode->i_ino);\n\tif (S_ISDIR(inode->i_mode))\n\t\toi->i_type = OMFS_DIR;\n\telse if (S_ISREG(inode->i_mode))\n\t\toi->i_type = OMFS_FILE;\n\telse {\n\t\tprintk(KERN_WARNING \"omfs: unknown file type: %d\\n\",\n\t\t\tinode->i_mode);\n\t\tgoto out_brelse;\n\t}\n\n\toi->i_head.h_body_size = cpu_to_be32(sbi->s_sys_blocksize -\n\t\tsizeof(struct omfs_header));\n\toi->i_head.h_version = 1;\n\toi->i_head.h_type = OMFS_INODE_NORMAL;\n\toi->i_head.h_magic = OMFS_IMAGIC;\n\toi->i_size = cpu_to_be64(inode->i_size);\n\n\tctime = inode->i_ctime.tv_sec * 1000LL +\n\t\t((inode->i_ctime.tv_nsec + 999)/1000);\n\toi->i_ctime = cpu_to_be64(ctime);\n\n\tomfs_update_checksums(oi);\n\n\tmark_buffer_dirty(bh);\n\tif (wait) {\n\t\tsync_dirty_buffer(bh);\n\t\tif (buffer_req(bh) && !buffer_uptodate(bh))\n\t\t\tsync_failed = 1;\n\t}\n\n\t/* if mirroring writes, copy to next fsblock */\n\tfor (i = 1; i < sbi->s_mirrors; i++) {\n\t\tbh2 = omfs_bread(inode->i_sb, inode->i_ino + i);\n\t\tif (!bh2)\n\t\t\tgoto out_brelse;\n\n\t\tmemcpy(bh2->b_data, bh->b_data, bh->b_size);\n\t\tmark_buffer_dirty(bh2);\n\t\tif (wait) {\n\t\t\tsync_dirty_buffer(bh2);\n\t\t\tif (buffer_req(bh2) && !buffer_uptodate(bh2))\n\t\t\t\tsync_failed = 1;\n\t\t}\n\t\tbrelse(bh2);\n\t}\n\tret = (sync_failed) ? -EIO : 0;\nout_brelse:\n\tbrelse(bh);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "omfs_update_checksums",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/inode.c",
    "lines": "81-98",
    "snippet": "static void omfs_update_checksums(struct omfs_inode *oi)\n{\n\tint xor, i, ofs = 0, count;\n\tu16 crc = 0;\n\tunsigned char *ptr = (unsigned char *) oi;\n\n\tcount = be32_to_cpu(oi->i_head.h_body_size);\n\tofs = sizeof(struct omfs_header);\n\n\tcrc = crc_itu_t(crc, ptr + ofs, count);\n\toi->i_head.h_crc = cpu_to_be16(crc);\n\n\txor = ptr[0];\n\tfor (i = 1; i < OMFS_XOR_COUNT; i++)\n\t\txor ^= ptr[i];\n\n\toi->i_head.h_check_xor = xor;\n}",
    "includes": [
      "#include \"omfs.h\"",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "crc"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crc_itu_t",
          "args": [
            "crc",
            "ptr + ofs",
            "count"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "oi->i_head.h_body_size"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"omfs.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/writeback.h>\n#include <linux/vmalloc.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic void omfs_update_checksums(struct omfs_inode *oi)\n{\n\tint xor, i, ofs = 0, count;\n\tu16 crc = 0;\n\tunsigned char *ptr = (unsigned char *) oi;\n\n\tcount = be32_to_cpu(oi->i_head.h_body_size);\n\tofs = sizeof(struct omfs_header);\n\n\tcrc = crc_itu_t(crc, ptr + ofs, count);\n\toi->i_head.h_crc = cpu_to_be16(crc);\n\n\txor = ptr[0];\n\tfor (i = 1; i < OMFS_XOR_COUNT; i++)\n\t\txor ^= ptr[i];\n\n\toi->i_head.h_check_xor = xor;\n}"
  },
  {
    "function_name": "omfs_new_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/inode.c",
    "lines": "31-74",
    "snippet": "struct inode *omfs_new_inode(struct inode *dir, umode_t mode)\n{\n\tstruct inode *inode;\n\tu64 new_block;\n\tint err;\n\tint len;\n\tstruct omfs_sb_info *sbi = OMFS_SB(dir->i_sb);\n\n\tinode = new_inode(dir->i_sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = omfs_allocate_range(dir->i_sb, sbi->s_mirrors, sbi->s_mirrors,\n\t\t\t&new_block, &len);\n\tif (err)\n\t\tgoto fail;\n\n\tinode->i_ino = new_block;\n\tinode_init_owner(inode, NULL, mode);\n\tinode->i_mapping->a_ops = &omfs_aops;\n\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\tswitch (mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &omfs_dir_inops;\n\t\tinode->i_fop = &omfs_dir_operations;\n\t\tinode->i_size = sbi->s_sys_blocksize;\n\t\tinc_nlink(inode);\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &omfs_file_inops;\n\t\tinode->i_fop = &omfs_file_operations;\n\t\tinode->i_size = 0;\n\t\tbreak;\n\t}\n\n\tinsert_inode_hash(inode);\n\tmark_inode_dirty(inode);\n\treturn inode;\nfail:\n\tmake_bad_inode(inode);\n\tiput(inode);\n\treturn ERR_PTR(err);\n}",
    "includes": [
      "#include \"omfs.h\"",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "inode"
          ],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1471-1488",
          "snippet": "void iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid iput(struct inode *inode)\n{\n\tif (!inode)\n\t\treturn;\n\tBUG_ON(inode->i_state & I_CLEAR);\nretry:\n\tif (atomic_dec_and_lock(&inode->i_count, &inode->i_lock)) {\n\t\tif (inode->i_nlink && (inode->i_state & I_DIRTY_TIME)) {\n\t\t\tatomic_inc(&inode->i_count);\n\t\t\tinode->i_state &= ~I_DIRTY_TIME;\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\ttrace_writeback_lazytime_iput(inode);\n\t\t\tmark_inode_dirty_sync(inode);\n\t\t\tgoto retry;\n\t\t}\n\t\tiput_final(inode);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_bad_inode",
          "args": [
            "inode"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_make_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/inode.c",
          "lines": "1520-1524",
          "snippet": "static void reiserfs_make_bad_inode(struct inode *inode)\n{\n\tmemset(INODE_PKEY(inode), 0, KEY_SIZE);\n\tmake_bad_inode(inode);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mpage.h>",
            "#include <linux/buffer_head.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/highmem.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/exportfs.h>",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"reiserfs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/quotaops.h>\n#include <linux/writeback.h>\n#include <linux/mpage.h>\n#include <linux/buffer_head.h>\n#include <asm/unaligned.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/pagemap.h>\n#include <linux/exportfs.h>\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"reiserfs.h\"\n#include <linux/fs.h>\n#include <linux/time.h>\n\nstatic void reiserfs_make_bad_inode(struct inode *inode)\n{\n\tmemset(INODE_PKEY(inode), 0, KEY_SIZE);\n\tmake_bad_inode(inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "insert_inode_hash",
          "args": [
            "inode"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_insert_inode_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "213-218",
          "snippet": "static inline void btrfs_insert_inode_hash(struct inode *inode)\n{\n\tunsigned long h = btrfs_inode_hash(inode->i_ino, BTRFS_I(inode)->root);\n\n\t__insert_inode_hash(inode, h);\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_insert_inode_hash(struct inode *inode)\n{\n\tunsigned long h = btrfs_inode_hash(inode->i_ino, BTRFS_I(inode)->root);\n\n\t__insert_inode_hash(inode, h);\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "inode"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "inc_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "327-335",
          "snippet": "void inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "inode_init_owner",
          "args": [
            "inode",
            "NULL",
            "mode"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "inode_init_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1880-1891",
          "snippet": "void inode_init_owner(struct inode *inode, const struct inode *dir,\n\t\t\tumode_t mode)\n{\n\tinode->i_uid = current_fsuid();\n\tif (dir && dir->i_mode & S_ISGID) {\n\t\tinode->i_gid = dir->i_gid;\n\t\tif (S_ISDIR(mode))\n\t\t\tmode |= S_ISGID;\n\t} else\n\t\tinode->i_gid = current_fsgid();\n\tinode->i_mode = mode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inode_init_owner(struct inode *inode, const struct inode *dir,\n\t\t\tumode_t mode)\n{\n\tinode->i_uid = current_fsuid();\n\tif (dir && dir->i_mode & S_ISGID) {\n\t\tinode->i_gid = dir->i_gid;\n\t\tif (S_ISDIR(mode))\n\t\t\tmode |= S_ISGID;\n\t} else\n\t\tinode->i_gid = current_fsgid();\n\tinode->i_mode = mode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "omfs_allocate_range",
          "args": [
            "dir->i_sb",
            "sbi->s_mirrors",
            "sbi->s_mirrors",
            "&new_block",
            "&len"
          ],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "omfs_allocate_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/bitmap.c",
          "lines": "129-169",
          "snippet": "int omfs_allocate_range(struct super_block *sb,\n\t\t\tint min_request,\n\t\t\tint max_request,\n\t\t\tu64 *return_block,\n\t\t\tint *return_size)\n{\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tint bits_per_entry = 8 * sb->s_blocksize;\n\tint ret = 0;\n\tint i, run, bit;\n\n\tmutex_lock(&sbi->s_bitmap_lock);\n\tfor (i = 0; i < sbi->s_imap_size; i++) {\n\t\tbit = 0;\n\t\twhile (bit < bits_per_entry) {\n\t\t\tbit = find_next_zero_bit(sbi->s_imap[i], bits_per_entry,\n\t\t\t\tbit);\n\n\t\t\tif (bit == bits_per_entry)\n\t\t\t\tbreak;\n\n\t\t\trun = count_run(&sbi->s_imap[i], bits_per_entry,\n\t\t\t\tsbi->s_imap_size-i, bit, max_request);\n\n\t\t\tif (run >= min_request)\n\t\t\t\tgoto found;\n\t\t\tbit += run;\n\t\t}\n\t}\n\tret = -ENOSPC;\n\tgoto out;\n\nfound:\n\t*return_block = i * bits_per_entry + bit;\n\t*return_size = run;\n\tret = set_run(sb, i, bits_per_entry, bit, run, 1);\n\nout:\n\tmutex_unlock(&sbi->s_bitmap_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"omfs.h\"",
            "#include <asm/div64.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs.h\"\n#include <asm/div64.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n\nint omfs_allocate_range(struct super_block *sb,\n\t\t\tint min_request,\n\t\t\tint max_request,\n\t\t\tu64 *return_block,\n\t\t\tint *return_size)\n{\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tint bits_per_entry = 8 * sb->s_blocksize;\n\tint ret = 0;\n\tint i, run, bit;\n\n\tmutex_lock(&sbi->s_bitmap_lock);\n\tfor (i = 0; i < sbi->s_imap_size; i++) {\n\t\tbit = 0;\n\t\twhile (bit < bits_per_entry) {\n\t\t\tbit = find_next_zero_bit(sbi->s_imap[i], bits_per_entry,\n\t\t\t\tbit);\n\n\t\t\tif (bit == bits_per_entry)\n\t\t\t\tbreak;\n\n\t\t\trun = count_run(&sbi->s_imap[i], bits_per_entry,\n\t\t\t\tsbi->s_imap_size-i, bit, max_request);\n\n\t\t\tif (run >= min_request)\n\t\t\t\tgoto found;\n\t\t\tbit += run;\n\t\t}\n\t}\n\tret = -ENOSPC;\n\tgoto out;\n\nfound:\n\t*return_block = i * bits_per_entry + bit;\n\t*return_size = run;\n\tret = set_run(sb, i, bits_per_entry, bit, run, 1);\n\nout:\n\tmutex_unlock(&sbi->s_bitmap_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_inode",
          "args": [
            "dir->i_sb"
          ],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OMFS_SB",
          "args": [
            "dir->i_sb"
          ],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "OMFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/omfs.h",
          "lines": "34-37",
          "snippet": "static inline struct omfs_sb_info *OMFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"omfs_fs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs_fs.h\"\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline struct omfs_sb_info *OMFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"omfs.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/writeback.h>\n#include <linux/vmalloc.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstruct inode *omfs_new_inode(struct inode *dir, umode_t mode)\n{\n\tstruct inode *inode;\n\tu64 new_block;\n\tint err;\n\tint len;\n\tstruct omfs_sb_info *sbi = OMFS_SB(dir->i_sb);\n\n\tinode = new_inode(dir->i_sb);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\terr = omfs_allocate_range(dir->i_sb, sbi->s_mirrors, sbi->s_mirrors,\n\t\t\t&new_block, &len);\n\tif (err)\n\t\tgoto fail;\n\n\tinode->i_ino = new_block;\n\tinode_init_owner(inode, NULL, mode);\n\tinode->i_mapping->a_ops = &omfs_aops;\n\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\tswitch (mode & S_IFMT) {\n\tcase S_IFDIR:\n\t\tinode->i_op = &omfs_dir_inops;\n\t\tinode->i_fop = &omfs_dir_operations;\n\t\tinode->i_size = sbi->s_sys_blocksize;\n\t\tinc_nlink(inode);\n\t\tbreak;\n\tcase S_IFREG:\n\t\tinode->i_op = &omfs_file_inops;\n\t\tinode->i_fop = &omfs_file_operations;\n\t\tinode->i_size = 0;\n\t\tbreak;\n\t}\n\n\tinsert_inode_hash(inode);\n\tmark_inode_dirty(inode);\n\treturn inode;\nfail:\n\tmake_bad_inode(inode);\n\tiput(inode);\n\treturn ERR_PTR(err);\n}"
  },
  {
    "function_name": "omfs_bread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/inode.c",
    "lines": "22-29",
    "snippet": "struct buffer_head *omfs_bread(struct super_block *sb, sector_t block)\n{\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tif (block >= sbi->s_num_blocks)\n\t\treturn NULL;\n\n\treturn sb_bread(sb, clus_to_blk(sbi, block));\n}",
    "includes": [
      "#include \"omfs.h\"",
      "#include <linux/crc-itu-t.h>",
      "#include <linux/writeback.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/buffer_head.h>",
      "#include <linux/parser.h>",
      "#include <linux/vfs.h>",
      "#include <linux/fs.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "sb",
            "clus_to_blk(sbi, block)"
          ],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clus_to_blk",
          "args": [
            "sbi",
            "block"
          ],
          "line": 28
        },
        "resolved": true,
        "details": {
          "function_name": "clus_to_blk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/omfs.h",
          "lines": "29-32",
          "snippet": "static inline sector_t clus_to_blk(struct omfs_sb_info *sbi, sector_t block)\n{\n\treturn block << sbi->s_block_shift;\n}",
          "includes": [
            "#include \"omfs_fs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs_fs.h\"\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline sector_t clus_to_blk(struct omfs_sb_info *sbi, sector_t block)\n{\n\treturn block << sbi->s_block_shift;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OMFS_SB",
          "args": [
            "sb"
          ],
          "line": 24
        },
        "resolved": true,
        "details": {
          "function_name": "OMFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/omfs/omfs.h",
          "lines": "34-37",
          "snippet": "static inline struct omfs_sb_info *OMFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"omfs_fs.h\"",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"omfs_fs.h\"\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic inline struct omfs_sb_info *OMFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"omfs.h\"\n#include <linux/crc-itu-t.h>\n#include <linux/writeback.h>\n#include <linux/vmalloc.h>\n#include <linux/buffer_head.h>\n#include <linux/parser.h>\n#include <linux/vfs.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstruct buffer_head *omfs_bread(struct super_block *sb, sector_t block)\n{\n\tstruct omfs_sb_info *sbi = OMFS_SB(sb);\n\tif (block >= sbi->s_num_blocks)\n\t\treturn NULL;\n\n\treturn sb_bread(sb, clus_to_blk(sbi, block));\n}"
  }
]