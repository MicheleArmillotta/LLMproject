[
  {
    "function_name": "_size(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/recovery.c",
    "lines": "1481-1553",
    "snippet": "over_size(struct ubifs_info *c)\n{\n\tstruct rb_node *this = rb_first(&c->size_tree);\n\n\twhile (this) {\n\t\tstruct size_entry *e;\n\t\tint err;\n\n\t\te = rb_entry(this, struct size_entry, rb);\n\t\tif (!e->exists) {\n\t\t\tunion ubifs_key key;\n\n\t\t\tino_key_init(c, &key, e->inum);\n\t\t\terr = ubifs_tnc_lookup(c, &key, c->sbuf);\n\t\t\tif (err && err != -ENOENT)\n\t\t\t\treturn err;\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t/* Remove data nodes that have no inode */\n\t\t\t\tdbg_rcvry(\"removing ino %lu\",\n\t\t\t\t\t  (unsigned long)e->inum);\n\t\t\t\terr = ubifs_tnc_remove_ino(c, e->inum);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t} else {\n\t\t\t\tstruct ubifs_ino_node *ino = c->sbuf;\n\n\t\t\t\te->exists = 1;\n\t\t\t\te->i_size = le64_to_cpu(ino->size);\n\t\t\t}\n\t\t}\n\n\t\tif (e->exists && e->i_size < e->d_size) {\n\t\t\tif (c->ro_mount) {\n\t\t\t\t/* Fix the inode size and pin it in memory */\n\t\t\t\tstruct inode *inode;\n\t\t\t\tstruct ubifs_inode *ui;\n\n\t\t\t\tubifs_assert(!e->inode);\n\n\t\t\t\tinode = ubifs_iget(c->vfs_sb, e->inum);\n\t\t\t\tif (IS_ERR(inode))\n\t\t\t\t\treturn PTR_ERR(inode);\n\n\t\t\t\tui = ubifs_inode(inode);\n\t\t\t\tif (inode->i_size < e->d_size) {\n\t\t\t\t\tdbg_rcvry(\"ino %lu size %lld -> %lld\",\n\t\t\t\t\t\t  (unsigned long)e->inum,\n\t\t\t\t\t\t  inode->i_size, e->d_size);\n\t\t\t\t\tinode->i_size = e->d_size;\n\t\t\t\t\tui->ui_size = e->d_size;\n\t\t\t\t\tui->synced_i_size = e->d_size;\n\t\t\t\t\te->inode = inode;\n\t\t\t\t\tthis = rb_next(this);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tiput(inode);\n\t\t\t} else {\n\t\t\t\t/* Fix the size in place */\n\t\t\t\terr = fix_size_in_place(c, e);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t\tif (e->inode)\n\t\t\t\t\tiput(e->inode);\n\t\t\t}\n\t\t}\n\n\t\tthis = rb_next(this);\n\t\trb_erase(&e->rb, &c->size_tree);\n\t\tkfree(e);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "fs.h\"\n\n/**\n * is_em",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ret",
          "args": [
            "r"
          ],
          "line": 1549
        },
        "resolved": true,
        "details": {
          "function_name": "retire_sysctl_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "1567-1570",
          "snippet": "void retire_sysctl_set(struct ctl_table_set *set)\n{\n\tWARN_ON(!RB_EMPTY_ROOT(&set->dir.root));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nvoid retire_sysctl_set(struct ctl_table_set *set)\n{\n\tWARN_ON(!RB_EMPTY_ROOT(&set->dir.root));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb, &c->",
          "args": [
            "ize_tr",
            ");\n\t\tkfree(e)"
          ],
          "line": 1548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";\n\t\trb_",
          "args": [
            "rase"
          ],
          "line": 1547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");",
          "args": [
            "}\n\t\t}"
          ],
          "line": 1543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lace(c, e);\n\t\t\t\ti",
          "args": [
            "r"
          ],
          "line": 1539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "}",
          "args": [
            "else"
          ],
          "line": 1536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ";",
          "args": [
            "onti"
          ],
          "line": 1533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "o %lu siz",
          "args": [
            "%lld -> %lld\",\n\t\t\t\t\t\t  (un",
            "g)e->inum,\n\t\t\t\t\t\t  ino",
            ", e->d_size);",
            "inode"
          ],
          "line": 1526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node);",
          "args": [
            "f (in"
          ],
          "line": 1524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");",
          "args": [
            "ui ="
          ],
          "line": 1522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ")",
          "args": [
            "retur"
          ],
          "line": 1521
        },
        "resolved": true,
        "details": {
          "function_name": "(void)\n{\n\tint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/shrinker.c",
          "lines": "225-277",
          "snippet": "ck_a_thread(void)\n{\n\tint i;\n\tstruct ubifs_info *c;\n\n\t/*\n\t * Iterate over all mounted UBIFS file-systems and find out if there is\n\t * already an ongoing commit operation there. If no, then iterate for\n\t * the second time and initiate background commit.\n\t */\n\tspin_lock(&ubifs_infos_lock);\n\tfor (i = 0; i < 2; i++) {\n\t\tlist_for_each_entry(c, &ubifs_infos, infos_list) {\n\t\t\tlong dirty_zn_cnt;\n\n\t\t\tif (!mutex_trylock(&c->umount_mutex)) {\n\t\t\t\t/*\n\t\t\t\t * Some un-mount is in progress, it will\n\t\t\t\t * certainly free memory, so just return.\n\t\t\t\t */\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tdirty_zn_cnt = atomic_long_read(&c->dirty_zn_cnt);\n\n\t\t\tif (!dirty_zn_cnt || c->cmt_state == COMMIT_BROKEN ||\n\t\t\t    c->ro_mount || c->ro_error) {\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (c->cmt_state != COMMIT_RESTING) {\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (i == 1) {\n\t\t\t\tlist_move_tail(&c->infos_list, &ubifs_infos);\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\n\t\t\t\tubifs_request_bg_commit(c);\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t}\n\t}\n\tspin_unlock(&ubifs_infos_lock);\n\n\treturn 0;\n}\n\nunsigned lo",
          "includes": [
            "fs.h\"\n\n/* List of a"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\n/* List of a\n\nck_a_thread(void)\n{\n\tint i;\n\tstruct ubifs_info *c;\n\n\t/*\n\t * Iterate over all mounted UBIFS file-systems and find out if there is\n\t * already an ongoing commit operation there. If no, then iterate for\n\t * the second time and initiate background commit.\n\t */\n\tspin_lock(&ubifs_infos_lock);\n\tfor (i = 0; i < 2; i++) {\n\t\tlist_for_each_entry(c, &ubifs_infos, infos_list) {\n\t\t\tlong dirty_zn_cnt;\n\n\t\t\tif (!mutex_trylock(&c->umount_mutex)) {\n\t\t\t\t/*\n\t\t\t\t * Some un-mount is in progress, it will\n\t\t\t\t * certainly free memory, so just return.\n\t\t\t\t */\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tdirty_zn_cnt = atomic_long_read(&c->dirty_zn_cnt);\n\n\t\t\tif (!dirty_zn_cnt || c->cmt_state == COMMIT_BROKEN ||\n\t\t\t    c->ro_mount || c->ro_error) {\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (c->cmt_state != COMMIT_RESTING) {\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tif (i == 1) {\n\t\t\t\tlist_move_tail(&c->infos_list, &ubifs_infos);\n\t\t\t\tspin_unlock(&ubifs_infos_lock);\n\n\t\t\t\tubifs_request_bg_commit(c);\n\t\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tmutex_unlock(&c->umount_mutex);\n\t\t}\n\t}\n\tspin_unlock(&ubifs_infos_lock);\n\n\treturn 0;\n}\n\nunsigned lo"
        }
      },
      {
        "call_info": {
          "callee": ">vfs_sb, e",
          "args": [
            ">inum);",
            "if (IS"
          ],
          "line": 1520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!e->inode);",
          "args": [
            "inode"
          ],
          "line": 1518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "no->size);",
          "args": [
            "}\n\t\t}"
          ],
          "line": 1508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ove_ino(c, e->inum);",
          "args": [
            "if (er"
          ],
          "line": 1501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "moving in",
          "args": [
            "%lu\",\n\t\t\t\t\t  (uns",
            "g)e->inum);\n\t\t\t\terr ="
          ],
          "line": 1499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kup(c, &key, c->",
          "args": [
            "b",
            ");",
            "if (err"
          ],
          "line": 1494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c, &key, e->",
          "args": [
            "n",
            ");",
            "err = u"
          ],
          "line": 1493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ", struct",
          "args": [
            "size",
            "ntry, b);\n\t\tif (",
            "->"
          ],
          "line": 1489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "size_tre",
          "args": [
            ");\n\n\twhile (t"
          ],
          "line": 1483
        },
        "resolved": true,
        "details": {
          "function_name": "_size_tree(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/recovery.c",
          "lines": "1335-1346",
          "snippet": "stroy_size_tree(struct ubifs_info *c)\n{\n\tstruct size_entry *e, *n;\n\n\trbtree_postorder_for_each_entry_safe(e, n, &c->size_tree, rb) {\n\t\tif (e->inode)\n\t\t\tiput(e->inode);\n\t\tkfree(e);\n\t}\n\n\tc->size_tree = RB_ROOT;\n}\n\n/**\n * ubif",
          "includes": [
            "fs.h\"\n\n/**\n * is_em",
            "ux/slab.h>\n#include \"ubi",
            "ux/crc32.h>\n#include <lin"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\n/**\n * is_em\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nstroy_size_tree(struct ubifs_info *c)\n{\n\tstruct size_entry *e, *n;\n\n\trbtree_postorder_for_each_entry_safe(e, n, &c->size_tree, rb) {\n\t\tif (e->inode)\n\t\t\tiput(e->inode);\n\t\tkfree(e);\n\t}\n\n\tc->size_tree = RB_ROOT;\n}\n\n/**\n * ubif"
        }
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * is_em\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nover_size(struct ubifs_info *c)\n{\n\tstruct rb_node *this = rb_first(&c->size_tree);\n\n\twhile (this) {\n\t\tstruct size_entry *e;\n\t\tint err;\n\n\t\te = rb_entry(this, struct size_entry, rb);\n\t\tif (!e->exists) {\n\t\t\tunion ubifs_key key;\n\n\t\t\tino_key_init(c, &key, e->inum);\n\t\t\terr = ubifs_tnc_lookup(c, &key, c->sbuf);\n\t\t\tif (err && err != -ENOENT)\n\t\t\t\treturn err;\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t/* Remove data nodes that have no inode */\n\t\t\t\tdbg_rcvry(\"removing ino %lu\",\n\t\t\t\t\t  (unsigned long)e->inum);\n\t\t\t\terr = ubifs_tnc_remove_ino(c, e->inum);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t} else {\n\t\t\t\tstruct ubifs_ino_node *ino = c->sbuf;\n\n\t\t\t\te->exists = 1;\n\t\t\t\te->i_size = le64_to_cpu(ino->size);\n\t\t\t}\n\t\t}\n\n\t\tif (e->exists && e->i_size < e->d_size) {\n\t\t\tif (c->ro_mount) {\n\t\t\t\t/* Fix the inode size and pin it in memory */\n\t\t\t\tstruct inode *inode;\n\t\t\t\tstruct ubifs_inode *ui;\n\n\t\t\t\tubifs_assert(!e->inode);\n\n\t\t\t\tinode = ubifs_iget(c->vfs_sb, e->inum);\n\t\t\t\tif (IS_ERR(inode))\n\t\t\t\t\treturn PTR_ERR(inode);\n\n\t\t\t\tui = ubifs_inode(inode);\n\t\t\t\tif (inode->i_size < e->d_size) {\n\t\t\t\t\tdbg_rcvry(\"ino %lu size %lld -> %lld\",\n\t\t\t\t\t\t  (unsigned long)e->inum,\n\t\t\t\t\t\t  inode->i_size, e->d_size);\n\t\t\t\t\tinode->i_size = e->d_size;\n\t\t\t\t\tui->ui_size = e->d_size;\n\t\t\t\t\tui->synced_i_size = e->d_size;\n\t\t\t\t\te->inode = inode;\n\t\t\t\t\tthis = rb_next(this);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tiput(inode);\n\t\t\t} else {\n\t\t\t\t/* Fix the size in place */\n\t\t\t\terr = fix_size_in_place(c, e);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t\tif (e->inode)\n\t\t\t\t\tiput(e->inode);\n\t\t\t}\n\t\t}\n\n\t\tthis = rb_next(this);\n\t\trb_erase(&e->rb, &c->size_tree);\n\t\tkfree(e);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "lace(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/recovery.c",
    "lines": "1421-1470",
    "snippet": "x_size_in_place(struct ubifs_info *c, struct size_entry *e)\n{\n\tstruct ubifs_ino_node *ino = c->sbuf;\n\tunsigned char *p;\n\tunion ubifs_key key;\n\tint err, lnum, offs, len;\n\tloff_t i_size;\n\tuint32_t crc;\n\n\t/* Locate the inode node LEB number and offset */\n\tino_key_init(c, &key, e->inum);\n\terr = ubifs_tnc_locate(c, &key, ino, &lnum, &offs);\n\tif (err)\n\t\tgoto out;\n\t/*\n\t * If the size recorded on the inode node is greater than the size that\n\t * was calculated from nodes in the journal then don't change the inode.\n\t */\n\ti_size = le64_to_cpu(ino->size);\n\tif (i_size >= e->d_size)\n\t\treturn 0;\n\t/* Read the LEB */\n\terr = ubifs_leb_read(c, lnum, c->sbuf, 0, c->leb_size, 1);\n\tif (err)\n\t\tgoto out;\n\t/* Change the size field and recalculate the CRC */\n\tino = c->sbuf + offs;\n\tino->size = cpu_to_le64(e->d_size);\n\tlen = le32_to_cpu(ino->ch.len);\n\tcrc = crc32(UBIFS_CRC32_INIT, (void *)ino + 8, len - 8);\n\tino->ch.crc = cpu_to_le32(crc);\n\t/* Work out where data in the LEB ends and free space begins */\n\tp = c->sbuf;\n\tlen = c->leb_size - 1;\n\twhile (p[len] == 0xff)\n\t\tlen -= 1;\n\tlen = ALIGN(len + 1, c->min_io_size);\n\t/* Atomically write the fixed LEB back again */\n\terr = ubifs_leb_change(c, lnum, c->sbuf, len);\n\tif (err)\n\t\tgoto out;\n\tdbg_rcvry(\"inode %lu at %d:%d size %lld -> %lld\",\n\t\t  (unsigned long)e->inum, lnum, offs, i_size, e->d_size);\n\treturn 0;\n\nout:\n\tubifs_warn(\"inode %lu failed to fix size %lld -> %lld error %d\",\n\t\t   (unsigned long)e->inum, e->i_size, e->d_size, err);\n\treturn err;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/**\n * is_em",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "node %lu f",
          "args": [
            "iled to fix size %lld -> %lld error %d\",\n\t\t   (unsig",
            "g)e->inum, e->i_size,",
            ">d_size,",
            "r);\n\tretu",
            "er"
          ],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode %lu a",
          "args": [
            "%d:%d size %lld -> %lld\",\n\t\t  (unsign",
            "g)e->inum, lnum, offs,",
            "_siz",
            "e->",
            "size);",
            "return 0;"
          ],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nge(c, lnum, c->",
          "args": [
            "b",
            ", le",
            ";\n\tif (",
            "r)"
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ", c->",
          "args": [
            "in_io_s",
            "e);\n\t/* Atomic"
          ],
          "line": 1457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rc);\n\t/* Wo",
          "args": [
            "k o"
          ],
          "line": 1451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RC32_",
          "args": [
            "NIT, (void *)ino",
            "8, len - 8);",
            "o->ch.c"
          ],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "no->ch.len)",
          "args": [
            "crc = crc"
          ],
          "line": 1449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->d_size);",
          "args": [
            "len = le3"
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d(c, lnum, c->",
          "args": [
            "b",
            ", 0,",
            "->leb_s",
            "e",
            "1);\n\tif (er"
          ],
          "line": 1443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "no->size);",
          "args": [
            "if (i_siz"
          ],
          "line": 1439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ate(c, &key, ino",
          "args": [
            "num,",
            "off",
            ";\n\tif",
            "err)"
          ],
          "line": 1432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c, &key, e->",
          "args": [
            "n",
            ");",
            "r = ubi"
          ],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * is_em\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nx_size_in_place(struct ubifs_info *c, struct size_entry *e)\n{\n\tstruct ubifs_ino_node *ino = c->sbuf;\n\tunsigned char *p;\n\tunion ubifs_key key;\n\tint err, lnum, offs, len;\n\tloff_t i_size;\n\tuint32_t crc;\n\n\t/* Locate the inode node LEB number and offset */\n\tino_key_init(c, &key, e->inum);\n\terr = ubifs_tnc_locate(c, &key, ino, &lnum, &offs);\n\tif (err)\n\t\tgoto out;\n\t/*\n\t * If the size recorded on the inode node is greater than the size that\n\t * was calculated from nodes in the journal then don't change the inode.\n\t */\n\ti_size = le64_to_cpu(ino->size);\n\tif (i_size >= e->d_size)\n\t\treturn 0;\n\t/* Read the LEB */\n\terr = ubifs_leb_read(c, lnum, c->sbuf, 0, c->leb_size, 1);\n\tif (err)\n\t\tgoto out;\n\t/* Change the size field and recalculate the CRC */\n\tino = c->sbuf + offs;\n\tino->size = cpu_to_le64(e->d_size);\n\tlen = le32_to_cpu(ino->ch.len);\n\tcrc = crc32(UBIFS_CRC32_INIT, (void *)ino + 8, len - 8);\n\tino->ch.crc = cpu_to_le32(crc);\n\t/* Work out where data in the LEB ends and free space begins */\n\tp = c->sbuf;\n\tlen = c->leb_size - 1;\n\twhile (p[len] == 0xff)\n\t\tlen -= 1;\n\tlen = ALIGN(len + 1, c->min_io_size);\n\t/* Atomically write the fixed LEB back again */\n\terr = ubifs_leb_change(c, lnum, c->sbuf, len);\n\tif (err)\n\t\tgoto out;\n\tdbg_rcvry(\"inode %lu at %d:%d size %lld -> %lld\",\n\t\t  (unsigned long)e->inum, lnum, offs, i_size, e->d_size);\n\treturn 0;\n\nout:\n\tubifs_warn(\"inode %lu failed to fix size %lld -> %lld error %d\",\n\t\t   (unsigned long)e->inum, e->i_size, e->d_size, err);\n\treturn err;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "_size_accum(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/recovery.c",
    "lines": "1373-1414",
    "snippet": "over_size_accum(struct ubifs_info *c, union ubifs_key *key,\n\t\t\t     int deletion, loff_t new_size)\n{\n\tino_t inum = key_inum(c, key);\n\tstruct size_entry *e;\n\tint err;\n\n\tswitch (key_type(c, key)) {\n\tcase UBIFS_INO_KEY:\n\t\tif (deletion)\n\t\t\tremove_ino(c, inum);\n\t\telse {\n\t\t\te = find_ino(c, inum);\n\t\t\tif (e) {\n\t\t\t\te->i_size = new_size;\n\t\t\t\te->exists = 1;\n\t\t\t} else {\n\t\t\t\terr = add_ino(c, inum, new_size, 0, 1);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase UBIFS_DATA_KEY:\n\t\te = find_ino(c, inum);\n\t\tif (e) {\n\t\t\tif (new_size > e->d_size)\n\t\t\t\te->d_size = new_size;\n\t\t} else {\n\t\t\terr = add_ino(c, inum, 0, new_size, 0);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tbreak;\n\tcase UBIFS_TRUN_KEY:\n\t\te = find_ino(c, inum);\n\t\tif (e)\n\t\t\te->d_size = new_size;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n/**\n * fix_",
    "includes": [
      "fs.h\"\n\n/**\n * is_em",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "num);",
          "args": [
            "f",
            "e)"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "um, 0,",
          "args": [
            "e",
            "size",
            "0",
            "if (",
            "r"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num);",
          "args": [
            "f",
            "e) {"
          ],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "um, new",
          "args": [
            "s",
            "e, 0",
            "1);",
            "r"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num);",
          "args": [
            "i",
            "(e)"
          ],
          "line": 1385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inum);",
          "args": [
            "l",
            "{"
          ],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ey)) {",
          "args": [
            "a",
            "UB"
          ],
          "line": 1380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ey);\n\tst",
          "args": [
            "u",
            "si"
          ],
          "line": 1376
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * is_em\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nover_size_accum(struct ubifs_info *c, union ubifs_key *key,\n\t\t\t     int deletion, loff_t new_size)\n{\n\tino_t inum = key_inum(c, key);\n\tstruct size_entry *e;\n\tint err;\n\n\tswitch (key_type(c, key)) {\n\tcase UBIFS_INO_KEY:\n\t\tif (deletion)\n\t\t\tremove_ino(c, inum);\n\t\telse {\n\t\t\te = find_ino(c, inum);\n\t\t\tif (e) {\n\t\t\t\te->i_size = new_size;\n\t\t\t\te->exists = 1;\n\t\t\t} else {\n\t\t\t\terr = add_ino(c, inum, new_size, 0, 1);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase UBIFS_DATA_KEY:\n\t\te = find_ino(c, inum);\n\t\tif (e) {\n\t\t\tif (new_size > e->d_size)\n\t\t\t\te->d_size = new_size;\n\t\t} else {\n\t\t\terr = add_ino(c, inum, 0, new_size, 0);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tbreak;\n\tcase UBIFS_TRUN_KEY:\n\t\te = find_ino(c, inum);\n\t\tif (e)\n\t\t\te->d_size = new_size;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n/**\n * fix_"
  },
  {
    "function_name": "_size_tree(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/recovery.c",
    "lines": "1335-1346",
    "snippet": "stroy_size_tree(struct ubifs_info *c)\n{\n\tstruct size_entry *e, *n;\n\n\trbtree_postorder_for_each_entry_safe(e, n, &c->size_tree, rb) {\n\t\tif (e->inode)\n\t\t\tiput(e->inode);\n\t\tkfree(e);\n\t}\n\n\tc->size_tree = RB_ROOT;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/**\n * is_em",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "c->",
          "args": [
            "i"
          ],
          "line": 1342
        },
        "resolved": true,
        "details": {
          "function_name": "_size(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/recovery.c",
          "lines": "1481-1553",
          "snippet": "over_size(struct ubifs_info *c)\n{\n\tstruct rb_node *this = rb_first(&c->size_tree);\n\n\twhile (this) {\n\t\tstruct size_entry *e;\n\t\tint err;\n\n\t\te = rb_entry(this, struct size_entry, rb);\n\t\tif (!e->exists) {\n\t\t\tunion ubifs_key key;\n\n\t\t\tino_key_init(c, &key, e->inum);\n\t\t\terr = ubifs_tnc_lookup(c, &key, c->sbuf);\n\t\t\tif (err && err != -ENOENT)\n\t\t\t\treturn err;\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t/* Remove data nodes that have no inode */\n\t\t\t\tdbg_rcvry(\"removing ino %lu\",\n\t\t\t\t\t  (unsigned long)e->inum);\n\t\t\t\terr = ubifs_tnc_remove_ino(c, e->inum);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t} else {\n\t\t\t\tstruct ubifs_ino_node *ino = c->sbuf;\n\n\t\t\t\te->exists = 1;\n\t\t\t\te->i_size = le64_to_cpu(ino->size);\n\t\t\t}\n\t\t}\n\n\t\tif (e->exists && e->i_size < e->d_size) {\n\t\t\tif (c->ro_mount) {\n\t\t\t\t/* Fix the inode size and pin it in memory */\n\t\t\t\tstruct inode *inode;\n\t\t\t\tstruct ubifs_inode *ui;\n\n\t\t\t\tubifs_assert(!e->inode);\n\n\t\t\t\tinode = ubifs_iget(c->vfs_sb, e->inum);\n\t\t\t\tif (IS_ERR(inode))\n\t\t\t\t\treturn PTR_ERR(inode);\n\n\t\t\t\tui = ubifs_inode(inode);\n\t\t\t\tif (inode->i_size < e->d_size) {\n\t\t\t\t\tdbg_rcvry(\"ino %lu size %lld -> %lld\",\n\t\t\t\t\t\t  (unsigned long)e->inum,\n\t\t\t\t\t\t  inode->i_size, e->d_size);\n\t\t\t\t\tinode->i_size = e->d_size;\n\t\t\t\t\tui->ui_size = e->d_size;\n\t\t\t\t\tui->synced_i_size = e->d_size;\n\t\t\t\t\te->inode = inode;\n\t\t\t\t\tthis = rb_next(this);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tiput(inode);\n\t\t\t} else {\n\t\t\t\t/* Fix the size in place */\n\t\t\t\terr = fix_size_in_place(c, e);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t\tif (e->inode)\n\t\t\t\t\tiput(e->inode);\n\t\t\t}\n\t\t}\n\n\t\tthis = rb_next(this);\n\t\trb_erase(&e->rb, &c->size_tree);\n\t\tkfree(e);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "fs.h\"\n\n/**\n * is_em",
            "ux/slab.h>\n#include \"ubi",
            "ux/crc32.h>\n#include <lin"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\n/**\n * is_em\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nover_size(struct ubifs_info *c)\n{\n\tstruct rb_node *this = rb_first(&c->size_tree);\n\n\twhile (this) {\n\t\tstruct size_entry *e;\n\t\tint err;\n\n\t\te = rb_entry(this, struct size_entry, rb);\n\t\tif (!e->exists) {\n\t\t\tunion ubifs_key key;\n\n\t\t\tino_key_init(c, &key, e->inum);\n\t\t\terr = ubifs_tnc_lookup(c, &key, c->sbuf);\n\t\t\tif (err && err != -ENOENT)\n\t\t\t\treturn err;\n\t\t\tif (err == -ENOENT) {\n\t\t\t\t/* Remove data nodes that have no inode */\n\t\t\t\tdbg_rcvry(\"removing ino %lu\",\n\t\t\t\t\t  (unsigned long)e->inum);\n\t\t\t\terr = ubifs_tnc_remove_ino(c, e->inum);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t} else {\n\t\t\t\tstruct ubifs_ino_node *ino = c->sbuf;\n\n\t\t\t\te->exists = 1;\n\t\t\t\te->i_size = le64_to_cpu(ino->size);\n\t\t\t}\n\t\t}\n\n\t\tif (e->exists && e->i_size < e->d_size) {\n\t\t\tif (c->ro_mount) {\n\t\t\t\t/* Fix the inode size and pin it in memory */\n\t\t\t\tstruct inode *inode;\n\t\t\t\tstruct ubifs_inode *ui;\n\n\t\t\t\tubifs_assert(!e->inode);\n\n\t\t\t\tinode = ubifs_iget(c->vfs_sb, e->inum);\n\t\t\t\tif (IS_ERR(inode))\n\t\t\t\t\treturn PTR_ERR(inode);\n\n\t\t\t\tui = ubifs_inode(inode);\n\t\t\t\tif (inode->i_size < e->d_size) {\n\t\t\t\t\tdbg_rcvry(\"ino %lu size %lld -> %lld\",\n\t\t\t\t\t\t  (unsigned long)e->inum,\n\t\t\t\t\t\t  inode->i_size, e->d_size);\n\t\t\t\t\tinode->i_size = e->d_size;\n\t\t\t\t\tui->ui_size = e->d_size;\n\t\t\t\t\tui->synced_i_size = e->d_size;\n\t\t\t\t\te->inode = inode;\n\t\t\t\t\tthis = rb_next(this);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tiput(inode);\n\t\t\t} else {\n\t\t\t\t/* Fix the size in place */\n\t\t\t\terr = fix_size_in_place(c, e);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t\tif (e->inode)\n\t\t\t\t\tiput(e->inode);\n\t\t\t}\n\t\t}\n\n\t\tthis = rb_next(this);\n\t\trb_erase(&e->rb, &c->size_tree);\n\t\tkfree(e);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": ");",
          "args": [
            "kfree(e)"
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "der_for_each_entry_safe(e, n, &c->si",
          "args": [
            "e",
            "r",
            ", rb) {\n\t\tif",
            "->"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * is_em\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nstroy_size_tree(struct ubifs_info *c)\n{\n\tstruct size_entry *e, *n;\n\n\trbtree_postorder_for_each_entry_safe(e, n, &c->size_tree, rb) {\n\t\tif (e->inode)\n\t\t\tiput(e->inode);\n\t\tkfree(e);\n\t}\n\n\tc->size_tree = RB_ROOT;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "ruct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/recovery.c",
    "lines": "1321-1329",
    "snippet": "emove_ino(struct ubifs_info *c, ino_t inum)\n{\n\tstruct size_entry *e = find_ino(c, inum);\n\n\tif (!e)\n\t\treturn;\n\trb_erase(&e->rb, &c->size_tree);\n\tkfree(e);\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/**\n * is_em",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "/**",
          "args": [],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb, &c->",
          "args": [
            "ize_tr",
            ");\n\tkfree(e);"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num);",
          "args": [
            "f",
            "!e)"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * is_em\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nemove_ino(struct ubifs_info *c, ino_t inum)\n{\n\tstruct size_entry *e = find_ino(c, inum);\n\n\tif (!e)\n\t\treturn;\n\trb_erase(&e->rb, &c->size_tree);\n\tkfree(e);\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "ct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/recovery.c",
    "lines": "1299-1314",
    "snippet": "size_entry *find_ino(struct ubifs_info *c, ino_t inum)\n{\n\tstruct rb_node *p = c->size_tree.rb_node;\n\tstruct size_entry *e;\n\n\twhile (p) {\n\t\te = rb_entry(p, struct size_entry, rb);\n\t\tif (inum < e->inum)\n\t\t\tp = p->rb_left;\n\t\telse if (inum > e->inum)\n\t\t\tp = p->rb_right;\n\t\telse\n\t\t\treturn e;\n\t}\n\treturn NULL;\n}\n\n/**\n * remo",
    "includes": [
      "fs.h\"\n\n/**\n * is_em",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "truct si",
          "args": [
            "e",
            "ntry, b);\n\t\tif (",
            "um"
          ],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * is_em\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nsize_entry *find_ino(struct ubifs_info *c, ino_t inum)\n{\n\tstruct rb_node *p = c->size_tree.rb_node;\n\tstruct size_entry *e;\n\n\twhile (p) {\n\t\te = rb_entry(p, struct size_entry, rb);\n\t\tif (inum < e->inum)\n\t\t\tp = p->rb_left;\n\t\telse if (inum > e->inum)\n\t\t\tp = p->rb_right;\n\t\telse\n\t\t\treturn e;\n\t}\n\treturn NULL;\n}\n\n/**\n * remo"
  },
  {
    "function_name": "t ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/recovery.c",
    "lines": "1264-1292",
    "snippet": "d_ino(struct ubifs_info *c, ino_t inum, loff_t i_size,\n\t\t   loff_t d_size, int exists)\n{\n\tstruct rb_node **p = &c->size_tree.rb_node, *parent = NULL;\n\tstruct size_entry *e;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\te = rb_entry(parent, struct size_entry, rb);\n\t\tif (inum < e->inum)\n\t\t\tp = &(*p)->rb_left;\n\t\telse\n\t\t\tp = &(*p)->rb_right;\n\t}\n\n\te = kzalloc(sizeof(struct size_entry), GFP_KERNEL);\n\tif (!e)\n\t\treturn -ENOMEM;\n\n\te->inum = inum;\n\te->i_size = i_size;\n\te->d_size = d_size;\n\te->exists = exists;\n\n\trb_link_node(&e->rb, parent, p);\n\trb_insert_color(&e->rb, &c->size_tree);\n\n\treturn 0;\n}\n\n/**\n * find",
    "includes": [
      "fs.h\"\n\n/**\n * is_em",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "or(&e->rb, &c->",
          "args": [
            "ize_tr",
            ");\n\n\treturn 0"
          ],
          "line": 1289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&e->rb, pare",
          "args": [
            "t, p);",
            "rb_ins",
            "t"
          ],
          "line": 1288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f(struc",
          "args": [
            "size_entry), GFP_KERNEL)",
            "if (!e)"
          ],
          "line": 1279
        },
        "resolved": true,
        "details": {
          "function_name": "f(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/log.c",
          "lines": "71-96",
          "snippet": "wbuf *ubifs_get_wbuf(struct ubifs_info *c, int lnum)\n{\n\tstruct rb_node *p;\n\tstruct ubifs_bud *bud;\n\tint jhead;\n\n\tif (!c->jheads)\n\t\treturn NULL;\n\n\tspin_lock(&c->buds_lock);\n\tp = c->buds.rb_node;\n\twhile (p) {\n\t\tbud = rb_entry(p, struct ubifs_bud, rb);\n\t\tif (lnum < bud->lnum)\n\t\t\tp = p->rb_left;\n\t\telse if (lnum > bud->lnum)\n\t\t\tp = p->rb_right;\n\t\telse {\n\t\t\tjhead = bud->jhead;\n\t\t\tspin_unlock(&c->buds_lock);\n\t\t\treturn &c->jheads[jhead].wbuf;\n\t\t}\n\t}\n\tspin_unlock(&c->buds_lock);\n\treturn NULL;\n}\n\n/**\n * empt",
          "includes": [
            "fs.h\"\n\nstatic int d"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\nstatic int d\n\nwbuf *ubifs_get_wbuf(struct ubifs_info *c, int lnum)\n{\n\tstruct rb_node *p;\n\tstruct ubifs_bud *bud;\n\tint jhead;\n\n\tif (!c->jheads)\n\t\treturn NULL;\n\n\tspin_lock(&c->buds_lock);\n\tp = c->buds.rb_node;\n\twhile (p) {\n\t\tbud = rb_entry(p, struct ubifs_bud, rb);\n\t\tif (lnum < bud->lnum)\n\t\t\tp = p->rb_left;\n\t\telse if (lnum > bud->lnum)\n\t\t\tp = p->rb_right;\n\t\telse {\n\t\t\tjhead = bud->jhead;\n\t\t\tspin_unlock(&c->buds_lock);\n\t\t\treturn &c->jheads[jhead].wbuf;\n\t\t}\n\t}\n\tspin_unlock(&c->buds_lock);\n\treturn NULL;\n}\n\n/**\n * empt"
        }
      },
      {
        "call_info": {
          "callee": "nt, stru",
          "args": [
            "t size",
            "ntry, b);\n\t\tif (",
            "um"
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * is_em\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nd_ino(struct ubifs_info *c, ino_t inum, loff_t i_size,\n\t\t   loff_t d_size, int exists)\n{\n\tstruct rb_node **p = &c->size_tree.rb_node, *parent = NULL;\n\tstruct size_entry *e;\n\n\twhile (*p) {\n\t\tparent = *p;\n\t\te = rb_entry(parent, struct size_entry, rb);\n\t\tif (inum < e->inum)\n\t\t\tp = &(*p)->rb_left;\n\t\telse\n\t\t\tp = &(*p)->rb_right;\n\t}\n\n\te = kzalloc(sizeof(struct size_entry), GFP_KERNEL);\n\tif (!e)\n\t\treturn -ENOMEM;\n\n\te->inum = inum;\n\te->i_size = i_size;\n\te->d_size = d_size;\n\te->exists = exists;\n\n\trb_link_node(&e->rb, parent, p);\n\trb_insert_color(&e->rb, &c->size_tree);\n\n\treturn 0;\n}\n\n/**\n * find"
  },
  {
    "function_name": "c_commit(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/recovery.c",
    "lines": "1176-1236",
    "snippet": "ry_gc_commit(struct ubifs_info *c)\n{\n\tstruct ubifs_wbuf *wbuf = &c->jheads[GCHD].wbuf;\n\tstruct ubifs_lprops lp;\n\tint err;\n\n\tdbg_rcvry(\"GC head LEB %d, offs %d\", wbuf->lnum, wbuf->offs);\n\n\tc->gc_lnum = -1;\n\tif (wbuf->lnum == -1 || wbuf->offs == c->leb_size)\n\t\treturn grab_empty_leb(c);\n\n\terr = ubifs_find_dirty_leb(c, &lp, wbuf->offs, 2);\n\tif (err) {\n\t\tif (err != -ENOSPC)\n\t\t\treturn err;\n\n\t\tdbg_rcvry(\"could not find a dirty LEB\");\n\t\treturn grab_empty_leb(c);\n\t}\n\n\tubifs_assert(!(lp.flags & LPROPS_INDEX));\n\tubifs_assert(lp.free + lp.dirty >= wbuf->offs);\n\n\t/*\n\t * We run the commit before garbage collection otherwise subsequent\n\t * mounts will see the GC and orphan deletion in a different order.\n\t */\n\tdbg_rcvry(\"committing\");\n\terr = ubifs_run_commit(c);\n\tif (err)\n\t\treturn err;\n\n\tdbg_rcvry(\"GC'ing LEB %d\", lp.lnum);\n\tmutex_lock_nested(&wbuf->io_mutex, wbuf->jhead);\n\terr = ubifs_garbage_collect_leb(c, &lp);\n\tif (err >= 0) {\n\t\tint err2 = ubifs_wbuf_sync_nolock(wbuf);\n\n\t\tif (err2)\n\t\t\terr = err2;\n\t}\n\tmutex_unlock(&wbuf->io_mutex);\n\tif (err < 0) {\n\t\tubifs_err(\"GC failed, error %d\", err);\n\t\tif (err == -EAGAIN)\n\t\t\terr = -EINVAL;\n\t\treturn err;\n\t}\n\n\tubifs_assert(err == LEB_RETAINED);\n\tif (err != LEB_RETAINED)\n\t\treturn -EINVAL;\n\n\terr = ubifs_leb_unmap(c, c->gc_lnum);\n\tif (err)\n\t\treturn err;\n\n\tdbg_rcvry(\"allocated LEB %d for GC\", lp.lnum);\n\treturn 0;\n}\n\n/**\n * stru",
    "includes": [
      "fs.h\"\n\n/**\n * is_em",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "located L",
          "args": [
            "B %d for GC\", lp.lnum);",
            "turn 0;"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ap(c, c->gc_lnu",
          "args": [
            ")",
            "if (err)"
          ],
          "line": 1230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "err == LEB_R",
          "args": [
            "TAINED);\n\tif (err !"
          ],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "failed,",
          "args": [
            "rror %d\", err);\n\t\tif",
            "rr"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&wbuf->io_mu",
          "args": [
            "ex);\n\tif (err <"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nc_nolock(wbuf);\n\n\t\tif",
          "args": [
            "(err"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_collect_leb(c, &lp);\n\tif",
          "args": [
            "(",
            "r >"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sted(&wbuf->io_mu",
          "args": [
            "ex, wbuf->jhead",
            "err = ubi"
          ],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "'ing LEB",
          "args": [
            "d\", lp.lnum);",
            "tex_loc"
          ],
          "line": 1209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mit(c);\n\tif (err",
          "args": [],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmitting\"",
          "args": [
            ";\n\terr = ubi"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lp.free + lp",
          "args": [
            "dirty >= wbuf->offs);\n\n\t/*\n\t * W"
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!(lp.flags &",
          "args": [
            "LPROPS_INDEX));\n\tubifs_ass"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b(c);\n\t}\n\n\tubi",
          "args": [
            "s"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uld not f",
          "args": [
            "nd a dirty LEB\");\n\t\treturn g"
          ],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rty_leb(c, &lp, wbuf",
          "args": [
            ">",
            "fs,",
            ");\n\tif (er"
          ],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b(c);\n\n\terr =",
          "args": [
            "b"
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "head LEB",
          "args": [
            "%d, offs %d\", wbuf->lnum,",
            "buf->offs)",
            "c->gc_ln"
          ],
          "line": 1182
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * is_em\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nry_gc_commit(struct ubifs_info *c)\n{\n\tstruct ubifs_wbuf *wbuf = &c->jheads[GCHD].wbuf;\n\tstruct ubifs_lprops lp;\n\tint err;\n\n\tdbg_rcvry(\"GC head LEB %d, offs %d\", wbuf->lnum, wbuf->offs);\n\n\tc->gc_lnum = -1;\n\tif (wbuf->lnum == -1 || wbuf->offs == c->leb_size)\n\t\treturn grab_empty_leb(c);\n\n\terr = ubifs_find_dirty_leb(c, &lp, wbuf->offs, 2);\n\tif (err) {\n\t\tif (err != -ENOSPC)\n\t\t\treturn err;\n\n\t\tdbg_rcvry(\"could not find a dirty LEB\");\n\t\treturn grab_empty_leb(c);\n\t}\n\n\tubifs_assert(!(lp.flags & LPROPS_INDEX));\n\tubifs_assert(lp.free + lp.dirty >= wbuf->offs);\n\n\t/*\n\t * We run the commit before garbage collection otherwise subsequent\n\t * mounts will see the GC and orphan deletion in a different order.\n\t */\n\tdbg_rcvry(\"committing\");\n\terr = ubifs_run_commit(c);\n\tif (err)\n\t\treturn err;\n\n\tdbg_rcvry(\"GC'ing LEB %d\", lp.lnum);\n\tmutex_lock_nested(&wbuf->io_mutex, wbuf->jhead);\n\terr = ubifs_garbage_collect_leb(c, &lp);\n\tif (err >= 0) {\n\t\tint err2 = ubifs_wbuf_sync_nolock(wbuf);\n\n\t\tif (err2)\n\t\t\terr = err2;\n\t}\n\tmutex_unlock(&wbuf->io_mutex);\n\tif (err < 0) {\n\t\tubifs_err(\"GC failed, error %d\", err);\n\t\tif (err == -EAGAIN)\n\t\t\terr = -EINVAL;\n\t\treturn err;\n\t}\n\n\tubifs_assert(err == LEB_RETAINED);\n\tif (err != LEB_RETAINED)\n\t\treturn -EINVAL;\n\n\terr = ubifs_leb_unmap(c, c->gc_lnum);\n\tif (err)\n\t\treturn err;\n\n\tdbg_rcvry(\"allocated LEB %d for GC\", lp.lnum);\n\treturn 0;\n}\n\n/**\n * stru"
  },
  {
    "function_name": "b(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/recovery.c",
    "lines": "1119-1156",
    "snippet": "ab_empty_leb(struct ubifs_info *c)\n{\n\tint lnum, err;\n\n\t/*\n\t * Note, it is very important to first search for an empty LEB and then\n\t * run the commit, not vice-versa. The reason is that there might be\n\t * only one empty LEB at the moment, the one which has been the\n\t * @c->gc_lnum just before the power cut happened. During the regular\n\t * UBIFS operation (not now) @c->gc_lnum is marked as \"taken\", so no\n\t * one but GC can grab it. But at this moment this single empty LEB is\n\t * not marked as taken, so if we run commit - what happens? Right, the\n\t * commit will grab it and write the index there. Remember that the\n\t * index always expands as long as there is free space, and it only\n\t * starts consolidating when we run out of space.\n\t *\n\t * IOW, if we run commit now, we might not be able to find a free LEB\n\t * after this.\n\t */\n\tlnum = ubifs_find_free_leb_for_idx(c);\n\tif (lnum < 0) {\n\t\tubifs_err(\"could not find an empty LEB\");\n\t\tubifs_dump_lprops(c);\n\t\tubifs_dump_budg(c, &c->bi);\n\t\treturn lnum;\n\t}\n\n\t/* Reset the index flag */\n\terr = ubifs_change_one_lp(c, lnum, LPROPS_NC, LPROPS_NC, 0,\n\t\t\t\t  LPROPS_INDEX, 0);\n\tif (err)\n\t\treturn err;\n\n\tc->gc_lnum = lnum;\n\tdbg_rcvry(\"found empty LEB %d, run commit\", lnum);\n\n\treturn ubifs_run_commit(c);\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/**\n * is_em",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mit(c);\n}\n\n/**",
          "args": [],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "und empty",
          "args": [
            "LEB %d, run commit\", lnum);\n\n\tre",
            "rn u"
          ],
          "line": 1153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "one_lp(c, lnum, LPR",
          "args": [
            "P",
            "NC,",
            "ROPS_NC,",
            "LP",
            "P",
            "0);\n\tif (er"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dg(c, &c->bi);",
          "args": [
            "turn l"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rops(c);\n\t\tubifs_",
          "args": [
            "u"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uld not f",
          "args": [
            "nd an empty LEB\");\n\t\tubifs_du"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ee_leb_for_idx(c);\n\tif (lnu",
          "args": [],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * is_em\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nab_empty_leb(struct ubifs_info *c)\n{\n\tint lnum, err;\n\n\t/*\n\t * Note, it is very important to first search for an empty LEB and then\n\t * run the commit, not vice-versa. The reason is that there might be\n\t * only one empty LEB at the moment, the one which has been the\n\t * @c->gc_lnum just before the power cut happened. During the regular\n\t * UBIFS operation (not now) @c->gc_lnum is marked as \"taken\", so no\n\t * one but GC can grab it. But at this moment this single empty LEB is\n\t * not marked as taken, so if we run commit - what happens? Right, the\n\t * commit will grab it and write the index there. Remember that the\n\t * index always expands as long as there is free space, and it only\n\t * starts consolidating when we run out of space.\n\t *\n\t * IOW, if we run commit now, we might not be able to find a free LEB\n\t * after this.\n\t */\n\tlnum = ubifs_find_free_leb_for_idx(c);\n\tif (lnum < 0) {\n\t\tubifs_err(\"could not find an empty LEB\");\n\t\tubifs_dump_lprops(c);\n\t\tubifs_dump_budg(c, &c->bi);\n\t\treturn lnum;\n\t}\n\n\t/* Reset the index flag */\n\terr = ubifs_change_one_lp(c, lnum, LPROPS_NC, LPROPS_NC, 0,\n\t\t\t\t  LPROPS_INDEX, 0);\n\tif (err)\n\t\treturn err;\n\n\tc->gc_lnum = lnum;\n\tdbg_rcvry(\"found empty LEB %d, run commit\", lnum);\n\n\treturn ubifs_run_commit(c);\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "ebs(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/recovery.c",
    "lines": "1093-1109",
    "snippet": "an_lebs(struct ubifs_info *c, void *sbuf)\n{\n\tdbg_rcvry(\"recovery\");\n\twhile (!list_empty(&c->unclean_leb_list)) {\n\t\tstruct ubifs_unclean_leb *ucleb;\n\t\tint err;\n\n\t\tucleb = list_entry(c->unclean_leb_list.next,\n\t\t\t\t   struct ubifs_unclean_leb, list);\n\t\terr = clean_an_unclean_leb(c, ucleb, sbuf);\n\t\tif (err)\n\t\t\treturn err;\n\t\tlist_del(&ucleb->list);\n\t\tkfree(ucleb);\n\t}\n\treturn 0;\n}\n\n/**\n * grab",
    "includes": [
      "fs.h\"\n\n/**\n * is_em",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "}",
          "args": [
            "eturn"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eb->list",
          "args": [
            ";\n\t\tkfree(uc"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ean_leb(c, ucleb, sb",
          "args": [
            "f",
            "if",
            "err)"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ">unclean_l",
          "args": [
            "b_list.next,\n\t\t\t\t   stru",
            "unclea_leb, list);\n\t\ter",
            "= cl"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "->unclean_",
          "args": [
            "eb_list)) {\n\t\tstruct"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "covery\");",
          "args": [
            "while (!l"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * is_em\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nan_lebs(struct ubifs_info *c, void *sbuf)\n{\n\tdbg_rcvry(\"recovery\");\n\twhile (!list_empty(&c->unclean_leb_list)) {\n\t\tstruct ubifs_unclean_leb *ucleb;\n\t\tint err;\n\n\t\tucleb = list_entry(c->unclean_leb_list.next,\n\t\t\t\t   struct ubifs_unclean_leb, list);\n\t\terr = clean_an_unclean_leb(c, ucleb, sbuf);\n\t\tif (err)\n\t\t\treturn err;\n\t\tlist_del(&ucleb->list);\n\t\tkfree(ucleb);\n\t}\n\treturn 0;\n}\n\n/**\n * grab"
  },
  {
    "function_name": "ean_leb(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/recovery.c",
    "lines": "997-1080",
    "snippet": "ean_an_unclean_leb(struct ubifs_info *c,\n\t\t\t\tstruct ubifs_unclean_leb *ucleb, void *sbuf)\n{\n\tint err, lnum = ucleb->lnum, offs = 0, len = ucleb->endpt, quiet = 1;\n\tvoid *buf = sbuf;\n\n\tdbg_rcvry(\"LEB %d len %d\", lnum, len);\n\n\tif (len == 0) {\n\t\t/* Nothing to read, just unmap it */\n\t\terr = ubifs_leb_unmap(c, lnum);\n\t\tif (err)\n\t\t\treturn err;\n\t\treturn 0;\n\t}\n\n\terr = ubifs_leb_read(c, lnum, buf, offs, len, 0);\n\tif (err && err != -EBADMSG)\n\t\treturn err;\n\n\twhile (len >= 8) {\n\t\tint ret;\n\n\t\tcond_resched();\n\n\t\t/* Scan quietly until there is an error */\n\t\tret = ubifs_scan_a_node(c, buf, len, lnum, offs, quiet);\n\n\t\tif (ret == SCANNED_A_NODE) {\n\t\t\t/* A valid node, and not a padding node */\n\t\t\tstruct ubifs_ch *ch = buf;\n\t\t\tint node_len;\n\n\t\t\tnode_len = ALIGN(le32_to_cpu(ch->len), 8);\n\t\t\toffs += node_len;\n\t\t\tbuf += node_len;\n\t\t\tlen -= node_len;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ret > 0) {\n\t\t\t/* Padding bytes or a valid padding node */\n\t\t\toffs += ret;\n\t\t\tbuf += ret;\n\t\t\tlen -= ret;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ret == SCANNED_EMPTY_SPACE) {\n\t\t\tubifs_err(\"unexpected empty space at %d:%d\",\n\t\t\t\t  lnum, offs);\n\t\t\treturn -EUCLEAN;\n\t\t}\n\n\t\tif (quiet) {\n\t\t\t/* Redo the last scan but noisily */\n\t\t\tquiet = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tubifs_scanned_corruption(c, lnum, offs, buf);\n\t\treturn -EUCLEAN;\n\t}\n\n\t/* Pad to min_io_size */\n\tlen = ALIGN(ucleb->endpt, c->min_io_size);\n\tif (len > ucleb->endpt) {\n\t\tint pad_len = len - ALIGN(ucleb->endpt, 8);\n\n\t\tif (pad_len > 0) {\n\t\t\tbuf = c->sbuf + len - pad_len;\n\t\t\tubifs_pad(c, buf, pad_len);\n\t\t}\n\t}\n\n\t/* Write back the LEB atomically */\n\terr = ubifs_leb_change(c, lnum, sbuf, len);\n\tif (err)\n\t\treturn err;\n\n\tdbg_rcvry(\"cleaned LEB %d\", lnum);\n\n\treturn 0;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/**\n * is_em",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eaned LEB",
          "args": [
            "%d\", lnum);\n\n\tre",
            "rn 0"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nge(c, lnum, sbu",
          "args": [
            ",",
            "en);",
            "if (",
            "r)"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buf, pad_",
          "args": [
            "e",
            ";",
            "}\n\n\t/"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "endpt",
          "args": [
            "8);\n\n\t\tif (",
            "d"
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "endpt",
          "args": [
            "c->min_io_s",
            "e);\n\tif (len >"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_corruption(c, lnum, off",
          "args": [
            ",",
            "uf);",
            "ret",
            "n -"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expected",
          "args": [
            "mpty space at %d:%d\",\n\t\t\t\t  lnum,",
            "r",
            "urn"
          ],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_report_unexpected_submission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/operation.c",
          "lines": "144-176",
          "snippet": "static void fscache_report_unexpected_submission(struct fscache_object *object,\n\t\t\t\t\t\t struct fscache_operation *op,\n\t\t\t\t\t\t const struct fscache_state *ostate)\n{\n\tstatic bool once_only;\n\tstruct fscache_operation *p;\n\tunsigned n;\n\n\tif (once_only)\n\t\treturn;\n\tonce_only = true;\n\n\tkdebug(\"unexpected submission OP%x [OBJ%x %s]\",\n\t       op->debug_id, object->debug_id, object->state->name);\n\tkdebug(\"objstate=%s [%s]\", object->state->name, ostate->name);\n\tkdebug(\"objflags=%lx\", object->flags);\n\tkdebug(\"objevent=%lx [%lx]\", object->events, object->event_mask);\n\tkdebug(\"ops=%u inp=%u exc=%u\",\n\t       object->n_ops, object->n_in_progress, object->n_exclusive);\n\n\tif (!list_empty(&object->pending_ops)) {\n\t\tn = 0;\n\t\tlist_for_each_entry(p, &object->pending_ops, pend_link) {\n\t\t\tASSERTCMP(p->object, ==, object);\n\t\t\tkdebug(\"%p %p\", op->processor, op->release);\n\t\t\tn++;\n\t\t}\n\n\t\tkdebug(\"n=%u\", n);\n\t}\n\n\tdump_stack();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n\nstatic void fscache_report_unexpected_submission(struct fscache_object *object,\n\t\t\t\t\t\t struct fscache_operation *op,\n\t\t\t\t\t\t const struct fscache_state *ostate)\n{\n\tstatic bool once_only;\n\tstruct fscache_operation *p;\n\tunsigned n;\n\n\tif (once_only)\n\t\treturn;\n\tonce_only = true;\n\n\tkdebug(\"unexpected submission OP%x [OBJ%x %s]\",\n\t       op->debug_id, object->debug_id, object->state->name);\n\tkdebug(\"objstate=%s [%s]\", object->state->name, ostate->name);\n\tkdebug(\"objflags=%lx\", object->flags);\n\tkdebug(\"objevent=%lx [%lx]\", object->events, object->event_mask);\n\tkdebug(\"ops=%u inp=%u exc=%u\",\n\t       object->n_ops, object->n_in_progress, object->n_exclusive);\n\n\tif (!list_empty(&object->pending_ops)) {\n\t\tn = 0;\n\t\tlist_for_each_entry(p, &object->pending_ops, pend_link) {\n\t\t\tASSERTCMP(p->object, ==, object);\n\t\t\tkdebug(\"%p %p\", op->processor, op->release);\n\t\t\tn++;\n\t\t}\n\n\t\tkdebug(\"n=%u\", n);\n\t}\n\n\tdump_stack();\n}"
        }
      },
      {
        "call_info": {
          "callee": "_cpu(",
          "args": [
            "h->len), 8);\n\t\t\toffs",
            "="
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "h->len), 8)",
          "args": [
            "off"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node(c, buf, len,",
          "args": [
            "l",
            "m,",
            "fs,",
            "uiet",
            "(ret"
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\n\t\t/* Sca",
          "args": [],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d(c, lnum, buf",
          "args": [
            "fs,",
            "n,",
            ";\n\ti",
            "(er",
            "&"
          ],
          "line": 1013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ap(c, lnum);",
          "args": [
            "f",
            "err)"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B %d len",
          "args": [
            "d\", lnum, len);",
            "if",
            "en"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * is_em\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nean_an_unclean_leb(struct ubifs_info *c,\n\t\t\t\tstruct ubifs_unclean_leb *ucleb, void *sbuf)\n{\n\tint err, lnum = ucleb->lnum, offs = 0, len = ucleb->endpt, quiet = 1;\n\tvoid *buf = sbuf;\n\n\tdbg_rcvry(\"LEB %d len %d\", lnum, len);\n\n\tif (len == 0) {\n\t\t/* Nothing to read, just unmap it */\n\t\terr = ubifs_leb_unmap(c, lnum);\n\t\tif (err)\n\t\t\treturn err;\n\t\treturn 0;\n\t}\n\n\terr = ubifs_leb_read(c, lnum, buf, offs, len, 0);\n\tif (err && err != -EBADMSG)\n\t\treturn err;\n\n\twhile (len >= 8) {\n\t\tint ret;\n\n\t\tcond_resched();\n\n\t\t/* Scan quietly until there is an error */\n\t\tret = ubifs_scan_a_node(c, buf, len, lnum, offs, quiet);\n\n\t\tif (ret == SCANNED_A_NODE) {\n\t\t\t/* A valid node, and not a padding node */\n\t\t\tstruct ubifs_ch *ch = buf;\n\t\t\tint node_len;\n\n\t\t\tnode_len = ALIGN(le32_to_cpu(ch->len), 8);\n\t\t\toffs += node_len;\n\t\t\tbuf += node_len;\n\t\t\tlen -= node_len;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ret > 0) {\n\t\t\t/* Padding bytes or a valid padding node */\n\t\t\toffs += ret;\n\t\t\tbuf += ret;\n\t\t\tlen -= ret;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ret == SCANNED_EMPTY_SPACE) {\n\t\t\tubifs_err(\"unexpected empty space at %d:%d\",\n\t\t\t\t  lnum, offs);\n\t\t\treturn -EUCLEAN;\n\t\t}\n\n\t\tif (quiet) {\n\t\t\t/* Redo the last scan but noisily */\n\t\t\tquiet = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tubifs_scanned_corruption(c, lnum, offs, buf);\n\t\treturn -EUCLEAN;\n\t}\n\n\t/* Pad to min_io_size */\n\tlen = ALIGN(ucleb->endpt, c->min_io_size);\n\tif (len > ucleb->endpt) {\n\t\tint pad_len = len - ALIGN(ucleb->endpt, 8);\n\n\t\tif (pad_len > 0) {\n\t\t\tbuf = c->sbuf + len - pad_len;\n\t\t\tubifs_pad(c, buf, pad_len);\n\t\t}\n\t}\n\n\t/* Write back the LEB atomically */\n\terr = ubifs_leb_change(c, lnum, sbuf, len);\n\tif (err)\n\t\treturn err;\n\n\tdbg_rcvry(\"cleaned LEB %d\", lnum);\n\n\treturn 0;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "_inl_heads(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/recovery.c",
    "lines": "966-983",
    "snippet": "over_inl_heads(struct ubifs_info *c, void *sbuf)\n{\n\tint err;\n\n\tubifs_assert(!c->ro_mount || c->remounting_rw);\n\n\tdbg_rcvry(\"checking index head at %d:%d\", c->ihead_lnum, c->ihead_offs);\n\terr = recover_head(c, c->ihead_lnum, c->ihead_offs, sbuf);\n\tif (err)\n\t\treturn err;\n\n\tdbg_rcvry(\"checking LPT head at %d:%d\", c->nhead_lnum, c->nhead_offs);\n\terr = recover_head(c, c->nhead_lnum, c->nhead_offs, sbuf);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\n/**\n * clea",
    "includes": [
      "fs.h\"\n\n/**\n * is_em",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "c, c->nhead_",
          "args": [
            "n",
            ", c->nhead_of",
            ", sbuf);\n\tif",
            "rr)"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecking LP",
          "args": [
            "head at %d:%d\", c->nhead_ln",
            ", c->nhead_of",
            ");\n\terr = rec"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c, c->ihead_",
          "args": [
            "n",
            ", c->ihead_of",
            ", sbuf);\n\tif",
            "rr)"
          ],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecking in",
          "args": [
            "ex head at %d:%d\", c->ihead_ln",
            ", c->ihead_of",
            ");\n\terr = rec"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!c->ro_mount",
          "args": [
            "|| c->remounting_rw);\n\n\tdbg_rcvr"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * is_em\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nover_inl_heads(struct ubifs_info *c, void *sbuf)\n{\n\tint err;\n\n\tubifs_assert(!c->ro_mount || c->remounting_rw);\n\n\tdbg_rcvry(\"checking index head at %d:%d\", c->ihead_lnum, c->ihead_offs);\n\terr = recover_head(c, c->ihead_lnum, c->ihead_offs, sbuf);\n\tif (err)\n\t\treturn err;\n\n\tdbg_rcvry(\"checking LPT head at %d:%d\", c->nhead_lnum, c->nhead_offs);\n\terr = recover_head(c, c->nhead_lnum, c->nhead_offs, sbuf);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\n/**\n * clea"
  },
  {
    "function_name": "struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/recovery.c",
    "lines": "924-947",
    "snippet": "cover_head(struct ubifs_info *c, int lnum, int offs, void *sbuf)\n{\n\tint len = c->max_write_size, err;\n\n\tif (offs + len > c->leb_size)\n\t\tlen = c->leb_size - offs;\n\n\tif (!len)\n\t\treturn 0;\n\n\t/* Read at the head location and check it is empty flash */\n\terr = ubifs_leb_read(c, lnum, sbuf, offs, len, 1);\n\tif (err || !is_empty(sbuf, len)) {\n\t\tdbg_rcvry(\"cleaning head at %d:%d\", lnum, offs);\n\t\tif (offs == 0)\n\t\t\treturn ubifs_leb_unmap(c, lnum);\n\t\terr = ubifs_leb_read(c, lnum, sbuf, 0, offs, 1);\n\t\tif (err)\n\t\t\treturn err;\n\t\treturn ubifs_leb_change(c, lnum, sbuf, offs);\n\t}\n\n\treturn 0;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/**\n * is_em",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nge(c, lnum, sbu",
          "args": [
            ",",
            "ffs)",
            "}",
            "etur"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d(c, lnum, sbu",
          "args": [
            ",",
            ", of",
            ", 1)",
            "f (e",
            ")"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ap(c, lnum);",
          "args": [
            "r",
            "= ub"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eaning he",
          "args": [
            "d at %d:%d\", lnum, offs)",
            "if",
            "offs"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ", len))",
          "args": [
            "d",
            "_rc"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d(c, lnum, sbu",
          "args": [
            ",",
            "ffs,",
            "en,",
            ";\n\ti",
            "(er",
            "|"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * is_em\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\ncover_head(struct ubifs_info *c, int lnum, int offs, void *sbuf)\n{\n\tint len = c->max_write_size, err;\n\n\tif (offs + len > c->leb_size)\n\t\tlen = c->leb_size - offs;\n\n\tif (!len)\n\t\treturn 0;\n\n\t/* Read at the head location and check it is empty flash */\n\terr = ubifs_leb_read(c, lnum, sbuf, offs, len, 1);\n\tif (err || !is_empty(sbuf, len)) {\n\t\tdbg_rcvry(\"cleaning head at %d:%d\", lnum, offs);\n\t\tif (offs == 0)\n\t\t\treturn ubifs_leb_unmap(c, lnum);\n\t\terr = ubifs_leb_read(c, lnum, sbuf, 0, offs, 1);\n\t\tif (err)\n\t\t\treturn err;\n\t\treturn ubifs_leb_change(c, lnum, sbuf, offs);\n\t}\n\n\treturn 0;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "_log_leb(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/recovery.c",
    "lines": "868-911",
    "snippet": "scan_leb *ubifs_recover_log_leb(struct ubifs_info *c, int lnum,\n\t\t\t\t\t     int offs, void *sbuf)\n{\n\tstruct ubifs_scan_leb *sleb;\n\tint next_lnum;\n\n\tdbg_rcvry(\"LEB %d\", lnum);\n\tnext_lnum = lnum + 1;\n\tif (next_lnum >= UBIFS_LOG_LNUM + c->log_lebs)\n\t\tnext_lnum = UBIFS_LOG_LNUM;\n\tif (next_lnum != c->ltail_lnum) {\n\t\t/*\n\t\t * We can only recover at the end of the log, so check that the\n\t\t * next log LEB is empty or out of date.\n\t\t */\n\t\tsleb = ubifs_scan(c, next_lnum, 0, sbuf, 0);\n\t\tif (IS_ERR(sleb))\n\t\t\treturn sleb;\n\t\tif (sleb->nodes_cnt) {\n\t\t\tstruct ubifs_scan_node *snod;\n\t\t\tunsigned long long cs_sqnum = c->cs_sqnum;\n\n\t\t\tsnod = list_entry(sleb->nodes.next,\n\t\t\t\t\t  struct ubifs_scan_node, list);\n\t\t\tif (cs_sqnum == 0) {\n\t\t\t\tint err;\n\n\t\t\t\terr = get_cs_sqnum(c, lnum, offs, &cs_sqnum);\n\t\t\t\tif (err) {\n\t\t\t\t\tubifs_scan_destroy(sleb);\n\t\t\t\t\treturn ERR_PTR(err);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (snod->sqnum > cs_sqnum) {\n\t\t\t\tubifs_err(\"unrecoverable log corruption in LEB %d\",\n\t\t\t\t\t  lnum);\n\t\t\t\tubifs_scan_destroy(sleb);\n\t\t\t\treturn ERR_PTR(-EUCLEAN);\n\t\t\t}\n\t\t}\n\t\tubifs_scan_destroy(sleb);\n\t}\n\treturn ubifs_recover_leb(c, lnum, offs, sbuf, -1);\n}\n\n/**\n * reco",
    "includes": [
      "fs.h\"\n\n/**\n * is_em",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leb(c, lnum, off",
          "args": [
            ",",
            "buf,",
            "1);",
            "/**",
            "*"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stroy(sleb);\n\t}\n\tr",
          "args": [
            "turn"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EAN);",
          "args": [
            "}\n\t\t}"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stroy(sleb);\n\t\t\t\tr",
          "args": [
            "turn"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recoverab",
          "args": [
            "e log corruption in LEB %d\",\n\t\t\t\t\t  lnum",
            "ifs_"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "}",
          "args": [
            "}"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stroy(sleb);",
          "args": [
            "etur"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c, lnum, off",
          "args": [
            ",",
            "cs_s",
            "um);",
            "if (er"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eb->nodes.",
          "args": [
            "ext,\n\t\t\t\t\t  stru",
            "scan_nde, list);\n\t\t\ti",
            "(cs_"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "re",
          "args": [
            "urn"
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "_size_tree(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/recovery.c",
          "lines": "1335-1346",
          "snippet": "stroy_size_tree(struct ubifs_info *c)\n{\n\tstruct size_entry *e, *n;\n\n\trbtree_postorder_for_each_entry_safe(e, n, &c->size_tree, rb) {\n\t\tif (e->inode)\n\t\t\tiput(e->inode);\n\t\tkfree(e);\n\t}\n\n\tc->size_tree = RB_ROOT;\n}\n\n/**\n * ubif",
          "includes": [
            "fs.h\"\n\n/**\n * is_em",
            "ux/slab.h>\n#include \"ubi",
            "ux/crc32.h>\n#include <lin"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\n/**\n * is_em\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nstroy_size_tree(struct ubifs_info *c)\n{\n\tstruct size_entry *e, *n;\n\n\trbtree_postorder_for_each_entry_safe(e, n, &c->size_tree, rb) {\n\t\tif (e->inode)\n\t\t\tiput(e->inode);\n\t\tkfree(e);\n\t}\n\n\tc->size_tree = RB_ROOT;\n}\n\n/**\n * ubif"
        }
      },
      {
        "call_info": {
          "callee": "next_lnum",
          "args": [
            "sbuf, 0)",
            "f (I",
            "E"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B %d\", ln",
          "args": [
            "m);\n\tnex",
            "lnum"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * is_em\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nscan_leb *ubifs_recover_log_leb(struct ubifs_info *c, int lnum,\n\t\t\t\t\t     int offs, void *sbuf)\n{\n\tstruct ubifs_scan_leb *sleb;\n\tint next_lnum;\n\n\tdbg_rcvry(\"LEB %d\", lnum);\n\tnext_lnum = lnum + 1;\n\tif (next_lnum >= UBIFS_LOG_LNUM + c->log_lebs)\n\t\tnext_lnum = UBIFS_LOG_LNUM;\n\tif (next_lnum != c->ltail_lnum) {\n\t\t/*\n\t\t * We can only recover at the end of the log, so check that the\n\t\t * next log LEB is empty or out of date.\n\t\t */\n\t\tsleb = ubifs_scan(c, next_lnum, 0, sbuf, 0);\n\t\tif (IS_ERR(sleb))\n\t\t\treturn sleb;\n\t\tif (sleb->nodes_cnt) {\n\t\t\tstruct ubifs_scan_node *snod;\n\t\t\tunsigned long long cs_sqnum = c->cs_sqnum;\n\n\t\t\tsnod = list_entry(sleb->nodes.next,\n\t\t\t\t\t  struct ubifs_scan_node, list);\n\t\t\tif (cs_sqnum == 0) {\n\t\t\t\tint err;\n\n\t\t\t\terr = get_cs_sqnum(c, lnum, offs, &cs_sqnum);\n\t\t\t\tif (err) {\n\t\t\t\t\tubifs_scan_destroy(sleb);\n\t\t\t\t\treturn ERR_PTR(err);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (snod->sqnum > cs_sqnum) {\n\t\t\t\tubifs_err(\"unrecoverable log corruption in LEB %d\",\n\t\t\t\t\t  lnum);\n\t\t\t\tubifs_scan_destroy(sleb);\n\t\t\t\treturn ERR_PTR(-EUCLEAN);\n\t\t\t}\n\t\t}\n\t\tubifs_scan_destroy(sleb);\n\t}\n\treturn ubifs_recover_leb(c, lnum, offs, sbuf, -1);\n}\n\n/**\n * reco"
  },
  {
    "function_name": "struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/recovery.c",
    "lines": "811-853",
    "snippet": "t_cs_sqnum(struct ubifs_info *c, int lnum, int offs,\n\t\t\tunsigned long long *cs_sqnum)\n{\n\tstruct ubifs_cs_node *cs_node = NULL;\n\tint err, ret;\n\n\tdbg_rcvry(\"at %d:%d\", lnum, offs);\n\tcs_node = kmalloc(UBIFS_CS_NODE_SZ, GFP_KERNEL);\n\tif (!cs_node)\n\t\treturn -ENOMEM;\n\tif (c->leb_size - offs < UBIFS_CS_NODE_SZ)\n\t\tgoto out_err;\n\terr = ubifs_leb_read(c, lnum, (void *)cs_node, offs,\n\t\t\t     UBIFS_CS_NODE_SZ, 0);\n\tif (err && err != -EBADMSG)\n\t\tgoto out_free;\n\tret = ubifs_scan_a_node(c, cs_node, UBIFS_CS_NODE_SZ, lnum, offs, 0);\n\tif (ret != SCANNED_A_NODE) {\n\t\tubifs_err(\"Not a valid node\");\n\t\tgoto out_err;\n\t}\n\tif (cs_node->ch.node_type != UBIFS_CS_NODE) {\n\t\tubifs_err(\"Node a CS node, type is %d\", cs_node->ch.node_type);\n\t\tgoto out_err;\n\t}\n\tif (le64_to_cpu(cs_node->cmt_no) != c->cmt_no) {\n\t\tubifs_err(\"CS node cmt_no %llu != current cmt_no %llu\",\n\t\t\t  (unsigned long long)le64_to_cpu(cs_node->cmt_no),\n\t\t\t  c->cmt_no);\n\t\tgoto out_err;\n\t}\n\t*cs_sqnum = le64_to_cpu(cs_node->ch.sqnum);\n\tdbg_rcvry(\"commit start sqnum %llu\", *cs_sqnum);\n\tkfree(cs_node);\n\treturn 0;\n\nout_err:\n\terr = -EINVAL;\nout_free:\n\tubifs_err(\"failed to get CS sqnum\");\n\tkfree(cs_node);\n\treturn err;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/**\n * is_em",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": ");\n\tr",
          "args": [
            "turn er"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iled to g",
          "args": [
            "t CS sqnum\");\n\tkfree(cs_"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\tr",
          "args": [
            "turn 0;"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmit star",
          "args": [
            "sqnum %llu\", *cs_sqnum);",
            "kfree(cs_"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s_node->ch.",
          "args": [
            "qnum);\n\tdbg_rcvry"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node cmt",
          "args": [
            "no %llu != current cmt_no %llu\",\n\t\t\t  (unsig",
            "g long)le64_to_cpu(cs_node->cmt_no),\n\t\t\t  c->cmt",
            "goto out"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s_node->cmt",
          "args": [
            "no),\n\t\t\t  c->cm"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "s_node->cmt",
          "args": [
            "no) != c->cmt_n"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de a CS n",
          "args": [
            "de, type is %d\", cs_node->ch",
            "ode_type);\n\t\tgoto out"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "t a valid",
          "args": [
            "node\");\n\t\tgoto out"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node(c, cs_node,",
          "args": [
            "B",
            "S_CS_NO",
            "_SZ, lnum, offs,",
            ");",
            "(re",
            "!"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d(c, lnum, (vo",
          "args": [
            "d",
            ")cs_",
            "de, offs,",
            "UBI",
            "_SZ, 0);\n\tif (er",
            "&"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_CS_NOD",
          "args": [
            "_SZ, GFP_KERNEL)",
            "if (!cs_n"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "%d:%d\",",
          "args": [
            "num, offs)",
            "cs_",
            "de ="
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * is_em\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nt_cs_sqnum(struct ubifs_info *c, int lnum, int offs,\n\t\t\tunsigned long long *cs_sqnum)\n{\n\tstruct ubifs_cs_node *cs_node = NULL;\n\tint err, ret;\n\n\tdbg_rcvry(\"at %d:%d\", lnum, offs);\n\tcs_node = kmalloc(UBIFS_CS_NODE_SZ, GFP_KERNEL);\n\tif (!cs_node)\n\t\treturn -ENOMEM;\n\tif (c->leb_size - offs < UBIFS_CS_NODE_SZ)\n\t\tgoto out_err;\n\terr = ubifs_leb_read(c, lnum, (void *)cs_node, offs,\n\t\t\t     UBIFS_CS_NODE_SZ, 0);\n\tif (err && err != -EBADMSG)\n\t\tgoto out_free;\n\tret = ubifs_scan_a_node(c, cs_node, UBIFS_CS_NODE_SZ, lnum, offs, 0);\n\tif (ret != SCANNED_A_NODE) {\n\t\tubifs_err(\"Not a valid node\");\n\t\tgoto out_err;\n\t}\n\tif (cs_node->ch.node_type != UBIFS_CS_NODE) {\n\t\tubifs_err(\"Node a CS node, type is %d\", cs_node->ch.node_type);\n\t\tgoto out_err;\n\t}\n\tif (le64_to_cpu(cs_node->cmt_no) != c->cmt_no) {\n\t\tubifs_err(\"CS node cmt_no %llu != current cmt_no %llu\",\n\t\t\t  (unsigned long long)le64_to_cpu(cs_node->cmt_no),\n\t\t\t  c->cmt_no);\n\t\tgoto out_err;\n\t}\n\t*cs_sqnum = le64_to_cpu(cs_node->ch.sqnum);\n\tdbg_rcvry(\"commit start sqnum %llu\", *cs_sqnum);\n\tkfree(cs_node);\n\treturn 0;\n\nout_err:\n\terr = -EINVAL;\nout_free:\n\tubifs_err(\"failed to get CS sqnum\");\n\tkfree(cs_node);\n\treturn err;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "_leb(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/recovery.c",
    "lines": "634-800",
    "snippet": "scan_leb *ubifs_recover_leb(struct ubifs_info *c, int lnum,\n\t\t\t\t\t int offs, void *sbuf, int jhead)\n{\n\tint ret = 0, err, len = c->leb_size - offs, start = offs, min_io_unit;\n\tint grouped = jhead == -1 ? 0 : c->jheads[jhead].grouped;\n\tstruct ubifs_scan_leb *sleb;\n\tvoid *buf = sbuf + offs;\n\n\tdbg_rcvry(\"%d:%d, jhead %d, grouped %d\", lnum, offs, jhead, grouped);\n\n\tsleb = ubifs_start_scan(c, lnum, offs, sbuf);\n\tif (IS_ERR(sleb))\n\t\treturn sleb;\n\n\tubifs_assert(len >= 8);\n\twhile (len >= 8) {\n\t\tdbg_scan(\"look at LEB %d:%d (%d bytes left)\",\n\t\t\t lnum, offs, len);\n\n\t\tcond_resched();\n\n\t\t/*\n\t\t * Scan quietly until there is an error from which we cannot\n\t\t * recover\n\t\t */\n\t\tret = ubifs_scan_a_node(c, buf, len, lnum, offs, 1);\n\t\tif (ret == SCANNED_A_NODE) {\n\t\t\t/* A valid node, and not a padding node */\n\t\t\tstruct ubifs_ch *ch = buf;\n\t\t\tint node_len;\n\n\t\t\terr = ubifs_add_snod(c, sleb, buf, offs);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\t\t\tnode_len = ALIGN(le32_to_cpu(ch->len), 8);\n\t\t\toffs += node_len;\n\t\t\tbuf += node_len;\n\t\t\tlen -= node_len;\n\t\t} else if (ret > 0) {\n\t\t\t/* Padding bytes or a valid padding node */\n\t\t\toffs += ret;\n\t\t\tbuf += ret;\n\t\t\tlen -= ret;\n\t\t} else if (ret == SCANNED_EMPTY_SPACE ||\n\t\t\t   ret == SCANNED_GARBAGE     ||\n\t\t\t   ret == SCANNED_A_BAD_PAD_NODE ||\n\t\t\t   ret == SCANNED_A_CORRUPT_NODE) {\n\t\t\tdbg_rcvry(\"found corruption (%d) at %d:%d\",\n\t\t\t\t  ret, lnum, offs);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tubifs_err(\"unexpected return value %d\", ret);\n\t\t\terr = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tif (ret == SCANNED_GARBAGE || ret == SCANNED_A_BAD_PAD_NODE) {\n\t\tif (!is_last_write(c, buf, offs))\n\t\t\tgoto corrupted_rescan;\n\t} else if (ret == SCANNED_A_CORRUPT_NODE) {\n\t\tif (!no_more_nodes(c, buf, len, lnum, offs))\n\t\t\tgoto corrupted_rescan;\n\t} else if (!is_empty(buf, len)) {\n\t\tif (!is_last_write(c, buf, offs)) {\n\t\t\tint corruption = first_non_ff(buf, len);\n\n\t\t\t/*\n\t\t\t * See header comment for this file for more\n\t\t\t * explanations about the reasons we have this check.\n\t\t\t */\n\t\t\tubifs_err(\"corrupt empty space LEB %d:%d, corruption starts at %d\",\n\t\t\t\t  lnum, offs, corruption);\n\t\t\t/* Make sure we dump interesting non-0xFF data */\n\t\t\toffs += corruption;\n\t\t\tbuf += corruption;\n\t\t\tgoto corrupted;\n\t\t}\n\t}\n\n\tmin_io_unit = round_down(offs, c->min_io_size);\n\tif (grouped)\n\t\t/*\n\t\t * If nodes are grouped, always drop the incomplete group at\n\t\t * the end.\n\t\t */\n\t\tdrop_last_group(sleb, &offs);\n\n\tif (jhead == GCHD) {\n\t\t/*\n\t\t * If this LEB belongs to the GC head then while we are in the\n\t\t * middle of the same min. I/O unit keep dropping nodes. So\n\t\t * basically, what we want is to make sure that the last min.\n\t\t * I/O unit where we saw the corruption is dropped completely\n\t\t * with all the uncorrupted nodes which may possibly sit there.\n\t\t *\n\t\t * In other words, let's name the min. I/O unit where the\n\t\t * corruption starts B, and the previous min. I/O unit A. The\n\t\t * below code tries to deal with a situation when half of B\n\t\t * contains valid nodes or the end of a valid node, and the\n\t\t * second half of B contains corrupted data or garbage. This\n\t\t * means that UBIFS had been writing to B just before the power\n\t\t * cut happened. I do not know how realistic is this scenario\n\t\t * that half of the min. I/O unit had been written successfully\n\t\t * and the other half not, but this is possible in our 'failure\n\t\t * mode emulation' infrastructure at least.\n\t\t *\n\t\t * So what is the problem, why we need to drop those nodes? Why\n\t\t * can't we just clean-up the second half of B by putting a\n\t\t * padding node there? We can, and this works fine with one\n\t\t * exception which was reproduced with power cut emulation\n\t\t * testing and happens extremely rarely.\n\t\t *\n\t\t * Imagine the file-system is full, we run GC which starts\n\t\t * moving valid nodes from LEB X to LEB Y (obviously, LEB Y is\n\t\t * the current GC head LEB). The @c->gc_lnum is -1, which means\n\t\t * that GC will retain LEB X and will try to continue. Imagine\n\t\t * that LEB X is currently the dirtiest LEB, and the amount of\n\t\t * used space in LEB Y is exactly the same as amount of free\n\t\t * space in LEB X.\n\t\t *\n\t\t * And a power cut happens when nodes are moved from LEB X to\n\t\t * LEB Y. We are here trying to recover LEB Y which is the GC\n\t\t * head LEB. We find the min. I/O unit B as described above.\n\t\t * Then we clean-up LEB Y by padding min. I/O unit. And later\n\t\t * 'ubifs_rcvry_gc_commit()' function fails, because it cannot\n\t\t * find a dirty LEB which could be GC'd into LEB Y! Even LEB X\n\t\t * does not match because the amount of valid nodes there does\n\t\t * not fit the free space in LEB Y any more! And this is\n\t\t * because of the padding node which we added to LEB Y. The\n\t\t * user-visible effect of this which I once observed and\n\t\t * analysed is that we cannot mount the file-system with\n\t\t * -ENOSPC error.\n\t\t *\n\t\t * So obviously, to make sure that situation does not happen we\n\t\t * should free min. I/O unit B in LEB Y completely and the last\n\t\t * used min. I/O unit in LEB Y should be A. This is basically\n\t\t * what the below code tries to do.\n\t\t */\n\t\twhile (offs > min_io_unit)\n\t\t\tdrop_last_node(sleb, &offs);\n\t}\n\n\tbuf = sbuf + offs;\n\tlen = c->leb_size - offs;\n\n\tclean_buf(c, &buf, lnum, &offs, &len);\n\tubifs_end_scan(c, sleb, lnum, offs);\n\n\terr = fix_unclean_leb(c, sleb, start);\n\tif (err)\n\t\tgoto error;\n\n\treturn sleb;\n\ncorrupted_rescan:\n\t/* Re-scan the corrupted data with verbose messages */\n\tubifs_err(\"corruption %d\", ret);\n\tubifs_scan_a_node(c, buf, len, lnum, offs, 1);\ncorrupted:\n\tubifs_scanned_corruption(c, lnum, offs, buf);\n\terr = -EUCLEAN;\nerror:\n\tubifs_err(\"LEB %d scanning failed\", lnum);\n\tubifs_scan_destroy(sleb);\n\treturn ERR_PTR(err);\n}\n\n/**\n * get_",
    "includes": [
      "fs.h\"\n\n/**\n * is_em",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "}\n\n/**",
          "args": [
            "*"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stroy(sleb);\n\tretu",
          "args": [
            "n ER"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "B %d scan",
          "args": [
            "ing failed\", lnum);\n\tubi",
            "_sca"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_corruption(c, lnum, off",
          "args": [
            ",",
            "uf);",
            "err",
            "-EU"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node(c, buf, len,",
          "args": [
            "l",
            "m,",
            "fs,",
            ");\nc",
            "rupt",
            ":"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rruption",
          "args": [
            "d\", ret);\n\tubif",
            "sca"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eb(c, sleb, sta",
          "args": [
            "t",
            "if",
            "err)"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n(c, sleb, lnu",
          "args": [
            ",",
            "ffs)",
            "er",
            "= fi"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "&buf, lnu",
          "args": [
            ",",
            "offs",
            "&len",
            "ubi",
            "_end"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e(sleb, &offs)",
          "args": [
            "}",
            "buf ="
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up(sleb, &offs)",
          "args": [
            "i",
            "(jhea"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fs, c->min",
          "args": [
            "io_s",
            "e);\n\tif (group"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rrupt emp",
          "args": [
            "y space LEB %d:%d, corruption starts at %d\",\n\t\t\t\t  lnum,",
            "orru",
            "ion)",
            "/* Make"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buf, len);",
          "args": [
            "/"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, buf, offs",
          "args": [
            ")",
            "nt c"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "len)) {",
          "args": [
            "i",
            "(!i"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, buf, len,",
          "args": [
            "l",
            "m,",
            "fs)",
            "g",
            "o co"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(c, buf, offs",
          "args": [
            ")",
            "g",
            "o co"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expected",
          "args": [
            "eturn value %d\", ret);\n\t\t\ter",
            "= -"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "und corru",
          "args": [
            "tion (%d) at %d:%d\",\n\t\t\t\t  ret,",
            "fs)",
            "b",
            "ak;"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_cpu(",
          "args": [
            "h->len), 8);\n\t\t\toffs",
            "="
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "h->len), 8)",
          "args": [
            "off"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d(c, sleb, buf",
          "args": [
            "fs);",
            "i",
            "(err"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node(c, buf, len,",
          "args": [
            "l",
            "m,",
            "fs,",
            ");",
            "f (r"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ");\n\n\t\t/*",
          "args": [],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "k at LEB",
          "args": [
            "%d:%d (%d bytes left)\",\n\t\t\t lnum, o",
            "en);",
            "co",
            "_re"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "len >= 8);",
          "args": [
            "hile (le"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ret",
          "args": [
            "rn s"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "retire_sysctl_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "1567-1570",
          "snippet": "void retire_sysctl_set(struct ctl_table_set *set)\n{\n\tWARN_ON(!RB_EMPTY_ROOT(&set->dir.root));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nvoid retire_sysctl_set(struct ctl_table_set *set)\n{\n\tWARN_ON(!RB_EMPTY_ROOT(&set->dir.root));\n}"
        }
      },
      {
        "call_info": {
          "callee": "can(c, lnum, off",
          "args": [
            ",",
            "buf)",
            "if",
            "S_ER"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": ":%d, jhea",
          "args": [
            "%d, grouped %d\", lnum, offs,",
            "head",
            "grou",
            "d);",
            "leb = u"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * is_em\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nscan_leb *ubifs_recover_leb(struct ubifs_info *c, int lnum,\n\t\t\t\t\t int offs, void *sbuf, int jhead)\n{\n\tint ret = 0, err, len = c->leb_size - offs, start = offs, min_io_unit;\n\tint grouped = jhead == -1 ? 0 : c->jheads[jhead].grouped;\n\tstruct ubifs_scan_leb *sleb;\n\tvoid *buf = sbuf + offs;\n\n\tdbg_rcvry(\"%d:%d, jhead %d, grouped %d\", lnum, offs, jhead, grouped);\n\n\tsleb = ubifs_start_scan(c, lnum, offs, sbuf);\n\tif (IS_ERR(sleb))\n\t\treturn sleb;\n\n\tubifs_assert(len >= 8);\n\twhile (len >= 8) {\n\t\tdbg_scan(\"look at LEB %d:%d (%d bytes left)\",\n\t\t\t lnum, offs, len);\n\n\t\tcond_resched();\n\n\t\t/*\n\t\t * Scan quietly until there is an error from which we cannot\n\t\t * recover\n\t\t */\n\t\tret = ubifs_scan_a_node(c, buf, len, lnum, offs, 1);\n\t\tif (ret == SCANNED_A_NODE) {\n\t\t\t/* A valid node, and not a padding node */\n\t\t\tstruct ubifs_ch *ch = buf;\n\t\t\tint node_len;\n\n\t\t\terr = ubifs_add_snod(c, sleb, buf, offs);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\t\t\tnode_len = ALIGN(le32_to_cpu(ch->len), 8);\n\t\t\toffs += node_len;\n\t\t\tbuf += node_len;\n\t\t\tlen -= node_len;\n\t\t} else if (ret > 0) {\n\t\t\t/* Padding bytes or a valid padding node */\n\t\t\toffs += ret;\n\t\t\tbuf += ret;\n\t\t\tlen -= ret;\n\t\t} else if (ret == SCANNED_EMPTY_SPACE ||\n\t\t\t   ret == SCANNED_GARBAGE     ||\n\t\t\t   ret == SCANNED_A_BAD_PAD_NODE ||\n\t\t\t   ret == SCANNED_A_CORRUPT_NODE) {\n\t\t\tdbg_rcvry(\"found corruption (%d) at %d:%d\",\n\t\t\t\t  ret, lnum, offs);\n\t\t\tbreak;\n\t\t} else {\n\t\t\tubifs_err(\"unexpected return value %d\", ret);\n\t\t\terr = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tif (ret == SCANNED_GARBAGE || ret == SCANNED_A_BAD_PAD_NODE) {\n\t\tif (!is_last_write(c, buf, offs))\n\t\t\tgoto corrupted_rescan;\n\t} else if (ret == SCANNED_A_CORRUPT_NODE) {\n\t\tif (!no_more_nodes(c, buf, len, lnum, offs))\n\t\t\tgoto corrupted_rescan;\n\t} else if (!is_empty(buf, len)) {\n\t\tif (!is_last_write(c, buf, offs)) {\n\t\t\tint corruption = first_non_ff(buf, len);\n\n\t\t\t/*\n\t\t\t * See header comment for this file for more\n\t\t\t * explanations about the reasons we have this check.\n\t\t\t */\n\t\t\tubifs_err(\"corrupt empty space LEB %d:%d, corruption starts at %d\",\n\t\t\t\t  lnum, offs, corruption);\n\t\t\t/* Make sure we dump interesting non-0xFF data */\n\t\t\toffs += corruption;\n\t\t\tbuf += corruption;\n\t\t\tgoto corrupted;\n\t\t}\n\t}\n\n\tmin_io_unit = round_down(offs, c->min_io_size);\n\tif (grouped)\n\t\t/*\n\t\t * If nodes are grouped, always drop the incomplete group at\n\t\t * the end.\n\t\t */\n\t\tdrop_last_group(sleb, &offs);\n\n\tif (jhead == GCHD) {\n\t\t/*\n\t\t * If this LEB belongs to the GC head then while we are in the\n\t\t * middle of the same min. I/O unit keep dropping nodes. So\n\t\t * basically, what we want is to make sure that the last min.\n\t\t * I/O unit where we saw the corruption is dropped completely\n\t\t * with all the uncorrupted nodes which may possibly sit there.\n\t\t *\n\t\t * In other words, let's name the min. I/O unit where the\n\t\t * corruption starts B, and the previous min. I/O unit A. The\n\t\t * below code tries to deal with a situation when half of B\n\t\t * contains valid nodes or the end of a valid node, and the\n\t\t * second half of B contains corrupted data or garbage. This\n\t\t * means that UBIFS had been writing to B just before the power\n\t\t * cut happened. I do not know how realistic is this scenario\n\t\t * that half of the min. I/O unit had been written successfully\n\t\t * and the other half not, but this is possible in our 'failure\n\t\t * mode emulation' infrastructure at least.\n\t\t *\n\t\t * So what is the problem, why we need to drop those nodes? Why\n\t\t * can't we just clean-up the second half of B by putting a\n\t\t * padding node there? We can, and this works fine with one\n\t\t * exception which was reproduced with power cut emulation\n\t\t * testing and happens extremely rarely.\n\t\t *\n\t\t * Imagine the file-system is full, we run GC which starts\n\t\t * moving valid nodes from LEB X to LEB Y (obviously, LEB Y is\n\t\t * the current GC head LEB). The @c->gc_lnum is -1, which means\n\t\t * that GC will retain LEB X and will try to continue. Imagine\n\t\t * that LEB X is currently the dirtiest LEB, and the amount of\n\t\t * used space in LEB Y is exactly the same as amount of free\n\t\t * space in LEB X.\n\t\t *\n\t\t * And a power cut happens when nodes are moved from LEB X to\n\t\t * LEB Y. We are here trying to recover LEB Y which is the GC\n\t\t * head LEB. We find the min. I/O unit B as described above.\n\t\t * Then we clean-up LEB Y by padding min. I/O unit. And later\n\t\t * 'ubifs_rcvry_gc_commit()' function fails, because it cannot\n\t\t * find a dirty LEB which could be GC'd into LEB Y! Even LEB X\n\t\t * does not match because the amount of valid nodes there does\n\t\t * not fit the free space in LEB Y any more! And this is\n\t\t * because of the padding node which we added to LEB Y. The\n\t\t * user-visible effect of this which I once observed and\n\t\t * analysed is that we cannot mount the file-system with\n\t\t * -ENOSPC error.\n\t\t *\n\t\t * So obviously, to make sure that situation does not happen we\n\t\t * should free min. I/O unit B in LEB Y completely and the last\n\t\t * used min. I/O unit in LEB Y should be A. This is basically\n\t\t * what the below code tries to do.\n\t\t */\n\t\twhile (offs > min_io_unit)\n\t\t\tdrop_last_node(sleb, &offs);\n\t}\n\n\tbuf = sbuf + offs;\n\tlen = c->leb_size - offs;\n\n\tclean_buf(c, &buf, lnum, &offs, &len);\n\tubifs_end_scan(c, sleb, lnum, offs);\n\n\terr = fix_unclean_leb(c, sleb, start);\n\tif (err)\n\t\tgoto error;\n\n\treturn sleb;\n\ncorrupted_rescan:\n\t/* Re-scan the corrupted data with verbose messages */\n\tubifs_err(\"corruption %d\", ret);\n\tubifs_scan_a_node(c, buf, len, lnum, offs, 1);\ncorrupted:\n\tubifs_scanned_corruption(c, lnum, offs, buf);\n\terr = -EUCLEAN;\nerror:\n\tubifs_err(\"LEB %d scanning failed\", lnum);\n\tubifs_scan_destroy(sleb);\n\treturn ERR_PTR(err);\n}\n\n/**\n * get_"
  },
  {
    "function_name": "e(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/recovery.c",
    "lines": "603-618",
    "snippet": "rop_last_node(struct ubifs_scan_leb *sleb, int *offs)\n{\n\tstruct ubifs_scan_node *snod;\n\n\tif (!list_empty(&sleb->nodes)) {\n\t\tsnod = list_entry(sleb->nodes.prev, struct ubifs_scan_node,\n\t\t\t\t  list);\n\n\t\tdbg_rcvry(\"dropping last node at %d:%d\",\n\t\t\t  sleb->lnum, snod->offs);\n\t\t*offs = snod->offs;\n\t\tlist_del(&snod->list);\n\t\tkfree(snod);\n\t\tsleb->nodes_cnt -= 1;\n\t}\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/**\n * is_em",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sle",
          "args": [
            "->no"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sleep_on_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "388-401",
          "snippet": "static void inode_sleep_on_writeback(struct inode *inode)\n\t__releases(inode->i_lock)\n{\n\tDEFINE_WAIT(wait);\n\twait_queue_head_t *wqh = bit_waitqueue(&inode->i_state, __I_SYNC);\n\tint sleep;\n\n\tprepare_to_wait(wqh, &wait, TASK_UNINTERRUPTIBLE);\n\tsleep = inode->i_state & I_SYNC;\n\tspin_unlock(&inode->i_lock);\n\tif (sleep)\n\t\tschedule();\n\tfinish_wait(wqh, &wait);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void inode_sleep_on_writeback(struct inode *inode)\n\t__releases(inode->i_lock)\n{\n\tDEFINE_WAIT(wait);\n\twait_queue_head_t *wqh = bit_waitqueue(&inode->i_state, __I_SYNC);\n\tint sleep;\n\n\tprepare_to_wait(wqh, &wait, TASK_UNINTERRUPTIBLE);\n\tsleep = inode->i_state & I_SYNC;\n\tspin_unlock(&inode->i_lock);\n\tif (sleep)\n\t\tschedule();\n\tfinish_wait(wqh, &wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d->list)",
          "args": [
            "kfree(sn"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opping la",
          "args": [
            "t node at %d:%d\",\n\t\t\t  sleb->",
            "nod->offs)",
            "*offs ="
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eb->nodes.",
          "args": [
            "rev, struct ubif",
            "scan_nde,\n\t\t\t\t  list)",
            "_rcv"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "leb->nodes",
          "args": [
            ") {\n\t\tsnod ="
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * is_em\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nrop_last_node(struct ubifs_scan_leb *sleb, int *offs)\n{\n\tstruct ubifs_scan_node *snod;\n\n\tif (!list_empty(&sleb->nodes)) {\n\t\tsnod = list_entry(sleb->nodes.prev, struct ubifs_scan_node,\n\t\t\t\t  list);\n\n\t\tdbg_rcvry(\"dropping last node at %d:%d\",\n\t\t\t  sleb->lnum, snod->offs);\n\t\t*offs = snod->offs;\n\t\tlist_del(&snod->list);\n\t\tkfree(snod);\n\t\tsleb->nodes_cnt -= 1;\n\t}\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "up(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/recovery.c",
    "lines": "574-593",
    "snippet": "rop_last_group(struct ubifs_scan_leb *sleb, int *offs)\n{\n\twhile (!list_empty(&sleb->nodes)) {\n\t\tstruct ubifs_scan_node *snod;\n\t\tstruct ubifs_ch *ch;\n\n\t\tsnod = list_entry(sleb->nodes.prev, struct ubifs_scan_node,\n\t\t\t\t  list);\n\t\tch = snod->node;\n\t\tif (ch->group_type != UBIFS_IN_NODE_GROUP)\n\t\t\tbreak;\n\n\t\tdbg_rcvry(\"dropping grouped node at %d:%d\",\n\t\t\t  sleb->lnum, snod->offs);\n\t\t*offs = snod->offs;\n\t\tlist_del(&snod->list);\n\t\tkfree(snod);\n\t\tsleb->nodes_cnt -= 1;\n\t}\n}\n\n/**\n * drop",
    "includes": [
      "fs.h\"\n\n/**\n * is_em",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sle",
          "args": [
            "->no"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "inode_sleep_on_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "388-401",
          "snippet": "static void inode_sleep_on_writeback(struct inode *inode)\n\t__releases(inode->i_lock)\n{\n\tDEFINE_WAIT(wait);\n\twait_queue_head_t *wqh = bit_waitqueue(&inode->i_state, __I_SYNC);\n\tint sleep;\n\n\tprepare_to_wait(wqh, &wait, TASK_UNINTERRUPTIBLE);\n\tsleep = inode->i_state & I_SYNC;\n\tspin_unlock(&inode->i_lock);\n\tif (sleep)\n\t\tschedule();\n\tfinish_wait(wqh, &wait);\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic void inode_sleep_on_writeback(struct inode *inode)\n\t__releases(inode->i_lock)\n{\n\tDEFINE_WAIT(wait);\n\twait_queue_head_t *wqh = bit_waitqueue(&inode->i_state, __I_SYNC);\n\tint sleep;\n\n\tprepare_to_wait(wqh, &wait, TASK_UNINTERRUPTIBLE);\n\tsleep = inode->i_state & I_SYNC;\n\tspin_unlock(&inode->i_lock);\n\tif (sleep)\n\t\tschedule();\n\tfinish_wait(wqh, &wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d->list)",
          "args": [
            "kfree(sn"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opping gr",
          "args": [
            "uped node at %d:%d\",\n\t\t\t  sleb->",
            "nod->offs)",
            "*offs ="
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eb->nodes.",
          "args": [
            "rev, struct ubif",
            "scan_nde,\n\t\t\t\t  list)",
            "sno"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "leb->nodes",
          "args": [
            ") {\n\t\tstruct"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * is_em\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nrop_last_group(struct ubifs_scan_leb *sleb, int *offs)\n{\n\twhile (!list_empty(&sleb->nodes)) {\n\t\tstruct ubifs_scan_node *snod;\n\t\tstruct ubifs_ch *ch;\n\n\t\tsnod = list_entry(sleb->nodes.prev, struct ubifs_scan_node,\n\t\t\t\t  list);\n\t\tch = snod->node;\n\t\tif (ch->group_type != UBIFS_IN_NODE_GROUP)\n\t\t\tbreak;\n\n\t\tdbg_rcvry(\"dropping grouped node at %d:%d\",\n\t\t\t  sleb->lnum, snod->offs);\n\t\t*offs = snod->offs;\n\t\tlist_del(&snod->list);\n\t\tkfree(snod);\n\t\tsleb->nodes_cnt -= 1;\n\t}\n}\n\n/**\n * drop"
  },
  {
    "function_name": "eb(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/recovery.c",
    "lines": "503-564",
    "snippet": "x_unclean_leb(struct ubifs_info *c, struct ubifs_scan_leb *sleb,\n\t\t\t   int start)\n{\n\tint lnum = sleb->lnum, endpt = start;\n\n\t/* Get the end offset of the last node we are keeping */\n\tif (!list_empty(&sleb->nodes)) {\n\t\tstruct ubifs_scan_node *snod;\n\n\t\tsnod = list_entry(sleb->nodes.prev,\n\t\t\t\t  struct ubifs_scan_node, list);\n\t\tendpt = snod->offs + snod->len;\n\t}\n\n\tif (c->ro_mount && !c->remounting_rw) {\n\t\t/* Add to recovery list */\n\t\tstruct ubifs_unclean_leb *ucleb;\n\n\t\tdbg_rcvry(\"need to fix LEB %d start %d endpt %d\",\n\t\t\t  lnum, start, sleb->endpt);\n\t\tucleb = kzalloc(sizeof(struct ubifs_unclean_leb), GFP_NOFS);\n\t\tif (!ucleb)\n\t\t\treturn -ENOMEM;\n\t\tucleb->lnum = lnum;\n\t\tucleb->endpt = endpt;\n\t\tlist_add_tail(&ucleb->list, &c->unclean_leb_list);\n\t} else {\n\t\t/* Write the fixed LEB back to flash */\n\t\tint err;\n\n\t\tdbg_rcvry(\"fixing LEB %d start %d endpt %d\",\n\t\t\t  lnum, start, sleb->endpt);\n\t\tif (endpt == 0) {\n\t\t\terr = ubifs_leb_unmap(c, lnum);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\tint len = ALIGN(endpt, c->min_io_size);\n\n\t\t\tif (start) {\n\t\t\t\terr = ubifs_leb_read(c, lnum, sleb->buf, 0,\n\t\t\t\t\t\t     start, 1);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t\t/* Pad to min_io_size */\n\t\t\tif (len > endpt) {\n\t\t\t\tint pad_len = len - ALIGN(endpt, 8);\n\n\t\t\t\tif (pad_len > 0) {\n\t\t\t\t\tvoid *buf = sleb->buf + len - pad_len;\n\n\t\t\t\t\tubifs_pad(c, buf, pad_len);\n\t\t\t\t}\n\t\t\t}\n\t\t\terr = ubifs_leb_change(c, lnum, sleb->buf, len);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/**\n * drop",
    "includes": [
      "fs.h\"\n\n/**\n * is_em",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nge(c, lnum, sle",
          "args": [
            "-",
            "uf,",
            "n);\n\t\t\tif",
            "err"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buf, pad_",
          "args": [
            "e",
            ";",
            "}\n\t\t\t}"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "8);",
          "args": [
            "if",
            "p"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d(c, lnum, sle",
          "args": [
            "-",
            "uf,",
            "if",
            "r"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->mi",
          "args": [
            "_io_s",
            "e);\n\n\t\t\tif (st"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ap(c, lnum);",
          "args": [
            "i",
            "(err"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xing LEB",
          "args": [
            "d start %d endpt %d\",\n\t\t\t  lnum,",
            "sleb",
            "endpt",
            "if (endp"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "(&ucleb->list",
          "args": [
            "&c->unclean",
            "eb_list);\n\t} else {"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "f(struc",
          "args": [
            "ubifs_unclean_leb), GFP_NOFS);",
            "if (!ucl"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "f(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/log.c",
          "lines": "71-96",
          "snippet": "wbuf *ubifs_get_wbuf(struct ubifs_info *c, int lnum)\n{\n\tstruct rb_node *p;\n\tstruct ubifs_bud *bud;\n\tint jhead;\n\n\tif (!c->jheads)\n\t\treturn NULL;\n\n\tspin_lock(&c->buds_lock);\n\tp = c->buds.rb_node;\n\twhile (p) {\n\t\tbud = rb_entry(p, struct ubifs_bud, rb);\n\t\tif (lnum < bud->lnum)\n\t\t\tp = p->rb_left;\n\t\telse if (lnum > bud->lnum)\n\t\t\tp = p->rb_right;\n\t\telse {\n\t\t\tjhead = bud->jhead;\n\t\t\tspin_unlock(&c->buds_lock);\n\t\t\treturn &c->jheads[jhead].wbuf;\n\t\t}\n\t}\n\tspin_unlock(&c->buds_lock);\n\treturn NULL;\n}\n\n/**\n * empt",
          "includes": [
            "fs.h\"\n\nstatic int d"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "fs.h\"\n\nstatic int d\n\nwbuf *ubifs_get_wbuf(struct ubifs_info *c, int lnum)\n{\n\tstruct rb_node *p;\n\tstruct ubifs_bud *bud;\n\tint jhead;\n\n\tif (!c->jheads)\n\t\treturn NULL;\n\n\tspin_lock(&c->buds_lock);\n\tp = c->buds.rb_node;\n\twhile (p) {\n\t\tbud = rb_entry(p, struct ubifs_bud, rb);\n\t\tif (lnum < bud->lnum)\n\t\t\tp = p->rb_left;\n\t\telse if (lnum > bud->lnum)\n\t\t\tp = p->rb_right;\n\t\telse {\n\t\t\tjhead = bud->jhead;\n\t\t\tspin_unlock(&c->buds_lock);\n\t\t\treturn &c->jheads[jhead].wbuf;\n\t\t}\n\t}\n\tspin_unlock(&c->buds_lock);\n\treturn NULL;\n}\n\n/**\n * empt"
        }
      },
      {
        "call_info": {
          "callee": "ed to fix",
          "args": [
            "LEB %d start %d endpt %d\",\n\t\t\t  lnum,",
            "sleb",
            "endpt",
            "ucleb ="
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eb->nodes.",
          "args": [
            "rev,\n\t\t\t\t  struc",
            "scan_nde, list);\n\t\ten",
            "t ="
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "leb->nodes",
          "args": [
            ") {\n\t\tstruct"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * is_em\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nx_unclean_leb(struct ubifs_info *c, struct ubifs_scan_leb *sleb,\n\t\t\t   int start)\n{\n\tint lnum = sleb->lnum, endpt = start;\n\n\t/* Get the end offset of the last node we are keeping */\n\tif (!list_empty(&sleb->nodes)) {\n\t\tstruct ubifs_scan_node *snod;\n\n\t\tsnod = list_entry(sleb->nodes.prev,\n\t\t\t\t  struct ubifs_scan_node, list);\n\t\tendpt = snod->offs + snod->len;\n\t}\n\n\tif (c->ro_mount && !c->remounting_rw) {\n\t\t/* Add to recovery list */\n\t\tstruct ubifs_unclean_leb *ucleb;\n\n\t\tdbg_rcvry(\"need to fix LEB %d start %d endpt %d\",\n\t\t\t  lnum, start, sleb->endpt);\n\t\tucleb = kzalloc(sizeof(struct ubifs_unclean_leb), GFP_NOFS);\n\t\tif (!ucleb)\n\t\t\treturn -ENOMEM;\n\t\tucleb->lnum = lnum;\n\t\tucleb->endpt = endpt;\n\t\tlist_add_tail(&ucleb->list, &c->unclean_leb_list);\n\t} else {\n\t\t/* Write the fixed LEB back to flash */\n\t\tint err;\n\n\t\tdbg_rcvry(\"fixing LEB %d start %d endpt %d\",\n\t\t\t  lnum, start, sleb->endpt);\n\t\tif (endpt == 0) {\n\t\t\terr = ubifs_leb_unmap(c, lnum);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\tint len = ALIGN(endpt, c->min_io_size);\n\n\t\t\tif (start) {\n\t\t\t\terr = ubifs_leb_read(c, lnum, sleb->buf, 0,\n\t\t\t\t\t\t     start, 1);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t\t/* Pad to min_io_size */\n\t\t\tif (len > endpt) {\n\t\t\t\tint pad_len = len - ALIGN(endpt, 8);\n\n\t\t\t\tif (pad_len > 0) {\n\t\t\t\t\tvoid *buf = sleb->buf + len - pad_len;\n\n\t\t\t\t\tubifs_pad(c, buf, pad_len);\n\t\t\t\t}\n\t\t\t}\n\t\t\terr = ubifs_leb_change(c, lnum, sleb->buf, len);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/**\n * drop"
  },
  {
    "function_name": "(const struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/recovery.c",
    "lines": "470-495",
    "snippet": "_more_nodes(const struct ubifs_info *c, void *buf, int len,\n\t\t\tint lnum, int offs)\n{\n\tstruct ubifs_ch *ch = buf;\n\tint skip, dlen = le32_to_cpu(ch->len);\n\n\t/* Check for empty space after the corrupt node's common header */\n\tskip = ALIGN(offs + UBIFS_CH_SZ, c->max_write_size) - offs;\n\tif (is_empty(buf + skip, len - skip))\n\t\treturn 1;\n\t/*\n\t * The area after the common header size is not empty, so the common\n\t * header must be intact. Check it.\n\t */\n\tif (ubifs_check_node(c, buf, lnum, offs, 1, 0) != -EUCLEAN) {\n\t\tdbg_rcvry(\"unexpected bad common header at %d:%d\", lnum, offs);\n\t\treturn 0;\n\t}\n\t/* Now we know the corrupt node's length we can skip over it */\n\tskip = ALIGN(offs + dlen, c->max_write_size) - offs;\n\t/* After which there should be empty space */\n\tif (is_empty(buf + skip, len - skip))\n\t\treturn 1;\n\tdbg_rcvry(\"unexpected data at %d:%d\", lnum, offs + skip);\n\treturn 0;\n}\n\n/**\n * fix_",
    "includes": [
      "fs.h\"\n\n/**\n * is_em",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "expected",
          "args": [
            "ata at %d:%d\", lnum, offs",
            "skip",
            "return 0;"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "fscache_report_unexpected_submission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fscache/operation.c",
          "lines": "144-176",
          "snippet": "static void fscache_report_unexpected_submission(struct fscache_object *object,\n\t\t\t\t\t\t struct fscache_operation *op,\n\t\t\t\t\t\t const struct fscache_state *ostate)\n{\n\tstatic bool once_only;\n\tstruct fscache_operation *p;\n\tunsigned n;\n\n\tif (once_only)\n\t\treturn;\n\tonce_only = true;\n\n\tkdebug(\"unexpected submission OP%x [OBJ%x %s]\",\n\t       op->debug_id, object->debug_id, object->state->name);\n\tkdebug(\"objstate=%s [%s]\", object->state->name, ostate->name);\n\tkdebug(\"objflags=%lx\", object->flags);\n\tkdebug(\"objevent=%lx [%lx]\", object->events, object->event_mask);\n\tkdebug(\"ops=%u inp=%u exc=%u\",\n\t       object->n_ops, object->n_in_progress, object->n_exclusive);\n\n\tif (!list_empty(&object->pending_ops)) {\n\t\tn = 0;\n\t\tlist_for_each_entry(p, &object->pending_ops, pend_link) {\n\t\t\tASSERTCMP(p->object, ==, object);\n\t\t\tkdebug(\"%p %p\", op->processor, op->release);\n\t\t\tn++;\n\t\t}\n\n\t\tkdebug(\"n=%u\", n);\n\t}\n\n\tdump_stack();\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n\nstatic void fscache_report_unexpected_submission(struct fscache_object *object,\n\t\t\t\t\t\t struct fscache_operation *op,\n\t\t\t\t\t\t const struct fscache_state *ostate)\n{\n\tstatic bool once_only;\n\tstruct fscache_operation *p;\n\tunsigned n;\n\n\tif (once_only)\n\t\treturn;\n\tonce_only = true;\n\n\tkdebug(\"unexpected submission OP%x [OBJ%x %s]\",\n\t       op->debug_id, object->debug_id, object->state->name);\n\tkdebug(\"objstate=%s [%s]\", object->state->name, ostate->name);\n\tkdebug(\"objflags=%lx\", object->flags);\n\tkdebug(\"objevent=%lx [%lx]\", object->events, object->event_mask);\n\tkdebug(\"ops=%u inp=%u exc=%u\",\n\t       object->n_ops, object->n_in_progress, object->n_exclusive);\n\n\tif (!list_empty(&object->pending_ops)) {\n\t\tn = 0;\n\t\tlist_for_each_entry(p, &object->pending_ops, pend_link) {\n\t\t\tASSERTCMP(p->object, ==, object);\n\t\t\tkdebug(\"%p %p\", op->processor, op->release);\n\t\t\tn++;\n\t\t}\n\n\t\tkdebug(\"n=%u\", n);\n\t}\n\n\tdump_stack();\n}"
        }
      },
      {
        "call_info": {
          "callee": "+ skip,",
          "args": [
            "en - skip)",
            "return 1"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dlen,",
          "args": [
            "c->max_writ",
            "size) - offs;\n\t/*"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ode(c, buf, lnum",
          "args": [
            "fs,",
            ", 0)",
            "= -E",
            "L",
            "N"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "+ skip,",
          "args": [
            "en - skip)",
            "return 1"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "UBIFS",
          "args": [
            "CH_SZ, c->max_writ",
            "size) - offs;\n\tif"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "h->len);",
          "args": [
            "* Check"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * is_em\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\n_more_nodes(const struct ubifs_info *c, void *buf, int len,\n\t\t\tint lnum, int offs)\n{\n\tstruct ubifs_ch *ch = buf;\n\tint skip, dlen = le32_to_cpu(ch->len);\n\n\t/* Check for empty space after the corrupt node's common header */\n\tskip = ALIGN(offs + UBIFS_CH_SZ, c->max_write_size) - offs;\n\tif (is_empty(buf + skip, len - skip))\n\t\treturn 1;\n\t/*\n\t * The area after the common header size is not empty, so the common\n\t * header must be intact. Check it.\n\t */\n\tif (ubifs_check_node(c, buf, lnum, offs, 1, 0) != -EUCLEAN) {\n\t\tdbg_rcvry(\"unexpected bad common header at %d:%d\", lnum, offs);\n\t\treturn 0;\n\t}\n\t/* Now we know the corrupt node's length we can skip over it */\n\tskip = ALIGN(offs + dlen, c->max_write_size) - offs;\n\t/* After which there should be empty space */\n\tif (is_empty(buf + skip, len - skip))\n\t\treturn 1;\n\tdbg_rcvry(\"unexpected data at %d:%d\", lnum, offs + skip);\n\treturn 0;\n}\n\n/**\n * fix_"
  },
  {
    "function_name": "st struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/recovery.c",
    "lines": "440-456",
    "snippet": "lean_buf(const struct ubifs_info *c, void **buf, int lnum,\n\t\t      int *offs, int *len)\n{\n\tint empty_offs, pad_len;\n\n\tlnum = lnum;\n\tdbg_rcvry(\"cleaning corruption at %d:%d\", lnum, *offs);\n\n\tubifs_assert(!(*offs & 7));\n\tempty_offs = ALIGN(*offs, c->min_io_size);\n\tpad_len = empty_offs - *offs;\n\tubifs_pad(c, *buf, pad_len);\n\t*offs += pad_len;\n\t*buf += pad_len;\n\t*len -= pad_len;\n\tmemset(*buf, 0xff, c->leb_size - empty_offs);\n}\n\n/**\n * no_m",
    "includes": [
      "fs.h\"\n\n/**\n * is_em",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "0xff,",
          "args": [
            "->le",
            "size",
            "empty_offs);\n}\n\n/**\n *"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "*buf, pad",
          "args": [
            "l",
            ");",
            "ffs +="
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "c->mi",
          "args": [
            "_io_s",
            "e);\n\tpad_len ="
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "!(*offs & 7)",
          "args": [
            ";\n\tempty_off"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eaning co",
          "args": [
            "ruption at %d:%d\", lnum, *offs",
            "u",
            "fs_as"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * is_em\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nlean_buf(const struct ubifs_info *c, void **buf, int lnum,\n\t\t      int *offs, int *len)\n{\n\tint empty_offs, pad_len;\n\n\tlnum = lnum;\n\tdbg_rcvry(\"cleaning corruption at %d:%d\", lnum, *offs);\n\n\tubifs_assert(!(*offs & 7));\n\tempty_offs = ALIGN(*offs, c->min_io_size);\n\tpad_len = empty_offs - *offs;\n\tubifs_pad(c, *buf, pad_len);\n\t*offs += pad_len;\n\t*buf += pad_len;\n\t*len -= pad_len;\n\tmemset(*buf, 0xff, c->leb_size - empty_offs);\n}\n\n/**\n * no_m"
  },
  {
    "function_name": "(const struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/recovery.c",
    "lines": "413-426",
    "snippet": "_last_write(const struct ubifs_info *c, void *buf, int offs)\n{\n\tint empty_offs, check_len;\n\tuint8_t *p;\n\n\t/*\n\t * Round up to the next @c->max_write_size boundary i.e. @offs is in\n\t * the last wbuf written. After that should be empty space.\n\t */\n\tempty_offs = ALIGN(offs + 1, c->max_write_size);\n\tcheck_len = c->leb_size - empty_offs;\n\tp = buf + empty_offs - offs;\n\treturn is_empty(p, check_len);\n}\n\n/**\n * clea",
    "includes": [
      "fs.h\"\n\n/**\n * is_em",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "heck_len",
          "args": [
            ";",
            "/**\n *"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "1, c-",
          "args": [
            "max_writ",
            "size);\n\tcheck_len"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * is_em\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\n_last_write(const struct ubifs_info *c, void *buf, int offs)\n{\n\tint empty_offs, check_len;\n\tuint8_t *p;\n\n\t/*\n\t * Round up to the next @c->max_write_size boundary i.e. @offs is in\n\t * the last wbuf written. After that should be empty space.\n\t */\n\tempty_offs = ALIGN(offs + 1, c->max_write_size);\n\tcheck_len = c->leb_size - empty_offs;\n\tp = buf + empty_offs - offs;\n\treturn is_empty(p, check_len);\n}\n\n/**\n * clea"
  },
  {
    "function_name": "cvrd_mst_node(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/recovery.c",
    "lines": "386-400",
    "snippet": "te_rcvrd_mst_node(struct ubifs_info *c)\n{\n\tint err;\n\n\tif (!c->rcvrd_mst_node)\n\t\treturn 0;\n\tc->rcvrd_mst_node->flags |= cpu_to_le32(UBIFS_MST_DIRTY);\n\tc->mst_node->flags |= cpu_to_le32(UBIFS_MST_DIRTY);\n\terr = write_rcvrd_mst_node(c, c->rcvrd_mst_node);\n\tif (err)\n\t\treturn err;\n\tkfree(c->rcvrd_mst_node);\n\tc->rcvrd_mst_node = NULL;\n\treturn 0;\n}\n\n/**\n * is_l",
    "includes": [
      "fs.h\"\n\n/**\n * is_em",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_mst",
          "args": [
            "node);\n\tc->rcvrd_"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "cvrd_mst_node(struct ubifs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/recovery.c",
          "lines": "386-400",
          "snippet": "te_rcvrd_mst_node(struct ubifs_info *c)\n{\n\tint err;\n\n\tif (!c->rcvrd_mst_node)\n\t\treturn 0;\n\tc->rcvrd_mst_node->flags |= cpu_to_le32(UBIFS_MST_DIRTY);\n\tc->mst_node->flags |= cpu_to_le32(UBIFS_MST_DIRTY);\n\terr = write_rcvrd_mst_node(c, c->rcvrd_mst_node);\n\tif (err)\n\t\treturn err;\n\tkfree(c->rcvrd_mst_node);\n\tc->rcvrd_mst_node = NULL;\n\treturn 0;\n}\n\n/**\n * is_l",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "st_node(c, c->rcvrd_",
          "args": [
            "s",
            "node);\n\tif (err)"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIFS_MST_DI",
          "args": [
            "TY);\n\terr = wri"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIFS_MST_DI",
          "args": [
            "TY);\n\tc->mst_no"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * is_em\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nte_rcvrd_mst_node(struct ubifs_info *c)\n{\n\tint err;\n\n\tif (!c->rcvrd_mst_node)\n\t\treturn 0;\n\tc->rcvrd_mst_node->flags |= cpu_to_le32(UBIFS_MST_DIRTY);\n\tc->mst_node->flags |= cpu_to_le32(UBIFS_MST_DIRTY);\n\terr = write_rcvrd_mst_node(c, c->rcvrd_mst_node);\n\tif (err)\n\t\treturn err;\n\tkfree(c->rcvrd_mst_node);\n\tc->rcvrd_mst_node = NULL;\n\treturn 0;\n}\n\n/**\n * is_l"
  },
  {
    "function_name": "_master_node(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/recovery.c",
    "lines": "236-375",
    "snippet": "over_master_node(struct ubifs_info *c)\n{\n\tvoid *buf1 = NULL, *buf2 = NULL, *cor1 = NULL, *cor2 = NULL;\n\tstruct ubifs_mst_node *mst1 = NULL, *mst2 = NULL, *mst;\n\tconst int sz = c->mst_node_alsz;\n\tint err, offs1, offs2;\n\n\tdbg_rcvry(\"recovery\");\n\n\terr = get_master_node(c, UBIFS_MST_LNUM, &buf1, &mst1, &cor1);\n\tif (err)\n\t\tgoto out_free;\n\n\terr = get_master_node(c, UBIFS_MST_LNUM + 1, &buf2, &mst2, &cor2);\n\tif (err)\n\t\tgoto out_free;\n\n\tif (mst1) {\n\t\toffs1 = (void *)mst1 - buf1;\n\t\tif ((le32_to_cpu(mst1->flags) & UBIFS_MST_RCVRY) &&\n\t\t    (offs1 == 0 && !cor1)) {\n\t\t\t/*\n\t\t\t * mst1 was written by recovery at offset 0 with no\n\t\t\t * corruption.\n\t\t\t */\n\t\t\tdbg_rcvry(\"recovery recovery\");\n\t\t\tmst = mst1;\n\t\t} else if (mst2) {\n\t\t\toffs2 = (void *)mst2 - buf2;\n\t\t\tif (offs1 == offs2) {\n\t\t\t\t/* Same offset, so must be the same */\n\t\t\t\tif (memcmp((void *)mst1 + UBIFS_CH_SZ,\n\t\t\t\t\t   (void *)mst2 + UBIFS_CH_SZ,\n\t\t\t\t\t   UBIFS_MST_NODE_SZ - UBIFS_CH_SZ))\n\t\t\t\t\tgoto out_err;\n\t\t\t\tmst = mst1;\n\t\t\t} else if (offs2 + sz == offs1) {\n\t\t\t\t/* 1st LEB was written, 2nd was not */\n\t\t\t\tif (cor1)\n\t\t\t\t\tgoto out_err;\n\t\t\t\tmst = mst1;\n\t\t\t} else if (offs1 == 0 &&\n\t\t\t\t   c->leb_size - offs2 - sz < sz) {\n\t\t\t\t/* 1st LEB was unmapped and written, 2nd not */\n\t\t\t\tif (cor1)\n\t\t\t\t\tgoto out_err;\n\t\t\t\tmst = mst1;\n\t\t\t} else\n\t\t\t\tgoto out_err;\n\t\t} else {\n\t\t\t/*\n\t\t\t * 2nd LEB was unmapped and about to be written, so\n\t\t\t * there must be only one master node in the first LEB\n\t\t\t * and no corruption.\n\t\t\t */\n\t\t\tif (offs1 != 0 || cor1)\n\t\t\t\tgoto out_err;\n\t\t\tmst = mst1;\n\t\t}\n\t} else {\n\t\tif (!mst2)\n\t\t\tgoto out_err;\n\t\t/*\n\t\t * 1st LEB was unmapped and about to be written, so there must\n\t\t * be no room left in 2nd LEB.\n\t\t */\n\t\toffs2 = (void *)mst2 - buf2;\n\t\tif (offs2 + sz + sz <= c->leb_size)\n\t\t\tgoto out_err;\n\t\tmst = mst2;\n\t}\n\n\tubifs_msg(\"recovered master node from LEB %d\",\n\t\t  (mst == mst1 ? UBIFS_MST_LNUM : UBIFS_MST_LNUM + 1));\n\n\tmemcpy(c->mst_node, mst, UBIFS_MST_NODE_SZ);\n\n\tif (c->ro_mount) {\n\t\t/* Read-only mode. Keep a copy for switching to rw mode */\n\t\tc->rcvrd_mst_node = kmalloc(sz, GFP_KERNEL);\n\t\tif (!c->rcvrd_mst_node) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_free;\n\t\t}\n\t\tmemcpy(c->rcvrd_mst_node, c->mst_node, UBIFS_MST_NODE_SZ);\n\n\t\t/*\n\t\t * We had to recover the master node, which means there was an\n\t\t * unclean reboot. However, it is possible that the master node\n\t\t * is clean at this point, i.e., %UBIFS_MST_DIRTY is not set.\n\t\t * E.g., consider the following chain of events:\n\t\t *\n\t\t * 1. UBIFS was cleanly unmounted, so the master node is clean\n\t\t * 2. UBIFS is being mounted R/W and starts changing the master\n\t\t *    node in the first (%UBIFS_MST_LNUM). A power cut happens,\n\t\t *    so this LEB ends up with some amount of garbage at the\n\t\t *    end.\n\t\t * 3. UBIFS is being mounted R/O. We reach this place and\n\t\t *    recover the master node from the second LEB\n\t\t *    (%UBIFS_MST_LNUM + 1). But we cannot update the media\n\t\t *    because we are being mounted R/O. We have to defer the\n\t\t *    operation.\n\t\t * 4. However, this master node (@c->mst_node) is marked as\n\t\t *    clean (since the step 1). And if we just return, the\n\t\t *    mount code will be confused and won't recover the master\n\t\t *    node when it is re-mounter R/W later.\n\t\t *\n\t\t *    Thus, to force the recovery by marking the master node as\n\t\t *    dirty.\n\t\t */\n\t\tc->mst_node->flags |= cpu_to_le32(UBIFS_MST_DIRTY);\n\t} else {\n\t\t/* Write the recovered master node */\n\t\tc->max_sqnum = le64_to_cpu(mst->ch.sqnum) - 1;\n\t\terr = write_rcvrd_mst_node(c, c->mst_node);\n\t\tif (err)\n\t\t\tgoto out_free;\n\t}\n\n\tvfree(buf2);\n\tvfree(buf1);\n\n\treturn 0;\n\nout_err:\n\terr = -EINVAL;\nout_free:\n\tubifs_err(\"failed to recover master node\");\n\tif (mst1) {\n\t\tubifs_err(\"dumping first master node\");\n\t\tubifs_dump_node(c, mst1);\n\t}\n\tif (mst2) {\n\t\tubifs_err(\"dumping second master node\");\n\t\tubifs_dump_node(c, mst2);\n\t}\n\tvfree(buf2);\n\tvfree(buf1);\n\treturn err;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/**\n * is_em",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "retu",
          "args": [
            "n er"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "nfsd4_return_all_client_layouts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/nfs4layouts.c",
          "lines": "544-556",
          "snippet": "void\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"netns.h\"",
            "#include \"pnfs.h\"",
            "#include <linux/sunrpc/addr.h>",
            "#include <linux/sched.h>",
            "#include <linux/jhash.h>",
            "#include <linux/file.h>",
            "#include <linux/kmod.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"netns.h\"\n#include \"pnfs.h\"\n#include <linux/sunrpc/addr.h>\n#include <linux/sched.h>\n#include <linux/jhash.h>\n#include <linux/file.h>\n#include <linux/kmod.h>\n\nvoid\nnfsd4_return_all_client_layouts(struct nfs4_client *clp)\n{\n\tstruct nfs4_layout_stateid *ls, *n;\n\tLIST_HEAD(reaplist);\n\n\tspin_lock(&clp->cl_lock);\n\tlist_for_each_entry_safe(ls, n, &clp->cl_lo_states, ls_perclnt)\n\t\tnfsd4_return_all_layouts(ls, &reaplist);\n\tspin_unlock(&clp->cl_lock);\n\n\tnfsd4_free_layouts(&reaplist);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfre",
          "args": [
            "(buf"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de(c, mst2);\n\t}",
          "args": [
            "ree("
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mping sec",
          "args": [
            "nd master node\");\n\t\tubifs_du"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de(c, mst1);\n\t}",
          "args": [
            "(ms"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mping fir",
          "args": [
            "t master node\");\n\t\tubifs_du"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iled to r",
          "args": [
            "cover master node\");\n\tif (mst1)"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ret",
          "args": [
            "rn 0"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "retire_sysctl_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/proc/proc_sysctl.c",
          "lines": "1567-1570",
          "snippet": "void retire_sysctl_set(struct ctl_table_set *set)\n{\n\tWARN_ON(!RB_EMPTY_ROOT(&set->dir.root));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/printk.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/poll.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/printk.h>\n#include <linux/proc_fs.h>\n#include <linux/poll.h>\n#include <linux/sysctl.h>\n#include <linux/init.h>\n\nvoid retire_sysctl_set(struct ctl_table_set *set)\n{\n\tWARN_ON(!RB_EMPTY_ROOT(&set->dir.root));\n}"
        }
      },
      {
        "call_info": {
          "callee": "vfre",
          "args": [
            "(buf"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st_node(c, c->mst_no",
          "args": [
            "e",
            "if (err)"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st->ch.sqnu",
          "args": [
            ") - 1;\n\t\terr"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIFS_MST_DI",
          "args": [
            "TY);\n\t} else {"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rd_mst",
          "args": [
            "node, c->mst_node",
            "UBIFS_MST_N",
            "E_SZ);\n\n\t\t/*\n\t\t *"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FP_KERN",
          "args": [
            "L)",
            "if (!c->"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_node,",
          "args": [
            "mst, UBIFS_",
            "T_N",
            "E_SZ);\n\n\tif (c->r"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "covered m",
          "args": [
            "ster node from LEB %d\",\n\t\t  (mst ==",
            "? UBIFS_MST_LNUM : UBIFS_MST_LNUM + 1));\n\n\tmemcpy(c"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "*)mst1",
          "args": [
            "+ UBIFS_CH_SZ,\n\t\t\t\t\t   (vo",
            "+ UBIFS_CH_SZ,\n\t\t\t\t\t   UBI",
            "E_SZ - UBIFS_CH_SZ))\n\t\t\t\t\tgoto"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "covery re",
          "args": [
            "overy\");\n\t\t\tmst = m"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "st1->flags)",
          "args": [
            "& UBIFS_MST"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de(c, UBIFS_MST",
          "args": [
            "L",
            "M + 1, &buf2, &mst",
            "&cor",
            ";\n\tif",
            "err)"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "de(c, UBIFS_MST",
          "args": [
            "L",
            "M, &buf1, &mst",
            "&cor",
            ";\n\tif",
            "err)"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "covery\");",
          "args": [
            "err = ge"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * is_em\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nover_master_node(struct ubifs_info *c)\n{\n\tvoid *buf1 = NULL, *buf2 = NULL, *cor1 = NULL, *cor2 = NULL;\n\tstruct ubifs_mst_node *mst1 = NULL, *mst2 = NULL, *mst;\n\tconst int sz = c->mst_node_alsz;\n\tint err, offs1, offs2;\n\n\tdbg_rcvry(\"recovery\");\n\n\terr = get_master_node(c, UBIFS_MST_LNUM, &buf1, &mst1, &cor1);\n\tif (err)\n\t\tgoto out_free;\n\n\terr = get_master_node(c, UBIFS_MST_LNUM + 1, &buf2, &mst2, &cor2);\n\tif (err)\n\t\tgoto out_free;\n\n\tif (mst1) {\n\t\toffs1 = (void *)mst1 - buf1;\n\t\tif ((le32_to_cpu(mst1->flags) & UBIFS_MST_RCVRY) &&\n\t\t    (offs1 == 0 && !cor1)) {\n\t\t\t/*\n\t\t\t * mst1 was written by recovery at offset 0 with no\n\t\t\t * corruption.\n\t\t\t */\n\t\t\tdbg_rcvry(\"recovery recovery\");\n\t\t\tmst = mst1;\n\t\t} else if (mst2) {\n\t\t\toffs2 = (void *)mst2 - buf2;\n\t\t\tif (offs1 == offs2) {\n\t\t\t\t/* Same offset, so must be the same */\n\t\t\t\tif (memcmp((void *)mst1 + UBIFS_CH_SZ,\n\t\t\t\t\t   (void *)mst2 + UBIFS_CH_SZ,\n\t\t\t\t\t   UBIFS_MST_NODE_SZ - UBIFS_CH_SZ))\n\t\t\t\t\tgoto out_err;\n\t\t\t\tmst = mst1;\n\t\t\t} else if (offs2 + sz == offs1) {\n\t\t\t\t/* 1st LEB was written, 2nd was not */\n\t\t\t\tif (cor1)\n\t\t\t\t\tgoto out_err;\n\t\t\t\tmst = mst1;\n\t\t\t} else if (offs1 == 0 &&\n\t\t\t\t   c->leb_size - offs2 - sz < sz) {\n\t\t\t\t/* 1st LEB was unmapped and written, 2nd not */\n\t\t\t\tif (cor1)\n\t\t\t\t\tgoto out_err;\n\t\t\t\tmst = mst1;\n\t\t\t} else\n\t\t\t\tgoto out_err;\n\t\t} else {\n\t\t\t/*\n\t\t\t * 2nd LEB was unmapped and about to be written, so\n\t\t\t * there must be only one master node in the first LEB\n\t\t\t * and no corruption.\n\t\t\t */\n\t\t\tif (offs1 != 0 || cor1)\n\t\t\t\tgoto out_err;\n\t\t\tmst = mst1;\n\t\t}\n\t} else {\n\t\tif (!mst2)\n\t\t\tgoto out_err;\n\t\t/*\n\t\t * 1st LEB was unmapped and about to be written, so there must\n\t\t * be no room left in 2nd LEB.\n\t\t */\n\t\toffs2 = (void *)mst2 - buf2;\n\t\tif (offs2 + sz + sz <= c->leb_size)\n\t\t\tgoto out_err;\n\t\tmst = mst2;\n\t}\n\n\tubifs_msg(\"recovered master node from LEB %d\",\n\t\t  (mst == mst1 ? UBIFS_MST_LNUM : UBIFS_MST_LNUM + 1));\n\n\tmemcpy(c->mst_node, mst, UBIFS_MST_NODE_SZ);\n\n\tif (c->ro_mount) {\n\t\t/* Read-only mode. Keep a copy for switching to rw mode */\n\t\tc->rcvrd_mst_node = kmalloc(sz, GFP_KERNEL);\n\t\tif (!c->rcvrd_mst_node) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out_free;\n\t\t}\n\t\tmemcpy(c->rcvrd_mst_node, c->mst_node, UBIFS_MST_NODE_SZ);\n\n\t\t/*\n\t\t * We had to recover the master node, which means there was an\n\t\t * unclean reboot. However, it is possible that the master node\n\t\t * is clean at this point, i.e., %UBIFS_MST_DIRTY is not set.\n\t\t * E.g., consider the following chain of events:\n\t\t *\n\t\t * 1. UBIFS was cleanly unmounted, so the master node is clean\n\t\t * 2. UBIFS is being mounted R/W and starts changing the master\n\t\t *    node in the first (%UBIFS_MST_LNUM). A power cut happens,\n\t\t *    so this LEB ends up with some amount of garbage at the\n\t\t *    end.\n\t\t * 3. UBIFS is being mounted R/O. We reach this place and\n\t\t *    recover the master node from the second LEB\n\t\t *    (%UBIFS_MST_LNUM + 1). But we cannot update the media\n\t\t *    because we are being mounted R/O. We have to defer the\n\t\t *    operation.\n\t\t * 4. However, this master node (@c->mst_node) is marked as\n\t\t *    clean (since the step 1). And if we just return, the\n\t\t *    mount code will be confused and won't recover the master\n\t\t *    node when it is re-mounter R/W later.\n\t\t *\n\t\t *    Thus, to force the recovery by marking the master node as\n\t\t *    dirty.\n\t\t */\n\t\tc->mst_node->flags |= cpu_to_le32(UBIFS_MST_DIRTY);\n\t} else {\n\t\t/* Write the recovered master node */\n\t\tc->max_sqnum = le64_to_cpu(mst->ch.sqnum) - 1;\n\t\terr = write_rcvrd_mst_node(c, c->mst_node);\n\t\tif (err)\n\t\t\tgoto out_free;\n\t}\n\n\tvfree(buf2);\n\tvfree(buf1);\n\n\treturn 0;\n\nout_err:\n\terr = -EINVAL;\nout_free:\n\tubifs_err(\"failed to recover master node\");\n\tif (mst1) {\n\t\tubifs_err(\"dumping first master node\");\n\t\tubifs_dump_node(c, mst1);\n\t}\n\tif (mst2) {\n\t\tubifs_err(\"dumping second master node\");\n\t\tubifs_dump_node(c, mst2);\n\t}\n\tvfree(buf2);\n\tvfree(buf1);\n\treturn err;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "st_node(struct ubifs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/recovery.c",
    "lines": "204-225",
    "snippet": "ite_rcvrd_mst_node(struct ubifs_info *c,\n\t\t\t\tstruct ubifs_mst_node *mst)\n{\n\tint err = 0, lnum = UBIFS_MST_LNUM, sz = c->mst_node_alsz;\n\t__le32 save_flags;\n\n\tdbg_rcvry(\"recovery\");\n\n\tsave_flags = mst->flags;\n\tmst->flags |= cpu_to_le32(UBIFS_MST_RCVRY);\n\n\tubifs_prepare_node(c, mst, UBIFS_MST_NODE_SZ, 1);\n\terr = ubifs_leb_change(c, lnum, mst, sz);\n\tif (err)\n\t\tgoto out;\n\terr = ubifs_leb_change(c, lnum + 1, mst, sz);\n\tif (err)\n\t\tgoto out;\nout:\n\tmst->flags = save_flags;\n\treturn err;\n}\n\n/**\n * ubif",
    "includes": [
      "fs.h\"\n\n/**\n * is_em",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nge(c, lnum + 1,",
          "args": [
            "m",
            ", sz);",
            "(e",
            ")"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nge(c, lnum, mst",
          "args": [
            ");",
            "(e",
            ")"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_node(c, mst, UBIF",
          "args": [
            "_",
            "T_N",
            "E_SZ, 1);\n\terr =",
            "i"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIFS_MST_RC",
          "args": [
            "RY);\n\n\tubifs_pr"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "covery\");",
          "args": [
            "save_fla"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * is_em\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nite_rcvrd_mst_node(struct ubifs_info *c,\n\t\t\t\tstruct ubifs_mst_node *mst)\n{\n\tint err = 0, lnum = UBIFS_MST_LNUM, sz = c->mst_node_alsz;\n\t__le32 save_flags;\n\n\tdbg_rcvry(\"recovery\");\n\n\tsave_flags = mst->flags;\n\tmst->flags |= cpu_to_le32(UBIFS_MST_RCVRY);\n\n\tubifs_prepare_node(c, mst, UBIFS_MST_NODE_SZ, 1);\n\terr = ubifs_leb_change(c, lnum, mst, sz);\n\tif (err)\n\t\tgoto out;\n\terr = ubifs_leb_change(c, lnum + 1, mst, sz);\n\tif (err)\n\t\tgoto out;\nout:\n\tmst->flags = save_flags;\n\treturn err;\n}\n\n/**\n * ubif"
  },
  {
    "function_name": "de(const struct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/recovery.c",
    "lines": "109-195",
    "snippet": "t_master_node(const struct ubifs_info *c, int lnum, void **pbuf,\n\t\t\t   struct ubifs_mst_node **mst, void **cor)\n{\n\tconst int sz = c->mst_node_alsz;\n\tint err, offs, len;\n\tvoid *sbuf, *buf;\n\n\tsbuf = vmalloc(c->leb_size);\n\tif (!sbuf)\n\t\treturn -ENOMEM;\n\n\terr = ubifs_leb_read(c, lnum, sbuf, 0, c->leb_size, 0);\n\tif (err && err != -EBADMSG)\n\t\tgoto out_free;\n\n\t/* Find the first position that is definitely not a node */\n\toffs = 0;\n\tbuf = sbuf;\n\tlen = c->leb_size;\n\twhile (offs + UBIFS_MST_NODE_SZ <= c->leb_size) {\n\t\tstruct ubifs_ch *ch = buf;\n\n\t\tif (le32_to_cpu(ch->magic) != UBIFS_NODE_MAGIC)\n\t\t\tbreak;\n\t\toffs += sz;\n\t\tbuf  += sz;\n\t\tlen  -= sz;\n\t}\n\t/* See if there was a valid master node before that */\n\tif (offs) {\n\t\tint ret;\n\n\t\toffs -= sz;\n\t\tbuf  -= sz;\n\t\tlen  += sz;\n\t\tret = ubifs_scan_a_node(c, buf, len, lnum, offs, 1);\n\t\tif (ret != SCANNED_A_NODE && offs) {\n\t\t\t/* Could have been corruption so check one place back */\n\t\t\toffs -= sz;\n\t\t\tbuf  -= sz;\n\t\t\tlen  += sz;\n\t\t\tret = ubifs_scan_a_node(c, buf, len, lnum, offs, 1);\n\t\t\tif (ret != SCANNED_A_NODE)\n\t\t\t\t/*\n\t\t\t\t * We accept only one area of corruption because\n\t\t\t\t * we are assuming that it was caused while\n\t\t\t\t * trying to write a master node.\n\t\t\t\t */\n\t\t\t\tgoto out_err;\n\t\t}\n\t\tif (ret == SCANNED_A_NODE) {\n\t\t\tstruct ubifs_ch *ch = buf;\n\n\t\t\tif (ch->node_type != UBIFS_MST_NODE)\n\t\t\t\tgoto out_err;\n\t\t\tdbg_rcvry(\"found a master node at %d:%d\", lnum, offs);\n\t\t\t*mst = buf;\n\t\t\toffs += sz;\n\t\t\tbuf  += sz;\n\t\t\tlen  -= sz;\n\t\t}\n\t}\n\t/* Check for corruption */\n\tif (offs < c->leb_size) {\n\t\tif (!is_empty(buf, min_t(int, len, sz))) {\n\t\t\t*cor = buf;\n\t\t\tdbg_rcvry(\"found corruption at %d:%d\", lnum, offs);\n\t\t}\n\t\toffs += sz;\n\t\tbuf  += sz;\n\t\tlen  -= sz;\n\t}\n\t/* Check remaining empty space */\n\tif (offs < c->leb_size)\n\t\tif (!is_empty(buf, len))\n\t\t\tgoto out_err;\n\t*pbuf = sbuf;\n\treturn 0;\n\nout_err:\n\terr = -EINVAL;\nout_free:\n\tvfree(sbuf);\n\t*mst = NULL;\n\t*cor = NULL;\n\treturn err;\n}\n\n/**\n * writ",
    "includes": [
      "fs.h\"\n\n/**\n * is_em",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "*mst",
          "args": [
            "= NU"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "len))",
          "args": [
            "go",
            "ou"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "und corru",
          "args": [
            "tion at %d:%d\", lnum, offs)",
            "}",
            "offs"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t(i",
          "args": [
            "t,",
            "n, sz))) {\n\t\t\t*cor"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "n, sz",
          "args": [
            "))",
            "or"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "und a mas",
          "args": [
            "er node at %d:%d\", lnum, offs)",
            "*",
            "t ="
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node(c, buf, len,",
          "args": [
            "l",
            "m,",
            "fs,",
            ");",
            "if (",
            "t"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "node(c, buf, len,",
          "args": [
            "l",
            "m,",
            "fs,",
            ");",
            "f (r"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "h->magic) !",
          "args": [
            "UBIFS_NO"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d(c, lnum, sbu",
          "args": [
            ",",
            ", c-",
            "eb_s",
            "e",
            "0);\n\tif (er",
            "&"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "b_size)",
          "args": [
            "if (!sbuf"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "fs.h\"\n\n/**\n * is_em\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nt_master_node(const struct ubifs_info *c, int lnum, void **pbuf,\n\t\t\t   struct ubifs_mst_node **mst, void **cor)\n{\n\tconst int sz = c->mst_node_alsz;\n\tint err, offs, len;\n\tvoid *sbuf, *buf;\n\n\tsbuf = vmalloc(c->leb_size);\n\tif (!sbuf)\n\t\treturn -ENOMEM;\n\n\terr = ubifs_leb_read(c, lnum, sbuf, 0, c->leb_size, 0);\n\tif (err && err != -EBADMSG)\n\t\tgoto out_free;\n\n\t/* Find the first position that is definitely not a node */\n\toffs = 0;\n\tbuf = sbuf;\n\tlen = c->leb_size;\n\twhile (offs + UBIFS_MST_NODE_SZ <= c->leb_size) {\n\t\tstruct ubifs_ch *ch = buf;\n\n\t\tif (le32_to_cpu(ch->magic) != UBIFS_NODE_MAGIC)\n\t\t\tbreak;\n\t\toffs += sz;\n\t\tbuf  += sz;\n\t\tlen  -= sz;\n\t}\n\t/* See if there was a valid master node before that */\n\tif (offs) {\n\t\tint ret;\n\n\t\toffs -= sz;\n\t\tbuf  -= sz;\n\t\tlen  += sz;\n\t\tret = ubifs_scan_a_node(c, buf, len, lnum, offs, 1);\n\t\tif (ret != SCANNED_A_NODE && offs) {\n\t\t\t/* Could have been corruption so check one place back */\n\t\t\toffs -= sz;\n\t\t\tbuf  -= sz;\n\t\t\tlen  += sz;\n\t\t\tret = ubifs_scan_a_node(c, buf, len, lnum, offs, 1);\n\t\t\tif (ret != SCANNED_A_NODE)\n\t\t\t\t/*\n\t\t\t\t * We accept only one area of corruption because\n\t\t\t\t * we are assuming that it was caused while\n\t\t\t\t * trying to write a master node.\n\t\t\t\t */\n\t\t\t\tgoto out_err;\n\t\t}\n\t\tif (ret == SCANNED_A_NODE) {\n\t\t\tstruct ubifs_ch *ch = buf;\n\n\t\t\tif (ch->node_type != UBIFS_MST_NODE)\n\t\t\t\tgoto out_err;\n\t\t\tdbg_rcvry(\"found a master node at %d:%d\", lnum, offs);\n\t\t\t*mst = buf;\n\t\t\toffs += sz;\n\t\t\tbuf  += sz;\n\t\t\tlen  -= sz;\n\t\t}\n\t}\n\t/* Check for corruption */\n\tif (offs < c->leb_size) {\n\t\tif (!is_empty(buf, min_t(int, len, sz))) {\n\t\t\t*cor = buf;\n\t\t\tdbg_rcvry(\"found corruption at %d:%d\", lnum, offs);\n\t\t}\n\t\toffs += sz;\n\t\tbuf  += sz;\n\t\tlen  -= sz;\n\t}\n\t/* Check remaining empty space */\n\tif (offs < c->leb_size)\n\t\tif (!is_empty(buf, len))\n\t\t\tgoto out_err;\n\t*pbuf = sbuf;\n\treturn 0;\n\nout_err:\n\terr = -EINVAL;\nout_free:\n\tvfree(sbuf);\n\t*mst = NULL;\n\t*cor = NULL;\n\treturn err;\n}\n\n/**\n * writ"
  },
  {
    "function_name": "void *buf, i",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/recovery.c",
    "lines": "81-90",
    "snippet": "rst_non_ff(void *buf, int len)\n{\n\tuint8_t *p = buf;\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\tif (*p++ != 0xff)\n\t\t\treturn i;\n\treturn -1;\n}\n\n/**\n * get_",
    "includes": [
      "fs.h\"\n\n/**\n * is_em",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "fs.h\"\n\n/**\n * is_em\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\nrst_non_ff(void *buf, int len)\n{\n\tuint8_t *p = buf;\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\tif (*p++ != 0xff)\n\t\t\treturn i;\n\treturn -1;\n}\n\n/**\n * get_"
  },
  {
    "function_name": "*buf, i",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ubifs/recovery.c",
    "lines": "62-71",
    "snippet": "_empty(void *buf, int len)\n{\n\tuint8_t *p = buf;\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\tif (*p++ != 0xff)\n\t\t\treturn 0;\n\treturn 1;\n}\n\n/**\n * firs",
    "includes": [
      "fs.h\"\n\n/**\n * is_em",
      "ux/slab.h>\n#include \"ubi",
      "ux/crc32.h>\n#include <lin"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "fs.h\"\n\n/**\n * is_em\nux/slab.h>\n#include \"ubi\nux/crc32.h>\n#include <lin\n\n_empty(void *buf, int len)\n{\n\tuint8_t *p = buf;\n\tint i;\n\n\tfor (i = 0; i < len; i++)\n\t\tif (*p++ != 0xff)\n\t\t\treturn 0;\n\treturn 1;\n}\n\n/**\n * firs"
  }
]