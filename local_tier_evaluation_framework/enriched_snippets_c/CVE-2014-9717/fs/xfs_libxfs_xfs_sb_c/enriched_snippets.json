[
  {
    "function_name": "xfs_sync_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
    "lines": "790-809",
    "snippet": "int\nxfs_sync_sb(\n\tstruct xfs_mount\t*mp,\n\tbool\t\t\twait)\n{\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\n\ttp = _xfs_trans_alloc(mp, XFS_TRANS_SB_CHANGE, KM_SLEEP);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_sb, 0, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn error;\n\t}\n\n\txfs_log_sb(tp);\n\tif (wait)\n\t\txfs_trans_set_sync(tp);\n\treturn xfs_trans_commit(tp, 0);\n}",
    "includes": [
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_commit",
          "args": [
            "tp",
            "0"
          ],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "845-927",
          "snippet": "int\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_commit(\n\tstruct xfs_trans\t*tp,\n\tuint\t\t\tflags)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\txfs_lsn_t\t\tcommit_lsn = -1;\n\tint\t\t\terror = 0;\n\tint\t\t\tlog_flags = 0;\n\tint\t\t\tsync = tp->t_flags & XFS_TRANS_SYNC;\n\n\t/*\n\t * Determine whether this commit is releasing a permanent\n\t * log reservation or not.\n\t */\n\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t}\n\n\t/*\n\t * If there is nothing to be logged by the transaction,\n\t * then unlock all of the items associated with the\n\t * transaction and free the transaction structure.\n\t * Also make sure to return any reserved blocks to\n\t * the free pool.\n\t */\n\tif (!(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tgoto out_unreserve;\n\n\tif (XFS_FORCED_SHUTDOWN(mp)) {\n\t\terror = -EIO;\n\t\tgoto out_unreserve;\n\t}\n\n\tASSERT(tp->t_ticket != NULL);\n\n\t/*\n\t * If we need to update the superblock, then do it now.\n\t */\n\tif (tp->t_flags & XFS_TRANS_SB_DIRTY)\n\t\txfs_trans_apply_sb_deltas(tp);\n\txfs_trans_apply_dquot_deltas(tp);\n\n\txfs_log_commit_cil(mp, tp, &commit_lsn, flags);\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free(tp);\n\n\t/*\n\t * If the transaction needs to be synchronous, then force the\n\t * log out now and wait for it.\n\t */\n\tif (sync) {\n\t\terror = _xfs_log_force_lsn(mp, commit_lsn, XFS_LOG_SYNC, NULL);\n\t\tXFS_STATS_INC(xs_trans_sync);\n\t} else {\n\t\tXFS_STATS_INC(xs_trans_async);\n\t}\n\n\treturn error;\n\nout_unreserve:\n\txfs_trans_unreserve_and_mod_sb(tp);\n\n\t/*\n\t * It is indeed possible for the transaction to be not dirty but\n\t * the dqinfo portion to be.  All that means is that we have some\n\t * (non-persistent) quota reservations that need to be unreserved.\n\t */\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\tif (tp->t_ticket) {\n\t\tcommit_lsn = xfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t\tif (commit_lsn == -1 && !error)\n\t\t\terror = -EIO;\n\t}\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\txfs_trans_free_items(tp, NULLCOMMITLSN, error ? XFS_TRANS_ABORT : 0);\n\txfs_trans_free(tp);\n\n\tXFS_STATS_INC(xs_trans_empty);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_set_sync",
          "args": [
            "tp"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_log_sb",
          "args": [
            "tp"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_log_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "767-777",
          "snippet": "void\nxfs_log_sb(\n\tstruct xfs_trans\t*tp)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\tstruct xfs_buf\t\t*bp = xfs_trans_getsb(tp, mp, 0);\n\n\txfs_sb_to_disk(XFS_BUF_TO_SBP(bp), &mp->m_sb);\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_SB_BUF);\n\txfs_trans_log_buf(tp, bp, 0, sizeof(struct xfs_dsb));\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_log_sb(\n\tstruct xfs_trans\t*tp)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\tstruct xfs_buf\t\t*bp = xfs_trans_getsb(tp, mp, 0);\n\n\txfs_sb_to_disk(XFS_BUF_TO_SBP(bp), &mp->m_sb);\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_SB_BUF);\n\txfs_trans_log_buf(tp, bp, 0, sizeof(struct xfs_dsb));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_cancel",
          "args": [
            "tp",
            "0"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "937-986",
          "snippet": "void\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_cancel(\n\txfs_trans_t\t\t*tp,\n\tint\t\t\tflags)\n{\n\tint\t\t\tlog_flags;\n\txfs_mount_t\t\t*mp = tp->t_mountp;\n\n\t/*\n\t * See if the caller is being too lazy to figure out if\n\t * the transaction really needs an abort.\n\t */\n\tif ((flags & XFS_TRANS_ABORT) && !(tp->t_flags & XFS_TRANS_DIRTY))\n\t\tflags &= ~XFS_TRANS_ABORT;\n\t/*\n\t * See if the caller is relying on us to shut down the\n\t * filesystem.  This happens in paths where we detect\n\t * corruption and decide to give up.\n\t */\n\tif ((tp->t_flags & XFS_TRANS_DIRTY) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tXFS_ERROR_REPORT(\"xfs_trans_cancel\", XFS_ERRLEVEL_LOW, mp);\n\t\txfs_force_shutdown(mp, SHUTDOWN_CORRUPT_INCORE);\n\t}\n#ifdef DEBUG\n\tif (!(flags & XFS_TRANS_ABORT) && !XFS_FORCED_SHUTDOWN(mp)) {\n\t\tstruct xfs_log_item_desc *lidp;\n\n\t\tlist_for_each_entry(lidp, &tp->t_items, lid_trans)\n\t\t\tASSERT(!(lidp->lid_item->li_type == XFS_LI_EFD));\n\t}\n#endif\n\txfs_trans_unreserve_and_mod_sb(tp);\n\txfs_trans_unreserve_and_mod_dquots(tp);\n\n\tif (tp->t_ticket) {\n\t\tif (flags & XFS_TRANS_RELEASE_LOG_RES) {\n\t\t\tASSERT(tp->t_flags & XFS_TRANS_PERM_LOG_RES);\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(mp, tp->t_ticket, NULL, log_flags);\n\t}\n\n\t/* mark this thread as no longer being in a transaction */\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\txfs_trans_free_items(tp, NULLCOMMITLSN, flags);\n\txfs_trans_free(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_reserve",
          "args": [
            "tp",
            "&M_RES(mp)->tr_sb",
            "0",
            "0"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "168-279",
          "snippet": "int\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_trans_reserve(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_trans_res\t*resp,\n\tuint\t\t\tblocks,\n\tuint\t\t\trtextents)\n{\n\tint\t\terror = 0;\n\tint\t\trsvd = (tp->t_flags & XFS_TRANS_RESERVE) != 0;\n\n\t/* Mark this thread as being in a transaction */\n\tcurrent_set_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\t/*\n\t * Attempt to reserve the needed disk blocks by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (blocks > 0) {\n\t\terror = xfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t  -((int64_t)blocks), rsvd);\n\t\tif (error != 0) {\n\t\t\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\ttp->t_blk_res += blocks;\n\t}\n\n\t/*\n\t * Reserve the log space needed for this transaction.\n\t */\n\tif (resp->tr_logres > 0) {\n\t\tbool\tpermanent = false;\n\n\t\tASSERT(tp->t_log_res == 0 ||\n\t\t       tp->t_log_res == resp->tr_logres);\n\t\tASSERT(tp->t_log_count == 0 ||\n\t\t       tp->t_log_count == resp->tr_logcount);\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\ttp->t_flags |= XFS_TRANS_PERM_LOG_RES;\n\t\t\tpermanent = true;\n\t\t} else {\n\t\t\tASSERT(tp->t_ticket == NULL);\n\t\t\tASSERT(!(tp->t_flags & XFS_TRANS_PERM_LOG_RES));\n\t\t}\n\n\t\tif (tp->t_ticket != NULL) {\n\t\t\tASSERT(resp->tr_logflags & XFS_TRANS_PERM_LOG_RES);\n\t\t\terror = xfs_log_regrant(tp->t_mountp, tp->t_ticket);\n\t\t} else {\n\t\t\terror = xfs_log_reserve(tp->t_mountp,\n\t\t\t\t\t\tresp->tr_logres,\n\t\t\t\t\t\tresp->tr_logcount,\n\t\t\t\t\t\t&tp->t_ticket, XFS_TRANSACTION,\n\t\t\t\t\t\tpermanent, tp->t_type);\n\t\t}\n\n\t\tif (error)\n\t\t\tgoto undo_blocks;\n\n\t\ttp->t_log_res = resp->tr_logres;\n\t\ttp->t_log_count = resp->tr_logcount;\n\t}\n\n\t/*\n\t * Attempt to reserve the needed realtime extents by decrementing\n\t * the number needed from the number available.  This will\n\t * fail if the count would go below zero.\n\t */\n\tif (rtextents > 0) {\n\t\terror = xfs_mod_incore_sb(tp->t_mountp, XFS_SBS_FREXTENTS,\n\t\t\t\t\t  -((int64_t)rtextents), rsvd);\n\t\tif (error) {\n\t\t\terror = -ENOSPC;\n\t\t\tgoto undo_log;\n\t\t}\n\t\ttp->t_rtx_res += rtextents;\n\t}\n\n\treturn 0;\n\n\t/*\n\t * Error cases jump to one of these labels to undo any\n\t * reservations which have already been performed.\n\t */\nundo_log:\n\tif (resp->tr_logres > 0) {\n\t\tint\t\tlog_flags;\n\n\t\tif (resp->tr_logflags & XFS_TRANS_PERM_LOG_RES) {\n\t\t\tlog_flags = XFS_LOG_REL_PERM_RESERV;\n\t\t} else {\n\t\t\tlog_flags = 0;\n\t\t}\n\t\txfs_log_done(tp->t_mountp, tp->t_ticket, NULL, log_flags);\n\t\ttp->t_ticket = NULL;\n\t\ttp->t_log_res = 0;\n\t\ttp->t_flags &= ~XFS_TRANS_PERM_LOG_RES;\n\t}\n\nundo_blocks:\n\tif (blocks > 0) {\n\t\txfs_icsb_modify_counters(tp->t_mountp, XFS_SBS_FDBLOCKS,\n\t\t\t\t\t (int64_t)blocks, rsvd);\n\t\ttp->t_blk_res = 0;\n\t}\n\n\tcurrent_restore_flags_nested(&tp->t_pflags, PF_FSTRANS);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "M_RES",
          "args": [
            "mp"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_xfs_trans_alloc",
          "args": [
            "mp",
            "XFS_TRANS_SB_CHANGE",
            "KM_SLEEP"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "_xfs_trans_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans.c",
          "lines": "70-88",
          "snippet": "xfs_trans_t *\n_xfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype,\n\txfs_km_flags_t\tmemflags)\n{\n\txfs_trans_t\t*tp;\n\n\tWARN_ON(mp->m_super->s_writers.frozen == SB_FREEZE_COMPLETE);\n\tatomic_inc(&mp->m_active_trans);\n\n\ttp = kmem_zone_zalloc(xfs_trans_zone, memflags);\n\ttp->t_magic = XFS_TRANS_HEADER_MAGIC;\n\ttp->t_type = type;\n\ttp->t_mountp = mp;\n\tINIT_LIST_HEAD(&tp->t_items);\n\tINIT_LIST_HEAD(&tp->t_busy);\n\treturn tp;\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "kmem_zone_t\t*xfs_trans_zone;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nkmem_zone_t\t*xfs_trans_zone;\n\nxfs_trans_t *\n_xfs_trans_alloc(\n\txfs_mount_t\t*mp,\n\tuint\t\ttype,\n\txfs_km_flags_t\tmemflags)\n{\n\txfs_trans_t\t*tp;\n\n\tWARN_ON(mp->m_super->s_writers.frozen == SB_FREEZE_COMPLETE);\n\tatomic_inc(&mp->m_active_trans);\n\n\ttp = kmem_zone_zalloc(xfs_trans_zone, memflags);\n\ttp->t_magic = XFS_TRANS_HEADER_MAGIC;\n\ttp->t_type = type;\n\ttp->t_mountp = mp;\n\tINIT_LIST_HEAD(&tp->t_items);\n\tINIT_LIST_HEAD(&tp->t_busy);\n\treturn tp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_sync_sb(\n\tstruct xfs_mount\t*mp,\n\tbool\t\t\twait)\n{\n\tstruct xfs_trans\t*tp;\n\tint\t\t\terror;\n\n\ttp = _xfs_trans_alloc(mp, XFS_TRANS_SB_CHANGE, KM_SLEEP);\n\terror = xfs_trans_reserve(tp, &M_RES(mp)->tr_sb, 0, 0);\n\tif (error) {\n\t\txfs_trans_cancel(tp, 0);\n\t\treturn error;\n\t}\n\n\txfs_log_sb(tp);\n\tif (wait)\n\t\txfs_trans_set_sync(tp);\n\treturn xfs_trans_commit(tp, 0);\n}"
  },
  {
    "function_name": "xfs_log_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
    "lines": "767-777",
    "snippet": "void\nxfs_log_sb(\n\tstruct xfs_trans\t*tp)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\tstruct xfs_buf\t\t*bp = xfs_trans_getsb(tp, mp, 0);\n\n\txfs_sb_to_disk(XFS_BUF_TO_SBP(bp), &mp->m_sb);\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_SB_BUF);\n\txfs_trans_log_buf(tp, bp, 0, sizeof(struct xfs_dsb));\n}",
    "includes": [
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_trans_log_buf",
          "args": [
            "tp",
            "bp",
            "0",
            "sizeof(struct xfs_dsb)"
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_log_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "497-552",
          "snippet": "void\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_trans_log_buf(xfs_trans_t\t*tp,\n\t\t  xfs_buf_t\t*bp,\n\t\t  uint\t\tfirst,\n\t\t  uint\t\tlast)\n{\n\txfs_buf_log_item_t\t*bip = bp->b_fspriv;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(first <= last && last < BBTOB(bp->b_length));\n\tASSERT(bp->b_iodone == NULL ||\n\t       bp->b_iodone == xfs_buf_iodone_callbacks);\n\n\t/*\n\t * Mark the buffer as needing to be written out eventually,\n\t * and set its iodone function to remove the buffer's buf log\n\t * item from the AIL and free it when the buffer is flushed\n\t * to disk.  See xfs_buf_attach_iodone() for more details\n\t * on li_cb and xfs_buf_iodone_callbacks().\n\t * If we end up aborting this transaction, we trap this buffer\n\t * inside the b_bdstrat callback so that this won't get written to\n\t * disk.\n\t */\n\tXFS_BUF_DONE(bp);\n\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\tbp->b_iodone = xfs_buf_iodone_callbacks;\n\tbip->bli_item.li_cb = xfs_buf_iodone;\n\n\ttrace_xfs_trans_log_buf(bip);\n\n\t/*\n\t * If we invalidated the buffer within this transaction, then\n\t * cancel the invalidation now that we're dirtying the buffer\n\t * again.  There are no races with the code in xfs_buf_item_unpin(),\n\t * because we have a reference to the buffer this entire time.\n\t */\n\tif (bip->bli_flags & XFS_BLI_STALE) {\n\t\tbip->bli_flags &= ~XFS_BLI_STALE;\n\t\tASSERT(XFS_BUF_ISSTALE(bp));\n\t\tXFS_BUF_UNSTALE(bp);\n\t\tbip->__bli_format.blf_flags &= ~XFS_BLF_CANCEL;\n\t}\n\n\ttp->t_flags |= XFS_TRANS_DIRTY;\n\tbip->bli_item.li_desc->lid_flags |= XFS_LID_DIRTY;\n\n\t/*\n\t * If we have an ordered buffer we are not logging any dirty range but\n\t * it still needs to be marked dirty and that it has been logged.\n\t */\n\tbip->bli_flags |= XFS_BLI_DIRTY | XFS_BLI_LOGGED;\n\tif (!(bip->bli_flags & XFS_BLI_ORDERED))\n\t\txfs_buf_item_log(bip, first, last);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_trans_buf_set_type",
          "args": [
            "tp",
            "bp",
            "XFS_BLFT_SB_BUF"
          ],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_buf_set_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "730-746",
          "snippet": "void\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nvoid\nxfs_trans_buf_set_type(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_buf\t\t*bp,\n\tenum xfs_blft\t\ttype)\n{\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\n\tif (!tp)\n\t\treturn;\n\n\tASSERT(bp->b_transp == tp);\n\tASSERT(bip != NULL);\n\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\n\txfs_blft_to_flags(&bip->__bli_format, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_to_disk",
          "args": [
            "XFS_BUF_TO_SBP(bp)",
            "&mp->m_sb"
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_to_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "460-530",
          "snippet": "void\nxfs_sb_to_disk(\n\tstruct xfs_dsb\t*to,\n\tstruct xfs_sb\t*from)\n{\n\txfs_sb_quota_to_disk(to, from);\n\n\tto->sb_magicnum = cpu_to_be32(from->sb_magicnum);\n\tto->sb_blocksize = cpu_to_be32(from->sb_blocksize);\n\tto->sb_dblocks = cpu_to_be64(from->sb_dblocks);\n\tto->sb_rblocks = cpu_to_be64(from->sb_rblocks);\n\tto->sb_rextents = cpu_to_be64(from->sb_rextents);\n\tmemcpy(&to->sb_uuid, &from->sb_uuid, sizeof(to->sb_uuid));\n\tto->sb_logstart = cpu_to_be64(from->sb_logstart);\n\tto->sb_rootino = cpu_to_be64(from->sb_rootino);\n\tto->sb_rbmino = cpu_to_be64(from->sb_rbmino);\n\tto->sb_rsumino = cpu_to_be64(from->sb_rsumino);\n\tto->sb_rextsize = cpu_to_be32(from->sb_rextsize);\n\tto->sb_agblocks = cpu_to_be32(from->sb_agblocks);\n\tto->sb_agcount = cpu_to_be32(from->sb_agcount);\n\tto->sb_rbmblocks = cpu_to_be32(from->sb_rbmblocks);\n\tto->sb_logblocks = cpu_to_be32(from->sb_logblocks);\n\tto->sb_versionnum = cpu_to_be16(from->sb_versionnum);\n\tto->sb_sectsize = cpu_to_be16(from->sb_sectsize);\n\tto->sb_inodesize = cpu_to_be16(from->sb_inodesize);\n\tto->sb_inopblock = cpu_to_be16(from->sb_inopblock);\n\tmemcpy(&to->sb_fname, &from->sb_fname, sizeof(to->sb_fname));\n\tto->sb_blocklog = from->sb_blocklog;\n\tto->sb_sectlog = from->sb_sectlog;\n\tto->sb_inodelog = from->sb_inodelog;\n\tto->sb_inopblog = from->sb_inopblog;\n\tto->sb_agblklog = from->sb_agblklog;\n\tto->sb_rextslog = from->sb_rextslog;\n\tto->sb_inprogress = from->sb_inprogress;\n\tto->sb_imax_pct = from->sb_imax_pct;\n\tto->sb_icount = cpu_to_be64(from->sb_icount);\n\tto->sb_ifree = cpu_to_be64(from->sb_ifree);\n\tto->sb_fdblocks = cpu_to_be64(from->sb_fdblocks);\n\tto->sb_frextents = cpu_to_be64(from->sb_frextents);\n\n\tto->sb_flags = from->sb_flags;\n\tto->sb_shared_vn = from->sb_shared_vn;\n\tto->sb_inoalignmt = cpu_to_be32(from->sb_inoalignmt);\n\tto->sb_unit = cpu_to_be32(from->sb_unit);\n\tto->sb_width = cpu_to_be32(from->sb_width);\n\tto->sb_dirblklog = from->sb_dirblklog;\n\tto->sb_logsectlog = from->sb_logsectlog;\n\tto->sb_logsectsize = cpu_to_be16(from->sb_logsectsize);\n\tto->sb_logsunit = cpu_to_be32(from->sb_logsunit);\n\n\t/*\n\t * We need to ensure that bad_features2 always matches features2.\n\t * Hence we enforce that here rather than having to remember to do it\n\t * everywhere else that updates features2.\n\t */\n\tfrom->sb_bad_features2 = from->sb_features2;\n\tto->sb_features2 = cpu_to_be32(from->sb_features2);\n\tto->sb_bad_features2 = cpu_to_be32(from->sb_bad_features2);\n\n\tif (xfs_sb_version_hascrc(from)) {\n\t\tto->sb_features_compat = cpu_to_be32(from->sb_features_compat);\n\t\tto->sb_features_ro_compat =\n\t\t\t\tcpu_to_be32(from->sb_features_ro_compat);\n\t\tto->sb_features_incompat =\n\t\t\t\tcpu_to_be32(from->sb_features_incompat);\n\t\tto->sb_features_log_incompat =\n\t\t\t\tcpu_to_be32(from->sb_features_log_incompat);\n\t\tto->sb_pad = 0;\n\t\tto->sb_lsn = cpu_to_be64(from->sb_lsn);\n\t}\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_sb_to_disk(\n\tstruct xfs_dsb\t*to,\n\tstruct xfs_sb\t*from)\n{\n\txfs_sb_quota_to_disk(to, from);\n\n\tto->sb_magicnum = cpu_to_be32(from->sb_magicnum);\n\tto->sb_blocksize = cpu_to_be32(from->sb_blocksize);\n\tto->sb_dblocks = cpu_to_be64(from->sb_dblocks);\n\tto->sb_rblocks = cpu_to_be64(from->sb_rblocks);\n\tto->sb_rextents = cpu_to_be64(from->sb_rextents);\n\tmemcpy(&to->sb_uuid, &from->sb_uuid, sizeof(to->sb_uuid));\n\tto->sb_logstart = cpu_to_be64(from->sb_logstart);\n\tto->sb_rootino = cpu_to_be64(from->sb_rootino);\n\tto->sb_rbmino = cpu_to_be64(from->sb_rbmino);\n\tto->sb_rsumino = cpu_to_be64(from->sb_rsumino);\n\tto->sb_rextsize = cpu_to_be32(from->sb_rextsize);\n\tto->sb_agblocks = cpu_to_be32(from->sb_agblocks);\n\tto->sb_agcount = cpu_to_be32(from->sb_agcount);\n\tto->sb_rbmblocks = cpu_to_be32(from->sb_rbmblocks);\n\tto->sb_logblocks = cpu_to_be32(from->sb_logblocks);\n\tto->sb_versionnum = cpu_to_be16(from->sb_versionnum);\n\tto->sb_sectsize = cpu_to_be16(from->sb_sectsize);\n\tto->sb_inodesize = cpu_to_be16(from->sb_inodesize);\n\tto->sb_inopblock = cpu_to_be16(from->sb_inopblock);\n\tmemcpy(&to->sb_fname, &from->sb_fname, sizeof(to->sb_fname));\n\tto->sb_blocklog = from->sb_blocklog;\n\tto->sb_sectlog = from->sb_sectlog;\n\tto->sb_inodelog = from->sb_inodelog;\n\tto->sb_inopblog = from->sb_inopblog;\n\tto->sb_agblklog = from->sb_agblklog;\n\tto->sb_rextslog = from->sb_rextslog;\n\tto->sb_inprogress = from->sb_inprogress;\n\tto->sb_imax_pct = from->sb_imax_pct;\n\tto->sb_icount = cpu_to_be64(from->sb_icount);\n\tto->sb_ifree = cpu_to_be64(from->sb_ifree);\n\tto->sb_fdblocks = cpu_to_be64(from->sb_fdblocks);\n\tto->sb_frextents = cpu_to_be64(from->sb_frextents);\n\n\tto->sb_flags = from->sb_flags;\n\tto->sb_shared_vn = from->sb_shared_vn;\n\tto->sb_inoalignmt = cpu_to_be32(from->sb_inoalignmt);\n\tto->sb_unit = cpu_to_be32(from->sb_unit);\n\tto->sb_width = cpu_to_be32(from->sb_width);\n\tto->sb_dirblklog = from->sb_dirblklog;\n\tto->sb_logsectlog = from->sb_logsectlog;\n\tto->sb_logsectsize = cpu_to_be16(from->sb_logsectsize);\n\tto->sb_logsunit = cpu_to_be32(from->sb_logsunit);\n\n\t/*\n\t * We need to ensure that bad_features2 always matches features2.\n\t * Hence we enforce that here rather than having to remember to do it\n\t * everywhere else that updates features2.\n\t */\n\tfrom->sb_bad_features2 = from->sb_features2;\n\tto->sb_features2 = cpu_to_be32(from->sb_features2);\n\tto->sb_bad_features2 = cpu_to_be32(from->sb_bad_features2);\n\n\tif (xfs_sb_version_hascrc(from)) {\n\t\tto->sb_features_compat = cpu_to_be32(from->sb_features_compat);\n\t\tto->sb_features_ro_compat =\n\t\t\t\tcpu_to_be32(from->sb_features_ro_compat);\n\t\tto->sb_features_incompat =\n\t\t\t\tcpu_to_be32(from->sb_features_incompat);\n\t\tto->sb_features_log_incompat =\n\t\t\t\tcpu_to_be32(from->sb_features_log_incompat);\n\t\tto->sb_pad = 0;\n\t\tto->sb_lsn = cpu_to_be64(from->sb_lsn);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_SBP",
          "args": [
            "bp"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_trans_getsb",
          "args": [
            "tp",
            "mp",
            "0"
          ],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_trans_getsb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_trans_buf.c",
          "lines": "190-228",
          "snippet": "xfs_buf_t *\nxfs_trans_getsb(xfs_trans_t\t*tp,\n\t\tstruct xfs_mount *mp,\n\t\tint\t\tflags)\n{\n\txfs_buf_t\t\t*bp;\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to just trying to lock the superblock buffer\n\t * if tp is NULL.\n\t */\n\tif (tp == NULL)\n\t\treturn xfs_getsb(mp, flags);\n\n\t/*\n\t * If the superblock buffer already has this transaction\n\t * pointer in its b_fsprivate2 field, then we know we already\n\t * have it locked.  In this case we just increment the lock\n\t * recursion count and return the buffer to the caller.\n\t */\n\tbp = mp->m_sb_bp;\n\tif (bp->b_transp == tp) {\n\t\tbip = bp->b_fspriv;\n\t\tASSERT(bip != NULL);\n\t\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\t\tbip->bli_recur++;\n\t\ttrace_xfs_trans_getsb_recur(bip);\n\t\treturn bp;\n\t}\n\n\tbp = xfs_getsb(mp, flags);\n\tif (bp == NULL)\n\t\treturn NULL;\n\n\t_xfs_trans_bjoin(tp, bp, 1);\n\ttrace_xfs_trans_getsb(bp->b_fspriv);\n\treturn bp;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nxfs_buf_t *\nxfs_trans_getsb(xfs_trans_t\t*tp,\n\t\tstruct xfs_mount *mp,\n\t\tint\t\tflags)\n{\n\txfs_buf_t\t\t*bp;\n\txfs_buf_log_item_t\t*bip;\n\n\t/*\n\t * Default to just trying to lock the superblock buffer\n\t * if tp is NULL.\n\t */\n\tif (tp == NULL)\n\t\treturn xfs_getsb(mp, flags);\n\n\t/*\n\t * If the superblock buffer already has this transaction\n\t * pointer in its b_fsprivate2 field, then we know we already\n\t * have it locked.  In this case we just increment the lock\n\t * recursion count and return the buffer to the caller.\n\t */\n\tbp = mp->m_sb_bp;\n\tif (bp->b_transp == tp) {\n\t\tbip = bp->b_fspriv;\n\t\tASSERT(bip != NULL);\n\t\tASSERT(atomic_read(&bip->bli_refcount) > 0);\n\t\tbip->bli_recur++;\n\t\ttrace_xfs_trans_getsb_recur(bip);\n\t\treturn bp;\n\t}\n\n\tbp = xfs_getsb(mp, flags);\n\tif (bp == NULL)\n\t\treturn NULL;\n\n\t_xfs_trans_bjoin(tp, bp, 1);\n\ttrace_xfs_trans_getsb(bp->b_fspriv);\n\treturn bp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_log_sb(\n\tstruct xfs_trans\t*tp)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\tstruct xfs_buf\t\t*bp = xfs_trans_getsb(tp, mp, 0);\n\n\txfs_sb_to_disk(XFS_BUF_TO_SBP(bp), &mp->m_sb);\n\txfs_trans_buf_set_type(tp, bp, XFS_BLFT_SB_BUF);\n\txfs_trans_log_buf(tp, bp, 0, sizeof(struct xfs_dsb));\n}"
  },
  {
    "function_name": "xfs_initialize_perag_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
    "lines": "710-759",
    "snippet": "int\nxfs_initialize_perag_data(\n\tstruct xfs_mount *mp,\n\txfs_agnumber_t\tagcount)\n{\n\txfs_agnumber_t\tindex;\n\txfs_perag_t\t*pag;\n\txfs_sb_t\t*sbp = &mp->m_sb;\n\tuint64_t\tifree = 0;\n\tuint64_t\tialloc = 0;\n\tuint64_t\tbfree = 0;\n\tuint64_t\tbfreelst = 0;\n\tuint64_t\tbtree = 0;\n\tint\t\terror;\n\n\tfor (index = 0; index < agcount; index++) {\n\t\t/*\n\t\t * read the agf, then the agi. This gets us\n\t\t * all the information we need and populates the\n\t\t * per-ag structures for us.\n\t\t */\n\t\terror = xfs_alloc_pagf_init(mp, NULL, index, 0);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = xfs_ialloc_pagi_init(mp, NULL, index);\n\t\tif (error)\n\t\t\treturn error;\n\t\tpag = xfs_perag_get(mp, index);\n\t\tifree += pag->pagi_freecount;\n\t\tialloc += pag->pagi_count;\n\t\tbfree += pag->pagf_freeblks;\n\t\tbfreelst += pag->pagf_flcount;\n\t\tbtree += pag->pagf_btreeblks;\n\t\txfs_perag_put(pag);\n\t}\n\t/*\n\t * Overwrite incore superblock counters with just-read data\n\t */\n\tspin_lock(&mp->m_sb_lock);\n\tsbp->sb_ifree = ifree;\n\tsbp->sb_icount = ialloc;\n\tsbp->sb_fdblocks = bfree + bfreelst + btree;\n\tspin_unlock(&mp->m_sb_lock);\n\n\t/* Fixup the per-cpu counters as well. */\n\txfs_icsb_reinit_counters(mp);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_icsb_reinit_counters",
          "args": [
            "mp"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_icsb_reinit_counters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "1562-1576",
          "snippet": "void\nxfs_icsb_reinit_counters(\n\txfs_mount_t\t*mp)\n{\n\txfs_icsb_lock(mp);\n\t/*\n\t * start with all counters disabled so that the\n\t * initial balance kicks us off correctly\n\t */\n\tmp->m_icsb_counters = -1;\n\txfs_icsb_balance_counter(mp, XFS_SBS_ICOUNT, 0);\n\txfs_icsb_balance_counter(mp, XFS_SBS_IFREE, 0);\n\txfs_icsb_balance_counter(mp, XFS_SBS_FDBLOCKS, 0);\n\txfs_icsb_unlock(mp);\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_icsb_reinit_counters(\n\txfs_mount_t\t*mp)\n{\n\txfs_icsb_lock(mp);\n\t/*\n\t * start with all counters disabled so that the\n\t * initial balance kicks us off correctly\n\t */\n\tmp->m_icsb_counters = -1;\n\txfs_icsb_balance_counter(mp, XFS_SBS_ICOUNT, 0);\n\txfs_icsb_balance_counter(mp, XFS_SBS_IFREE, 0);\n\txfs_icsb_balance_counter(mp, XFS_SBS_FDBLOCKS, 0);\n\txfs_icsb_unlock(mp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&mp->m_sb_lock"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&mp->m_sb_lock"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_perag_put",
          "args": [
            "pag"
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "93-102",
          "snippet": "void\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_perag_get",
          "args": [
            "mp",
            "index"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_perag_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "48-65",
          "snippet": "struct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstruct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_ialloc_pagi_init",
          "args": [
            "mp",
            "NULL",
            "index"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_ialloc_pagi_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc.c",
          "lines": "2182-2197",
          "snippet": "int\nxfs_ialloc_pagi_init(\n\txfs_mount_t\t*mp,\t\t/* file system mount structure */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_agnumber_t\tagno)\t\t/* allocation group number */\n{\n\txfs_buf_t\t*bp = NULL;\n\tint\t\terror;\n\n\terror = xfs_ialloc_read_agi(mp, tp, agno, &bp);\n\tif (error)\n\t\treturn error;\n\tif (bp)\n\t\txfs_trans_brelse(tp, bp);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_trace.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_icreate_item.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trace.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_icreate_item.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_error.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_ialloc_pagi_init(\n\txfs_mount_t\t*mp,\t\t/* file system mount structure */\n\txfs_trans_t\t*tp,\t\t/* transaction pointer */\n\txfs_agnumber_t\tagno)\t\t/* allocation group number */\n{\n\txfs_buf_t\t*bp = NULL;\n\tint\t\terror;\n\n\terror = xfs_ialloc_read_agi(mp, tp, agno, &bp);\n\tif (error)\n\t\treturn error;\n\tif (bp)\n\t\txfs_trans_brelse(tp, bp);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_alloc_pagf_init",
          "args": [
            "mp",
            "NULL",
            "index",
            "0"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alloc_pagf_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc.c",
          "lines": "2115-2130",
          "snippet": "int\t\t\t\t\t/* error */\nxfs_alloc_pagf_init(\n\txfs_mount_t\t\t*mp,\t/* file system mount structure */\n\txfs_trans_t\t\t*tp,\t/* transaction pointer */\n\txfs_agnumber_t\t\tagno,\t/* allocation group number */\n\tint\t\t\tflags)\t/* XFS_ALLOC_FLAGS_... */\n{\n\txfs_buf_t\t\t*bp;\n\tint\t\t\terror;\n\n\tif ((error = xfs_alloc_read_agf(mp, tp, agno, flags, &bp)))\n\t\treturn error;\n\tif (bp)\n\t\txfs_trans_brelse(tp, bp);\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\t\t\t\t\t/* error */\nxfs_alloc_pagf_init(\n\txfs_mount_t\t\t*mp,\t/* file system mount structure */\n\txfs_trans_t\t\t*tp,\t/* transaction pointer */\n\txfs_agnumber_t\t\tagno,\t/* allocation group number */\n\tint\t\t\tflags)\t/* XFS_ALLOC_FLAGS_... */\n{\n\txfs_buf_t\t\t*bp;\n\tint\t\t\terror;\n\n\tif ((error = xfs_alloc_read_agf(mp, tp, agno, flags, &bp)))\n\t\treturn error;\n\tif (bp)\n\t\txfs_trans_brelse(tp, bp);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_initialize_perag_data(\n\tstruct xfs_mount *mp,\n\txfs_agnumber_t\tagcount)\n{\n\txfs_agnumber_t\tindex;\n\txfs_perag_t\t*pag;\n\txfs_sb_t\t*sbp = &mp->m_sb;\n\tuint64_t\tifree = 0;\n\tuint64_t\tialloc = 0;\n\tuint64_t\tbfree = 0;\n\tuint64_t\tbfreelst = 0;\n\tuint64_t\tbtree = 0;\n\tint\t\terror;\n\n\tfor (index = 0; index < agcount; index++) {\n\t\t/*\n\t\t * read the agf, then the agi. This gets us\n\t\t * all the information we need and populates the\n\t\t * per-ag structures for us.\n\t\t */\n\t\terror = xfs_alloc_pagf_init(mp, NULL, index, 0);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\terror = xfs_ialloc_pagi_init(mp, NULL, index);\n\t\tif (error)\n\t\t\treturn error;\n\t\tpag = xfs_perag_get(mp, index);\n\t\tifree += pag->pagi_freecount;\n\t\tialloc += pag->pagi_count;\n\t\tbfree += pag->pagf_freeblks;\n\t\tbfreelst += pag->pagf_flcount;\n\t\tbtree += pag->pagf_btreeblks;\n\t\txfs_perag_put(pag);\n\t}\n\t/*\n\t * Overwrite incore superblock counters with just-read data\n\t */\n\tspin_lock(&mp->m_sb_lock);\n\tsbp->sb_ifree = ifree;\n\tsbp->sb_icount = ialloc;\n\tsbp->sb_fdblocks = bfree + bfreelst + btree;\n\tspin_unlock(&mp->m_sb_lock);\n\n\t/* Fixup the per-cpu counters as well. */\n\txfs_icsb_reinit_counters(mp);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_sb_mount_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
    "lines": "664-700",
    "snippet": "void\nxfs_sb_mount_common(\n\tstruct xfs_mount *mp,\n\tstruct xfs_sb\t*sbp)\n{\n\tmp->m_agfrotor = mp->m_agirotor = 0;\n\tspin_lock_init(&mp->m_agirotor_lock);\n\tmp->m_maxagi = mp->m_sb.sb_agcount;\n\tmp->m_blkbit_log = sbp->sb_blocklog + XFS_NBBYLOG;\n\tmp->m_blkbb_log = sbp->sb_blocklog - BBSHIFT;\n\tmp->m_sectbb_log = sbp->sb_sectlog - BBSHIFT;\n\tmp->m_agno_log = xfs_highbit32(sbp->sb_agcount - 1) + 1;\n\tmp->m_agino_log = sbp->sb_inopblog + sbp->sb_agblklog;\n\tmp->m_blockmask = sbp->sb_blocksize - 1;\n\tmp->m_blockwsize = sbp->sb_blocksize >> XFS_WORDLOG;\n\tmp->m_blockwmask = mp->m_blockwsize - 1;\n\n\tmp->m_alloc_mxr[0] = xfs_allocbt_maxrecs(mp, sbp->sb_blocksize, 1);\n\tmp->m_alloc_mxr[1] = xfs_allocbt_maxrecs(mp, sbp->sb_blocksize, 0);\n\tmp->m_alloc_mnr[0] = mp->m_alloc_mxr[0] / 2;\n\tmp->m_alloc_mnr[1] = mp->m_alloc_mxr[1] / 2;\n\n\tmp->m_inobt_mxr[0] = xfs_inobt_maxrecs(mp, sbp->sb_blocksize, 1);\n\tmp->m_inobt_mxr[1] = xfs_inobt_maxrecs(mp, sbp->sb_blocksize, 0);\n\tmp->m_inobt_mnr[0] = mp->m_inobt_mxr[0] / 2;\n\tmp->m_inobt_mnr[1] = mp->m_inobt_mxr[1] / 2;\n\n\tmp->m_bmap_dmxr[0] = xfs_bmbt_maxrecs(mp, sbp->sb_blocksize, 1);\n\tmp->m_bmap_dmxr[1] = xfs_bmbt_maxrecs(mp, sbp->sb_blocksize, 0);\n\tmp->m_bmap_dmnr[0] = mp->m_bmap_dmxr[0] / 2;\n\tmp->m_bmap_dmnr[1] = mp->m_bmap_dmxr[1] / 2;\n\n\tmp->m_bsize = XFS_FSB_TO_BB(mp, 1);\n\tmp->m_ialloc_inos = (int)MAX((__uint16_t)XFS_INODES_PER_CHUNK,\n\t\t\t\t\tsbp->sb_inopblock);\n\tmp->m_ialloc_blks = mp->m_ialloc_inos >> sbp->sb_inopblog;\n}",
    "includes": [
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "MAX",
          "args": [
            "(__uint16_t)XFS_INODES_PER_CHUNK",
            "sbp->sb_inopblock"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_FSB_TO_BB",
          "args": [
            "mp",
            "1"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_bmbt_maxrecs",
          "args": [
            "mp",
            "sbp->sb_blocksize",
            "0"
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_bmbt_maxrecs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bmap_btree.c",
          "lines": "813-824",
          "snippet": "int\nxfs_bmbt_maxrecs(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tblocklen,\n\tint\t\t\tleaf)\n{\n\tblocklen -= XFS_BMBT_BLOCK_LEN(mp);\n\n\tif (leaf)\n\t\treturn blocklen / sizeof(xfs_bmbt_rec_t);\n\treturn blocklen / (sizeof(xfs_bmbt_key_t) + sizeof(xfs_bmbt_ptr_t));\n}",
          "includes": [
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_inode_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_inode_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nint\nxfs_bmbt_maxrecs(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tblocklen,\n\tint\t\t\tleaf)\n{\n\tblocklen -= XFS_BMBT_BLOCK_LEN(mp);\n\n\tif (leaf)\n\t\treturn blocklen / sizeof(xfs_bmbt_rec_t);\n\treturn blocklen / (sizeof(xfs_bmbt_key_t) + sizeof(xfs_bmbt_ptr_t));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_inobt_maxrecs",
          "args": [
            "mp",
            "sbp->sb_blocksize",
            "0"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_inobt_maxrecs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_ialloc_btree.c",
          "lines": "409-420",
          "snippet": "int\nxfs_inobt_maxrecs(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tblocklen,\n\tint\t\t\tleaf)\n{\n\tblocklen -= XFS_INOBT_BLOCK_LEN(mp);\n\n\tif (leaf)\n\t\treturn blocklen / sizeof(xfs_inobt_rec_t);\n\treturn blocklen / (sizeof(xfs_inobt_key_t) + sizeof(xfs_inobt_ptr_t));\n}",
          "includes": [
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc_btree.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nint\nxfs_inobt_maxrecs(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tblocklen,\n\tint\t\t\tleaf)\n{\n\tblocklen -= XFS_INOBT_BLOCK_LEN(mp);\n\n\tif (leaf)\n\t\treturn blocklen / sizeof(xfs_inobt_rec_t);\n\treturn blocklen / (sizeof(xfs_inobt_key_t) + sizeof(xfs_inobt_ptr_t));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_allocbt_maxrecs",
          "args": [
            "mp",
            "sbp->sb_blocksize",
            "0"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_allocbt_maxrecs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_alloc_btree.c",
          "lines": "492-503",
          "snippet": "int\nxfs_allocbt_maxrecs(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tblocklen,\n\tint\t\t\tleaf)\n{\n\tblocklen -= XFS_ALLOC_BLOCK_LEN(mp);\n\n\tif (leaf)\n\t\treturn blocklen / sizeof(xfs_alloc_rec_t);\n\treturn blocklen / (sizeof(xfs_alloc_key_t) + sizeof(xfs_alloc_ptr_t));\n}",
          "includes": [
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_extent_busy.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_btree.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "STATIC struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_extent_busy.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_btree.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC struct;\n\nint\nxfs_allocbt_maxrecs(\n\tstruct xfs_mount\t*mp,\n\tint\t\t\tblocklen,\n\tint\t\t\tleaf)\n{\n\tblocklen -= XFS_ALLOC_BLOCK_LEN(mp);\n\n\tif (leaf)\n\t\treturn blocklen / sizeof(xfs_alloc_rec_t);\n\treturn blocklen / (sizeof(xfs_alloc_key_t) + sizeof(xfs_alloc_ptr_t));\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_highbit32",
          "args": [
            "sbp->sb_agcount - 1"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_highbit32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_bit.h",
          "lines": "42-45",
          "snippet": "static inline int xfs_highbit32(__uint32_t v)\n{\n\treturn fls(v) - 1;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int xfs_highbit32(__uint32_t v)\n{\n\treturn fls(v) - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&mp->m_agirotor_lock"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_sb_mount_common(\n\tstruct xfs_mount *mp,\n\tstruct xfs_sb\t*sbp)\n{\n\tmp->m_agfrotor = mp->m_agirotor = 0;\n\tspin_lock_init(&mp->m_agirotor_lock);\n\tmp->m_maxagi = mp->m_sb.sb_agcount;\n\tmp->m_blkbit_log = sbp->sb_blocklog + XFS_NBBYLOG;\n\tmp->m_blkbb_log = sbp->sb_blocklog - BBSHIFT;\n\tmp->m_sectbb_log = sbp->sb_sectlog - BBSHIFT;\n\tmp->m_agno_log = xfs_highbit32(sbp->sb_agcount - 1) + 1;\n\tmp->m_agino_log = sbp->sb_inopblog + sbp->sb_agblklog;\n\tmp->m_blockmask = sbp->sb_blocksize - 1;\n\tmp->m_blockwsize = sbp->sb_blocksize >> XFS_WORDLOG;\n\tmp->m_blockwmask = mp->m_blockwsize - 1;\n\n\tmp->m_alloc_mxr[0] = xfs_allocbt_maxrecs(mp, sbp->sb_blocksize, 1);\n\tmp->m_alloc_mxr[1] = xfs_allocbt_maxrecs(mp, sbp->sb_blocksize, 0);\n\tmp->m_alloc_mnr[0] = mp->m_alloc_mxr[0] / 2;\n\tmp->m_alloc_mnr[1] = mp->m_alloc_mxr[1] / 2;\n\n\tmp->m_inobt_mxr[0] = xfs_inobt_maxrecs(mp, sbp->sb_blocksize, 1);\n\tmp->m_inobt_mxr[1] = xfs_inobt_maxrecs(mp, sbp->sb_blocksize, 0);\n\tmp->m_inobt_mnr[0] = mp->m_inobt_mxr[0] / 2;\n\tmp->m_inobt_mnr[1] = mp->m_inobt_mxr[1] / 2;\n\n\tmp->m_bmap_dmxr[0] = xfs_bmbt_maxrecs(mp, sbp->sb_blocksize, 1);\n\tmp->m_bmap_dmxr[1] = xfs_bmbt_maxrecs(mp, sbp->sb_blocksize, 0);\n\tmp->m_bmap_dmnr[0] = mp->m_bmap_dmxr[0] / 2;\n\tmp->m_bmap_dmnr[1] = mp->m_bmap_dmxr[1] / 2;\n\n\tmp->m_bsize = XFS_FSB_TO_BB(mp, 1);\n\tmp->m_ialloc_inos = (int)MAX((__uint16_t)XFS_INODES_PER_CHUNK,\n\t\t\t\t\tsbp->sb_inopblock);\n\tmp->m_ialloc_blks = mp->m_ialloc_inos >> sbp->sb_inopblog;\n}"
  },
  {
    "function_name": "xfs_sb_write_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
    "lines": "623-645",
    "snippet": "static void\nxfs_sb_write_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\tint\t\t\terror;\n\n\terror = xfs_sb_verify(bp, false);\n\tif (error) {\n\t\txfs_buf_ioerror(bp, error);\n\t\txfs_verifier_error(bp);\n\t\treturn;\n\t}\n\n\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn;\n\n\tif (bip)\n\t\tXFS_BUF_TO_SBP(bp)->sb_lsn = cpu_to_be64(bip->bli_item.li_lsn);\n\n\txfs_buf_update_cksum(bp, XFS_SB_CRC_OFF);\n}",
    "includes": [
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_update_cksum",
          "args": [
            "bp",
            "XFS_SB_CRC_OFF"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_update_cksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "374-379",
          "snippet": "static inline void\nxfs_buf_update_cksum(struct xfs_buf *bp, unsigned long cksum_offset)\n{\n\txfs_update_cksum(bp->b_addr, BBTOB(bp->b_length),\n\t\t\t cksum_offset);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline void\nxfs_buf_update_cksum(struct xfs_buf *bp, unsigned long cksum_offset)\n{\n\txfs_update_cksum(bp->b_addr, BBTOB(bp->b_length),\n\t\t\t cksum_offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "bip->bli_item.li_lsn"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_SBP",
          "args": [
            "bp"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_verifier_error",
          "args": [
            "bp"
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_verifier_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_error.c",
          "lines": "161-180",
          "snippet": "void\nxfs_verifier_error(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\txfs_alert(mp, \"Metadata %s detected at %pF, block 0x%llx\",\n\t\t  bp->b_error == -EFSBADCRC ? \"CRC error\" : \"corruption\",\n\t\t  __return_address, bp->b_bn);\n\n\txfs_alert(mp, \"Unmount and run xfs_repair\");\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\txfs_alert(mp, \"First 64 bytes of corrupted metadata buffer:\");\n\t\txfs_hex_dump(xfs_buf_offset(bp, 0), 64);\n\t}\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_HIGH)\n\t\txfs_stack_trace();\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_verifier_error(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\txfs_alert(mp, \"Metadata %s detected at %pF, block 0x%llx\",\n\t\t  bp->b_error == -EFSBADCRC ? \"CRC error\" : \"corruption\",\n\t\t  __return_address, bp->b_bn);\n\n\txfs_alert(mp, \"Unmount and run xfs_repair\");\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\txfs_alert(mp, \"First 64 bytes of corrupted metadata buffer:\");\n\t\txfs_hex_dump(xfs_buf_offset(bp, 0), 64);\n\t}\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_HIGH)\n\t\txfs_stack_trace();\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_ioerror",
          "args": [
            "bp",
            "error"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_ioerror_alert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1067-1075",
          "snippet": "void\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_verify",
          "args": [
            "bp",
            "false"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "532-552",
          "snippet": "static int\nxfs_sb_verify(\n\tstruct xfs_buf\t*bp,\n\tbool\t\tcheck_version)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\tstruct xfs_sb\tsb;\n\n\t/*\n\t * Use call variant which doesn't convert quota flags from disk \n\t * format, because xfs_mount_validate_sb checks the on-disk flags.\n\t */\n\t__xfs_sb_from_disk(&sb, XFS_BUF_TO_SBP(bp), false);\n\n\t/*\n\t * Only check the in progress field for the primary superblock as\n\t * mkfs.xfs doesn't clear it from secondary superblocks.\n\t */\n\treturn xfs_mount_validate_sb(mp, &sb, bp->b_bn == XFS_SB_DADDR,\n\t\t\t\t     check_version);\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int\nxfs_sb_verify(\n\tstruct xfs_buf\t*bp,\n\tbool\t\tcheck_version)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\tstruct xfs_sb\tsb;\n\n\t/*\n\t * Use call variant which doesn't convert quota flags from disk \n\t * format, because xfs_mount_validate_sb checks the on-disk flags.\n\t */\n\t__xfs_sb_from_disk(&sb, XFS_BUF_TO_SBP(bp), false);\n\n\t/*\n\t * Only check the in progress field for the primary superblock as\n\t * mkfs.xfs doesn't clear it from secondary superblocks.\n\t */\n\treturn xfs_mount_validate_sb(mp, &sb, bp->b_bn == XFS_SB_DADDR,\n\t\t\t\t     check_version);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxfs_sb_write_verify(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount\t*mp = bp->b_target->bt_mount;\n\tstruct xfs_buf_log_item\t*bip = bp->b_fspriv;\n\tint\t\t\terror;\n\n\terror = xfs_sb_verify(bp, false);\n\tif (error) {\n\t\txfs_buf_ioerror(bp, error);\n\t\txfs_verifier_error(bp);\n\t\treturn;\n\t}\n\n\tif (!xfs_sb_version_hascrc(&mp->m_sb))\n\t\treturn;\n\n\tif (bip)\n\t\tXFS_BUF_TO_SBP(bp)->sb_lsn = cpu_to_be64(bip->bli_item.li_lsn);\n\n\txfs_buf_update_cksum(bp, XFS_SB_CRC_OFF);\n}"
  },
  {
    "function_name": "xfs_sb_quiet_read_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
    "lines": "608-621",
    "snippet": "static void\nxfs_sb_quiet_read_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_dsb\t*dsb = XFS_BUF_TO_SBP(bp);\n\n\tif (dsb->sb_magicnum == cpu_to_be32(XFS_SB_MAGIC)) {\n\t\t/* XFS filesystem, verify noisily! */\n\t\txfs_sb_read_verify(bp);\n\t\treturn;\n\t}\n\t/* quietly fail */\n\txfs_buf_ioerror(bp, -EWRONGFS);\n}",
    "includes": [
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_buf_ioerror",
          "args": [
            "bp",
            "-EWRONGFS"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_ioerror_alert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1067-1075",
          "snippet": "void\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_read_verify",
          "args": [
            "bp"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_read_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "566-600",
          "snippet": "static void\nxfs_sb_read_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\tstruct xfs_dsb\t*dsb = XFS_BUF_TO_SBP(bp);\n\tint\t\terror;\n\n\t/*\n\t * open code the version check to avoid needing to convert the entire\n\t * superblock from disk order just to check the version number\n\t */\n\tif (dsb->sb_magicnum == cpu_to_be32(XFS_SB_MAGIC) &&\n\t    (((be16_to_cpu(dsb->sb_versionnum) & XFS_SB_VERSION_NUMBITS) ==\n\t\t\t\t\t\tXFS_SB_VERSION_5) ||\n\t     dsb->sb_crc != 0)) {\n\n\t\tif (!xfs_buf_verify_cksum(bp, XFS_SB_CRC_OFF)) {\n\t\t\t/* Only fail bad secondaries on a known V5 filesystem */\n\t\t\tif (bp->b_bn == XFS_SB_DADDR ||\n\t\t\t    xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\t\t\terror = -EFSBADCRC;\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t}\n\t}\n\terror = xfs_sb_verify(bp, true);\n\nout_error:\n\tif (error) {\n\t\txfs_buf_ioerror(bp, error);\n\t\tif (error == -EFSCORRUPTED || error == -EFSBADCRC)\n\t\t\txfs_verifier_error(bp);\n\t}\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxfs_sb_read_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\tstruct xfs_dsb\t*dsb = XFS_BUF_TO_SBP(bp);\n\tint\t\terror;\n\n\t/*\n\t * open code the version check to avoid needing to convert the entire\n\t * superblock from disk order just to check the version number\n\t */\n\tif (dsb->sb_magicnum == cpu_to_be32(XFS_SB_MAGIC) &&\n\t    (((be16_to_cpu(dsb->sb_versionnum) & XFS_SB_VERSION_NUMBITS) ==\n\t\t\t\t\t\tXFS_SB_VERSION_5) ||\n\t     dsb->sb_crc != 0)) {\n\n\t\tif (!xfs_buf_verify_cksum(bp, XFS_SB_CRC_OFF)) {\n\t\t\t/* Only fail bad secondaries on a known V5 filesystem */\n\t\t\tif (bp->b_bn == XFS_SB_DADDR ||\n\t\t\t    xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\t\t\terror = -EFSBADCRC;\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t}\n\t}\n\terror = xfs_sb_verify(bp, true);\n\nout_error:\n\tif (error) {\n\t\txfs_buf_ioerror(bp, error);\n\t\tif (error == -EFSCORRUPTED || error == -EFSBADCRC)\n\t\t\txfs_verifier_error(bp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_SB_MAGIC"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_SBP",
          "args": [
            "bp"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxfs_sb_quiet_read_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_dsb\t*dsb = XFS_BUF_TO_SBP(bp);\n\n\tif (dsb->sb_magicnum == cpu_to_be32(XFS_SB_MAGIC)) {\n\t\t/* XFS filesystem, verify noisily! */\n\t\txfs_sb_read_verify(bp);\n\t\treturn;\n\t}\n\t/* quietly fail */\n\txfs_buf_ioerror(bp, -EWRONGFS);\n}"
  },
  {
    "function_name": "xfs_sb_read_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
    "lines": "566-600",
    "snippet": "static void\nxfs_sb_read_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\tstruct xfs_dsb\t*dsb = XFS_BUF_TO_SBP(bp);\n\tint\t\terror;\n\n\t/*\n\t * open code the version check to avoid needing to convert the entire\n\t * superblock from disk order just to check the version number\n\t */\n\tif (dsb->sb_magicnum == cpu_to_be32(XFS_SB_MAGIC) &&\n\t    (((be16_to_cpu(dsb->sb_versionnum) & XFS_SB_VERSION_NUMBITS) ==\n\t\t\t\t\t\tXFS_SB_VERSION_5) ||\n\t     dsb->sb_crc != 0)) {\n\n\t\tif (!xfs_buf_verify_cksum(bp, XFS_SB_CRC_OFF)) {\n\t\t\t/* Only fail bad secondaries on a known V5 filesystem */\n\t\t\tif (bp->b_bn == XFS_SB_DADDR ||\n\t\t\t    xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\t\t\terror = -EFSBADCRC;\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t}\n\t}\n\terror = xfs_sb_verify(bp, true);\n\nout_error:\n\tif (error) {\n\t\txfs_buf_ioerror(bp, error);\n\t\tif (error == -EFSCORRUPTED || error == -EFSBADCRC)\n\t\t\txfs_verifier_error(bp);\n\t}\n}",
    "includes": [
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_verifier_error",
          "args": [
            "bp"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_verifier_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_error.c",
          "lines": "161-180",
          "snippet": "void\nxfs_verifier_error(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\txfs_alert(mp, \"Metadata %s detected at %pF, block 0x%llx\",\n\t\t  bp->b_error == -EFSBADCRC ? \"CRC error\" : \"corruption\",\n\t\t  __return_address, bp->b_bn);\n\n\txfs_alert(mp, \"Unmount and run xfs_repair\");\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\txfs_alert(mp, \"First 64 bytes of corrupted metadata buffer:\");\n\t\txfs_hex_dump(xfs_buf_offset(bp, 0), 64);\n\t}\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_HIGH)\n\t\txfs_stack_trace();\n}",
          "includes": [
            "#include \"xfs_error.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_error.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs_format.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_verifier_error(\n\tstruct xfs_buf\t\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\n\txfs_alert(mp, \"Metadata %s detected at %pF, block 0x%llx\",\n\t\t  bp->b_error == -EFSBADCRC ? \"CRC error\" : \"corruption\",\n\t\t  __return_address, bp->b_bn);\n\n\txfs_alert(mp, \"Unmount and run xfs_repair\");\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_LOW) {\n\t\txfs_alert(mp, \"First 64 bytes of corrupted metadata buffer:\");\n\t\txfs_hex_dump(xfs_buf_offset(bp, 0), 64);\n\t}\n\n\tif (xfs_error_level >= XFS_ERRLEVEL_HIGH)\n\t\txfs_stack_trace();\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_ioerror",
          "args": [
            "bp",
            "error"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_ioerror_alert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.c",
          "lines": "1067-1075",
          "snippet": "void\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}",
          "includes": [
            "#include \"xfs_log.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include <linux/freezer.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/migrate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hash.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/percpu.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/bio.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/stddef.h>",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_log.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include <linux/freezer.h>\n#include <linux/backing-dev.h>\n#include <linux/migrate.h>\n#include <linux/kthread.h>\n#include <linux/hash.h>\n#include <linux/blkdev.h>\n#include <linux/percpu.h>\n#include <linux/workqueue.h>\n#include <linux/proc_fs.h>\n#include <linux/sysctl.h>\n#include <linux/bio.h>\n#include <linux/vmalloc.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include \"xfs.h\"\n\nvoid\nxfs_buf_ioerror_alert(\n\tstruct xfs_buf\t\t*bp,\n\tconst char\t\t*func)\n{\n\txfs_alert(bp->b_target->bt_mount,\n\"metadata I/O error: block 0x%llx (\\\"%s\\\") error %d numblks %d\",\n\t\t(__uint64_t)XFS_BUF_ADDR(bp), func, -bp->b_error, bp->b_length);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_verify",
          "args": [
            "bp",
            "true"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "532-552",
          "snippet": "static int\nxfs_sb_verify(\n\tstruct xfs_buf\t*bp,\n\tbool\t\tcheck_version)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\tstruct xfs_sb\tsb;\n\n\t/*\n\t * Use call variant which doesn't convert quota flags from disk \n\t * format, because xfs_mount_validate_sb checks the on-disk flags.\n\t */\n\t__xfs_sb_from_disk(&sb, XFS_BUF_TO_SBP(bp), false);\n\n\t/*\n\t * Only check the in progress field for the primary superblock as\n\t * mkfs.xfs doesn't clear it from secondary superblocks.\n\t */\n\treturn xfs_mount_validate_sb(mp, &sb, bp->b_bn == XFS_SB_DADDR,\n\t\t\t\t     check_version);\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int\nxfs_sb_verify(\n\tstruct xfs_buf\t*bp,\n\tbool\t\tcheck_version)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\tstruct xfs_sb\tsb;\n\n\t/*\n\t * Use call variant which doesn't convert quota flags from disk \n\t * format, because xfs_mount_validate_sb checks the on-disk flags.\n\t */\n\t__xfs_sb_from_disk(&sb, XFS_BUF_TO_SBP(bp), false);\n\n\t/*\n\t * Only check the in progress field for the primary superblock as\n\t * mkfs.xfs doesn't clear it from secondary superblocks.\n\t */\n\treturn xfs_mount_validate_sb(mp, &sb, bp->b_bn == XFS_SB_DADDR,\n\t\t\t\t     check_version);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "&mp->m_sb"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_buf_verify_cksum",
          "args": [
            "bp",
            "XFS_SB_CRC_OFF"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_buf_verify_cksum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_buf.h",
          "lines": "367-372",
          "snippet": "static inline int\nxfs_buf_verify_cksum(struct xfs_buf *bp, unsigned long cksum_offset)\n{\n\treturn xfs_verify_cksum(bp->b_addr, BBTOB(bp->b_length),\n\t\t\t\tcksum_offset);\n}",
          "includes": [
            "#include <linux/list_lru.h>",
            "#include <linux/uio.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/types.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/list_lru.h>\n#include <linux/uio.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/spinlock.h>\n#include <linux/types.h>\n#include <linux/list.h>\n\nstatic inline int\nxfs_buf_verify_cksum(struct xfs_buf *bp, unsigned long cksum_offset)\n{\n\treturn xfs_verify_cksum(bp->b_addr, BBTOB(bp->b_length),\n\t\t\t\tcksum_offset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "dsb->sb_versionnum"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "XFS_SB_MAGIC"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_SBP",
          "args": [
            "bp"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxfs_sb_read_verify(\n\tstruct xfs_buf\t*bp)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\tstruct xfs_dsb\t*dsb = XFS_BUF_TO_SBP(bp);\n\tint\t\terror;\n\n\t/*\n\t * open code the version check to avoid needing to convert the entire\n\t * superblock from disk order just to check the version number\n\t */\n\tif (dsb->sb_magicnum == cpu_to_be32(XFS_SB_MAGIC) &&\n\t    (((be16_to_cpu(dsb->sb_versionnum) & XFS_SB_VERSION_NUMBITS) ==\n\t\t\t\t\t\tXFS_SB_VERSION_5) ||\n\t     dsb->sb_crc != 0)) {\n\n\t\tif (!xfs_buf_verify_cksum(bp, XFS_SB_CRC_OFF)) {\n\t\t\t/* Only fail bad secondaries on a known V5 filesystem */\n\t\t\tif (bp->b_bn == XFS_SB_DADDR ||\n\t\t\t    xfs_sb_version_hascrc(&mp->m_sb)) {\n\t\t\t\terror = -EFSBADCRC;\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t}\n\t}\n\terror = xfs_sb_verify(bp, true);\n\nout_error:\n\tif (error) {\n\t\txfs_buf_ioerror(bp, error);\n\t\tif (error == -EFSCORRUPTED || error == -EFSBADCRC)\n\t\t\txfs_verifier_error(bp);\n\t}\n}"
  },
  {
    "function_name": "xfs_sb_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
    "lines": "532-552",
    "snippet": "static int\nxfs_sb_verify(\n\tstruct xfs_buf\t*bp,\n\tbool\t\tcheck_version)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\tstruct xfs_sb\tsb;\n\n\t/*\n\t * Use call variant which doesn't convert quota flags from disk \n\t * format, because xfs_mount_validate_sb checks the on-disk flags.\n\t */\n\t__xfs_sb_from_disk(&sb, XFS_BUF_TO_SBP(bp), false);\n\n\t/*\n\t * Only check the in progress field for the primary superblock as\n\t * mkfs.xfs doesn't clear it from secondary superblocks.\n\t */\n\treturn xfs_mount_validate_sb(mp, &sb, bp->b_bn == XFS_SB_DADDR,\n\t\t\t\t     check_version);\n}",
    "includes": [
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_mount_validate_sb",
          "args": [
            "mp",
            "&sb",
            "bp->b_bn == XFS_SB_DADDR",
            "check_version"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_mount_validate_sb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "107-275",
          "snippet": "STATIC int\nxfs_mount_validate_sb(\n\txfs_mount_t\t*mp,\n\txfs_sb_t\t*sbp,\n\tbool\t\tcheck_inprogress,\n\tbool\t\tcheck_version)\n{\n\n\t/*\n\t * If the log device and data device have the\n\t * same device number, the log is internal.\n\t * Consequently, the sb_logstart should be non-zero.  If\n\t * we have a zero sb_logstart in this case, we may be trying to mount\n\t * a volume filesystem in a non-volume manner.\n\t */\n\tif (sbp->sb_magicnum != XFS_SB_MAGIC) {\n\t\txfs_warn(mp, \"bad magic number\");\n\t\treturn -EWRONGFS;\n\t}\n\n\n\tif (!xfs_sb_good_version(sbp)) {\n\t\txfs_warn(mp, \"bad version\");\n\t\treturn -EWRONGFS;\n\t}\n\n\t/*\n\t * Version 5 superblock feature mask validation. Reject combinations the\n\t * kernel cannot support up front before checking anything else. For\n\t * write validation, we don't need to check feature masks.\n\t */\n\tif (check_version && XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5) {\n\t\tif (xfs_sb_has_compat_feature(sbp,\n\t\t\t\t\tXFS_SB_FEAT_COMPAT_UNKNOWN)) {\n\t\t\txfs_warn(mp,\n\"Superblock has unknown compatible features (0x%x) enabled.\\n\"\n\"Using a more recent kernel is recommended.\",\n\t\t\t\t(sbp->sb_features_compat &\n\t\t\t\t\t\tXFS_SB_FEAT_COMPAT_UNKNOWN));\n\t\t}\n\n\t\tif (xfs_sb_has_ro_compat_feature(sbp,\n\t\t\t\t\tXFS_SB_FEAT_RO_COMPAT_UNKNOWN)) {\n\t\t\txfs_alert(mp,\n\"Superblock has unknown read-only compatible features (0x%x) enabled.\",\n\t\t\t\t(sbp->sb_features_ro_compat &\n\t\t\t\t\t\tXFS_SB_FEAT_RO_COMPAT_UNKNOWN));\n\t\t\tif (!(mp->m_flags & XFS_MOUNT_RDONLY)) {\n\t\t\t\txfs_warn(mp,\n\"Attempted to mount read-only compatible filesystem read-write.\\n\"\n\"Filesystem can only be safely mounted read only.\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\tif (xfs_sb_has_incompat_feature(sbp,\n\t\t\t\t\tXFS_SB_FEAT_INCOMPAT_UNKNOWN)) {\n\t\t\txfs_warn(mp,\n\"Superblock has unknown incompatible features (0x%x) enabled.\\n\"\n\"Filesystem can not be safely mounted by this kernel.\",\n\t\t\t\t(sbp->sb_features_incompat &\n\t\t\t\t\t\tXFS_SB_FEAT_INCOMPAT_UNKNOWN));\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (xfs_sb_version_has_pquotino(sbp)) {\n\t\tif (sbp->sb_qflags & (XFS_OQUOTA_ENFD | XFS_OQUOTA_CHKD)) {\n\t\t\txfs_notice(mp,\n\t\t\t   \"Version 5 of Super block has XFS_OQUOTA bits.\");\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t} else if (sbp->sb_qflags & (XFS_PQUOTA_ENFD | XFS_GQUOTA_ENFD |\n\t\t\t\tXFS_PQUOTA_CHKD | XFS_GQUOTA_CHKD)) {\n\t\t\txfs_notice(mp,\n\"Superblock earlier than Version 5 has XFS_[PQ]UOTA_{ENFD|CHKD} bits.\");\n\t\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (unlikely(\n\t    sbp->sb_logstart == 0 && mp->m_logdev_targp == mp->m_ddev_targp)) {\n\t\txfs_warn(mp,\n\t\t\"filesystem is marked as having an external log; \"\n\t\t\"specify logdev on the mount command line.\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (unlikely(\n\t    sbp->sb_logstart != 0 && mp->m_logdev_targp != mp->m_ddev_targp)) {\n\t\txfs_warn(mp,\n\t\t\"filesystem is marked as having an internal log; \"\n\t\t\"do not specify logdev on the mount command line.\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * More sanity checking.  Most of these were stolen directly from\n\t * xfs_repair.\n\t */\n\tif (unlikely(\n\t    sbp->sb_agcount <= 0\t\t\t\t\t||\n\t    sbp->sb_sectsize < XFS_MIN_SECTORSIZE\t\t\t||\n\t    sbp->sb_sectsize > XFS_MAX_SECTORSIZE\t\t\t||\n\t    sbp->sb_sectlog < XFS_MIN_SECTORSIZE_LOG\t\t\t||\n\t    sbp->sb_sectlog > XFS_MAX_SECTORSIZE_LOG\t\t\t||\n\t    sbp->sb_sectsize != (1 << sbp->sb_sectlog)\t\t\t||\n\t    sbp->sb_blocksize < XFS_MIN_BLOCKSIZE\t\t\t||\n\t    sbp->sb_blocksize > XFS_MAX_BLOCKSIZE\t\t\t||\n\t    sbp->sb_blocklog < XFS_MIN_BLOCKSIZE_LOG\t\t\t||\n\t    sbp->sb_blocklog > XFS_MAX_BLOCKSIZE_LOG\t\t\t||\n\t    sbp->sb_blocksize != (1 << sbp->sb_blocklog)\t\t||\n\t    sbp->sb_dirblklog > XFS_MAX_BLOCKSIZE_LOG\t\t\t||\n\t    sbp->sb_inodesize < XFS_DINODE_MIN_SIZE\t\t\t||\n\t    sbp->sb_inodesize > XFS_DINODE_MAX_SIZE\t\t\t||\n\t    sbp->sb_inodelog < XFS_DINODE_MIN_LOG\t\t\t||\n\t    sbp->sb_inodelog > XFS_DINODE_MAX_LOG\t\t\t||\n\t    sbp->sb_inodesize != (1 << sbp->sb_inodelog)\t\t||\n\t    sbp->sb_logsunit > XLOG_MAX_RECORD_BSIZE\t\t\t||\n\t    sbp->sb_inopblock != howmany(sbp->sb_blocksize,sbp->sb_inodesize) ||\n\t    (sbp->sb_blocklog - sbp->sb_inodelog != sbp->sb_inopblog)\t||\n\t    (sbp->sb_rextsize * sbp->sb_blocksize > XFS_MAX_RTEXTSIZE)\t||\n\t    (sbp->sb_rextsize * sbp->sb_blocksize < XFS_MIN_RTEXTSIZE)\t||\n\t    (sbp->sb_imax_pct > 100 /* zero sb_imax_pct is valid */)\t||\n\t    sbp->sb_dblocks == 0\t\t\t\t\t||\n\t    sbp->sb_dblocks > XFS_MAX_DBLOCKS(sbp)\t\t\t||\n\t    sbp->sb_dblocks < XFS_MIN_DBLOCKS(sbp)\t\t\t||\n\t    sbp->sb_shared_vn != 0)) {\n\t\txfs_notice(mp, \"SB sanity check failed\");\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/*\n\t * Until this is fixed only page-sized or smaller data blocks work.\n\t */\n\tif (unlikely(sbp->sb_blocksize > PAGE_SIZE)) {\n\t\txfs_warn(mp,\n\t\t\"File system with blocksize %d bytes. \"\n\t\t\"Only pagesize (%ld) or less will currently work.\",\n\t\t\t\tsbp->sb_blocksize, PAGE_SIZE);\n\t\treturn -ENOSYS;\n\t}\n\n\t/*\n\t * Currently only very few inode sizes are supported.\n\t */\n\tswitch (sbp->sb_inodesize) {\n\tcase 256:\n\tcase 512:\n\tcase 1024:\n\tcase 2048:\n\t\tbreak;\n\tdefault:\n\t\txfs_warn(mp, \"inode size of %d bytes not supported\",\n\t\t\t\tsbp->sb_inodesize);\n\t\treturn -ENOSYS;\n\t}\n\n\tif (xfs_sb_validate_fsb_count(sbp, sbp->sb_dblocks) ||\n\t    xfs_sb_validate_fsb_count(sbp, sbp->sb_rblocks)) {\n\t\txfs_warn(mp,\n\t\t\"file system too large to be mounted on this system.\");\n\t\treturn -EFBIG;\n\t}\n\n\tif (check_inprogress && sbp->sb_inprogress) {\n\t\txfs_warn(mp, \"Offline file system operation in progress!\");\n\t\treturn -EFSCORRUPTED;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_mount_validate_sb(\n\txfs_mount_t\t*mp,\n\txfs_sb_t\t*sbp,\n\tbool\t\tcheck_inprogress,\n\tbool\t\tcheck_version)\n{\n\n\t/*\n\t * If the log device and data device have the\n\t * same device number, the log is internal.\n\t * Consequently, the sb_logstart should be non-zero.  If\n\t * we have a zero sb_logstart in this case, we may be trying to mount\n\t * a volume filesystem in a non-volume manner.\n\t */\n\tif (sbp->sb_magicnum != XFS_SB_MAGIC) {\n\t\txfs_warn(mp, \"bad magic number\");\n\t\treturn -EWRONGFS;\n\t}\n\n\n\tif (!xfs_sb_good_version(sbp)) {\n\t\txfs_warn(mp, \"bad version\");\n\t\treturn -EWRONGFS;\n\t}\n\n\t/*\n\t * Version 5 superblock feature mask validation. Reject combinations the\n\t * kernel cannot support up front before checking anything else. For\n\t * write validation, we don't need to check feature masks.\n\t */\n\tif (check_version && XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5) {\n\t\tif (xfs_sb_has_compat_feature(sbp,\n\t\t\t\t\tXFS_SB_FEAT_COMPAT_UNKNOWN)) {\n\t\t\txfs_warn(mp,\n\"Superblock has unknown compatible features (0x%x) enabled.\\n\"\n\"Using a more recent kernel is recommended.\",\n\t\t\t\t(sbp->sb_features_compat &\n\t\t\t\t\t\tXFS_SB_FEAT_COMPAT_UNKNOWN));\n\t\t}\n\n\t\tif (xfs_sb_has_ro_compat_feature(sbp,\n\t\t\t\t\tXFS_SB_FEAT_RO_COMPAT_UNKNOWN)) {\n\t\t\txfs_alert(mp,\n\"Superblock has unknown read-only compatible features (0x%x) enabled.\",\n\t\t\t\t(sbp->sb_features_ro_compat &\n\t\t\t\t\t\tXFS_SB_FEAT_RO_COMPAT_UNKNOWN));\n\t\t\tif (!(mp->m_flags & XFS_MOUNT_RDONLY)) {\n\t\t\t\txfs_warn(mp,\n\"Attempted to mount read-only compatible filesystem read-write.\\n\"\n\"Filesystem can only be safely mounted read only.\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\tif (xfs_sb_has_incompat_feature(sbp,\n\t\t\t\t\tXFS_SB_FEAT_INCOMPAT_UNKNOWN)) {\n\t\t\txfs_warn(mp,\n\"Superblock has unknown incompatible features (0x%x) enabled.\\n\"\n\"Filesystem can not be safely mounted by this kernel.\",\n\t\t\t\t(sbp->sb_features_incompat &\n\t\t\t\t\t\tXFS_SB_FEAT_INCOMPAT_UNKNOWN));\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (xfs_sb_version_has_pquotino(sbp)) {\n\t\tif (sbp->sb_qflags & (XFS_OQUOTA_ENFD | XFS_OQUOTA_CHKD)) {\n\t\t\txfs_notice(mp,\n\t\t\t   \"Version 5 of Super block has XFS_OQUOTA bits.\");\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t} else if (sbp->sb_qflags & (XFS_PQUOTA_ENFD | XFS_GQUOTA_ENFD |\n\t\t\t\tXFS_PQUOTA_CHKD | XFS_GQUOTA_CHKD)) {\n\t\t\txfs_notice(mp,\n\"Superblock earlier than Version 5 has XFS_[PQ]UOTA_{ENFD|CHKD} bits.\");\n\t\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (unlikely(\n\t    sbp->sb_logstart == 0 && mp->m_logdev_targp == mp->m_ddev_targp)) {\n\t\txfs_warn(mp,\n\t\t\"filesystem is marked as having an external log; \"\n\t\t\"specify logdev on the mount command line.\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (unlikely(\n\t    sbp->sb_logstart != 0 && mp->m_logdev_targp != mp->m_ddev_targp)) {\n\t\txfs_warn(mp,\n\t\t\"filesystem is marked as having an internal log; \"\n\t\t\"do not specify logdev on the mount command line.\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * More sanity checking.  Most of these were stolen directly from\n\t * xfs_repair.\n\t */\n\tif (unlikely(\n\t    sbp->sb_agcount <= 0\t\t\t\t\t||\n\t    sbp->sb_sectsize < XFS_MIN_SECTORSIZE\t\t\t||\n\t    sbp->sb_sectsize > XFS_MAX_SECTORSIZE\t\t\t||\n\t    sbp->sb_sectlog < XFS_MIN_SECTORSIZE_LOG\t\t\t||\n\t    sbp->sb_sectlog > XFS_MAX_SECTORSIZE_LOG\t\t\t||\n\t    sbp->sb_sectsize != (1 << sbp->sb_sectlog)\t\t\t||\n\t    sbp->sb_blocksize < XFS_MIN_BLOCKSIZE\t\t\t||\n\t    sbp->sb_blocksize > XFS_MAX_BLOCKSIZE\t\t\t||\n\t    sbp->sb_blocklog < XFS_MIN_BLOCKSIZE_LOG\t\t\t||\n\t    sbp->sb_blocklog > XFS_MAX_BLOCKSIZE_LOG\t\t\t||\n\t    sbp->sb_blocksize != (1 << sbp->sb_blocklog)\t\t||\n\t    sbp->sb_dirblklog > XFS_MAX_BLOCKSIZE_LOG\t\t\t||\n\t    sbp->sb_inodesize < XFS_DINODE_MIN_SIZE\t\t\t||\n\t    sbp->sb_inodesize > XFS_DINODE_MAX_SIZE\t\t\t||\n\t    sbp->sb_inodelog < XFS_DINODE_MIN_LOG\t\t\t||\n\t    sbp->sb_inodelog > XFS_DINODE_MAX_LOG\t\t\t||\n\t    sbp->sb_inodesize != (1 << sbp->sb_inodelog)\t\t||\n\t    sbp->sb_logsunit > XLOG_MAX_RECORD_BSIZE\t\t\t||\n\t    sbp->sb_inopblock != howmany(sbp->sb_blocksize,sbp->sb_inodesize) ||\n\t    (sbp->sb_blocklog - sbp->sb_inodelog != sbp->sb_inopblog)\t||\n\t    (sbp->sb_rextsize * sbp->sb_blocksize > XFS_MAX_RTEXTSIZE)\t||\n\t    (sbp->sb_rextsize * sbp->sb_blocksize < XFS_MIN_RTEXTSIZE)\t||\n\t    (sbp->sb_imax_pct > 100 /* zero sb_imax_pct is valid */)\t||\n\t    sbp->sb_dblocks == 0\t\t\t\t\t||\n\t    sbp->sb_dblocks > XFS_MAX_DBLOCKS(sbp)\t\t\t||\n\t    sbp->sb_dblocks < XFS_MIN_DBLOCKS(sbp)\t\t\t||\n\t    sbp->sb_shared_vn != 0)) {\n\t\txfs_notice(mp, \"SB sanity check failed\");\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/*\n\t * Until this is fixed only page-sized or smaller data blocks work.\n\t */\n\tif (unlikely(sbp->sb_blocksize > PAGE_SIZE)) {\n\t\txfs_warn(mp,\n\t\t\"File system with blocksize %d bytes. \"\n\t\t\"Only pagesize (%ld) or less will currently work.\",\n\t\t\t\tsbp->sb_blocksize, PAGE_SIZE);\n\t\treturn -ENOSYS;\n\t}\n\n\t/*\n\t * Currently only very few inode sizes are supported.\n\t */\n\tswitch (sbp->sb_inodesize) {\n\tcase 256:\n\tcase 512:\n\tcase 1024:\n\tcase 2048:\n\t\tbreak;\n\tdefault:\n\t\txfs_warn(mp, \"inode size of %d bytes not supported\",\n\t\t\t\tsbp->sb_inodesize);\n\t\treturn -ENOSYS;\n\t}\n\n\tif (xfs_sb_validate_fsb_count(sbp, sbp->sb_dblocks) ||\n\t    xfs_sb_validate_fsb_count(sbp, sbp->sb_rblocks)) {\n\t\txfs_warn(mp,\n\t\t\"file system too large to be mounted on this system.\");\n\t\treturn -EFBIG;\n\t}\n\n\tif (check_inprogress && sbp->sb_inprogress) {\n\t\txfs_warn(mp, \"Offline file system operation in progress!\");\n\t\treturn -EFSCORRUPTED;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__xfs_sb_from_disk",
          "args": [
            "&sb",
            "XFS_BUF_TO_SBP(bp)",
            "false"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "__xfs_sb_from_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "326-391",
          "snippet": "static void\n__xfs_sb_from_disk(\n\tstruct xfs_sb\t*to,\n\txfs_dsb_t\t*from,\n\tbool\t\tconvert_xquota)\n{\n\tto->sb_magicnum = be32_to_cpu(from->sb_magicnum);\n\tto->sb_blocksize = be32_to_cpu(from->sb_blocksize);\n\tto->sb_dblocks = be64_to_cpu(from->sb_dblocks);\n\tto->sb_rblocks = be64_to_cpu(from->sb_rblocks);\n\tto->sb_rextents = be64_to_cpu(from->sb_rextents);\n\tmemcpy(&to->sb_uuid, &from->sb_uuid, sizeof(to->sb_uuid));\n\tto->sb_logstart = be64_to_cpu(from->sb_logstart);\n\tto->sb_rootino = be64_to_cpu(from->sb_rootino);\n\tto->sb_rbmino = be64_to_cpu(from->sb_rbmino);\n\tto->sb_rsumino = be64_to_cpu(from->sb_rsumino);\n\tto->sb_rextsize = be32_to_cpu(from->sb_rextsize);\n\tto->sb_agblocks = be32_to_cpu(from->sb_agblocks);\n\tto->sb_agcount = be32_to_cpu(from->sb_agcount);\n\tto->sb_rbmblocks = be32_to_cpu(from->sb_rbmblocks);\n\tto->sb_logblocks = be32_to_cpu(from->sb_logblocks);\n\tto->sb_versionnum = be16_to_cpu(from->sb_versionnum);\n\tto->sb_sectsize = be16_to_cpu(from->sb_sectsize);\n\tto->sb_inodesize = be16_to_cpu(from->sb_inodesize);\n\tto->sb_inopblock = be16_to_cpu(from->sb_inopblock);\n\tmemcpy(&to->sb_fname, &from->sb_fname, sizeof(to->sb_fname));\n\tto->sb_blocklog = from->sb_blocklog;\n\tto->sb_sectlog = from->sb_sectlog;\n\tto->sb_inodelog = from->sb_inodelog;\n\tto->sb_inopblog = from->sb_inopblog;\n\tto->sb_agblklog = from->sb_agblklog;\n\tto->sb_rextslog = from->sb_rextslog;\n\tto->sb_inprogress = from->sb_inprogress;\n\tto->sb_imax_pct = from->sb_imax_pct;\n\tto->sb_icount = be64_to_cpu(from->sb_icount);\n\tto->sb_ifree = be64_to_cpu(from->sb_ifree);\n\tto->sb_fdblocks = be64_to_cpu(from->sb_fdblocks);\n\tto->sb_frextents = be64_to_cpu(from->sb_frextents);\n\tto->sb_uquotino = be64_to_cpu(from->sb_uquotino);\n\tto->sb_gquotino = be64_to_cpu(from->sb_gquotino);\n\tto->sb_qflags = be16_to_cpu(from->sb_qflags);\n\tto->sb_flags = from->sb_flags;\n\tto->sb_shared_vn = from->sb_shared_vn;\n\tto->sb_inoalignmt = be32_to_cpu(from->sb_inoalignmt);\n\tto->sb_unit = be32_to_cpu(from->sb_unit);\n\tto->sb_width = be32_to_cpu(from->sb_width);\n\tto->sb_dirblklog = from->sb_dirblklog;\n\tto->sb_logsectlog = from->sb_logsectlog;\n\tto->sb_logsectsize = be16_to_cpu(from->sb_logsectsize);\n\tto->sb_logsunit = be32_to_cpu(from->sb_logsunit);\n\tto->sb_features2 = be32_to_cpu(from->sb_features2);\n\tto->sb_bad_features2 = be32_to_cpu(from->sb_bad_features2);\n\tto->sb_features_compat = be32_to_cpu(from->sb_features_compat);\n\tto->sb_features_ro_compat = be32_to_cpu(from->sb_features_ro_compat);\n\tto->sb_features_incompat = be32_to_cpu(from->sb_features_incompat);\n\tto->sb_features_log_incompat =\n\t\t\t\tbe32_to_cpu(from->sb_features_log_incompat);\n\t/* crc is only used on disk, not in memory; just init to 0 here. */\n\tto->sb_crc = 0;\n\tto->sb_pad = 0;\n\tto->sb_pquotino = be64_to_cpu(from->sb_pquotino);\n\tto->sb_lsn = be64_to_cpu(from->sb_lsn);\n\t/* Convert on-disk flags to in-memory flags? */\n\tif (convert_xquota)\n\t\txfs_sb_quota_from_disk(to);\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\n__xfs_sb_from_disk(\n\tstruct xfs_sb\t*to,\n\txfs_dsb_t\t*from,\n\tbool\t\tconvert_xquota)\n{\n\tto->sb_magicnum = be32_to_cpu(from->sb_magicnum);\n\tto->sb_blocksize = be32_to_cpu(from->sb_blocksize);\n\tto->sb_dblocks = be64_to_cpu(from->sb_dblocks);\n\tto->sb_rblocks = be64_to_cpu(from->sb_rblocks);\n\tto->sb_rextents = be64_to_cpu(from->sb_rextents);\n\tmemcpy(&to->sb_uuid, &from->sb_uuid, sizeof(to->sb_uuid));\n\tto->sb_logstart = be64_to_cpu(from->sb_logstart);\n\tto->sb_rootino = be64_to_cpu(from->sb_rootino);\n\tto->sb_rbmino = be64_to_cpu(from->sb_rbmino);\n\tto->sb_rsumino = be64_to_cpu(from->sb_rsumino);\n\tto->sb_rextsize = be32_to_cpu(from->sb_rextsize);\n\tto->sb_agblocks = be32_to_cpu(from->sb_agblocks);\n\tto->sb_agcount = be32_to_cpu(from->sb_agcount);\n\tto->sb_rbmblocks = be32_to_cpu(from->sb_rbmblocks);\n\tto->sb_logblocks = be32_to_cpu(from->sb_logblocks);\n\tto->sb_versionnum = be16_to_cpu(from->sb_versionnum);\n\tto->sb_sectsize = be16_to_cpu(from->sb_sectsize);\n\tto->sb_inodesize = be16_to_cpu(from->sb_inodesize);\n\tto->sb_inopblock = be16_to_cpu(from->sb_inopblock);\n\tmemcpy(&to->sb_fname, &from->sb_fname, sizeof(to->sb_fname));\n\tto->sb_blocklog = from->sb_blocklog;\n\tto->sb_sectlog = from->sb_sectlog;\n\tto->sb_inodelog = from->sb_inodelog;\n\tto->sb_inopblog = from->sb_inopblog;\n\tto->sb_agblklog = from->sb_agblklog;\n\tto->sb_rextslog = from->sb_rextslog;\n\tto->sb_inprogress = from->sb_inprogress;\n\tto->sb_imax_pct = from->sb_imax_pct;\n\tto->sb_icount = be64_to_cpu(from->sb_icount);\n\tto->sb_ifree = be64_to_cpu(from->sb_ifree);\n\tto->sb_fdblocks = be64_to_cpu(from->sb_fdblocks);\n\tto->sb_frextents = be64_to_cpu(from->sb_frextents);\n\tto->sb_uquotino = be64_to_cpu(from->sb_uquotino);\n\tto->sb_gquotino = be64_to_cpu(from->sb_gquotino);\n\tto->sb_qflags = be16_to_cpu(from->sb_qflags);\n\tto->sb_flags = from->sb_flags;\n\tto->sb_shared_vn = from->sb_shared_vn;\n\tto->sb_inoalignmt = be32_to_cpu(from->sb_inoalignmt);\n\tto->sb_unit = be32_to_cpu(from->sb_unit);\n\tto->sb_width = be32_to_cpu(from->sb_width);\n\tto->sb_dirblklog = from->sb_dirblklog;\n\tto->sb_logsectlog = from->sb_logsectlog;\n\tto->sb_logsectsize = be16_to_cpu(from->sb_logsectsize);\n\tto->sb_logsunit = be32_to_cpu(from->sb_logsunit);\n\tto->sb_features2 = be32_to_cpu(from->sb_features2);\n\tto->sb_bad_features2 = be32_to_cpu(from->sb_bad_features2);\n\tto->sb_features_compat = be32_to_cpu(from->sb_features_compat);\n\tto->sb_features_ro_compat = be32_to_cpu(from->sb_features_ro_compat);\n\tto->sb_features_incompat = be32_to_cpu(from->sb_features_incompat);\n\tto->sb_features_log_incompat =\n\t\t\t\tbe32_to_cpu(from->sb_features_log_incompat);\n\t/* crc is only used on disk, not in memory; just init to 0 here. */\n\tto->sb_crc = 0;\n\tto->sb_pad = 0;\n\tto->sb_pquotino = be64_to_cpu(from->sb_pquotino);\n\tto->sb_lsn = be64_to_cpu(from->sb_lsn);\n\t/* Convert on-disk flags to in-memory flags? */\n\tif (convert_xquota)\n\t\txfs_sb_quota_from_disk(to);\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_BUF_TO_SBP",
          "args": [
            "bp"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic int\nxfs_sb_verify(\n\tstruct xfs_buf\t*bp,\n\tbool\t\tcheck_version)\n{\n\tstruct xfs_mount *mp = bp->b_target->bt_mount;\n\tstruct xfs_sb\tsb;\n\n\t/*\n\t * Use call variant which doesn't convert quota flags from disk \n\t * format, because xfs_mount_validate_sb checks the on-disk flags.\n\t */\n\t__xfs_sb_from_disk(&sb, XFS_BUF_TO_SBP(bp), false);\n\n\t/*\n\t * Only check the in progress field for the primary superblock as\n\t * mkfs.xfs doesn't clear it from secondary superblocks.\n\t */\n\treturn xfs_mount_validate_sb(mp, &sb, bp->b_bn == XFS_SB_DADDR,\n\t\t\t\t     check_version);\n}"
  },
  {
    "function_name": "xfs_sb_to_disk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
    "lines": "460-530",
    "snippet": "void\nxfs_sb_to_disk(\n\tstruct xfs_dsb\t*to,\n\tstruct xfs_sb\t*from)\n{\n\txfs_sb_quota_to_disk(to, from);\n\n\tto->sb_magicnum = cpu_to_be32(from->sb_magicnum);\n\tto->sb_blocksize = cpu_to_be32(from->sb_blocksize);\n\tto->sb_dblocks = cpu_to_be64(from->sb_dblocks);\n\tto->sb_rblocks = cpu_to_be64(from->sb_rblocks);\n\tto->sb_rextents = cpu_to_be64(from->sb_rextents);\n\tmemcpy(&to->sb_uuid, &from->sb_uuid, sizeof(to->sb_uuid));\n\tto->sb_logstart = cpu_to_be64(from->sb_logstart);\n\tto->sb_rootino = cpu_to_be64(from->sb_rootino);\n\tto->sb_rbmino = cpu_to_be64(from->sb_rbmino);\n\tto->sb_rsumino = cpu_to_be64(from->sb_rsumino);\n\tto->sb_rextsize = cpu_to_be32(from->sb_rextsize);\n\tto->sb_agblocks = cpu_to_be32(from->sb_agblocks);\n\tto->sb_agcount = cpu_to_be32(from->sb_agcount);\n\tto->sb_rbmblocks = cpu_to_be32(from->sb_rbmblocks);\n\tto->sb_logblocks = cpu_to_be32(from->sb_logblocks);\n\tto->sb_versionnum = cpu_to_be16(from->sb_versionnum);\n\tto->sb_sectsize = cpu_to_be16(from->sb_sectsize);\n\tto->sb_inodesize = cpu_to_be16(from->sb_inodesize);\n\tto->sb_inopblock = cpu_to_be16(from->sb_inopblock);\n\tmemcpy(&to->sb_fname, &from->sb_fname, sizeof(to->sb_fname));\n\tto->sb_blocklog = from->sb_blocklog;\n\tto->sb_sectlog = from->sb_sectlog;\n\tto->sb_inodelog = from->sb_inodelog;\n\tto->sb_inopblog = from->sb_inopblog;\n\tto->sb_agblklog = from->sb_agblklog;\n\tto->sb_rextslog = from->sb_rextslog;\n\tto->sb_inprogress = from->sb_inprogress;\n\tto->sb_imax_pct = from->sb_imax_pct;\n\tto->sb_icount = cpu_to_be64(from->sb_icount);\n\tto->sb_ifree = cpu_to_be64(from->sb_ifree);\n\tto->sb_fdblocks = cpu_to_be64(from->sb_fdblocks);\n\tto->sb_frextents = cpu_to_be64(from->sb_frextents);\n\n\tto->sb_flags = from->sb_flags;\n\tto->sb_shared_vn = from->sb_shared_vn;\n\tto->sb_inoalignmt = cpu_to_be32(from->sb_inoalignmt);\n\tto->sb_unit = cpu_to_be32(from->sb_unit);\n\tto->sb_width = cpu_to_be32(from->sb_width);\n\tto->sb_dirblklog = from->sb_dirblklog;\n\tto->sb_logsectlog = from->sb_logsectlog;\n\tto->sb_logsectsize = cpu_to_be16(from->sb_logsectsize);\n\tto->sb_logsunit = cpu_to_be32(from->sb_logsunit);\n\n\t/*\n\t * We need to ensure that bad_features2 always matches features2.\n\t * Hence we enforce that here rather than having to remember to do it\n\t * everywhere else that updates features2.\n\t */\n\tfrom->sb_bad_features2 = from->sb_features2;\n\tto->sb_features2 = cpu_to_be32(from->sb_features2);\n\tto->sb_bad_features2 = cpu_to_be32(from->sb_bad_features2);\n\n\tif (xfs_sb_version_hascrc(from)) {\n\t\tto->sb_features_compat = cpu_to_be32(from->sb_features_compat);\n\t\tto->sb_features_ro_compat =\n\t\t\t\tcpu_to_be32(from->sb_features_ro_compat);\n\t\tto->sb_features_incompat =\n\t\t\t\tcpu_to_be32(from->sb_features_incompat);\n\t\tto->sb_features_log_incompat =\n\t\t\t\tcpu_to_be32(from->sb_features_log_incompat);\n\t\tto->sb_pad = 0;\n\t\tto->sb_lsn = cpu_to_be64(from->sb_lsn);\n\t}\n}",
    "includes": [
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "from->sb_lsn"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "from->sb_features_log_incompat"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "from->sb_features_incompat"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "from->sb_features_ro_compat"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "from->sb_features_compat"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_hascrc",
          "args": [
            "from"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_hascrc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "547-550",
          "snippet": "static inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_hascrc(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "from->sb_bad_features2"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "from->sb_features2"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "from->sb_logsunit"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "from->sb_logsectsize"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "from->sb_width"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "from->sb_unit"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "from->sb_inoalignmt"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "from->sb_frextents"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "from->sb_fdblocks"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "from->sb_ifree"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "from->sb_icount"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&to->sb_fname",
            "&from->sb_fname",
            "sizeof(to->sb_fname)"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "from->sb_inopblock"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "from->sb_inodesize"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "from->sb_sectsize"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "from->sb_versionnum"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "from->sb_logblocks"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "from->sb_rbmblocks"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "from->sb_agcount"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "from->sb_agblocks"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "from->sb_rextsize"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "from->sb_rsumino"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "from->sb_rbmino"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "from->sb_rootino"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "from->sb_logstart"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&to->sb_uuid",
            "&from->sb_uuid",
            "sizeof(to->sb_uuid)"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "from->sb_rextents"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "from->sb_rblocks"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "from->sb_dblocks"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "from->sb_blocksize"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "from->sb_magicnum"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_quota_to_disk",
          "args": [
            "to",
            "from"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_quota_to_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "401-458",
          "snippet": "static void\nxfs_sb_quota_to_disk(\n\tstruct xfs_dsb\t*to,\n\tstruct xfs_sb\t*from)\n{\n\t__uint16_t\tqflags = from->sb_qflags;\n\n\tto->sb_uquotino = cpu_to_be64(from->sb_uquotino);\n\tif (xfs_sb_version_has_pquotino(from)) {\n\t\tto->sb_qflags = cpu_to_be16(from->sb_qflags);\n\t\tto->sb_gquotino = cpu_to_be64(from->sb_gquotino);\n\t\tto->sb_pquotino = cpu_to_be64(from->sb_pquotino);\n\t\treturn;\n\t}\n\n\t/*\n\t * The in-core version of sb_qflags do not have XFS_OQUOTA_*\n\t * flags, whereas the on-disk version does.  So, convert incore\n\t * XFS_{PG}QUOTA_* flags to on-disk XFS_OQUOTA_* flags.\n\t */\n\tqflags &= ~(XFS_PQUOTA_ENFD | XFS_PQUOTA_CHKD |\n\t\t\tXFS_GQUOTA_ENFD | XFS_GQUOTA_CHKD);\n\n\tif (from->sb_qflags &\n\t\t\t(XFS_PQUOTA_ENFD | XFS_GQUOTA_ENFD))\n\t\tqflags |= XFS_OQUOTA_ENFD;\n\tif (from->sb_qflags &\n\t\t\t(XFS_PQUOTA_CHKD | XFS_GQUOTA_CHKD))\n\t\tqflags |= XFS_OQUOTA_CHKD;\n\tto->sb_qflags = cpu_to_be16(qflags);\n\n\t/*\n\t * GQUOTINO and PQUOTINO cannot be used together in versions\n\t * of superblock that do not have pquotino. from->sb_flags\n\t * tells us which quota is active and should be copied to\n\t * disk. If neither are active, we should NULL the inode.\n\t *\n\t * In all cases, the separate pquotino must remain 0 because it\n\t * it beyond the \"end\" of the valid non-pquotino superblock.\n\t */\n\tif (from->sb_qflags & XFS_GQUOTA_ACCT)\n\t\tto->sb_gquotino = cpu_to_be64(from->sb_gquotino);\n\telse if (from->sb_qflags & XFS_PQUOTA_ACCT)\n\t\tto->sb_gquotino = cpu_to_be64(from->sb_pquotino);\n\telse {\n\t\t/*\n\t\t * We can't rely on just the fields being logged to tell us\n\t\t * that it is safe to write NULLFSINO - we should only do that\n\t\t * if quotas are not actually enabled. Hence only write\n\t\t * NULLFSINO if both in-core quota inodes are NULL.\n\t\t */\n\t\tif (from->sb_gquotino == NULLFSINO &&\n\t\t    from->sb_pquotino == NULLFSINO)\n\t\t\tto->sb_gquotino = cpu_to_be64(NULLFSINO);\n\t}\n\n\tto->sb_pquotino = 0;\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxfs_sb_quota_to_disk(\n\tstruct xfs_dsb\t*to,\n\tstruct xfs_sb\t*from)\n{\n\t__uint16_t\tqflags = from->sb_qflags;\n\n\tto->sb_uquotino = cpu_to_be64(from->sb_uquotino);\n\tif (xfs_sb_version_has_pquotino(from)) {\n\t\tto->sb_qflags = cpu_to_be16(from->sb_qflags);\n\t\tto->sb_gquotino = cpu_to_be64(from->sb_gquotino);\n\t\tto->sb_pquotino = cpu_to_be64(from->sb_pquotino);\n\t\treturn;\n\t}\n\n\t/*\n\t * The in-core version of sb_qflags do not have XFS_OQUOTA_*\n\t * flags, whereas the on-disk version does.  So, convert incore\n\t * XFS_{PG}QUOTA_* flags to on-disk XFS_OQUOTA_* flags.\n\t */\n\tqflags &= ~(XFS_PQUOTA_ENFD | XFS_PQUOTA_CHKD |\n\t\t\tXFS_GQUOTA_ENFD | XFS_GQUOTA_CHKD);\n\n\tif (from->sb_qflags &\n\t\t\t(XFS_PQUOTA_ENFD | XFS_GQUOTA_ENFD))\n\t\tqflags |= XFS_OQUOTA_ENFD;\n\tif (from->sb_qflags &\n\t\t\t(XFS_PQUOTA_CHKD | XFS_GQUOTA_CHKD))\n\t\tqflags |= XFS_OQUOTA_CHKD;\n\tto->sb_qflags = cpu_to_be16(qflags);\n\n\t/*\n\t * GQUOTINO and PQUOTINO cannot be used together in versions\n\t * of superblock that do not have pquotino. from->sb_flags\n\t * tells us which quota is active and should be copied to\n\t * disk. If neither are active, we should NULL the inode.\n\t *\n\t * In all cases, the separate pquotino must remain 0 because it\n\t * it beyond the \"end\" of the valid non-pquotino superblock.\n\t */\n\tif (from->sb_qflags & XFS_GQUOTA_ACCT)\n\t\tto->sb_gquotino = cpu_to_be64(from->sb_gquotino);\n\telse if (from->sb_qflags & XFS_PQUOTA_ACCT)\n\t\tto->sb_gquotino = cpu_to_be64(from->sb_pquotino);\n\telse {\n\t\t/*\n\t\t * We can't rely on just the fields being logged to tell us\n\t\t * that it is safe to write NULLFSINO - we should only do that\n\t\t * if quotas are not actually enabled. Hence only write\n\t\t * NULLFSINO if both in-core quota inodes are NULL.\n\t\t */\n\t\tif (from->sb_gquotino == NULLFSINO &&\n\t\t    from->sb_pquotino == NULLFSINO)\n\t\t\tto->sb_gquotino = cpu_to_be64(NULLFSINO);\n\t}\n\n\tto->sb_pquotino = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_sb_to_disk(\n\tstruct xfs_dsb\t*to,\n\tstruct xfs_sb\t*from)\n{\n\txfs_sb_quota_to_disk(to, from);\n\n\tto->sb_magicnum = cpu_to_be32(from->sb_magicnum);\n\tto->sb_blocksize = cpu_to_be32(from->sb_blocksize);\n\tto->sb_dblocks = cpu_to_be64(from->sb_dblocks);\n\tto->sb_rblocks = cpu_to_be64(from->sb_rblocks);\n\tto->sb_rextents = cpu_to_be64(from->sb_rextents);\n\tmemcpy(&to->sb_uuid, &from->sb_uuid, sizeof(to->sb_uuid));\n\tto->sb_logstart = cpu_to_be64(from->sb_logstart);\n\tto->sb_rootino = cpu_to_be64(from->sb_rootino);\n\tto->sb_rbmino = cpu_to_be64(from->sb_rbmino);\n\tto->sb_rsumino = cpu_to_be64(from->sb_rsumino);\n\tto->sb_rextsize = cpu_to_be32(from->sb_rextsize);\n\tto->sb_agblocks = cpu_to_be32(from->sb_agblocks);\n\tto->sb_agcount = cpu_to_be32(from->sb_agcount);\n\tto->sb_rbmblocks = cpu_to_be32(from->sb_rbmblocks);\n\tto->sb_logblocks = cpu_to_be32(from->sb_logblocks);\n\tto->sb_versionnum = cpu_to_be16(from->sb_versionnum);\n\tto->sb_sectsize = cpu_to_be16(from->sb_sectsize);\n\tto->sb_inodesize = cpu_to_be16(from->sb_inodesize);\n\tto->sb_inopblock = cpu_to_be16(from->sb_inopblock);\n\tmemcpy(&to->sb_fname, &from->sb_fname, sizeof(to->sb_fname));\n\tto->sb_blocklog = from->sb_blocklog;\n\tto->sb_sectlog = from->sb_sectlog;\n\tto->sb_inodelog = from->sb_inodelog;\n\tto->sb_inopblog = from->sb_inopblog;\n\tto->sb_agblklog = from->sb_agblklog;\n\tto->sb_rextslog = from->sb_rextslog;\n\tto->sb_inprogress = from->sb_inprogress;\n\tto->sb_imax_pct = from->sb_imax_pct;\n\tto->sb_icount = cpu_to_be64(from->sb_icount);\n\tto->sb_ifree = cpu_to_be64(from->sb_ifree);\n\tto->sb_fdblocks = cpu_to_be64(from->sb_fdblocks);\n\tto->sb_frextents = cpu_to_be64(from->sb_frextents);\n\n\tto->sb_flags = from->sb_flags;\n\tto->sb_shared_vn = from->sb_shared_vn;\n\tto->sb_inoalignmt = cpu_to_be32(from->sb_inoalignmt);\n\tto->sb_unit = cpu_to_be32(from->sb_unit);\n\tto->sb_width = cpu_to_be32(from->sb_width);\n\tto->sb_dirblklog = from->sb_dirblklog;\n\tto->sb_logsectlog = from->sb_logsectlog;\n\tto->sb_logsectsize = cpu_to_be16(from->sb_logsectsize);\n\tto->sb_logsunit = cpu_to_be32(from->sb_logsunit);\n\n\t/*\n\t * We need to ensure that bad_features2 always matches features2.\n\t * Hence we enforce that here rather than having to remember to do it\n\t * everywhere else that updates features2.\n\t */\n\tfrom->sb_bad_features2 = from->sb_features2;\n\tto->sb_features2 = cpu_to_be32(from->sb_features2);\n\tto->sb_bad_features2 = cpu_to_be32(from->sb_bad_features2);\n\n\tif (xfs_sb_version_hascrc(from)) {\n\t\tto->sb_features_compat = cpu_to_be32(from->sb_features_compat);\n\t\tto->sb_features_ro_compat =\n\t\t\t\tcpu_to_be32(from->sb_features_ro_compat);\n\t\tto->sb_features_incompat =\n\t\t\t\tcpu_to_be32(from->sb_features_incompat);\n\t\tto->sb_features_log_incompat =\n\t\t\t\tcpu_to_be32(from->sb_features_log_incompat);\n\t\tto->sb_pad = 0;\n\t\tto->sb_lsn = cpu_to_be64(from->sb_lsn);\n\t}\n}"
  },
  {
    "function_name": "xfs_sb_quota_to_disk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
    "lines": "401-458",
    "snippet": "static void\nxfs_sb_quota_to_disk(\n\tstruct xfs_dsb\t*to,\n\tstruct xfs_sb\t*from)\n{\n\t__uint16_t\tqflags = from->sb_qflags;\n\n\tto->sb_uquotino = cpu_to_be64(from->sb_uquotino);\n\tif (xfs_sb_version_has_pquotino(from)) {\n\t\tto->sb_qflags = cpu_to_be16(from->sb_qflags);\n\t\tto->sb_gquotino = cpu_to_be64(from->sb_gquotino);\n\t\tto->sb_pquotino = cpu_to_be64(from->sb_pquotino);\n\t\treturn;\n\t}\n\n\t/*\n\t * The in-core version of sb_qflags do not have XFS_OQUOTA_*\n\t * flags, whereas the on-disk version does.  So, convert incore\n\t * XFS_{PG}QUOTA_* flags to on-disk XFS_OQUOTA_* flags.\n\t */\n\tqflags &= ~(XFS_PQUOTA_ENFD | XFS_PQUOTA_CHKD |\n\t\t\tXFS_GQUOTA_ENFD | XFS_GQUOTA_CHKD);\n\n\tif (from->sb_qflags &\n\t\t\t(XFS_PQUOTA_ENFD | XFS_GQUOTA_ENFD))\n\t\tqflags |= XFS_OQUOTA_ENFD;\n\tif (from->sb_qflags &\n\t\t\t(XFS_PQUOTA_CHKD | XFS_GQUOTA_CHKD))\n\t\tqflags |= XFS_OQUOTA_CHKD;\n\tto->sb_qflags = cpu_to_be16(qflags);\n\n\t/*\n\t * GQUOTINO and PQUOTINO cannot be used together in versions\n\t * of superblock that do not have pquotino. from->sb_flags\n\t * tells us which quota is active and should be copied to\n\t * disk. If neither are active, we should NULL the inode.\n\t *\n\t * In all cases, the separate pquotino must remain 0 because it\n\t * it beyond the \"end\" of the valid non-pquotino superblock.\n\t */\n\tif (from->sb_qflags & XFS_GQUOTA_ACCT)\n\t\tto->sb_gquotino = cpu_to_be64(from->sb_gquotino);\n\telse if (from->sb_qflags & XFS_PQUOTA_ACCT)\n\t\tto->sb_gquotino = cpu_to_be64(from->sb_pquotino);\n\telse {\n\t\t/*\n\t\t * We can't rely on just the fields being logged to tell us\n\t\t * that it is safe to write NULLFSINO - we should only do that\n\t\t * if quotas are not actually enabled. Hence only write\n\t\t * NULLFSINO if both in-core quota inodes are NULL.\n\t\t */\n\t\tif (from->sb_gquotino == NULLFSINO &&\n\t\t    from->sb_pquotino == NULLFSINO)\n\t\t\tto->sb_gquotino = cpu_to_be64(NULLFSINO);\n\t}\n\n\tto->sb_pquotino = 0;\n}",
    "includes": [
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "NULLFSINO"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "from->sb_pquotino"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "from->sb_gquotino"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "qflags"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "from->sb_pquotino"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "from->sb_gquotino"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be16",
          "args": [
            "from->sb_qflags"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_has_pquotino",
          "args": [
            "from"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_has_pquotino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "552-555",
          "snippet": "static inline int xfs_sb_version_has_pquotino(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_has_pquotino(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_be64",
          "args": [
            "from->sb_uquotino"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\nxfs_sb_quota_to_disk(\n\tstruct xfs_dsb\t*to,\n\tstruct xfs_sb\t*from)\n{\n\t__uint16_t\tqflags = from->sb_qflags;\n\n\tto->sb_uquotino = cpu_to_be64(from->sb_uquotino);\n\tif (xfs_sb_version_has_pquotino(from)) {\n\t\tto->sb_qflags = cpu_to_be16(from->sb_qflags);\n\t\tto->sb_gquotino = cpu_to_be64(from->sb_gquotino);\n\t\tto->sb_pquotino = cpu_to_be64(from->sb_pquotino);\n\t\treturn;\n\t}\n\n\t/*\n\t * The in-core version of sb_qflags do not have XFS_OQUOTA_*\n\t * flags, whereas the on-disk version does.  So, convert incore\n\t * XFS_{PG}QUOTA_* flags to on-disk XFS_OQUOTA_* flags.\n\t */\n\tqflags &= ~(XFS_PQUOTA_ENFD | XFS_PQUOTA_CHKD |\n\t\t\tXFS_GQUOTA_ENFD | XFS_GQUOTA_CHKD);\n\n\tif (from->sb_qflags &\n\t\t\t(XFS_PQUOTA_ENFD | XFS_GQUOTA_ENFD))\n\t\tqflags |= XFS_OQUOTA_ENFD;\n\tif (from->sb_qflags &\n\t\t\t(XFS_PQUOTA_CHKD | XFS_GQUOTA_CHKD))\n\t\tqflags |= XFS_OQUOTA_CHKD;\n\tto->sb_qflags = cpu_to_be16(qflags);\n\n\t/*\n\t * GQUOTINO and PQUOTINO cannot be used together in versions\n\t * of superblock that do not have pquotino. from->sb_flags\n\t * tells us which quota is active and should be copied to\n\t * disk. If neither are active, we should NULL the inode.\n\t *\n\t * In all cases, the separate pquotino must remain 0 because it\n\t * it beyond the \"end\" of the valid non-pquotino superblock.\n\t */\n\tif (from->sb_qflags & XFS_GQUOTA_ACCT)\n\t\tto->sb_gquotino = cpu_to_be64(from->sb_gquotino);\n\telse if (from->sb_qflags & XFS_PQUOTA_ACCT)\n\t\tto->sb_gquotino = cpu_to_be64(from->sb_pquotino);\n\telse {\n\t\t/*\n\t\t * We can't rely on just the fields being logged to tell us\n\t\t * that it is safe to write NULLFSINO - we should only do that\n\t\t * if quotas are not actually enabled. Hence only write\n\t\t * NULLFSINO if both in-core quota inodes are NULL.\n\t\t */\n\t\tif (from->sb_gquotino == NULLFSINO &&\n\t\t    from->sb_pquotino == NULLFSINO)\n\t\t\tto->sb_gquotino = cpu_to_be64(NULLFSINO);\n\t}\n\n\tto->sb_pquotino = 0;\n}"
  },
  {
    "function_name": "xfs_sb_from_disk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
    "lines": "393-399",
    "snippet": "void\nxfs_sb_from_disk(\n\tstruct xfs_sb\t*to,\n\txfs_dsb_t\t*from)\n{\n\t__xfs_sb_from_disk(to, from, true);\n}",
    "includes": [
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__xfs_sb_from_disk",
          "args": [
            "to",
            "from",
            "true"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "__xfs_sb_from_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "326-391",
          "snippet": "static void\n__xfs_sb_from_disk(\n\tstruct xfs_sb\t*to,\n\txfs_dsb_t\t*from,\n\tbool\t\tconvert_xquota)\n{\n\tto->sb_magicnum = be32_to_cpu(from->sb_magicnum);\n\tto->sb_blocksize = be32_to_cpu(from->sb_blocksize);\n\tto->sb_dblocks = be64_to_cpu(from->sb_dblocks);\n\tto->sb_rblocks = be64_to_cpu(from->sb_rblocks);\n\tto->sb_rextents = be64_to_cpu(from->sb_rextents);\n\tmemcpy(&to->sb_uuid, &from->sb_uuid, sizeof(to->sb_uuid));\n\tto->sb_logstart = be64_to_cpu(from->sb_logstart);\n\tto->sb_rootino = be64_to_cpu(from->sb_rootino);\n\tto->sb_rbmino = be64_to_cpu(from->sb_rbmino);\n\tto->sb_rsumino = be64_to_cpu(from->sb_rsumino);\n\tto->sb_rextsize = be32_to_cpu(from->sb_rextsize);\n\tto->sb_agblocks = be32_to_cpu(from->sb_agblocks);\n\tto->sb_agcount = be32_to_cpu(from->sb_agcount);\n\tto->sb_rbmblocks = be32_to_cpu(from->sb_rbmblocks);\n\tto->sb_logblocks = be32_to_cpu(from->sb_logblocks);\n\tto->sb_versionnum = be16_to_cpu(from->sb_versionnum);\n\tto->sb_sectsize = be16_to_cpu(from->sb_sectsize);\n\tto->sb_inodesize = be16_to_cpu(from->sb_inodesize);\n\tto->sb_inopblock = be16_to_cpu(from->sb_inopblock);\n\tmemcpy(&to->sb_fname, &from->sb_fname, sizeof(to->sb_fname));\n\tto->sb_blocklog = from->sb_blocklog;\n\tto->sb_sectlog = from->sb_sectlog;\n\tto->sb_inodelog = from->sb_inodelog;\n\tto->sb_inopblog = from->sb_inopblog;\n\tto->sb_agblklog = from->sb_agblklog;\n\tto->sb_rextslog = from->sb_rextslog;\n\tto->sb_inprogress = from->sb_inprogress;\n\tto->sb_imax_pct = from->sb_imax_pct;\n\tto->sb_icount = be64_to_cpu(from->sb_icount);\n\tto->sb_ifree = be64_to_cpu(from->sb_ifree);\n\tto->sb_fdblocks = be64_to_cpu(from->sb_fdblocks);\n\tto->sb_frextents = be64_to_cpu(from->sb_frextents);\n\tto->sb_uquotino = be64_to_cpu(from->sb_uquotino);\n\tto->sb_gquotino = be64_to_cpu(from->sb_gquotino);\n\tto->sb_qflags = be16_to_cpu(from->sb_qflags);\n\tto->sb_flags = from->sb_flags;\n\tto->sb_shared_vn = from->sb_shared_vn;\n\tto->sb_inoalignmt = be32_to_cpu(from->sb_inoalignmt);\n\tto->sb_unit = be32_to_cpu(from->sb_unit);\n\tto->sb_width = be32_to_cpu(from->sb_width);\n\tto->sb_dirblklog = from->sb_dirblklog;\n\tto->sb_logsectlog = from->sb_logsectlog;\n\tto->sb_logsectsize = be16_to_cpu(from->sb_logsectsize);\n\tto->sb_logsunit = be32_to_cpu(from->sb_logsunit);\n\tto->sb_features2 = be32_to_cpu(from->sb_features2);\n\tto->sb_bad_features2 = be32_to_cpu(from->sb_bad_features2);\n\tto->sb_features_compat = be32_to_cpu(from->sb_features_compat);\n\tto->sb_features_ro_compat = be32_to_cpu(from->sb_features_ro_compat);\n\tto->sb_features_incompat = be32_to_cpu(from->sb_features_incompat);\n\tto->sb_features_log_incompat =\n\t\t\t\tbe32_to_cpu(from->sb_features_log_incompat);\n\t/* crc is only used on disk, not in memory; just init to 0 here. */\n\tto->sb_crc = 0;\n\tto->sb_pad = 0;\n\tto->sb_pquotino = be64_to_cpu(from->sb_pquotino);\n\tto->sb_lsn = be64_to_cpu(from->sb_lsn);\n\t/* Convert on-disk flags to in-memory flags? */\n\tif (convert_xquota)\n\t\txfs_sb_quota_from_disk(to);\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\n__xfs_sb_from_disk(\n\tstruct xfs_sb\t*to,\n\txfs_dsb_t\t*from,\n\tbool\t\tconvert_xquota)\n{\n\tto->sb_magicnum = be32_to_cpu(from->sb_magicnum);\n\tto->sb_blocksize = be32_to_cpu(from->sb_blocksize);\n\tto->sb_dblocks = be64_to_cpu(from->sb_dblocks);\n\tto->sb_rblocks = be64_to_cpu(from->sb_rblocks);\n\tto->sb_rextents = be64_to_cpu(from->sb_rextents);\n\tmemcpy(&to->sb_uuid, &from->sb_uuid, sizeof(to->sb_uuid));\n\tto->sb_logstart = be64_to_cpu(from->sb_logstart);\n\tto->sb_rootino = be64_to_cpu(from->sb_rootino);\n\tto->sb_rbmino = be64_to_cpu(from->sb_rbmino);\n\tto->sb_rsumino = be64_to_cpu(from->sb_rsumino);\n\tto->sb_rextsize = be32_to_cpu(from->sb_rextsize);\n\tto->sb_agblocks = be32_to_cpu(from->sb_agblocks);\n\tto->sb_agcount = be32_to_cpu(from->sb_agcount);\n\tto->sb_rbmblocks = be32_to_cpu(from->sb_rbmblocks);\n\tto->sb_logblocks = be32_to_cpu(from->sb_logblocks);\n\tto->sb_versionnum = be16_to_cpu(from->sb_versionnum);\n\tto->sb_sectsize = be16_to_cpu(from->sb_sectsize);\n\tto->sb_inodesize = be16_to_cpu(from->sb_inodesize);\n\tto->sb_inopblock = be16_to_cpu(from->sb_inopblock);\n\tmemcpy(&to->sb_fname, &from->sb_fname, sizeof(to->sb_fname));\n\tto->sb_blocklog = from->sb_blocklog;\n\tto->sb_sectlog = from->sb_sectlog;\n\tto->sb_inodelog = from->sb_inodelog;\n\tto->sb_inopblog = from->sb_inopblog;\n\tto->sb_agblklog = from->sb_agblklog;\n\tto->sb_rextslog = from->sb_rextslog;\n\tto->sb_inprogress = from->sb_inprogress;\n\tto->sb_imax_pct = from->sb_imax_pct;\n\tto->sb_icount = be64_to_cpu(from->sb_icount);\n\tto->sb_ifree = be64_to_cpu(from->sb_ifree);\n\tto->sb_fdblocks = be64_to_cpu(from->sb_fdblocks);\n\tto->sb_frextents = be64_to_cpu(from->sb_frextents);\n\tto->sb_uquotino = be64_to_cpu(from->sb_uquotino);\n\tto->sb_gquotino = be64_to_cpu(from->sb_gquotino);\n\tto->sb_qflags = be16_to_cpu(from->sb_qflags);\n\tto->sb_flags = from->sb_flags;\n\tto->sb_shared_vn = from->sb_shared_vn;\n\tto->sb_inoalignmt = be32_to_cpu(from->sb_inoalignmt);\n\tto->sb_unit = be32_to_cpu(from->sb_unit);\n\tto->sb_width = be32_to_cpu(from->sb_width);\n\tto->sb_dirblklog = from->sb_dirblklog;\n\tto->sb_logsectlog = from->sb_logsectlog;\n\tto->sb_logsectsize = be16_to_cpu(from->sb_logsectsize);\n\tto->sb_logsunit = be32_to_cpu(from->sb_logsunit);\n\tto->sb_features2 = be32_to_cpu(from->sb_features2);\n\tto->sb_bad_features2 = be32_to_cpu(from->sb_bad_features2);\n\tto->sb_features_compat = be32_to_cpu(from->sb_features_compat);\n\tto->sb_features_ro_compat = be32_to_cpu(from->sb_features_ro_compat);\n\tto->sb_features_incompat = be32_to_cpu(from->sb_features_incompat);\n\tto->sb_features_log_incompat =\n\t\t\t\tbe32_to_cpu(from->sb_features_log_incompat);\n\t/* crc is only used on disk, not in memory; just init to 0 here. */\n\tto->sb_crc = 0;\n\tto->sb_pad = 0;\n\tto->sb_pquotino = be64_to_cpu(from->sb_pquotino);\n\tto->sb_lsn = be64_to_cpu(from->sb_lsn);\n\t/* Convert on-disk flags to in-memory flags? */\n\tif (convert_xquota)\n\t\txfs_sb_quota_from_disk(to);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_sb_from_disk(\n\tstruct xfs_sb\t*to,\n\txfs_dsb_t\t*from)\n{\n\t__xfs_sb_from_disk(to, from, true);\n}"
  },
  {
    "function_name": "__xfs_sb_from_disk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
    "lines": "326-391",
    "snippet": "static void\n__xfs_sb_from_disk(\n\tstruct xfs_sb\t*to,\n\txfs_dsb_t\t*from,\n\tbool\t\tconvert_xquota)\n{\n\tto->sb_magicnum = be32_to_cpu(from->sb_magicnum);\n\tto->sb_blocksize = be32_to_cpu(from->sb_blocksize);\n\tto->sb_dblocks = be64_to_cpu(from->sb_dblocks);\n\tto->sb_rblocks = be64_to_cpu(from->sb_rblocks);\n\tto->sb_rextents = be64_to_cpu(from->sb_rextents);\n\tmemcpy(&to->sb_uuid, &from->sb_uuid, sizeof(to->sb_uuid));\n\tto->sb_logstart = be64_to_cpu(from->sb_logstart);\n\tto->sb_rootino = be64_to_cpu(from->sb_rootino);\n\tto->sb_rbmino = be64_to_cpu(from->sb_rbmino);\n\tto->sb_rsumino = be64_to_cpu(from->sb_rsumino);\n\tto->sb_rextsize = be32_to_cpu(from->sb_rextsize);\n\tto->sb_agblocks = be32_to_cpu(from->sb_agblocks);\n\tto->sb_agcount = be32_to_cpu(from->sb_agcount);\n\tto->sb_rbmblocks = be32_to_cpu(from->sb_rbmblocks);\n\tto->sb_logblocks = be32_to_cpu(from->sb_logblocks);\n\tto->sb_versionnum = be16_to_cpu(from->sb_versionnum);\n\tto->sb_sectsize = be16_to_cpu(from->sb_sectsize);\n\tto->sb_inodesize = be16_to_cpu(from->sb_inodesize);\n\tto->sb_inopblock = be16_to_cpu(from->sb_inopblock);\n\tmemcpy(&to->sb_fname, &from->sb_fname, sizeof(to->sb_fname));\n\tto->sb_blocklog = from->sb_blocklog;\n\tto->sb_sectlog = from->sb_sectlog;\n\tto->sb_inodelog = from->sb_inodelog;\n\tto->sb_inopblog = from->sb_inopblog;\n\tto->sb_agblklog = from->sb_agblklog;\n\tto->sb_rextslog = from->sb_rextslog;\n\tto->sb_inprogress = from->sb_inprogress;\n\tto->sb_imax_pct = from->sb_imax_pct;\n\tto->sb_icount = be64_to_cpu(from->sb_icount);\n\tto->sb_ifree = be64_to_cpu(from->sb_ifree);\n\tto->sb_fdblocks = be64_to_cpu(from->sb_fdblocks);\n\tto->sb_frextents = be64_to_cpu(from->sb_frextents);\n\tto->sb_uquotino = be64_to_cpu(from->sb_uquotino);\n\tto->sb_gquotino = be64_to_cpu(from->sb_gquotino);\n\tto->sb_qflags = be16_to_cpu(from->sb_qflags);\n\tto->sb_flags = from->sb_flags;\n\tto->sb_shared_vn = from->sb_shared_vn;\n\tto->sb_inoalignmt = be32_to_cpu(from->sb_inoalignmt);\n\tto->sb_unit = be32_to_cpu(from->sb_unit);\n\tto->sb_width = be32_to_cpu(from->sb_width);\n\tto->sb_dirblklog = from->sb_dirblklog;\n\tto->sb_logsectlog = from->sb_logsectlog;\n\tto->sb_logsectsize = be16_to_cpu(from->sb_logsectsize);\n\tto->sb_logsunit = be32_to_cpu(from->sb_logsunit);\n\tto->sb_features2 = be32_to_cpu(from->sb_features2);\n\tto->sb_bad_features2 = be32_to_cpu(from->sb_bad_features2);\n\tto->sb_features_compat = be32_to_cpu(from->sb_features_compat);\n\tto->sb_features_ro_compat = be32_to_cpu(from->sb_features_ro_compat);\n\tto->sb_features_incompat = be32_to_cpu(from->sb_features_incompat);\n\tto->sb_features_log_incompat =\n\t\t\t\tbe32_to_cpu(from->sb_features_log_incompat);\n\t/* crc is only used on disk, not in memory; just init to 0 here. */\n\tto->sb_crc = 0;\n\tto->sb_pad = 0;\n\tto->sb_pquotino = be64_to_cpu(from->sb_pquotino);\n\tto->sb_lsn = be64_to_cpu(from->sb_lsn);\n\t/* Convert on-disk flags to in-memory flags? */\n\tif (convert_xquota)\n\t\txfs_sb_quota_from_disk(to);\n}",
    "includes": [
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_sb_quota_from_disk",
          "args": [
            "to"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_quota_from_disk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
          "lines": "277-324",
          "snippet": "void\nxfs_sb_quota_from_disk(struct xfs_sb *sbp)\n{\n\t/*\n\t * older mkfs doesn't initialize quota inodes to NULLFSINO. This\n\t * leads to in-core values having two different values for a quota\n\t * inode to be invalid: 0 and NULLFSINO. Change it to a single value\n\t * NULLFSINO.\n\t *\n\t * Note that this change affect only the in-core values. These\n\t * values are not written back to disk unless any quota information\n\t * is written to the disk. Even in that case, sb_pquotino field is\n\t * not written to disk unless the superblock supports pquotino.\n\t */\n\tif (sbp->sb_uquotino == 0)\n\t\tsbp->sb_uquotino = NULLFSINO;\n\tif (sbp->sb_gquotino == 0)\n\t\tsbp->sb_gquotino = NULLFSINO;\n\tif (sbp->sb_pquotino == 0)\n\t\tsbp->sb_pquotino = NULLFSINO;\n\n\t/*\n\t * We need to do these manipilations only if we are working\n\t * with an older version of on-disk superblock.\n\t */\n\tif (xfs_sb_version_has_pquotino(sbp))\n\t\treturn;\n\n\tif (sbp->sb_qflags & XFS_OQUOTA_ENFD)\n\t\tsbp->sb_qflags |= (sbp->sb_qflags & XFS_PQUOTA_ACCT) ?\n\t\t\t\t\tXFS_PQUOTA_ENFD : XFS_GQUOTA_ENFD;\n\tif (sbp->sb_qflags & XFS_OQUOTA_CHKD)\n\t\tsbp->sb_qflags |= (sbp->sb_qflags & XFS_PQUOTA_ACCT) ?\n\t\t\t\t\tXFS_PQUOTA_CHKD : XFS_GQUOTA_CHKD;\n\tsbp->sb_qflags &= ~(XFS_OQUOTA_ENFD | XFS_OQUOTA_CHKD);\n\n\tif (sbp->sb_qflags & XFS_PQUOTA_ACCT)  {\n\t\t/*\n\t\t * In older version of superblock, on-disk superblock only\n\t\t * has sb_gquotino, and in-core superblock has both sb_gquotino\n\t\t * and sb_pquotino. But, only one of them is supported at any\n\t\t * point of time. So, if PQUOTA is set in disk superblock,\n\t\t * copy over sb_gquotino to sb_pquotino.\n\t\t */\n\t\tsbp->sb_pquotino = sbp->sb_gquotino;\n\t\tsbp->sb_gquotino = NULLFSINO;\n\t}\n}",
          "includes": [
            "#include \"xfs_ialloc_btree.h\"",
            "#include \"xfs_alloc_btree.h\"",
            "#include \"xfs_bmap_btree.h\"",
            "#include \"xfs_buf_item.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_sb_quota_from_disk(struct xfs_sb *sbp)\n{\n\t/*\n\t * older mkfs doesn't initialize quota inodes to NULLFSINO. This\n\t * leads to in-core values having two different values for a quota\n\t * inode to be invalid: 0 and NULLFSINO. Change it to a single value\n\t * NULLFSINO.\n\t *\n\t * Note that this change affect only the in-core values. These\n\t * values are not written back to disk unless any quota information\n\t * is written to the disk. Even in that case, sb_pquotino field is\n\t * not written to disk unless the superblock supports pquotino.\n\t */\n\tif (sbp->sb_uquotino == 0)\n\t\tsbp->sb_uquotino = NULLFSINO;\n\tif (sbp->sb_gquotino == 0)\n\t\tsbp->sb_gquotino = NULLFSINO;\n\tif (sbp->sb_pquotino == 0)\n\t\tsbp->sb_pquotino = NULLFSINO;\n\n\t/*\n\t * We need to do these manipilations only if we are working\n\t * with an older version of on-disk superblock.\n\t */\n\tif (xfs_sb_version_has_pquotino(sbp))\n\t\treturn;\n\n\tif (sbp->sb_qflags & XFS_OQUOTA_ENFD)\n\t\tsbp->sb_qflags |= (sbp->sb_qflags & XFS_PQUOTA_ACCT) ?\n\t\t\t\t\tXFS_PQUOTA_ENFD : XFS_GQUOTA_ENFD;\n\tif (sbp->sb_qflags & XFS_OQUOTA_CHKD)\n\t\tsbp->sb_qflags |= (sbp->sb_qflags & XFS_PQUOTA_ACCT) ?\n\t\t\t\t\tXFS_PQUOTA_CHKD : XFS_GQUOTA_CHKD;\n\tsbp->sb_qflags &= ~(XFS_OQUOTA_ENFD | XFS_OQUOTA_CHKD);\n\n\tif (sbp->sb_qflags & XFS_PQUOTA_ACCT)  {\n\t\t/*\n\t\t * In older version of superblock, on-disk superblock only\n\t\t * has sb_gquotino, and in-core superblock has both sb_gquotino\n\t\t * and sb_pquotino. But, only one of them is supported at any\n\t\t * point of time. So, if PQUOTA is set in disk superblock,\n\t\t * copy over sb_gquotino to sb_pquotino.\n\t\t */\n\t\tsbp->sb_pquotino = sbp->sb_gquotino;\n\t\tsbp->sb_gquotino = NULLFSINO;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "from->sb_lsn"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "from->sb_pquotino"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "from->sb_features_log_incompat"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "from->sb_features_incompat"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "from->sb_features_ro_compat"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "from->sb_features_compat"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "from->sb_bad_features2"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "from->sb_features2"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "from->sb_logsunit"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "from->sb_logsectsize"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "from->sb_width"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "from->sb_unit"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "from->sb_inoalignmt"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "from->sb_qflags"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "from->sb_gquotino"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "from->sb_uquotino"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "from->sb_frextents"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "from->sb_fdblocks"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "from->sb_ifree"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "from->sb_icount"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&to->sb_fname",
            "&from->sb_fname",
            "sizeof(to->sb_fname)"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "from->sb_inopblock"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "from->sb_inodesize"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "from->sb_sectsize"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "from->sb_versionnum"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "from->sb_logblocks"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "from->sb_rbmblocks"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "from->sb_agcount"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "from->sb_agblocks"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "from->sb_rextsize"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "from->sb_rsumino"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "from->sb_rbmino"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "from->sb_rootino"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "from->sb_logstart"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&to->sb_uuid",
            "&from->sb_uuid",
            "sizeof(to->sb_uuid)"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "from->sb_rextents"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "from->sb_rblocks"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be64_to_cpu",
          "args": [
            "from->sb_dblocks"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "from->sb_blocksize"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "from->sb_magicnum"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstatic void\n__xfs_sb_from_disk(\n\tstruct xfs_sb\t*to,\n\txfs_dsb_t\t*from,\n\tbool\t\tconvert_xquota)\n{\n\tto->sb_magicnum = be32_to_cpu(from->sb_magicnum);\n\tto->sb_blocksize = be32_to_cpu(from->sb_blocksize);\n\tto->sb_dblocks = be64_to_cpu(from->sb_dblocks);\n\tto->sb_rblocks = be64_to_cpu(from->sb_rblocks);\n\tto->sb_rextents = be64_to_cpu(from->sb_rextents);\n\tmemcpy(&to->sb_uuid, &from->sb_uuid, sizeof(to->sb_uuid));\n\tto->sb_logstart = be64_to_cpu(from->sb_logstart);\n\tto->sb_rootino = be64_to_cpu(from->sb_rootino);\n\tto->sb_rbmino = be64_to_cpu(from->sb_rbmino);\n\tto->sb_rsumino = be64_to_cpu(from->sb_rsumino);\n\tto->sb_rextsize = be32_to_cpu(from->sb_rextsize);\n\tto->sb_agblocks = be32_to_cpu(from->sb_agblocks);\n\tto->sb_agcount = be32_to_cpu(from->sb_agcount);\n\tto->sb_rbmblocks = be32_to_cpu(from->sb_rbmblocks);\n\tto->sb_logblocks = be32_to_cpu(from->sb_logblocks);\n\tto->sb_versionnum = be16_to_cpu(from->sb_versionnum);\n\tto->sb_sectsize = be16_to_cpu(from->sb_sectsize);\n\tto->sb_inodesize = be16_to_cpu(from->sb_inodesize);\n\tto->sb_inopblock = be16_to_cpu(from->sb_inopblock);\n\tmemcpy(&to->sb_fname, &from->sb_fname, sizeof(to->sb_fname));\n\tto->sb_blocklog = from->sb_blocklog;\n\tto->sb_sectlog = from->sb_sectlog;\n\tto->sb_inodelog = from->sb_inodelog;\n\tto->sb_inopblog = from->sb_inopblog;\n\tto->sb_agblklog = from->sb_agblklog;\n\tto->sb_rextslog = from->sb_rextslog;\n\tto->sb_inprogress = from->sb_inprogress;\n\tto->sb_imax_pct = from->sb_imax_pct;\n\tto->sb_icount = be64_to_cpu(from->sb_icount);\n\tto->sb_ifree = be64_to_cpu(from->sb_ifree);\n\tto->sb_fdblocks = be64_to_cpu(from->sb_fdblocks);\n\tto->sb_frextents = be64_to_cpu(from->sb_frextents);\n\tto->sb_uquotino = be64_to_cpu(from->sb_uquotino);\n\tto->sb_gquotino = be64_to_cpu(from->sb_gquotino);\n\tto->sb_qflags = be16_to_cpu(from->sb_qflags);\n\tto->sb_flags = from->sb_flags;\n\tto->sb_shared_vn = from->sb_shared_vn;\n\tto->sb_inoalignmt = be32_to_cpu(from->sb_inoalignmt);\n\tto->sb_unit = be32_to_cpu(from->sb_unit);\n\tto->sb_width = be32_to_cpu(from->sb_width);\n\tto->sb_dirblklog = from->sb_dirblklog;\n\tto->sb_logsectlog = from->sb_logsectlog;\n\tto->sb_logsectsize = be16_to_cpu(from->sb_logsectsize);\n\tto->sb_logsunit = be32_to_cpu(from->sb_logsunit);\n\tto->sb_features2 = be32_to_cpu(from->sb_features2);\n\tto->sb_bad_features2 = be32_to_cpu(from->sb_bad_features2);\n\tto->sb_features_compat = be32_to_cpu(from->sb_features_compat);\n\tto->sb_features_ro_compat = be32_to_cpu(from->sb_features_ro_compat);\n\tto->sb_features_incompat = be32_to_cpu(from->sb_features_incompat);\n\tto->sb_features_log_incompat =\n\t\t\t\tbe32_to_cpu(from->sb_features_log_incompat);\n\t/* crc is only used on disk, not in memory; just init to 0 here. */\n\tto->sb_crc = 0;\n\tto->sb_pad = 0;\n\tto->sb_pquotino = be64_to_cpu(from->sb_pquotino);\n\tto->sb_lsn = be64_to_cpu(from->sb_lsn);\n\t/* Convert on-disk flags to in-memory flags? */\n\tif (convert_xquota)\n\t\txfs_sb_quota_from_disk(to);\n}"
  },
  {
    "function_name": "xfs_sb_quota_from_disk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
    "lines": "277-324",
    "snippet": "void\nxfs_sb_quota_from_disk(struct xfs_sb *sbp)\n{\n\t/*\n\t * older mkfs doesn't initialize quota inodes to NULLFSINO. This\n\t * leads to in-core values having two different values for a quota\n\t * inode to be invalid: 0 and NULLFSINO. Change it to a single value\n\t * NULLFSINO.\n\t *\n\t * Note that this change affect only the in-core values. These\n\t * values are not written back to disk unless any quota information\n\t * is written to the disk. Even in that case, sb_pquotino field is\n\t * not written to disk unless the superblock supports pquotino.\n\t */\n\tif (sbp->sb_uquotino == 0)\n\t\tsbp->sb_uquotino = NULLFSINO;\n\tif (sbp->sb_gquotino == 0)\n\t\tsbp->sb_gquotino = NULLFSINO;\n\tif (sbp->sb_pquotino == 0)\n\t\tsbp->sb_pquotino = NULLFSINO;\n\n\t/*\n\t * We need to do these manipilations only if we are working\n\t * with an older version of on-disk superblock.\n\t */\n\tif (xfs_sb_version_has_pquotino(sbp))\n\t\treturn;\n\n\tif (sbp->sb_qflags & XFS_OQUOTA_ENFD)\n\t\tsbp->sb_qflags |= (sbp->sb_qflags & XFS_PQUOTA_ACCT) ?\n\t\t\t\t\tXFS_PQUOTA_ENFD : XFS_GQUOTA_ENFD;\n\tif (sbp->sb_qflags & XFS_OQUOTA_CHKD)\n\t\tsbp->sb_qflags |= (sbp->sb_qflags & XFS_PQUOTA_ACCT) ?\n\t\t\t\t\tXFS_PQUOTA_CHKD : XFS_GQUOTA_CHKD;\n\tsbp->sb_qflags &= ~(XFS_OQUOTA_ENFD | XFS_OQUOTA_CHKD);\n\n\tif (sbp->sb_qflags & XFS_PQUOTA_ACCT)  {\n\t\t/*\n\t\t * In older version of superblock, on-disk superblock only\n\t\t * has sb_gquotino, and in-core superblock has both sb_gquotino\n\t\t * and sb_pquotino. But, only one of them is supported at any\n\t\t * point of time. So, if PQUOTA is set in disk superblock,\n\t\t * copy over sb_gquotino to sb_pquotino.\n\t\t */\n\t\tsbp->sb_pquotino = sbp->sb_gquotino;\n\t\tsbp->sb_gquotino = NULLFSINO;\n\t}\n}",
    "includes": [
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_sb_version_has_pquotino",
          "args": [
            "sbp"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_has_pquotino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "552-555",
          "snippet": "static inline int xfs_sb_version_has_pquotino(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_has_pquotino(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_sb_quota_from_disk(struct xfs_sb *sbp)\n{\n\t/*\n\t * older mkfs doesn't initialize quota inodes to NULLFSINO. This\n\t * leads to in-core values having two different values for a quota\n\t * inode to be invalid: 0 and NULLFSINO. Change it to a single value\n\t * NULLFSINO.\n\t *\n\t * Note that this change affect only the in-core values. These\n\t * values are not written back to disk unless any quota information\n\t * is written to the disk. Even in that case, sb_pquotino field is\n\t * not written to disk unless the superblock supports pquotino.\n\t */\n\tif (sbp->sb_uquotino == 0)\n\t\tsbp->sb_uquotino = NULLFSINO;\n\tif (sbp->sb_gquotino == 0)\n\t\tsbp->sb_gquotino = NULLFSINO;\n\tif (sbp->sb_pquotino == 0)\n\t\tsbp->sb_pquotino = NULLFSINO;\n\n\t/*\n\t * We need to do these manipilations only if we are working\n\t * with an older version of on-disk superblock.\n\t */\n\tif (xfs_sb_version_has_pquotino(sbp))\n\t\treturn;\n\n\tif (sbp->sb_qflags & XFS_OQUOTA_ENFD)\n\t\tsbp->sb_qflags |= (sbp->sb_qflags & XFS_PQUOTA_ACCT) ?\n\t\t\t\t\tXFS_PQUOTA_ENFD : XFS_GQUOTA_ENFD;\n\tif (sbp->sb_qflags & XFS_OQUOTA_CHKD)\n\t\tsbp->sb_qflags |= (sbp->sb_qflags & XFS_PQUOTA_ACCT) ?\n\t\t\t\t\tXFS_PQUOTA_CHKD : XFS_GQUOTA_CHKD;\n\tsbp->sb_qflags &= ~(XFS_OQUOTA_ENFD | XFS_OQUOTA_CHKD);\n\n\tif (sbp->sb_qflags & XFS_PQUOTA_ACCT)  {\n\t\t/*\n\t\t * In older version of superblock, on-disk superblock only\n\t\t * has sb_gquotino, and in-core superblock has both sb_gquotino\n\t\t * and sb_pquotino. But, only one of them is supported at any\n\t\t * point of time. So, if PQUOTA is set in disk superblock,\n\t\t * copy over sb_gquotino to sb_pquotino.\n\t\t */\n\t\tsbp->sb_pquotino = sbp->sb_gquotino;\n\t\tsbp->sb_gquotino = NULLFSINO;\n\t}\n}"
  },
  {
    "function_name": "xfs_mount_validate_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
    "lines": "107-275",
    "snippet": "STATIC int\nxfs_mount_validate_sb(\n\txfs_mount_t\t*mp,\n\txfs_sb_t\t*sbp,\n\tbool\t\tcheck_inprogress,\n\tbool\t\tcheck_version)\n{\n\n\t/*\n\t * If the log device and data device have the\n\t * same device number, the log is internal.\n\t * Consequently, the sb_logstart should be non-zero.  If\n\t * we have a zero sb_logstart in this case, we may be trying to mount\n\t * a volume filesystem in a non-volume manner.\n\t */\n\tif (sbp->sb_magicnum != XFS_SB_MAGIC) {\n\t\txfs_warn(mp, \"bad magic number\");\n\t\treturn -EWRONGFS;\n\t}\n\n\n\tif (!xfs_sb_good_version(sbp)) {\n\t\txfs_warn(mp, \"bad version\");\n\t\treturn -EWRONGFS;\n\t}\n\n\t/*\n\t * Version 5 superblock feature mask validation. Reject combinations the\n\t * kernel cannot support up front before checking anything else. For\n\t * write validation, we don't need to check feature masks.\n\t */\n\tif (check_version && XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5) {\n\t\tif (xfs_sb_has_compat_feature(sbp,\n\t\t\t\t\tXFS_SB_FEAT_COMPAT_UNKNOWN)) {\n\t\t\txfs_warn(mp,\n\"Superblock has unknown compatible features (0x%x) enabled.\\n\"\n\"Using a more recent kernel is recommended.\",\n\t\t\t\t(sbp->sb_features_compat &\n\t\t\t\t\t\tXFS_SB_FEAT_COMPAT_UNKNOWN));\n\t\t}\n\n\t\tif (xfs_sb_has_ro_compat_feature(sbp,\n\t\t\t\t\tXFS_SB_FEAT_RO_COMPAT_UNKNOWN)) {\n\t\t\txfs_alert(mp,\n\"Superblock has unknown read-only compatible features (0x%x) enabled.\",\n\t\t\t\t(sbp->sb_features_ro_compat &\n\t\t\t\t\t\tXFS_SB_FEAT_RO_COMPAT_UNKNOWN));\n\t\t\tif (!(mp->m_flags & XFS_MOUNT_RDONLY)) {\n\t\t\t\txfs_warn(mp,\n\"Attempted to mount read-only compatible filesystem read-write.\\n\"\n\"Filesystem can only be safely mounted read only.\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\tif (xfs_sb_has_incompat_feature(sbp,\n\t\t\t\t\tXFS_SB_FEAT_INCOMPAT_UNKNOWN)) {\n\t\t\txfs_warn(mp,\n\"Superblock has unknown incompatible features (0x%x) enabled.\\n\"\n\"Filesystem can not be safely mounted by this kernel.\",\n\t\t\t\t(sbp->sb_features_incompat &\n\t\t\t\t\t\tXFS_SB_FEAT_INCOMPAT_UNKNOWN));\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (xfs_sb_version_has_pquotino(sbp)) {\n\t\tif (sbp->sb_qflags & (XFS_OQUOTA_ENFD | XFS_OQUOTA_CHKD)) {\n\t\t\txfs_notice(mp,\n\t\t\t   \"Version 5 of Super block has XFS_OQUOTA bits.\");\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t} else if (sbp->sb_qflags & (XFS_PQUOTA_ENFD | XFS_GQUOTA_ENFD |\n\t\t\t\tXFS_PQUOTA_CHKD | XFS_GQUOTA_CHKD)) {\n\t\t\txfs_notice(mp,\n\"Superblock earlier than Version 5 has XFS_[PQ]UOTA_{ENFD|CHKD} bits.\");\n\t\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (unlikely(\n\t    sbp->sb_logstart == 0 && mp->m_logdev_targp == mp->m_ddev_targp)) {\n\t\txfs_warn(mp,\n\t\t\"filesystem is marked as having an external log; \"\n\t\t\"specify logdev on the mount command line.\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (unlikely(\n\t    sbp->sb_logstart != 0 && mp->m_logdev_targp != mp->m_ddev_targp)) {\n\t\txfs_warn(mp,\n\t\t\"filesystem is marked as having an internal log; \"\n\t\t\"do not specify logdev on the mount command line.\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * More sanity checking.  Most of these were stolen directly from\n\t * xfs_repair.\n\t */\n\tif (unlikely(\n\t    sbp->sb_agcount <= 0\t\t\t\t\t||\n\t    sbp->sb_sectsize < XFS_MIN_SECTORSIZE\t\t\t||\n\t    sbp->sb_sectsize > XFS_MAX_SECTORSIZE\t\t\t||\n\t    sbp->sb_sectlog < XFS_MIN_SECTORSIZE_LOG\t\t\t||\n\t    sbp->sb_sectlog > XFS_MAX_SECTORSIZE_LOG\t\t\t||\n\t    sbp->sb_sectsize != (1 << sbp->sb_sectlog)\t\t\t||\n\t    sbp->sb_blocksize < XFS_MIN_BLOCKSIZE\t\t\t||\n\t    sbp->sb_blocksize > XFS_MAX_BLOCKSIZE\t\t\t||\n\t    sbp->sb_blocklog < XFS_MIN_BLOCKSIZE_LOG\t\t\t||\n\t    sbp->sb_blocklog > XFS_MAX_BLOCKSIZE_LOG\t\t\t||\n\t    sbp->sb_blocksize != (1 << sbp->sb_blocklog)\t\t||\n\t    sbp->sb_dirblklog > XFS_MAX_BLOCKSIZE_LOG\t\t\t||\n\t    sbp->sb_inodesize < XFS_DINODE_MIN_SIZE\t\t\t||\n\t    sbp->sb_inodesize > XFS_DINODE_MAX_SIZE\t\t\t||\n\t    sbp->sb_inodelog < XFS_DINODE_MIN_LOG\t\t\t||\n\t    sbp->sb_inodelog > XFS_DINODE_MAX_LOG\t\t\t||\n\t    sbp->sb_inodesize != (1 << sbp->sb_inodelog)\t\t||\n\t    sbp->sb_logsunit > XLOG_MAX_RECORD_BSIZE\t\t\t||\n\t    sbp->sb_inopblock != howmany(sbp->sb_blocksize,sbp->sb_inodesize) ||\n\t    (sbp->sb_blocklog - sbp->sb_inodelog != sbp->sb_inopblog)\t||\n\t    (sbp->sb_rextsize * sbp->sb_blocksize > XFS_MAX_RTEXTSIZE)\t||\n\t    (sbp->sb_rextsize * sbp->sb_blocksize < XFS_MIN_RTEXTSIZE)\t||\n\t    (sbp->sb_imax_pct > 100 /* zero sb_imax_pct is valid */)\t||\n\t    sbp->sb_dblocks == 0\t\t\t\t\t||\n\t    sbp->sb_dblocks > XFS_MAX_DBLOCKS(sbp)\t\t\t||\n\t    sbp->sb_dblocks < XFS_MIN_DBLOCKS(sbp)\t\t\t||\n\t    sbp->sb_shared_vn != 0)) {\n\t\txfs_notice(mp, \"SB sanity check failed\");\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/*\n\t * Until this is fixed only page-sized or smaller data blocks work.\n\t */\n\tif (unlikely(sbp->sb_blocksize > PAGE_SIZE)) {\n\t\txfs_warn(mp,\n\t\t\"File system with blocksize %d bytes. \"\n\t\t\"Only pagesize (%ld) or less will currently work.\",\n\t\t\t\tsbp->sb_blocksize, PAGE_SIZE);\n\t\treturn -ENOSYS;\n\t}\n\n\t/*\n\t * Currently only very few inode sizes are supported.\n\t */\n\tswitch (sbp->sb_inodesize) {\n\tcase 256:\n\tcase 512:\n\tcase 1024:\n\tcase 2048:\n\t\tbreak;\n\tdefault:\n\t\txfs_warn(mp, \"inode size of %d bytes not supported\",\n\t\t\t\tsbp->sb_inodesize);\n\t\treturn -ENOSYS;\n\t}\n\n\tif (xfs_sb_validate_fsb_count(sbp, sbp->sb_dblocks) ||\n\t    xfs_sb_validate_fsb_count(sbp, sbp->sb_rblocks)) {\n\t\txfs_warn(mp,\n\t\t\"file system too large to be mounted on this system.\");\n\t\treturn -EFBIG;\n\t}\n\n\tif (check_inprogress && sbp->sb_inprogress) {\n\t\txfs_warn(mp, \"Offline file system operation in progress!\");\n\t\treturn -EFSCORRUPTED;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"Offline file system operation in progress!\""
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"file system too large to be mounted on this system.\""
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_validate_fsb_count",
          "args": [
            "sbp",
            "sbp->sb_rblocks"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_validate_fsb_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_mount.c",
          "lines": "167-179",
          "snippet": "int\nxfs_sb_validate_fsb_count(\n\txfs_sb_t\t*sbp,\n\t__uint64_t\tnblocks)\n{\n\tASSERT(PAGE_SHIFT >= sbp->sb_blocklog);\n\tASSERT(sbp->sb_blocklog >= BBSHIFT);\n\n\t/* Limited by ULONG_MAX of page cache index */\n\tif (nblocks >> (PAGE_CACHE_SHIFT - sbp->sb_blocklog) > ULONG_MAX)\n\t\treturn -EFBIG;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfs_sysfs.h\"",
            "#include \"xfs_icache.h\"",
            "#include \"xfs_trace.h\"",
            "#include \"xfs_fsops.h\"",
            "#include \"xfs_quota.h\"",
            "#include \"xfs_error.h\"",
            "#include \"xfs_log.h\"",
            "#include \"xfs_trans_priv.h\"",
            "#include \"xfs_trans.h\"",
            "#include \"xfs_bmap.h\"",
            "#include \"xfs_rtalloc.h\"",
            "#include \"xfs_alloc.h\"",
            "#include \"xfs_ialloc.h\"",
            "#include \"xfs_dir2.h\"",
            "#include \"xfs_inode.h\"",
            "#include \"xfs_da_btree.h\"",
            "#include \"xfs_da_format.h\"",
            "#include \"xfs_mount.h\"",
            "#include \"xfs_sb.h\"",
            "#include \"xfs_bit.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_shared.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_sysfs.h\"\n#include \"xfs_icache.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_fsops.h\"\n#include \"xfs_quota.h\"\n#include \"xfs_error.h\"\n#include \"xfs_log.h\"\n#include \"xfs_trans_priv.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_bmap.h\"\n#include \"xfs_rtalloc.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_dir2.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_da_btree.h\"\n#include \"xfs_da_format.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nint\nxfs_sb_validate_fsb_count(\n\txfs_sb_t\t*sbp,\n\t__uint64_t\tnblocks)\n{\n\tASSERT(PAGE_SHIFT >= sbp->sb_blocklog);\n\tASSERT(sbp->sb_blocklog >= BBSHIFT);\n\n\t/* Limited by ULONG_MAX of page cache index */\n\tif (nblocks >> (PAGE_CACHE_SHIFT - sbp->sb_blocklog) > ULONG_MAX)\n\t\treturn -EFBIG;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"inode size of %d bytes not supported\"",
            "sbp->sb_inodesize"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"File system with blocksize %d bytes. \"\n\t\t\"Only pagesize (%ld) or less will currently work.\"",
            "sbp->sb_blocksize",
            "PAGE_SIZE"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "sbp->sb_blocksize > PAGE_SIZE"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_notice",
          "args": [
            "mp",
            "\"SB sanity check failed\""
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "sbp->sb_agcount <= 0\t\t\t\t\t||\n\t    sbp->sb_sectsize < XFS_MIN_SECTORSIZE\t\t\t||\n\t    sbp->sb_sectsize > XFS_MAX_SECTORSIZE\t\t\t||\n\t    sbp->sb_sectlog < XFS_MIN_SECTORSIZE_LOG\t\t\t||\n\t    sbp->sb_sectlog > XFS_MAX_SECTORSIZE_LOG\t\t\t||\n\t    sbp->sb_sectsize != (1 << sbp->sb_sectlog)\t\t\t||\n\t    sbp->sb_blocksize < XFS_MIN_BLOCKSIZE\t\t\t||\n\t    sbp->sb_blocksize > XFS_MAX_BLOCKSIZE\t\t\t||\n\t    sbp->sb_blocklog < XFS_MIN_BLOCKSIZE_LOG\t\t\t||\n\t    sbp->sb_blocklog > XFS_MAX_BLOCKSIZE_LOG\t\t\t||\n\t    sbp->sb_blocksize != (1 << sbp->sb_blocklog)\t\t||\n\t    sbp->sb_dirblklog > XFS_MAX_BLOCKSIZE_LOG\t\t\t||\n\t    sbp->sb_inodesize < XFS_DINODE_MIN_SIZE\t\t\t||\n\t    sbp->sb_inodesize > XFS_DINODE_MAX_SIZE\t\t\t||\n\t    sbp->sb_inodelog < XFS_DINODE_MIN_LOG\t\t\t||\n\t    sbp->sb_inodelog > XFS_DINODE_MAX_LOG\t\t\t||\n\t    sbp->sb_inodesize != (1 << sbp->sb_inodelog)\t\t||\n\t    sbp->sb_logsunit > XLOG_MAX_RECORD_BSIZE\t\t\t||\n\t    sbp->sb_inopblock != howmany(sbp->sb_blocksize,sbp->sb_inodesize) ||\n\t    (sbp->sb_blocklog - sbp->sb_inodelog != sbp->sb_inopblog)\t||\n\t    (sbp->sb_rextsize * sbp->sb_blocksize > XFS_MAX_RTEXTSIZE)\t||\n\t    (sbp->sb_rextsize * sbp->sb_blocksize < XFS_MIN_RTEXTSIZE)\t||\n\t    (sbp->sb_imax_pct > 100 /* zero sb_imax_pct is valid */)\t||\n\t    sbp->sb_dblocks == 0\t\t\t\t\t||\n\t    sbp->sb_dblocks > XFS_MAX_DBLOCKS(sbp)\t\t\t||\n\t    sbp->sb_dblocks < XFS_MIN_DBLOCKS(sbp)\t\t\t||\n\t    sbp->sb_shared_vn != 0"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_MIN_DBLOCKS",
          "args": [
            "sbp"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "XFS_MAX_DBLOCKS",
          "args": [
            "sbp"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "howmany",
          "args": [
            "sbp->sb_blocksize",
            "sbp->sb_inodesize"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "howmany_64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_linux.h",
          "lines": "340-345",
          "snippet": "static inline __uint64_t howmany_64(__uint64_t x, __uint32_t y)\n{\n\tx += y - 1;\n\tdo_div(x, y);\n\treturn x;\n}",
          "includes": [
            "#include \"xfs_message.h\"",
            "#include \"xfs_buf.h\"",
            "#include \"xfs_cksum.h\"",
            "#include \"xfs_super.h\"",
            "#include \"xfs_aops.h\"",
            "#include \"xfs_iops.h\"",
            "#include \"xfs_sysctl.h\"",
            "#include \"xfs_stats.h\"",
            "#include \"xfs_fs.h\"",
            "#include <asm/unaligned.h>",
            "#include <asm/byteorder.h>",
            "#include <asm/uaccess.h>",
            "#include <asm/param.h>",
            "#include <asm/div64.h>",
            "#include <asm/page.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/list_sort.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/capability.h>",
            "#include <linux/writeback.h>",
            "#include <linux/ctype.h>",
            "#include <linux/random.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/log2.h>",
            "#include <linux/delay.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sort.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/list.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/vfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/major.h>",
            "#include <linux/bitops.h>",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/swap.h>",
            "#include <linux/file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/crc32c.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mm.h>",
            "#include <linux/semaphore.h>",
            "#include \"uuid.h\"",
            "#include \"mrlock.h\"",
            "#include \"kmem.h\"",
            "#include \"xfs_types.h\"",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_message.h\"\n#include \"xfs_buf.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_super.h\"\n#include \"xfs_aops.h\"\n#include \"xfs_iops.h\"\n#include \"xfs_sysctl.h\"\n#include \"xfs_stats.h\"\n#include \"xfs_fs.h\"\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n#include <asm/uaccess.h>\n#include <asm/param.h>\n#include <asm/div64.h>\n#include <asm/page.h>\n#include <linux/ratelimit.h>\n#include <linux/list_sort.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/capability.h>\n#include <linux/writeback.h>\n#include <linux/ctype.h>\n#include <linux/random.h>\n#include <linux/spinlock.h>\n#include <linux/log2.h>\n#include <linux/delay.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/sort.h>\n#include <linux/proc_fs.h>\n#include <linux/list.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/vfs.h>\n#include <linux/pagemap.h>\n#include <linux/major.h>\n#include <linux/bitops.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/swap.h>\n#include <linux/file.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/crc32c.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/semaphore.h>\n#include \"uuid.h\"\n#include \"mrlock.h\"\n#include \"kmem.h\"\n#include \"xfs_types.h\"\n#include <linux/types.h>\n\nstatic inline __uint64_t howmany_64(__uint64_t x, __uint32_t y)\n{\n\tx += y - 1;\n\tdo_div(x, y);\n\treturn x;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"filesystem is marked as having an internal log; \"\n\t\t\"do not specify logdev on the mount command line.\""
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "sbp->sb_logstart != 0 && mp->m_logdev_targp != mp->m_ddev_targp"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"filesystem is marked as having an external log; \"\n\t\t\"specify logdev on the mount command line.\""
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "sbp->sb_logstart == 0 && mp->m_logdev_targp == mp->m_ddev_targp"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_notice",
          "args": [
            "mp",
            "\"Superblock earlier than Version 5 has XFS_[PQ]UOTA_{ENFD|CHKD} bits.\""
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_notice",
          "args": [
            "mp",
            "\"Version 5 of Super block has XFS_OQUOTA bits.\""
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_version_has_pquotino",
          "args": [
            "sbp"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_version_has_pquotino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "552-555",
          "snippet": "static inline int xfs_sb_version_has_pquotino(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n\nstatic inline int xfs_sb_version_has_pquotino(struct xfs_sb *sbp)\n{\n\treturn XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"Superblock has unknown incompatible features (0x%x) enabled.\\n\"\n\"Filesystem can not be safely mounted by this kernel.\"",
            "(sbp->sb_features_incompat &\n\t\t\t\t\t\tXFS_SB_FEAT_INCOMPAT_UNKNOWN)"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_has_incompat_feature",
          "args": [
            "sbp",
            "XFS_SB_FEAT_INCOMPAT_UNKNOWN"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_has_incompat_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "526-532",
          "snippet": "static inline bool\nxfs_sb_has_incompat_feature(\n\tstruct xfs_sb\t*sbp,\n\t__uint32_t\tfeature)\n{\n\treturn (sbp->sb_features_incompat & feature) != 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool\nxfs_sb_has_incompat_feature(\n\tstruct xfs_sb\t*sbp,\n\t__uint32_t\tfeature)\n{\n\treturn (sbp->sb_features_incompat & feature) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"Attempted to mount read-only compatible filesystem read-write.\\n\"\n\"Filesystem can only be safely mounted read only.\""
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_alert",
          "args": [
            "mp",
            "\"Superblock has unknown read-only compatible features (0x%x) enabled.\"",
            "(sbp->sb_features_ro_compat &\n\t\t\t\t\t\tXFS_SB_FEAT_RO_COMPAT_UNKNOWN)"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_alert_tag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/xfs_message.c",
          "lines": "67-91",
          "snippet": "void\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}",
          "includes": [
            "#include \"xfs_mount.h\"",
            "#include \"xfs_trans_resv.h\"",
            "#include \"xfs_log_format.h\"",
            "#include \"xfs_format.h\"",
            "#include \"xfs_fs.h\"",
            "#include \"xfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfs_mount.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_alert_tag(\n\tconst struct xfs_mount\t*mp,\n\tint\t\t\tpanic_tag,\n\tconst char\t\t*fmt, ...)\n{\n\tstruct va_format\tvaf;\n\tva_list\t\t\targs;\n\tint\t\t\tdo_panic = 0;\n\n\tif (xfs_panic_mask && (xfs_panic_mask & panic_tag)) {\n\t\txfs_alert(mp, \"Transforming an alert into a BUG.\");\n\t\tdo_panic = 1;\n\t}\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\t__xfs_printk(KERN_ALERT, mp, &vaf);\n\tva_end(args);\n\n\tBUG_ON(do_panic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_sb_has_ro_compat_feature",
          "args": [
            "sbp",
            "XFS_SB_FEAT_RO_COMPAT_UNKNOWN"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_has_ro_compat_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "513-519",
          "snippet": "static inline bool\nxfs_sb_has_ro_compat_feature(\n\tstruct xfs_sb\t*sbp,\n\t__uint32_t\tfeature)\n{\n\treturn (sbp->sb_features_ro_compat & feature) != 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool\nxfs_sb_has_ro_compat_feature(\n\tstruct xfs_sb\t*sbp,\n\t__uint32_t\tfeature)\n{\n\treturn (sbp->sb_features_ro_compat & feature) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"Superblock has unknown compatible features (0x%x) enabled.\\n\"\n\"Using a more recent kernel is recommended.\"",
            "(sbp->sb_features_compat &\n\t\t\t\t\t\tXFS_SB_FEAT_COMPAT_UNKNOWN)"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_has_compat_feature",
          "args": [
            "sbp",
            "XFS_SB_FEAT_COMPAT_UNKNOWN"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_has_compat_feature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "501-507",
          "snippet": "static inline bool\nxfs_sb_has_compat_feature(\n\tstruct xfs_sb\t*sbp,\n\t__uint32_t\tfeature)\n{\n\treturn (sbp->sb_features_compat & feature) != 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool\nxfs_sb_has_compat_feature(\n\tstruct xfs_sb\t*sbp,\n\t__uint32_t\tfeature)\n{\n\treturn (sbp->sb_features_compat & feature) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "XFS_SB_VERSION_NUM",
          "args": [
            "sbp"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"bad version\""
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfs_sb_good_version",
          "args": [
            "sbp"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "xfs_sb_good_version",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_format.h",
          "lines": "361-368",
          "snippet": "static inline bool xfs_sb_good_version(struct xfs_sb *sbp)\n{\n\tif (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5)\n\t\treturn true;\n\tif (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_4)\n\t\treturn xfs_sb_good_v4_features(sbp);\n\treturn false;\n}",
          "includes": [],
          "macros_used": [
            "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */",
            "#define\tXFS_SB_VERSION_4\t4\t\t/* 6.2+ - bitmask version */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define\tXFS_SB_VERSION_5\t5\t\t/* CRC enabled filesystem */\n#define\tXFS_SB_VERSION_4\t4\t\t/* 6.2+ - bitmask version */\n\nstatic inline bool xfs_sb_good_version(struct xfs_sb *sbp)\n{\n\tif (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5)\n\t\treturn true;\n\tif (XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_4)\n\t\treturn xfs_sb_good_v4_features(sbp);\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfs_warn",
          "args": [
            "mp",
            "\"bad magic number\""
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nSTATIC int\nxfs_mount_validate_sb(\n\txfs_mount_t\t*mp,\n\txfs_sb_t\t*sbp,\n\tbool\t\tcheck_inprogress,\n\tbool\t\tcheck_version)\n{\n\n\t/*\n\t * If the log device and data device have the\n\t * same device number, the log is internal.\n\t * Consequently, the sb_logstart should be non-zero.  If\n\t * we have a zero sb_logstart in this case, we may be trying to mount\n\t * a volume filesystem in a non-volume manner.\n\t */\n\tif (sbp->sb_magicnum != XFS_SB_MAGIC) {\n\t\txfs_warn(mp, \"bad magic number\");\n\t\treturn -EWRONGFS;\n\t}\n\n\n\tif (!xfs_sb_good_version(sbp)) {\n\t\txfs_warn(mp, \"bad version\");\n\t\treturn -EWRONGFS;\n\t}\n\n\t/*\n\t * Version 5 superblock feature mask validation. Reject combinations the\n\t * kernel cannot support up front before checking anything else. For\n\t * write validation, we don't need to check feature masks.\n\t */\n\tif (check_version && XFS_SB_VERSION_NUM(sbp) == XFS_SB_VERSION_5) {\n\t\tif (xfs_sb_has_compat_feature(sbp,\n\t\t\t\t\tXFS_SB_FEAT_COMPAT_UNKNOWN)) {\n\t\t\txfs_warn(mp,\n\"Superblock has unknown compatible features (0x%x) enabled.\\n\"\n\"Using a more recent kernel is recommended.\",\n\t\t\t\t(sbp->sb_features_compat &\n\t\t\t\t\t\tXFS_SB_FEAT_COMPAT_UNKNOWN));\n\t\t}\n\n\t\tif (xfs_sb_has_ro_compat_feature(sbp,\n\t\t\t\t\tXFS_SB_FEAT_RO_COMPAT_UNKNOWN)) {\n\t\t\txfs_alert(mp,\n\"Superblock has unknown read-only compatible features (0x%x) enabled.\",\n\t\t\t\t(sbp->sb_features_ro_compat &\n\t\t\t\t\t\tXFS_SB_FEAT_RO_COMPAT_UNKNOWN));\n\t\t\tif (!(mp->m_flags & XFS_MOUNT_RDONLY)) {\n\t\t\t\txfs_warn(mp,\n\"Attempted to mount read-only compatible filesystem read-write.\\n\"\n\"Filesystem can only be safely mounted read only.\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t\tif (xfs_sb_has_incompat_feature(sbp,\n\t\t\t\t\tXFS_SB_FEAT_INCOMPAT_UNKNOWN)) {\n\t\t\txfs_warn(mp,\n\"Superblock has unknown incompatible features (0x%x) enabled.\\n\"\n\"Filesystem can not be safely mounted by this kernel.\",\n\t\t\t\t(sbp->sb_features_incompat &\n\t\t\t\t\t\tXFS_SB_FEAT_INCOMPAT_UNKNOWN));\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (xfs_sb_version_has_pquotino(sbp)) {\n\t\tif (sbp->sb_qflags & (XFS_OQUOTA_ENFD | XFS_OQUOTA_CHKD)) {\n\t\t\txfs_notice(mp,\n\t\t\t   \"Version 5 of Super block has XFS_OQUOTA bits.\");\n\t\t\treturn -EFSCORRUPTED;\n\t\t}\n\t} else if (sbp->sb_qflags & (XFS_PQUOTA_ENFD | XFS_GQUOTA_ENFD |\n\t\t\t\tXFS_PQUOTA_CHKD | XFS_GQUOTA_CHKD)) {\n\t\t\txfs_notice(mp,\n\"Superblock earlier than Version 5 has XFS_[PQ]UOTA_{ENFD|CHKD} bits.\");\n\t\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (unlikely(\n\t    sbp->sb_logstart == 0 && mp->m_logdev_targp == mp->m_ddev_targp)) {\n\t\txfs_warn(mp,\n\t\t\"filesystem is marked as having an external log; \"\n\t\t\"specify logdev on the mount command line.\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (unlikely(\n\t    sbp->sb_logstart != 0 && mp->m_logdev_targp != mp->m_ddev_targp)) {\n\t\txfs_warn(mp,\n\t\t\"filesystem is marked as having an internal log; \"\n\t\t\"do not specify logdev on the mount command line.\");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * More sanity checking.  Most of these were stolen directly from\n\t * xfs_repair.\n\t */\n\tif (unlikely(\n\t    sbp->sb_agcount <= 0\t\t\t\t\t||\n\t    sbp->sb_sectsize < XFS_MIN_SECTORSIZE\t\t\t||\n\t    sbp->sb_sectsize > XFS_MAX_SECTORSIZE\t\t\t||\n\t    sbp->sb_sectlog < XFS_MIN_SECTORSIZE_LOG\t\t\t||\n\t    sbp->sb_sectlog > XFS_MAX_SECTORSIZE_LOG\t\t\t||\n\t    sbp->sb_sectsize != (1 << sbp->sb_sectlog)\t\t\t||\n\t    sbp->sb_blocksize < XFS_MIN_BLOCKSIZE\t\t\t||\n\t    sbp->sb_blocksize > XFS_MAX_BLOCKSIZE\t\t\t||\n\t    sbp->sb_blocklog < XFS_MIN_BLOCKSIZE_LOG\t\t\t||\n\t    sbp->sb_blocklog > XFS_MAX_BLOCKSIZE_LOG\t\t\t||\n\t    sbp->sb_blocksize != (1 << sbp->sb_blocklog)\t\t||\n\t    sbp->sb_dirblklog > XFS_MAX_BLOCKSIZE_LOG\t\t\t||\n\t    sbp->sb_inodesize < XFS_DINODE_MIN_SIZE\t\t\t||\n\t    sbp->sb_inodesize > XFS_DINODE_MAX_SIZE\t\t\t||\n\t    sbp->sb_inodelog < XFS_DINODE_MIN_LOG\t\t\t||\n\t    sbp->sb_inodelog > XFS_DINODE_MAX_LOG\t\t\t||\n\t    sbp->sb_inodesize != (1 << sbp->sb_inodelog)\t\t||\n\t    sbp->sb_logsunit > XLOG_MAX_RECORD_BSIZE\t\t\t||\n\t    sbp->sb_inopblock != howmany(sbp->sb_blocksize,sbp->sb_inodesize) ||\n\t    (sbp->sb_blocklog - sbp->sb_inodelog != sbp->sb_inopblog)\t||\n\t    (sbp->sb_rextsize * sbp->sb_blocksize > XFS_MAX_RTEXTSIZE)\t||\n\t    (sbp->sb_rextsize * sbp->sb_blocksize < XFS_MIN_RTEXTSIZE)\t||\n\t    (sbp->sb_imax_pct > 100 /* zero sb_imax_pct is valid */)\t||\n\t    sbp->sb_dblocks == 0\t\t\t\t\t||\n\t    sbp->sb_dblocks > XFS_MAX_DBLOCKS(sbp)\t\t\t||\n\t    sbp->sb_dblocks < XFS_MIN_DBLOCKS(sbp)\t\t\t||\n\t    sbp->sb_shared_vn != 0)) {\n\t\txfs_notice(mp, \"SB sanity check failed\");\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/*\n\t * Until this is fixed only page-sized or smaller data blocks work.\n\t */\n\tif (unlikely(sbp->sb_blocksize > PAGE_SIZE)) {\n\t\txfs_warn(mp,\n\t\t\"File system with blocksize %d bytes. \"\n\t\t\"Only pagesize (%ld) or less will currently work.\",\n\t\t\t\tsbp->sb_blocksize, PAGE_SIZE);\n\t\treturn -ENOSYS;\n\t}\n\n\t/*\n\t * Currently only very few inode sizes are supported.\n\t */\n\tswitch (sbp->sb_inodesize) {\n\tcase 256:\n\tcase 512:\n\tcase 1024:\n\tcase 2048:\n\t\tbreak;\n\tdefault:\n\t\txfs_warn(mp, \"inode size of %d bytes not supported\",\n\t\t\t\tsbp->sb_inodesize);\n\t\treturn -ENOSYS;\n\t}\n\n\tif (xfs_sb_validate_fsb_count(sbp, sbp->sb_dblocks) ||\n\t    xfs_sb_validate_fsb_count(sbp, sbp->sb_rblocks)) {\n\t\txfs_warn(mp,\n\t\t\"file system too large to be mounted on this system.\");\n\t\treturn -EFBIG;\n\t}\n\n\tif (check_inprogress && sbp->sb_inprogress) {\n\t\txfs_warn(mp, \"Offline file system operation in progress!\");\n\t\treturn -EFSCORRUPTED;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "xfs_perag_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
    "lines": "93-102",
    "snippet": "void\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}",
    "includes": [
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_xfs_perag_put",
          "args": [
            "pag->pag_mount",
            "pag->pag_agno",
            "ref",
            "_RET_IP_"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_return",
          "args": [
            "&pag->pag_ref"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "atomic_read(&pag->pag_ref) > 0"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&pag->pag_ref"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nvoid\nxfs_perag_put(\n\tstruct xfs_perag\t*pag)\n{\n\tint\tref;\n\n\tASSERT(atomic_read(&pag->pag_ref) > 0);\n\tref = atomic_dec_return(&pag->pag_ref);\n\ttrace_xfs_perag_put(pag->pag_mount, pag->pag_agno, ref, _RET_IP_);\n}"
  },
  {
    "function_name": "xfs_perag_get_tag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
    "lines": "70-91",
    "snippet": "struct xfs_perag *\nxfs_perag_get_tag(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tfirst,\n\tint\t\t\ttag)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tfound;\n\tint\t\t\tref;\n\n\trcu_read_lock();\n\tfound = radix_tree_gang_lookup_tag(&mp->m_perag_tree,\n\t\t\t\t\t(void **)&pag, first, 1, tag);\n\tif (found <= 0) {\n\t\trcu_read_unlock();\n\t\treturn NULL;\n\t}\n\tref = atomic_inc_return(&pag->pag_ref);\n\trcu_read_unlock();\n\ttrace_xfs_perag_get_tag(mp, pag->pag_agno, ref, _RET_IP_);\n\treturn pag;\n}",
    "includes": [
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_xfs_perag_get_tag",
          "args": [
            "mp",
            "pag->pag_agno",
            "ref",
            "_RET_IP_"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&pag->pag_ref"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_gang_lookup_tag",
          "args": [
            "&mp->m_perag_tree",
            "(void **)&pag",
            "first",
            "1",
            "tag"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstruct xfs_perag *\nxfs_perag_get_tag(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tfirst,\n\tint\t\t\ttag)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tfound;\n\tint\t\t\tref;\n\n\trcu_read_lock();\n\tfound = radix_tree_gang_lookup_tag(&mp->m_perag_tree,\n\t\t\t\t\t(void **)&pag, first, 1, tag);\n\tif (found <= 0) {\n\t\trcu_read_unlock();\n\t\treturn NULL;\n\t}\n\tref = atomic_inc_return(&pag->pag_ref);\n\trcu_read_unlock();\n\ttrace_xfs_perag_get_tag(mp, pag->pag_agno, ref, _RET_IP_);\n\treturn pag;\n}"
  },
  {
    "function_name": "xfs_perag_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/libxfs/xfs_sb.c",
    "lines": "48-65",
    "snippet": "struct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}",
    "includes": [
      "#include \"xfs_ialloc_btree.h\"",
      "#include \"xfs_alloc_btree.h\"",
      "#include \"xfs_bmap_btree.h\"",
      "#include \"xfs_buf_item.h\"",
      "#include \"xfs_trans.h\"",
      "#include \"xfs_cksum.h\"",
      "#include \"xfs_trace.h\"",
      "#include \"xfs_error.h\"",
      "#include \"xfs_alloc.h\"",
      "#include \"xfs_ialloc.h\"",
      "#include \"xfs_inode.h\"",
      "#include \"xfs_mount.h\"",
      "#include \"xfs_sb.h\"",
      "#include \"xfs_bit.h\"",
      "#include \"xfs_trans_resv.h\"",
      "#include \"xfs_log_format.h\"",
      "#include \"xfs_format.h\"",
      "#include \"xfs_shared.h\"",
      "#include \"xfs_fs.h\"",
      "#include \"xfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_xfs_perag_get",
          "args": [
            "mp",
            "agno",
            "ref",
            "_RET_IP_"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&pag->pag_ref"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "atomic_read(&pag->pag_ref) >= 0"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&pag->pag_ref"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_lookup",
          "args": [
            "&mp->m_perag_tree",
            "agno"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfs_ialloc_btree.h\"\n#include \"xfs_alloc_btree.h\"\n#include \"xfs_bmap_btree.h\"\n#include \"xfs_buf_item.h\"\n#include \"xfs_trans.h\"\n#include \"xfs_cksum.h\"\n#include \"xfs_trace.h\"\n#include \"xfs_error.h\"\n#include \"xfs_alloc.h\"\n#include \"xfs_ialloc.h\"\n#include \"xfs_inode.h\"\n#include \"xfs_mount.h\"\n#include \"xfs_sb.h\"\n#include \"xfs_bit.h\"\n#include \"xfs_trans_resv.h\"\n#include \"xfs_log_format.h\"\n#include \"xfs_format.h\"\n#include \"xfs_shared.h\"\n#include \"xfs_fs.h\"\n#include \"xfs.h\"\n\nstruct xfs_perag *\nxfs_perag_get(\n\tstruct xfs_mount\t*mp,\n\txfs_agnumber_t\t\tagno)\n{\n\tstruct xfs_perag\t*pag;\n\tint\t\t\tref = 0;\n\n\trcu_read_lock();\n\tpag = radix_tree_lookup(&mp->m_perag_tree, agno);\n\tif (pag) {\n\t\tASSERT(atomic_read(&pag->pag_ref) >= 0);\n\t\tref = atomic_inc_return(&pag->pag_ref);\n\t}\n\trcu_read_unlock();\n\ttrace_xfs_perag_get(mp, agno, ref, _RET_IP_);\n\treturn pag;\n}"
  }
]