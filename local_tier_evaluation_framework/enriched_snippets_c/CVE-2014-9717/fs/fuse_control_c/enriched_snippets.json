[
  {
    "function_name": "fuse_ctl_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/control.c",
    "lines": "351-354",
    "snippet": "void __exit fuse_ctl_cleanup(void)\n{\n\tunregister_filesystem(&fuse_ctl_fs_type);\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type fuse_ctl_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"fusectl\",\n\t.mount\t\t= fuse_ctl_mount,\n\t.kill_sb\t= fuse_ctl_kill_sb,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_filesystem",
          "args": [
            "&fuse_ctl_fs_type"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic struct file_system_type fuse_ctl_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"fusectl\",\n\t.mount\t\t= fuse_ctl_mount,\n\t.kill_sb\t= fuse_ctl_kill_sb,\n};\n\nvoid __exit fuse_ctl_cleanup(void)\n{\n\tunregister_filesystem(&fuse_ctl_fs_type);\n}"
  },
  {
    "function_name": "fuse_ctl_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/control.c",
    "lines": "346-349",
    "snippet": "int __init fuse_ctl_init(void)\n{\n\treturn register_filesystem(&fuse_ctl_fs_type);\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type fuse_ctl_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"fusectl\",\n\t.mount\t\t= fuse_ctl_mount,\n\t.kill_sb\t= fuse_ctl_kill_sb,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_filesystem",
          "args": [
            "&fuse_ctl_fs_type"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_filesystem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/filesystems.c",
          "lines": "101-120",
          "snippet": "int unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kmod.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct file_system_type *file_systems;",
            "static DEFINE_RWLOCK(file_systems_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/uaccess.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kmod.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n\nstatic struct file_system_type *file_systems;\nstatic DEFINE_RWLOCK(file_systems_lock);\n\nint unregister_filesystem(struct file_system_type * fs)\n{\n\tstruct file_system_type ** tmp;\n\n\twrite_lock(&file_systems_lock);\n\ttmp = &file_systems;\n\twhile (*tmp) {\n\t\tif (fs == *tmp) {\n\t\t\t*tmp = fs->next;\n\t\t\tfs->next = NULL;\n\t\t\twrite_unlock(&file_systems_lock);\n\t\t\tsynchronize_rcu();\n\t\t\treturn 0;\n\t\t}\n\t\ttmp = &(*tmp)->next;\n\t}\n\twrite_unlock(&file_systems_lock);\n\n\treturn -EINVAL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic struct file_system_type fuse_ctl_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"fusectl\",\n\t.mount\t\t= fuse_ctl_mount,\n\t.kill_sb\t= fuse_ctl_kill_sb,\n};\n\nint __init fuse_ctl_init(void)\n{\n\treturn register_filesystem(&fuse_ctl_fs_type);\n}"
  },
  {
    "function_name": "fuse_ctl_kill_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/control.c",
    "lines": "325-336",
    "snippet": "static void fuse_ctl_kill_sb(struct super_block *sb)\n{\n\tstruct fuse_conn *fc;\n\n\tmutex_lock(&fuse_mutex);\n\tfuse_control_sb = NULL;\n\tlist_for_each_entry(fc, &fuse_conn_list, entry)\n\t\tfc->ctl_ndents = 0;\n\tmutex_unlock(&fuse_mutex);\n\n\tkill_litter_super(sb);\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct super_block *fuse_control_sb;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kill_litter_super",
          "args": [
            "sb"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fuse_mutex"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "fc",
            "&fuse_conn_list",
            "entry"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fuse_mutex"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic struct super_block *fuse_control_sb;\n\nstatic void fuse_ctl_kill_sb(struct super_block *sb)\n{\n\tstruct fuse_conn *fc;\n\n\tmutex_lock(&fuse_mutex);\n\tfuse_control_sb = NULL;\n\tlist_for_each_entry(fc, &fuse_conn_list, entry)\n\t\tfc->ctl_ndents = 0;\n\tmutex_unlock(&fuse_mutex);\n\n\tkill_litter_super(sb);\n}"
  },
  {
    "function_name": "fuse_ctl_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/control.c",
    "lines": "319-323",
    "snippet": "static struct dentry *fuse_ctl_mount(struct file_system_type *fs_type,\n\t\t\tint flags, const char *dev_name, void *raw_data)\n{\n\treturn mount_single(fs_type, flags, raw_data, fuse_ctl_fill_super);\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mount_single",
          "args": [
            "fs_type",
            "flags",
            "raw_data",
            "fuse_ctl_fill_super"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic struct dentry *fuse_ctl_mount(struct file_system_type *fs_type,\n\t\t\tint flags, const char *dev_name, void *raw_data)\n{\n\treturn mount_single(fs_type, flags, raw_data, fuse_ctl_fill_super);\n}"
  },
  {
    "function_name": "fuse_ctl_fill_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/control.c",
    "lines": "293-317",
    "snippet": "static int fuse_ctl_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct tree_descr empty_descr = {\"\"};\n\tstruct fuse_conn *fc;\n\tint err;\n\n\terr = simple_fill_super(sb, FUSE_CTL_SUPER_MAGIC, &empty_descr);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&fuse_mutex);\n\tBUG_ON(fuse_control_sb);\n\tfuse_control_sb = sb;\n\tlist_for_each_entry(fc, &fuse_conn_list, entry) {\n\t\terr = fuse_ctl_add_conn(fc);\n\t\tif (err) {\n\t\t\tfuse_control_sb = NULL;\n\t\t\tmutex_unlock(&fuse_mutex);\n\t\t\treturn err;\n\t\t}\n\t}\n\tmutex_unlock(&fuse_mutex);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [
      "#define FUSE_CTL_SUPER_MAGIC 0x65735543"
    ],
    "globals_used": [
      "static struct super_block *fuse_control_sb;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fuse_mutex"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fuse_mutex"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_ctl_add_conn",
          "args": [
            "fc"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_ctl_add_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/control.c",
          "lines": "238-271",
          "snippet": "int fuse_ctl_add_conn(struct fuse_conn *fc)\n{\n\tstruct dentry *parent;\n\tchar name[32];\n\n\tif (!fuse_control_sb)\n\t\treturn 0;\n\n\tparent = fuse_control_sb->s_root;\n\tinc_nlink(parent->d_inode);\n\tsprintf(name, \"%u\", fc->dev);\n\tparent = fuse_ctl_add_dentry(parent, fc, name, S_IFDIR | 0500, 2,\n\t\t\t\t     &simple_dir_inode_operations,\n\t\t\t\t     &simple_dir_operations);\n\tif (!parent)\n\t\tgoto err;\n\n\tif (!fuse_ctl_add_dentry(parent, fc, \"waiting\", S_IFREG | 0400, 1,\n\t\t\t\t NULL, &fuse_ctl_waiting_ops) ||\n\t    !fuse_ctl_add_dentry(parent, fc, \"abort\", S_IFREG | 0200, 1,\n\t\t\t\t NULL, &fuse_ctl_abort_ops) ||\n\t    !fuse_ctl_add_dentry(parent, fc, \"max_background\", S_IFREG | 0600,\n\t\t\t\t 1, NULL, &fuse_conn_max_background_ops) ||\n\t    !fuse_ctl_add_dentry(parent, fc, \"congestion_threshold\",\n\t\t\t\t S_IFREG | 0600, 1, NULL,\n\t\t\t\t &fuse_conn_congestion_threshold_ops))\n\t\tgoto err;\n\n\treturn 0;\n\n err:\n\tfuse_ctl_remove_conn(fc);\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct super_block *fuse_control_sb;",
            "static const struct file_operations fuse_ctl_abort_ops = {\n\t.open = nonseekable_open,\n\t.write = fuse_conn_abort_write,\n\t.llseek = no_llseek,\n};",
            "static const struct file_operations fuse_ctl_waiting_ops = {\n\t.open = nonseekable_open,\n\t.read = fuse_conn_waiting_read,\n\t.llseek = no_llseek,\n};",
            "static const struct file_operations fuse_conn_max_background_ops = {\n\t.open = nonseekable_open,\n\t.read = fuse_conn_max_background_read,\n\t.write = fuse_conn_max_background_write,\n\t.llseek = no_llseek,\n};",
            "static const struct file_operations fuse_conn_congestion_threshold_ops = {\n\t.open = nonseekable_open,\n\t.read = fuse_conn_congestion_threshold_read,\n\t.write = fuse_conn_congestion_threshold_write,\n\t.llseek = no_llseek,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic struct super_block *fuse_control_sb;\nstatic const struct file_operations fuse_ctl_abort_ops = {\n\t.open = nonseekable_open,\n\t.write = fuse_conn_abort_write,\n\t.llseek = no_llseek,\n};\nstatic const struct file_operations fuse_ctl_waiting_ops = {\n\t.open = nonseekable_open,\n\t.read = fuse_conn_waiting_read,\n\t.llseek = no_llseek,\n};\nstatic const struct file_operations fuse_conn_max_background_ops = {\n\t.open = nonseekable_open,\n\t.read = fuse_conn_max_background_read,\n\t.write = fuse_conn_max_background_write,\n\t.llseek = no_llseek,\n};\nstatic const struct file_operations fuse_conn_congestion_threshold_ops = {\n\t.open = nonseekable_open,\n\t.read = fuse_conn_congestion_threshold_read,\n\t.write = fuse_conn_congestion_threshold_write,\n\t.llseek = no_llseek,\n};\n\nint fuse_ctl_add_conn(struct fuse_conn *fc)\n{\n\tstruct dentry *parent;\n\tchar name[32];\n\n\tif (!fuse_control_sb)\n\t\treturn 0;\n\n\tparent = fuse_control_sb->s_root;\n\tinc_nlink(parent->d_inode);\n\tsprintf(name, \"%u\", fc->dev);\n\tparent = fuse_ctl_add_dentry(parent, fc, name, S_IFDIR | 0500, 2,\n\t\t\t\t     &simple_dir_inode_operations,\n\t\t\t\t     &simple_dir_operations);\n\tif (!parent)\n\t\tgoto err;\n\n\tif (!fuse_ctl_add_dentry(parent, fc, \"waiting\", S_IFREG | 0400, 1,\n\t\t\t\t NULL, &fuse_ctl_waiting_ops) ||\n\t    !fuse_ctl_add_dentry(parent, fc, \"abort\", S_IFREG | 0200, 1,\n\t\t\t\t NULL, &fuse_ctl_abort_ops) ||\n\t    !fuse_ctl_add_dentry(parent, fc, \"max_background\", S_IFREG | 0600,\n\t\t\t\t 1, NULL, &fuse_conn_max_background_ops) ||\n\t    !fuse_ctl_add_dentry(parent, fc, \"congestion_threshold\",\n\t\t\t\t S_IFREG | 0600, 1, NULL,\n\t\t\t\t &fuse_conn_congestion_threshold_ops))\n\t\tgoto err;\n\n\treturn 0;\n\n err:\n\tfuse_ctl_remove_conn(fc);\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "fc",
            "&fuse_conn_list",
            "entry"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "fuse_control_sb"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fuse_mutex"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_fill_super",
          "args": [
            "sb",
            "FUSE_CTL_SUPER_MAGIC",
            "&empty_descr"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "simple_fill_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "477-538",
          "snippet": "int simple_fill_super(struct super_block *s, unsigned long magic,\n\t\t      struct tree_descr *files)\n{\n\tstruct inode *inode;\n\tstruct dentry *root;\n\tstruct dentry *dentry;\n\tint i;\n\n\ts->s_blocksize = PAGE_CACHE_SIZE;\n\ts->s_blocksize_bits = PAGE_CACHE_SHIFT;\n\ts->s_magic = magic;\n\ts->s_op = &simple_super_operations;\n\ts->s_time_gran = 1;\n\n\tinode = new_inode(s);\n\tif (!inode)\n\t\treturn -ENOMEM;\n\t/*\n\t * because the root inode is 1, the files array must not contain an\n\t * entry at index 1\n\t */\n\tinode->i_ino = 1;\n\tinode->i_mode = S_IFDIR | 0755;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\tinode->i_op = &simple_dir_inode_operations;\n\tinode->i_fop = &simple_dir_operations;\n\tset_nlink(inode, 2);\n\troot = d_make_root(inode);\n\tif (!root)\n\t\treturn -ENOMEM;\n\tfor (i = 0; !files->name || files->name[0]; i++, files++) {\n\t\tif (!files->name)\n\t\t\tcontinue;\n\n\t\t/* warn if it tries to conflict with the root inode */\n\t\tif (unlikely(i == 1))\n\t\t\tprintk(KERN_WARNING \"%s: %s passed in a files array\"\n\t\t\t\t\"with an index of 1!\\n\", __func__,\n\t\t\t\ts->s_type->name);\n\n\t\tdentry = d_alloc_name(root, files->name);\n\t\tif (!dentry)\n\t\t\tgoto out;\n\t\tinode = new_inode(s);\n\t\tif (!inode) {\n\t\t\tdput(dentry);\n\t\t\tgoto out;\n\t\t}\n\t\tinode->i_mode = S_IFREG | files->mode;\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t\tinode->i_fop = files->ops;\n\t\tinode->i_ino = i;\n\t\td_add(dentry, inode);\n\t}\n\ts->s_root = root;\n\treturn 0;\nout:\n\td_genocide(root);\n\tshrink_dcache_parent(root);\n\tdput(root);\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct file_operations simple_dir_operations = {\n\t.open\t\t= dcache_dir_open,\n\t.release\t= dcache_dir_close,\n\t.llseek\t\t= dcache_dir_lseek,\n\t.read\t\t= generic_read_dir,\n\t.iterate\t= dcache_readdir,\n\t.fsync\t\t= noop_fsync,\n};",
            "const struct inode_operations simple_dir_inode_operations = {\n\t.lookup\t\t= simple_lookup,\n};",
            "static const struct super_operations simple_super_operations = {\n\t.statfs\t\t= simple_statfs,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nconst struct file_operations simple_dir_operations = {\n\t.open\t\t= dcache_dir_open,\n\t.release\t= dcache_dir_close,\n\t.llseek\t\t= dcache_dir_lseek,\n\t.read\t\t= generic_read_dir,\n\t.iterate\t= dcache_readdir,\n\t.fsync\t\t= noop_fsync,\n};\nconst struct inode_operations simple_dir_inode_operations = {\n\t.lookup\t\t= simple_lookup,\n};\nstatic const struct super_operations simple_super_operations = {\n\t.statfs\t\t= simple_statfs,\n};\n\nint simple_fill_super(struct super_block *s, unsigned long magic,\n\t\t      struct tree_descr *files)\n{\n\tstruct inode *inode;\n\tstruct dentry *root;\n\tstruct dentry *dentry;\n\tint i;\n\n\ts->s_blocksize = PAGE_CACHE_SIZE;\n\ts->s_blocksize_bits = PAGE_CACHE_SHIFT;\n\ts->s_magic = magic;\n\ts->s_op = &simple_super_operations;\n\ts->s_time_gran = 1;\n\n\tinode = new_inode(s);\n\tif (!inode)\n\t\treturn -ENOMEM;\n\t/*\n\t * because the root inode is 1, the files array must not contain an\n\t * entry at index 1\n\t */\n\tinode->i_ino = 1;\n\tinode->i_mode = S_IFDIR | 0755;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\tinode->i_op = &simple_dir_inode_operations;\n\tinode->i_fop = &simple_dir_operations;\n\tset_nlink(inode, 2);\n\troot = d_make_root(inode);\n\tif (!root)\n\t\treturn -ENOMEM;\n\tfor (i = 0; !files->name || files->name[0]; i++, files++) {\n\t\tif (!files->name)\n\t\t\tcontinue;\n\n\t\t/* warn if it tries to conflict with the root inode */\n\t\tif (unlikely(i == 1))\n\t\t\tprintk(KERN_WARNING \"%s: %s passed in a files array\"\n\t\t\t\t\"with an index of 1!\\n\", __func__,\n\t\t\t\ts->s_type->name);\n\n\t\tdentry = d_alloc_name(root, files->name);\n\t\tif (!dentry)\n\t\t\tgoto out;\n\t\tinode = new_inode(s);\n\t\tif (!inode) {\n\t\t\tdput(dentry);\n\t\t\tgoto out;\n\t\t}\n\t\tinode->i_mode = S_IFREG | files->mode;\n\t\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t\tinode->i_fop = files->ops;\n\t\tinode->i_ino = i;\n\t\td_add(dentry, inode);\n\t}\n\ts->s_root = root;\n\treturn 0;\nout:\n\td_genocide(root);\n\tshrink_dcache_parent(root);\n\tdput(root);\n\treturn -ENOMEM;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\n#define FUSE_CTL_SUPER_MAGIC 0x65735543\n\nstatic struct super_block *fuse_control_sb;\n\nstatic int fuse_ctl_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstruct tree_descr empty_descr = {\"\"};\n\tstruct fuse_conn *fc;\n\tint err;\n\n\terr = simple_fill_super(sb, FUSE_CTL_SUPER_MAGIC, &empty_descr);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&fuse_mutex);\n\tBUG_ON(fuse_control_sb);\n\tfuse_control_sb = sb;\n\tlist_for_each_entry(fc, &fuse_conn_list, entry) {\n\t\terr = fuse_ctl_add_conn(fc);\n\t\tif (err) {\n\t\t\tfuse_control_sb = NULL;\n\t\t\tmutex_unlock(&fuse_mutex);\n\t\t\treturn err;\n\t\t}\n\t}\n\tmutex_unlock(&fuse_mutex);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "fuse_ctl_remove_conn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/control.c",
    "lines": "277-291",
    "snippet": "void fuse_ctl_remove_conn(struct fuse_conn *fc)\n{\n\tint i;\n\n\tif (!fuse_control_sb)\n\t\treturn;\n\n\tfor (i = fc->ctl_ndents - 1; i >= 0; i--) {\n\t\tstruct dentry *dentry = fc->ctl_dentry[i];\n\t\tdentry->d_inode->i_private = NULL;\n\t\td_drop(dentry);\n\t\tdput(dentry);\n\t}\n\tdrop_nlink(fuse_control_sb->s_root->d_inode);\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct super_block *fuse_control_sb;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "drop_nlink",
          "args": [
            "fuse_control_sb->s_root->d_inode"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "drop_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "271-277",
          "snippet": "void drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid drop_nlink(struct inode *inode)\n{\n\tWARN_ON(inode->i_nlink == 0);\n\tinode->__i_nlink--;\n\tif (!inode->i_nlink)\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_drop",
          "args": [
            "dentry"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "check_and_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1447-1453",
          "snippet": "static void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic struct super_block *fuse_control_sb;\n\nvoid fuse_ctl_remove_conn(struct fuse_conn *fc)\n{\n\tint i;\n\n\tif (!fuse_control_sb)\n\t\treturn;\n\n\tfor (i = fc->ctl_ndents - 1; i >= 0; i--) {\n\t\tstruct dentry *dentry = fc->ctl_dentry[i];\n\t\tdentry->d_inode->i_private = NULL;\n\t\td_drop(dentry);\n\t\tdput(dentry);\n\t}\n\tdrop_nlink(fuse_control_sb->s_root->d_inode);\n}"
  },
  {
    "function_name": "fuse_ctl_add_conn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/control.c",
    "lines": "238-271",
    "snippet": "int fuse_ctl_add_conn(struct fuse_conn *fc)\n{\n\tstruct dentry *parent;\n\tchar name[32];\n\n\tif (!fuse_control_sb)\n\t\treturn 0;\n\n\tparent = fuse_control_sb->s_root;\n\tinc_nlink(parent->d_inode);\n\tsprintf(name, \"%u\", fc->dev);\n\tparent = fuse_ctl_add_dentry(parent, fc, name, S_IFDIR | 0500, 2,\n\t\t\t\t     &simple_dir_inode_operations,\n\t\t\t\t     &simple_dir_operations);\n\tif (!parent)\n\t\tgoto err;\n\n\tif (!fuse_ctl_add_dentry(parent, fc, \"waiting\", S_IFREG | 0400, 1,\n\t\t\t\t NULL, &fuse_ctl_waiting_ops) ||\n\t    !fuse_ctl_add_dentry(parent, fc, \"abort\", S_IFREG | 0200, 1,\n\t\t\t\t NULL, &fuse_ctl_abort_ops) ||\n\t    !fuse_ctl_add_dentry(parent, fc, \"max_background\", S_IFREG | 0600,\n\t\t\t\t 1, NULL, &fuse_conn_max_background_ops) ||\n\t    !fuse_ctl_add_dentry(parent, fc, \"congestion_threshold\",\n\t\t\t\t S_IFREG | 0600, 1, NULL,\n\t\t\t\t &fuse_conn_congestion_threshold_ops))\n\t\tgoto err;\n\n\treturn 0;\n\n err:\n\tfuse_ctl_remove_conn(fc);\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct super_block *fuse_control_sb;",
      "static const struct file_operations fuse_ctl_abort_ops = {\n\t.open = nonseekable_open,\n\t.write = fuse_conn_abort_write,\n\t.llseek = no_llseek,\n};",
      "static const struct file_operations fuse_ctl_waiting_ops = {\n\t.open = nonseekable_open,\n\t.read = fuse_conn_waiting_read,\n\t.llseek = no_llseek,\n};",
      "static const struct file_operations fuse_conn_max_background_ops = {\n\t.open = nonseekable_open,\n\t.read = fuse_conn_max_background_read,\n\t.write = fuse_conn_max_background_write,\n\t.llseek = no_llseek,\n};",
      "static const struct file_operations fuse_conn_congestion_threshold_ops = {\n\t.open = nonseekable_open,\n\t.read = fuse_conn_congestion_threshold_read,\n\t.write = fuse_conn_congestion_threshold_write,\n\t.llseek = no_llseek,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_ctl_remove_conn",
          "args": [
            "fc"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_ctl_remove_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/control.c",
          "lines": "277-291",
          "snippet": "void fuse_ctl_remove_conn(struct fuse_conn *fc)\n{\n\tint i;\n\n\tif (!fuse_control_sb)\n\t\treturn;\n\n\tfor (i = fc->ctl_ndents - 1; i >= 0; i--) {\n\t\tstruct dentry *dentry = fc->ctl_dentry[i];\n\t\tdentry->d_inode->i_private = NULL;\n\t\td_drop(dentry);\n\t\tdput(dentry);\n\t}\n\tdrop_nlink(fuse_control_sb->s_root->d_inode);\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct super_block *fuse_control_sb;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic struct super_block *fuse_control_sb;\n\nvoid fuse_ctl_remove_conn(struct fuse_conn *fc)\n{\n\tint i;\n\n\tif (!fuse_control_sb)\n\t\treturn;\n\n\tfor (i = fc->ctl_ndents - 1; i >= 0; i--) {\n\t\tstruct dentry *dentry = fc->ctl_dentry[i];\n\t\tdentry->d_inode->i_private = NULL;\n\t\td_drop(dentry);\n\t\tdput(dentry);\n\t}\n\tdrop_nlink(fuse_control_sb->s_root->d_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_ctl_add_dentry",
          "args": [
            "parent",
            "fc",
            "\"congestion_threshold\"",
            "S_IFREG | 0600",
            "1",
            "NULL",
            "&fuse_conn_congestion_threshold_ops"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_ctl_add_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/control.c",
          "lines": "199-232",
          "snippet": "static struct dentry *fuse_ctl_add_dentry(struct dentry *parent,\n\t\t\t\t\t  struct fuse_conn *fc,\n\t\t\t\t\t  const char *name,\n\t\t\t\t\t  int mode, int nlink,\n\t\t\t\t\t  const struct inode_operations *iop,\n\t\t\t\t\t  const struct file_operations *fop)\n{\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\n\tBUG_ON(fc->ctl_ndents >= FUSE_CTL_NUM_DENTRIES);\n\tdentry = d_alloc_name(parent, name);\n\tif (!dentry)\n\t\treturn NULL;\n\n\tfc->ctl_dentry[fc->ctl_ndents++] = dentry;\n\tinode = new_inode(fuse_control_sb);\n\tif (!inode)\n\t\treturn NULL;\n\n\tinode->i_ino = get_next_ino();\n\tinode->i_mode = mode;\n\tinode->i_uid = fc->user_id;\n\tinode->i_gid = fc->group_id;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t/* setting ->i_op to NULL is not allowed */\n\tif (iop)\n\t\tinode->i_op = iop;\n\tinode->i_fop = fop;\n\tset_nlink(inode, nlink);\n\tinode->i_private = fc;\n\td_add(dentry, inode);\n\treturn dentry;\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct super_block *fuse_control_sb;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic struct super_block *fuse_control_sb;\n\nstatic struct dentry *fuse_ctl_add_dentry(struct dentry *parent,\n\t\t\t\t\t  struct fuse_conn *fc,\n\t\t\t\t\t  const char *name,\n\t\t\t\t\t  int mode, int nlink,\n\t\t\t\t\t  const struct inode_operations *iop,\n\t\t\t\t\t  const struct file_operations *fop)\n{\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\n\tBUG_ON(fc->ctl_ndents >= FUSE_CTL_NUM_DENTRIES);\n\tdentry = d_alloc_name(parent, name);\n\tif (!dentry)\n\t\treturn NULL;\n\n\tfc->ctl_dentry[fc->ctl_ndents++] = dentry;\n\tinode = new_inode(fuse_control_sb);\n\tif (!inode)\n\t\treturn NULL;\n\n\tinode->i_ino = get_next_ino();\n\tinode->i_mode = mode;\n\tinode->i_uid = fc->user_id;\n\tinode->i_gid = fc->group_id;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t/* setting ->i_op to NULL is not allowed */\n\tif (iop)\n\t\tinode->i_op = iop;\n\tinode->i_fop = fop;\n\tset_nlink(inode, nlink);\n\tinode->i_private = fc;\n\td_add(dentry, inode);\n\treturn dentry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "name",
            "\"%u\"",
            "fc->dev"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "parent->d_inode"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "inc_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "327-335",
          "snippet": "void inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid inc_nlink(struct inode *inode)\n{\n\tif (unlikely(inode->i_nlink == 0)) {\n\t\tWARN_ON(!(inode->i_state & I_LINKABLE));\n\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\t}\n\n\tinode->__i_nlink++;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic struct super_block *fuse_control_sb;\nstatic const struct file_operations fuse_ctl_abort_ops = {\n\t.open = nonseekable_open,\n\t.write = fuse_conn_abort_write,\n\t.llseek = no_llseek,\n};\nstatic const struct file_operations fuse_ctl_waiting_ops = {\n\t.open = nonseekable_open,\n\t.read = fuse_conn_waiting_read,\n\t.llseek = no_llseek,\n};\nstatic const struct file_operations fuse_conn_max_background_ops = {\n\t.open = nonseekable_open,\n\t.read = fuse_conn_max_background_read,\n\t.write = fuse_conn_max_background_write,\n\t.llseek = no_llseek,\n};\nstatic const struct file_operations fuse_conn_congestion_threshold_ops = {\n\t.open = nonseekable_open,\n\t.read = fuse_conn_congestion_threshold_read,\n\t.write = fuse_conn_congestion_threshold_write,\n\t.llseek = no_llseek,\n};\n\nint fuse_ctl_add_conn(struct fuse_conn *fc)\n{\n\tstruct dentry *parent;\n\tchar name[32];\n\n\tif (!fuse_control_sb)\n\t\treturn 0;\n\n\tparent = fuse_control_sb->s_root;\n\tinc_nlink(parent->d_inode);\n\tsprintf(name, \"%u\", fc->dev);\n\tparent = fuse_ctl_add_dentry(parent, fc, name, S_IFDIR | 0500, 2,\n\t\t\t\t     &simple_dir_inode_operations,\n\t\t\t\t     &simple_dir_operations);\n\tif (!parent)\n\t\tgoto err;\n\n\tif (!fuse_ctl_add_dentry(parent, fc, \"waiting\", S_IFREG | 0400, 1,\n\t\t\t\t NULL, &fuse_ctl_waiting_ops) ||\n\t    !fuse_ctl_add_dentry(parent, fc, \"abort\", S_IFREG | 0200, 1,\n\t\t\t\t NULL, &fuse_ctl_abort_ops) ||\n\t    !fuse_ctl_add_dentry(parent, fc, \"max_background\", S_IFREG | 0600,\n\t\t\t\t 1, NULL, &fuse_conn_max_background_ops) ||\n\t    !fuse_ctl_add_dentry(parent, fc, \"congestion_threshold\",\n\t\t\t\t S_IFREG | 0600, 1, NULL,\n\t\t\t\t &fuse_conn_congestion_threshold_ops))\n\t\tgoto err;\n\n\treturn 0;\n\n err:\n\tfuse_ctl_remove_conn(fc);\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "fuse_ctl_add_dentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/control.c",
    "lines": "199-232",
    "snippet": "static struct dentry *fuse_ctl_add_dentry(struct dentry *parent,\n\t\t\t\t\t  struct fuse_conn *fc,\n\t\t\t\t\t  const char *name,\n\t\t\t\t\t  int mode, int nlink,\n\t\t\t\t\t  const struct inode_operations *iop,\n\t\t\t\t\t  const struct file_operations *fop)\n{\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\n\tBUG_ON(fc->ctl_ndents >= FUSE_CTL_NUM_DENTRIES);\n\tdentry = d_alloc_name(parent, name);\n\tif (!dentry)\n\t\treturn NULL;\n\n\tfc->ctl_dentry[fc->ctl_ndents++] = dentry;\n\tinode = new_inode(fuse_control_sb);\n\tif (!inode)\n\t\treturn NULL;\n\n\tinode->i_ino = get_next_ino();\n\tinode->i_mode = mode;\n\tinode->i_uid = fc->user_id;\n\tinode->i_gid = fc->group_id;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t/* setting ->i_op to NULL is not allowed */\n\tif (iop)\n\t\tinode->i_op = iop;\n\tinode->i_fop = fop;\n\tset_nlink(inode, nlink);\n\tinode->i_private = fc;\n\td_add(dentry, inode);\n\treturn dentry;\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct super_block *fuse_control_sb;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_add",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "49-54",
          "snippet": "void v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "nlink"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_next_ino",
          "args": [],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "get_next_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "828-845",
          "snippet": "unsigned int get_next_ino(void)\n{\n\tunsigned int *p = &get_cpu_var(last_ino);\n\tunsigned int res = *p;\n\n#ifdef CONFIG_SMP\n\tif (unlikely((res & (LAST_INO_BATCH-1)) == 0)) {\n\t\tstatic atomic_t shared_last_ino;\n\t\tint next = atomic_add_return(LAST_INO_BATCH, &shared_last_ino);\n\n\t\tres = next - LAST_INO_BATCH;\n\t}\n#endif\n\n\t*p = ++res;\n\tput_cpu_var(last_ino);\n\treturn res;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define LAST_INO_BATCH 1024"
          ],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned int, last_ino);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\n#define LAST_INO_BATCH 1024\n\nstatic DEFINE_PER_CPU(unsigned int, last_ino);\n\nunsigned int get_next_ino(void)\n{\n\tunsigned int *p = &get_cpu_var(last_ino);\n\tunsigned int res = *p;\n\n#ifdef CONFIG_SMP\n\tif (unlikely((res & (LAST_INO_BATCH-1)) == 0)) {\n\t\tstatic atomic_t shared_last_ino;\n\t\tint next = atomic_add_return(LAST_INO_BATCH, &shared_last_ino);\n\n\t\tres = next - LAST_INO_BATCH;\n\t}\n#endif\n\n\t*p = ++res;\n\tput_cpu_var(last_ino);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "new_inode",
          "args": [
            "fuse_control_sb"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_new_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "924-933",
          "snippet": "void unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid unlock_new_inode(struct inode *inode)\n{\n\tlockdep_annotate_inode_mutex_key(inode);\n\tspin_lock(&inode->i_lock);\n\tWARN_ON(!(inode->i_state & I_NEW));\n\tinode->i_state &= ~I_NEW;\n\tsmp_mb();\n\twake_up_bit(&inode->i_state, __I_NEW);\n\tspin_unlock(&inode->i_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_alloc_name",
          "args": [
            "parent",
            "name"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "d_alloc_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1624-1632",
          "snippet": "struct dentry *d_alloc_name(struct dentry *parent, const char *name)\n{\n\tstruct qstr q;\n\n\tq.name = name;\n\tq.len = strlen(name);\n\tq.hash = full_name_hash(q.name, q.len);\n\treturn d_alloc(parent, &q);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *d_alloc_name(struct dentry *parent, const char *name)\n{\n\tstruct qstr q;\n\n\tq.name = name;\n\tq.len = strlen(name);\n\tq.hash = full_name_hash(q.name, q.len);\n\treturn d_alloc(parent, &q);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "fc->ctl_ndents >= FUSE_CTL_NUM_DENTRIES"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic struct super_block *fuse_control_sb;\n\nstatic struct dentry *fuse_ctl_add_dentry(struct dentry *parent,\n\t\t\t\t\t  struct fuse_conn *fc,\n\t\t\t\t\t  const char *name,\n\t\t\t\t\t  int mode, int nlink,\n\t\t\t\t\t  const struct inode_operations *iop,\n\t\t\t\t\t  const struct file_operations *fop)\n{\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\n\tBUG_ON(fc->ctl_ndents >= FUSE_CTL_NUM_DENTRIES);\n\tdentry = d_alloc_name(parent, name);\n\tif (!dentry)\n\t\treturn NULL;\n\n\tfc->ctl_dentry[fc->ctl_ndents++] = dentry;\n\tinode = new_inode(fuse_control_sb);\n\tif (!inode)\n\t\treturn NULL;\n\n\tinode->i_ino = get_next_ino();\n\tinode->i_mode = mode;\n\tinode->i_uid = fc->user_id;\n\tinode->i_gid = fc->group_id;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;\n\t/* setting ->i_op to NULL is not allowed */\n\tif (iop)\n\t\tinode->i_op = iop;\n\tinode->i_fop = fop;\n\tset_nlink(inode, nlink);\n\tinode->i_private = fc;\n\td_add(dentry, inode);\n\treturn dentry;\n}"
  },
  {
    "function_name": "fuse_conn_congestion_threshold_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/control.c",
    "lines": "153-171",
    "snippet": "static ssize_t fuse_conn_congestion_threshold_write(struct file *file,\n\t\t\t\t\t\t    const char __user *buf,\n\t\t\t\t\t\t    size_t count, loff_t *ppos)\n{\n\tunsigned uninitialized_var(val);\n\tssize_t ret;\n\n\tret = fuse_conn_limit_write(file, buf, count, ppos, &val,\n\t\t\t\t    max_user_congthresh);\n\tif (ret > 0) {\n\t\tstruct fuse_conn *fc = fuse_ctl_file_conn_get(file);\n\t\tif (fc) {\n\t\t\tfc->congestion_threshold = val;\n\t\t\tfuse_conn_put(fc);\n\t\t}\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_conn_put",
          "args": [
            "fc"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_conn_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "599-606",
          "snippet": "void fuse_conn_put(struct fuse_conn *fc)\n{\n\tif (atomic_dec_and_test(&fc->count)) {\n\t\tif (fc->destroy_req)\n\t\t\tfuse_request_free(fc->destroy_req);\n\t\tfc->release(fc);\n\t}\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_conn_put(struct fuse_conn *fc)\n{\n\tif (atomic_dec_and_test(&fc->count)) {\n\t\tif (fc->destroy_req)\n\t\t\tfuse_request_free(fc->destroy_req);\n\t\tfc->release(fc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_ctl_file_conn_get",
          "args": [
            "file"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_ctl_file_conn_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/control.c",
          "lines": "22-31",
          "snippet": "static struct fuse_conn *fuse_ctl_file_conn_get(struct file *file)\n{\n\tstruct fuse_conn *fc;\n\tmutex_lock(&fuse_mutex);\n\tfc = file_inode(file)->i_private;\n\tif (fc)\n\t\tfc = fuse_conn_get(fc);\n\tmutex_unlock(&fuse_mutex);\n\treturn fc;\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic struct fuse_conn *fuse_ctl_file_conn_get(struct file *file)\n{\n\tstruct fuse_conn *fc;\n\tmutex_lock(&fuse_mutex);\n\tfc = file_inode(file)->i_private;\n\tif (fc)\n\t\tfc = fuse_conn_get(fc);\n\tmutex_unlock(&fuse_mutex);\n\treturn fc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_conn_limit_write",
          "args": [
            "file",
            "buf",
            "count",
            "ppos",
            "&val",
            "max_user_congthresh"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_conn_limit_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/control.c",
          "lines": "73-97",
          "snippet": "static ssize_t fuse_conn_limit_write(struct file *file, const char __user *buf,\n\t\t\t\t     size_t count, loff_t *ppos, unsigned *val,\n\t\t\t\t     unsigned global_limit)\n{\n\tunsigned long t;\n\tunsigned limit = (1 << 16) - 1;\n\tint err;\n\n\tif (*ppos)\n\t\treturn -EINVAL;\n\n\terr = kstrtoul_from_user(buf, count, 0, &t);\n\tif (err)\n\t\treturn err;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\tlimit = min(limit, global_limit);\n\n\tif (t > limit)\n\t\treturn -EINVAL;\n\n\t*val = t;\n\n\treturn count;\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic ssize_t fuse_conn_limit_write(struct file *file, const char __user *buf,\n\t\t\t\t     size_t count, loff_t *ppos, unsigned *val,\n\t\t\t\t     unsigned global_limit)\n{\n\tunsigned long t;\n\tunsigned limit = (1 << 16) - 1;\n\tint err;\n\n\tif (*ppos)\n\t\treturn -EINVAL;\n\n\terr = kstrtoul_from_user(buf, count, 0, &t);\n\tif (err)\n\t\treturn err;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\tlimit = min(limit, global_limit);\n\n\tif (t > limit)\n\t\treturn -EINVAL;\n\n\t*val = t;\n\n\treturn count;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic ssize_t fuse_conn_congestion_threshold_write(struct file *file,\n\t\t\t\t\t\t    const char __user *buf,\n\t\t\t\t\t\t    size_t count, loff_t *ppos)\n{\n\tunsigned uninitialized_var(val);\n\tssize_t ret;\n\n\tret = fuse_conn_limit_write(file, buf, count, ppos, &val,\n\t\t\t\t    max_user_congthresh);\n\tif (ret > 0) {\n\t\tstruct fuse_conn *fc = fuse_ctl_file_conn_get(file);\n\t\tif (fc) {\n\t\t\tfc->congestion_threshold = val;\n\t\t\tfuse_conn_put(fc);\n\t\t}\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "fuse_conn_congestion_threshold_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/control.c",
    "lines": "136-151",
    "snippet": "static ssize_t fuse_conn_congestion_threshold_read(struct file *file,\n\t\t\t\t\t\t   char __user *buf, size_t len,\n\t\t\t\t\t\t   loff_t *ppos)\n{\n\tstruct fuse_conn *fc;\n\tunsigned val;\n\n\tfc = fuse_ctl_file_conn_get(file);\n\tif (!fc)\n\t\treturn 0;\n\n\tval = fc->congestion_threshold;\n\tfuse_conn_put(fc);\n\n\treturn fuse_conn_limit_read(file, buf, len, ppos, val);\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_conn_limit_read",
          "args": [
            "file",
            "buf",
            "len",
            "ppos",
            "val"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_conn_limit_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/control.c",
          "lines": "64-71",
          "snippet": "static ssize_t fuse_conn_limit_read(struct file *file, char __user *buf,\n\t\t\t\t    size_t len, loff_t *ppos, unsigned val)\n{\n\tchar tmp[32];\n\tsize_t size = sprintf(tmp, \"%u\\n\", val);\n\n\treturn simple_read_from_buffer(buf, len, ppos, tmp, size);\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic ssize_t fuse_conn_limit_read(struct file *file, char __user *buf,\n\t\t\t\t    size_t len, loff_t *ppos, unsigned val)\n{\n\tchar tmp[32];\n\tsize_t size = sprintf(tmp, \"%u\\n\", val);\n\n\treturn simple_read_from_buffer(buf, len, ppos, tmp, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_conn_put",
          "args": [
            "fc"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_conn_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "599-606",
          "snippet": "void fuse_conn_put(struct fuse_conn *fc)\n{\n\tif (atomic_dec_and_test(&fc->count)) {\n\t\tif (fc->destroy_req)\n\t\t\tfuse_request_free(fc->destroy_req);\n\t\tfc->release(fc);\n\t}\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_conn_put(struct fuse_conn *fc)\n{\n\tif (atomic_dec_and_test(&fc->count)) {\n\t\tif (fc->destroy_req)\n\t\t\tfuse_request_free(fc->destroy_req);\n\t\tfc->release(fc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_ctl_file_conn_get",
          "args": [
            "file"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_ctl_file_conn_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/control.c",
          "lines": "22-31",
          "snippet": "static struct fuse_conn *fuse_ctl_file_conn_get(struct file *file)\n{\n\tstruct fuse_conn *fc;\n\tmutex_lock(&fuse_mutex);\n\tfc = file_inode(file)->i_private;\n\tif (fc)\n\t\tfc = fuse_conn_get(fc);\n\tmutex_unlock(&fuse_mutex);\n\treturn fc;\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic struct fuse_conn *fuse_ctl_file_conn_get(struct file *file)\n{\n\tstruct fuse_conn *fc;\n\tmutex_lock(&fuse_mutex);\n\tfc = file_inode(file)->i_private;\n\tif (fc)\n\t\tfc = fuse_conn_get(fc);\n\tmutex_unlock(&fuse_mutex);\n\treturn fc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic ssize_t fuse_conn_congestion_threshold_read(struct file *file,\n\t\t\t\t\t\t   char __user *buf, size_t len,\n\t\t\t\t\t\t   loff_t *ppos)\n{\n\tstruct fuse_conn *fc;\n\tunsigned val;\n\n\tfc = fuse_ctl_file_conn_get(file);\n\tif (!fc)\n\t\treturn 0;\n\n\tval = fc->congestion_threshold;\n\tfuse_conn_put(fc);\n\n\treturn fuse_conn_limit_read(file, buf, len, ppos, val);\n}"
  },
  {
    "function_name": "fuse_conn_max_background_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/control.c",
    "lines": "116-134",
    "snippet": "static ssize_t fuse_conn_max_background_write(struct file *file,\n\t\t\t\t\t      const char __user *buf,\n\t\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tunsigned uninitialized_var(val);\n\tssize_t ret;\n\n\tret = fuse_conn_limit_write(file, buf, count, ppos, &val,\n\t\t\t\t    max_user_bgreq);\n\tif (ret > 0) {\n\t\tstruct fuse_conn *fc = fuse_ctl_file_conn_get(file);\n\t\tif (fc) {\n\t\t\tfc->max_background = val;\n\t\t\tfuse_conn_put(fc);\n\t\t}\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_conn_put",
          "args": [
            "fc"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_conn_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "599-606",
          "snippet": "void fuse_conn_put(struct fuse_conn *fc)\n{\n\tif (atomic_dec_and_test(&fc->count)) {\n\t\tif (fc->destroy_req)\n\t\t\tfuse_request_free(fc->destroy_req);\n\t\tfc->release(fc);\n\t}\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_conn_put(struct fuse_conn *fc)\n{\n\tif (atomic_dec_and_test(&fc->count)) {\n\t\tif (fc->destroy_req)\n\t\t\tfuse_request_free(fc->destroy_req);\n\t\tfc->release(fc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_ctl_file_conn_get",
          "args": [
            "file"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_ctl_file_conn_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/control.c",
          "lines": "22-31",
          "snippet": "static struct fuse_conn *fuse_ctl_file_conn_get(struct file *file)\n{\n\tstruct fuse_conn *fc;\n\tmutex_lock(&fuse_mutex);\n\tfc = file_inode(file)->i_private;\n\tif (fc)\n\t\tfc = fuse_conn_get(fc);\n\tmutex_unlock(&fuse_mutex);\n\treturn fc;\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic struct fuse_conn *fuse_ctl_file_conn_get(struct file *file)\n{\n\tstruct fuse_conn *fc;\n\tmutex_lock(&fuse_mutex);\n\tfc = file_inode(file)->i_private;\n\tif (fc)\n\t\tfc = fuse_conn_get(fc);\n\tmutex_unlock(&fuse_mutex);\n\treturn fc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_conn_limit_write",
          "args": [
            "file",
            "buf",
            "count",
            "ppos",
            "&val",
            "max_user_bgreq"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_conn_limit_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/control.c",
          "lines": "73-97",
          "snippet": "static ssize_t fuse_conn_limit_write(struct file *file, const char __user *buf,\n\t\t\t\t     size_t count, loff_t *ppos, unsigned *val,\n\t\t\t\t     unsigned global_limit)\n{\n\tunsigned long t;\n\tunsigned limit = (1 << 16) - 1;\n\tint err;\n\n\tif (*ppos)\n\t\treturn -EINVAL;\n\n\terr = kstrtoul_from_user(buf, count, 0, &t);\n\tif (err)\n\t\treturn err;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\tlimit = min(limit, global_limit);\n\n\tif (t > limit)\n\t\treturn -EINVAL;\n\n\t*val = t;\n\n\treturn count;\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic ssize_t fuse_conn_limit_write(struct file *file, const char __user *buf,\n\t\t\t\t     size_t count, loff_t *ppos, unsigned *val,\n\t\t\t\t     unsigned global_limit)\n{\n\tunsigned long t;\n\tunsigned limit = (1 << 16) - 1;\n\tint err;\n\n\tif (*ppos)\n\t\treturn -EINVAL;\n\n\terr = kstrtoul_from_user(buf, count, 0, &t);\n\tif (err)\n\t\treturn err;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\tlimit = min(limit, global_limit);\n\n\tif (t > limit)\n\t\treturn -EINVAL;\n\n\t*val = t;\n\n\treturn count;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic ssize_t fuse_conn_max_background_write(struct file *file,\n\t\t\t\t\t      const char __user *buf,\n\t\t\t\t\t      size_t count, loff_t *ppos)\n{\n\tunsigned uninitialized_var(val);\n\tssize_t ret;\n\n\tret = fuse_conn_limit_write(file, buf, count, ppos, &val,\n\t\t\t\t    max_user_bgreq);\n\tif (ret > 0) {\n\t\tstruct fuse_conn *fc = fuse_ctl_file_conn_get(file);\n\t\tif (fc) {\n\t\t\tfc->max_background = val;\n\t\t\tfuse_conn_put(fc);\n\t\t}\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "fuse_conn_max_background_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/control.c",
    "lines": "99-114",
    "snippet": "static ssize_t fuse_conn_max_background_read(struct file *file,\n\t\t\t\t\t     char __user *buf, size_t len,\n\t\t\t\t\t     loff_t *ppos)\n{\n\tstruct fuse_conn *fc;\n\tunsigned val;\n\n\tfc = fuse_ctl_file_conn_get(file);\n\tif (!fc)\n\t\treturn 0;\n\n\tval = fc->max_background;\n\tfuse_conn_put(fc);\n\n\treturn fuse_conn_limit_read(file, buf, len, ppos, val);\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_conn_limit_read",
          "args": [
            "file",
            "buf",
            "len",
            "ppos",
            "val"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_conn_limit_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/control.c",
          "lines": "64-71",
          "snippet": "static ssize_t fuse_conn_limit_read(struct file *file, char __user *buf,\n\t\t\t\t    size_t len, loff_t *ppos, unsigned val)\n{\n\tchar tmp[32];\n\tsize_t size = sprintf(tmp, \"%u\\n\", val);\n\n\treturn simple_read_from_buffer(buf, len, ppos, tmp, size);\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic ssize_t fuse_conn_limit_read(struct file *file, char __user *buf,\n\t\t\t\t    size_t len, loff_t *ppos, unsigned val)\n{\n\tchar tmp[32];\n\tsize_t size = sprintf(tmp, \"%u\\n\", val);\n\n\treturn simple_read_from_buffer(buf, len, ppos, tmp, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_conn_put",
          "args": [
            "fc"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_conn_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "599-606",
          "snippet": "void fuse_conn_put(struct fuse_conn *fc)\n{\n\tif (atomic_dec_and_test(&fc->count)) {\n\t\tif (fc->destroy_req)\n\t\t\tfuse_request_free(fc->destroy_req);\n\t\tfc->release(fc);\n\t}\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_conn_put(struct fuse_conn *fc)\n{\n\tif (atomic_dec_and_test(&fc->count)) {\n\t\tif (fc->destroy_req)\n\t\t\tfuse_request_free(fc->destroy_req);\n\t\tfc->release(fc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_ctl_file_conn_get",
          "args": [
            "file"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_ctl_file_conn_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/control.c",
          "lines": "22-31",
          "snippet": "static struct fuse_conn *fuse_ctl_file_conn_get(struct file *file)\n{\n\tstruct fuse_conn *fc;\n\tmutex_lock(&fuse_mutex);\n\tfc = file_inode(file)->i_private;\n\tif (fc)\n\t\tfc = fuse_conn_get(fc);\n\tmutex_unlock(&fuse_mutex);\n\treturn fc;\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic struct fuse_conn *fuse_ctl_file_conn_get(struct file *file)\n{\n\tstruct fuse_conn *fc;\n\tmutex_lock(&fuse_mutex);\n\tfc = file_inode(file)->i_private;\n\tif (fc)\n\t\tfc = fuse_conn_get(fc);\n\tmutex_unlock(&fuse_mutex);\n\treturn fc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic ssize_t fuse_conn_max_background_read(struct file *file,\n\t\t\t\t\t     char __user *buf, size_t len,\n\t\t\t\t\t     loff_t *ppos)\n{\n\tstruct fuse_conn *fc;\n\tunsigned val;\n\n\tfc = fuse_ctl_file_conn_get(file);\n\tif (!fc)\n\t\treturn 0;\n\n\tval = fc->max_background;\n\tfuse_conn_put(fc);\n\n\treturn fuse_conn_limit_read(file, buf, len, ppos, val);\n}"
  },
  {
    "function_name": "fuse_conn_limit_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/control.c",
    "lines": "73-97",
    "snippet": "static ssize_t fuse_conn_limit_write(struct file *file, const char __user *buf,\n\t\t\t\t     size_t count, loff_t *ppos, unsigned *val,\n\t\t\t\t     unsigned global_limit)\n{\n\tunsigned long t;\n\tunsigned limit = (1 << 16) - 1;\n\tint err;\n\n\tif (*ppos)\n\t\treturn -EINVAL;\n\n\terr = kstrtoul_from_user(buf, count, 0, &t);\n\tif (err)\n\t\treturn err;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\tlimit = min(limit, global_limit);\n\n\tif (t > limit)\n\t\treturn -EINVAL;\n\n\t*val = t;\n\n\treturn count;\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "min",
          "args": [
            "limit",
            "global_limit"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "get_dominating_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/pnode.c",
          "lines": "55-66",
          "snippet": "int get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"pnode.h\"",
            "#include \"internal.h\"",
            "#include <linux/nsproxy.h>",
            "#include <linux/fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/mnt_namespace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pnode.h\"\n#include \"internal.h\"\n#include <linux/nsproxy.h>\n#include <linux/fs.h>\n#include <linux/mount.h>\n#include <linux/mnt_namespace.h>\n\nint get_dominating_id(struct mount *mnt, const struct path *root)\n{\n\tstruct mount *m;\n\n\tfor (m = mnt->mnt_master; m != NULL; m = m->mnt_master) {\n\t\tstruct mount *d = get_peer_under_root(m, mnt->mnt_ns, root);\n\t\tif (d)\n\t\t\treturn d->mnt_group_id;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrtoul_from_user",
          "args": [
            "buf",
            "count",
            "0",
            "&t"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic ssize_t fuse_conn_limit_write(struct file *file, const char __user *buf,\n\t\t\t\t     size_t count, loff_t *ppos, unsigned *val,\n\t\t\t\t     unsigned global_limit)\n{\n\tunsigned long t;\n\tunsigned limit = (1 << 16) - 1;\n\tint err;\n\n\tif (*ppos)\n\t\treturn -EINVAL;\n\n\terr = kstrtoul_from_user(buf, count, 0, &t);\n\tif (err)\n\t\treturn err;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\tlimit = min(limit, global_limit);\n\n\tif (t > limit)\n\t\treturn -EINVAL;\n\n\t*val = t;\n\n\treturn count;\n}"
  },
  {
    "function_name": "fuse_conn_limit_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/control.c",
    "lines": "64-71",
    "snippet": "static ssize_t fuse_conn_limit_read(struct file *file, char __user *buf,\n\t\t\t\t    size_t len, loff_t *ppos, unsigned val)\n{\n\tchar tmp[32];\n\tsize_t size = sprintf(tmp, \"%u\\n\", val);\n\n\treturn simple_read_from_buffer(buf, len, ppos, tmp, size);\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "buf",
            "len",
            "ppos",
            "tmp",
            "size"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "simple_read_from_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "590-608",
          "snippet": "ssize_t simple_read_from_buffer(void __user *to, size_t count, loff_t *ppos,\n\t\t\t\tconst void *from, size_t available)\n{\n\tloff_t pos = *ppos;\n\tsize_t ret;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tif (pos >= available || !count)\n\t\treturn 0;\n\tif (count > available - pos)\n\t\tcount = available - pos;\n\tret = copy_to_user(to, from + pos, count);\n\tif (ret == count)\n\t\treturn -EFAULT;\n\tcount -= ret;\n\t*ppos = pos + count;\n\treturn count;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nssize_t simple_read_from_buffer(void __user *to, size_t count, loff_t *ppos,\n\t\t\t\tconst void *from, size_t available)\n{\n\tloff_t pos = *ppos;\n\tsize_t ret;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tif (pos >= available || !count)\n\t\treturn 0;\n\tif (count > available - pos)\n\t\tcount = available - pos;\n\tret = copy_to_user(to, from + pos, count);\n\tif (ret == count)\n\t\treturn -EFAULT;\n\tcount -= ret;\n\t*ppos = pos + count;\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "tmp",
            "\"%u\\n\"",
            "val"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic ssize_t fuse_conn_limit_read(struct file *file, char __user *buf,\n\t\t\t\t    size_t len, loff_t *ppos, unsigned val)\n{\n\tchar tmp[32];\n\tsize_t size = sprintf(tmp, \"%u\\n\", val);\n\n\treturn simple_read_from_buffer(buf, len, ppos, tmp, size);\n}"
  },
  {
    "function_name": "fuse_conn_waiting_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/control.c",
    "lines": "44-62",
    "snippet": "static ssize_t fuse_conn_waiting_read(struct file *file, char __user *buf,\n\t\t\t\t      size_t len, loff_t *ppos)\n{\n\tchar tmp[32];\n\tsize_t size;\n\n\tif (!*ppos) {\n\t\tlong value;\n\t\tstruct fuse_conn *fc = fuse_ctl_file_conn_get(file);\n\t\tif (!fc)\n\t\t\treturn 0;\n\n\t\tvalue = atomic_read(&fc->num_waiting);\n\t\tfile->private_data = (void *)value;\n\t\tfuse_conn_put(fc);\n\t}\n\tsize = sprintf(tmp, \"%ld\\n\", (long)file->private_data);\n\treturn simple_read_from_buffer(buf, len, ppos, tmp, size);\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "buf",
            "len",
            "ppos",
            "tmp",
            "size"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "simple_read_from_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "590-608",
          "snippet": "ssize_t simple_read_from_buffer(void __user *to, size_t count, loff_t *ppos,\n\t\t\t\tconst void *from, size_t available)\n{\n\tloff_t pos = *ppos;\n\tsize_t ret;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tif (pos >= available || !count)\n\t\treturn 0;\n\tif (count > available - pos)\n\t\tcount = available - pos;\n\tret = copy_to_user(to, from + pos, count);\n\tif (ret == count)\n\t\treturn -EFAULT;\n\tcount -= ret;\n\t*ppos = pos + count;\n\treturn count;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nssize_t simple_read_from_buffer(void __user *to, size_t count, loff_t *ppos,\n\t\t\t\tconst void *from, size_t available)\n{\n\tloff_t pos = *ppos;\n\tsize_t ret;\n\n\tif (pos < 0)\n\t\treturn -EINVAL;\n\tif (pos >= available || !count)\n\t\treturn 0;\n\tif (count > available - pos)\n\t\tcount = available - pos;\n\tret = copy_to_user(to, from + pos, count);\n\tif (ret == count)\n\t\treturn -EFAULT;\n\tcount -= ret;\n\t*ppos = pos + count;\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "tmp",
            "\"%ld\\n\"",
            "(long)file->private_data"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_conn_put",
          "args": [
            "fc"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_conn_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "599-606",
          "snippet": "void fuse_conn_put(struct fuse_conn *fc)\n{\n\tif (atomic_dec_and_test(&fc->count)) {\n\t\tif (fc->destroy_req)\n\t\t\tfuse_request_free(fc->destroy_req);\n\t\tfc->release(fc);\n\t}\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_conn_put(struct fuse_conn *fc)\n{\n\tif (atomic_dec_and_test(&fc->count)) {\n\t\tif (fc->destroy_req)\n\t\t\tfuse_request_free(fc->destroy_req);\n\t\tfc->release(fc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&fc->num_waiting"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_ctl_file_conn_get",
          "args": [
            "file"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_ctl_file_conn_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/control.c",
          "lines": "22-31",
          "snippet": "static struct fuse_conn *fuse_ctl_file_conn_get(struct file *file)\n{\n\tstruct fuse_conn *fc;\n\tmutex_lock(&fuse_mutex);\n\tfc = file_inode(file)->i_private;\n\tif (fc)\n\t\tfc = fuse_conn_get(fc);\n\tmutex_unlock(&fuse_mutex);\n\treturn fc;\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic struct fuse_conn *fuse_ctl_file_conn_get(struct file *file)\n{\n\tstruct fuse_conn *fc;\n\tmutex_lock(&fuse_mutex);\n\tfc = file_inode(file)->i_private;\n\tif (fc)\n\t\tfc = fuse_conn_get(fc);\n\tmutex_unlock(&fuse_mutex);\n\treturn fc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic ssize_t fuse_conn_waiting_read(struct file *file, char __user *buf,\n\t\t\t\t      size_t len, loff_t *ppos)\n{\n\tchar tmp[32];\n\tsize_t size;\n\n\tif (!*ppos) {\n\t\tlong value;\n\t\tstruct fuse_conn *fc = fuse_ctl_file_conn_get(file);\n\t\tif (!fc)\n\t\t\treturn 0;\n\n\t\tvalue = atomic_read(&fc->num_waiting);\n\t\tfile->private_data = (void *)value;\n\t\tfuse_conn_put(fc);\n\t}\n\tsize = sprintf(tmp, \"%ld\\n\", (long)file->private_data);\n\treturn simple_read_from_buffer(buf, len, ppos, tmp, size);\n}"
  },
  {
    "function_name": "fuse_conn_abort_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/control.c",
    "lines": "33-42",
    "snippet": "static ssize_t fuse_conn_abort_write(struct file *file, const char __user *buf,\n\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct fuse_conn *fc = fuse_ctl_file_conn_get(file);\n\tif (fc) {\n\t\tfuse_abort_conn(fc);\n\t\tfuse_conn_put(fc);\n\t}\n\treturn count;\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_conn_put",
          "args": [
            "fc"
          ],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_conn_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "599-606",
          "snippet": "void fuse_conn_put(struct fuse_conn *fc)\n{\n\tif (atomic_dec_and_test(&fc->count)) {\n\t\tif (fc->destroy_req)\n\t\t\tfuse_request_free(fc->destroy_req);\n\t\tfc->release(fc);\n\t}\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nvoid fuse_conn_put(struct fuse_conn *fc)\n{\n\tif (atomic_dec_and_test(&fc->count)) {\n\t\tif (fc->destroy_req)\n\t\t\tfuse_request_free(fc->destroy_req);\n\t\tfc->release(fc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_abort_conn",
          "args": [
            "fc"
          ],
          "line": 38
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_abort_conn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/dev.c",
          "lines": "2185-2200",
          "snippet": "void fuse_abort_conn(struct fuse_conn *fc)\n{\n\tspin_lock(&fc->lock);\n\tif (fc->connected) {\n\t\tfc->connected = 0;\n\t\tfc->blocked = 0;\n\t\tfuse_set_initialized(fc);\n\t\tend_io_requests(fc);\n\t\tend_queued_requests(fc);\n\t\tend_polls(fc);\n\t\twake_up_all(&fc->waitq);\n\t\twake_up_all(&fc->blocked_waitq);\n\t\tkill_fasync(&fc->fasync, SIGIO, POLL_IN);\n\t}\n\tspin_unlock(&fc->lock);\n}",
          "includes": [
            "#include <linux/aio.h>",
            "#include <linux/splice.h>",
            "#include <linux/swap.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/miscdevice.h>",
            "#include <linux/uio.h>",
            "#include <linux/poll.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/aio.h>\n#include <linux/splice.h>\n#include <linux/swap.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/pagemap.h>\n#include <linux/miscdevice.h>\n#include <linux/uio.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nvoid fuse_abort_conn(struct fuse_conn *fc)\n{\n\tspin_lock(&fc->lock);\n\tif (fc->connected) {\n\t\tfc->connected = 0;\n\t\tfc->blocked = 0;\n\t\tfuse_set_initialized(fc);\n\t\tend_io_requests(fc);\n\t\tend_queued_requests(fc);\n\t\tend_polls(fc);\n\t\twake_up_all(&fc->waitq);\n\t\twake_up_all(&fc->blocked_waitq);\n\t\tkill_fasync(&fc->fasync, SIGIO, POLL_IN);\n\t}\n\tspin_unlock(&fc->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_ctl_file_conn_get",
          "args": [
            "file"
          ],
          "line": 36
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_ctl_file_conn_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/control.c",
          "lines": "22-31",
          "snippet": "static struct fuse_conn *fuse_ctl_file_conn_get(struct file *file)\n{\n\tstruct fuse_conn *fc;\n\tmutex_lock(&fuse_mutex);\n\tfc = file_inode(file)->i_private;\n\tif (fc)\n\t\tfc = fuse_conn_get(fc);\n\tmutex_unlock(&fuse_mutex);\n\treturn fc;\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic struct fuse_conn *fuse_ctl_file_conn_get(struct file *file)\n{\n\tstruct fuse_conn *fc;\n\tmutex_lock(&fuse_mutex);\n\tfc = file_inode(file)->i_private;\n\tif (fc)\n\t\tfc = fuse_conn_get(fc);\n\tmutex_unlock(&fuse_mutex);\n\treturn fc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic ssize_t fuse_conn_abort_write(struct file *file, const char __user *buf,\n\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct fuse_conn *fc = fuse_ctl_file_conn_get(file);\n\tif (fc) {\n\t\tfuse_abort_conn(fc);\n\t\tfuse_conn_put(fc);\n\t}\n\treturn count;\n}"
  },
  {
    "function_name": "fuse_ctl_file_conn_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/control.c",
    "lines": "22-31",
    "snippet": "static struct fuse_conn *fuse_ctl_file_conn_get(struct file *file)\n{\n\tstruct fuse_conn *fc;\n\tmutex_lock(&fuse_mutex);\n\tfc = file_inode(file)->i_private;\n\tif (fc)\n\t\tfc = fuse_conn_get(fc);\n\tmutex_unlock(&fuse_mutex);\n\treturn fc;\n}",
    "includes": [
      "#include <linux/module.h>",
      "#include <linux/init.h>",
      "#include \"fuse_i.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&fuse_mutex"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_conn_get",
          "args": [
            "fc"
          ],
          "line": 28
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_conn_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/inode.c",
          "lines": "609-613",
          "snippet": "struct fuse_conn *fuse_conn_get(struct fuse_conn *fc)\n{\n\tatomic_inc(&fc->count);\n\treturn fc;\n}",
          "includes": [
            "#include <linux/exportfs.h>",
            "#include <linux/sched.h>",
            "#include <linux/random.h>",
            "#include <linux/statfs.h>",
            "#include <linux/parser.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/exportfs.h>\n#include <linux/sched.h>\n#include <linux/random.h>\n#include <linux/statfs.h>\n#include <linux/parser.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/seq_file.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstruct fuse_conn *fuse_conn_get(struct fuse_conn *fc)\n{\n\tatomic_inc(&fc->count);\n\treturn fc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 26
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&fuse_mutex"
          ],
          "line": 25
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/module.h>\n#include <linux/init.h>\n#include \"fuse_i.h\"\n\nstatic struct fuse_conn *fuse_ctl_file_conn_get(struct file *file)\n{\n\tstruct fuse_conn *fc;\n\tmutex_lock(&fuse_mutex);\n\tfc = file_inode(file)->i_private;\n\tif (fc)\n\t\tfc = fuse_conn_get(fc);\n\tmutex_unlock(&fuse_mutex);\n\treturn fc;\n}"
  }
]