[
  {
    "function_name": "__ntfs_cluster_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/lcnalloc.c",
    "lines": "849-1012",
    "snippet": "s64 __ntfs_cluster_free(ntfs_inode *ni, const VCN start_vcn, s64 count,\n\t\tntfs_attr_search_ctx *ctx, const bool is_rollback)\n{\n\ts64 delta, to_free, total_freed, real_freed;\n\tntfs_volume *vol;\n\tstruct inode *lcnbmp_vi;\n\trunlist_element *rl;\n\tint err;\n\n\tBUG_ON(!ni);\n\tntfs_debug(\"Entering for i_ino 0x%lx, start_vcn 0x%llx, count \"\n\t\t\t\"0x%llx.%s\", ni->mft_no, (unsigned long long)start_vcn,\n\t\t\t(unsigned long long)count,\n\t\t\tis_rollback ? \" (rollback)\" : \"\");\n\tvol = ni->vol;\n\tlcnbmp_vi = vol->lcnbmp_ino;\n\tBUG_ON(!lcnbmp_vi);\n\tBUG_ON(start_vcn < 0);\n\tBUG_ON(count < -1);\n\t/*\n\t * Lock the lcn bitmap for writing but only if not rolling back.  We\n\t * must hold the lock all the way including through rollback otherwise\n\t * rollback is not possible because once we have cleared a bit and\n\t * dropped the lock, anyone could have set the bit again, thus\n\t * allocating the cluster for another use.\n\t */\n\tif (likely(!is_rollback))\n\t\tdown_write(&vol->lcnbmp_lock);\n\n\ttotal_freed = real_freed = 0;\n\n\trl = ntfs_attr_find_vcn_nolock(ni, start_vcn, ctx);\n\tif (IS_ERR(rl)) {\n\t\tif (!is_rollback)\n\t\t\tntfs_error(vol->sb, \"Failed to find first runlist \"\n\t\t\t\t\t\"element (error %li), aborting.\",\n\t\t\t\t\tPTR_ERR(rl));\n\t\terr = PTR_ERR(rl);\n\t\tgoto err_out;\n\t}\n\tif (unlikely(rl->lcn < LCN_HOLE)) {\n\t\tif (!is_rollback)\n\t\t\tntfs_error(vol->sb, \"First runlist element has \"\n\t\t\t\t\t\"invalid lcn, aborting.\");\n\t\terr = -EIO;\n\t\tgoto err_out;\n\t}\n\t/* Find the starting cluster inside the run that needs freeing. */\n\tdelta = start_vcn - rl->vcn;\n\n\t/* The number of clusters in this run that need freeing. */\n\tto_free = rl->length - delta;\n\tif (count >= 0 && to_free > count)\n\t\tto_free = count;\n\n\tif (likely(rl->lcn >= 0)) {\n\t\t/* Do the actual freeing of the clusters in this run. */\n\t\terr = ntfs_bitmap_set_bits_in_run(lcnbmp_vi, rl->lcn + delta,\n\t\t\t\tto_free, likely(!is_rollback) ? 0 : 1);\n\t\tif (unlikely(err)) {\n\t\t\tif (!is_rollback)\n\t\t\t\tntfs_error(vol->sb, \"Failed to clear first run \"\n\t\t\t\t\t\t\"(error %i), aborting.\", err);\n\t\t\tgoto err_out;\n\t\t}\n\t\t/* We have freed @to_free real clusters. */\n\t\treal_freed = to_free;\n\t};\n\t/* Go to the next run and adjust the number of clusters left to free. */\n\t++rl;\n\tif (count >= 0)\n\t\tcount -= to_free;\n\n\t/* Keep track of the total \"freed\" clusters, including sparse ones. */\n\ttotal_freed = to_free;\n\t/*\n\t * Loop over the remaining runs, using @count as a capping value, and\n\t * free them.\n\t */\n\tfor (; rl->length && count != 0; ++rl) {\n\t\tif (unlikely(rl->lcn < LCN_HOLE)) {\n\t\t\tVCN vcn;\n\n\t\t\t/* Attempt to map runlist. */\n\t\t\tvcn = rl->vcn;\n\t\t\trl = ntfs_attr_find_vcn_nolock(ni, vcn, ctx);\n\t\t\tif (IS_ERR(rl)) {\n\t\t\t\terr = PTR_ERR(rl);\n\t\t\t\tif (!is_rollback)\n\t\t\t\t\tntfs_error(vol->sb, \"Failed to map \"\n\t\t\t\t\t\t\t\"runlist fragment or \"\n\t\t\t\t\t\t\t\"failed to find \"\n\t\t\t\t\t\t\t\"subsequent runlist \"\n\t\t\t\t\t\t\t\"element.\");\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\tif (unlikely(rl->lcn < LCN_HOLE)) {\n\t\t\t\tif (!is_rollback)\n\t\t\t\t\tntfs_error(vol->sb, \"Runlist element \"\n\t\t\t\t\t\t\t\"has invalid lcn \"\n\t\t\t\t\t\t\t\"(0x%llx).\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\trl->lcn);\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t}\n\t\t/* The number of clusters in this run that need freeing. */\n\t\tto_free = rl->length;\n\t\tif (count >= 0 && to_free > count)\n\t\t\tto_free = count;\n\n\t\tif (likely(rl->lcn >= 0)) {\n\t\t\t/* Do the actual freeing of the clusters in the run. */\n\t\t\terr = ntfs_bitmap_set_bits_in_run(lcnbmp_vi, rl->lcn,\n\t\t\t\t\tto_free, likely(!is_rollback) ? 0 : 1);\n\t\t\tif (unlikely(err)) {\n\t\t\t\tif (!is_rollback)\n\t\t\t\t\tntfs_error(vol->sb, \"Failed to clear \"\n\t\t\t\t\t\t\t\"subsequent run.\");\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\t/* We have freed @to_free real clusters. */\n\t\t\treal_freed += to_free;\n\t\t}\n\t\t/* Adjust the number of clusters left to free. */\n\t\tif (count >= 0)\n\t\t\tcount -= to_free;\n\t\n\t\t/* Update the total done clusters. */\n\t\ttotal_freed += to_free;\n\t}\n\tif (likely(!is_rollback))\n\t\tup_write(&vol->lcnbmp_lock);\n\n\tBUG_ON(count > 0);\n\n\t/* We are done.  Return the number of actually freed clusters. */\n\tntfs_debug(\"Done.\");\n\treturn real_freed;\nerr_out:\n\tif (is_rollback)\n\t\treturn err;\n\t/* If no real clusters were freed, no need to rollback. */\n\tif (!real_freed) {\n\t\tup_write(&vol->lcnbmp_lock);\n\t\treturn err;\n\t}\n\t/*\n\t * Attempt to rollback and if that succeeds just return the error code.\n\t * If rollback fails, set the volume errors flag, emit an error\n\t * message, and return the error code.\n\t */\n\tdelta = __ntfs_cluster_free(ni, start_vcn, total_freed, ctx, true);\n\tif (delta < 0) {\n\t\tntfs_error(vol->sb, \"Failed to rollback (error %i).  Leaving \"\n\t\t\t\t\"inconsistent metadata!  Unmount and run \"\n\t\t\t\t\"chkdsk.\", (int)delta);\n\t\tNVolSetErrors(vol);\n\t}\n\tup_write(&vol->lcnbmp_lock);\n\tntfs_error(vol->sb, \"Aborting (error %i).\", err);\n\treturn err;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"aops.h\"",
      "#include \"malloc.h\"",
      "#include \"attrib.h\"",
      "#include \"volume.h\"",
      "#include \"inode.h\"",
      "#include \"bitmap.h\"",
      "#include \"debug.h\"",
      "#include \"lcnalloc.h\"",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Aborting (error %i).\"",
            "err"
          ],
          "line": 1010
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "86-108",
          "snippet": "void __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&vol->lcnbmp_lock"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NVolSetErrors",
          "args": [
            "vol"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ntfs_cluster_free",
          "args": [
            "ni",
            "start_vcn",
            "total_freed",
            "ctx",
            "true"
          ],
          "line": 1002
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_cluster_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/lcnalloc.c",
          "lines": "849-1012",
          "snippet": "s64 __ntfs_cluster_free(ntfs_inode *ni, const VCN start_vcn, s64 count,\n\t\tntfs_attr_search_ctx *ctx, const bool is_rollback)\n{\n\ts64 delta, to_free, total_freed, real_freed;\n\tntfs_volume *vol;\n\tstruct inode *lcnbmp_vi;\n\trunlist_element *rl;\n\tint err;\n\n\tBUG_ON(!ni);\n\tntfs_debug(\"Entering for i_ino 0x%lx, start_vcn 0x%llx, count \"\n\t\t\t\"0x%llx.%s\", ni->mft_no, (unsigned long long)start_vcn,\n\t\t\t(unsigned long long)count,\n\t\t\tis_rollback ? \" (rollback)\" : \"\");\n\tvol = ni->vol;\n\tlcnbmp_vi = vol->lcnbmp_ino;\n\tBUG_ON(!lcnbmp_vi);\n\tBUG_ON(start_vcn < 0);\n\tBUG_ON(count < -1);\n\t/*\n\t * Lock the lcn bitmap for writing but only if not rolling back.  We\n\t * must hold the lock all the way including through rollback otherwise\n\t * rollback is not possible because once we have cleared a bit and\n\t * dropped the lock, anyone could have set the bit again, thus\n\t * allocating the cluster for another use.\n\t */\n\tif (likely(!is_rollback))\n\t\tdown_write(&vol->lcnbmp_lock);\n\n\ttotal_freed = real_freed = 0;\n\n\trl = ntfs_attr_find_vcn_nolock(ni, start_vcn, ctx);\n\tif (IS_ERR(rl)) {\n\t\tif (!is_rollback)\n\t\t\tntfs_error(vol->sb, \"Failed to find first runlist \"\n\t\t\t\t\t\"element (error %li), aborting.\",\n\t\t\t\t\tPTR_ERR(rl));\n\t\terr = PTR_ERR(rl);\n\t\tgoto err_out;\n\t}\n\tif (unlikely(rl->lcn < LCN_HOLE)) {\n\t\tif (!is_rollback)\n\t\t\tntfs_error(vol->sb, \"First runlist element has \"\n\t\t\t\t\t\"invalid lcn, aborting.\");\n\t\terr = -EIO;\n\t\tgoto err_out;\n\t}\n\t/* Find the starting cluster inside the run that needs freeing. */\n\tdelta = start_vcn - rl->vcn;\n\n\t/* The number of clusters in this run that need freeing. */\n\tto_free = rl->length - delta;\n\tif (count >= 0 && to_free > count)\n\t\tto_free = count;\n\n\tif (likely(rl->lcn >= 0)) {\n\t\t/* Do the actual freeing of the clusters in this run. */\n\t\terr = ntfs_bitmap_set_bits_in_run(lcnbmp_vi, rl->lcn + delta,\n\t\t\t\tto_free, likely(!is_rollback) ? 0 : 1);\n\t\tif (unlikely(err)) {\n\t\t\tif (!is_rollback)\n\t\t\t\tntfs_error(vol->sb, \"Failed to clear first run \"\n\t\t\t\t\t\t\"(error %i), aborting.\", err);\n\t\t\tgoto err_out;\n\t\t}\n\t\t/* We have freed @to_free real clusters. */\n\t\treal_freed = to_free;\n\t};\n\t/* Go to the next run and adjust the number of clusters left to free. */\n\t++rl;\n\tif (count >= 0)\n\t\tcount -= to_free;\n\n\t/* Keep track of the total \"freed\" clusters, including sparse ones. */\n\ttotal_freed = to_free;\n\t/*\n\t * Loop over the remaining runs, using @count as a capping value, and\n\t * free them.\n\t */\n\tfor (; rl->length && count != 0; ++rl) {\n\t\tif (unlikely(rl->lcn < LCN_HOLE)) {\n\t\t\tVCN vcn;\n\n\t\t\t/* Attempt to map runlist. */\n\t\t\tvcn = rl->vcn;\n\t\t\trl = ntfs_attr_find_vcn_nolock(ni, vcn, ctx);\n\t\t\tif (IS_ERR(rl)) {\n\t\t\t\terr = PTR_ERR(rl);\n\t\t\t\tif (!is_rollback)\n\t\t\t\t\tntfs_error(vol->sb, \"Failed to map \"\n\t\t\t\t\t\t\t\"runlist fragment or \"\n\t\t\t\t\t\t\t\"failed to find \"\n\t\t\t\t\t\t\t\"subsequent runlist \"\n\t\t\t\t\t\t\t\"element.\");\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\tif (unlikely(rl->lcn < LCN_HOLE)) {\n\t\t\t\tif (!is_rollback)\n\t\t\t\t\tntfs_error(vol->sb, \"Runlist element \"\n\t\t\t\t\t\t\t\"has invalid lcn \"\n\t\t\t\t\t\t\t\"(0x%llx).\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\trl->lcn);\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t}\n\t\t/* The number of clusters in this run that need freeing. */\n\t\tto_free = rl->length;\n\t\tif (count >= 0 && to_free > count)\n\t\t\tto_free = count;\n\n\t\tif (likely(rl->lcn >= 0)) {\n\t\t\t/* Do the actual freeing of the clusters in the run. */\n\t\t\terr = ntfs_bitmap_set_bits_in_run(lcnbmp_vi, rl->lcn,\n\t\t\t\t\tto_free, likely(!is_rollback) ? 0 : 1);\n\t\t\tif (unlikely(err)) {\n\t\t\t\tif (!is_rollback)\n\t\t\t\t\tntfs_error(vol->sb, \"Failed to clear \"\n\t\t\t\t\t\t\t\"subsequent run.\");\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\t/* We have freed @to_free real clusters. */\n\t\t\treal_freed += to_free;\n\t\t}\n\t\t/* Adjust the number of clusters left to free. */\n\t\tif (count >= 0)\n\t\t\tcount -= to_free;\n\t\n\t\t/* Update the total done clusters. */\n\t\ttotal_freed += to_free;\n\t}\n\tif (likely(!is_rollback))\n\t\tup_write(&vol->lcnbmp_lock);\n\n\tBUG_ON(count > 0);\n\n\t/* We are done.  Return the number of actually freed clusters. */\n\tntfs_debug(\"Done.\");\n\treturn real_freed;\nerr_out:\n\tif (is_rollback)\n\t\treturn err;\n\t/* If no real clusters were freed, no need to rollback. */\n\tif (!real_freed) {\n\t\tup_write(&vol->lcnbmp_lock);\n\t\treturn err;\n\t}\n\t/*\n\t * Attempt to rollback and if that succeeds just return the error code.\n\t * If rollback fails, set the volume errors flag, emit an error\n\t * message, and return the error code.\n\t */\n\tdelta = __ntfs_cluster_free(ni, start_vcn, total_freed, ctx, true);\n\tif (delta < 0) {\n\t\tntfs_error(vol->sb, \"Failed to rollback (error %i).  Leaving \"\n\t\t\t\t\"inconsistent metadata!  Unmount and run \"\n\t\t\t\t\"chkdsk.\", (int)delta);\n\t\tNVolSetErrors(vol);\n\t}\n\tup_write(&vol->lcnbmp_lock);\n\tntfs_error(vol->sb, \"Aborting (error %i).\", err);\n\treturn err;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&vol->lcnbmp_lock"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Done.\""
          ],
          "line": 987
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "count > 0"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&vol->lcnbmp_lock"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!is_rollback"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to clear \"\n\t\t\t\t\t\t\t\"subsequent run.\""
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_bitmap_set_bits_in_run",
          "args": [
            "lcnbmp_vi",
            "rl->lcn",
            "to_free",
            "likely(!is_rollback) ? 0 : 1"
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_bitmap_set_bits_in_run",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/bitmap.h",
          "lines": "47-52",
          "snippet": "static inline int ntfs_bitmap_set_bits_in_run(struct inode *vi,\n\t\tconst s64 start_bit, const s64 count, const u8 value)\n{\n\treturn __ntfs_bitmap_set_bits_in_run(vi, start_bit, count, value,\n\t\t\tfalse);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline int ntfs_bitmap_set_bits_in_run(struct inode *vi,\n\t\tconst s64 start_bit, const s64 count, const u8 value)\n{\n\treturn __ntfs_bitmap_set_bits_in_run(vi, start_bit, count, value,\n\t\t\tfalse);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!is_rollback"
          ],
          "line": 964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "rl->lcn >= 0"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "rl->lcn < LCN_HOLE"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to map \"\n\t\t\t\t\t\t\t\"runlist fragment or \"\n\t\t\t\t\t\t\t\"failed to find \"\n\t\t\t\t\t\t\t\"subsequent runlist \"\n\t\t\t\t\t\t\t\"element.\""
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "rl"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "rl"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_attr_find_vcn_nolock",
          "args": [
            "ni",
            "vcn",
            "ctx"
          ],
          "line": 934
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_attr_find_vcn_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/attrib.c",
          "lines": "464-530",
          "snippet": "runlist_element *ntfs_attr_find_vcn_nolock(ntfs_inode *ni, const VCN vcn,\n\t\tntfs_attr_search_ctx *ctx)\n{\n\tunsigned long flags;\n\trunlist_element *rl;\n\tint err = 0;\n\tbool is_retry = false;\n\n\tBUG_ON(!ni);\n\tntfs_debug(\"Entering for i_ino 0x%lx, vcn 0x%llx, with%s ctx.\",\n\t\t\tni->mft_no, (unsigned long long)vcn, ctx ? \"\" : \"out\");\n\tBUG_ON(!NInoNonResident(ni));\n\tBUG_ON(vcn < 0);\n\tif (!ni->runlist.rl) {\n\t\tread_lock_irqsave(&ni->size_lock, flags);\n\t\tif (!ni->allocated_size) {\n\t\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t\t\treturn ERR_PTR(-ENOENT);\n\t\t}\n\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t}\nretry_remap:\n\trl = ni->runlist.rl;\n\tif (likely(rl && vcn >= rl[0].vcn)) {\n\t\twhile (likely(rl->length)) {\n\t\t\tif (unlikely(vcn < rl[1].vcn)) {\n\t\t\t\tif (likely(rl->lcn >= LCN_HOLE)) {\n\t\t\t\t\tntfs_debug(\"Done.\");\n\t\t\t\t\treturn rl;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trl++;\n\t\t}\n\t\tif (likely(rl->lcn != LCN_RL_NOT_MAPPED)) {\n\t\t\tif (likely(rl->lcn == LCN_ENOENT))\n\t\t\t\terr = -ENOENT;\n\t\t\telse\n\t\t\t\terr = -EIO;\n\t\t}\n\t}\n\tif (!err && !is_retry) {\n\t\t/*\n\t\t * If the search context is invalid we cannot map the unmapped\n\t\t * region.\n\t\t */\n\t\tif (IS_ERR(ctx->mrec))\n\t\t\terr = PTR_ERR(ctx->mrec);\n\t\telse {\n\t\t\t/*\n\t\t\t * The @vcn is in an unmapped region, map the runlist\n\t\t\t * and retry.\n\t\t\t */\n\t\t\terr = ntfs_map_runlist_nolock(ni, vcn, ctx);\n\t\t\tif (likely(!err)) {\n\t\t\t\tis_retry = true;\n\t\t\t\tgoto retry_remap;\n\t\t\t}\n\t\t}\n\t\tif (err == -EINVAL)\n\t\t\terr = -EIO;\n\t} else if (!err)\n\t\terr = -EIO;\n\tif (err != -ENOENT)\n\t\tntfs_error(ni->vol->sb, \"Failed with error code %i.\", err);\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include \"ntfs.h\"",
            "#include \"mft.h\"",
            "#include \"malloc.h\"",
            "#include \"lcnalloc.h\"",
            "#include \"layout.h\"",
            "#include \"debug.h\"",
            "#include \"attrib.h\"",
            "#include <linux/writeback.h>",
            "#include <linux/swap.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/buffer_head.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include \"ntfs.h\"\n#include \"mft.h\"\n#include \"malloc.h\"\n#include \"lcnalloc.h\"\n#include \"layout.h\"\n#include \"debug.h\"\n#include \"attrib.h\"\n#include <linux/writeback.h>\n#include <linux/swap.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/buffer_head.h>\n\nrunlist_element *ntfs_attr_find_vcn_nolock(ntfs_inode *ni, const VCN vcn,\n\t\tntfs_attr_search_ctx *ctx)\n{\n\tunsigned long flags;\n\trunlist_element *rl;\n\tint err = 0;\n\tbool is_retry = false;\n\n\tBUG_ON(!ni);\n\tntfs_debug(\"Entering for i_ino 0x%lx, vcn 0x%llx, with%s ctx.\",\n\t\t\tni->mft_no, (unsigned long long)vcn, ctx ? \"\" : \"out\");\n\tBUG_ON(!NInoNonResident(ni));\n\tBUG_ON(vcn < 0);\n\tif (!ni->runlist.rl) {\n\t\tread_lock_irqsave(&ni->size_lock, flags);\n\t\tif (!ni->allocated_size) {\n\t\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t\t\treturn ERR_PTR(-ENOENT);\n\t\t}\n\t\tread_unlock_irqrestore(&ni->size_lock, flags);\n\t}\nretry_remap:\n\trl = ni->runlist.rl;\n\tif (likely(rl && vcn >= rl[0].vcn)) {\n\t\twhile (likely(rl->length)) {\n\t\t\tif (unlikely(vcn < rl[1].vcn)) {\n\t\t\t\tif (likely(rl->lcn >= LCN_HOLE)) {\n\t\t\t\t\tntfs_debug(\"Done.\");\n\t\t\t\t\treturn rl;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trl++;\n\t\t}\n\t\tif (likely(rl->lcn != LCN_RL_NOT_MAPPED)) {\n\t\t\tif (likely(rl->lcn == LCN_ENOENT))\n\t\t\t\terr = -ENOENT;\n\t\t\telse\n\t\t\t\terr = -EIO;\n\t\t}\n\t}\n\tif (!err && !is_retry) {\n\t\t/*\n\t\t * If the search context is invalid we cannot map the unmapped\n\t\t * region.\n\t\t */\n\t\tif (IS_ERR(ctx->mrec))\n\t\t\terr = PTR_ERR(ctx->mrec);\n\t\telse {\n\t\t\t/*\n\t\t\t * The @vcn is in an unmapped region, map the runlist\n\t\t\t * and retry.\n\t\t\t */\n\t\t\terr = ntfs_map_runlist_nolock(ni, vcn, ctx);\n\t\t\tif (likely(!err)) {\n\t\t\t\tis_retry = true;\n\t\t\t\tgoto retry_remap;\n\t\t\t}\n\t\t}\n\t\tif (err == -EINVAL)\n\t\t\terr = -EIO;\n\t} else if (!err)\n\t\terr = -EIO;\n\tif (err != -ENOENT)\n\t\tntfs_error(ni->vol->sb, \"Failed with error code %i.\", err);\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "rl->lcn < LCN_HOLE"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!is_rollback"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "rl->lcn >= 0"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"First runlist element has \"\n\t\t\t\t\t\"invalid lcn, aborting.\""
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "rl->lcn < LCN_HOLE"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "rl"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "rl"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "rl"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&vol->lcnbmp_lock"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!is_rollback"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "count < -1"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "start_vcn < 0"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!lcnbmp_vi"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Entering for i_ino 0x%lx, start_vcn 0x%llx, count \"\n\t\t\t\"0x%llx.%s\"",
            "ni->mft_no",
            "(unsigned long long)start_vcn",
            "(unsigned long long)count",
            "is_rollback ? \" (rollback)\" : \"\""
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "115-131",
          "snippet": "void __ntfs_debug(const char *file, int line, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n\tif (!debug_msgs)\n\t\treturn;\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s, %d): %s(): %pV\", file, line, flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_debug(const char *file, int line, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n\tif (!debug_msgs)\n\t\treturn;\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s, %d): %s(): %pV\", file, line, flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ni"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"aops.h\"\n#include \"malloc.h\"\n#include \"attrib.h\"\n#include \"volume.h\"\n#include \"inode.h\"\n#include \"bitmap.h\"\n#include \"debug.h\"\n#include \"lcnalloc.h\"\n#include <linux/pagemap.h>\n\ns64 __ntfs_cluster_free(ntfs_inode *ni, const VCN start_vcn, s64 count,\n\t\tntfs_attr_search_ctx *ctx, const bool is_rollback)\n{\n\ts64 delta, to_free, total_freed, real_freed;\n\tntfs_volume *vol;\n\tstruct inode *lcnbmp_vi;\n\trunlist_element *rl;\n\tint err;\n\n\tBUG_ON(!ni);\n\tntfs_debug(\"Entering for i_ino 0x%lx, start_vcn 0x%llx, count \"\n\t\t\t\"0x%llx.%s\", ni->mft_no, (unsigned long long)start_vcn,\n\t\t\t(unsigned long long)count,\n\t\t\tis_rollback ? \" (rollback)\" : \"\");\n\tvol = ni->vol;\n\tlcnbmp_vi = vol->lcnbmp_ino;\n\tBUG_ON(!lcnbmp_vi);\n\tBUG_ON(start_vcn < 0);\n\tBUG_ON(count < -1);\n\t/*\n\t * Lock the lcn bitmap for writing but only if not rolling back.  We\n\t * must hold the lock all the way including through rollback otherwise\n\t * rollback is not possible because once we have cleared a bit and\n\t * dropped the lock, anyone could have set the bit again, thus\n\t * allocating the cluster for another use.\n\t */\n\tif (likely(!is_rollback))\n\t\tdown_write(&vol->lcnbmp_lock);\n\n\ttotal_freed = real_freed = 0;\n\n\trl = ntfs_attr_find_vcn_nolock(ni, start_vcn, ctx);\n\tif (IS_ERR(rl)) {\n\t\tif (!is_rollback)\n\t\t\tntfs_error(vol->sb, \"Failed to find first runlist \"\n\t\t\t\t\t\"element (error %li), aborting.\",\n\t\t\t\t\tPTR_ERR(rl));\n\t\terr = PTR_ERR(rl);\n\t\tgoto err_out;\n\t}\n\tif (unlikely(rl->lcn < LCN_HOLE)) {\n\t\tif (!is_rollback)\n\t\t\tntfs_error(vol->sb, \"First runlist element has \"\n\t\t\t\t\t\"invalid lcn, aborting.\");\n\t\terr = -EIO;\n\t\tgoto err_out;\n\t}\n\t/* Find the starting cluster inside the run that needs freeing. */\n\tdelta = start_vcn - rl->vcn;\n\n\t/* The number of clusters in this run that need freeing. */\n\tto_free = rl->length - delta;\n\tif (count >= 0 && to_free > count)\n\t\tto_free = count;\n\n\tif (likely(rl->lcn >= 0)) {\n\t\t/* Do the actual freeing of the clusters in this run. */\n\t\terr = ntfs_bitmap_set_bits_in_run(lcnbmp_vi, rl->lcn + delta,\n\t\t\t\tto_free, likely(!is_rollback) ? 0 : 1);\n\t\tif (unlikely(err)) {\n\t\t\tif (!is_rollback)\n\t\t\t\tntfs_error(vol->sb, \"Failed to clear first run \"\n\t\t\t\t\t\t\"(error %i), aborting.\", err);\n\t\t\tgoto err_out;\n\t\t}\n\t\t/* We have freed @to_free real clusters. */\n\t\treal_freed = to_free;\n\t};\n\t/* Go to the next run and adjust the number of clusters left to free. */\n\t++rl;\n\tif (count >= 0)\n\t\tcount -= to_free;\n\n\t/* Keep track of the total \"freed\" clusters, including sparse ones. */\n\ttotal_freed = to_free;\n\t/*\n\t * Loop over the remaining runs, using @count as a capping value, and\n\t * free them.\n\t */\n\tfor (; rl->length && count != 0; ++rl) {\n\t\tif (unlikely(rl->lcn < LCN_HOLE)) {\n\t\t\tVCN vcn;\n\n\t\t\t/* Attempt to map runlist. */\n\t\t\tvcn = rl->vcn;\n\t\t\trl = ntfs_attr_find_vcn_nolock(ni, vcn, ctx);\n\t\t\tif (IS_ERR(rl)) {\n\t\t\t\terr = PTR_ERR(rl);\n\t\t\t\tif (!is_rollback)\n\t\t\t\t\tntfs_error(vol->sb, \"Failed to map \"\n\t\t\t\t\t\t\t\"runlist fragment or \"\n\t\t\t\t\t\t\t\"failed to find \"\n\t\t\t\t\t\t\t\"subsequent runlist \"\n\t\t\t\t\t\t\t\"element.\");\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\tif (unlikely(rl->lcn < LCN_HOLE)) {\n\t\t\t\tif (!is_rollback)\n\t\t\t\t\tntfs_error(vol->sb, \"Runlist element \"\n\t\t\t\t\t\t\t\"has invalid lcn \"\n\t\t\t\t\t\t\t\"(0x%llx).\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\trl->lcn);\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t}\n\t\t/* The number of clusters in this run that need freeing. */\n\t\tto_free = rl->length;\n\t\tif (count >= 0 && to_free > count)\n\t\t\tto_free = count;\n\n\t\tif (likely(rl->lcn >= 0)) {\n\t\t\t/* Do the actual freeing of the clusters in the run. */\n\t\t\terr = ntfs_bitmap_set_bits_in_run(lcnbmp_vi, rl->lcn,\n\t\t\t\t\tto_free, likely(!is_rollback) ? 0 : 1);\n\t\t\tif (unlikely(err)) {\n\t\t\t\tif (!is_rollback)\n\t\t\t\t\tntfs_error(vol->sb, \"Failed to clear \"\n\t\t\t\t\t\t\t\"subsequent run.\");\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\t/* We have freed @to_free real clusters. */\n\t\t\treal_freed += to_free;\n\t\t}\n\t\t/* Adjust the number of clusters left to free. */\n\t\tif (count >= 0)\n\t\t\tcount -= to_free;\n\t\n\t\t/* Update the total done clusters. */\n\t\ttotal_freed += to_free;\n\t}\n\tif (likely(!is_rollback))\n\t\tup_write(&vol->lcnbmp_lock);\n\n\tBUG_ON(count > 0);\n\n\t/* We are done.  Return the number of actually freed clusters. */\n\tntfs_debug(\"Done.\");\n\treturn real_freed;\nerr_out:\n\tif (is_rollback)\n\t\treturn err;\n\t/* If no real clusters were freed, no need to rollback. */\n\tif (!real_freed) {\n\t\tup_write(&vol->lcnbmp_lock);\n\t\treturn err;\n\t}\n\t/*\n\t * Attempt to rollback and if that succeeds just return the error code.\n\t * If rollback fails, set the volume errors flag, emit an error\n\t * message, and return the error code.\n\t */\n\tdelta = __ntfs_cluster_free(ni, start_vcn, total_freed, ctx, true);\n\tif (delta < 0) {\n\t\tntfs_error(vol->sb, \"Failed to rollback (error %i).  Leaving \"\n\t\t\t\t\"inconsistent metadata!  Unmount and run \"\n\t\t\t\t\"chkdsk.\", (int)delta);\n\t\tNVolSetErrors(vol);\n\t}\n\tup_write(&vol->lcnbmp_lock);\n\tntfs_error(vol->sb, \"Aborting (error %i).\", err);\n\treturn err;\n}"
  },
  {
    "function_name": "ntfs_cluster_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/lcnalloc.c",
    "lines": "146-787",
    "snippet": "runlist_element *ntfs_cluster_alloc(ntfs_volume *vol, const VCN start_vcn,\n\t\tconst s64 count, const LCN start_lcn,\n\t\tconst NTFS_CLUSTER_ALLOCATION_ZONES zone,\n\t\tconst bool is_extension)\n{\n\tLCN zone_start, zone_end, bmp_pos, bmp_initial_pos, last_read_pos, lcn;\n\tLCN prev_lcn = 0, prev_run_len = 0, mft_zone_size;\n\ts64 clusters;\n\tloff_t i_size;\n\tstruct inode *lcnbmp_vi;\n\trunlist_element *rl = NULL;\n\tstruct address_space *mapping;\n\tstruct page *page = NULL;\n\tu8 *buf, *byte;\n\tint err = 0, rlpos, rlsize, buf_size;\n\tu8 pass, done_zones, search_zone, need_writeback = 0, bit;\n\n\tntfs_debug(\"Entering for start_vcn 0x%llx, count 0x%llx, start_lcn \"\n\t\t\t\"0x%llx, zone %s_ZONE.\", (unsigned long long)start_vcn,\n\t\t\t(unsigned long long)count,\n\t\t\t(unsigned long long)start_lcn,\n\t\t\tzone == MFT_ZONE ? \"MFT\" : \"DATA\");\n\tBUG_ON(!vol);\n\tlcnbmp_vi = vol->lcnbmp_ino;\n\tBUG_ON(!lcnbmp_vi);\n\tBUG_ON(start_vcn < 0);\n\tBUG_ON(count < 0);\n\tBUG_ON(start_lcn < -1);\n\tBUG_ON(zone < FIRST_ZONE);\n\tBUG_ON(zone > LAST_ZONE);\n\n\t/* Return NULL if @count is zero. */\n\tif (!count)\n\t\treturn NULL;\n\t/* Take the lcnbmp lock for writing. */\n\tdown_write(&vol->lcnbmp_lock);\n\t/*\n\t * If no specific @start_lcn was requested, use the current data zone\n\t * position, otherwise use the requested @start_lcn but make sure it\n\t * lies outside the mft zone.  Also set done_zones to 0 (no zones done)\n\t * and pass depending on whether we are starting inside a zone (1) or\n\t * at the beginning of a zone (2).  If requesting from the MFT_ZONE,\n\t * we either start at the current position within the mft zone or at\n\t * the specified position.  If the latter is out of bounds then we start\n\t * at the beginning of the MFT_ZONE.\n\t */\n\tdone_zones = 0;\n\tpass = 1;\n\t/*\n\t * zone_start and zone_end are the current search range.  search_zone\n\t * is 1 for mft zone, 2 for data zone 1 (end of mft zone till end of\n\t * volume) and 4 for data zone 2 (start of volume till start of mft\n\t * zone).\n\t */\n\tzone_start = start_lcn;\n\tif (zone_start < 0) {\n\t\tif (zone == DATA_ZONE)\n\t\t\tzone_start = vol->data1_zone_pos;\n\t\telse\n\t\t\tzone_start = vol->mft_zone_pos;\n\t\tif (!zone_start) {\n\t\t\t/*\n\t\t\t * Zone starts at beginning of volume which means a\n\t\t\t * single pass is sufficient.\n\t\t\t */\n\t\t\tpass = 2;\n\t\t}\n\t} else if (zone == DATA_ZONE && zone_start >= vol->mft_zone_start &&\n\t\t\tzone_start < vol->mft_zone_end) {\n\t\tzone_start = vol->mft_zone_end;\n\t\t/*\n\t\t * Starting at beginning of data1_zone which means a single\n\t\t * pass in this zone is sufficient.\n\t\t */\n\t\tpass = 2;\n\t} else if (zone == MFT_ZONE && (zone_start < vol->mft_zone_start ||\n\t\t\tzone_start >= vol->mft_zone_end)) {\n\t\tzone_start = vol->mft_lcn;\n\t\tif (!vol->mft_zone_end)\n\t\t\tzone_start = 0;\n\t\t/*\n\t\t * Starting at beginning of volume which means a single pass\n\t\t * is sufficient.\n\t\t */\n\t\tpass = 2;\n\t}\n\tif (zone == MFT_ZONE) {\n\t\tzone_end = vol->mft_zone_end;\n\t\tsearch_zone = 1;\n\t} else /* if (zone == DATA_ZONE) */ {\n\t\t/* Skip searching the mft zone. */\n\t\tdone_zones |= 1;\n\t\tif (zone_start >= vol->mft_zone_end) {\n\t\t\tzone_end = vol->nr_clusters;\n\t\t\tsearch_zone = 2;\n\t\t} else {\n\t\t\tzone_end = vol->mft_zone_start;\n\t\t\tsearch_zone = 4;\n\t\t}\n\t}\n\t/*\n\t * bmp_pos is the current bit position inside the bitmap.  We use\n\t * bmp_initial_pos to determine whether or not to do a zone switch.\n\t */\n\tbmp_pos = bmp_initial_pos = zone_start;\n\n\t/* Loop until all clusters are allocated, i.e. clusters == 0. */\n\tclusters = count;\n\trlpos = rlsize = 0;\n\tmapping = lcnbmp_vi->i_mapping;\n\ti_size = i_size_read(lcnbmp_vi);\n\twhile (1) {\n\t\tntfs_debug(\"Start of outer while loop: done_zones 0x%x, \"\n\t\t\t\t\"search_zone %i, pass %i, zone_start 0x%llx, \"\n\t\t\t\t\"zone_end 0x%llx, bmp_initial_pos 0x%llx, \"\n\t\t\t\t\"bmp_pos 0x%llx, rlpos %i, rlsize %i.\",\n\t\t\t\tdone_zones, search_zone, pass,\n\t\t\t\t(unsigned long long)zone_start,\n\t\t\t\t(unsigned long long)zone_end,\n\t\t\t\t(unsigned long long)bmp_initial_pos,\n\t\t\t\t(unsigned long long)bmp_pos, rlpos, rlsize);\n\t\t/* Loop until we run out of free clusters. */\n\t\tlast_read_pos = bmp_pos >> 3;\n\t\tntfs_debug(\"last_read_pos 0x%llx.\",\n\t\t\t\t(unsigned long long)last_read_pos);\n\t\tif (last_read_pos > i_size) {\n\t\t\tntfs_debug(\"End of attribute reached.  \"\n\t\t\t\t\t\"Skipping to zone_pass_done.\");\n\t\t\tgoto zone_pass_done;\n\t\t}\n\t\tif (likely(page)) {\n\t\t\tif (need_writeback) {\n\t\t\t\tntfs_debug(\"Marking page dirty.\");\n\t\t\t\tflush_dcache_page(page);\n\t\t\t\tset_page_dirty(page);\n\t\t\t\tneed_writeback = 0;\n\t\t\t}\n\t\t\tntfs_unmap_page(page);\n\t\t}\n\t\tpage = ntfs_map_page(mapping, last_read_pos >>\n\t\t\t\tPAGE_CACHE_SHIFT);\n\t\tif (IS_ERR(page)) {\n\t\t\terr = PTR_ERR(page);\n\t\t\tntfs_error(vol->sb, \"Failed to map page.\");\n\t\t\tgoto out;\n\t\t}\n\t\tbuf_size = last_read_pos & ~PAGE_CACHE_MASK;\n\t\tbuf = page_address(page) + buf_size;\n\t\tbuf_size = PAGE_CACHE_SIZE - buf_size;\n\t\tif (unlikely(last_read_pos + buf_size > i_size))\n\t\t\tbuf_size = i_size - last_read_pos;\n\t\tbuf_size <<= 3;\n\t\tlcn = bmp_pos & 7;\n\t\tbmp_pos &= ~(LCN)7;\n\t\tntfs_debug(\"Before inner while loop: buf_size %i, lcn 0x%llx, \"\n\t\t\t\t\"bmp_pos 0x%llx, need_writeback %i.\", buf_size,\n\t\t\t\t(unsigned long long)lcn,\n\t\t\t\t(unsigned long long)bmp_pos, need_writeback);\n\t\twhile (lcn < buf_size && lcn + bmp_pos < zone_end) {\n\t\t\tbyte = buf + (lcn >> 3);\n\t\t\tntfs_debug(\"In inner while loop: buf_size %i, \"\n\t\t\t\t\t\"lcn 0x%llx, bmp_pos 0x%llx, \"\n\t\t\t\t\t\"need_writeback %i, byte ofs 0x%x, \"\n\t\t\t\t\t\"*byte 0x%x.\", buf_size,\n\t\t\t\t\t(unsigned long long)lcn,\n\t\t\t\t\t(unsigned long long)bmp_pos,\n\t\t\t\t\tneed_writeback,\n\t\t\t\t\t(unsigned int)(lcn >> 3),\n\t\t\t\t\t(unsigned int)*byte);\n\t\t\t/* Skip full bytes. */\n\t\t\tif (*byte == 0xff) {\n\t\t\t\tlcn = (lcn + 8) & ~(LCN)7;\n\t\t\t\tntfs_debug(\"Continuing while loop 1.\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbit = 1 << (lcn & 7);\n\t\t\tntfs_debug(\"bit 0x%x.\", bit);\n\t\t\t/* If the bit is already set, go onto the next one. */\n\t\t\tif (*byte & bit) {\n\t\t\t\tlcn++;\n\t\t\t\tntfs_debug(\"Continuing while loop 2.\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Allocate more memory if needed, including space for\n\t\t\t * the terminator element.\n\t\t\t * ntfs_malloc_nofs() operates on whole pages only.\n\t\t\t */\n\t\t\tif ((rlpos + 2) * sizeof(*rl) > rlsize) {\n\t\t\t\trunlist_element *rl2;\n\n\t\t\t\tntfs_debug(\"Reallocating memory.\");\n\t\t\t\tif (!rl)\n\t\t\t\t\tntfs_debug(\"First free bit is at LCN \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\t(lcn + bmp_pos));\n\t\t\t\trl2 = ntfs_malloc_nofs(rlsize + (int)PAGE_SIZE);\n\t\t\t\tif (unlikely(!rl2)) {\n\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\tntfs_error(vol->sb, \"Failed to \"\n\t\t\t\t\t\t\t\"allocate memory.\");\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tmemcpy(rl2, rl, rlsize);\n\t\t\t\tntfs_free(rl);\n\t\t\t\trl = rl2;\n\t\t\t\trlsize += PAGE_SIZE;\n\t\t\t\tntfs_debug(\"Reallocated memory, rlsize 0x%x.\",\n\t\t\t\t\t\trlsize);\n\t\t\t}\n\t\t\t/* Allocate the bitmap bit. */\n\t\t\t*byte |= bit;\n\t\t\t/* We need to write this bitmap page to disk. */\n\t\t\tneed_writeback = 1;\n\t\t\tntfs_debug(\"*byte 0x%x, need_writeback is set.\",\n\t\t\t\t\t(unsigned int)*byte);\n\t\t\t/*\n\t\t\t * Coalesce with previous run if adjacent LCNs.\n\t\t\t * Otherwise, append a new run.\n\t\t\t */\n\t\t\tntfs_debug(\"Adding run (lcn 0x%llx, len 0x%llx), \"\n\t\t\t\t\t\"prev_lcn 0x%llx, lcn 0x%llx, \"\n\t\t\t\t\t\"bmp_pos 0x%llx, prev_run_len 0x%llx, \"\n\t\t\t\t\t\"rlpos %i.\",\n\t\t\t\t\t(unsigned long long)(lcn + bmp_pos),\n\t\t\t\t\t1ULL, (unsigned long long)prev_lcn,\n\t\t\t\t\t(unsigned long long)lcn,\n\t\t\t\t\t(unsigned long long)bmp_pos,\n\t\t\t\t\t(unsigned long long)prev_run_len,\n\t\t\t\t\trlpos);\n\t\t\tif (prev_lcn == lcn + bmp_pos - prev_run_len && rlpos) {\n\t\t\t\tntfs_debug(\"Coalescing to run (lcn 0x%llx, \"\n\t\t\t\t\t\t\"len 0x%llx).\",\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\trl[rlpos - 1].lcn,\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\trl[rlpos - 1].length);\n\t\t\t\trl[rlpos - 1].length = ++prev_run_len;\n\t\t\t\tntfs_debug(\"Run now (lcn 0x%llx, len 0x%llx), \"\n\t\t\t\t\t\t\"prev_run_len 0x%llx.\",\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\trl[rlpos - 1].lcn,\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\trl[rlpos - 1].length,\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\tprev_run_len);\n\t\t\t} else {\n\t\t\t\tif (likely(rlpos)) {\n\t\t\t\t\tntfs_debug(\"Adding new run, (previous \"\n\t\t\t\t\t\t\t\"run lcn 0x%llx, \"\n\t\t\t\t\t\t\t\"len 0x%llx).\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\trl[rlpos - 1].lcn,\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\trl[rlpos - 1].length);\n\t\t\t\t\trl[rlpos].vcn = rl[rlpos - 1].vcn +\n\t\t\t\t\t\t\tprev_run_len;\n\t\t\t\t} else {\n\t\t\t\t\tntfs_debug(\"Adding new run, is first \"\n\t\t\t\t\t\t\t\"run.\");\n\t\t\t\t\trl[rlpos].vcn = start_vcn;\n\t\t\t\t}\n\t\t\t\trl[rlpos].lcn = prev_lcn = lcn + bmp_pos;\n\t\t\t\trl[rlpos].length = prev_run_len = 1;\n\t\t\t\trlpos++;\n\t\t\t}\n\t\t\t/* Done? */\n\t\t\tif (!--clusters) {\n\t\t\t\tLCN tc;\n\t\t\t\t/*\n\t\t\t\t * Update the current zone position.  Positions\n\t\t\t\t * of already scanned zones have been updated\n\t\t\t\t * during the respective zone switches.\n\t\t\t\t */\n\t\t\t\ttc = lcn + bmp_pos + 1;\n\t\t\t\tntfs_debug(\"Done. Updating current zone \"\n\t\t\t\t\t\t\"position, tc 0x%llx, \"\n\t\t\t\t\t\t\"search_zone %i.\",\n\t\t\t\t\t\t(unsigned long long)tc,\n\t\t\t\t\t\tsearch_zone);\n\t\t\t\tswitch (search_zone) {\n\t\t\t\tcase 1:\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->mft_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->mft_zone_pos);\n\t\t\t\t\tif (tc >= vol->mft_zone_end) {\n\t\t\t\t\t\tvol->mft_zone_pos =\n\t\t\t\t\t\t\t\tvol->mft_lcn;\n\t\t\t\t\t\tif (!vol->mft_zone_end)\n\t\t\t\t\t\t\tvol->mft_zone_pos = 0;\n\t\t\t\t\t} else if ((bmp_initial_pos >=\n\t\t\t\t\t\t\tvol->mft_zone_pos ||\n\t\t\t\t\t\t\ttc > vol->mft_zone_pos)\n\t\t\t\t\t\t\t&& tc >= vol->mft_lcn)\n\t\t\t\t\t\tvol->mft_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->mft_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->mft_zone_pos);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->data1_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data1_zone_pos);\n\t\t\t\t\tif (tc >= vol->nr_clusters)\n\t\t\t\t\t\tvol->data1_zone_pos =\n\t\t\t\t\t\t\t     vol->mft_zone_end;\n\t\t\t\t\telse if ((bmp_initial_pos >=\n\t\t\t\t\t\t    vol->data1_zone_pos ||\n\t\t\t\t\t\t    tc > vol->data1_zone_pos)\n\t\t\t\t\t\t    && tc >= vol->mft_zone_end)\n\t\t\t\t\t\tvol->data1_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->data1_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data1_zone_pos);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->data2_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data2_zone_pos);\n\t\t\t\t\tif (tc >= vol->mft_zone_start)\n\t\t\t\t\t\tvol->data2_zone_pos = 0;\n\t\t\t\t\telse if (bmp_initial_pos >=\n\t\t\t\t\t\t      vol->data2_zone_pos ||\n\t\t\t\t\t\t      tc > vol->data2_zone_pos)\n\t\t\t\t\t\tvol->data2_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->data2_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data2_zone_pos);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tBUG();\n\t\t\t\t}\n\t\t\t\tntfs_debug(\"Finished.  Going to out.\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tlcn++;\n\t\t}\n\t\tbmp_pos += buf_size;\n\t\tntfs_debug(\"After inner while loop: buf_size 0x%x, lcn \"\n\t\t\t\t\"0x%llx, bmp_pos 0x%llx, need_writeback %i.\",\n\t\t\t\tbuf_size, (unsigned long long)lcn,\n\t\t\t\t(unsigned long long)bmp_pos, need_writeback);\n\t\tif (bmp_pos < zone_end) {\n\t\t\tntfs_debug(\"Continuing outer while loop, \"\n\t\t\t\t\t\"bmp_pos 0x%llx, zone_end 0x%llx.\",\n\t\t\t\t\t(unsigned long long)bmp_pos,\n\t\t\t\t\t(unsigned long long)zone_end);\n\t\t\tcontinue;\n\t\t}\nzone_pass_done:\t/* Finished with the current zone pass. */\n\t\tntfs_debug(\"At zone_pass_done, pass %i.\", pass);\n\t\tif (pass == 1) {\n\t\t\t/*\n\t\t\t * Now do pass 2, scanning the first part of the zone\n\t\t\t * we omitted in pass 1.\n\t\t\t */\n\t\t\tpass = 2;\n\t\t\tzone_end = zone_start;\n\t\t\tswitch (search_zone) {\n\t\t\tcase 1: /* mft_zone */\n\t\t\t\tzone_start = vol->mft_zone_start;\n\t\t\t\tbreak;\n\t\t\tcase 2: /* data1_zone */\n\t\t\t\tzone_start = vol->mft_zone_end;\n\t\t\t\tbreak;\n\t\t\tcase 4: /* data2_zone */\n\t\t\t\tzone_start = 0;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\t}\n\t\t\t/* Sanity check. */\n\t\t\tif (zone_end < zone_start)\n\t\t\t\tzone_end = zone_start;\n\t\t\tbmp_pos = zone_start;\n\t\t\tntfs_debug(\"Continuing outer while loop, pass 2, \"\n\t\t\t\t\t\"zone_start 0x%llx, zone_end 0x%llx, \"\n\t\t\t\t\t\"bmp_pos 0x%llx.\",\n\t\t\t\t\t(unsigned long long)zone_start,\n\t\t\t\t\t(unsigned long long)zone_end,\n\t\t\t\t\t(unsigned long long)bmp_pos);\n\t\t\tcontinue;\n\t\t} /* pass == 2 */\ndone_zones_check:\n\t\tntfs_debug(\"At done_zones_check, search_zone %i, done_zones \"\n\t\t\t\t\"before 0x%x, done_zones after 0x%x.\",\n\t\t\t\tsearch_zone, done_zones,\n\t\t\t\tdone_zones | search_zone);\n\t\tdone_zones |= search_zone;\n\t\tif (done_zones < 7) {\n\t\t\tntfs_debug(\"Switching zone.\");\n\t\t\t/* Now switch to the next zone we haven't done yet. */\n\t\t\tpass = 1;\n\t\t\tswitch (search_zone) {\n\t\t\tcase 1:\n\t\t\t\tntfs_debug(\"Switching from mft zone to data1 \"\n\t\t\t\t\t\t\"zone.\");\n\t\t\t\t/* Update mft zone position. */\n\t\t\t\tif (rlpos) {\n\t\t\t\t\tLCN tc;\n\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->mft_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->mft_zone_pos);\n\t\t\t\t\ttc = rl[rlpos - 1].lcn +\n\t\t\t\t\t\t\trl[rlpos - 1].length;\n\t\t\t\t\tif (tc >= vol->mft_zone_end) {\n\t\t\t\t\t\tvol->mft_zone_pos =\n\t\t\t\t\t\t\t\tvol->mft_lcn;\n\t\t\t\t\t\tif (!vol->mft_zone_end)\n\t\t\t\t\t\t\tvol->mft_zone_pos = 0;\n\t\t\t\t\t} else if ((bmp_initial_pos >=\n\t\t\t\t\t\t\tvol->mft_zone_pos ||\n\t\t\t\t\t\t\ttc > vol->mft_zone_pos)\n\t\t\t\t\t\t\t&& tc >= vol->mft_lcn)\n\t\t\t\t\t\tvol->mft_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->mft_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->mft_zone_pos);\n\t\t\t\t}\n\t\t\t\t/* Switch from mft zone to data1 zone. */\nswitch_to_data1_zone:\t\tsearch_zone = 2;\n\t\t\t\tzone_start = bmp_initial_pos =\n\t\t\t\t\t\tvol->data1_zone_pos;\n\t\t\t\tzone_end = vol->nr_clusters;\n\t\t\t\tif (zone_start == vol->mft_zone_end)\n\t\t\t\t\tpass = 2;\n\t\t\t\tif (zone_start >= zone_end) {\n\t\t\t\t\tvol->data1_zone_pos = zone_start =\n\t\t\t\t\t\t\tvol->mft_zone_end;\n\t\t\t\t\tpass = 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tntfs_debug(\"Switching from data1 zone to \"\n\t\t\t\t\t\t\"data2 zone.\");\n\t\t\t\t/* Update data1 zone position. */\n\t\t\t\tif (rlpos) {\n\t\t\t\t\tLCN tc;\n\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->data1_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data1_zone_pos);\n\t\t\t\t\ttc = rl[rlpos - 1].lcn +\n\t\t\t\t\t\t\trl[rlpos - 1].length;\n\t\t\t\t\tif (tc >= vol->nr_clusters)\n\t\t\t\t\t\tvol->data1_zone_pos =\n\t\t\t\t\t\t\t     vol->mft_zone_end;\n\t\t\t\t\telse if ((bmp_initial_pos >=\n\t\t\t\t\t\t    vol->data1_zone_pos ||\n\t\t\t\t\t\t    tc > vol->data1_zone_pos)\n\t\t\t\t\t\t    && tc >= vol->mft_zone_end)\n\t\t\t\t\t\tvol->data1_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->data1_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data1_zone_pos);\n\t\t\t\t}\n\t\t\t\t/* Switch from data1 zone to data2 zone. */\n\t\t\t\tsearch_zone = 4;\n\t\t\t\tzone_start = bmp_initial_pos =\n\t\t\t\t\t\tvol->data2_zone_pos;\n\t\t\t\tzone_end = vol->mft_zone_start;\n\t\t\t\tif (!zone_start)\n\t\t\t\t\tpass = 2;\n\t\t\t\tif (zone_start >= zone_end) {\n\t\t\t\t\tvol->data2_zone_pos = zone_start =\n\t\t\t\t\t\t\tbmp_initial_pos = 0;\n\t\t\t\t\tpass = 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tntfs_debug(\"Switching from data2 zone to \"\n\t\t\t\t\t\t\"data1 zone.\");\n\t\t\t\t/* Update data2 zone position. */\n\t\t\t\tif (rlpos) {\n\t\t\t\t\tLCN tc;\n\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->data2_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data2_zone_pos);\n\t\t\t\t\ttc = rl[rlpos - 1].lcn +\n\t\t\t\t\t\t\trl[rlpos - 1].length;\n\t\t\t\t\tif (tc >= vol->mft_zone_start)\n\t\t\t\t\t\tvol->data2_zone_pos = 0;\n\t\t\t\t\telse if (bmp_initial_pos >=\n\t\t\t\t\t\t      vol->data2_zone_pos ||\n\t\t\t\t\t\t      tc > vol->data2_zone_pos)\n\t\t\t\t\t\tvol->data2_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->data2_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data2_zone_pos);\n\t\t\t\t}\n\t\t\t\t/* Switch from data2 zone to data1 zone. */\n\t\t\t\tgoto switch_to_data1_zone;\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\t}\n\t\t\tntfs_debug(\"After zone switch, search_zone %i, \"\n\t\t\t\t\t\"pass %i, bmp_initial_pos 0x%llx, \"\n\t\t\t\t\t\"zone_start 0x%llx, zone_end 0x%llx.\",\n\t\t\t\t\tsearch_zone, pass,\n\t\t\t\t\t(unsigned long long)bmp_initial_pos,\n\t\t\t\t\t(unsigned long long)zone_start,\n\t\t\t\t\t(unsigned long long)zone_end);\n\t\t\tbmp_pos = zone_start;\n\t\t\tif (zone_start == zone_end) {\n\t\t\t\tntfs_debug(\"Empty zone, going to \"\n\t\t\t\t\t\t\"done_zones_check.\");\n\t\t\t\t/* Empty zone. Don't bother searching it. */\n\t\t\t\tgoto done_zones_check;\n\t\t\t}\n\t\t\tntfs_debug(\"Continuing outer while loop.\");\n\t\t\tcontinue;\n\t\t} /* done_zones == 7 */\n\t\tntfs_debug(\"All zones are finished.\");\n\t\t/*\n\t\t * All zones are finished!  If DATA_ZONE, shrink mft zone.  If\n\t\t * MFT_ZONE, we have really run out of space.\n\t\t */\n\t\tmft_zone_size = vol->mft_zone_end - vol->mft_zone_start;\n\t\tntfs_debug(\"vol->mft_zone_start 0x%llx, vol->mft_zone_end \"\n\t\t\t\t\"0x%llx, mft_zone_size 0x%llx.\",\n\t\t\t\t(unsigned long long)vol->mft_zone_start,\n\t\t\t\t(unsigned long long)vol->mft_zone_end,\n\t\t\t\t(unsigned long long)mft_zone_size);\n\t\tif (zone == MFT_ZONE || mft_zone_size <= 0) {\n\t\t\tntfs_debug(\"No free clusters left, going to out.\");\n\t\t\t/* Really no more space left on device. */\n\t\t\terr = -ENOSPC;\n\t\t\tgoto out;\n\t\t} /* zone == DATA_ZONE && mft_zone_size > 0 */\n\t\tntfs_debug(\"Shrinking mft zone.\");\n\t\tzone_end = vol->mft_zone_end;\n\t\tmft_zone_size >>= 1;\n\t\tif (mft_zone_size > 0)\n\t\t\tvol->mft_zone_end = vol->mft_zone_start + mft_zone_size;\n\t\telse /* mft zone and data2 zone no longer exist. */\n\t\t\tvol->data2_zone_pos = vol->mft_zone_start =\n\t\t\t\t\tvol->mft_zone_end = 0;\n\t\tif (vol->mft_zone_pos >= vol->mft_zone_end) {\n\t\t\tvol->mft_zone_pos = vol->mft_lcn;\n\t\t\tif (!vol->mft_zone_end)\n\t\t\t\tvol->mft_zone_pos = 0;\n\t\t}\n\t\tbmp_pos = zone_start = bmp_initial_pos =\n\t\t\t\tvol->data1_zone_pos = vol->mft_zone_end;\n\t\tsearch_zone = 2;\n\t\tpass = 2;\n\t\tdone_zones &= ~2;\n\t\tntfs_debug(\"After shrinking mft zone, mft_zone_size 0x%llx, \"\n\t\t\t\t\"vol->mft_zone_start 0x%llx, \"\n\t\t\t\t\"vol->mft_zone_end 0x%llx, \"\n\t\t\t\t\"vol->mft_zone_pos 0x%llx, search_zone 2, \"\n\t\t\t\t\"pass 2, dones_zones 0x%x, zone_start 0x%llx, \"\n\t\t\t\t\"zone_end 0x%llx, vol->data1_zone_pos 0x%llx, \"\n\t\t\t\t\"continuing outer while loop.\",\n\t\t\t\t(unsigned long long)mft_zone_size,\n\t\t\t\t(unsigned long long)vol->mft_zone_start,\n\t\t\t\t(unsigned long long)vol->mft_zone_end,\n\t\t\t\t(unsigned long long)vol->mft_zone_pos,\n\t\t\t\tdone_zones, (unsigned long long)zone_start,\n\t\t\t\t(unsigned long long)zone_end,\n\t\t\t\t(unsigned long long)vol->data1_zone_pos);\n\t}\n\tntfs_debug(\"After outer while loop.\");\nout:\n\tntfs_debug(\"At out.\");\n\t/* Add runlist terminator element. */\n\tif (likely(rl)) {\n\t\trl[rlpos].vcn = rl[rlpos - 1].vcn + rl[rlpos - 1].length;\n\t\trl[rlpos].lcn = is_extension ? LCN_ENOENT : LCN_RL_NOT_MAPPED;\n\t\trl[rlpos].length = 0;\n\t}\n\tif (likely(page && !IS_ERR(page))) {\n\t\tif (need_writeback) {\n\t\t\tntfs_debug(\"Marking page dirty.\");\n\t\t\tflush_dcache_page(page);\n\t\t\tset_page_dirty(page);\n\t\t\tneed_writeback = 0;\n\t\t}\n\t\tntfs_unmap_page(page);\n\t}\n\tif (likely(!err)) {\n\t\tup_write(&vol->lcnbmp_lock);\n\t\tntfs_debug(\"Done.\");\n\t\treturn rl;\n\t}\n\tntfs_error(vol->sb, \"Failed to allocate clusters, aborting \"\n\t\t\t\"(error %i).\", err);\n\tif (rl) {\n\t\tint err2;\n\n\t\tif (err == -ENOSPC)\n\t\t\tntfs_debug(\"Not enough space to complete allocation, \"\n\t\t\t\t\t\"err -ENOSPC, first free lcn 0x%llx, \"\n\t\t\t\t\t\"could allocate up to 0x%llx \"\n\t\t\t\t\t\"clusters.\",\n\t\t\t\t\t(unsigned long long)rl[0].lcn,\n\t\t\t\t\t(unsigned long long)(count - clusters));\n\t\t/* Deallocate all allocated clusters. */\n\t\tntfs_debug(\"Attempting rollback...\");\n\t\terr2 = ntfs_cluster_free_from_rl_nolock(vol, rl);\n\t\tif (err2) {\n\t\t\tntfs_error(vol->sb, \"Failed to rollback (error %i).  \"\n\t\t\t\t\t\"Leaving inconsistent metadata!  \"\n\t\t\t\t\t\"Unmount and run chkdsk.\", err2);\n\t\t\tNVolSetErrors(vol);\n\t\t}\n\t\t/* Free the runlist. */\n\t\tntfs_free(rl);\n\t} else if (err == -ENOSPC)\n\t\tntfs_debug(\"No space left at all, err = -ENOSPC, first free \"\n\t\t\t\t\"lcn = 0x%llx.\",\n\t\t\t\t(long long)vol->data1_zone_pos);\n\tup_write(&vol->lcnbmp_lock);\n\treturn ERR_PTR(err);\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"aops.h\"",
      "#include \"malloc.h\"",
      "#include \"attrib.h\"",
      "#include \"volume.h\"",
      "#include \"inode.h\"",
      "#include \"bitmap.h\"",
      "#include \"debug.h\"",
      "#include \"lcnalloc.h\"",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&vol->lcnbmp_lock"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"No space left at all, err = -ENOSPC, first free \"\n\t\t\t\t\"lcn = 0x%llx.\"",
            "(long long)vol->data1_zone_pos"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_free",
          "args": [
            "rl"
          ],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/malloc.h",
          "lines": "86-94",
          "snippet": "static inline void ntfs_free(void *addr)\n{\n\tif (!is_vmalloc_addr(addr)) {\n\t\tkfree(addr);\n\t\t/* free_page((unsigned long)addr); */\n\t\treturn;\n\t}\n\tvfree(addr);\n}",
          "includes": [
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n\nstatic inline void ntfs_free(void *addr)\n{\n\tif (!is_vmalloc_addr(addr)) {\n\t\tkfree(addr);\n\t\t/* free_page((unsigned long)addr); */\n\t\treturn;\n\t}\n\tvfree(addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "NVolSetErrors",
          "args": [
            "vol"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to rollback (error %i).  \"\n\t\t\t\t\t\"Leaving inconsistent metadata!  \"\n\t\t\t\t\t\"Unmount and run chkdsk.\"",
            "err2"
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "86-108",
          "snippet": "void __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_error(const char *function, const struct super_block *sb,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n#ifndef DEBUG\n\tif (!printk_ratelimit())\n\t\treturn;\n#endif\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tif (sb)\n\t\tpr_err(\"(device %s): %s(): %pV\\n\",\n\t\t       sb->s_id, flen ? function : \"\", &vaf);\n\telse\n\t\tpr_err(\"%s(): %pV\\n\", flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_cluster_free_from_rl_nolock",
          "args": [
            "vol",
            "rl"
          ],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_cluster_free_from_rl_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/lcnalloc.c",
          "lines": "50-70",
          "snippet": "int ntfs_cluster_free_from_rl_nolock(ntfs_volume *vol,\n\t\tconst runlist_element *rl)\n{\n\tstruct inode *lcnbmp_vi = vol->lcnbmp_ino;\n\tint ret = 0;\n\n\tntfs_debug(\"Entering.\");\n\tif (!rl)\n\t\treturn 0;\n\tfor (; rl->length; rl++) {\n\t\tint err;\n\n\t\tif (rl->lcn < 0)\n\t\t\tcontinue;\n\t\terr = ntfs_bitmap_clear_run(lcnbmp_vi, rl->lcn, rl->length);\n\t\tif (unlikely(err && (!ret || ret == -ENOMEM) && ret != err))\n\t\t\tret = err;\n\t}\n\tntfs_debug(\"Done.\");\n\treturn ret;\n}",
          "includes": [
            "#include \"ntfs.h\"",
            "#include \"aops.h\"",
            "#include \"malloc.h\"",
            "#include \"attrib.h\"",
            "#include \"volume.h\"",
            "#include \"inode.h\"",
            "#include \"bitmap.h\"",
            "#include \"debug.h\"",
            "#include \"lcnalloc.h\"",
            "#include <linux/pagemap.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ntfs.h\"\n#include \"aops.h\"\n#include \"malloc.h\"\n#include \"attrib.h\"\n#include \"volume.h\"\n#include \"inode.h\"\n#include \"bitmap.h\"\n#include \"debug.h\"\n#include \"lcnalloc.h\"\n#include <linux/pagemap.h>\n\nint ntfs_cluster_free_from_rl_nolock(ntfs_volume *vol,\n\t\tconst runlist_element *rl)\n{\n\tstruct inode *lcnbmp_vi = vol->lcnbmp_ino;\n\tint ret = 0;\n\n\tntfs_debug(\"Entering.\");\n\tif (!rl)\n\t\treturn 0;\n\tfor (; rl->length; rl++) {\n\t\tint err;\n\n\t\tif (rl->lcn < 0)\n\t\t\tcontinue;\n\t\terr = ntfs_bitmap_clear_run(lcnbmp_vi, rl->lcn, rl->length);\n\t\tif (unlikely(err && (!ret || ret == -ENOMEM) && ret != err))\n\t\t\tret = err;\n\t}\n\tntfs_debug(\"Done.\");\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Attempting rollback...\""
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Not enough space to complete allocation, \"\n\t\t\t\t\t\"err -ENOSPC, first free lcn 0x%llx, \"\n\t\t\t\t\t\"could allocate up to 0x%llx \"\n\t\t\t\t\t\"clusters.\"",
            "(unsigned long long)rl[0].lcn",
            "(unsigned long long)(count - clusters)"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&vol->lcnbmp_lock"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!err"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_unmap_page",
          "args": [
            "page"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_unmap_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/aops.h",
          "lines": "40-44",
          "snippet": "static inline void ntfs_unmap_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"inode.h\"",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode.h\"\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline void ntfs_unmap_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "page"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "anon_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "1040-1043",
          "snippet": "static int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_dcache_page",
          "args": [
            "page"
          ],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_index_entry_flush_dcache_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/index.h",
          "lines": "111-117",
          "snippet": "static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}",
          "includes": [
            "#include \"aops.h\"",
            "#include \"mft.h\"",
            "#include \"attrib.h\"",
            "#include \"inode.h\"",
            "#include \"layout.h\"",
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"aops.h\"\n#include \"mft.h\"\n#include \"attrib.h\"\n#include \"inode.h\"\n#include \"layout.h\"\n#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)\n{\n\tif (ictx->is_in_root)\n\t\tflush_dcache_mft_record_page(ictx->actx->ntfs_ino);\n\telse\n\t\tflush_dcache_page(ictx->page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "page && !IS_ERR(page)"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "rl"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"After shrinking mft zone, mft_zone_size 0x%llx, \"\n\t\t\t\t\"vol->mft_zone_start 0x%llx, \"\n\t\t\t\t\"vol->mft_zone_end 0x%llx, \"\n\t\t\t\t\"vol->mft_zone_pos 0x%llx, search_zone 2, \"\n\t\t\t\t\"pass 2, dones_zones 0x%x, zone_start 0x%llx, \"\n\t\t\t\t\"zone_end 0x%llx, vol->data1_zone_pos 0x%llx, \"\n\t\t\t\t\"continuing outer while loop.\"",
            "(unsigned long long)mft_zone_size",
            "(unsigned long long)vol->mft_zone_start",
            "(unsigned long long)vol->mft_zone_end",
            "(unsigned long long)vol->mft_zone_pos",
            "done_zones",
            "(unsigned long long)zone_start",
            "(unsigned long long)zone_end",
            "(unsigned long long)vol->data1_zone_pos"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "__ntfs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "115-131",
          "snippet": "void __ntfs_debug(const char *file, int line, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n\tif (!debug_msgs)\n\t\treturn;\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s, %d): %s(): %pV\", file, line, flen ? function : \"\", &vaf);\n\tva_end(args);\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid __ntfs_debug(const char *file, int line, const char *function,\n\t\tconst char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\tint flen = 0;\n\n\tif (!debug_msgs)\n\t\treturn;\n\tif (function)\n\t\tflen = strlen(function);\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s, %d): %s(): %pV\", file, line, flen ? function : \"\", &vaf);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"After checks, \"\n\t\t\t\t\t\t\t\"vol->data2_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\"",
            "(unsigned long long)\n\t\t\t\t\t\t\tvol->data2_zone_pos"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->data2_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\"",
            "(unsigned long long)\n\t\t\t\t\t\t\tvol->data2_zone_pos"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"After checks, \"\n\t\t\t\t\t\t\t\"vol->data1_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\"",
            "(unsigned long long)\n\t\t\t\t\t\t\tvol->data1_zone_pos"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->data1_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\"",
            "(unsigned long long)\n\t\t\t\t\t\t\tvol->data1_zone_pos"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"After checks, \"\n\t\t\t\t\t\t\t\"vol->mft_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\"",
            "(unsigned long long)\n\t\t\t\t\t\t\tvol->mft_zone_pos"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->mft_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\"",
            "(unsigned long long)\n\t\t\t\t\t\t\tvol->mft_zone_pos"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"At zone_pass_done, pass %i.\"",
            "pass"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Continuing outer while loop, \"\n\t\t\t\t\t\"bmp_pos 0x%llx, zone_end 0x%llx.\"",
            "(unsigned long long)bmp_pos",
            "(unsigned long long)zone_end"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"After checks, \"\n\t\t\t\t\t\t\t\"vol->data2_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\"",
            "(unsigned long long)\n\t\t\t\t\t\t\tvol->data2_zone_pos"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->data2_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\"",
            "(unsigned long long)\n\t\t\t\t\t\t\tvol->data2_zone_pos"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"After checks, \"\n\t\t\t\t\t\t\t\"vol->data1_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\"",
            "(unsigned long long)\n\t\t\t\t\t\t\tvol->data1_zone_pos"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->data1_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\"",
            "(unsigned long long)\n\t\t\t\t\t\t\tvol->data1_zone_pos"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"After checks, \"\n\t\t\t\t\t\t\t\"vol->mft_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\"",
            "(unsigned long long)\n\t\t\t\t\t\t\tvol->mft_zone_pos"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->mft_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\"",
            "(unsigned long long)\n\t\t\t\t\t\t\tvol->mft_zone_pos"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Done. Updating current zone \"\n\t\t\t\t\t\t\"position, tc 0x%llx, \"\n\t\t\t\t\t\t\"search_zone %i.\"",
            "(unsigned long long)tc",
            "search_zone"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Adding new run, (previous \"\n\t\t\t\t\t\t\t\"run lcn 0x%llx, \"\n\t\t\t\t\t\t\t\"len 0x%llx).\"",
            "(unsigned long long)\n\t\t\t\t\t\t\trl[rlpos - 1].lcn",
            "(unsigned long long)\n\t\t\t\t\t\t\trl[rlpos - 1].length"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "rlpos"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Coalescing to run (lcn 0x%llx, \"\n\t\t\t\t\t\t\"len 0x%llx).\"",
            "(unsigned long long)\n\t\t\t\t\t\trl[rlpos - 1].lcn",
            "(unsigned long long)\n\t\t\t\t\t\trl[rlpos - 1].length"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"*byte 0x%x, need_writeback is set.\"",
            "(unsigned int)*byte"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Reallocated memory, rlsize 0x%x.\"",
            "rlsize"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "rl2",
            "rl",
            "rlsize"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to \"\n\t\t\t\t\t\t\t\"allocate memory.\""
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!rl2"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_malloc_nofs",
          "args": [
            "rlsize + (int)PAGE_SIZE"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_malloc_nofs_nofail",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/malloc.h",
          "lines": "81-84",
          "snippet": "static inline void *ntfs_malloc_nofs_nofail(unsigned long size)\n{\n\treturn __ntfs_malloc(size, GFP_NOFS | __GFP_HIGHMEM | __GFP_NOFAIL);\n}",
          "includes": [
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/vmalloc.h>\n\nstatic inline void *ntfs_malloc_nofs_nofail(unsigned long size)\n{\n\treturn __ntfs_malloc(size, GFP_NOFS | __GFP_HIGHMEM | __GFP_NOFAIL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"First free bit is at LCN \"\n\t\t\t\t\t\t\t\"0x%llx.\"",
            "(unsigned long long)\n\t\t\t\t\t\t\t(lcn + bmp_pos)"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"bit 0x%x.\"",
            "bit"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "last_read_pos + buf_size > i_size"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_error",
          "args": [
            "vol->sb",
            "\"Failed to map page.\""
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "page"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_map_page",
          "args": [
            "mapping",
            "last_read_pos >>\n\t\t\t\tPAGE_CACHE_SHIFT"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_map_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/aops.h",
          "lines": "86-99",
          "snippet": "static inline struct page *ntfs_map_page(struct address_space *mapping,\n\t\tunsigned long index)\n{\n\tstruct page *page = read_mapping_page(mapping, index, NULL);\n\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (!PageError(page))\n\t\t\treturn page;\n\t\tntfs_unmap_page(page);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}",
          "includes": [
            "#include \"inode.h\"",
            "#include <linux/fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"inode.h\"\n#include <linux/fs.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n\nstatic inline struct page *ntfs_map_page(struct address_space *mapping,\n\t\tunsigned long index)\n{\n\tstruct page *page = read_mapping_page(mapping, index, NULL);\n\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (!PageError(page))\n\t\t\treturn page;\n\t\tntfs_unmap_page(page);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\treturn page;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "page"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"last_read_pos 0x%llx.\"",
            "(unsigned long long)last_read_pos"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "lcnbmp_vi"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&vol->lcnbmp_lock"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "zone > LAST_ZONE"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "zone < FIRST_ZONE"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "start_lcn < -1"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "count < 0"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "start_vcn < 0"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!lcnbmp_vi"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!vol"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"aops.h\"\n#include \"malloc.h\"\n#include \"attrib.h\"\n#include \"volume.h\"\n#include \"inode.h\"\n#include \"bitmap.h\"\n#include \"debug.h\"\n#include \"lcnalloc.h\"\n#include <linux/pagemap.h>\n\nrunlist_element *ntfs_cluster_alloc(ntfs_volume *vol, const VCN start_vcn,\n\t\tconst s64 count, const LCN start_lcn,\n\t\tconst NTFS_CLUSTER_ALLOCATION_ZONES zone,\n\t\tconst bool is_extension)\n{\n\tLCN zone_start, zone_end, bmp_pos, bmp_initial_pos, last_read_pos, lcn;\n\tLCN prev_lcn = 0, prev_run_len = 0, mft_zone_size;\n\ts64 clusters;\n\tloff_t i_size;\n\tstruct inode *lcnbmp_vi;\n\trunlist_element *rl = NULL;\n\tstruct address_space *mapping;\n\tstruct page *page = NULL;\n\tu8 *buf, *byte;\n\tint err = 0, rlpos, rlsize, buf_size;\n\tu8 pass, done_zones, search_zone, need_writeback = 0, bit;\n\n\tntfs_debug(\"Entering for start_vcn 0x%llx, count 0x%llx, start_lcn \"\n\t\t\t\"0x%llx, zone %s_ZONE.\", (unsigned long long)start_vcn,\n\t\t\t(unsigned long long)count,\n\t\t\t(unsigned long long)start_lcn,\n\t\t\tzone == MFT_ZONE ? \"MFT\" : \"DATA\");\n\tBUG_ON(!vol);\n\tlcnbmp_vi = vol->lcnbmp_ino;\n\tBUG_ON(!lcnbmp_vi);\n\tBUG_ON(start_vcn < 0);\n\tBUG_ON(count < 0);\n\tBUG_ON(start_lcn < -1);\n\tBUG_ON(zone < FIRST_ZONE);\n\tBUG_ON(zone > LAST_ZONE);\n\n\t/* Return NULL if @count is zero. */\n\tif (!count)\n\t\treturn NULL;\n\t/* Take the lcnbmp lock for writing. */\n\tdown_write(&vol->lcnbmp_lock);\n\t/*\n\t * If no specific @start_lcn was requested, use the current data zone\n\t * position, otherwise use the requested @start_lcn but make sure it\n\t * lies outside the mft zone.  Also set done_zones to 0 (no zones done)\n\t * and pass depending on whether we are starting inside a zone (1) or\n\t * at the beginning of a zone (2).  If requesting from the MFT_ZONE,\n\t * we either start at the current position within the mft zone or at\n\t * the specified position.  If the latter is out of bounds then we start\n\t * at the beginning of the MFT_ZONE.\n\t */\n\tdone_zones = 0;\n\tpass = 1;\n\t/*\n\t * zone_start and zone_end are the current search range.  search_zone\n\t * is 1 for mft zone, 2 for data zone 1 (end of mft zone till end of\n\t * volume) and 4 for data zone 2 (start of volume till start of mft\n\t * zone).\n\t */\n\tzone_start = start_lcn;\n\tif (zone_start < 0) {\n\t\tif (zone == DATA_ZONE)\n\t\t\tzone_start = vol->data1_zone_pos;\n\t\telse\n\t\t\tzone_start = vol->mft_zone_pos;\n\t\tif (!zone_start) {\n\t\t\t/*\n\t\t\t * Zone starts at beginning of volume which means a\n\t\t\t * single pass is sufficient.\n\t\t\t */\n\t\t\tpass = 2;\n\t\t}\n\t} else if (zone == DATA_ZONE && zone_start >= vol->mft_zone_start &&\n\t\t\tzone_start < vol->mft_zone_end) {\n\t\tzone_start = vol->mft_zone_end;\n\t\t/*\n\t\t * Starting at beginning of data1_zone which means a single\n\t\t * pass in this zone is sufficient.\n\t\t */\n\t\tpass = 2;\n\t} else if (zone == MFT_ZONE && (zone_start < vol->mft_zone_start ||\n\t\t\tzone_start >= vol->mft_zone_end)) {\n\t\tzone_start = vol->mft_lcn;\n\t\tif (!vol->mft_zone_end)\n\t\t\tzone_start = 0;\n\t\t/*\n\t\t * Starting at beginning of volume which means a single pass\n\t\t * is sufficient.\n\t\t */\n\t\tpass = 2;\n\t}\n\tif (zone == MFT_ZONE) {\n\t\tzone_end = vol->mft_zone_end;\n\t\tsearch_zone = 1;\n\t} else /* if (zone == DATA_ZONE) */ {\n\t\t/* Skip searching the mft zone. */\n\t\tdone_zones |= 1;\n\t\tif (zone_start >= vol->mft_zone_end) {\n\t\t\tzone_end = vol->nr_clusters;\n\t\t\tsearch_zone = 2;\n\t\t} else {\n\t\t\tzone_end = vol->mft_zone_start;\n\t\t\tsearch_zone = 4;\n\t\t}\n\t}\n\t/*\n\t * bmp_pos is the current bit position inside the bitmap.  We use\n\t * bmp_initial_pos to determine whether or not to do a zone switch.\n\t */\n\tbmp_pos = bmp_initial_pos = zone_start;\n\n\t/* Loop until all clusters are allocated, i.e. clusters == 0. */\n\tclusters = count;\n\trlpos = rlsize = 0;\n\tmapping = lcnbmp_vi->i_mapping;\n\ti_size = i_size_read(lcnbmp_vi);\n\twhile (1) {\n\t\tntfs_debug(\"Start of outer while loop: done_zones 0x%x, \"\n\t\t\t\t\"search_zone %i, pass %i, zone_start 0x%llx, \"\n\t\t\t\t\"zone_end 0x%llx, bmp_initial_pos 0x%llx, \"\n\t\t\t\t\"bmp_pos 0x%llx, rlpos %i, rlsize %i.\",\n\t\t\t\tdone_zones, search_zone, pass,\n\t\t\t\t(unsigned long long)zone_start,\n\t\t\t\t(unsigned long long)zone_end,\n\t\t\t\t(unsigned long long)bmp_initial_pos,\n\t\t\t\t(unsigned long long)bmp_pos, rlpos, rlsize);\n\t\t/* Loop until we run out of free clusters. */\n\t\tlast_read_pos = bmp_pos >> 3;\n\t\tntfs_debug(\"last_read_pos 0x%llx.\",\n\t\t\t\t(unsigned long long)last_read_pos);\n\t\tif (last_read_pos > i_size) {\n\t\t\tntfs_debug(\"End of attribute reached.  \"\n\t\t\t\t\t\"Skipping to zone_pass_done.\");\n\t\t\tgoto zone_pass_done;\n\t\t}\n\t\tif (likely(page)) {\n\t\t\tif (need_writeback) {\n\t\t\t\tntfs_debug(\"Marking page dirty.\");\n\t\t\t\tflush_dcache_page(page);\n\t\t\t\tset_page_dirty(page);\n\t\t\t\tneed_writeback = 0;\n\t\t\t}\n\t\t\tntfs_unmap_page(page);\n\t\t}\n\t\tpage = ntfs_map_page(mapping, last_read_pos >>\n\t\t\t\tPAGE_CACHE_SHIFT);\n\t\tif (IS_ERR(page)) {\n\t\t\terr = PTR_ERR(page);\n\t\t\tntfs_error(vol->sb, \"Failed to map page.\");\n\t\t\tgoto out;\n\t\t}\n\t\tbuf_size = last_read_pos & ~PAGE_CACHE_MASK;\n\t\tbuf = page_address(page) + buf_size;\n\t\tbuf_size = PAGE_CACHE_SIZE - buf_size;\n\t\tif (unlikely(last_read_pos + buf_size > i_size))\n\t\t\tbuf_size = i_size - last_read_pos;\n\t\tbuf_size <<= 3;\n\t\tlcn = bmp_pos & 7;\n\t\tbmp_pos &= ~(LCN)7;\n\t\tntfs_debug(\"Before inner while loop: buf_size %i, lcn 0x%llx, \"\n\t\t\t\t\"bmp_pos 0x%llx, need_writeback %i.\", buf_size,\n\t\t\t\t(unsigned long long)lcn,\n\t\t\t\t(unsigned long long)bmp_pos, need_writeback);\n\t\twhile (lcn < buf_size && lcn + bmp_pos < zone_end) {\n\t\t\tbyte = buf + (lcn >> 3);\n\t\t\tntfs_debug(\"In inner while loop: buf_size %i, \"\n\t\t\t\t\t\"lcn 0x%llx, bmp_pos 0x%llx, \"\n\t\t\t\t\t\"need_writeback %i, byte ofs 0x%x, \"\n\t\t\t\t\t\"*byte 0x%x.\", buf_size,\n\t\t\t\t\t(unsigned long long)lcn,\n\t\t\t\t\t(unsigned long long)bmp_pos,\n\t\t\t\t\tneed_writeback,\n\t\t\t\t\t(unsigned int)(lcn >> 3),\n\t\t\t\t\t(unsigned int)*byte);\n\t\t\t/* Skip full bytes. */\n\t\t\tif (*byte == 0xff) {\n\t\t\t\tlcn = (lcn + 8) & ~(LCN)7;\n\t\t\t\tntfs_debug(\"Continuing while loop 1.\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbit = 1 << (lcn & 7);\n\t\t\tntfs_debug(\"bit 0x%x.\", bit);\n\t\t\t/* If the bit is already set, go onto the next one. */\n\t\t\tif (*byte & bit) {\n\t\t\t\tlcn++;\n\t\t\t\tntfs_debug(\"Continuing while loop 2.\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Allocate more memory if needed, including space for\n\t\t\t * the terminator element.\n\t\t\t * ntfs_malloc_nofs() operates on whole pages only.\n\t\t\t */\n\t\t\tif ((rlpos + 2) * sizeof(*rl) > rlsize) {\n\t\t\t\trunlist_element *rl2;\n\n\t\t\t\tntfs_debug(\"Reallocating memory.\");\n\t\t\t\tif (!rl)\n\t\t\t\t\tntfs_debug(\"First free bit is at LCN \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\t(lcn + bmp_pos));\n\t\t\t\trl2 = ntfs_malloc_nofs(rlsize + (int)PAGE_SIZE);\n\t\t\t\tif (unlikely(!rl2)) {\n\t\t\t\t\terr = -ENOMEM;\n\t\t\t\t\tntfs_error(vol->sb, \"Failed to \"\n\t\t\t\t\t\t\t\"allocate memory.\");\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tmemcpy(rl2, rl, rlsize);\n\t\t\t\tntfs_free(rl);\n\t\t\t\trl = rl2;\n\t\t\t\trlsize += PAGE_SIZE;\n\t\t\t\tntfs_debug(\"Reallocated memory, rlsize 0x%x.\",\n\t\t\t\t\t\trlsize);\n\t\t\t}\n\t\t\t/* Allocate the bitmap bit. */\n\t\t\t*byte |= bit;\n\t\t\t/* We need to write this bitmap page to disk. */\n\t\t\tneed_writeback = 1;\n\t\t\tntfs_debug(\"*byte 0x%x, need_writeback is set.\",\n\t\t\t\t\t(unsigned int)*byte);\n\t\t\t/*\n\t\t\t * Coalesce with previous run if adjacent LCNs.\n\t\t\t * Otherwise, append a new run.\n\t\t\t */\n\t\t\tntfs_debug(\"Adding run (lcn 0x%llx, len 0x%llx), \"\n\t\t\t\t\t\"prev_lcn 0x%llx, lcn 0x%llx, \"\n\t\t\t\t\t\"bmp_pos 0x%llx, prev_run_len 0x%llx, \"\n\t\t\t\t\t\"rlpos %i.\",\n\t\t\t\t\t(unsigned long long)(lcn + bmp_pos),\n\t\t\t\t\t1ULL, (unsigned long long)prev_lcn,\n\t\t\t\t\t(unsigned long long)lcn,\n\t\t\t\t\t(unsigned long long)bmp_pos,\n\t\t\t\t\t(unsigned long long)prev_run_len,\n\t\t\t\t\trlpos);\n\t\t\tif (prev_lcn == lcn + bmp_pos - prev_run_len && rlpos) {\n\t\t\t\tntfs_debug(\"Coalescing to run (lcn 0x%llx, \"\n\t\t\t\t\t\t\"len 0x%llx).\",\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\trl[rlpos - 1].lcn,\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\trl[rlpos - 1].length);\n\t\t\t\trl[rlpos - 1].length = ++prev_run_len;\n\t\t\t\tntfs_debug(\"Run now (lcn 0x%llx, len 0x%llx), \"\n\t\t\t\t\t\t\"prev_run_len 0x%llx.\",\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\trl[rlpos - 1].lcn,\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\trl[rlpos - 1].length,\n\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\tprev_run_len);\n\t\t\t} else {\n\t\t\t\tif (likely(rlpos)) {\n\t\t\t\t\tntfs_debug(\"Adding new run, (previous \"\n\t\t\t\t\t\t\t\"run lcn 0x%llx, \"\n\t\t\t\t\t\t\t\"len 0x%llx).\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\trl[rlpos - 1].lcn,\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\trl[rlpos - 1].length);\n\t\t\t\t\trl[rlpos].vcn = rl[rlpos - 1].vcn +\n\t\t\t\t\t\t\tprev_run_len;\n\t\t\t\t} else {\n\t\t\t\t\tntfs_debug(\"Adding new run, is first \"\n\t\t\t\t\t\t\t\"run.\");\n\t\t\t\t\trl[rlpos].vcn = start_vcn;\n\t\t\t\t}\n\t\t\t\trl[rlpos].lcn = prev_lcn = lcn + bmp_pos;\n\t\t\t\trl[rlpos].length = prev_run_len = 1;\n\t\t\t\trlpos++;\n\t\t\t}\n\t\t\t/* Done? */\n\t\t\tif (!--clusters) {\n\t\t\t\tLCN tc;\n\t\t\t\t/*\n\t\t\t\t * Update the current zone position.  Positions\n\t\t\t\t * of already scanned zones have been updated\n\t\t\t\t * during the respective zone switches.\n\t\t\t\t */\n\t\t\t\ttc = lcn + bmp_pos + 1;\n\t\t\t\tntfs_debug(\"Done. Updating current zone \"\n\t\t\t\t\t\t\"position, tc 0x%llx, \"\n\t\t\t\t\t\t\"search_zone %i.\",\n\t\t\t\t\t\t(unsigned long long)tc,\n\t\t\t\t\t\tsearch_zone);\n\t\t\t\tswitch (search_zone) {\n\t\t\t\tcase 1:\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->mft_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->mft_zone_pos);\n\t\t\t\t\tif (tc >= vol->mft_zone_end) {\n\t\t\t\t\t\tvol->mft_zone_pos =\n\t\t\t\t\t\t\t\tvol->mft_lcn;\n\t\t\t\t\t\tif (!vol->mft_zone_end)\n\t\t\t\t\t\t\tvol->mft_zone_pos = 0;\n\t\t\t\t\t} else if ((bmp_initial_pos >=\n\t\t\t\t\t\t\tvol->mft_zone_pos ||\n\t\t\t\t\t\t\ttc > vol->mft_zone_pos)\n\t\t\t\t\t\t\t&& tc >= vol->mft_lcn)\n\t\t\t\t\t\tvol->mft_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->mft_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->mft_zone_pos);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->data1_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data1_zone_pos);\n\t\t\t\t\tif (tc >= vol->nr_clusters)\n\t\t\t\t\t\tvol->data1_zone_pos =\n\t\t\t\t\t\t\t     vol->mft_zone_end;\n\t\t\t\t\telse if ((bmp_initial_pos >=\n\t\t\t\t\t\t    vol->data1_zone_pos ||\n\t\t\t\t\t\t    tc > vol->data1_zone_pos)\n\t\t\t\t\t\t    && tc >= vol->mft_zone_end)\n\t\t\t\t\t\tvol->data1_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->data1_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data1_zone_pos);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->data2_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data2_zone_pos);\n\t\t\t\t\tif (tc >= vol->mft_zone_start)\n\t\t\t\t\t\tvol->data2_zone_pos = 0;\n\t\t\t\t\telse if (bmp_initial_pos >=\n\t\t\t\t\t\t      vol->data2_zone_pos ||\n\t\t\t\t\t\t      tc > vol->data2_zone_pos)\n\t\t\t\t\t\tvol->data2_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->data2_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data2_zone_pos);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tBUG();\n\t\t\t\t}\n\t\t\t\tntfs_debug(\"Finished.  Going to out.\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tlcn++;\n\t\t}\n\t\tbmp_pos += buf_size;\n\t\tntfs_debug(\"After inner while loop: buf_size 0x%x, lcn \"\n\t\t\t\t\"0x%llx, bmp_pos 0x%llx, need_writeback %i.\",\n\t\t\t\tbuf_size, (unsigned long long)lcn,\n\t\t\t\t(unsigned long long)bmp_pos, need_writeback);\n\t\tif (bmp_pos < zone_end) {\n\t\t\tntfs_debug(\"Continuing outer while loop, \"\n\t\t\t\t\t\"bmp_pos 0x%llx, zone_end 0x%llx.\",\n\t\t\t\t\t(unsigned long long)bmp_pos,\n\t\t\t\t\t(unsigned long long)zone_end);\n\t\t\tcontinue;\n\t\t}\nzone_pass_done:\t/* Finished with the current zone pass. */\n\t\tntfs_debug(\"At zone_pass_done, pass %i.\", pass);\n\t\tif (pass == 1) {\n\t\t\t/*\n\t\t\t * Now do pass 2, scanning the first part of the zone\n\t\t\t * we omitted in pass 1.\n\t\t\t */\n\t\t\tpass = 2;\n\t\t\tzone_end = zone_start;\n\t\t\tswitch (search_zone) {\n\t\t\tcase 1: /* mft_zone */\n\t\t\t\tzone_start = vol->mft_zone_start;\n\t\t\t\tbreak;\n\t\t\tcase 2: /* data1_zone */\n\t\t\t\tzone_start = vol->mft_zone_end;\n\t\t\t\tbreak;\n\t\t\tcase 4: /* data2_zone */\n\t\t\t\tzone_start = 0;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\t}\n\t\t\t/* Sanity check. */\n\t\t\tif (zone_end < zone_start)\n\t\t\t\tzone_end = zone_start;\n\t\t\tbmp_pos = zone_start;\n\t\t\tntfs_debug(\"Continuing outer while loop, pass 2, \"\n\t\t\t\t\t\"zone_start 0x%llx, zone_end 0x%llx, \"\n\t\t\t\t\t\"bmp_pos 0x%llx.\",\n\t\t\t\t\t(unsigned long long)zone_start,\n\t\t\t\t\t(unsigned long long)zone_end,\n\t\t\t\t\t(unsigned long long)bmp_pos);\n\t\t\tcontinue;\n\t\t} /* pass == 2 */\ndone_zones_check:\n\t\tntfs_debug(\"At done_zones_check, search_zone %i, done_zones \"\n\t\t\t\t\"before 0x%x, done_zones after 0x%x.\",\n\t\t\t\tsearch_zone, done_zones,\n\t\t\t\tdone_zones | search_zone);\n\t\tdone_zones |= search_zone;\n\t\tif (done_zones < 7) {\n\t\t\tntfs_debug(\"Switching zone.\");\n\t\t\t/* Now switch to the next zone we haven't done yet. */\n\t\t\tpass = 1;\n\t\t\tswitch (search_zone) {\n\t\t\tcase 1:\n\t\t\t\tntfs_debug(\"Switching from mft zone to data1 \"\n\t\t\t\t\t\t\"zone.\");\n\t\t\t\t/* Update mft zone position. */\n\t\t\t\tif (rlpos) {\n\t\t\t\t\tLCN tc;\n\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->mft_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->mft_zone_pos);\n\t\t\t\t\ttc = rl[rlpos - 1].lcn +\n\t\t\t\t\t\t\trl[rlpos - 1].length;\n\t\t\t\t\tif (tc >= vol->mft_zone_end) {\n\t\t\t\t\t\tvol->mft_zone_pos =\n\t\t\t\t\t\t\t\tvol->mft_lcn;\n\t\t\t\t\t\tif (!vol->mft_zone_end)\n\t\t\t\t\t\t\tvol->mft_zone_pos = 0;\n\t\t\t\t\t} else if ((bmp_initial_pos >=\n\t\t\t\t\t\t\tvol->mft_zone_pos ||\n\t\t\t\t\t\t\ttc > vol->mft_zone_pos)\n\t\t\t\t\t\t\t&& tc >= vol->mft_lcn)\n\t\t\t\t\t\tvol->mft_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->mft_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->mft_zone_pos);\n\t\t\t\t}\n\t\t\t\t/* Switch from mft zone to data1 zone. */\nswitch_to_data1_zone:\t\tsearch_zone = 2;\n\t\t\t\tzone_start = bmp_initial_pos =\n\t\t\t\t\t\tvol->data1_zone_pos;\n\t\t\t\tzone_end = vol->nr_clusters;\n\t\t\t\tif (zone_start == vol->mft_zone_end)\n\t\t\t\t\tpass = 2;\n\t\t\t\tif (zone_start >= zone_end) {\n\t\t\t\t\tvol->data1_zone_pos = zone_start =\n\t\t\t\t\t\t\tvol->mft_zone_end;\n\t\t\t\t\tpass = 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tntfs_debug(\"Switching from data1 zone to \"\n\t\t\t\t\t\t\"data2 zone.\");\n\t\t\t\t/* Update data1 zone position. */\n\t\t\t\tif (rlpos) {\n\t\t\t\t\tLCN tc;\n\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->data1_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data1_zone_pos);\n\t\t\t\t\ttc = rl[rlpos - 1].lcn +\n\t\t\t\t\t\t\trl[rlpos - 1].length;\n\t\t\t\t\tif (tc >= vol->nr_clusters)\n\t\t\t\t\t\tvol->data1_zone_pos =\n\t\t\t\t\t\t\t     vol->mft_zone_end;\n\t\t\t\t\telse if ((bmp_initial_pos >=\n\t\t\t\t\t\t    vol->data1_zone_pos ||\n\t\t\t\t\t\t    tc > vol->data1_zone_pos)\n\t\t\t\t\t\t    && tc >= vol->mft_zone_end)\n\t\t\t\t\t\tvol->data1_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->data1_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data1_zone_pos);\n\t\t\t\t}\n\t\t\t\t/* Switch from data1 zone to data2 zone. */\n\t\t\t\tsearch_zone = 4;\n\t\t\t\tzone_start = bmp_initial_pos =\n\t\t\t\t\t\tvol->data2_zone_pos;\n\t\t\t\tzone_end = vol->mft_zone_start;\n\t\t\t\tif (!zone_start)\n\t\t\t\t\tpass = 2;\n\t\t\t\tif (zone_start >= zone_end) {\n\t\t\t\t\tvol->data2_zone_pos = zone_start =\n\t\t\t\t\t\t\tbmp_initial_pos = 0;\n\t\t\t\t\tpass = 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tntfs_debug(\"Switching from data2 zone to \"\n\t\t\t\t\t\t\"data1 zone.\");\n\t\t\t\t/* Update data2 zone position. */\n\t\t\t\tif (rlpos) {\n\t\t\t\t\tLCN tc;\n\n\t\t\t\t\tntfs_debug(\"Before checks, \"\n\t\t\t\t\t\t\t\"vol->data2_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data2_zone_pos);\n\t\t\t\t\ttc = rl[rlpos - 1].lcn +\n\t\t\t\t\t\t\trl[rlpos - 1].length;\n\t\t\t\t\tif (tc >= vol->mft_zone_start)\n\t\t\t\t\t\tvol->data2_zone_pos = 0;\n\t\t\t\t\telse if (bmp_initial_pos >=\n\t\t\t\t\t\t      vol->data2_zone_pos ||\n\t\t\t\t\t\t      tc > vol->data2_zone_pos)\n\t\t\t\t\t\tvol->data2_zone_pos = tc;\n\t\t\t\t\tntfs_debug(\"After checks, \"\n\t\t\t\t\t\t\t\"vol->data2_zone_pos \"\n\t\t\t\t\t\t\t\"0x%llx.\",\n\t\t\t\t\t\t\t(unsigned long long)\n\t\t\t\t\t\t\tvol->data2_zone_pos);\n\t\t\t\t}\n\t\t\t\t/* Switch from data2 zone to data1 zone. */\n\t\t\t\tgoto switch_to_data1_zone;\n\t\t\tdefault:\n\t\t\t\tBUG();\n\t\t\t}\n\t\t\tntfs_debug(\"After zone switch, search_zone %i, \"\n\t\t\t\t\t\"pass %i, bmp_initial_pos 0x%llx, \"\n\t\t\t\t\t\"zone_start 0x%llx, zone_end 0x%llx.\",\n\t\t\t\t\tsearch_zone, pass,\n\t\t\t\t\t(unsigned long long)bmp_initial_pos,\n\t\t\t\t\t(unsigned long long)zone_start,\n\t\t\t\t\t(unsigned long long)zone_end);\n\t\t\tbmp_pos = zone_start;\n\t\t\tif (zone_start == zone_end) {\n\t\t\t\tntfs_debug(\"Empty zone, going to \"\n\t\t\t\t\t\t\"done_zones_check.\");\n\t\t\t\t/* Empty zone. Don't bother searching it. */\n\t\t\t\tgoto done_zones_check;\n\t\t\t}\n\t\t\tntfs_debug(\"Continuing outer while loop.\");\n\t\t\tcontinue;\n\t\t} /* done_zones == 7 */\n\t\tntfs_debug(\"All zones are finished.\");\n\t\t/*\n\t\t * All zones are finished!  If DATA_ZONE, shrink mft zone.  If\n\t\t * MFT_ZONE, we have really run out of space.\n\t\t */\n\t\tmft_zone_size = vol->mft_zone_end - vol->mft_zone_start;\n\t\tntfs_debug(\"vol->mft_zone_start 0x%llx, vol->mft_zone_end \"\n\t\t\t\t\"0x%llx, mft_zone_size 0x%llx.\",\n\t\t\t\t(unsigned long long)vol->mft_zone_start,\n\t\t\t\t(unsigned long long)vol->mft_zone_end,\n\t\t\t\t(unsigned long long)mft_zone_size);\n\t\tif (zone == MFT_ZONE || mft_zone_size <= 0) {\n\t\t\tntfs_debug(\"No free clusters left, going to out.\");\n\t\t\t/* Really no more space left on device. */\n\t\t\terr = -ENOSPC;\n\t\t\tgoto out;\n\t\t} /* zone == DATA_ZONE && mft_zone_size > 0 */\n\t\tntfs_debug(\"Shrinking mft zone.\");\n\t\tzone_end = vol->mft_zone_end;\n\t\tmft_zone_size >>= 1;\n\t\tif (mft_zone_size > 0)\n\t\t\tvol->mft_zone_end = vol->mft_zone_start + mft_zone_size;\n\t\telse /* mft zone and data2 zone no longer exist. */\n\t\t\tvol->data2_zone_pos = vol->mft_zone_start =\n\t\t\t\t\tvol->mft_zone_end = 0;\n\t\tif (vol->mft_zone_pos >= vol->mft_zone_end) {\n\t\t\tvol->mft_zone_pos = vol->mft_lcn;\n\t\t\tif (!vol->mft_zone_end)\n\t\t\t\tvol->mft_zone_pos = 0;\n\t\t}\n\t\tbmp_pos = zone_start = bmp_initial_pos =\n\t\t\t\tvol->data1_zone_pos = vol->mft_zone_end;\n\t\tsearch_zone = 2;\n\t\tpass = 2;\n\t\tdone_zones &= ~2;\n\t\tntfs_debug(\"After shrinking mft zone, mft_zone_size 0x%llx, \"\n\t\t\t\t\"vol->mft_zone_start 0x%llx, \"\n\t\t\t\t\"vol->mft_zone_end 0x%llx, \"\n\t\t\t\t\"vol->mft_zone_pos 0x%llx, search_zone 2, \"\n\t\t\t\t\"pass 2, dones_zones 0x%x, zone_start 0x%llx, \"\n\t\t\t\t\"zone_end 0x%llx, vol->data1_zone_pos 0x%llx, \"\n\t\t\t\t\"continuing outer while loop.\",\n\t\t\t\t(unsigned long long)mft_zone_size,\n\t\t\t\t(unsigned long long)vol->mft_zone_start,\n\t\t\t\t(unsigned long long)vol->mft_zone_end,\n\t\t\t\t(unsigned long long)vol->mft_zone_pos,\n\t\t\t\tdone_zones, (unsigned long long)zone_start,\n\t\t\t\t(unsigned long long)zone_end,\n\t\t\t\t(unsigned long long)vol->data1_zone_pos);\n\t}\n\tntfs_debug(\"After outer while loop.\");\nout:\n\tntfs_debug(\"At out.\");\n\t/* Add runlist terminator element. */\n\tif (likely(rl)) {\n\t\trl[rlpos].vcn = rl[rlpos - 1].vcn + rl[rlpos - 1].length;\n\t\trl[rlpos].lcn = is_extension ? LCN_ENOENT : LCN_RL_NOT_MAPPED;\n\t\trl[rlpos].length = 0;\n\t}\n\tif (likely(page && !IS_ERR(page))) {\n\t\tif (need_writeback) {\n\t\t\tntfs_debug(\"Marking page dirty.\");\n\t\t\tflush_dcache_page(page);\n\t\t\tset_page_dirty(page);\n\t\t\tneed_writeback = 0;\n\t\t}\n\t\tntfs_unmap_page(page);\n\t}\n\tif (likely(!err)) {\n\t\tup_write(&vol->lcnbmp_lock);\n\t\tntfs_debug(\"Done.\");\n\t\treturn rl;\n\t}\n\tntfs_error(vol->sb, \"Failed to allocate clusters, aborting \"\n\t\t\t\"(error %i).\", err);\n\tif (rl) {\n\t\tint err2;\n\n\t\tif (err == -ENOSPC)\n\t\t\tntfs_debug(\"Not enough space to complete allocation, \"\n\t\t\t\t\t\"err -ENOSPC, first free lcn 0x%llx, \"\n\t\t\t\t\t\"could allocate up to 0x%llx \"\n\t\t\t\t\t\"clusters.\",\n\t\t\t\t\t(unsigned long long)rl[0].lcn,\n\t\t\t\t\t(unsigned long long)(count - clusters));\n\t\t/* Deallocate all allocated clusters. */\n\t\tntfs_debug(\"Attempting rollback...\");\n\t\terr2 = ntfs_cluster_free_from_rl_nolock(vol, rl);\n\t\tif (err2) {\n\t\t\tntfs_error(vol->sb, \"Failed to rollback (error %i).  \"\n\t\t\t\t\t\"Leaving inconsistent metadata!  \"\n\t\t\t\t\t\"Unmount and run chkdsk.\", err2);\n\t\t\tNVolSetErrors(vol);\n\t\t}\n\t\t/* Free the runlist. */\n\t\tntfs_free(rl);\n\t} else if (err == -ENOSPC)\n\t\tntfs_debug(\"No space left at all, err = -ENOSPC, first free \"\n\t\t\t\t\"lcn = 0x%llx.\",\n\t\t\t\t(long long)vol->data1_zone_pos);\n\tup_write(&vol->lcnbmp_lock);\n\treturn ERR_PTR(err);\n}"
  },
  {
    "function_name": "ntfs_cluster_free_from_rl_nolock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/lcnalloc.c",
    "lines": "50-70",
    "snippet": "int ntfs_cluster_free_from_rl_nolock(ntfs_volume *vol,\n\t\tconst runlist_element *rl)\n{\n\tstruct inode *lcnbmp_vi = vol->lcnbmp_ino;\n\tint ret = 0;\n\n\tntfs_debug(\"Entering.\");\n\tif (!rl)\n\t\treturn 0;\n\tfor (; rl->length; rl++) {\n\t\tint err;\n\n\t\tif (rl->lcn < 0)\n\t\t\tcontinue;\n\t\terr = ntfs_bitmap_clear_run(lcnbmp_vi, rl->lcn, rl->length);\n\t\tif (unlikely(err && (!ret || ret == -ENOMEM) && ret != err))\n\t\t\tret = err;\n\t}\n\tntfs_debug(\"Done.\");\n\treturn ret;\n}",
    "includes": [
      "#include \"ntfs.h\"",
      "#include \"aops.h\"",
      "#include \"malloc.h\"",
      "#include \"attrib.h\"",
      "#include \"volume.h\"",
      "#include \"inode.h\"",
      "#include \"bitmap.h\"",
      "#include \"debug.h\"",
      "#include \"lcnalloc.h\"",
      "#include <linux/pagemap.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntfs_debug",
          "args": [
            "\"Done.\""
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_debug_dump_runlist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/debug.c",
          "lines": "134-171",
          "snippet": "void ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"debug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"debug.h\"\n\nvoid ntfs_debug_dump_runlist(const runlist_element *rl)\n{\n\tint i;\n\tconst char *lcn_str[5] = { \"LCN_HOLE         \", \"LCN_RL_NOT_MAPPED\",\n\t\t\t\t   \"LCN_ENOENT       \", \"LCN_unknown      \" };\n\n\tif (!debug_msgs)\n\t\treturn;\n\tpr_debug(\"Dumping runlist (values in hex):\\n\");\n\tif (!rl) {\n\t\tpr_debug(\"Run list not present.\\n\");\n\t\treturn;\n\t}\n\tpr_debug(\"VCN              LCN               Run length\\n\");\n\tfor (i = 0; ; i++) {\n\t\tLCN lcn = (rl + i)->lcn;\n\n\t\tif (lcn < (LCN)0) {\n\t\t\tint index = -lcn - 1;\n\n\t\t\tif (index > -LCN_ENOENT - 1)\n\t\t\t\tindex = 3;\n\t\t\tpr_debug(\"%-16Lx %s %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn, lcn_str[index],\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\t} else\n\t\t\tpr_debug(\"%-16Lx %-16Lx  %-16Lx%s\\n\",\n\t\t\t\t\t(long long)(rl + i)->vcn,\n\t\t\t\t\t(long long)(rl + i)->lcn,\n\t\t\t\t\t(long long)(rl + i)->length,\n\t\t\t\t\t(rl + i)->length ? \"\" :\n\t\t\t\t\t\t\" (runlist end)\");\n\t\tif (!(rl + i)->length)\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "err && (!ret || ret == -ENOMEM) && ret != err"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntfs_bitmap_clear_run",
          "args": [
            "lcnbmp_vi",
            "rl->lcn",
            "rl->length"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "ntfs_bitmap_clear_run",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/bitmap.h",
          "lines": "82-86",
          "snippet": "static inline int ntfs_bitmap_clear_run(struct inode *vi, const s64 start_bit,\n\t\tconst s64 count)\n{\n\treturn ntfs_bitmap_set_bits_in_run(vi, start_bit, count, 0);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <linux/fs.h>\n\nstatic inline int ntfs_bitmap_clear_run(struct inode *vi, const s64 start_bit,\n\t\tconst s64 count)\n{\n\treturn ntfs_bitmap_set_bits_in_run(vi, start_bit, count, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ntfs.h\"\n#include \"aops.h\"\n#include \"malloc.h\"\n#include \"attrib.h\"\n#include \"volume.h\"\n#include \"inode.h\"\n#include \"bitmap.h\"\n#include \"debug.h\"\n#include \"lcnalloc.h\"\n#include <linux/pagemap.h>\n\nint ntfs_cluster_free_from_rl_nolock(ntfs_volume *vol,\n\t\tconst runlist_element *rl)\n{\n\tstruct inode *lcnbmp_vi = vol->lcnbmp_ino;\n\tint ret = 0;\n\n\tntfs_debug(\"Entering.\");\n\tif (!rl)\n\t\treturn 0;\n\tfor (; rl->length; rl++) {\n\t\tint err;\n\n\t\tif (rl->lcn < 0)\n\t\t\tcontinue;\n\t\terr = ntfs_bitmap_clear_run(lcnbmp_vi, rl->lcn, rl->length);\n\t\tif (unlikely(err && (!ret || ret == -ENOMEM) && ret != err))\n\t\t\tret = err;\n\t}\n\tntfs_debug(\"Done.\");\n\treturn ret;\n}"
  }
]