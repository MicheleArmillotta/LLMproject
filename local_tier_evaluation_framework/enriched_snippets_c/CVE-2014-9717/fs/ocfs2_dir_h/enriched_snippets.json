[
  {
    "function_name": "ocfs2_add_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.h",
    "lines": "69-78",
    "snippet": "static inline int ocfs2_add_entry(handle_t *handle,\n\t\t\t\t  struct dentry *dentry,\n\t\t\t\t  struct inode *inode, u64 blkno,\n\t\t\t\t  struct buffer_head *parent_fe_bh,\n\t\t\t\t  struct ocfs2_dir_lookup_result *lookup)\n{\n\treturn __ocfs2_add_entry(handle, dentry->d_parent->d_inode,\n\t\t\t\t dentry->d_name.name, dentry->d_name.len,\n\t\t\t\t inode, blkno, parent_fe_bh, lookup);\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ocfs2_add_entry",
          "args": [
            "handle",
            "dentry->d_parent->d_inode",
            "dentry->d_name.name",
            "dentry->d_name.len",
            "inode",
            "blkno",
            "parent_fe_bh",
            "lookup"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_add_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "1608-1760",
          "snippet": "int __ocfs2_add_entry(handle_t *handle,\n\t\t      struct inode *dir,\n\t\t      const char *name, int namelen,\n\t\t      struct inode *inode, u64 blkno,\n\t\t      struct buffer_head *parent_fe_bh,\n\t\t      struct ocfs2_dir_lookup_result *lookup)\n{\n\tunsigned long offset;\n\tunsigned short rec_len;\n\tstruct ocfs2_dir_entry *de, *de1;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)parent_fe_bh->b_data;\n\tstruct super_block *sb = dir->i_sb;\n\tint retval, status;\n\tunsigned int size = sb->s_blocksize;\n\tstruct buffer_head *insert_bh = lookup->dl_leaf_bh;\n\tchar *data_start = insert_bh->b_data;\n\n\tif (!namelen)\n\t\treturn -EINVAL;\n\n\tif (ocfs2_dir_indexed(dir)) {\n\t\tstruct buffer_head *bh;\n\n\t\t/*\n\t\t * An indexed dir may require that we update the free space\n\t\t * list. Reserve a write to the previous node in the list so\n\t\t * that we don't fail later.\n\t\t *\n\t\t * XXX: This can be either a dx_root_block, or an unindexed\n\t\t * directory tree leaf block.\n\t\t */\n\t\tif (ocfs2_free_list_at_root(lookup)) {\n\t\t\tbh = lookup->dl_dx_root_bh;\n\t\t\tretval = ocfs2_journal_access_dr(handle,\n\t\t\t\t\t\t INODE_CACHE(dir), bh,\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\t\t} else {\n\t\t\tbh = lookup->dl_prev_leaf_bh;\n\t\t\tretval = ocfs2_journal_access_db(handle,\n\t\t\t\t\t\t INODE_CACHE(dir), bh,\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\t\t}\n\t\tif (retval) {\n\t\t\tmlog_errno(retval);\n\t\t\treturn retval;\n\t\t}\n\t} else if (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tdata_start = di->id2.i_data.id_data;\n\t\tsize = i_size_read(dir);\n\n\t\tBUG_ON(insert_bh != parent_fe_bh);\n\t}\n\n\trec_len = OCFS2_DIR_REC_LEN(namelen);\n\toffset = 0;\n\tde = (struct ocfs2_dir_entry *) data_start;\n\twhile (1) {\n\t\tBUG_ON((char *)de >= (size + data_start));\n\n\t\t/* These checks should've already been passed by the\n\t\t * prepare function, but I guess we can leave them\n\t\t * here anyway. */\n\t\tif (!ocfs2_check_dir_entry(dir, de, insert_bh, offset)) {\n\t\t\tretval = -ENOENT;\n\t\t\tgoto bail;\n\t\t}\n\t\tif (ocfs2_match(namelen, name, de)) {\n\t\t\tretval = -EEXIST;\n\t\t\tgoto bail;\n\t\t}\n\n\t\t/* We're guaranteed that we should have space, so we\n\t\t * can't possibly have hit the trailer...right? */\n\t\tmlog_bug_on_msg(ocfs2_skip_dir_trailer(dir, de, offset, size),\n\t\t\t\t\"Hit dir trailer trying to insert %.*s \"\n\t\t\t        \"(namelen %d) into directory %llu.  \"\n\t\t\t\t\"offset is %lu, trailer offset is %d\\n\",\n\t\t\t\tnamelen, name, namelen,\n\t\t\t\t(unsigned long long)parent_fe_bh->b_blocknr,\n\t\t\t\toffset, ocfs2_dir_trailer_blk_off(dir->i_sb));\n\n\t\tif (ocfs2_dirent_would_fit(de, rec_len)) {\n\t\t\tdir->i_mtime = dir->i_ctime = CURRENT_TIME;\n\t\t\tretval = ocfs2_mark_inode_dirty(handle, dir, parent_fe_bh);\n\t\t\tif (retval < 0) {\n\t\t\t\tmlog_errno(retval);\n\t\t\t\tgoto bail;\n\t\t\t}\n\n\t\t\tif (insert_bh == parent_fe_bh)\n\t\t\t\tstatus = ocfs2_journal_access_di(handle,\n\t\t\t\t\t\t\t\t INODE_CACHE(dir),\n\t\t\t\t\t\t\t\t insert_bh,\n\t\t\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\t\t\telse {\n\t\t\t\tstatus = ocfs2_journal_access_db(handle,\n\t\t\t\t\t\t\t\t INODE_CACHE(dir),\n\t\t\t\t\t\t\t\t insert_bh,\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\n\t\t\t\tif (ocfs2_dir_indexed(dir)) {\n\t\t\t\t\tstatus = ocfs2_dx_dir_insert(dir,\n\t\t\t\t\t\t\t\thandle,\n\t\t\t\t\t\t\t\tlookup);\n\t\t\t\t\tif (status) {\n\t\t\t\t\t\tmlog_errno(status);\n\t\t\t\t\t\tgoto bail;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* By now the buffer is marked for journaling */\n\t\t\toffset += le16_to_cpu(de->rec_len);\n\t\t\tif (le64_to_cpu(de->inode)) {\n\t\t\t\tde1 = (struct ocfs2_dir_entry *)((char *) de +\n\t\t\t\t\tOCFS2_DIR_REC_LEN(de->name_len));\n\t\t\t\tde1->rec_len =\n\t\t\t\t\tcpu_to_le16(le16_to_cpu(de->rec_len) -\n\t\t\t\t\tOCFS2_DIR_REC_LEN(de->name_len));\n\t\t\t\tde->rec_len = cpu_to_le16(OCFS2_DIR_REC_LEN(de->name_len));\n\t\t\t\tde = de1;\n\t\t\t}\n\t\t\tde->file_type = OCFS2_FT_UNKNOWN;\n\t\t\tif (blkno) {\n\t\t\t\tde->inode = cpu_to_le64(blkno);\n\t\t\t\tocfs2_set_de_type(de, inode->i_mode);\n\t\t\t} else\n\t\t\t\tde->inode = 0;\n\t\t\tde->name_len = namelen;\n\t\t\tmemcpy(de->name, name, namelen);\n\n\t\t\tif (ocfs2_dir_indexed(dir))\n\t\t\t\tocfs2_recalc_free_list(dir, handle, lookup);\n\n\t\t\tdir->i_version++;\n\t\t\tocfs2_journal_dirty(handle, insert_bh);\n\t\t\tretval = 0;\n\t\t\tgoto bail;\n\t\t}\n\n\t\toffset += le16_to_cpu(de->rec_len);\n\t\tde = (struct ocfs2_dir_entry *) ((char *) de + le16_to_cpu(de->rec_len));\n\t}\n\n\t/* when you think about it, the assert above should prevent us\n\t * from ever getting here. */\n\tretval = -ENOSPC;\nbail:\n\tif (retval)\n\t\tmlog_errno(retval);\n\n\treturn retval;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_dir_indexed(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_dir_indexed(struct inode *inode);\n\nint __ocfs2_add_entry(handle_t *handle,\n\t\t      struct inode *dir,\n\t\t      const char *name, int namelen,\n\t\t      struct inode *inode, u64 blkno,\n\t\t      struct buffer_head *parent_fe_bh,\n\t\t      struct ocfs2_dir_lookup_result *lookup)\n{\n\tunsigned long offset;\n\tunsigned short rec_len;\n\tstruct ocfs2_dir_entry *de, *de1;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)parent_fe_bh->b_data;\n\tstruct super_block *sb = dir->i_sb;\n\tint retval, status;\n\tunsigned int size = sb->s_blocksize;\n\tstruct buffer_head *insert_bh = lookup->dl_leaf_bh;\n\tchar *data_start = insert_bh->b_data;\n\n\tif (!namelen)\n\t\treturn -EINVAL;\n\n\tif (ocfs2_dir_indexed(dir)) {\n\t\tstruct buffer_head *bh;\n\n\t\t/*\n\t\t * An indexed dir may require that we update the free space\n\t\t * list. Reserve a write to the previous node in the list so\n\t\t * that we don't fail later.\n\t\t *\n\t\t * XXX: This can be either a dx_root_block, or an unindexed\n\t\t * directory tree leaf block.\n\t\t */\n\t\tif (ocfs2_free_list_at_root(lookup)) {\n\t\t\tbh = lookup->dl_dx_root_bh;\n\t\t\tretval = ocfs2_journal_access_dr(handle,\n\t\t\t\t\t\t INODE_CACHE(dir), bh,\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\t\t} else {\n\t\t\tbh = lookup->dl_prev_leaf_bh;\n\t\t\tretval = ocfs2_journal_access_db(handle,\n\t\t\t\t\t\t INODE_CACHE(dir), bh,\n\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\t\t}\n\t\tif (retval) {\n\t\t\tmlog_errno(retval);\n\t\t\treturn retval;\n\t\t}\n\t} else if (OCFS2_I(dir)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tdata_start = di->id2.i_data.id_data;\n\t\tsize = i_size_read(dir);\n\n\t\tBUG_ON(insert_bh != parent_fe_bh);\n\t}\n\n\trec_len = OCFS2_DIR_REC_LEN(namelen);\n\toffset = 0;\n\tde = (struct ocfs2_dir_entry *) data_start;\n\twhile (1) {\n\t\tBUG_ON((char *)de >= (size + data_start));\n\n\t\t/* These checks should've already been passed by the\n\t\t * prepare function, but I guess we can leave them\n\t\t * here anyway. */\n\t\tif (!ocfs2_check_dir_entry(dir, de, insert_bh, offset)) {\n\t\t\tretval = -ENOENT;\n\t\t\tgoto bail;\n\t\t}\n\t\tif (ocfs2_match(namelen, name, de)) {\n\t\t\tretval = -EEXIST;\n\t\t\tgoto bail;\n\t\t}\n\n\t\t/* We're guaranteed that we should have space, so we\n\t\t * can't possibly have hit the trailer...right? */\n\t\tmlog_bug_on_msg(ocfs2_skip_dir_trailer(dir, de, offset, size),\n\t\t\t\t\"Hit dir trailer trying to insert %.*s \"\n\t\t\t        \"(namelen %d) into directory %llu.  \"\n\t\t\t\t\"offset is %lu, trailer offset is %d\\n\",\n\t\t\t\tnamelen, name, namelen,\n\t\t\t\t(unsigned long long)parent_fe_bh->b_blocknr,\n\t\t\t\toffset, ocfs2_dir_trailer_blk_off(dir->i_sb));\n\n\t\tif (ocfs2_dirent_would_fit(de, rec_len)) {\n\t\t\tdir->i_mtime = dir->i_ctime = CURRENT_TIME;\n\t\t\tretval = ocfs2_mark_inode_dirty(handle, dir, parent_fe_bh);\n\t\t\tif (retval < 0) {\n\t\t\t\tmlog_errno(retval);\n\t\t\t\tgoto bail;\n\t\t\t}\n\n\t\t\tif (insert_bh == parent_fe_bh)\n\t\t\t\tstatus = ocfs2_journal_access_di(handle,\n\t\t\t\t\t\t\t\t INODE_CACHE(dir),\n\t\t\t\t\t\t\t\t insert_bh,\n\t\t\t\t\t\t\t\t OCFS2_JOURNAL_ACCESS_WRITE);\n\t\t\telse {\n\t\t\t\tstatus = ocfs2_journal_access_db(handle,\n\t\t\t\t\t\t\t\t INODE_CACHE(dir),\n\t\t\t\t\t\t\t\t insert_bh,\n\t\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\n\t\t\t\tif (ocfs2_dir_indexed(dir)) {\n\t\t\t\t\tstatus = ocfs2_dx_dir_insert(dir,\n\t\t\t\t\t\t\t\thandle,\n\t\t\t\t\t\t\t\tlookup);\n\t\t\t\t\tif (status) {\n\t\t\t\t\t\tmlog_errno(status);\n\t\t\t\t\t\tgoto bail;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* By now the buffer is marked for journaling */\n\t\t\toffset += le16_to_cpu(de->rec_len);\n\t\t\tif (le64_to_cpu(de->inode)) {\n\t\t\t\tde1 = (struct ocfs2_dir_entry *)((char *) de +\n\t\t\t\t\tOCFS2_DIR_REC_LEN(de->name_len));\n\t\t\t\tde1->rec_len =\n\t\t\t\t\tcpu_to_le16(le16_to_cpu(de->rec_len) -\n\t\t\t\t\tOCFS2_DIR_REC_LEN(de->name_len));\n\t\t\t\tde->rec_len = cpu_to_le16(OCFS2_DIR_REC_LEN(de->name_len));\n\t\t\t\tde = de1;\n\t\t\t}\n\t\t\tde->file_type = OCFS2_FT_UNKNOWN;\n\t\t\tif (blkno) {\n\t\t\t\tde->inode = cpu_to_le64(blkno);\n\t\t\t\tocfs2_set_de_type(de, inode->i_mode);\n\t\t\t} else\n\t\t\t\tde->inode = 0;\n\t\t\tde->name_len = namelen;\n\t\t\tmemcpy(de->name, name, namelen);\n\n\t\t\tif (ocfs2_dir_indexed(dir))\n\t\t\t\tocfs2_recalc_free_list(dir, handle, lookup);\n\n\t\t\tdir->i_version++;\n\t\t\tocfs2_journal_dirty(handle, insert_bh);\n\t\t\tretval = 0;\n\t\t\tgoto bail;\n\t\t}\n\n\t\toffset += le16_to_cpu(de->rec_len);\n\t\tde = (struct ocfs2_dir_entry *) ((char *) de + le16_to_cpu(de->rec_len));\n\t}\n\n\t/* when you think about it, the assert above should prevent us\n\t * from ever getting here. */\n\tretval = -ENOSPC;\nbail:\n\tif (retval)\n\t\tmlog_errno(retval);\n\n\treturn retval;\n}"
        }
      }
    ],
    "contextual_snippet": "static inline int ocfs2_add_entry(handle_t *handle,\n\t\t\t\t  struct dentry *dentry,\n\t\t\t\t  struct inode *inode, u64 blkno,\n\t\t\t\t  struct buffer_head *parent_fe_bh,\n\t\t\t\t  struct ocfs2_dir_lookup_result *lookup)\n{\n\treturn __ocfs2_add_entry(handle, dentry->d_parent->d_inode,\n\t\t\t\t dentry->d_name.name, dentry->d_name.len,\n\t\t\t\t inode, blkno, parent_fe_bh, lookup);\n}"
  }
]