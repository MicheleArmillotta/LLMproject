[
  {
    "function_name": "rock_ridge_symlink_readpage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/rock.c",
    "lines": "685-797",
    "snippet": "static int rock_ridge_symlink_readpage(struct file *file, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct iso_inode_info *ei = ISOFS_I(inode);\n\tstruct isofs_sb_info *sbi = ISOFS_SB(inode->i_sb);\n\tchar *link = kmap(page);\n\tunsigned long bufsize = ISOFS_BUFFER_SIZE(inode);\n\tstruct buffer_head *bh;\n\tchar *rpnt = link;\n\tunsigned char *pnt;\n\tstruct iso_directory_record *raw_de;\n\tunsigned long block, offset;\n\tint sig;\n\tstruct rock_ridge *rr;\n\tstruct rock_state rs;\n\tint ret;\n\n\tif (!sbi->s_rock)\n\t\tgoto error;\n\n\tinit_rock_state(&rs, inode);\n\tblock = ei->i_iget5_block;\n\tbh = sb_bread(inode->i_sb, block);\n\tif (!bh)\n\t\tgoto out_noread;\n\n\toffset = ei->i_iget5_offset;\n\tpnt = (unsigned char *)bh->b_data + offset;\n\n\traw_de = (struct iso_directory_record *)pnt;\n\n\t/*\n\t * If we go past the end of the buffer, there is some sort of error.\n\t */\n\tif (offset + *pnt > bufsize)\n\t\tgoto out_bad_span;\n\n\t/*\n\t * Now test for possible Rock Ridge extensions which will override\n\t * some of these numbers in the inode structure.\n\t */\n\n\tsetup_rock_ridge(raw_de, inode, &rs);\n\nrepeat:\n\twhile (rs.len > 2) { /* There may be one byte for padding somewhere */\n\t\trr = (struct rock_ridge *)rs.chr;\n\t\tif (rr->len < 3)\n\t\t\tgoto out;\t/* Something got screwed up here */\n\t\tsig = isonum_721(rs.chr);\n\t\tif (rock_check_overflow(&rs, sig))\n\t\t\tgoto out;\n\t\trs.chr += rr->len;\n\t\trs.len -= rr->len;\n\t\tif (rs.len < 0)\n\t\t\tgoto out;\t/* corrupted isofs */\n\n\t\tswitch (sig) {\n\t\tcase SIG('R', 'R'):\n\t\t\tif ((rr->u.RR.flags[0] & RR_SL) == 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase SIG('S', 'P'):\n\t\t\tif (check_sp(rr, inode))\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase SIG('S', 'L'):\n\t\t\trpnt = get_symlink_chunk(rpnt, rr,\n\t\t\t\t\t\t link + (PAGE_SIZE - 1));\n\t\t\tif (rpnt == NULL)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase SIG('C', 'E'):\n\t\t\t/* This tells is if there is a continuation record */\n\t\t\trs.cont_extent = isonum_733(rr->u.CE.extent);\n\t\t\trs.cont_offset = isonum_733(rr->u.CE.offset);\n\t\t\trs.cont_size = isonum_733(rr->u.CE.size);\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tret = rock_continue(&rs);\n\tif (ret == 0)\n\t\tgoto repeat;\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tif (rpnt == link)\n\t\tgoto fail;\n\tbrelse(bh);\n\t*rpnt = '\\0';\n\tSetPageUptodate(page);\n\tkunmap(page);\n\tunlock_page(page);\n\treturn 0;\n\n\t/* error exit from macro */\nout:\n\tkfree(rs.buffer);\n\tgoto fail;\nout_noread:\n\tprintk(\"unable to read i-node block\");\n\tgoto fail;\nout_bad_span:\n\tprintk(\"symlink spans iso9660 blocks\\n\");\nfail:\n\tbrelse(bh);\nerror:\n\tSetPageError(page);\n\tkunmap(page);\n\tunlock_page(page);\n\treturn -EIO;\n}",
    "includes": [
      "#include \"rock.h\"",
      "#include \"isofs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "page"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "bh"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"symlink spans iso9660 blocks\\n\""
          ],
          "line": 789
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rs.buffer"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rock_continue",
          "args": [
            "&rs"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "rock_continue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/rock.c",
          "lines": "84-132",
          "snippet": "static int rock_continue(struct rock_state *rs)\n{\n\tint ret = 1;\n\tint blocksize = 1 << rs->inode->i_blkbits;\n\tconst int min_de_size = offsetof(struct rock_ridge, u);\n\n\tkfree(rs->buffer);\n\trs->buffer = NULL;\n\n\tif ((unsigned)rs->cont_offset > blocksize - min_de_size ||\n\t    (unsigned)rs->cont_size > blocksize ||\n\t    (unsigned)(rs->cont_offset + rs->cont_size) > blocksize) {\n\t\tprintk(KERN_NOTICE \"rock: corrupted directory entry. \"\n\t\t\t\"extent=%d, offset=%d, size=%d\\n\",\n\t\t\trs->cont_extent, rs->cont_offset, rs->cont_size);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tif (rs->cont_extent) {\n\t\tstruct buffer_head *bh;\n\n\t\trs->buffer = kmalloc(rs->cont_size, GFP_KERNEL);\n\t\tif (!rs->buffer) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = -EIO;\n\t\tif (++rs->cont_loops >= RR_MAX_CE_ENTRIES)\n\t\t\tgoto out;\n\t\tbh = sb_bread(rs->inode->i_sb, rs->cont_extent);\n\t\tif (bh) {\n\t\t\tmemcpy(rs->buffer, bh->b_data + rs->cont_offset,\n\t\t\t\t\trs->cont_size);\n\t\t\tput_bh(bh);\n\t\t\trs->chr = rs->buffer;\n\t\t\trs->len = rs->cont_size;\n\t\t\trs->cont_extent = 0;\n\t\t\trs->cont_size = 0;\n\t\t\trs->cont_offset = 0;\n\t\t\treturn 0;\n\t\t}\n\t\tprintk(\"Unable to read rock-ridge attributes\\n\");\n\t}\nout:\n\tkfree(rs->buffer);\n\trs->buffer = NULL;\n\treturn ret;\n}",
          "includes": [
            "#include \"rock.h\"",
            "#include \"isofs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define RR_MAX_CE_ENTRIES 32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rock.h\"\n#include \"isofs.h\"\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n\n#define RR_MAX_CE_ENTRIES 32\n\nstatic int rock_continue(struct rock_state *rs)\n{\n\tint ret = 1;\n\tint blocksize = 1 << rs->inode->i_blkbits;\n\tconst int min_de_size = offsetof(struct rock_ridge, u);\n\n\tkfree(rs->buffer);\n\trs->buffer = NULL;\n\n\tif ((unsigned)rs->cont_offset > blocksize - min_de_size ||\n\t    (unsigned)rs->cont_size > blocksize ||\n\t    (unsigned)(rs->cont_offset + rs->cont_size) > blocksize) {\n\t\tprintk(KERN_NOTICE \"rock: corrupted directory entry. \"\n\t\t\t\"extent=%d, offset=%d, size=%d\\n\",\n\t\t\trs->cont_extent, rs->cont_offset, rs->cont_size);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tif (rs->cont_extent) {\n\t\tstruct buffer_head *bh;\n\n\t\trs->buffer = kmalloc(rs->cont_size, GFP_KERNEL);\n\t\tif (!rs->buffer) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = -EIO;\n\t\tif (++rs->cont_loops >= RR_MAX_CE_ENTRIES)\n\t\t\tgoto out;\n\t\tbh = sb_bread(rs->inode->i_sb, rs->cont_extent);\n\t\tif (bh) {\n\t\t\tmemcpy(rs->buffer, bh->b_data + rs->cont_offset,\n\t\t\t\t\trs->cont_size);\n\t\t\tput_bh(bh);\n\t\t\trs->chr = rs->buffer;\n\t\t\trs->len = rs->cont_size;\n\t\t\trs->cont_extent = 0;\n\t\t\trs->cont_size = 0;\n\t\t\trs->cont_offset = 0;\n\t\t\treturn 0;\n\t\t}\n\t\tprintk(\"Unable to read rock-ridge attributes\\n\");\n\t}\nout:\n\tkfree(rs->buffer);\n\trs->buffer = NULL;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isonum_733",
          "args": [
            "rr->u.CE.size"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "isonum_733",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/isofs.h",
          "lines": "101-105",
          "snippet": "static inline unsigned int isonum_733(char *p)\n{\n\t/* Ignore bigendian datum due to broken mastering programs */\n\treturn get_unaligned_le32(p);\n}",
          "includes": [
            "#include <asm/unaligned.h>",
            "#include <linux/iso_fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unaligned.h>\n#include <linux/iso_fs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline unsigned int isonum_733(char *p)\n{\n\t/* Ignore bigendian datum due to broken mastering programs */\n\treturn get_unaligned_le32(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIG",
          "args": [
            "'C'",
            "'E'"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_symlink_chunk",
          "args": [
            "rpnt",
            "rr",
            "link + (PAGE_SIZE - 1)"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "get_symlink_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/rock.c",
          "lines": "595-661",
          "snippet": "static char *get_symlink_chunk(char *rpnt, struct rock_ridge *rr, char *plimit)\n{\n\tint slen;\n\tint rootflag;\n\tstruct SL_component *oldslp;\n\tstruct SL_component *slp;\n\tslen = rr->len - 5;\n\tslp = &rr->u.SL.link;\n\twhile (slen > 1) {\n\t\trootflag = 0;\n\t\tswitch (slp->flags & ~1) {\n\t\tcase 0:\n\t\t\tif (slp->len > plimit - rpnt)\n\t\t\t\treturn NULL;\n\t\t\tmemcpy(rpnt, slp->text, slp->len);\n\t\t\trpnt += slp->len;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (rpnt >= plimit)\n\t\t\t\treturn NULL;\n\t\t\t*rpnt++ = '.';\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tif (2 > plimit - rpnt)\n\t\t\t\treturn NULL;\n\t\t\t*rpnt++ = '.';\n\t\t\t*rpnt++ = '.';\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tif (rpnt >= plimit)\n\t\t\t\treturn NULL;\n\t\t\trootflag = 1;\n\t\t\t*rpnt++ = '/';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(\"Symlink component flag not implemented (%d)\\n\",\n\t\t\t       slp->flags);\n\t\t}\n\t\tslen -= slp->len + 2;\n\t\toldslp = slp;\n\t\tslp = (struct SL_component *)((char *)slp + slp->len + 2);\n\n\t\tif (slen < 2) {\n\t\t\t/*\n\t\t\t * If there is another SL record, and this component\n\t\t\t * record isn't continued, then add a slash.\n\t\t\t */\n\t\t\tif ((!rootflag) && (rr->u.SL.flags & 1) &&\n\t\t\t    !(oldslp->flags & 1)) {\n\t\t\t\tif (rpnt >= plimit)\n\t\t\t\t\treturn NULL;\n\t\t\t\t*rpnt++ = '/';\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If this component record isn't continued, then append a '/'.\n\t\t */\n\t\tif (!rootflag && !(oldslp->flags & 1)) {\n\t\t\tif (rpnt >= plimit)\n\t\t\t\treturn NULL;\n\t\t\t*rpnt++ = '/';\n\t\t}\n\t}\n\treturn rpnt;\n}",
          "includes": [
            "#include \"rock.h\"",
            "#include \"isofs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rock.h\"\n#include \"isofs.h\"\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n\nstatic char *get_symlink_chunk(char *rpnt, struct rock_ridge *rr, char *plimit)\n{\n\tint slen;\n\tint rootflag;\n\tstruct SL_component *oldslp;\n\tstruct SL_component *slp;\n\tslen = rr->len - 5;\n\tslp = &rr->u.SL.link;\n\twhile (slen > 1) {\n\t\trootflag = 0;\n\t\tswitch (slp->flags & ~1) {\n\t\tcase 0:\n\t\t\tif (slp->len > plimit - rpnt)\n\t\t\t\treturn NULL;\n\t\t\tmemcpy(rpnt, slp->text, slp->len);\n\t\t\trpnt += slp->len;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (rpnt >= plimit)\n\t\t\t\treturn NULL;\n\t\t\t*rpnt++ = '.';\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tif (2 > plimit - rpnt)\n\t\t\t\treturn NULL;\n\t\t\t*rpnt++ = '.';\n\t\t\t*rpnt++ = '.';\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tif (rpnt >= plimit)\n\t\t\t\treturn NULL;\n\t\t\trootflag = 1;\n\t\t\t*rpnt++ = '/';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(\"Symlink component flag not implemented (%d)\\n\",\n\t\t\t       slp->flags);\n\t\t}\n\t\tslen -= slp->len + 2;\n\t\toldslp = slp;\n\t\tslp = (struct SL_component *)((char *)slp + slp->len + 2);\n\n\t\tif (slen < 2) {\n\t\t\t/*\n\t\t\t * If there is another SL record, and this component\n\t\t\t * record isn't continued, then add a slash.\n\t\t\t */\n\t\t\tif ((!rootflag) && (rr->u.SL.flags & 1) &&\n\t\t\t    !(oldslp->flags & 1)) {\n\t\t\t\tif (rpnt >= plimit)\n\t\t\t\t\treturn NULL;\n\t\t\t\t*rpnt++ = '/';\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If this component record isn't continued, then append a '/'.\n\t\t */\n\t\tif (!rootflag && !(oldslp->flags & 1)) {\n\t\t\tif (rpnt >= plimit)\n\t\t\t\treturn NULL;\n\t\t\t*rpnt++ = '/';\n\t\t}\n\t}\n\treturn rpnt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIG",
          "args": [
            "'S'",
            "'L'"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_sp",
          "args": [
            "rr",
            "inode"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "check_sp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/rock.c",
          "lines": "42-50",
          "snippet": "static int check_sp(struct rock_ridge *rr, struct inode *inode)\n{\n\tif (rr->u.SP.magic[0] != 0xbe)\n\t\treturn -1;\n\tif (rr->u.SP.magic[1] != 0xef)\n\t\treturn -1;\n\tISOFS_SB(inode->i_sb)->s_rock_offset = rr->u.SP.skip;\n\treturn 0;\n}",
          "includes": [
            "#include \"rock.h\"",
            "#include \"isofs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rock.h\"\n#include \"isofs.h\"\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n\nstatic int check_sp(struct rock_ridge *rr, struct inode *inode)\n{\n\tif (rr->u.SP.magic[0] != 0xbe)\n\t\treturn -1;\n\tif (rr->u.SP.magic[1] != 0xef)\n\t\treturn -1;\n\tISOFS_SB(inode->i_sb)->s_rock_offset = rr->u.SP.skip;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIG",
          "args": [
            "'S'",
            "'P'"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIG",
          "args": [
            "'R'",
            "'R'"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rock_check_overflow",
          "args": [
            "&rs",
            "sig"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "rock_check_overflow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/rock.c",
          "lines": "138-192",
          "snippet": "static int rock_check_overflow(struct rock_state *rs, int sig)\n{\n\tint len;\n\n\tswitch (sig) {\n\tcase SIG('S', 'P'):\n\t\tlen = sizeof(struct SU_SP_s);\n\t\tbreak;\n\tcase SIG('C', 'E'):\n\t\tlen = sizeof(struct SU_CE_s);\n\t\tbreak;\n\tcase SIG('E', 'R'):\n\t\tlen = sizeof(struct SU_ER_s);\n\t\tbreak;\n\tcase SIG('R', 'R'):\n\t\tlen = sizeof(struct RR_RR_s);\n\t\tbreak;\n\tcase SIG('P', 'X'):\n\t\tlen = sizeof(struct RR_PX_s);\n\t\tbreak;\n\tcase SIG('P', 'N'):\n\t\tlen = sizeof(struct RR_PN_s);\n\t\tbreak;\n\tcase SIG('S', 'L'):\n\t\tlen = sizeof(struct RR_SL_s);\n\t\tbreak;\n\tcase SIG('N', 'M'):\n\t\tlen = sizeof(struct RR_NM_s);\n\t\tbreak;\n\tcase SIG('C', 'L'):\n\t\tlen = sizeof(struct RR_CL_s);\n\t\tbreak;\n\tcase SIG('P', 'L'):\n\t\tlen = sizeof(struct RR_PL_s);\n\t\tbreak;\n\tcase SIG('T', 'F'):\n\t\tlen = sizeof(struct RR_TF_s);\n\t\tbreak;\n\tcase SIG('Z', 'F'):\n\t\tlen = sizeof(struct RR_ZF_s);\n\t\tbreak;\n\tdefault:\n\t\tlen = 0;\n\t\tbreak;\n\t}\n\tlen += offsetof(struct rock_ridge, u);\n\tif (len > rs->len) {\n\t\tprintk(KERN_NOTICE \"rock: directory entry would overflow \"\n\t\t\t\t\"storage\\n\");\n\t\tprintk(KERN_NOTICE \"rock: sig=0x%02x, size=%d, remaining=%d\\n\",\n\t\t\t\tsig, len, rs->len);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"rock.h\"",
            "#include \"isofs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rock.h\"\n#include \"isofs.h\"\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n\nstatic int rock_check_overflow(struct rock_state *rs, int sig)\n{\n\tint len;\n\n\tswitch (sig) {\n\tcase SIG('S', 'P'):\n\t\tlen = sizeof(struct SU_SP_s);\n\t\tbreak;\n\tcase SIG('C', 'E'):\n\t\tlen = sizeof(struct SU_CE_s);\n\t\tbreak;\n\tcase SIG('E', 'R'):\n\t\tlen = sizeof(struct SU_ER_s);\n\t\tbreak;\n\tcase SIG('R', 'R'):\n\t\tlen = sizeof(struct RR_RR_s);\n\t\tbreak;\n\tcase SIG('P', 'X'):\n\t\tlen = sizeof(struct RR_PX_s);\n\t\tbreak;\n\tcase SIG('P', 'N'):\n\t\tlen = sizeof(struct RR_PN_s);\n\t\tbreak;\n\tcase SIG('S', 'L'):\n\t\tlen = sizeof(struct RR_SL_s);\n\t\tbreak;\n\tcase SIG('N', 'M'):\n\t\tlen = sizeof(struct RR_NM_s);\n\t\tbreak;\n\tcase SIG('C', 'L'):\n\t\tlen = sizeof(struct RR_CL_s);\n\t\tbreak;\n\tcase SIG('P', 'L'):\n\t\tlen = sizeof(struct RR_PL_s);\n\t\tbreak;\n\tcase SIG('T', 'F'):\n\t\tlen = sizeof(struct RR_TF_s);\n\t\tbreak;\n\tcase SIG('Z', 'F'):\n\t\tlen = sizeof(struct RR_ZF_s);\n\t\tbreak;\n\tdefault:\n\t\tlen = 0;\n\t\tbreak;\n\t}\n\tlen += offsetof(struct rock_ridge, u);\n\tif (len > rs->len) {\n\t\tprintk(KERN_NOTICE \"rock: directory entry would overflow \"\n\t\t\t\t\"storage\\n\");\n\t\tprintk(KERN_NOTICE \"rock: sig=0x%02x, size=%d, remaining=%d\\n\",\n\t\t\t\tsig, len, rs->len);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isonum_721",
          "args": [
            "rs.chr"
          ],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "isonum_721",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/isofs.h",
          "lines": "80-83",
          "snippet": "static inline unsigned int isonum_721(char *p)\n{\n\treturn get_unaligned_le16(p);\n}",
          "includes": [
            "#include <asm/unaligned.h>",
            "#include <linux/iso_fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unaligned.h>\n#include <linux/iso_fs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline unsigned int isonum_721(char *p)\n{\n\treturn get_unaligned_le16(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "setup_rock_ridge",
          "args": [
            "raw_de",
            "inode",
            "&rs"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "setup_rock_ridge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/rock.c",
          "lines": "52-69",
          "snippet": "static void setup_rock_ridge(struct iso_directory_record *de,\n\t\t\tstruct inode *inode, struct rock_state *rs)\n{\n\trs->len = sizeof(struct iso_directory_record) + de->name_len[0];\n\tif (rs->len & 1)\n\t\t(rs->len)++;\n\trs->chr = (unsigned char *)de + rs->len;\n\trs->len = *((unsigned char *)de) - rs->len;\n\tif (rs->len < 0)\n\t\trs->len = 0;\n\n\tif (ISOFS_SB(inode->i_sb)->s_rock_offset != -1) {\n\t\trs->len -= ISOFS_SB(inode->i_sb)->s_rock_offset;\n\t\trs->chr += ISOFS_SB(inode->i_sb)->s_rock_offset;\n\t\tif (rs->len < 0)\n\t\t\trs->len = 0;\n\t}\n}",
          "includes": [
            "#include \"rock.h\"",
            "#include \"isofs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rock.h\"\n#include \"isofs.h\"\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n\nstatic void setup_rock_ridge(struct iso_directory_record *de,\n\t\t\tstruct inode *inode, struct rock_state *rs)\n{\n\trs->len = sizeof(struct iso_directory_record) + de->name_len[0];\n\tif (rs->len & 1)\n\t\t(rs->len)++;\n\trs->chr = (unsigned char *)de + rs->len;\n\trs->len = *((unsigned char *)de) - rs->len;\n\tif (rs->len < 0)\n\t\trs->len = 0;\n\n\tif (ISOFS_SB(inode->i_sb)->s_rock_offset != -1) {\n\t\trs->len -= ISOFS_SB(inode->i_sb)->s_rock_offset;\n\t\trs->chr += ISOFS_SB(inode->i_sb)->s_rock_offset;\n\t\tif (rs->len < 0)\n\t\t\trs->len = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "inode->i_sb",
            "block"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_rock_state",
          "args": [
            "&rs",
            "inode"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "init_rock_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/rock.c",
          "lines": "71-75",
          "snippet": "static void init_rock_state(struct rock_state *rs, struct inode *inode)\n{\n\tmemset(rs, 0, sizeof(*rs));\n\trs->inode = inode;\n}",
          "includes": [
            "#include \"rock.h\"",
            "#include \"isofs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rock.h\"\n#include \"isofs.h\"\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n\nstatic void init_rock_state(struct rock_state *rs, struct inode *inode)\n{\n\tmemset(rs, 0, sizeof(*rs));\n\trs->inode = inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ISOFS_BUFFER_SIZE",
          "args": [
            "inode"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "page"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ISOFS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "ISOFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/isofs.h",
          "lines": "62-65",
          "snippet": "static inline struct isofs_sb_info *ISOFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <asm/unaligned.h>",
            "#include <linux/iso_fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unaligned.h>\n#include <linux/iso_fs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline struct isofs_sb_info *ISOFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ISOFS_I",
          "args": [
            "inode"
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "ISOFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/isofs.h",
          "lines": "67-70",
          "snippet": "static inline struct iso_inode_info *ISOFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct iso_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <asm/unaligned.h>",
            "#include <linux/iso_fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int get_rock_ridge_filename(struct iso_directory_record *, char *, struct inode *);",
            "extern int isofs_name_translate(struct iso_directory_record *, char *, struct inode *);",
            "int get_joliet_filename(struct iso_directory_record *, unsigned char *, struct inode *);",
            "int get_acorn_filename(struct iso_directory_record *, char *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unaligned.h>\n#include <linux/iso_fs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nextern int get_rock_ridge_filename(struct iso_directory_record *, char *, struct inode *);\nextern int isofs_name_translate(struct iso_directory_record *, char *, struct inode *);\nint get_joliet_filename(struct iso_directory_record *, unsigned char *, struct inode *);\nint get_acorn_filename(struct iso_directory_record *, char *, struct inode *);\n\nstatic inline struct iso_inode_info *ISOFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct iso_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rock.h\"\n#include \"isofs.h\"\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n\nstatic int rock_ridge_symlink_readpage(struct file *file, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct iso_inode_info *ei = ISOFS_I(inode);\n\tstruct isofs_sb_info *sbi = ISOFS_SB(inode->i_sb);\n\tchar *link = kmap(page);\n\tunsigned long bufsize = ISOFS_BUFFER_SIZE(inode);\n\tstruct buffer_head *bh;\n\tchar *rpnt = link;\n\tunsigned char *pnt;\n\tstruct iso_directory_record *raw_de;\n\tunsigned long block, offset;\n\tint sig;\n\tstruct rock_ridge *rr;\n\tstruct rock_state rs;\n\tint ret;\n\n\tif (!sbi->s_rock)\n\t\tgoto error;\n\n\tinit_rock_state(&rs, inode);\n\tblock = ei->i_iget5_block;\n\tbh = sb_bread(inode->i_sb, block);\n\tif (!bh)\n\t\tgoto out_noread;\n\n\toffset = ei->i_iget5_offset;\n\tpnt = (unsigned char *)bh->b_data + offset;\n\n\traw_de = (struct iso_directory_record *)pnt;\n\n\t/*\n\t * If we go past the end of the buffer, there is some sort of error.\n\t */\n\tif (offset + *pnt > bufsize)\n\t\tgoto out_bad_span;\n\n\t/*\n\t * Now test for possible Rock Ridge extensions which will override\n\t * some of these numbers in the inode structure.\n\t */\n\n\tsetup_rock_ridge(raw_de, inode, &rs);\n\nrepeat:\n\twhile (rs.len > 2) { /* There may be one byte for padding somewhere */\n\t\trr = (struct rock_ridge *)rs.chr;\n\t\tif (rr->len < 3)\n\t\t\tgoto out;\t/* Something got screwed up here */\n\t\tsig = isonum_721(rs.chr);\n\t\tif (rock_check_overflow(&rs, sig))\n\t\t\tgoto out;\n\t\trs.chr += rr->len;\n\t\trs.len -= rr->len;\n\t\tif (rs.len < 0)\n\t\t\tgoto out;\t/* corrupted isofs */\n\n\t\tswitch (sig) {\n\t\tcase SIG('R', 'R'):\n\t\t\tif ((rr->u.RR.flags[0] & RR_SL) == 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase SIG('S', 'P'):\n\t\t\tif (check_sp(rr, inode))\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase SIG('S', 'L'):\n\t\t\trpnt = get_symlink_chunk(rpnt, rr,\n\t\t\t\t\t\t link + (PAGE_SIZE - 1));\n\t\t\tif (rpnt == NULL)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase SIG('C', 'E'):\n\t\t\t/* This tells is if there is a continuation record */\n\t\t\trs.cont_extent = isonum_733(rr->u.CE.extent);\n\t\t\trs.cont_offset = isonum_733(rr->u.CE.offset);\n\t\t\trs.cont_size = isonum_733(rr->u.CE.size);\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tret = rock_continue(&rs);\n\tif (ret == 0)\n\t\tgoto repeat;\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tif (rpnt == link)\n\t\tgoto fail;\n\tbrelse(bh);\n\t*rpnt = '\\0';\n\tSetPageUptodate(page);\n\tkunmap(page);\n\tunlock_page(page);\n\treturn 0;\n\n\t/* error exit from macro */\nout:\n\tkfree(rs.buffer);\n\tgoto fail;\nout_noread:\n\tprintk(\"unable to read i-node block\");\n\tgoto fail;\nout_bad_span:\n\tprintk(\"symlink spans iso9660 blocks\\n\");\nfail:\n\tbrelse(bh);\nerror:\n\tSetPageError(page);\n\tkunmap(page);\n\tunlock_page(page);\n\treturn -EIO;\n}"
  },
  {
    "function_name": "parse_rock_ridge_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/rock.c",
    "lines": "663-679",
    "snippet": "int parse_rock_ridge_inode(struct iso_directory_record *de, struct inode *inode,\n\t\t\t   int relocated)\n{\n\tint flags = relocated ? RR_RELOC_DE : 0;\n\tint result = parse_rock_ridge_inode_internal(de, inode, flags);\n\n\t/*\n\t * if rockridge flag was reset and we didn't look for attributes\n\t * behind eventual XA attributes, have a look there\n\t */\n\tif ((ISOFS_SB(inode->i_sb)->s_rock_offset == -1)\n\t    && (ISOFS_SB(inode->i_sb)->s_rock == 2)) {\n\t\tresult = parse_rock_ridge_inode_internal(de, inode,\n\t\t\t\t\t\t\t flags | RR_REGARD_XA);\n\t}\n\treturn result;\n}",
    "includes": [
      "#include \"rock.h\"",
      "#include \"isofs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define RR_RELOC_DE 2",
      "#define RR_REGARD_XA 1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "parse_rock_ridge_inode_internal",
          "args": [
            "de",
            "inode",
            "flags | RR_REGARD_XA"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "parse_rock_ridge_inode_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/rock.c",
          "lines": "300-593",
          "snippet": "static int\nparse_rock_ridge_inode_internal(struct iso_directory_record *de,\n\t\t\t\tstruct inode *inode, int flags)\n{\n\tint symlink_len = 0;\n\tint cnt, sig;\n\tunsigned int reloc_block;\n\tstruct inode *reloc;\n\tstruct rock_ridge *rr;\n\tint rootflag;\n\tstruct rock_state rs;\n\tint ret = 0;\n\n\tif (!ISOFS_SB(inode->i_sb)->s_rock)\n\t\treturn 0;\n\n\tinit_rock_state(&rs, inode);\n\tsetup_rock_ridge(de, inode, &rs);\n\tif (flags & RR_REGARD_XA) {\n\t\trs.chr += 14;\n\t\trs.len -= 14;\n\t\tif (rs.len < 0)\n\t\t\trs.len = 0;\n\t}\n\nrepeat:\n\twhile (rs.len > 2) { /* There may be one byte for padding somewhere */\n\t\trr = (struct rock_ridge *)rs.chr;\n\t\t/*\n\t\t * Ignore rock ridge info if rr->len is out of range, but\n\t\t * don't return -EIO because that would make the file\n\t\t * invisible.\n\t\t */\n\t\tif (rr->len < 3)\n\t\t\tgoto out;\t/* Something got screwed up here */\n\t\tsig = isonum_721(rs.chr);\n\t\tif (rock_check_overflow(&rs, sig))\n\t\t\tgoto eio;\n\t\trs.chr += rr->len;\n\t\trs.len -= rr->len;\n\t\t/*\n\t\t * As above, just ignore the rock ridge info if rr->len\n\t\t * is bogus.\n\t\t */\n\t\tif (rs.len < 0)\n\t\t\tgoto out;\t/* Something got screwed up here */\n\n\t\tswitch (sig) {\n#ifndef CONFIG_ZISOFS\t\t/* No flag for SF or ZF */\n\t\tcase SIG('R', 'R'):\n\t\t\tif ((rr->u.RR.flags[0] &\n\t\t\t     (RR_PX | RR_TF | RR_SL | RR_CL)) == 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n#endif\n\t\tcase SIG('S', 'P'):\n\t\t\tif (check_sp(rr, inode))\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase SIG('C', 'E'):\n\t\t\trs.cont_extent = isonum_733(rr->u.CE.extent);\n\t\t\trs.cont_offset = isonum_733(rr->u.CE.offset);\n\t\t\trs.cont_size = isonum_733(rr->u.CE.size);\n\t\t\tbreak;\n\t\tcase SIG('E', 'R'):\n\t\t\t/* Invalid length of ER tag id? */\n\t\t\tif (rr->u.ER.len_id + offsetof(struct rock_ridge, u.ER.data) > rr->len)\n\t\t\t\tgoto out;\n\t\t\tISOFS_SB(inode->i_sb)->s_rock = 1;\n\t\t\tprintk(KERN_DEBUG \"ISO 9660 Extensions: \");\n\t\t\t{\n\t\t\t\tint p;\n\t\t\t\tfor (p = 0; p < rr->u.ER.len_id; p++)\n\t\t\t\t\tprintk(\"%c\", rr->u.ER.data[p]);\n\t\t\t}\n\t\t\tprintk(\"\\n\");\n\t\t\tbreak;\n\t\tcase SIG('P', 'X'):\n\t\t\tinode->i_mode = isonum_733(rr->u.PX.mode);\n\t\t\tset_nlink(inode, isonum_733(rr->u.PX.n_links));\n\t\t\ti_uid_write(inode, isonum_733(rr->u.PX.uid));\n\t\t\ti_gid_write(inode, isonum_733(rr->u.PX.gid));\n\t\t\tbreak;\n\t\tcase SIG('P', 'N'):\n\t\t\t{\n\t\t\t\tint high, low;\n\t\t\t\thigh = isonum_733(rr->u.PN.dev_high);\n\t\t\t\tlow = isonum_733(rr->u.PN.dev_low);\n\t\t\t\t/*\n\t\t\t\t * The Rock Ridge standard specifies that if\n\t\t\t\t * sizeof(dev_t) <= 4, then the high field is\n\t\t\t\t * unused, and the device number is completely\n\t\t\t\t * stored in the low field.  Some writers may\n\t\t\t\t * ignore this subtlety,\n\t\t\t\t * and as a result we test to see if the entire\n\t\t\t\t * device number is\n\t\t\t\t * stored in the low field, and use that.\n\t\t\t\t */\n\t\t\t\tif ((low & ~0xff) && high == 0) {\n\t\t\t\t\tinode->i_rdev =\n\t\t\t\t\t    MKDEV(low >> 8, low & 0xff);\n\t\t\t\t} else {\n\t\t\t\t\tinode->i_rdev =\n\t\t\t\t\t    MKDEV(high, low);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SIG('T', 'F'):\n\t\t\t/*\n\t\t\t * Some RRIP writers incorrectly place ctime in the\n\t\t\t * TF_CREATE field. Try to handle this correctly for\n\t\t\t * either case.\n\t\t\t */\n\t\t\t/* Rock ridge never appears on a High Sierra disk */\n\t\t\tcnt = 0;\n\t\t\tif (rr->u.TF.flags & TF_CREATE) {\n\t\t\t\tinode->i_ctime.tv_sec =\n\t\t\t\t    iso_date(rr->u.TF.times[cnt++].time,\n\t\t\t\t\t     0);\n\t\t\t\tinode->i_ctime.tv_nsec = 0;\n\t\t\t}\n\t\t\tif (rr->u.TF.flags & TF_MODIFY) {\n\t\t\t\tinode->i_mtime.tv_sec =\n\t\t\t\t    iso_date(rr->u.TF.times[cnt++].time,\n\t\t\t\t\t     0);\n\t\t\t\tinode->i_mtime.tv_nsec = 0;\n\t\t\t}\n\t\t\tif (rr->u.TF.flags & TF_ACCESS) {\n\t\t\t\tinode->i_atime.tv_sec =\n\t\t\t\t    iso_date(rr->u.TF.times[cnt++].time,\n\t\t\t\t\t     0);\n\t\t\t\tinode->i_atime.tv_nsec = 0;\n\t\t\t}\n\t\t\tif (rr->u.TF.flags & TF_ATTRIBUTES) {\n\t\t\t\tinode->i_ctime.tv_sec =\n\t\t\t\t    iso_date(rr->u.TF.times[cnt++].time,\n\t\t\t\t\t     0);\n\t\t\t\tinode->i_ctime.tv_nsec = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SIG('S', 'L'):\n\t\t\t{\n\t\t\t\tint slen;\n\t\t\t\tstruct SL_component *slp;\n\t\t\t\tstruct SL_component *oldslp;\n\t\t\t\tslen = rr->len - 5;\n\t\t\t\tslp = &rr->u.SL.link;\n\t\t\t\tinode->i_size = symlink_len;\n\t\t\t\twhile (slen > 1) {\n\t\t\t\t\trootflag = 0;\n\t\t\t\t\tswitch (slp->flags & ~1) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tinode->i_size +=\n\t\t\t\t\t\t    slp->len;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tinode->i_size += 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tinode->i_size += 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 8:\n\t\t\t\t\t\trootflag = 1;\n\t\t\t\t\t\tinode->i_size += 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tprintk(\"Symlink component flag \"\n\t\t\t\t\t\t\t\"not implemented\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tslen -= slp->len + 2;\n\t\t\t\t\toldslp = slp;\n\t\t\t\t\tslp = (struct SL_component *)\n\t\t\t\t\t\t(((char *)slp) + slp->len + 2);\n\n\t\t\t\t\tif (slen < 2) {\n\t\t\t\t\t\tif (((rr->u.SL.\n\t\t\t\t\t\t      flags & 1) != 0)\n\t\t\t\t\t\t    &&\n\t\t\t\t\t\t    ((oldslp->\n\t\t\t\t\t\t      flags & 1) == 0))\n\t\t\t\t\t\t\tinode->i_size +=\n\t\t\t\t\t\t\t    1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * If this component record isn't\n\t\t\t\t\t * continued, then append a '/'.\n\t\t\t\t\t */\n\t\t\t\t\tif (!rootflag\n\t\t\t\t\t    && (oldslp->flags & 1) == 0)\n\t\t\t\t\t\tinode->i_size += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsymlink_len = inode->i_size;\n\t\t\tbreak;\n\t\tcase SIG('R', 'E'):\n\t\t\tprintk(KERN_WARNING \"Attempt to read inode for \"\n\t\t\t\t\t\"relocated directory\\n\");\n\t\t\tgoto out;\n\t\tcase SIG('C', 'L'):\n\t\t\tif (flags & RR_RELOC_DE) {\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"ISOFS: Recursive directory relocation \"\n\t\t\t\t       \"is not supported\\n\");\n\t\t\t\tgoto eio;\n\t\t\t}\n\t\t\treloc_block = isonum_733(rr->u.CL.location);\n\t\t\tif (reloc_block == ISOFS_I(inode)->i_iget5_block &&\n\t\t\t    ISOFS_I(inode)->i_iget5_offset == 0) {\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"ISOFS: Directory relocation points to \"\n\t\t\t\t       \"itself\\n\");\n\t\t\t\tgoto eio;\n\t\t\t}\n\t\t\tISOFS_I(inode)->i_first_extent = reloc_block;\n\t\t\treloc = isofs_iget_reloc(inode->i_sb, reloc_block, 0);\n\t\t\tif (IS_ERR(reloc)) {\n\t\t\t\tret = PTR_ERR(reloc);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tinode->i_mode = reloc->i_mode;\n\t\t\tset_nlink(inode, reloc->i_nlink);\n\t\t\tinode->i_uid = reloc->i_uid;\n\t\t\tinode->i_gid = reloc->i_gid;\n\t\t\tinode->i_rdev = reloc->i_rdev;\n\t\t\tinode->i_size = reloc->i_size;\n\t\t\tinode->i_blocks = reloc->i_blocks;\n\t\t\tinode->i_atime = reloc->i_atime;\n\t\t\tinode->i_ctime = reloc->i_ctime;\n\t\t\tinode->i_mtime = reloc->i_mtime;\n\t\t\tiput(reloc);\n\t\t\tbreak;\n#ifdef CONFIG_ZISOFS\n\t\tcase SIG('Z', 'F'): {\n\t\t\tint algo;\n\n\t\t\tif (ISOFS_SB(inode->i_sb)->s_nocompress)\n\t\t\t\tbreak;\n\t\t\talgo = isonum_721(rr->u.ZF.algorithm);\n\t\t\tif (algo == SIG('p', 'z')) {\n\t\t\t\tint block_shift =\n\t\t\t\t\tisonum_711(&rr->u.ZF.parms[1]);\n\t\t\t\tif (block_shift > 17) {\n\t\t\t\t\tprintk(KERN_WARNING \"isofs: \"\n\t\t\t\t\t\t\"Can't handle ZF block \"\n\t\t\t\t\t\t\"size of 2^%d\\n\",\n\t\t\t\t\t\tblock_shift);\n\t\t\t\t} else {\n\t\t\t\t\t/*\n\t\t\t\t\t * Note: we don't change\n\t\t\t\t\t * i_blocks here\n\t\t\t\t\t */\n\t\t\t\t\tISOFS_I(inode)->i_file_format =\n\t\t\t\t\t\tisofs_file_compressed;\n\t\t\t\t\t/*\n\t\t\t\t\t * Parameters to compression\n\t\t\t\t\t * algorithm (header size,\n\t\t\t\t\t * block size)\n\t\t\t\t\t */\n\t\t\t\t\tISOFS_I(inode)->i_format_parm[0] =\n\t\t\t\t\t\tisonum_711(&rr->u.ZF.parms[0]);\n\t\t\t\t\tISOFS_I(inode)->i_format_parm[1] =\n\t\t\t\t\t\tisonum_711(&rr->u.ZF.parms[1]);\n\t\t\t\t\tinode->i_size =\n\t\t\t\t\t    isonum_733(rr->u.ZF.\n\t\t\t\t\t\t       real_size);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t       \"isofs: Unknown ZF compression \"\n\t\t\t\t\t\t\"algorithm: %c%c\\n\",\n\t\t\t\t       rr->u.ZF.algorithm[0],\n\t\t\t\t       rr->u.ZF.algorithm[1]);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tret = rock_continue(&rs);\n\tif (ret == 0)\n\t\tgoto repeat;\n\tif (ret == 1)\n\t\tret = 0;\nout:\n\tkfree(rs.buffer);\n\treturn ret;\neio:\n\tret = -EIO;\n\tgoto out;\n}",
          "includes": [
            "#include \"rock.h\"",
            "#include \"isofs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define RR_RELOC_DE 2",
            "#define RR_REGARD_XA 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rock.h\"\n#include \"isofs.h\"\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n\n#define RR_RELOC_DE 2\n#define RR_REGARD_XA 1\n\nstatic int\nparse_rock_ridge_inode_internal(struct iso_directory_record *de,\n\t\t\t\tstruct inode *inode, int flags)\n{\n\tint symlink_len = 0;\n\tint cnt, sig;\n\tunsigned int reloc_block;\n\tstruct inode *reloc;\n\tstruct rock_ridge *rr;\n\tint rootflag;\n\tstruct rock_state rs;\n\tint ret = 0;\n\n\tif (!ISOFS_SB(inode->i_sb)->s_rock)\n\t\treturn 0;\n\n\tinit_rock_state(&rs, inode);\n\tsetup_rock_ridge(de, inode, &rs);\n\tif (flags & RR_REGARD_XA) {\n\t\trs.chr += 14;\n\t\trs.len -= 14;\n\t\tif (rs.len < 0)\n\t\t\trs.len = 0;\n\t}\n\nrepeat:\n\twhile (rs.len > 2) { /* There may be one byte for padding somewhere */\n\t\trr = (struct rock_ridge *)rs.chr;\n\t\t/*\n\t\t * Ignore rock ridge info if rr->len is out of range, but\n\t\t * don't return -EIO because that would make the file\n\t\t * invisible.\n\t\t */\n\t\tif (rr->len < 3)\n\t\t\tgoto out;\t/* Something got screwed up here */\n\t\tsig = isonum_721(rs.chr);\n\t\tif (rock_check_overflow(&rs, sig))\n\t\t\tgoto eio;\n\t\trs.chr += rr->len;\n\t\trs.len -= rr->len;\n\t\t/*\n\t\t * As above, just ignore the rock ridge info if rr->len\n\t\t * is bogus.\n\t\t */\n\t\tif (rs.len < 0)\n\t\t\tgoto out;\t/* Something got screwed up here */\n\n\t\tswitch (sig) {\n#ifndef CONFIG_ZISOFS\t\t/* No flag for SF or ZF */\n\t\tcase SIG('R', 'R'):\n\t\t\tif ((rr->u.RR.flags[0] &\n\t\t\t     (RR_PX | RR_TF | RR_SL | RR_CL)) == 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n#endif\n\t\tcase SIG('S', 'P'):\n\t\t\tif (check_sp(rr, inode))\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase SIG('C', 'E'):\n\t\t\trs.cont_extent = isonum_733(rr->u.CE.extent);\n\t\t\trs.cont_offset = isonum_733(rr->u.CE.offset);\n\t\t\trs.cont_size = isonum_733(rr->u.CE.size);\n\t\t\tbreak;\n\t\tcase SIG('E', 'R'):\n\t\t\t/* Invalid length of ER tag id? */\n\t\t\tif (rr->u.ER.len_id + offsetof(struct rock_ridge, u.ER.data) > rr->len)\n\t\t\t\tgoto out;\n\t\t\tISOFS_SB(inode->i_sb)->s_rock = 1;\n\t\t\tprintk(KERN_DEBUG \"ISO 9660 Extensions: \");\n\t\t\t{\n\t\t\t\tint p;\n\t\t\t\tfor (p = 0; p < rr->u.ER.len_id; p++)\n\t\t\t\t\tprintk(\"%c\", rr->u.ER.data[p]);\n\t\t\t}\n\t\t\tprintk(\"\\n\");\n\t\t\tbreak;\n\t\tcase SIG('P', 'X'):\n\t\t\tinode->i_mode = isonum_733(rr->u.PX.mode);\n\t\t\tset_nlink(inode, isonum_733(rr->u.PX.n_links));\n\t\t\ti_uid_write(inode, isonum_733(rr->u.PX.uid));\n\t\t\ti_gid_write(inode, isonum_733(rr->u.PX.gid));\n\t\t\tbreak;\n\t\tcase SIG('P', 'N'):\n\t\t\t{\n\t\t\t\tint high, low;\n\t\t\t\thigh = isonum_733(rr->u.PN.dev_high);\n\t\t\t\tlow = isonum_733(rr->u.PN.dev_low);\n\t\t\t\t/*\n\t\t\t\t * The Rock Ridge standard specifies that if\n\t\t\t\t * sizeof(dev_t) <= 4, then the high field is\n\t\t\t\t * unused, and the device number is completely\n\t\t\t\t * stored in the low field.  Some writers may\n\t\t\t\t * ignore this subtlety,\n\t\t\t\t * and as a result we test to see if the entire\n\t\t\t\t * device number is\n\t\t\t\t * stored in the low field, and use that.\n\t\t\t\t */\n\t\t\t\tif ((low & ~0xff) && high == 0) {\n\t\t\t\t\tinode->i_rdev =\n\t\t\t\t\t    MKDEV(low >> 8, low & 0xff);\n\t\t\t\t} else {\n\t\t\t\t\tinode->i_rdev =\n\t\t\t\t\t    MKDEV(high, low);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SIG('T', 'F'):\n\t\t\t/*\n\t\t\t * Some RRIP writers incorrectly place ctime in the\n\t\t\t * TF_CREATE field. Try to handle this correctly for\n\t\t\t * either case.\n\t\t\t */\n\t\t\t/* Rock ridge never appears on a High Sierra disk */\n\t\t\tcnt = 0;\n\t\t\tif (rr->u.TF.flags & TF_CREATE) {\n\t\t\t\tinode->i_ctime.tv_sec =\n\t\t\t\t    iso_date(rr->u.TF.times[cnt++].time,\n\t\t\t\t\t     0);\n\t\t\t\tinode->i_ctime.tv_nsec = 0;\n\t\t\t}\n\t\t\tif (rr->u.TF.flags & TF_MODIFY) {\n\t\t\t\tinode->i_mtime.tv_sec =\n\t\t\t\t    iso_date(rr->u.TF.times[cnt++].time,\n\t\t\t\t\t     0);\n\t\t\t\tinode->i_mtime.tv_nsec = 0;\n\t\t\t}\n\t\t\tif (rr->u.TF.flags & TF_ACCESS) {\n\t\t\t\tinode->i_atime.tv_sec =\n\t\t\t\t    iso_date(rr->u.TF.times[cnt++].time,\n\t\t\t\t\t     0);\n\t\t\t\tinode->i_atime.tv_nsec = 0;\n\t\t\t}\n\t\t\tif (rr->u.TF.flags & TF_ATTRIBUTES) {\n\t\t\t\tinode->i_ctime.tv_sec =\n\t\t\t\t    iso_date(rr->u.TF.times[cnt++].time,\n\t\t\t\t\t     0);\n\t\t\t\tinode->i_ctime.tv_nsec = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SIG('S', 'L'):\n\t\t\t{\n\t\t\t\tint slen;\n\t\t\t\tstruct SL_component *slp;\n\t\t\t\tstruct SL_component *oldslp;\n\t\t\t\tslen = rr->len - 5;\n\t\t\t\tslp = &rr->u.SL.link;\n\t\t\t\tinode->i_size = symlink_len;\n\t\t\t\twhile (slen > 1) {\n\t\t\t\t\trootflag = 0;\n\t\t\t\t\tswitch (slp->flags & ~1) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tinode->i_size +=\n\t\t\t\t\t\t    slp->len;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tinode->i_size += 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tinode->i_size += 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 8:\n\t\t\t\t\t\trootflag = 1;\n\t\t\t\t\t\tinode->i_size += 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tprintk(\"Symlink component flag \"\n\t\t\t\t\t\t\t\"not implemented\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tslen -= slp->len + 2;\n\t\t\t\t\toldslp = slp;\n\t\t\t\t\tslp = (struct SL_component *)\n\t\t\t\t\t\t(((char *)slp) + slp->len + 2);\n\n\t\t\t\t\tif (slen < 2) {\n\t\t\t\t\t\tif (((rr->u.SL.\n\t\t\t\t\t\t      flags & 1) != 0)\n\t\t\t\t\t\t    &&\n\t\t\t\t\t\t    ((oldslp->\n\t\t\t\t\t\t      flags & 1) == 0))\n\t\t\t\t\t\t\tinode->i_size +=\n\t\t\t\t\t\t\t    1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * If this component record isn't\n\t\t\t\t\t * continued, then append a '/'.\n\t\t\t\t\t */\n\t\t\t\t\tif (!rootflag\n\t\t\t\t\t    && (oldslp->flags & 1) == 0)\n\t\t\t\t\t\tinode->i_size += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsymlink_len = inode->i_size;\n\t\t\tbreak;\n\t\tcase SIG('R', 'E'):\n\t\t\tprintk(KERN_WARNING \"Attempt to read inode for \"\n\t\t\t\t\t\"relocated directory\\n\");\n\t\t\tgoto out;\n\t\tcase SIG('C', 'L'):\n\t\t\tif (flags & RR_RELOC_DE) {\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"ISOFS: Recursive directory relocation \"\n\t\t\t\t       \"is not supported\\n\");\n\t\t\t\tgoto eio;\n\t\t\t}\n\t\t\treloc_block = isonum_733(rr->u.CL.location);\n\t\t\tif (reloc_block == ISOFS_I(inode)->i_iget5_block &&\n\t\t\t    ISOFS_I(inode)->i_iget5_offset == 0) {\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"ISOFS: Directory relocation points to \"\n\t\t\t\t       \"itself\\n\");\n\t\t\t\tgoto eio;\n\t\t\t}\n\t\t\tISOFS_I(inode)->i_first_extent = reloc_block;\n\t\t\treloc = isofs_iget_reloc(inode->i_sb, reloc_block, 0);\n\t\t\tif (IS_ERR(reloc)) {\n\t\t\t\tret = PTR_ERR(reloc);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tinode->i_mode = reloc->i_mode;\n\t\t\tset_nlink(inode, reloc->i_nlink);\n\t\t\tinode->i_uid = reloc->i_uid;\n\t\t\tinode->i_gid = reloc->i_gid;\n\t\t\tinode->i_rdev = reloc->i_rdev;\n\t\t\tinode->i_size = reloc->i_size;\n\t\t\tinode->i_blocks = reloc->i_blocks;\n\t\t\tinode->i_atime = reloc->i_atime;\n\t\t\tinode->i_ctime = reloc->i_ctime;\n\t\t\tinode->i_mtime = reloc->i_mtime;\n\t\t\tiput(reloc);\n\t\t\tbreak;\n#ifdef CONFIG_ZISOFS\n\t\tcase SIG('Z', 'F'): {\n\t\t\tint algo;\n\n\t\t\tif (ISOFS_SB(inode->i_sb)->s_nocompress)\n\t\t\t\tbreak;\n\t\t\talgo = isonum_721(rr->u.ZF.algorithm);\n\t\t\tif (algo == SIG('p', 'z')) {\n\t\t\t\tint block_shift =\n\t\t\t\t\tisonum_711(&rr->u.ZF.parms[1]);\n\t\t\t\tif (block_shift > 17) {\n\t\t\t\t\tprintk(KERN_WARNING \"isofs: \"\n\t\t\t\t\t\t\"Can't handle ZF block \"\n\t\t\t\t\t\t\"size of 2^%d\\n\",\n\t\t\t\t\t\tblock_shift);\n\t\t\t\t} else {\n\t\t\t\t\t/*\n\t\t\t\t\t * Note: we don't change\n\t\t\t\t\t * i_blocks here\n\t\t\t\t\t */\n\t\t\t\t\tISOFS_I(inode)->i_file_format =\n\t\t\t\t\t\tisofs_file_compressed;\n\t\t\t\t\t/*\n\t\t\t\t\t * Parameters to compression\n\t\t\t\t\t * algorithm (header size,\n\t\t\t\t\t * block size)\n\t\t\t\t\t */\n\t\t\t\t\tISOFS_I(inode)->i_format_parm[0] =\n\t\t\t\t\t\tisonum_711(&rr->u.ZF.parms[0]);\n\t\t\t\t\tISOFS_I(inode)->i_format_parm[1] =\n\t\t\t\t\t\tisonum_711(&rr->u.ZF.parms[1]);\n\t\t\t\t\tinode->i_size =\n\t\t\t\t\t    isonum_733(rr->u.ZF.\n\t\t\t\t\t\t       real_size);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t       \"isofs: Unknown ZF compression \"\n\t\t\t\t\t\t\"algorithm: %c%c\\n\",\n\t\t\t\t       rr->u.ZF.algorithm[0],\n\t\t\t\t       rr->u.ZF.algorithm[1]);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tret = rock_continue(&rs);\n\tif (ret == 0)\n\t\tgoto repeat;\n\tif (ret == 1)\n\t\tret = 0;\nout:\n\tkfree(rs.buffer);\n\treturn ret;\neio:\n\tret = -EIO;\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ISOFS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "ISOFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/isofs.h",
          "lines": "62-65",
          "snippet": "static inline struct isofs_sb_info *ISOFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <asm/unaligned.h>",
            "#include <linux/iso_fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unaligned.h>\n#include <linux/iso_fs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline struct isofs_sb_info *ISOFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rock.h\"\n#include \"isofs.h\"\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n\n#define RR_RELOC_DE 2\n#define RR_REGARD_XA 1\n\nint parse_rock_ridge_inode(struct iso_directory_record *de, struct inode *inode,\n\t\t\t   int relocated)\n{\n\tint flags = relocated ? RR_RELOC_DE : 0;\n\tint result = parse_rock_ridge_inode_internal(de, inode, flags);\n\n\t/*\n\t * if rockridge flag was reset and we didn't look for attributes\n\t * behind eventual XA attributes, have a look there\n\t */\n\tif ((ISOFS_SB(inode->i_sb)->s_rock_offset == -1)\n\t    && (ISOFS_SB(inode->i_sb)->s_rock == 2)) {\n\t\tresult = parse_rock_ridge_inode_internal(de, inode,\n\t\t\t\t\t\t\t flags | RR_REGARD_XA);\n\t}\n\treturn result;\n}"
  },
  {
    "function_name": "get_symlink_chunk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/rock.c",
    "lines": "595-661",
    "snippet": "static char *get_symlink_chunk(char *rpnt, struct rock_ridge *rr, char *plimit)\n{\n\tint slen;\n\tint rootflag;\n\tstruct SL_component *oldslp;\n\tstruct SL_component *slp;\n\tslen = rr->len - 5;\n\tslp = &rr->u.SL.link;\n\twhile (slen > 1) {\n\t\trootflag = 0;\n\t\tswitch (slp->flags & ~1) {\n\t\tcase 0:\n\t\t\tif (slp->len > plimit - rpnt)\n\t\t\t\treturn NULL;\n\t\t\tmemcpy(rpnt, slp->text, slp->len);\n\t\t\trpnt += slp->len;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (rpnt >= plimit)\n\t\t\t\treturn NULL;\n\t\t\t*rpnt++ = '.';\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tif (2 > plimit - rpnt)\n\t\t\t\treturn NULL;\n\t\t\t*rpnt++ = '.';\n\t\t\t*rpnt++ = '.';\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tif (rpnt >= plimit)\n\t\t\t\treturn NULL;\n\t\t\trootflag = 1;\n\t\t\t*rpnt++ = '/';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(\"Symlink component flag not implemented (%d)\\n\",\n\t\t\t       slp->flags);\n\t\t}\n\t\tslen -= slp->len + 2;\n\t\toldslp = slp;\n\t\tslp = (struct SL_component *)((char *)slp + slp->len + 2);\n\n\t\tif (slen < 2) {\n\t\t\t/*\n\t\t\t * If there is another SL record, and this component\n\t\t\t * record isn't continued, then add a slash.\n\t\t\t */\n\t\t\tif ((!rootflag) && (rr->u.SL.flags & 1) &&\n\t\t\t    !(oldslp->flags & 1)) {\n\t\t\t\tif (rpnt >= plimit)\n\t\t\t\t\treturn NULL;\n\t\t\t\t*rpnt++ = '/';\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If this component record isn't continued, then append a '/'.\n\t\t */\n\t\tif (!rootflag && !(oldslp->flags & 1)) {\n\t\t\tif (rpnt >= plimit)\n\t\t\t\treturn NULL;\n\t\t\t*rpnt++ = '/';\n\t\t}\n\t}\n\treturn rpnt;\n}",
    "includes": [
      "#include \"rock.h\"",
      "#include \"isofs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Symlink component flag not implemented (%d)\\n\"",
            "slp->flags"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "rpnt",
            "slp->text",
            "slp->len"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rock.h\"\n#include \"isofs.h\"\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n\nstatic char *get_symlink_chunk(char *rpnt, struct rock_ridge *rr, char *plimit)\n{\n\tint slen;\n\tint rootflag;\n\tstruct SL_component *oldslp;\n\tstruct SL_component *slp;\n\tslen = rr->len - 5;\n\tslp = &rr->u.SL.link;\n\twhile (slen > 1) {\n\t\trootflag = 0;\n\t\tswitch (slp->flags & ~1) {\n\t\tcase 0:\n\t\t\tif (slp->len > plimit - rpnt)\n\t\t\t\treturn NULL;\n\t\t\tmemcpy(rpnt, slp->text, slp->len);\n\t\t\trpnt += slp->len;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (rpnt >= plimit)\n\t\t\t\treturn NULL;\n\t\t\t*rpnt++ = '.';\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tif (2 > plimit - rpnt)\n\t\t\t\treturn NULL;\n\t\t\t*rpnt++ = '.';\n\t\t\t*rpnt++ = '.';\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tif (rpnt >= plimit)\n\t\t\t\treturn NULL;\n\t\t\trootflag = 1;\n\t\t\t*rpnt++ = '/';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintk(\"Symlink component flag not implemented (%d)\\n\",\n\t\t\t       slp->flags);\n\t\t}\n\t\tslen -= slp->len + 2;\n\t\toldslp = slp;\n\t\tslp = (struct SL_component *)((char *)slp + slp->len + 2);\n\n\t\tif (slen < 2) {\n\t\t\t/*\n\t\t\t * If there is another SL record, and this component\n\t\t\t * record isn't continued, then add a slash.\n\t\t\t */\n\t\t\tif ((!rootflag) && (rr->u.SL.flags & 1) &&\n\t\t\t    !(oldslp->flags & 1)) {\n\t\t\t\tif (rpnt >= plimit)\n\t\t\t\t\treturn NULL;\n\t\t\t\t*rpnt++ = '/';\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * If this component record isn't continued, then append a '/'.\n\t\t */\n\t\tif (!rootflag && !(oldslp->flags & 1)) {\n\t\t\tif (rpnt >= plimit)\n\t\t\t\treturn NULL;\n\t\t\t*rpnt++ = '/';\n\t\t}\n\t}\n\treturn rpnt;\n}"
  },
  {
    "function_name": "parse_rock_ridge_inode_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/rock.c",
    "lines": "300-593",
    "snippet": "static int\nparse_rock_ridge_inode_internal(struct iso_directory_record *de,\n\t\t\t\tstruct inode *inode, int flags)\n{\n\tint symlink_len = 0;\n\tint cnt, sig;\n\tunsigned int reloc_block;\n\tstruct inode *reloc;\n\tstruct rock_ridge *rr;\n\tint rootflag;\n\tstruct rock_state rs;\n\tint ret = 0;\n\n\tif (!ISOFS_SB(inode->i_sb)->s_rock)\n\t\treturn 0;\n\n\tinit_rock_state(&rs, inode);\n\tsetup_rock_ridge(de, inode, &rs);\n\tif (flags & RR_REGARD_XA) {\n\t\trs.chr += 14;\n\t\trs.len -= 14;\n\t\tif (rs.len < 0)\n\t\t\trs.len = 0;\n\t}\n\nrepeat:\n\twhile (rs.len > 2) { /* There may be one byte for padding somewhere */\n\t\trr = (struct rock_ridge *)rs.chr;\n\t\t/*\n\t\t * Ignore rock ridge info if rr->len is out of range, but\n\t\t * don't return -EIO because that would make the file\n\t\t * invisible.\n\t\t */\n\t\tif (rr->len < 3)\n\t\t\tgoto out;\t/* Something got screwed up here */\n\t\tsig = isonum_721(rs.chr);\n\t\tif (rock_check_overflow(&rs, sig))\n\t\t\tgoto eio;\n\t\trs.chr += rr->len;\n\t\trs.len -= rr->len;\n\t\t/*\n\t\t * As above, just ignore the rock ridge info if rr->len\n\t\t * is bogus.\n\t\t */\n\t\tif (rs.len < 0)\n\t\t\tgoto out;\t/* Something got screwed up here */\n\n\t\tswitch (sig) {\n#ifndef CONFIG_ZISOFS\t\t/* No flag for SF or ZF */\n\t\tcase SIG('R', 'R'):\n\t\t\tif ((rr->u.RR.flags[0] &\n\t\t\t     (RR_PX | RR_TF | RR_SL | RR_CL)) == 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n#endif\n\t\tcase SIG('S', 'P'):\n\t\t\tif (check_sp(rr, inode))\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase SIG('C', 'E'):\n\t\t\trs.cont_extent = isonum_733(rr->u.CE.extent);\n\t\t\trs.cont_offset = isonum_733(rr->u.CE.offset);\n\t\t\trs.cont_size = isonum_733(rr->u.CE.size);\n\t\t\tbreak;\n\t\tcase SIG('E', 'R'):\n\t\t\t/* Invalid length of ER tag id? */\n\t\t\tif (rr->u.ER.len_id + offsetof(struct rock_ridge, u.ER.data) > rr->len)\n\t\t\t\tgoto out;\n\t\t\tISOFS_SB(inode->i_sb)->s_rock = 1;\n\t\t\tprintk(KERN_DEBUG \"ISO 9660 Extensions: \");\n\t\t\t{\n\t\t\t\tint p;\n\t\t\t\tfor (p = 0; p < rr->u.ER.len_id; p++)\n\t\t\t\t\tprintk(\"%c\", rr->u.ER.data[p]);\n\t\t\t}\n\t\t\tprintk(\"\\n\");\n\t\t\tbreak;\n\t\tcase SIG('P', 'X'):\n\t\t\tinode->i_mode = isonum_733(rr->u.PX.mode);\n\t\t\tset_nlink(inode, isonum_733(rr->u.PX.n_links));\n\t\t\ti_uid_write(inode, isonum_733(rr->u.PX.uid));\n\t\t\ti_gid_write(inode, isonum_733(rr->u.PX.gid));\n\t\t\tbreak;\n\t\tcase SIG('P', 'N'):\n\t\t\t{\n\t\t\t\tint high, low;\n\t\t\t\thigh = isonum_733(rr->u.PN.dev_high);\n\t\t\t\tlow = isonum_733(rr->u.PN.dev_low);\n\t\t\t\t/*\n\t\t\t\t * The Rock Ridge standard specifies that if\n\t\t\t\t * sizeof(dev_t) <= 4, then the high field is\n\t\t\t\t * unused, and the device number is completely\n\t\t\t\t * stored in the low field.  Some writers may\n\t\t\t\t * ignore this subtlety,\n\t\t\t\t * and as a result we test to see if the entire\n\t\t\t\t * device number is\n\t\t\t\t * stored in the low field, and use that.\n\t\t\t\t */\n\t\t\t\tif ((low & ~0xff) && high == 0) {\n\t\t\t\t\tinode->i_rdev =\n\t\t\t\t\t    MKDEV(low >> 8, low & 0xff);\n\t\t\t\t} else {\n\t\t\t\t\tinode->i_rdev =\n\t\t\t\t\t    MKDEV(high, low);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SIG('T', 'F'):\n\t\t\t/*\n\t\t\t * Some RRIP writers incorrectly place ctime in the\n\t\t\t * TF_CREATE field. Try to handle this correctly for\n\t\t\t * either case.\n\t\t\t */\n\t\t\t/* Rock ridge never appears on a High Sierra disk */\n\t\t\tcnt = 0;\n\t\t\tif (rr->u.TF.flags & TF_CREATE) {\n\t\t\t\tinode->i_ctime.tv_sec =\n\t\t\t\t    iso_date(rr->u.TF.times[cnt++].time,\n\t\t\t\t\t     0);\n\t\t\t\tinode->i_ctime.tv_nsec = 0;\n\t\t\t}\n\t\t\tif (rr->u.TF.flags & TF_MODIFY) {\n\t\t\t\tinode->i_mtime.tv_sec =\n\t\t\t\t    iso_date(rr->u.TF.times[cnt++].time,\n\t\t\t\t\t     0);\n\t\t\t\tinode->i_mtime.tv_nsec = 0;\n\t\t\t}\n\t\t\tif (rr->u.TF.flags & TF_ACCESS) {\n\t\t\t\tinode->i_atime.tv_sec =\n\t\t\t\t    iso_date(rr->u.TF.times[cnt++].time,\n\t\t\t\t\t     0);\n\t\t\t\tinode->i_atime.tv_nsec = 0;\n\t\t\t}\n\t\t\tif (rr->u.TF.flags & TF_ATTRIBUTES) {\n\t\t\t\tinode->i_ctime.tv_sec =\n\t\t\t\t    iso_date(rr->u.TF.times[cnt++].time,\n\t\t\t\t\t     0);\n\t\t\t\tinode->i_ctime.tv_nsec = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SIG('S', 'L'):\n\t\t\t{\n\t\t\t\tint slen;\n\t\t\t\tstruct SL_component *slp;\n\t\t\t\tstruct SL_component *oldslp;\n\t\t\t\tslen = rr->len - 5;\n\t\t\t\tslp = &rr->u.SL.link;\n\t\t\t\tinode->i_size = symlink_len;\n\t\t\t\twhile (slen > 1) {\n\t\t\t\t\trootflag = 0;\n\t\t\t\t\tswitch (slp->flags & ~1) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tinode->i_size +=\n\t\t\t\t\t\t    slp->len;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tinode->i_size += 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tinode->i_size += 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 8:\n\t\t\t\t\t\trootflag = 1;\n\t\t\t\t\t\tinode->i_size += 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tprintk(\"Symlink component flag \"\n\t\t\t\t\t\t\t\"not implemented\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tslen -= slp->len + 2;\n\t\t\t\t\toldslp = slp;\n\t\t\t\t\tslp = (struct SL_component *)\n\t\t\t\t\t\t(((char *)slp) + slp->len + 2);\n\n\t\t\t\t\tif (slen < 2) {\n\t\t\t\t\t\tif (((rr->u.SL.\n\t\t\t\t\t\t      flags & 1) != 0)\n\t\t\t\t\t\t    &&\n\t\t\t\t\t\t    ((oldslp->\n\t\t\t\t\t\t      flags & 1) == 0))\n\t\t\t\t\t\t\tinode->i_size +=\n\t\t\t\t\t\t\t    1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * If this component record isn't\n\t\t\t\t\t * continued, then append a '/'.\n\t\t\t\t\t */\n\t\t\t\t\tif (!rootflag\n\t\t\t\t\t    && (oldslp->flags & 1) == 0)\n\t\t\t\t\t\tinode->i_size += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsymlink_len = inode->i_size;\n\t\t\tbreak;\n\t\tcase SIG('R', 'E'):\n\t\t\tprintk(KERN_WARNING \"Attempt to read inode for \"\n\t\t\t\t\t\"relocated directory\\n\");\n\t\t\tgoto out;\n\t\tcase SIG('C', 'L'):\n\t\t\tif (flags & RR_RELOC_DE) {\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"ISOFS: Recursive directory relocation \"\n\t\t\t\t       \"is not supported\\n\");\n\t\t\t\tgoto eio;\n\t\t\t}\n\t\t\treloc_block = isonum_733(rr->u.CL.location);\n\t\t\tif (reloc_block == ISOFS_I(inode)->i_iget5_block &&\n\t\t\t    ISOFS_I(inode)->i_iget5_offset == 0) {\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"ISOFS: Directory relocation points to \"\n\t\t\t\t       \"itself\\n\");\n\t\t\t\tgoto eio;\n\t\t\t}\n\t\t\tISOFS_I(inode)->i_first_extent = reloc_block;\n\t\t\treloc = isofs_iget_reloc(inode->i_sb, reloc_block, 0);\n\t\t\tif (IS_ERR(reloc)) {\n\t\t\t\tret = PTR_ERR(reloc);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tinode->i_mode = reloc->i_mode;\n\t\t\tset_nlink(inode, reloc->i_nlink);\n\t\t\tinode->i_uid = reloc->i_uid;\n\t\t\tinode->i_gid = reloc->i_gid;\n\t\t\tinode->i_rdev = reloc->i_rdev;\n\t\t\tinode->i_size = reloc->i_size;\n\t\t\tinode->i_blocks = reloc->i_blocks;\n\t\t\tinode->i_atime = reloc->i_atime;\n\t\t\tinode->i_ctime = reloc->i_ctime;\n\t\t\tinode->i_mtime = reloc->i_mtime;\n\t\t\tiput(reloc);\n\t\t\tbreak;\n#ifdef CONFIG_ZISOFS\n\t\tcase SIG('Z', 'F'): {\n\t\t\tint algo;\n\n\t\t\tif (ISOFS_SB(inode->i_sb)->s_nocompress)\n\t\t\t\tbreak;\n\t\t\talgo = isonum_721(rr->u.ZF.algorithm);\n\t\t\tif (algo == SIG('p', 'z')) {\n\t\t\t\tint block_shift =\n\t\t\t\t\tisonum_711(&rr->u.ZF.parms[1]);\n\t\t\t\tif (block_shift > 17) {\n\t\t\t\t\tprintk(KERN_WARNING \"isofs: \"\n\t\t\t\t\t\t\"Can't handle ZF block \"\n\t\t\t\t\t\t\"size of 2^%d\\n\",\n\t\t\t\t\t\tblock_shift);\n\t\t\t\t} else {\n\t\t\t\t\t/*\n\t\t\t\t\t * Note: we don't change\n\t\t\t\t\t * i_blocks here\n\t\t\t\t\t */\n\t\t\t\t\tISOFS_I(inode)->i_file_format =\n\t\t\t\t\t\tisofs_file_compressed;\n\t\t\t\t\t/*\n\t\t\t\t\t * Parameters to compression\n\t\t\t\t\t * algorithm (header size,\n\t\t\t\t\t * block size)\n\t\t\t\t\t */\n\t\t\t\t\tISOFS_I(inode)->i_format_parm[0] =\n\t\t\t\t\t\tisonum_711(&rr->u.ZF.parms[0]);\n\t\t\t\t\tISOFS_I(inode)->i_format_parm[1] =\n\t\t\t\t\t\tisonum_711(&rr->u.ZF.parms[1]);\n\t\t\t\t\tinode->i_size =\n\t\t\t\t\t    isonum_733(rr->u.ZF.\n\t\t\t\t\t\t       real_size);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t       \"isofs: Unknown ZF compression \"\n\t\t\t\t\t\t\"algorithm: %c%c\\n\",\n\t\t\t\t       rr->u.ZF.algorithm[0],\n\t\t\t\t       rr->u.ZF.algorithm[1]);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tret = rock_continue(&rs);\n\tif (ret == 0)\n\t\tgoto repeat;\n\tif (ret == 1)\n\t\tret = 0;\nout:\n\tkfree(rs.buffer);\n\treturn ret;\neio:\n\tret = -EIO;\n\tgoto out;\n}",
    "includes": [
      "#include \"rock.h\"",
      "#include \"isofs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define RR_RELOC_DE 2",
      "#define RR_REGARD_XA 1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rs.buffer"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rock_continue",
          "args": [
            "&rs"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "rock_continue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/rock.c",
          "lines": "84-132",
          "snippet": "static int rock_continue(struct rock_state *rs)\n{\n\tint ret = 1;\n\tint blocksize = 1 << rs->inode->i_blkbits;\n\tconst int min_de_size = offsetof(struct rock_ridge, u);\n\n\tkfree(rs->buffer);\n\trs->buffer = NULL;\n\n\tif ((unsigned)rs->cont_offset > blocksize - min_de_size ||\n\t    (unsigned)rs->cont_size > blocksize ||\n\t    (unsigned)(rs->cont_offset + rs->cont_size) > blocksize) {\n\t\tprintk(KERN_NOTICE \"rock: corrupted directory entry. \"\n\t\t\t\"extent=%d, offset=%d, size=%d\\n\",\n\t\t\trs->cont_extent, rs->cont_offset, rs->cont_size);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tif (rs->cont_extent) {\n\t\tstruct buffer_head *bh;\n\n\t\trs->buffer = kmalloc(rs->cont_size, GFP_KERNEL);\n\t\tif (!rs->buffer) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = -EIO;\n\t\tif (++rs->cont_loops >= RR_MAX_CE_ENTRIES)\n\t\t\tgoto out;\n\t\tbh = sb_bread(rs->inode->i_sb, rs->cont_extent);\n\t\tif (bh) {\n\t\t\tmemcpy(rs->buffer, bh->b_data + rs->cont_offset,\n\t\t\t\t\trs->cont_size);\n\t\t\tput_bh(bh);\n\t\t\trs->chr = rs->buffer;\n\t\t\trs->len = rs->cont_size;\n\t\t\trs->cont_extent = 0;\n\t\t\trs->cont_size = 0;\n\t\t\trs->cont_offset = 0;\n\t\t\treturn 0;\n\t\t}\n\t\tprintk(\"Unable to read rock-ridge attributes\\n\");\n\t}\nout:\n\tkfree(rs->buffer);\n\trs->buffer = NULL;\n\treturn ret;\n}",
          "includes": [
            "#include \"rock.h\"",
            "#include \"isofs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define RR_MAX_CE_ENTRIES 32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rock.h\"\n#include \"isofs.h\"\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n\n#define RR_MAX_CE_ENTRIES 32\n\nstatic int rock_continue(struct rock_state *rs)\n{\n\tint ret = 1;\n\tint blocksize = 1 << rs->inode->i_blkbits;\n\tconst int min_de_size = offsetof(struct rock_ridge, u);\n\n\tkfree(rs->buffer);\n\trs->buffer = NULL;\n\n\tif ((unsigned)rs->cont_offset > blocksize - min_de_size ||\n\t    (unsigned)rs->cont_size > blocksize ||\n\t    (unsigned)(rs->cont_offset + rs->cont_size) > blocksize) {\n\t\tprintk(KERN_NOTICE \"rock: corrupted directory entry. \"\n\t\t\t\"extent=%d, offset=%d, size=%d\\n\",\n\t\t\trs->cont_extent, rs->cont_offset, rs->cont_size);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tif (rs->cont_extent) {\n\t\tstruct buffer_head *bh;\n\n\t\trs->buffer = kmalloc(rs->cont_size, GFP_KERNEL);\n\t\tif (!rs->buffer) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = -EIO;\n\t\tif (++rs->cont_loops >= RR_MAX_CE_ENTRIES)\n\t\t\tgoto out;\n\t\tbh = sb_bread(rs->inode->i_sb, rs->cont_extent);\n\t\tif (bh) {\n\t\t\tmemcpy(rs->buffer, bh->b_data + rs->cont_offset,\n\t\t\t\t\trs->cont_size);\n\t\t\tput_bh(bh);\n\t\t\trs->chr = rs->buffer;\n\t\t\trs->len = rs->cont_size;\n\t\t\trs->cont_extent = 0;\n\t\t\trs->cont_size = 0;\n\t\t\trs->cont_offset = 0;\n\t\t\treturn 0;\n\t\t}\n\t\tprintk(\"Unable to read rock-ridge attributes\\n\");\n\t}\nout:\n\tkfree(rs->buffer);\n\trs->buffer = NULL;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING\n\t\t\t\t       \"isofs: Unknown ZF compression \"\n\t\t\t\t\t\t\"algorithm: %c%c\\n\"",
            "rr->u.ZF.algorithm[0]",
            "rr->u.ZF.algorithm[1]"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isonum_733",
          "args": [
            "rr->u.ZF.\n\t\t\t\t\t\t       real_size"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "isonum_733",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/isofs.h",
          "lines": "101-105",
          "snippet": "static inline unsigned int isonum_733(char *p)\n{\n\t/* Ignore bigendian datum due to broken mastering programs */\n\treturn get_unaligned_le32(p);\n}",
          "includes": [
            "#include <asm/unaligned.h>",
            "#include <linux/iso_fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unaligned.h>\n#include <linux/iso_fs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline unsigned int isonum_733(char *p)\n{\n\t/* Ignore bigendian datum due to broken mastering programs */\n\treturn get_unaligned_le32(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "isonum_711",
          "args": [
            "&rr->u.ZF.parms[1]"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "isonum_711",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/isofs.h",
          "lines": "72-75",
          "snippet": "static inline int isonum_711(char *p)\n{\n\treturn *(u8 *)p;\n}",
          "includes": [
            "#include <asm/unaligned.h>",
            "#include <linux/iso_fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unaligned.h>\n#include <linux/iso_fs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline int isonum_711(char *p)\n{\n\treturn *(u8 *)p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ISOFS_I",
          "args": [
            "inode"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "ISOFS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/isofs.h",
          "lines": "67-70",
          "snippet": "static inline struct iso_inode_info *ISOFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct iso_inode_info, vfs_inode);\n}",
          "includes": [
            "#include <asm/unaligned.h>",
            "#include <linux/iso_fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int get_rock_ridge_filename(struct iso_directory_record *, char *, struct inode *);",
            "extern int isofs_name_translate(struct iso_directory_record *, char *, struct inode *);",
            "int get_joliet_filename(struct iso_directory_record *, unsigned char *, struct inode *);",
            "int get_acorn_filename(struct iso_directory_record *, char *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unaligned.h>\n#include <linux/iso_fs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nextern int get_rock_ridge_filename(struct iso_directory_record *, char *, struct inode *);\nextern int isofs_name_translate(struct iso_directory_record *, char *, struct inode *);\nint get_joliet_filename(struct iso_directory_record *, unsigned char *, struct inode *);\nint get_acorn_filename(struct iso_directory_record *, char *, struct inode *);\n\nstatic inline struct iso_inode_info *ISOFS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct iso_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIG",
          "args": [
            "'p'",
            "'z'"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isonum_721",
          "args": [
            "rr->u.ZF.algorithm"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "isonum_721",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/isofs.h",
          "lines": "80-83",
          "snippet": "static inline unsigned int isonum_721(char *p)\n{\n\treturn get_unaligned_le16(p);\n}",
          "includes": [
            "#include <asm/unaligned.h>",
            "#include <linux/iso_fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unaligned.h>\n#include <linux/iso_fs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline unsigned int isonum_721(char *p)\n{\n\treturn get_unaligned_le16(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ISOFS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "ISOFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/isofs.h",
          "lines": "62-65",
          "snippet": "static inline struct isofs_sb_info *ISOFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <asm/unaligned.h>",
            "#include <linux/iso_fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unaligned.h>\n#include <linux/iso_fs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline struct isofs_sb_info *ISOFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIG",
          "args": [
            "'Z'",
            "'F'"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "reloc"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_nlink",
          "args": [
            "inode",
            "reloc->i_nlink"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "set_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "305-316",
          "snippet": "void set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid set_nlink(struct inode *inode, unsigned int nlink)\n{\n\tif (!nlink) {\n\t\tclear_nlink(inode);\n\t} else {\n\t\t/* Yes, some filesystems do change nlink from zero to one */\n\t\tif (inode->i_nlink == 0)\n\t\t\tatomic_long_dec(&inode->i_sb->s_remove_count);\n\n\t\tinode->__i_nlink = nlink;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "reloc"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "reloc"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isofs_iget_reloc",
          "args": [
            "inode->i_sb",
            "reloc_block",
            "0"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "isofs_iget_reloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/isofs.h",
          "lines": "133-138",
          "snippet": "static inline struct inode *isofs_iget_reloc(struct super_block *sb,\n\t\t\t\t\t     unsigned long block,\n\t\t\t\t\t     unsigned long offset)\n{\n\treturn __isofs_iget(sb, block, offset, 1);\n}",
          "includes": [
            "#include <asm/unaligned.h>",
            "#include <linux/iso_fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern int get_rock_ridge_filename(struct iso_directory_record *, char *, struct inode *);",
            "extern int isofs_name_translate(struct iso_directory_record *, char *, struct inode *);",
            "int get_joliet_filename(struct iso_directory_record *, unsigned char *, struct inode *);",
            "int get_acorn_filename(struct iso_directory_record *, char *, struct inode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unaligned.h>\n#include <linux/iso_fs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nextern int get_rock_ridge_filename(struct iso_directory_record *, char *, struct inode *);\nextern int isofs_name_translate(struct iso_directory_record *, char *, struct inode *);\nint get_joliet_filename(struct iso_directory_record *, unsigned char *, struct inode *);\nint get_acorn_filename(struct iso_directory_record *, char *, struct inode *);\n\nstatic inline struct inode *isofs_iget_reloc(struct super_block *sb,\n\t\t\t\t\t     unsigned long block,\n\t\t\t\t\t     unsigned long offset)\n{\n\treturn __isofs_iget(sb, block, offset, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIG",
          "args": [
            "'C'",
            "'L'"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIG",
          "args": [
            "'R'",
            "'E'"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIG",
          "args": [
            "'S'",
            "'L'"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iso_date",
          "args": [
            "rr->u.TF.times[cnt++].time",
            "0"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "iso_date",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/util.c",
          "lines": "18-70",
          "snippet": "int iso_date(char * p, int flag)\n{\n\tint year, month, day, hour, minute, second, tz;\n\tint crtime;\n\n\tyear = p[0];\n\tmonth = p[1];\n\tday = p[2];\n\thour = p[3];\n\tminute = p[4];\n\tsecond = p[5];\n\tif (flag == 0) tz = p[6]; /* High sierra has no time zone */\n\telse tz = 0;\n\t\n\tif (year < 0) {\n\t\tcrtime = 0;\n\t} else {\n\t\tcrtime = mktime64(year+1900, month, day, hour, minute, second);\n\n\t\t/* sign extend */\n\t\tif (tz & 0x80)\n\t\t\ttz |= (-1 << 8);\n\t\t\n\t\t/* \n\t\t * The timezone offset is unreliable on some disks,\n\t\t * so we make a sanity check.  In no case is it ever\n\t\t * more than 13 hours from GMT, which is 52*15min.\n\t\t * The time is always stored in localtime with the\n\t\t * timezone offset being what get added to GMT to\n\t\t * get to localtime.  Thus we need to subtract the offset\n\t\t * to get to true GMT, which is what we store the time\n\t\t * as internally.  On the local system, the user may set\n\t\t * their timezone any way they wish, of course, so GMT\n\t\t * gets converted back to localtime on the receiving\n\t\t * system.\n\t\t *\n\t\t * NOTE: mkisofs in versions prior to mkisofs-1.10 had\n\t\t * the sign wrong on the timezone offset.  This has now\n\t\t * been corrected there too, but if you are getting screwy\n\t\t * results this may be the explanation.  If enough people\n\t\t * complain, a user configuration option could be added\n\t\t * to add the timezone offset in with the wrong sign\n\t\t * for 'compatibility' with older discs, but I cannot see how\n\t\t * it will matter that much.\n\t\t *\n\t\t * Thanks to kuhlmav@elec.canterbury.ac.nz (Volker Kuhlmann)\n\t\t * for pointing out the sign error.\n\t\t */\n\t\tif (-52 <= tz && tz <= 52)\n\t\t\tcrtime -= tz * 15 * 60;\n\t}\n\treturn crtime;\n}",
          "includes": [
            "#include \"isofs.h\"",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"isofs.h\"\n#include <linux/time.h>\n\nint iso_date(char * p, int flag)\n{\n\tint year, month, day, hour, minute, second, tz;\n\tint crtime;\n\n\tyear = p[0];\n\tmonth = p[1];\n\tday = p[2];\n\thour = p[3];\n\tminute = p[4];\n\tsecond = p[5];\n\tif (flag == 0) tz = p[6]; /* High sierra has no time zone */\n\telse tz = 0;\n\t\n\tif (year < 0) {\n\t\tcrtime = 0;\n\t} else {\n\t\tcrtime = mktime64(year+1900, month, day, hour, minute, second);\n\n\t\t/* sign extend */\n\t\tif (tz & 0x80)\n\t\t\ttz |= (-1 << 8);\n\t\t\n\t\t/* \n\t\t * The timezone offset is unreliable on some disks,\n\t\t * so we make a sanity check.  In no case is it ever\n\t\t * more than 13 hours from GMT, which is 52*15min.\n\t\t * The time is always stored in localtime with the\n\t\t * timezone offset being what get added to GMT to\n\t\t * get to localtime.  Thus we need to subtract the offset\n\t\t * to get to true GMT, which is what we store the time\n\t\t * as internally.  On the local system, the user may set\n\t\t * their timezone any way they wish, of course, so GMT\n\t\t * gets converted back to localtime on the receiving\n\t\t * system.\n\t\t *\n\t\t * NOTE: mkisofs in versions prior to mkisofs-1.10 had\n\t\t * the sign wrong on the timezone offset.  This has now\n\t\t * been corrected there too, but if you are getting screwy\n\t\t * results this may be the explanation.  If enough people\n\t\t * complain, a user configuration option could be added\n\t\t * to add the timezone offset in with the wrong sign\n\t\t * for 'compatibility' with older discs, but I cannot see how\n\t\t * it will matter that much.\n\t\t *\n\t\t * Thanks to kuhlmav@elec.canterbury.ac.nz (Volker Kuhlmann)\n\t\t * for pointing out the sign error.\n\t\t */\n\t\tif (-52 <= tz && tz <= 52)\n\t\t\tcrtime -= tz * 15 * 60;\n\t}\n\treturn crtime;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIG",
          "args": [
            "'T'",
            "'F'"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MKDEV",
          "args": [
            "high",
            "low"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MKDEV",
          "args": [
            "low >> 8",
            "low & 0xff"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIG",
          "args": [
            "'P'",
            "'N'"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_gid_write",
          "args": [
            "inode",
            "isonum_733(rr->u.PX.gid)"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_uid_write",
          "args": [
            "inode",
            "isonum_733(rr->u.PX.uid)"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIG",
          "args": [
            "'P'",
            "'X'"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIG",
          "args": [
            "'E'",
            "'R'"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIG",
          "args": [
            "'C'",
            "'E'"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_sp",
          "args": [
            "rr",
            "inode"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "check_sp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/rock.c",
          "lines": "42-50",
          "snippet": "static int check_sp(struct rock_ridge *rr, struct inode *inode)\n{\n\tif (rr->u.SP.magic[0] != 0xbe)\n\t\treturn -1;\n\tif (rr->u.SP.magic[1] != 0xef)\n\t\treturn -1;\n\tISOFS_SB(inode->i_sb)->s_rock_offset = rr->u.SP.skip;\n\treturn 0;\n}",
          "includes": [
            "#include \"rock.h\"",
            "#include \"isofs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rock.h\"\n#include \"isofs.h\"\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n\nstatic int check_sp(struct rock_ridge *rr, struct inode *inode)\n{\n\tif (rr->u.SP.magic[0] != 0xbe)\n\t\treturn -1;\n\tif (rr->u.SP.magic[1] != 0xef)\n\t\treturn -1;\n\tISOFS_SB(inode->i_sb)->s_rock_offset = rr->u.SP.skip;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIG",
          "args": [
            "'S'",
            "'P'"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIG",
          "args": [
            "'R'",
            "'R'"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rock_check_overflow",
          "args": [
            "&rs",
            "sig"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "rock_check_overflow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/rock.c",
          "lines": "138-192",
          "snippet": "static int rock_check_overflow(struct rock_state *rs, int sig)\n{\n\tint len;\n\n\tswitch (sig) {\n\tcase SIG('S', 'P'):\n\t\tlen = sizeof(struct SU_SP_s);\n\t\tbreak;\n\tcase SIG('C', 'E'):\n\t\tlen = sizeof(struct SU_CE_s);\n\t\tbreak;\n\tcase SIG('E', 'R'):\n\t\tlen = sizeof(struct SU_ER_s);\n\t\tbreak;\n\tcase SIG('R', 'R'):\n\t\tlen = sizeof(struct RR_RR_s);\n\t\tbreak;\n\tcase SIG('P', 'X'):\n\t\tlen = sizeof(struct RR_PX_s);\n\t\tbreak;\n\tcase SIG('P', 'N'):\n\t\tlen = sizeof(struct RR_PN_s);\n\t\tbreak;\n\tcase SIG('S', 'L'):\n\t\tlen = sizeof(struct RR_SL_s);\n\t\tbreak;\n\tcase SIG('N', 'M'):\n\t\tlen = sizeof(struct RR_NM_s);\n\t\tbreak;\n\tcase SIG('C', 'L'):\n\t\tlen = sizeof(struct RR_CL_s);\n\t\tbreak;\n\tcase SIG('P', 'L'):\n\t\tlen = sizeof(struct RR_PL_s);\n\t\tbreak;\n\tcase SIG('T', 'F'):\n\t\tlen = sizeof(struct RR_TF_s);\n\t\tbreak;\n\tcase SIG('Z', 'F'):\n\t\tlen = sizeof(struct RR_ZF_s);\n\t\tbreak;\n\tdefault:\n\t\tlen = 0;\n\t\tbreak;\n\t}\n\tlen += offsetof(struct rock_ridge, u);\n\tif (len > rs->len) {\n\t\tprintk(KERN_NOTICE \"rock: directory entry would overflow \"\n\t\t\t\t\"storage\\n\");\n\t\tprintk(KERN_NOTICE \"rock: sig=0x%02x, size=%d, remaining=%d\\n\",\n\t\t\t\tsig, len, rs->len);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"rock.h\"",
            "#include \"isofs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rock.h\"\n#include \"isofs.h\"\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n\nstatic int rock_check_overflow(struct rock_state *rs, int sig)\n{\n\tint len;\n\n\tswitch (sig) {\n\tcase SIG('S', 'P'):\n\t\tlen = sizeof(struct SU_SP_s);\n\t\tbreak;\n\tcase SIG('C', 'E'):\n\t\tlen = sizeof(struct SU_CE_s);\n\t\tbreak;\n\tcase SIG('E', 'R'):\n\t\tlen = sizeof(struct SU_ER_s);\n\t\tbreak;\n\tcase SIG('R', 'R'):\n\t\tlen = sizeof(struct RR_RR_s);\n\t\tbreak;\n\tcase SIG('P', 'X'):\n\t\tlen = sizeof(struct RR_PX_s);\n\t\tbreak;\n\tcase SIG('P', 'N'):\n\t\tlen = sizeof(struct RR_PN_s);\n\t\tbreak;\n\tcase SIG('S', 'L'):\n\t\tlen = sizeof(struct RR_SL_s);\n\t\tbreak;\n\tcase SIG('N', 'M'):\n\t\tlen = sizeof(struct RR_NM_s);\n\t\tbreak;\n\tcase SIG('C', 'L'):\n\t\tlen = sizeof(struct RR_CL_s);\n\t\tbreak;\n\tcase SIG('P', 'L'):\n\t\tlen = sizeof(struct RR_PL_s);\n\t\tbreak;\n\tcase SIG('T', 'F'):\n\t\tlen = sizeof(struct RR_TF_s);\n\t\tbreak;\n\tcase SIG('Z', 'F'):\n\t\tlen = sizeof(struct RR_ZF_s);\n\t\tbreak;\n\tdefault:\n\t\tlen = 0;\n\t\tbreak;\n\t}\n\tlen += offsetof(struct rock_ridge, u);\n\tif (len > rs->len) {\n\t\tprintk(KERN_NOTICE \"rock: directory entry would overflow \"\n\t\t\t\t\"storage\\n\");\n\t\tprintk(KERN_NOTICE \"rock: sig=0x%02x, size=%d, remaining=%d\\n\",\n\t\t\t\tsig, len, rs->len);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setup_rock_ridge",
          "args": [
            "de",
            "inode",
            "&rs"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "setup_rock_ridge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/rock.c",
          "lines": "52-69",
          "snippet": "static void setup_rock_ridge(struct iso_directory_record *de,\n\t\t\tstruct inode *inode, struct rock_state *rs)\n{\n\trs->len = sizeof(struct iso_directory_record) + de->name_len[0];\n\tif (rs->len & 1)\n\t\t(rs->len)++;\n\trs->chr = (unsigned char *)de + rs->len;\n\trs->len = *((unsigned char *)de) - rs->len;\n\tif (rs->len < 0)\n\t\trs->len = 0;\n\n\tif (ISOFS_SB(inode->i_sb)->s_rock_offset != -1) {\n\t\trs->len -= ISOFS_SB(inode->i_sb)->s_rock_offset;\n\t\trs->chr += ISOFS_SB(inode->i_sb)->s_rock_offset;\n\t\tif (rs->len < 0)\n\t\t\trs->len = 0;\n\t}\n}",
          "includes": [
            "#include \"rock.h\"",
            "#include \"isofs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rock.h\"\n#include \"isofs.h\"\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n\nstatic void setup_rock_ridge(struct iso_directory_record *de,\n\t\t\tstruct inode *inode, struct rock_state *rs)\n{\n\trs->len = sizeof(struct iso_directory_record) + de->name_len[0];\n\tif (rs->len & 1)\n\t\t(rs->len)++;\n\trs->chr = (unsigned char *)de + rs->len;\n\trs->len = *((unsigned char *)de) - rs->len;\n\tif (rs->len < 0)\n\t\trs->len = 0;\n\n\tif (ISOFS_SB(inode->i_sb)->s_rock_offset != -1) {\n\t\trs->len -= ISOFS_SB(inode->i_sb)->s_rock_offset;\n\t\trs->chr += ISOFS_SB(inode->i_sb)->s_rock_offset;\n\t\tif (rs->len < 0)\n\t\t\trs->len = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_rock_state",
          "args": [
            "&rs",
            "inode"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "init_rock_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/rock.c",
          "lines": "71-75",
          "snippet": "static void init_rock_state(struct rock_state *rs, struct inode *inode)\n{\n\tmemset(rs, 0, sizeof(*rs));\n\trs->inode = inode;\n}",
          "includes": [
            "#include \"rock.h\"",
            "#include \"isofs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rock.h\"\n#include \"isofs.h\"\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n\nstatic void init_rock_state(struct rock_state *rs, struct inode *inode)\n{\n\tmemset(rs, 0, sizeof(*rs));\n\trs->inode = inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rock.h\"\n#include \"isofs.h\"\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n\n#define RR_RELOC_DE 2\n#define RR_REGARD_XA 1\n\nstatic int\nparse_rock_ridge_inode_internal(struct iso_directory_record *de,\n\t\t\t\tstruct inode *inode, int flags)\n{\n\tint symlink_len = 0;\n\tint cnt, sig;\n\tunsigned int reloc_block;\n\tstruct inode *reloc;\n\tstruct rock_ridge *rr;\n\tint rootflag;\n\tstruct rock_state rs;\n\tint ret = 0;\n\n\tif (!ISOFS_SB(inode->i_sb)->s_rock)\n\t\treturn 0;\n\n\tinit_rock_state(&rs, inode);\n\tsetup_rock_ridge(de, inode, &rs);\n\tif (flags & RR_REGARD_XA) {\n\t\trs.chr += 14;\n\t\trs.len -= 14;\n\t\tif (rs.len < 0)\n\t\t\trs.len = 0;\n\t}\n\nrepeat:\n\twhile (rs.len > 2) { /* There may be one byte for padding somewhere */\n\t\trr = (struct rock_ridge *)rs.chr;\n\t\t/*\n\t\t * Ignore rock ridge info if rr->len is out of range, but\n\t\t * don't return -EIO because that would make the file\n\t\t * invisible.\n\t\t */\n\t\tif (rr->len < 3)\n\t\t\tgoto out;\t/* Something got screwed up here */\n\t\tsig = isonum_721(rs.chr);\n\t\tif (rock_check_overflow(&rs, sig))\n\t\t\tgoto eio;\n\t\trs.chr += rr->len;\n\t\trs.len -= rr->len;\n\t\t/*\n\t\t * As above, just ignore the rock ridge info if rr->len\n\t\t * is bogus.\n\t\t */\n\t\tif (rs.len < 0)\n\t\t\tgoto out;\t/* Something got screwed up here */\n\n\t\tswitch (sig) {\n#ifndef CONFIG_ZISOFS\t\t/* No flag for SF or ZF */\n\t\tcase SIG('R', 'R'):\n\t\t\tif ((rr->u.RR.flags[0] &\n\t\t\t     (RR_PX | RR_TF | RR_SL | RR_CL)) == 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n#endif\n\t\tcase SIG('S', 'P'):\n\t\t\tif (check_sp(rr, inode))\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase SIG('C', 'E'):\n\t\t\trs.cont_extent = isonum_733(rr->u.CE.extent);\n\t\t\trs.cont_offset = isonum_733(rr->u.CE.offset);\n\t\t\trs.cont_size = isonum_733(rr->u.CE.size);\n\t\t\tbreak;\n\t\tcase SIG('E', 'R'):\n\t\t\t/* Invalid length of ER tag id? */\n\t\t\tif (rr->u.ER.len_id + offsetof(struct rock_ridge, u.ER.data) > rr->len)\n\t\t\t\tgoto out;\n\t\t\tISOFS_SB(inode->i_sb)->s_rock = 1;\n\t\t\tprintk(KERN_DEBUG \"ISO 9660 Extensions: \");\n\t\t\t{\n\t\t\t\tint p;\n\t\t\t\tfor (p = 0; p < rr->u.ER.len_id; p++)\n\t\t\t\t\tprintk(\"%c\", rr->u.ER.data[p]);\n\t\t\t}\n\t\t\tprintk(\"\\n\");\n\t\t\tbreak;\n\t\tcase SIG('P', 'X'):\n\t\t\tinode->i_mode = isonum_733(rr->u.PX.mode);\n\t\t\tset_nlink(inode, isonum_733(rr->u.PX.n_links));\n\t\t\ti_uid_write(inode, isonum_733(rr->u.PX.uid));\n\t\t\ti_gid_write(inode, isonum_733(rr->u.PX.gid));\n\t\t\tbreak;\n\t\tcase SIG('P', 'N'):\n\t\t\t{\n\t\t\t\tint high, low;\n\t\t\t\thigh = isonum_733(rr->u.PN.dev_high);\n\t\t\t\tlow = isonum_733(rr->u.PN.dev_low);\n\t\t\t\t/*\n\t\t\t\t * The Rock Ridge standard specifies that if\n\t\t\t\t * sizeof(dev_t) <= 4, then the high field is\n\t\t\t\t * unused, and the device number is completely\n\t\t\t\t * stored in the low field.  Some writers may\n\t\t\t\t * ignore this subtlety,\n\t\t\t\t * and as a result we test to see if the entire\n\t\t\t\t * device number is\n\t\t\t\t * stored in the low field, and use that.\n\t\t\t\t */\n\t\t\t\tif ((low & ~0xff) && high == 0) {\n\t\t\t\t\tinode->i_rdev =\n\t\t\t\t\t    MKDEV(low >> 8, low & 0xff);\n\t\t\t\t} else {\n\t\t\t\t\tinode->i_rdev =\n\t\t\t\t\t    MKDEV(high, low);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SIG('T', 'F'):\n\t\t\t/*\n\t\t\t * Some RRIP writers incorrectly place ctime in the\n\t\t\t * TF_CREATE field. Try to handle this correctly for\n\t\t\t * either case.\n\t\t\t */\n\t\t\t/* Rock ridge never appears on a High Sierra disk */\n\t\t\tcnt = 0;\n\t\t\tif (rr->u.TF.flags & TF_CREATE) {\n\t\t\t\tinode->i_ctime.tv_sec =\n\t\t\t\t    iso_date(rr->u.TF.times[cnt++].time,\n\t\t\t\t\t     0);\n\t\t\t\tinode->i_ctime.tv_nsec = 0;\n\t\t\t}\n\t\t\tif (rr->u.TF.flags & TF_MODIFY) {\n\t\t\t\tinode->i_mtime.tv_sec =\n\t\t\t\t    iso_date(rr->u.TF.times[cnt++].time,\n\t\t\t\t\t     0);\n\t\t\t\tinode->i_mtime.tv_nsec = 0;\n\t\t\t}\n\t\t\tif (rr->u.TF.flags & TF_ACCESS) {\n\t\t\t\tinode->i_atime.tv_sec =\n\t\t\t\t    iso_date(rr->u.TF.times[cnt++].time,\n\t\t\t\t\t     0);\n\t\t\t\tinode->i_atime.tv_nsec = 0;\n\t\t\t}\n\t\t\tif (rr->u.TF.flags & TF_ATTRIBUTES) {\n\t\t\t\tinode->i_ctime.tv_sec =\n\t\t\t\t    iso_date(rr->u.TF.times[cnt++].time,\n\t\t\t\t\t     0);\n\t\t\t\tinode->i_ctime.tv_nsec = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SIG('S', 'L'):\n\t\t\t{\n\t\t\t\tint slen;\n\t\t\t\tstruct SL_component *slp;\n\t\t\t\tstruct SL_component *oldslp;\n\t\t\t\tslen = rr->len - 5;\n\t\t\t\tslp = &rr->u.SL.link;\n\t\t\t\tinode->i_size = symlink_len;\n\t\t\t\twhile (slen > 1) {\n\t\t\t\t\trootflag = 0;\n\t\t\t\t\tswitch (slp->flags & ~1) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tinode->i_size +=\n\t\t\t\t\t\t    slp->len;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tinode->i_size += 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\tinode->i_size += 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 8:\n\t\t\t\t\t\trootflag = 1;\n\t\t\t\t\t\tinode->i_size += 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tprintk(\"Symlink component flag \"\n\t\t\t\t\t\t\t\"not implemented\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tslen -= slp->len + 2;\n\t\t\t\t\toldslp = slp;\n\t\t\t\t\tslp = (struct SL_component *)\n\t\t\t\t\t\t(((char *)slp) + slp->len + 2);\n\n\t\t\t\t\tif (slen < 2) {\n\t\t\t\t\t\tif (((rr->u.SL.\n\t\t\t\t\t\t      flags & 1) != 0)\n\t\t\t\t\t\t    &&\n\t\t\t\t\t\t    ((oldslp->\n\t\t\t\t\t\t      flags & 1) == 0))\n\t\t\t\t\t\t\tinode->i_size +=\n\t\t\t\t\t\t\t    1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * If this component record isn't\n\t\t\t\t\t * continued, then append a '/'.\n\t\t\t\t\t */\n\t\t\t\t\tif (!rootflag\n\t\t\t\t\t    && (oldslp->flags & 1) == 0)\n\t\t\t\t\t\tinode->i_size += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsymlink_len = inode->i_size;\n\t\t\tbreak;\n\t\tcase SIG('R', 'E'):\n\t\t\tprintk(KERN_WARNING \"Attempt to read inode for \"\n\t\t\t\t\t\"relocated directory\\n\");\n\t\t\tgoto out;\n\t\tcase SIG('C', 'L'):\n\t\t\tif (flags & RR_RELOC_DE) {\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"ISOFS: Recursive directory relocation \"\n\t\t\t\t       \"is not supported\\n\");\n\t\t\t\tgoto eio;\n\t\t\t}\n\t\t\treloc_block = isonum_733(rr->u.CL.location);\n\t\t\tif (reloc_block == ISOFS_I(inode)->i_iget5_block &&\n\t\t\t    ISOFS_I(inode)->i_iget5_offset == 0) {\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"ISOFS: Directory relocation points to \"\n\t\t\t\t       \"itself\\n\");\n\t\t\t\tgoto eio;\n\t\t\t}\n\t\t\tISOFS_I(inode)->i_first_extent = reloc_block;\n\t\t\treloc = isofs_iget_reloc(inode->i_sb, reloc_block, 0);\n\t\t\tif (IS_ERR(reloc)) {\n\t\t\t\tret = PTR_ERR(reloc);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tinode->i_mode = reloc->i_mode;\n\t\t\tset_nlink(inode, reloc->i_nlink);\n\t\t\tinode->i_uid = reloc->i_uid;\n\t\t\tinode->i_gid = reloc->i_gid;\n\t\t\tinode->i_rdev = reloc->i_rdev;\n\t\t\tinode->i_size = reloc->i_size;\n\t\t\tinode->i_blocks = reloc->i_blocks;\n\t\t\tinode->i_atime = reloc->i_atime;\n\t\t\tinode->i_ctime = reloc->i_ctime;\n\t\t\tinode->i_mtime = reloc->i_mtime;\n\t\t\tiput(reloc);\n\t\t\tbreak;\n#ifdef CONFIG_ZISOFS\n\t\tcase SIG('Z', 'F'): {\n\t\t\tint algo;\n\n\t\t\tif (ISOFS_SB(inode->i_sb)->s_nocompress)\n\t\t\t\tbreak;\n\t\t\talgo = isonum_721(rr->u.ZF.algorithm);\n\t\t\tif (algo == SIG('p', 'z')) {\n\t\t\t\tint block_shift =\n\t\t\t\t\tisonum_711(&rr->u.ZF.parms[1]);\n\t\t\t\tif (block_shift > 17) {\n\t\t\t\t\tprintk(KERN_WARNING \"isofs: \"\n\t\t\t\t\t\t\"Can't handle ZF block \"\n\t\t\t\t\t\t\"size of 2^%d\\n\",\n\t\t\t\t\t\tblock_shift);\n\t\t\t\t} else {\n\t\t\t\t\t/*\n\t\t\t\t\t * Note: we don't change\n\t\t\t\t\t * i_blocks here\n\t\t\t\t\t */\n\t\t\t\t\tISOFS_I(inode)->i_file_format =\n\t\t\t\t\t\tisofs_file_compressed;\n\t\t\t\t\t/*\n\t\t\t\t\t * Parameters to compression\n\t\t\t\t\t * algorithm (header size,\n\t\t\t\t\t * block size)\n\t\t\t\t\t */\n\t\t\t\t\tISOFS_I(inode)->i_format_parm[0] =\n\t\t\t\t\t\tisonum_711(&rr->u.ZF.parms[0]);\n\t\t\t\t\tISOFS_I(inode)->i_format_parm[1] =\n\t\t\t\t\t\tisonum_711(&rr->u.ZF.parms[1]);\n\t\t\t\t\tinode->i_size =\n\t\t\t\t\t    isonum_733(rr->u.ZF.\n\t\t\t\t\t\t       real_size);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tprintk(KERN_WARNING\n\t\t\t\t       \"isofs: Unknown ZF compression \"\n\t\t\t\t\t\t\"algorithm: %c%c\\n\",\n\t\t\t\t       rr->u.ZF.algorithm[0],\n\t\t\t\t       rr->u.ZF.algorithm[1]);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tret = rock_continue(&rs);\n\tif (ret == 0)\n\t\tgoto repeat;\n\tif (ret == 1)\n\t\tret = 0;\nout:\n\tkfree(rs.buffer);\n\treturn ret;\neio:\n\tret = -EIO;\n\tgoto out;\n}"
  },
  {
    "function_name": "get_rock_ridge_filename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/rock.c",
    "lines": "197-295",
    "snippet": "int get_rock_ridge_filename(struct iso_directory_record *de,\n\t\t\t    char *retname, struct inode *inode)\n{\n\tstruct rock_state rs;\n\tstruct rock_ridge *rr;\n\tint sig;\n\tint retnamlen = 0;\n\tint truncate = 0;\n\tint ret = 0;\n\n\tif (!ISOFS_SB(inode->i_sb)->s_rock)\n\t\treturn 0;\n\t*retname = 0;\n\n\tinit_rock_state(&rs, inode);\n\tsetup_rock_ridge(de, inode, &rs);\nrepeat:\n\n\twhile (rs.len > 2) { /* There may be one byte for padding somewhere */\n\t\trr = (struct rock_ridge *)rs.chr;\n\t\t/*\n\t\t * Ignore rock ridge info if rr->len is out of range, but\n\t\t * don't return -EIO because that would make the file\n\t\t * invisible.\n\t\t */\n\t\tif (rr->len < 3)\n\t\t\tgoto out;\t/* Something got screwed up here */\n\t\tsig = isonum_721(rs.chr);\n\t\tif (rock_check_overflow(&rs, sig))\n\t\t\tgoto eio;\n\t\trs.chr += rr->len;\n\t\trs.len -= rr->len;\n\t\t/*\n\t\t * As above, just ignore the rock ridge info if rr->len\n\t\t * is bogus.\n\t\t */\n\t\tif (rs.len < 0)\n\t\t\tgoto out;\t/* Something got screwed up here */\n\n\t\tswitch (sig) {\n\t\tcase SIG('R', 'R'):\n\t\t\tif ((rr->u.RR.flags[0] & RR_NM) == 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase SIG('S', 'P'):\n\t\t\tif (check_sp(rr, inode))\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase SIG('C', 'E'):\n\t\t\trs.cont_extent = isonum_733(rr->u.CE.extent);\n\t\t\trs.cont_offset = isonum_733(rr->u.CE.offset);\n\t\t\trs.cont_size = isonum_733(rr->u.CE.size);\n\t\t\tbreak;\n\t\tcase SIG('N', 'M'):\n\t\t\tif (truncate)\n\t\t\t\tbreak;\n\t\t\tif (rr->len < 5)\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * If the flags are 2 or 4, this indicates '.' or '..'.\n\t\t\t * We don't want to do anything with this, because it\n\t\t\t * screws up the code that calls us.  We don't really\n\t\t\t * care anyways, since we can just use the non-RR\n\t\t\t * name.\n\t\t\t */\n\t\t\tif (rr->u.NM.flags & 6)\n\t\t\t\tbreak;\n\n\t\t\tif (rr->u.NM.flags & ~1) {\n\t\t\t\tprintk(\"Unsupported NM flag settings (%d)\\n\",\n\t\t\t\t\trr->u.NM.flags);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((strlen(retname) + rr->len - 5) >= 254) {\n\t\t\t\ttruncate = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstrncat(retname, rr->u.NM.name, rr->len - 5);\n\t\t\tretnamlen += rr->len - 5;\n\t\t\tbreak;\n\t\tcase SIG('R', 'E'):\n\t\t\tkfree(rs.buffer);\n\t\t\treturn -1;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tret = rock_continue(&rs);\n\tif (ret == 0)\n\t\tgoto repeat;\n\tif (ret == 1)\n\t\treturn retnamlen; /* If 0, this file did not have a NM field */\nout:\n\tkfree(rs.buffer);\n\treturn ret;\neio:\n\tret = -EIO;\n\tgoto out;\n}",
    "includes": [
      "#include \"rock.h\"",
      "#include \"isofs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rs.buffer"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rock_continue",
          "args": [
            "&rs"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "rock_continue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/rock.c",
          "lines": "84-132",
          "snippet": "static int rock_continue(struct rock_state *rs)\n{\n\tint ret = 1;\n\tint blocksize = 1 << rs->inode->i_blkbits;\n\tconst int min_de_size = offsetof(struct rock_ridge, u);\n\n\tkfree(rs->buffer);\n\trs->buffer = NULL;\n\n\tif ((unsigned)rs->cont_offset > blocksize - min_de_size ||\n\t    (unsigned)rs->cont_size > blocksize ||\n\t    (unsigned)(rs->cont_offset + rs->cont_size) > blocksize) {\n\t\tprintk(KERN_NOTICE \"rock: corrupted directory entry. \"\n\t\t\t\"extent=%d, offset=%d, size=%d\\n\",\n\t\t\trs->cont_extent, rs->cont_offset, rs->cont_size);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tif (rs->cont_extent) {\n\t\tstruct buffer_head *bh;\n\n\t\trs->buffer = kmalloc(rs->cont_size, GFP_KERNEL);\n\t\tif (!rs->buffer) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = -EIO;\n\t\tif (++rs->cont_loops >= RR_MAX_CE_ENTRIES)\n\t\t\tgoto out;\n\t\tbh = sb_bread(rs->inode->i_sb, rs->cont_extent);\n\t\tif (bh) {\n\t\t\tmemcpy(rs->buffer, bh->b_data + rs->cont_offset,\n\t\t\t\t\trs->cont_size);\n\t\t\tput_bh(bh);\n\t\t\trs->chr = rs->buffer;\n\t\t\trs->len = rs->cont_size;\n\t\t\trs->cont_extent = 0;\n\t\t\trs->cont_size = 0;\n\t\t\trs->cont_offset = 0;\n\t\t\treturn 0;\n\t\t}\n\t\tprintk(\"Unable to read rock-ridge attributes\\n\");\n\t}\nout:\n\tkfree(rs->buffer);\n\trs->buffer = NULL;\n\treturn ret;\n}",
          "includes": [
            "#include \"rock.h\"",
            "#include \"isofs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define RR_MAX_CE_ENTRIES 32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rock.h\"\n#include \"isofs.h\"\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n\n#define RR_MAX_CE_ENTRIES 32\n\nstatic int rock_continue(struct rock_state *rs)\n{\n\tint ret = 1;\n\tint blocksize = 1 << rs->inode->i_blkbits;\n\tconst int min_de_size = offsetof(struct rock_ridge, u);\n\n\tkfree(rs->buffer);\n\trs->buffer = NULL;\n\n\tif ((unsigned)rs->cont_offset > blocksize - min_de_size ||\n\t    (unsigned)rs->cont_size > blocksize ||\n\t    (unsigned)(rs->cont_offset + rs->cont_size) > blocksize) {\n\t\tprintk(KERN_NOTICE \"rock: corrupted directory entry. \"\n\t\t\t\"extent=%d, offset=%d, size=%d\\n\",\n\t\t\trs->cont_extent, rs->cont_offset, rs->cont_size);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tif (rs->cont_extent) {\n\t\tstruct buffer_head *bh;\n\n\t\trs->buffer = kmalloc(rs->cont_size, GFP_KERNEL);\n\t\tif (!rs->buffer) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = -EIO;\n\t\tif (++rs->cont_loops >= RR_MAX_CE_ENTRIES)\n\t\t\tgoto out;\n\t\tbh = sb_bread(rs->inode->i_sb, rs->cont_extent);\n\t\tif (bh) {\n\t\t\tmemcpy(rs->buffer, bh->b_data + rs->cont_offset,\n\t\t\t\t\trs->cont_size);\n\t\t\tput_bh(bh);\n\t\t\trs->chr = rs->buffer;\n\t\t\trs->len = rs->cont_size;\n\t\t\trs->cont_extent = 0;\n\t\t\trs->cont_size = 0;\n\t\t\trs->cont_offset = 0;\n\t\t\treturn 0;\n\t\t}\n\t\tprintk(\"Unable to read rock-ridge attributes\\n\");\n\t}\nout:\n\tkfree(rs->buffer);\n\trs->buffer = NULL;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rs.buffer"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIG",
          "args": [
            "'R'",
            "'E'"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncat",
          "args": [
            "retname",
            "rr->u.NM.name",
            "rr->len - 5"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "retname"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Unsupported NM flag settings (%d)\\n\"",
            "rr->u.NM.flags"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIG",
          "args": [
            "'N'",
            "'M'"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isonum_733",
          "args": [
            "rr->u.CE.size"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "isonum_733",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/isofs.h",
          "lines": "101-105",
          "snippet": "static inline unsigned int isonum_733(char *p)\n{\n\t/* Ignore bigendian datum due to broken mastering programs */\n\treturn get_unaligned_le32(p);\n}",
          "includes": [
            "#include <asm/unaligned.h>",
            "#include <linux/iso_fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unaligned.h>\n#include <linux/iso_fs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline unsigned int isonum_733(char *p)\n{\n\t/* Ignore bigendian datum due to broken mastering programs */\n\treturn get_unaligned_le32(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIG",
          "args": [
            "'C'",
            "'E'"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_sp",
          "args": [
            "rr",
            "inode"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "check_sp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/rock.c",
          "lines": "42-50",
          "snippet": "static int check_sp(struct rock_ridge *rr, struct inode *inode)\n{\n\tif (rr->u.SP.magic[0] != 0xbe)\n\t\treturn -1;\n\tif (rr->u.SP.magic[1] != 0xef)\n\t\treturn -1;\n\tISOFS_SB(inode->i_sb)->s_rock_offset = rr->u.SP.skip;\n\treturn 0;\n}",
          "includes": [
            "#include \"rock.h\"",
            "#include \"isofs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rock.h\"\n#include \"isofs.h\"\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n\nstatic int check_sp(struct rock_ridge *rr, struct inode *inode)\n{\n\tif (rr->u.SP.magic[0] != 0xbe)\n\t\treturn -1;\n\tif (rr->u.SP.magic[1] != 0xef)\n\t\treturn -1;\n\tISOFS_SB(inode->i_sb)->s_rock_offset = rr->u.SP.skip;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIG",
          "args": [
            "'S'",
            "'P'"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIG",
          "args": [
            "'R'",
            "'R'"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rock_check_overflow",
          "args": [
            "&rs",
            "sig"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "rock_check_overflow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/rock.c",
          "lines": "138-192",
          "snippet": "static int rock_check_overflow(struct rock_state *rs, int sig)\n{\n\tint len;\n\n\tswitch (sig) {\n\tcase SIG('S', 'P'):\n\t\tlen = sizeof(struct SU_SP_s);\n\t\tbreak;\n\tcase SIG('C', 'E'):\n\t\tlen = sizeof(struct SU_CE_s);\n\t\tbreak;\n\tcase SIG('E', 'R'):\n\t\tlen = sizeof(struct SU_ER_s);\n\t\tbreak;\n\tcase SIG('R', 'R'):\n\t\tlen = sizeof(struct RR_RR_s);\n\t\tbreak;\n\tcase SIG('P', 'X'):\n\t\tlen = sizeof(struct RR_PX_s);\n\t\tbreak;\n\tcase SIG('P', 'N'):\n\t\tlen = sizeof(struct RR_PN_s);\n\t\tbreak;\n\tcase SIG('S', 'L'):\n\t\tlen = sizeof(struct RR_SL_s);\n\t\tbreak;\n\tcase SIG('N', 'M'):\n\t\tlen = sizeof(struct RR_NM_s);\n\t\tbreak;\n\tcase SIG('C', 'L'):\n\t\tlen = sizeof(struct RR_CL_s);\n\t\tbreak;\n\tcase SIG('P', 'L'):\n\t\tlen = sizeof(struct RR_PL_s);\n\t\tbreak;\n\tcase SIG('T', 'F'):\n\t\tlen = sizeof(struct RR_TF_s);\n\t\tbreak;\n\tcase SIG('Z', 'F'):\n\t\tlen = sizeof(struct RR_ZF_s);\n\t\tbreak;\n\tdefault:\n\t\tlen = 0;\n\t\tbreak;\n\t}\n\tlen += offsetof(struct rock_ridge, u);\n\tif (len > rs->len) {\n\t\tprintk(KERN_NOTICE \"rock: directory entry would overflow \"\n\t\t\t\t\"storage\\n\");\n\t\tprintk(KERN_NOTICE \"rock: sig=0x%02x, size=%d, remaining=%d\\n\",\n\t\t\t\tsig, len, rs->len);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"rock.h\"",
            "#include \"isofs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rock.h\"\n#include \"isofs.h\"\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n\nstatic int rock_check_overflow(struct rock_state *rs, int sig)\n{\n\tint len;\n\n\tswitch (sig) {\n\tcase SIG('S', 'P'):\n\t\tlen = sizeof(struct SU_SP_s);\n\t\tbreak;\n\tcase SIG('C', 'E'):\n\t\tlen = sizeof(struct SU_CE_s);\n\t\tbreak;\n\tcase SIG('E', 'R'):\n\t\tlen = sizeof(struct SU_ER_s);\n\t\tbreak;\n\tcase SIG('R', 'R'):\n\t\tlen = sizeof(struct RR_RR_s);\n\t\tbreak;\n\tcase SIG('P', 'X'):\n\t\tlen = sizeof(struct RR_PX_s);\n\t\tbreak;\n\tcase SIG('P', 'N'):\n\t\tlen = sizeof(struct RR_PN_s);\n\t\tbreak;\n\tcase SIG('S', 'L'):\n\t\tlen = sizeof(struct RR_SL_s);\n\t\tbreak;\n\tcase SIG('N', 'M'):\n\t\tlen = sizeof(struct RR_NM_s);\n\t\tbreak;\n\tcase SIG('C', 'L'):\n\t\tlen = sizeof(struct RR_CL_s);\n\t\tbreak;\n\tcase SIG('P', 'L'):\n\t\tlen = sizeof(struct RR_PL_s);\n\t\tbreak;\n\tcase SIG('T', 'F'):\n\t\tlen = sizeof(struct RR_TF_s);\n\t\tbreak;\n\tcase SIG('Z', 'F'):\n\t\tlen = sizeof(struct RR_ZF_s);\n\t\tbreak;\n\tdefault:\n\t\tlen = 0;\n\t\tbreak;\n\t}\n\tlen += offsetof(struct rock_ridge, u);\n\tif (len > rs->len) {\n\t\tprintk(KERN_NOTICE \"rock: directory entry would overflow \"\n\t\t\t\t\"storage\\n\");\n\t\tprintk(KERN_NOTICE \"rock: sig=0x%02x, size=%d, remaining=%d\\n\",\n\t\t\t\tsig, len, rs->len);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isonum_721",
          "args": [
            "rs.chr"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "isonum_721",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/isofs.h",
          "lines": "80-83",
          "snippet": "static inline unsigned int isonum_721(char *p)\n{\n\treturn get_unaligned_le16(p);\n}",
          "includes": [
            "#include <asm/unaligned.h>",
            "#include <linux/iso_fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unaligned.h>\n#include <linux/iso_fs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline unsigned int isonum_721(char *p)\n{\n\treturn get_unaligned_le16(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "setup_rock_ridge",
          "args": [
            "de",
            "inode",
            "&rs"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "setup_rock_ridge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/rock.c",
          "lines": "52-69",
          "snippet": "static void setup_rock_ridge(struct iso_directory_record *de,\n\t\t\tstruct inode *inode, struct rock_state *rs)\n{\n\trs->len = sizeof(struct iso_directory_record) + de->name_len[0];\n\tif (rs->len & 1)\n\t\t(rs->len)++;\n\trs->chr = (unsigned char *)de + rs->len;\n\trs->len = *((unsigned char *)de) - rs->len;\n\tif (rs->len < 0)\n\t\trs->len = 0;\n\n\tif (ISOFS_SB(inode->i_sb)->s_rock_offset != -1) {\n\t\trs->len -= ISOFS_SB(inode->i_sb)->s_rock_offset;\n\t\trs->chr += ISOFS_SB(inode->i_sb)->s_rock_offset;\n\t\tif (rs->len < 0)\n\t\t\trs->len = 0;\n\t}\n}",
          "includes": [
            "#include \"rock.h\"",
            "#include \"isofs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rock.h\"\n#include \"isofs.h\"\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n\nstatic void setup_rock_ridge(struct iso_directory_record *de,\n\t\t\tstruct inode *inode, struct rock_state *rs)\n{\n\trs->len = sizeof(struct iso_directory_record) + de->name_len[0];\n\tif (rs->len & 1)\n\t\t(rs->len)++;\n\trs->chr = (unsigned char *)de + rs->len;\n\trs->len = *((unsigned char *)de) - rs->len;\n\tif (rs->len < 0)\n\t\trs->len = 0;\n\n\tif (ISOFS_SB(inode->i_sb)->s_rock_offset != -1) {\n\t\trs->len -= ISOFS_SB(inode->i_sb)->s_rock_offset;\n\t\trs->chr += ISOFS_SB(inode->i_sb)->s_rock_offset;\n\t\tif (rs->len < 0)\n\t\t\trs->len = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_rock_state",
          "args": [
            "&rs",
            "inode"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "init_rock_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/rock.c",
          "lines": "71-75",
          "snippet": "static void init_rock_state(struct rock_state *rs, struct inode *inode)\n{\n\tmemset(rs, 0, sizeof(*rs));\n\trs->inode = inode;\n}",
          "includes": [
            "#include \"rock.h\"",
            "#include \"isofs.h\"",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rock.h\"\n#include \"isofs.h\"\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n\nstatic void init_rock_state(struct rock_state *rs, struct inode *inode)\n{\n\tmemset(rs, 0, sizeof(*rs));\n\trs->inode = inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ISOFS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "ISOFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/isofs.h",
          "lines": "62-65",
          "snippet": "static inline struct isofs_sb_info *ISOFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <asm/unaligned.h>",
            "#include <linux/iso_fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unaligned.h>\n#include <linux/iso_fs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline struct isofs_sb_info *ISOFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rock.h\"\n#include \"isofs.h\"\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n\nint get_rock_ridge_filename(struct iso_directory_record *de,\n\t\t\t    char *retname, struct inode *inode)\n{\n\tstruct rock_state rs;\n\tstruct rock_ridge *rr;\n\tint sig;\n\tint retnamlen = 0;\n\tint truncate = 0;\n\tint ret = 0;\n\n\tif (!ISOFS_SB(inode->i_sb)->s_rock)\n\t\treturn 0;\n\t*retname = 0;\n\n\tinit_rock_state(&rs, inode);\n\tsetup_rock_ridge(de, inode, &rs);\nrepeat:\n\n\twhile (rs.len > 2) { /* There may be one byte for padding somewhere */\n\t\trr = (struct rock_ridge *)rs.chr;\n\t\t/*\n\t\t * Ignore rock ridge info if rr->len is out of range, but\n\t\t * don't return -EIO because that would make the file\n\t\t * invisible.\n\t\t */\n\t\tif (rr->len < 3)\n\t\t\tgoto out;\t/* Something got screwed up here */\n\t\tsig = isonum_721(rs.chr);\n\t\tif (rock_check_overflow(&rs, sig))\n\t\t\tgoto eio;\n\t\trs.chr += rr->len;\n\t\trs.len -= rr->len;\n\t\t/*\n\t\t * As above, just ignore the rock ridge info if rr->len\n\t\t * is bogus.\n\t\t */\n\t\tif (rs.len < 0)\n\t\t\tgoto out;\t/* Something got screwed up here */\n\n\t\tswitch (sig) {\n\t\tcase SIG('R', 'R'):\n\t\t\tif ((rr->u.RR.flags[0] & RR_NM) == 0)\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase SIG('S', 'P'):\n\t\t\tif (check_sp(rr, inode))\n\t\t\t\tgoto out;\n\t\t\tbreak;\n\t\tcase SIG('C', 'E'):\n\t\t\trs.cont_extent = isonum_733(rr->u.CE.extent);\n\t\t\trs.cont_offset = isonum_733(rr->u.CE.offset);\n\t\t\trs.cont_size = isonum_733(rr->u.CE.size);\n\t\t\tbreak;\n\t\tcase SIG('N', 'M'):\n\t\t\tif (truncate)\n\t\t\t\tbreak;\n\t\t\tif (rr->len < 5)\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * If the flags are 2 or 4, this indicates '.' or '..'.\n\t\t\t * We don't want to do anything with this, because it\n\t\t\t * screws up the code that calls us.  We don't really\n\t\t\t * care anyways, since we can just use the non-RR\n\t\t\t * name.\n\t\t\t */\n\t\t\tif (rr->u.NM.flags & 6)\n\t\t\t\tbreak;\n\n\t\t\tif (rr->u.NM.flags & ~1) {\n\t\t\t\tprintk(\"Unsupported NM flag settings (%d)\\n\",\n\t\t\t\t\trr->u.NM.flags);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ((strlen(retname) + rr->len - 5) >= 254) {\n\t\t\t\ttruncate = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstrncat(retname, rr->u.NM.name, rr->len - 5);\n\t\t\tretnamlen += rr->len - 5;\n\t\t\tbreak;\n\t\tcase SIG('R', 'E'):\n\t\t\tkfree(rs.buffer);\n\t\t\treturn -1;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tret = rock_continue(&rs);\n\tif (ret == 0)\n\t\tgoto repeat;\n\tif (ret == 1)\n\t\treturn retnamlen; /* If 0, this file did not have a NM field */\nout:\n\tkfree(rs.buffer);\n\treturn ret;\neio:\n\tret = -EIO;\n\tgoto out;\n}"
  },
  {
    "function_name": "rock_check_overflow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/rock.c",
    "lines": "138-192",
    "snippet": "static int rock_check_overflow(struct rock_state *rs, int sig)\n{\n\tint len;\n\n\tswitch (sig) {\n\tcase SIG('S', 'P'):\n\t\tlen = sizeof(struct SU_SP_s);\n\t\tbreak;\n\tcase SIG('C', 'E'):\n\t\tlen = sizeof(struct SU_CE_s);\n\t\tbreak;\n\tcase SIG('E', 'R'):\n\t\tlen = sizeof(struct SU_ER_s);\n\t\tbreak;\n\tcase SIG('R', 'R'):\n\t\tlen = sizeof(struct RR_RR_s);\n\t\tbreak;\n\tcase SIG('P', 'X'):\n\t\tlen = sizeof(struct RR_PX_s);\n\t\tbreak;\n\tcase SIG('P', 'N'):\n\t\tlen = sizeof(struct RR_PN_s);\n\t\tbreak;\n\tcase SIG('S', 'L'):\n\t\tlen = sizeof(struct RR_SL_s);\n\t\tbreak;\n\tcase SIG('N', 'M'):\n\t\tlen = sizeof(struct RR_NM_s);\n\t\tbreak;\n\tcase SIG('C', 'L'):\n\t\tlen = sizeof(struct RR_CL_s);\n\t\tbreak;\n\tcase SIG('P', 'L'):\n\t\tlen = sizeof(struct RR_PL_s);\n\t\tbreak;\n\tcase SIG('T', 'F'):\n\t\tlen = sizeof(struct RR_TF_s);\n\t\tbreak;\n\tcase SIG('Z', 'F'):\n\t\tlen = sizeof(struct RR_ZF_s);\n\t\tbreak;\n\tdefault:\n\t\tlen = 0;\n\t\tbreak;\n\t}\n\tlen += offsetof(struct rock_ridge, u);\n\tif (len > rs->len) {\n\t\tprintk(KERN_NOTICE \"rock: directory entry would overflow \"\n\t\t\t\t\"storage\\n\");\n\t\tprintk(KERN_NOTICE \"rock: sig=0x%02x, size=%d, remaining=%d\\n\",\n\t\t\t\tsig, len, rs->len);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"rock.h\"",
      "#include \"isofs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_NOTICE \"rock: sig=0x%02x, size=%d, remaining=%d\\n\"",
            "sig",
            "len",
            "rs->len"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SIG",
          "args": [
            "'Z'",
            "'F'"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIG",
          "args": [
            "'T'",
            "'F'"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIG",
          "args": [
            "'P'",
            "'L'"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIG",
          "args": [
            "'C'",
            "'L'"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIG",
          "args": [
            "'N'",
            "'M'"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIG",
          "args": [
            "'S'",
            "'L'"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIG",
          "args": [
            "'P'",
            "'N'"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIG",
          "args": [
            "'P'",
            "'X'"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIG",
          "args": [
            "'R'",
            "'R'"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIG",
          "args": [
            "'E'",
            "'R'"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIG",
          "args": [
            "'C'",
            "'E'"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SIG",
          "args": [
            "'S'",
            "'P'"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rock.h\"\n#include \"isofs.h\"\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n\nstatic int rock_check_overflow(struct rock_state *rs, int sig)\n{\n\tint len;\n\n\tswitch (sig) {\n\tcase SIG('S', 'P'):\n\t\tlen = sizeof(struct SU_SP_s);\n\t\tbreak;\n\tcase SIG('C', 'E'):\n\t\tlen = sizeof(struct SU_CE_s);\n\t\tbreak;\n\tcase SIG('E', 'R'):\n\t\tlen = sizeof(struct SU_ER_s);\n\t\tbreak;\n\tcase SIG('R', 'R'):\n\t\tlen = sizeof(struct RR_RR_s);\n\t\tbreak;\n\tcase SIG('P', 'X'):\n\t\tlen = sizeof(struct RR_PX_s);\n\t\tbreak;\n\tcase SIG('P', 'N'):\n\t\tlen = sizeof(struct RR_PN_s);\n\t\tbreak;\n\tcase SIG('S', 'L'):\n\t\tlen = sizeof(struct RR_SL_s);\n\t\tbreak;\n\tcase SIG('N', 'M'):\n\t\tlen = sizeof(struct RR_NM_s);\n\t\tbreak;\n\tcase SIG('C', 'L'):\n\t\tlen = sizeof(struct RR_CL_s);\n\t\tbreak;\n\tcase SIG('P', 'L'):\n\t\tlen = sizeof(struct RR_PL_s);\n\t\tbreak;\n\tcase SIG('T', 'F'):\n\t\tlen = sizeof(struct RR_TF_s);\n\t\tbreak;\n\tcase SIG('Z', 'F'):\n\t\tlen = sizeof(struct RR_ZF_s);\n\t\tbreak;\n\tdefault:\n\t\tlen = 0;\n\t\tbreak;\n\t}\n\tlen += offsetof(struct rock_ridge, u);\n\tif (len > rs->len) {\n\t\tprintk(KERN_NOTICE \"rock: directory entry would overflow \"\n\t\t\t\t\"storage\\n\");\n\t\tprintk(KERN_NOTICE \"rock: sig=0x%02x, size=%d, remaining=%d\\n\",\n\t\t\t\tsig, len, rs->len);\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "rock_continue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/rock.c",
    "lines": "84-132",
    "snippet": "static int rock_continue(struct rock_state *rs)\n{\n\tint ret = 1;\n\tint blocksize = 1 << rs->inode->i_blkbits;\n\tconst int min_de_size = offsetof(struct rock_ridge, u);\n\n\tkfree(rs->buffer);\n\trs->buffer = NULL;\n\n\tif ((unsigned)rs->cont_offset > blocksize - min_de_size ||\n\t    (unsigned)rs->cont_size > blocksize ||\n\t    (unsigned)(rs->cont_offset + rs->cont_size) > blocksize) {\n\t\tprintk(KERN_NOTICE \"rock: corrupted directory entry. \"\n\t\t\t\"extent=%d, offset=%d, size=%d\\n\",\n\t\t\trs->cont_extent, rs->cont_offset, rs->cont_size);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tif (rs->cont_extent) {\n\t\tstruct buffer_head *bh;\n\n\t\trs->buffer = kmalloc(rs->cont_size, GFP_KERNEL);\n\t\tif (!rs->buffer) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = -EIO;\n\t\tif (++rs->cont_loops >= RR_MAX_CE_ENTRIES)\n\t\t\tgoto out;\n\t\tbh = sb_bread(rs->inode->i_sb, rs->cont_extent);\n\t\tif (bh) {\n\t\t\tmemcpy(rs->buffer, bh->b_data + rs->cont_offset,\n\t\t\t\t\trs->cont_size);\n\t\t\tput_bh(bh);\n\t\t\trs->chr = rs->buffer;\n\t\t\trs->len = rs->cont_size;\n\t\t\trs->cont_extent = 0;\n\t\t\trs->cont_size = 0;\n\t\t\trs->cont_offset = 0;\n\t\t\treturn 0;\n\t\t}\n\t\tprintk(\"Unable to read rock-ridge attributes\\n\");\n\t}\nout:\n\tkfree(rs->buffer);\n\trs->buffer = NULL;\n\treturn ret;\n}",
    "includes": [
      "#include \"rock.h\"",
      "#include \"isofs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define RR_MAX_CE_ENTRIES 32"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rs->buffer"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"Unable to read rock-ridge attributes\\n\""
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_bh",
          "args": [
            "bh"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "rs->buffer",
            "bh->b_data + rs->cont_offset",
            "rs->cont_size"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_bread",
          "args": [
            "rs->inode->i_sb",
            "rs->cont_extent"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "rs->cont_size",
            "GFP_KERNEL"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rs->buffer"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rock.h\"\n#include \"isofs.h\"\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n\n#define RR_MAX_CE_ENTRIES 32\n\nstatic int rock_continue(struct rock_state *rs)\n{\n\tint ret = 1;\n\tint blocksize = 1 << rs->inode->i_blkbits;\n\tconst int min_de_size = offsetof(struct rock_ridge, u);\n\n\tkfree(rs->buffer);\n\trs->buffer = NULL;\n\n\tif ((unsigned)rs->cont_offset > blocksize - min_de_size ||\n\t    (unsigned)rs->cont_size > blocksize ||\n\t    (unsigned)(rs->cont_offset + rs->cont_size) > blocksize) {\n\t\tprintk(KERN_NOTICE \"rock: corrupted directory entry. \"\n\t\t\t\"extent=%d, offset=%d, size=%d\\n\",\n\t\t\trs->cont_extent, rs->cont_offset, rs->cont_size);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tif (rs->cont_extent) {\n\t\tstruct buffer_head *bh;\n\n\t\trs->buffer = kmalloc(rs->cont_size, GFP_KERNEL);\n\t\tif (!rs->buffer) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tret = -EIO;\n\t\tif (++rs->cont_loops >= RR_MAX_CE_ENTRIES)\n\t\t\tgoto out;\n\t\tbh = sb_bread(rs->inode->i_sb, rs->cont_extent);\n\t\tif (bh) {\n\t\t\tmemcpy(rs->buffer, bh->b_data + rs->cont_offset,\n\t\t\t\t\trs->cont_size);\n\t\t\tput_bh(bh);\n\t\t\trs->chr = rs->buffer;\n\t\t\trs->len = rs->cont_size;\n\t\t\trs->cont_extent = 0;\n\t\t\trs->cont_size = 0;\n\t\t\trs->cont_offset = 0;\n\t\t\treturn 0;\n\t\t}\n\t\tprintk(\"Unable to read rock-ridge attributes\\n\");\n\t}\nout:\n\tkfree(rs->buffer);\n\trs->buffer = NULL;\n\treturn ret;\n}"
  },
  {
    "function_name": "init_rock_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/rock.c",
    "lines": "71-75",
    "snippet": "static void init_rock_state(struct rock_state *rs, struct inode *inode)\n{\n\tmemset(rs, 0, sizeof(*rs));\n\trs->inode = inode;\n}",
    "includes": [
      "#include \"rock.h\"",
      "#include \"isofs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "rs",
            "0",
            "sizeof(*rs)"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rock.h\"\n#include \"isofs.h\"\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n\nstatic void init_rock_state(struct rock_state *rs, struct inode *inode)\n{\n\tmemset(rs, 0, sizeof(*rs));\n\trs->inode = inode;\n}"
  },
  {
    "function_name": "setup_rock_ridge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/rock.c",
    "lines": "52-69",
    "snippet": "static void setup_rock_ridge(struct iso_directory_record *de,\n\t\t\tstruct inode *inode, struct rock_state *rs)\n{\n\trs->len = sizeof(struct iso_directory_record) + de->name_len[0];\n\tif (rs->len & 1)\n\t\t(rs->len)++;\n\trs->chr = (unsigned char *)de + rs->len;\n\trs->len = *((unsigned char *)de) - rs->len;\n\tif (rs->len < 0)\n\t\trs->len = 0;\n\n\tif (ISOFS_SB(inode->i_sb)->s_rock_offset != -1) {\n\t\trs->len -= ISOFS_SB(inode->i_sb)->s_rock_offset;\n\t\trs->chr += ISOFS_SB(inode->i_sb)->s_rock_offset;\n\t\tif (rs->len < 0)\n\t\t\trs->len = 0;\n\t}\n}",
    "includes": [
      "#include \"rock.h\"",
      "#include \"isofs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ISOFS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "ISOFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/isofs.h",
          "lines": "62-65",
          "snippet": "static inline struct isofs_sb_info *ISOFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <asm/unaligned.h>",
            "#include <linux/iso_fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unaligned.h>\n#include <linux/iso_fs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline struct isofs_sb_info *ISOFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rock.h\"\n#include \"isofs.h\"\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n\nstatic void setup_rock_ridge(struct iso_directory_record *de,\n\t\t\tstruct inode *inode, struct rock_state *rs)\n{\n\trs->len = sizeof(struct iso_directory_record) + de->name_len[0];\n\tif (rs->len & 1)\n\t\t(rs->len)++;\n\trs->chr = (unsigned char *)de + rs->len;\n\trs->len = *((unsigned char *)de) - rs->len;\n\tif (rs->len < 0)\n\t\trs->len = 0;\n\n\tif (ISOFS_SB(inode->i_sb)->s_rock_offset != -1) {\n\t\trs->len -= ISOFS_SB(inode->i_sb)->s_rock_offset;\n\t\trs->chr += ISOFS_SB(inode->i_sb)->s_rock_offset;\n\t\tif (rs->len < 0)\n\t\t\trs->len = 0;\n\t}\n}"
  },
  {
    "function_name": "check_sp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/rock.c",
    "lines": "42-50",
    "snippet": "static int check_sp(struct rock_ridge *rr, struct inode *inode)\n{\n\tif (rr->u.SP.magic[0] != 0xbe)\n\t\treturn -1;\n\tif (rr->u.SP.magic[1] != 0xef)\n\t\treturn -1;\n\tISOFS_SB(inode->i_sb)->s_rock_offset = rr->u.SP.skip;\n\treturn 0;\n}",
    "includes": [
      "#include \"rock.h\"",
      "#include \"isofs.h\"",
      "#include <linux/pagemap.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ISOFS_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "ISOFS_SB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/isofs/isofs.h",
          "lines": "62-65",
          "snippet": "static inline struct isofs_sb_info *ISOFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include <asm/unaligned.h>",
            "#include <linux/iso_fs.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/unaligned.h>\n#include <linux/iso_fs.h>\n#include <linux/exportfs.h>\n#include <linux/buffer_head.h>\n#include <linux/fs.h>\n\nstatic inline struct isofs_sb_info *ISOFS_SB(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rock.h\"\n#include \"isofs.h\"\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n\nstatic int check_sp(struct rock_ridge *rr, struct inode *inode)\n{\n\tif (rr->u.SP.magic[0] != 0xbe)\n\t\treturn -1;\n\tif (rr->u.SP.magic[1] != 0xef)\n\t\treturn -1;\n\tISOFS_SB(inode->i_sb)->s_rock_offset = rr->u.SP.skip;\n\treturn 0;\n}"
  }
]