[
  {
    "function_name": "afs_rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/dir.c",
    "lines": "1085-1123",
    "snippet": "static int afs_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\t      struct inode *new_dir, struct dentry *new_dentry)\n{\n\tstruct afs_vnode *orig_dvnode, *new_dvnode, *vnode;\n\tstruct key *key;\n\tint ret;\n\n\tvnode = AFS_FS_I(old_dentry->d_inode);\n\torig_dvnode = AFS_FS_I(old_dir);\n\tnew_dvnode = AFS_FS_I(new_dir);\n\n\t_enter(\"{%x:%u},{%x:%u},{%x:%u},{%pd}\",\n\t       orig_dvnode->fid.vid, orig_dvnode->fid.vnode,\n\t       vnode->fid.vid, vnode->fid.vnode,\n\t       new_dvnode->fid.vid, new_dvnode->fid.vnode,\n\t       new_dentry);\n\n\tkey = afs_request_key(orig_dvnode->volume->cell);\n\tif (IS_ERR(key)) {\n\t\tret = PTR_ERR(key);\n\t\tgoto error;\n\t}\n\n\tret = afs_vnode_rename(orig_dvnode, new_dvnode, key,\n\t\t\t       old_dentry->d_name.name,\n\t\t\t       new_dentry->d_name.name);\n\tif (ret < 0)\n\t\tgoto rename_error;\n\tkey_put(key);\n\t_leave(\" = 0\");\n\treturn 0;\n\nrename_error:\n\tkey_put(key);\nerror:\n\td_drop(new_dentry);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int afs_d_delete(const struct dentry *dentry);",
      "static void afs_d_release(struct dentry *dentry);",
      "static int afs_rmdir(struct inode *dir, struct dentry *dentry);",
      "static int afs_unlink(struct inode *dir, struct dentry *dentry);",
      "static int afs_link(struct dentry *from, struct inode *dir,\n\t\t    struct dentry *dentry);",
      "static int afs_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\t      struct inode *new_dir, struct dentry *new_dentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 1121
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_drop",
          "args": [
            "new_dentry"
          ],
          "line": 1120
        },
        "resolved": true,
        "details": {
          "function_name": "check_and_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1447-1453",
          "snippet": "static void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "key"
          ],
          "line": 1118
        },
        "resolved": true,
        "details": {
          "function_name": "expkey_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "40-49",
          "snippet": "static void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree(key);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\n\nstatic void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree(key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = 0\""
          ],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_vnode_rename",
          "args": [
            "orig_dvnode",
            "new_dvnode",
            "key",
            "old_dentry->d_name.name",
            "new_dentry->d_name.name"
          ],
          "line": 1108
        },
        "resolved": true,
        "details": {
          "function_name": "afs_vnode_rename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vnode.c",
          "lines": "690-764",
          "snippet": "int afs_vnode_rename(struct afs_vnode *orig_dvnode,\n\t\t     struct afs_vnode *new_dvnode,\n\t\t     struct key *key,\n\t\t     const char *orig_name,\n\t\t     const char *new_name)\n{\n\tstruct afs_server *server;\n\tint ret;\n\n\t_enter(\"%s{%x:%u.%u},%s{%u,%u,%u},%x,%s,%s\",\n\t       orig_dvnode->volume->vlocation->vldb.name,\n\t       orig_dvnode->fid.vid,\n\t       orig_dvnode->fid.vnode,\n\t       orig_dvnode->fid.unique,\n\t       new_dvnode->volume->vlocation->vldb.name,\n\t       new_dvnode->fid.vid,\n\t       new_dvnode->fid.vnode,\n\t       new_dvnode->fid.unique,\n\t       key_serial(key),\n\t       orig_name,\n\t       new_name);\n\n\t/* this op will fetch the status on both the directories we're dealing\n\t * with */\n\tspin_lock(&orig_dvnode->lock);\n\torig_dvnode->update_cnt++;\n\tspin_unlock(&orig_dvnode->lock);\n\tif (new_dvnode != orig_dvnode) {\n\t\tspin_lock(&new_dvnode->lock);\n\t\tnew_dvnode->update_cnt++;\n\t\tspin_unlock(&new_dvnode->lock);\n\t}\n\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(orig_dvnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %08x\\n\", ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_rename(server, key, orig_dvnode, orig_name,\n\t\t\t\t    new_dvnode, new_name, &afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(orig_dvnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0) {\n\t\tafs_vnode_finalise_status_update(orig_dvnode, server);\n\t\tif (new_dvnode != orig_dvnode)\n\t\t\tafs_vnode_finalise_status_update(new_dvnode, server);\n\t\tafs_put_server(server);\n\t} else {\n\t\tafs_vnode_status_update_failed(orig_dvnode, ret);\n\t\tif (new_dvnode != orig_dvnode)\n\t\t\tafs_vnode_status_update_failed(new_dvnode, ret);\n\t}\n\n\t_leave(\" = %d [cnt %d]\", ret, orig_dvnode->update_cnt);\n\treturn ret;\n\nno_server:\n\tspin_lock(&orig_dvnode->lock);\n\torig_dvnode->update_cnt--;\n\tASSERTCMP(orig_dvnode->update_cnt, >=, 0);\n\tspin_unlock(&orig_dvnode->lock);\n\tif (new_dvnode != orig_dvnode) {\n\t\tspin_lock(&new_dvnode->lock);\n\t\tnew_dvnode->update_cnt--;\n\t\tASSERTCMP(new_dvnode->update_cnt, >=, 0);\n\t\tspin_unlock(&new_dvnode->lock);\n\t}\n\t_leave(\" = %ld [cnt %d]\", PTR_ERR(server), orig_dvnode->update_cnt);\n\treturn PTR_ERR(server);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint afs_vnode_rename(struct afs_vnode *orig_dvnode,\n\t\t     struct afs_vnode *new_dvnode,\n\t\t     struct key *key,\n\t\t     const char *orig_name,\n\t\t     const char *new_name)\n{\n\tstruct afs_server *server;\n\tint ret;\n\n\t_enter(\"%s{%x:%u.%u},%s{%u,%u,%u},%x,%s,%s\",\n\t       orig_dvnode->volume->vlocation->vldb.name,\n\t       orig_dvnode->fid.vid,\n\t       orig_dvnode->fid.vnode,\n\t       orig_dvnode->fid.unique,\n\t       new_dvnode->volume->vlocation->vldb.name,\n\t       new_dvnode->fid.vid,\n\t       new_dvnode->fid.vnode,\n\t       new_dvnode->fid.unique,\n\t       key_serial(key),\n\t       orig_name,\n\t       new_name);\n\n\t/* this op will fetch the status on both the directories we're dealing\n\t * with */\n\tspin_lock(&orig_dvnode->lock);\n\torig_dvnode->update_cnt++;\n\tspin_unlock(&orig_dvnode->lock);\n\tif (new_dvnode != orig_dvnode) {\n\t\tspin_lock(&new_dvnode->lock);\n\t\tnew_dvnode->update_cnt++;\n\t\tspin_unlock(&new_dvnode->lock);\n\t}\n\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(orig_dvnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %08x\\n\", ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_rename(server, key, orig_dvnode, orig_name,\n\t\t\t\t    new_dvnode, new_name, &afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(orig_dvnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0) {\n\t\tafs_vnode_finalise_status_update(orig_dvnode, server);\n\t\tif (new_dvnode != orig_dvnode)\n\t\t\tafs_vnode_finalise_status_update(new_dvnode, server);\n\t\tafs_put_server(server);\n\t} else {\n\t\tafs_vnode_status_update_failed(orig_dvnode, ret);\n\t\tif (new_dvnode != orig_dvnode)\n\t\t\tafs_vnode_status_update_failed(new_dvnode, ret);\n\t}\n\n\t_leave(\" = %d [cnt %d]\", ret, orig_dvnode->update_cnt);\n\treturn ret;\n\nno_server:\n\tspin_lock(&orig_dvnode->lock);\n\torig_dvnode->update_cnt--;\n\tASSERTCMP(orig_dvnode->update_cnt, >=, 0);\n\tspin_unlock(&orig_dvnode->lock);\n\tif (new_dvnode != orig_dvnode) {\n\t\tspin_lock(&new_dvnode->lock);\n\t\tnew_dvnode->update_cnt--;\n\t\tASSERTCMP(new_dvnode->update_cnt, >=, 0);\n\t\tspin_unlock(&new_dvnode->lock);\n\t}\n\t_leave(\" = %ld [cnt %d]\", PTR_ERR(server), orig_dvnode->update_cnt);\n\treturn PTR_ERR(server);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "key"
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "key"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_request_key",
          "args": [
            "orig_dvnode->volume->cell"
          ],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "afs_request_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/security.c",
          "lines": "23-46",
          "snippet": "struct key *afs_request_key(struct afs_cell *cell)\n{\n\tstruct key *key;\n\n\t_enter(\"{%x}\", key_serial(cell->anonymous_key));\n\n\t_debug(\"key %s\", cell->anonymous_key->description);\n\tkey = request_key(&key_type_rxrpc, cell->anonymous_key->description,\n\t\t\t  NULL);\n\tif (IS_ERR(key)) {\n\t\tif (PTR_ERR(key) != -ENOKEY) {\n\t\t\t_leave(\" = %ld\", PTR_ERR(key));\n\t\t\treturn key;\n\t\t}\n\n\t\t/* act as anonymous user */\n\t\t_leave(\" = {%x} [anon]\", key_serial(cell->anonymous_key));\n\t\treturn key_get(cell->anonymous_key);\n\t} else {\n\t\t/* act as authorised user */\n\t\t_leave(\" = {%x} [auth]\", key_serial(key));\n\t\treturn key;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <keys/rxrpc-type.h>",
            "#include <linux/sched.h>",
            "#include <linux/ctype.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <keys/rxrpc-type.h>\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstruct key *afs_request_key(struct afs_cell *cell)\n{\n\tstruct key *key;\n\n\t_enter(\"{%x}\", key_serial(cell->anonymous_key));\n\n\t_debug(\"key %s\", cell->anonymous_key->description);\n\tkey = request_key(&key_type_rxrpc, cell->anonymous_key->description,\n\t\t\t  NULL);\n\tif (IS_ERR(key)) {\n\t\tif (PTR_ERR(key) != -ENOKEY) {\n\t\t\t_leave(\" = %ld\", PTR_ERR(key));\n\t\t\treturn key;\n\t\t}\n\n\t\t/* act as anonymous user */\n\t\t_leave(\" = {%x} [anon]\", key_serial(cell->anonymous_key));\n\t\treturn key_get(cell->anonymous_key);\n\t} else {\n\t\t/* act as authorised user */\n\t\t_leave(\" = {%x} [auth]\", key_serial(key));\n\t\treturn key;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%x:%u},{%x:%u},{%x:%u},{%pd}\"",
            "orig_dvnode->fid.vid",
            "orig_dvnode->fid.vnode",
            "vnode->fid.vid",
            "vnode->fid.vnode",
            "new_dvnode->fid.vid",
            "new_dvnode->fid.vnode",
            "new_dentry"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFS_FS_I",
          "args": [
            "new_dir"
          ],
          "line": 1094
        },
        "resolved": true,
        "details": {
          "function_name": "AFS_FS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/internal.h",
          "lines": "687-690",
          "snippet": "static inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}",
          "includes": [
            "#include \"afs_vl.h\"",
            "#include \"afs.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/fscache.h>",
            "#include <linux/sched.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/key.h>",
            "#include <linux/rxrpc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void afs_discard_callback_on_delete(struct afs_vnode *);",
            "extern void afs_give_up_callback(struct afs_vnode *);",
            "extern void afs_lock_may_be_available(struct afs_vnode *);",
            "extern void afs_zap_data(struct afs_vnode *);",
            "extern void afs_evict_inode(struct inode *);",
            "extern int afs_drop_inode(struct inode *);",
            "extern void afs_clear_permits(struct afs_vnode *);",
            "extern int afs_permission(struct inode *, int);",
            "extern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);",
            "extern int afs_writeback_all(struct afs_vnode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_vl.h\"\n#include \"afs.h\"\n#include <linux/backing-dev.h>\n#include <linux/fscache.h>\n#include <linux/sched.h>\n#include <linux/workqueue.h>\n#include <linux/key.h>\n#include <linux/rxrpc.h>\n#include <linux/skbuff.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n\nextern void afs_discard_callback_on_delete(struct afs_vnode *);\nextern void afs_give_up_callback(struct afs_vnode *);\nextern void afs_lock_may_be_available(struct afs_vnode *);\nextern void afs_zap_data(struct afs_vnode *);\nextern void afs_evict_inode(struct inode *);\nextern int afs_drop_inode(struct inode *);\nextern void afs_clear_permits(struct afs_vnode *);\nextern int afs_permission(struct inode *, int);\nextern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);\nextern int afs_writeback_all(struct afs_vnode *);\n\nstatic inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int afs_d_delete(const struct dentry *dentry);\nstatic void afs_d_release(struct dentry *dentry);\nstatic int afs_rmdir(struct inode *dir, struct dentry *dentry);\nstatic int afs_unlink(struct inode *dir, struct dentry *dentry);\nstatic int afs_link(struct dentry *from, struct inode *dir,\n\t\t    struct dentry *dentry);\nstatic int afs_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\t      struct inode *new_dir, struct dentry *new_dentry);\n\nstatic int afs_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\t      struct inode *new_dir, struct dentry *new_dentry)\n{\n\tstruct afs_vnode *orig_dvnode, *new_dvnode, *vnode;\n\tstruct key *key;\n\tint ret;\n\n\tvnode = AFS_FS_I(old_dentry->d_inode);\n\torig_dvnode = AFS_FS_I(old_dir);\n\tnew_dvnode = AFS_FS_I(new_dir);\n\n\t_enter(\"{%x:%u},{%x:%u},{%x:%u},{%pd}\",\n\t       orig_dvnode->fid.vid, orig_dvnode->fid.vnode,\n\t       vnode->fid.vid, vnode->fid.vnode,\n\t       new_dvnode->fid.vid, new_dvnode->fid.vnode,\n\t       new_dentry);\n\n\tkey = afs_request_key(orig_dvnode->volume->cell);\n\tif (IS_ERR(key)) {\n\t\tret = PTR_ERR(key);\n\t\tgoto error;\n\t}\n\n\tret = afs_vnode_rename(orig_dvnode, new_dvnode, key,\n\t\t\t       old_dentry->d_name.name,\n\t\t\t       new_dentry->d_name.name);\n\tif (ret < 0)\n\t\tgoto rename_error;\n\tkey_put(key);\n\t_leave(\" = 0\");\n\treturn 0;\n\nrename_error:\n\tkey_put(key);\nerror:\n\td_drop(new_dentry);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "afs_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/dir.c",
    "lines": "1015-1080",
    "snippet": "static int afs_symlink(struct inode *dir, struct dentry *dentry,\n\t\t       const char *content)\n{\n\tstruct afs_file_status status;\n\tstruct afs_server *server;\n\tstruct afs_vnode *dvnode, *vnode;\n\tstruct afs_fid fid;\n\tstruct inode *inode;\n\tstruct key *key;\n\tint ret;\n\n\tdvnode = AFS_FS_I(dir);\n\n\t_enter(\"{%x:%u},{%pd},%s\",\n\t       dvnode->fid.vid, dvnode->fid.vnode, dentry,\n\t       content);\n\n\tret = -EINVAL;\n\tif (strlen(content) >= AFSPATHMAX)\n\t\tgoto error;\n\n\tkey = afs_request_key(dvnode->volume->cell);\n\tif (IS_ERR(key)) {\n\t\tret = PTR_ERR(key);\n\t\tgoto error;\n\t}\n\n\tret = afs_vnode_symlink(dvnode, key, dentry->d_name.name, content,\n\t\t\t\t&fid, &status, &server);\n\tif (ret < 0)\n\t\tgoto create_error;\n\n\tinode = afs_iget(dir->i_sb, key, &fid, &status, NULL);\n\tif (IS_ERR(inode)) {\n\t\t/* ENOMEM at a really inconvenient time - just abandon the new\n\t\t * directory on the server */\n\t\tret = PTR_ERR(inode);\n\t\tgoto iget_error;\n\t}\n\n\t/* apply the status report we've got for the new vnode */\n\tvnode = AFS_FS_I(inode);\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt++;\n\tspin_unlock(&vnode->lock);\n\tafs_vnode_finalise_status_update(vnode, server);\n\tafs_put_server(server);\n\n\td_instantiate(dentry, inode);\n\tif (d_unhashed(dentry)) {\n\t\t_debug(\"not hashed\");\n\t\td_rehash(dentry);\n\t}\n\tkey_put(key);\n\t_leave(\" = 0\");\n\treturn 0;\n\niget_error:\n\tafs_put_server(server);\ncreate_error:\n\tkey_put(key);\nerror:\n\td_drop(dentry);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int afs_d_delete(const struct dentry *dentry);",
      "static void afs_d_release(struct dentry *dentry);",
      "static int afs_rmdir(struct inode *dir, struct dentry *dentry);",
      "static int afs_unlink(struct inode *dir, struct dentry *dentry);",
      "static int afs_link(struct dentry *from, struct inode *dir,\n\t\t    struct dentry *dentry);",
      "static int afs_symlink(struct inode *dir, struct dentry *dentry,\n\t\t       const char *content);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 1078
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_drop",
          "args": [
            "dentry"
          ],
          "line": 1077
        },
        "resolved": true,
        "details": {
          "function_name": "check_and_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1447-1453",
          "snippet": "static void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "key"
          ],
          "line": 1075
        },
        "resolved": true,
        "details": {
          "function_name": "expkey_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "40-49",
          "snippet": "static void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree(key);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\n\nstatic void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree(key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_put_server",
          "args": [
            "server"
          ],
          "line": 1073
        },
        "resolved": true,
        "details": {
          "function_name": "afs_put_server",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/server.c",
          "lines": "219-246",
          "snippet": "void afs_put_server(struct afs_server *server)\n{\n\tif (!server)\n\t\treturn;\n\n\t_enter(\"%p{%d}\", server, atomic_read(&server->usage));\n\n\t_debug(\"PUT SERVER %d\", atomic_read(&server->usage));\n\n\tASSERTCMP(atomic_read(&server->usage), >, 0);\n\n\tif (likely(!atomic_dec_and_test(&server->usage))) {\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tafs_flush_callback_breaks(server);\n\n\tspin_lock(&afs_server_graveyard_lock);\n\tif (atomic_read(&server->usage) == 0) {\n\t\tlist_move_tail(&server->grave, &afs_server_graveyard);\n\t\tserver->time_of_death = get_seconds();\n\t\tqueue_delayed_work(afs_wq, &afs_server_reaper,\n\t\t\t\t   afs_server_timeout * HZ);\n\t}\n\tspin_unlock(&afs_server_graveyard_lock);\n\t_leave(\" [dead]\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned afs_server_timeout = 10;",
            "static LIST_HEAD(afs_server_graveyard);",
            "static DEFINE_SPINLOCK(afs_server_graveyard_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic unsigned afs_server_timeout = 10;\nstatic LIST_HEAD(afs_server_graveyard);\nstatic DEFINE_SPINLOCK(afs_server_graveyard_lock);\n\nvoid afs_put_server(struct afs_server *server)\n{\n\tif (!server)\n\t\treturn;\n\n\t_enter(\"%p{%d}\", server, atomic_read(&server->usage));\n\n\t_debug(\"PUT SERVER %d\", atomic_read(&server->usage));\n\n\tASSERTCMP(atomic_read(&server->usage), >, 0);\n\n\tif (likely(!atomic_dec_and_test(&server->usage))) {\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tafs_flush_callback_breaks(server);\n\n\tspin_lock(&afs_server_graveyard_lock);\n\tif (atomic_read(&server->usage) == 0) {\n\t\tlist_move_tail(&server->grave, &afs_server_graveyard);\n\t\tserver->time_of_death = get_seconds();\n\t\tqueue_delayed_work(afs_wq, &afs_server_reaper,\n\t\t\t\t   afs_server_timeout * HZ);\n\t}\n\tspin_unlock(&afs_server_graveyard_lock);\n\t_leave(\" [dead]\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = 0\""
          ],
          "line": 1069
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_rehash",
          "args": [
            "dentry"
          ],
          "line": 1066
        },
        "resolved": true,
        "details": {
          "function_name": "d_rehash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2403-2408",
          "snippet": "void d_rehash(struct dentry * entry)\n{\n\tspin_lock(&entry->d_lock);\n\t_d_rehash(entry);\n\tspin_unlock(&entry->d_lock);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid d_rehash(struct dentry * entry)\n{\n\tspin_lock(&entry->d_lock);\n\t_d_rehash(entry);\n\tspin_unlock(&entry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"not hashed\""
          ],
          "line": 1065
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_suballoc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2634-2662",
          "snippet": "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_unhashed",
          "args": [
            "dentry"
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 1063
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_vnode_finalise_status_update",
          "args": [
            "vnode",
            "server"
          ],
          "line": 1060
        },
        "resolved": true,
        "details": {
          "function_name": "afs_vnode_finalise_status_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vnode.c",
          "lines": "213-230",
          "snippet": "void afs_vnode_finalise_status_update(struct afs_vnode *vnode,\n\t\t\t\t      struct afs_server *server)\n{\n\tstruct afs_server *oldserver = NULL;\n\n\t_enter(\"%p,%p\", vnode, server);\n\n\tspin_lock(&vnode->lock);\n\tclear_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\tafs_vnode_note_promise(vnode, server);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\n\twake_up_all(&vnode->update_waitq);\n\tafs_put_server(oldserver);\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nvoid afs_vnode_finalise_status_update(struct afs_vnode *vnode,\n\t\t\t\t      struct afs_server *server)\n{\n\tstruct afs_server *oldserver = NULL;\n\n\t_enter(\"%p,%p\", vnode, server);\n\n\tspin_lock(&vnode->lock);\n\tclear_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\tafs_vnode_note_promise(vnode, server);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\n\twake_up_all(&vnode->update_waitq);\n\tafs_put_server(oldserver);\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vnode->lock"
          ],
          "line": 1059
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&vnode->lock"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "AFS_FS_I",
          "args": [
            "inode"
          ],
          "line": 1056
        },
        "resolved": true,
        "details": {
          "function_name": "AFS_FS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/internal.h",
          "lines": "687-690",
          "snippet": "static inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}",
          "includes": [
            "#include \"afs_vl.h\"",
            "#include \"afs.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/fscache.h>",
            "#include <linux/sched.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/key.h>",
            "#include <linux/rxrpc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void afs_discard_callback_on_delete(struct afs_vnode *);",
            "extern void afs_give_up_callback(struct afs_vnode *);",
            "extern void afs_lock_may_be_available(struct afs_vnode *);",
            "extern void afs_zap_data(struct afs_vnode *);",
            "extern void afs_evict_inode(struct inode *);",
            "extern int afs_drop_inode(struct inode *);",
            "extern void afs_clear_permits(struct afs_vnode *);",
            "extern int afs_permission(struct inode *, int);",
            "extern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);",
            "extern int afs_writeback_all(struct afs_vnode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_vl.h\"\n#include \"afs.h\"\n#include <linux/backing-dev.h>\n#include <linux/fscache.h>\n#include <linux/sched.h>\n#include <linux/workqueue.h>\n#include <linux/key.h>\n#include <linux/rxrpc.h>\n#include <linux/skbuff.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n\nextern void afs_discard_callback_on_delete(struct afs_vnode *);\nextern void afs_give_up_callback(struct afs_vnode *);\nextern void afs_lock_may_be_available(struct afs_vnode *);\nextern void afs_zap_data(struct afs_vnode *);\nextern void afs_evict_inode(struct inode *);\nextern int afs_drop_inode(struct inode *);\nextern void afs_clear_permits(struct afs_vnode *);\nextern int afs_permission(struct inode *, int);\nextern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);\nextern int afs_writeback_all(struct afs_vnode *);\n\nstatic inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_iget",
          "args": [
            "dir->i_sb",
            "key",
            "&fid",
            "&status",
            "NULL"
          ],
          "line": 1047
        },
        "resolved": true,
        "details": {
          "function_name": "afs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/inode.c",
          "lines": "198-285",
          "snippet": "struct inode *afs_iget(struct super_block *sb, struct key *key,\n\t\t       struct afs_fid *fid, struct afs_file_status *status,\n\t\t       struct afs_callback *cb)\n{\n\tstruct afs_iget_data data = { .fid = *fid };\n\tstruct afs_super_info *as;\n\tstruct afs_vnode *vnode;\n\tstruct inode *inode;\n\tint ret;\n\n\t_enter(\",{%x:%u.%u},,\", fid->vid, fid->vnode, fid->unique);\n\n\tas = sb->s_fs_info;\n\tdata.volume = as->volume;\n\n\tinode = iget5_locked(sb, fid->vnode, afs_iget5_test, afs_iget5_set,\n\t\t\t     &data);\n\tif (!inode) {\n\t\t_leave(\" = -ENOMEM\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t_debug(\"GOT INODE %p { vl=%x vn=%x, u=%x }\",\n\t       inode, fid->vid, fid->vnode, fid->unique);\n\n\tvnode = AFS_FS_I(inode);\n\n\t/* deal with an existing inode */\n\tif (!(inode->i_state & I_NEW)) {\n\t\t_leave(\" = %p\", inode);\n\t\treturn inode;\n\t}\n\n\tif (!status) {\n\t\t/* it's a remotely extant inode */\n\t\tset_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\t\tret = afs_vnode_fetch_status(vnode, NULL, key);\n\t\tif (ret < 0)\n\t\t\tgoto bad_inode;\n\t} else {\n\t\t/* it's an inode we just created */\n\t\tmemcpy(&vnode->status, status, sizeof(vnode->status));\n\n\t\tif (!cb) {\n\t\t\t/* it's a symlink we just created (the fileserver\n\t\t\t * didn't give us a callback) */\n\t\t\tvnode->cb_version = 0;\n\t\t\tvnode->cb_expiry = 0;\n\t\t\tvnode->cb_type = 0;\n\t\t\tvnode->cb_expires = get_seconds();\n\t\t} else {\n\t\t\tvnode->cb_version = cb->version;\n\t\t\tvnode->cb_expiry = cb->expiry;\n\t\t\tvnode->cb_type = cb->type;\n\t\t\tvnode->cb_expires = vnode->cb_expiry + get_seconds();\n\t\t}\n\t}\n\n\t/* set up caching before mapping the status, as map-status reads the\n\t * first page of symlinks to see if they're really mountpoints */\n\tinode->i_size = vnode->status.size;\n#ifdef CONFIG_AFS_FSCACHE\n\tvnode->cache = fscache_acquire_cookie(vnode->volume->cache,\n\t\t\t\t\t      &afs_vnode_cache_index_def,\n\t\t\t\t\t      vnode, true);\n#endif\n\n\tret = afs_inode_map_status(vnode, key);\n\tif (ret < 0)\n\t\tgoto bad_inode;\n\n\t/* success */\n\tclear_bit(AFS_VNODE_UNSET, &vnode->flags);\n\tinode->i_flags |= S_NOATIME;\n\tunlock_new_inode(inode);\n\t_leave(\" = %p [CB { v=%u t=%u }]\", inode, vnode->cb_version, vnode->cb_type);\n\treturn inode;\n\n\t/* failure */\nbad_inode:\n#ifdef CONFIG_AFS_FSCACHE\n\tfscache_relinquish_cookie(vnode->cache, 0);\n\tvnode->cache = NULL;\n#endif\n\tiget_failed(inode);\n\t_leave(\" = %d [bad]\", ret);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstruct inode *afs_iget(struct super_block *sb, struct key *key,\n\t\t       struct afs_fid *fid, struct afs_file_status *status,\n\t\t       struct afs_callback *cb)\n{\n\tstruct afs_iget_data data = { .fid = *fid };\n\tstruct afs_super_info *as;\n\tstruct afs_vnode *vnode;\n\tstruct inode *inode;\n\tint ret;\n\n\t_enter(\",{%x:%u.%u},,\", fid->vid, fid->vnode, fid->unique);\n\n\tas = sb->s_fs_info;\n\tdata.volume = as->volume;\n\n\tinode = iget5_locked(sb, fid->vnode, afs_iget5_test, afs_iget5_set,\n\t\t\t     &data);\n\tif (!inode) {\n\t\t_leave(\" = -ENOMEM\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t_debug(\"GOT INODE %p { vl=%x vn=%x, u=%x }\",\n\t       inode, fid->vid, fid->vnode, fid->unique);\n\n\tvnode = AFS_FS_I(inode);\n\n\t/* deal with an existing inode */\n\tif (!(inode->i_state & I_NEW)) {\n\t\t_leave(\" = %p\", inode);\n\t\treturn inode;\n\t}\n\n\tif (!status) {\n\t\t/* it's a remotely extant inode */\n\t\tset_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\t\tret = afs_vnode_fetch_status(vnode, NULL, key);\n\t\tif (ret < 0)\n\t\t\tgoto bad_inode;\n\t} else {\n\t\t/* it's an inode we just created */\n\t\tmemcpy(&vnode->status, status, sizeof(vnode->status));\n\n\t\tif (!cb) {\n\t\t\t/* it's a symlink we just created (the fileserver\n\t\t\t * didn't give us a callback) */\n\t\t\tvnode->cb_version = 0;\n\t\t\tvnode->cb_expiry = 0;\n\t\t\tvnode->cb_type = 0;\n\t\t\tvnode->cb_expires = get_seconds();\n\t\t} else {\n\t\t\tvnode->cb_version = cb->version;\n\t\t\tvnode->cb_expiry = cb->expiry;\n\t\t\tvnode->cb_type = cb->type;\n\t\t\tvnode->cb_expires = vnode->cb_expiry + get_seconds();\n\t\t}\n\t}\n\n\t/* set up caching before mapping the status, as map-status reads the\n\t * first page of symlinks to see if they're really mountpoints */\n\tinode->i_size = vnode->status.size;\n#ifdef CONFIG_AFS_FSCACHE\n\tvnode->cache = fscache_acquire_cookie(vnode->volume->cache,\n\t\t\t\t\t      &afs_vnode_cache_index_def,\n\t\t\t\t\t      vnode, true);\n#endif\n\n\tret = afs_inode_map_status(vnode, key);\n\tif (ret < 0)\n\t\tgoto bad_inode;\n\n\t/* success */\n\tclear_bit(AFS_VNODE_UNSET, &vnode->flags);\n\tinode->i_flags |= S_NOATIME;\n\tunlock_new_inode(inode);\n\t_leave(\" = %p [CB { v=%u t=%u }]\", inode, vnode->cb_version, vnode->cb_type);\n\treturn inode;\n\n\t/* failure */\nbad_inode:\n#ifdef CONFIG_AFS_FSCACHE\n\tfscache_relinquish_cookie(vnode->cache, 0);\n\tvnode->cache = NULL;\n#endif\n\tiget_failed(inode);\n\t_leave(\" = %d [bad]\", ret);\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_vnode_symlink",
          "args": [
            "dvnode",
            "key",
            "dentry->d_name.name",
            "content",
            "&fid",
            "&status",
            "&server"
          ],
          "line": 1042
        },
        "resolved": true,
        "details": {
          "function_name": "afs_vnode_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vnode.c",
          "lines": "631-685",
          "snippet": "int afs_vnode_symlink(struct afs_vnode *vnode, struct key *key,\n\t\t      const char *name, const char *content,\n\t\t      struct afs_fid *newfid,\n\t\t      struct afs_file_status *newstatus,\n\t\t      struct afs_server **_server)\n{\n\tstruct afs_server *server;\n\tint ret;\n\n\t_enter(\"%s{%x:%u.%u},%x,%s,%s,,,\",\n\t       vnode->volume->vlocation->vldb.name,\n\t       vnode->fid.vid,\n\t       vnode->fid.vnode,\n\t       vnode->fid.unique,\n\t       key_serial(key),\n\t       name, content);\n\n\t/* this op will fetch the status on the directory we're creating in */\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt++;\n\tspin_unlock(&vnode->lock);\n\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(vnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %08x\\n\", ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_symlink(server, key, vnode, name, content,\n\t\t\t\t     newfid, newstatus, &afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(vnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0) {\n\t\tafs_vnode_finalise_status_update(vnode, server);\n\t\t*_server = server;\n\t} else {\n\t\tafs_vnode_status_update_failed(vnode, ret);\n\t\t*_server = NULL;\n\t}\n\n\t_leave(\" = %d [cnt %d]\", ret, vnode->update_cnt);\n\treturn ret;\n\nno_server:\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\t_leave(\" = %ld [cnt %d]\", PTR_ERR(server), vnode->update_cnt);\n\treturn PTR_ERR(server);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint afs_vnode_symlink(struct afs_vnode *vnode, struct key *key,\n\t\t      const char *name, const char *content,\n\t\t      struct afs_fid *newfid,\n\t\t      struct afs_file_status *newstatus,\n\t\t      struct afs_server **_server)\n{\n\tstruct afs_server *server;\n\tint ret;\n\n\t_enter(\"%s{%x:%u.%u},%x,%s,%s,,,\",\n\t       vnode->volume->vlocation->vldb.name,\n\t       vnode->fid.vid,\n\t       vnode->fid.vnode,\n\t       vnode->fid.unique,\n\t       key_serial(key),\n\t       name, content);\n\n\t/* this op will fetch the status on the directory we're creating in */\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt++;\n\tspin_unlock(&vnode->lock);\n\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(vnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %08x\\n\", ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_symlink(server, key, vnode, name, content,\n\t\t\t\t     newfid, newstatus, &afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(vnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0) {\n\t\tafs_vnode_finalise_status_update(vnode, server);\n\t\t*_server = server;\n\t} else {\n\t\tafs_vnode_status_update_failed(vnode, ret);\n\t\t*_server = NULL;\n\t}\n\n\t_leave(\" = %d [cnt %d]\", ret, vnode->update_cnt);\n\treturn ret;\n\nno_server:\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\t_leave(\" = %ld [cnt %d]\", PTR_ERR(server), vnode->update_cnt);\n\treturn PTR_ERR(server);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "key"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "key"
          ],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_request_key",
          "args": [
            "dvnode->volume->cell"
          ],
          "line": 1036
        },
        "resolved": true,
        "details": {
          "function_name": "afs_request_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/security.c",
          "lines": "23-46",
          "snippet": "struct key *afs_request_key(struct afs_cell *cell)\n{\n\tstruct key *key;\n\n\t_enter(\"{%x}\", key_serial(cell->anonymous_key));\n\n\t_debug(\"key %s\", cell->anonymous_key->description);\n\tkey = request_key(&key_type_rxrpc, cell->anonymous_key->description,\n\t\t\t  NULL);\n\tif (IS_ERR(key)) {\n\t\tif (PTR_ERR(key) != -ENOKEY) {\n\t\t\t_leave(\" = %ld\", PTR_ERR(key));\n\t\t\treturn key;\n\t\t}\n\n\t\t/* act as anonymous user */\n\t\t_leave(\" = {%x} [anon]\", key_serial(cell->anonymous_key));\n\t\treturn key_get(cell->anonymous_key);\n\t} else {\n\t\t/* act as authorised user */\n\t\t_leave(\" = {%x} [auth]\", key_serial(key));\n\t\treturn key;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <keys/rxrpc-type.h>",
            "#include <linux/sched.h>",
            "#include <linux/ctype.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <keys/rxrpc-type.h>\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstruct key *afs_request_key(struct afs_cell *cell)\n{\n\tstruct key *key;\n\n\t_enter(\"{%x}\", key_serial(cell->anonymous_key));\n\n\t_debug(\"key %s\", cell->anonymous_key->description);\n\tkey = request_key(&key_type_rxrpc, cell->anonymous_key->description,\n\t\t\t  NULL);\n\tif (IS_ERR(key)) {\n\t\tif (PTR_ERR(key) != -ENOKEY) {\n\t\t\t_leave(\" = %ld\", PTR_ERR(key));\n\t\t\treturn key;\n\t\t}\n\n\t\t/* act as anonymous user */\n\t\t_leave(\" = {%x} [anon]\", key_serial(cell->anonymous_key));\n\t\treturn key_get(cell->anonymous_key);\n\t} else {\n\t\t/* act as authorised user */\n\t\t_leave(\" = {%x} [auth]\", key_serial(key));\n\t\treturn key;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "content"
          ],
          "line": 1033
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%x:%u},{%pd},%s\"",
            "dvnode->fid.vid",
            "dvnode->fid.vnode",
            "dentry",
            "content"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int afs_d_delete(const struct dentry *dentry);\nstatic void afs_d_release(struct dentry *dentry);\nstatic int afs_rmdir(struct inode *dir, struct dentry *dentry);\nstatic int afs_unlink(struct inode *dir, struct dentry *dentry);\nstatic int afs_link(struct dentry *from, struct inode *dir,\n\t\t    struct dentry *dentry);\nstatic int afs_symlink(struct inode *dir, struct dentry *dentry,\n\t\t       const char *content);\n\nstatic int afs_symlink(struct inode *dir, struct dentry *dentry,\n\t\t       const char *content)\n{\n\tstruct afs_file_status status;\n\tstruct afs_server *server;\n\tstruct afs_vnode *dvnode, *vnode;\n\tstruct afs_fid fid;\n\tstruct inode *inode;\n\tstruct key *key;\n\tint ret;\n\n\tdvnode = AFS_FS_I(dir);\n\n\t_enter(\"{%x:%u},{%pd},%s\",\n\t       dvnode->fid.vid, dvnode->fid.vnode, dentry,\n\t       content);\n\n\tret = -EINVAL;\n\tif (strlen(content) >= AFSPATHMAX)\n\t\tgoto error;\n\n\tkey = afs_request_key(dvnode->volume->cell);\n\tif (IS_ERR(key)) {\n\t\tret = PTR_ERR(key);\n\t\tgoto error;\n\t}\n\n\tret = afs_vnode_symlink(dvnode, key, dentry->d_name.name, content,\n\t\t\t\t&fid, &status, &server);\n\tif (ret < 0)\n\t\tgoto create_error;\n\n\tinode = afs_iget(dir->i_sb, key, &fid, &status, NULL);\n\tif (IS_ERR(inode)) {\n\t\t/* ENOMEM at a really inconvenient time - just abandon the new\n\t\t * directory on the server */\n\t\tret = PTR_ERR(inode);\n\t\tgoto iget_error;\n\t}\n\n\t/* apply the status report we've got for the new vnode */\n\tvnode = AFS_FS_I(inode);\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt++;\n\tspin_unlock(&vnode->lock);\n\tafs_vnode_finalise_status_update(vnode, server);\n\tafs_put_server(server);\n\n\td_instantiate(dentry, inode);\n\tif (d_unhashed(dentry)) {\n\t\t_debug(\"not hashed\");\n\t\td_rehash(dentry);\n\t}\n\tkey_put(key);\n\t_leave(\" = 0\");\n\treturn 0;\n\niget_error:\n\tafs_put_server(server);\ncreate_error:\n\tkey_put(key);\nerror:\n\td_drop(dentry);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "afs_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/dir.c",
    "lines": "973-1010",
    "snippet": "static int afs_link(struct dentry *from, struct inode *dir,\n\t\t    struct dentry *dentry)\n{\n\tstruct afs_vnode *dvnode, *vnode;\n\tstruct key *key;\n\tint ret;\n\n\tvnode = AFS_FS_I(from->d_inode);\n\tdvnode = AFS_FS_I(dir);\n\n\t_enter(\"{%x:%u},{%x:%u},{%pd}\",\n\t       vnode->fid.vid, vnode->fid.vnode,\n\t       dvnode->fid.vid, dvnode->fid.vnode,\n\t       dentry);\n\n\tkey = afs_request_key(dvnode->volume->cell);\n\tif (IS_ERR(key)) {\n\t\tret = PTR_ERR(key);\n\t\tgoto error;\n\t}\n\n\tret = afs_vnode_link(dvnode, vnode, key, dentry->d_name.name);\n\tif (ret < 0)\n\t\tgoto link_error;\n\n\tihold(&vnode->vfs_inode);\n\td_instantiate(dentry, &vnode->vfs_inode);\n\tkey_put(key);\n\t_leave(\" = 0\");\n\treturn 0;\n\nlink_error:\n\tkey_put(key);\nerror:\n\td_drop(dentry);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int afs_d_delete(const struct dentry *dentry);",
      "static void afs_d_release(struct dentry *dentry);",
      "static int afs_rmdir(struct inode *dir, struct dentry *dentry);",
      "static int afs_unlink(struct inode *dir, struct dentry *dentry);",
      "static int afs_link(struct dentry *from, struct inode *dir,\n\t\t    struct dentry *dentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 1008
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_drop",
          "args": [
            "dentry"
          ],
          "line": 1007
        },
        "resolved": true,
        "details": {
          "function_name": "check_and_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1447-1453",
          "snippet": "static void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "key"
          ],
          "line": 1005
        },
        "resolved": true,
        "details": {
          "function_name": "expkey_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "40-49",
          "snippet": "static void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree(key);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\n\nstatic void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree(key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = 0\""
          ],
          "line": 1001
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "&vnode->vfs_inode"
          ],
          "line": 999
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ihold",
          "args": [
            "&vnode->vfs_inode"
          ],
          "line": 998
        },
        "resolved": true,
        "details": {
          "function_name": "ihold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "388-391",
          "snippet": "void ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid ihold(struct inode *inode)\n{\n\tWARN_ON(atomic_inc_return(&inode->i_count) < 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_vnode_link",
          "args": [
            "dvnode",
            "vnode",
            "key",
            "dentry->d_name.name"
          ],
          "line": 994
        },
        "resolved": true,
        "details": {
          "function_name": "afs_vnode_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vnode.c",
          "lines": "563-626",
          "snippet": "int afs_vnode_link(struct afs_vnode *dvnode, struct afs_vnode *vnode,\n\t\t\t  struct key *key, const char *name)\n{\n\tstruct afs_server *server;\n\tint ret;\n\n\t_enter(\"%s{%x:%u.%u},%s{%x:%u.%u},%x,%s\",\n\t       dvnode->volume->vlocation->vldb.name,\n\t       dvnode->fid.vid,\n\t       dvnode->fid.vnode,\n\t       dvnode->fid.unique,\n\t       vnode->volume->vlocation->vldb.name,\n\t       vnode->fid.vid,\n\t       vnode->fid.vnode,\n\t       vnode->fid.unique,\n\t       key_serial(key),\n\t       name);\n\n\t/* this op will fetch the status on the directory we're removing from */\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt++;\n\tspin_unlock(&vnode->lock);\n\tspin_lock(&dvnode->lock);\n\tdvnode->update_cnt++;\n\tspin_unlock(&dvnode->lock);\n\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(dvnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %08x\\n\", ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_link(server, key, dvnode, vnode, name,\n\t\t\t\t  &afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(dvnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0) {\n\t\tafs_vnode_finalise_status_update(vnode, server);\n\t\tafs_vnode_finalise_status_update(dvnode, server);\n\t\tafs_put_server(server);\n\t} else {\n\t\tafs_vnode_status_update_failed(vnode, ret);\n\t\tafs_vnode_status_update_failed(dvnode, ret);\n\t}\n\n\t_leave(\" = %d [cnt %d]\", ret, vnode->update_cnt);\n\treturn ret;\n\nno_server:\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\tspin_lock(&dvnode->lock);\n\tdvnode->update_cnt--;\n\tASSERTCMP(dvnode->update_cnt, >=, 0);\n\tspin_unlock(&dvnode->lock);\n\t_leave(\" = %ld [cnt %d]\", PTR_ERR(server), vnode->update_cnt);\n\treturn PTR_ERR(server);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint afs_vnode_link(struct afs_vnode *dvnode, struct afs_vnode *vnode,\n\t\t\t  struct key *key, const char *name)\n{\n\tstruct afs_server *server;\n\tint ret;\n\n\t_enter(\"%s{%x:%u.%u},%s{%x:%u.%u},%x,%s\",\n\t       dvnode->volume->vlocation->vldb.name,\n\t       dvnode->fid.vid,\n\t       dvnode->fid.vnode,\n\t       dvnode->fid.unique,\n\t       vnode->volume->vlocation->vldb.name,\n\t       vnode->fid.vid,\n\t       vnode->fid.vnode,\n\t       vnode->fid.unique,\n\t       key_serial(key),\n\t       name);\n\n\t/* this op will fetch the status on the directory we're removing from */\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt++;\n\tspin_unlock(&vnode->lock);\n\tspin_lock(&dvnode->lock);\n\tdvnode->update_cnt++;\n\tspin_unlock(&dvnode->lock);\n\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(dvnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %08x\\n\", ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_link(server, key, dvnode, vnode, name,\n\t\t\t\t  &afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(dvnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0) {\n\t\tafs_vnode_finalise_status_update(vnode, server);\n\t\tafs_vnode_finalise_status_update(dvnode, server);\n\t\tafs_put_server(server);\n\t} else {\n\t\tafs_vnode_status_update_failed(vnode, ret);\n\t\tafs_vnode_status_update_failed(dvnode, ret);\n\t}\n\n\t_leave(\" = %d [cnt %d]\", ret, vnode->update_cnt);\n\treturn ret;\n\nno_server:\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\tspin_lock(&dvnode->lock);\n\tdvnode->update_cnt--;\n\tASSERTCMP(dvnode->update_cnt, >=, 0);\n\tspin_unlock(&dvnode->lock);\n\t_leave(\" = %ld [cnt %d]\", PTR_ERR(server), vnode->update_cnt);\n\treturn PTR_ERR(server);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "key"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "key"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_request_key",
          "args": [
            "dvnode->volume->cell"
          ],
          "line": 988
        },
        "resolved": true,
        "details": {
          "function_name": "afs_request_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/security.c",
          "lines": "23-46",
          "snippet": "struct key *afs_request_key(struct afs_cell *cell)\n{\n\tstruct key *key;\n\n\t_enter(\"{%x}\", key_serial(cell->anonymous_key));\n\n\t_debug(\"key %s\", cell->anonymous_key->description);\n\tkey = request_key(&key_type_rxrpc, cell->anonymous_key->description,\n\t\t\t  NULL);\n\tif (IS_ERR(key)) {\n\t\tif (PTR_ERR(key) != -ENOKEY) {\n\t\t\t_leave(\" = %ld\", PTR_ERR(key));\n\t\t\treturn key;\n\t\t}\n\n\t\t/* act as anonymous user */\n\t\t_leave(\" = {%x} [anon]\", key_serial(cell->anonymous_key));\n\t\treturn key_get(cell->anonymous_key);\n\t} else {\n\t\t/* act as authorised user */\n\t\t_leave(\" = {%x} [auth]\", key_serial(key));\n\t\treturn key;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <keys/rxrpc-type.h>",
            "#include <linux/sched.h>",
            "#include <linux/ctype.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <keys/rxrpc-type.h>\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstruct key *afs_request_key(struct afs_cell *cell)\n{\n\tstruct key *key;\n\n\t_enter(\"{%x}\", key_serial(cell->anonymous_key));\n\n\t_debug(\"key %s\", cell->anonymous_key->description);\n\tkey = request_key(&key_type_rxrpc, cell->anonymous_key->description,\n\t\t\t  NULL);\n\tif (IS_ERR(key)) {\n\t\tif (PTR_ERR(key) != -ENOKEY) {\n\t\t\t_leave(\" = %ld\", PTR_ERR(key));\n\t\t\treturn key;\n\t\t}\n\n\t\t/* act as anonymous user */\n\t\t_leave(\" = {%x} [anon]\", key_serial(cell->anonymous_key));\n\t\treturn key_get(cell->anonymous_key);\n\t} else {\n\t\t/* act as authorised user */\n\t\t_leave(\" = {%x} [auth]\", key_serial(key));\n\t\treturn key;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%x:%u},{%x:%u},{%pd}\"",
            "vnode->fid.vid",
            "vnode->fid.vnode",
            "dvnode->fid.vid",
            "dvnode->fid.vnode",
            "dentry"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFS_FS_I",
          "args": [
            "dir"
          ],
          "line": 981
        },
        "resolved": true,
        "details": {
          "function_name": "AFS_FS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/internal.h",
          "lines": "687-690",
          "snippet": "static inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}",
          "includes": [
            "#include \"afs_vl.h\"",
            "#include \"afs.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/fscache.h>",
            "#include <linux/sched.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/key.h>",
            "#include <linux/rxrpc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void afs_discard_callback_on_delete(struct afs_vnode *);",
            "extern void afs_give_up_callback(struct afs_vnode *);",
            "extern void afs_lock_may_be_available(struct afs_vnode *);",
            "extern void afs_zap_data(struct afs_vnode *);",
            "extern void afs_evict_inode(struct inode *);",
            "extern int afs_drop_inode(struct inode *);",
            "extern void afs_clear_permits(struct afs_vnode *);",
            "extern int afs_permission(struct inode *, int);",
            "extern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);",
            "extern int afs_writeback_all(struct afs_vnode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_vl.h\"\n#include \"afs.h\"\n#include <linux/backing-dev.h>\n#include <linux/fscache.h>\n#include <linux/sched.h>\n#include <linux/workqueue.h>\n#include <linux/key.h>\n#include <linux/rxrpc.h>\n#include <linux/skbuff.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n\nextern void afs_discard_callback_on_delete(struct afs_vnode *);\nextern void afs_give_up_callback(struct afs_vnode *);\nextern void afs_lock_may_be_available(struct afs_vnode *);\nextern void afs_zap_data(struct afs_vnode *);\nextern void afs_evict_inode(struct inode *);\nextern int afs_drop_inode(struct inode *);\nextern void afs_clear_permits(struct afs_vnode *);\nextern int afs_permission(struct inode *, int);\nextern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);\nextern int afs_writeback_all(struct afs_vnode *);\n\nstatic inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int afs_d_delete(const struct dentry *dentry);\nstatic void afs_d_release(struct dentry *dentry);\nstatic int afs_rmdir(struct inode *dir, struct dentry *dentry);\nstatic int afs_unlink(struct inode *dir, struct dentry *dentry);\nstatic int afs_link(struct dentry *from, struct inode *dir,\n\t\t    struct dentry *dentry);\n\nstatic int afs_link(struct dentry *from, struct inode *dir,\n\t\t    struct dentry *dentry)\n{\n\tstruct afs_vnode *dvnode, *vnode;\n\tstruct key *key;\n\tint ret;\n\n\tvnode = AFS_FS_I(from->d_inode);\n\tdvnode = AFS_FS_I(dir);\n\n\t_enter(\"{%x:%u},{%x:%u},{%pd}\",\n\t       vnode->fid.vid, vnode->fid.vnode,\n\t       dvnode->fid.vid, dvnode->fid.vnode,\n\t       dentry);\n\n\tkey = afs_request_key(dvnode->volume->cell);\n\tif (IS_ERR(key)) {\n\t\tret = PTR_ERR(key);\n\t\tgoto error;\n\t}\n\n\tret = afs_vnode_link(dvnode, vnode, key, dentry->d_name.name);\n\tif (ret < 0)\n\t\tgoto link_error;\n\n\tihold(&vnode->vfs_inode);\n\td_instantiate(dentry, &vnode->vfs_inode);\n\tkey_put(key);\n\t_leave(\" = 0\");\n\treturn 0;\n\nlink_error:\n\tkey_put(key);\nerror:\n\td_drop(dentry);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "afs_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/dir.c",
    "lines": "906-968",
    "snippet": "static int afs_create(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\t      bool excl)\n{\n\tstruct afs_file_status status;\n\tstruct afs_callback cb;\n\tstruct afs_server *server;\n\tstruct afs_vnode *dvnode, *vnode;\n\tstruct afs_fid fid;\n\tstruct inode *inode;\n\tstruct key *key;\n\tint ret;\n\n\tdvnode = AFS_FS_I(dir);\n\n\t_enter(\"{%x:%u},{%pd},%ho,\",\n\t       dvnode->fid.vid, dvnode->fid.vnode, dentry, mode);\n\n\tkey = afs_request_key(dvnode->volume->cell);\n\tif (IS_ERR(key)) {\n\t\tret = PTR_ERR(key);\n\t\tgoto error;\n\t}\n\n\tmode |= S_IFREG;\n\tret = afs_vnode_create(dvnode, key, dentry->d_name.name,\n\t\t\t       mode, &fid, &status, &cb, &server);\n\tif (ret < 0)\n\t\tgoto create_error;\n\n\tinode = afs_iget(dir->i_sb, key, &fid, &status, &cb);\n\tif (IS_ERR(inode)) {\n\t\t/* ENOMEM at a really inconvenient time - just abandon the new\n\t\t * directory on the server */\n\t\tret = PTR_ERR(inode);\n\t\tgoto iget_error;\n\t}\n\n\t/* apply the status report we've got for the new vnode */\n\tvnode = AFS_FS_I(inode);\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt++;\n\tspin_unlock(&vnode->lock);\n\tafs_vnode_finalise_status_update(vnode, server);\n\tafs_put_server(server);\n\n\td_instantiate(dentry, inode);\n\tif (d_unhashed(dentry)) {\n\t\t_debug(\"not hashed\");\n\t\td_rehash(dentry);\n\t}\n\tkey_put(key);\n\t_leave(\" = 0\");\n\treturn 0;\n\niget_error:\n\tafs_put_server(server);\ncreate_error:\n\tkey_put(key);\nerror:\n\td_drop(dentry);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int afs_d_delete(const struct dentry *dentry);",
      "static void afs_d_release(struct dentry *dentry);",
      "static int afs_create(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\t      bool excl);",
      "static int afs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode);",
      "static int afs_rmdir(struct inode *dir, struct dentry *dentry);",
      "static int afs_unlink(struct inode *dir, struct dentry *dentry);",
      "static int afs_link(struct dentry *from, struct inode *dir,\n\t\t    struct dentry *dentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_drop",
          "args": [
            "dentry"
          ],
          "line": 965
        },
        "resolved": true,
        "details": {
          "function_name": "check_and_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1447-1453",
          "snippet": "static void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "key"
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "expkey_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "40-49",
          "snippet": "static void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree(key);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\n\nstatic void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree(key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_put_server",
          "args": [
            "server"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "afs_put_server",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/server.c",
          "lines": "219-246",
          "snippet": "void afs_put_server(struct afs_server *server)\n{\n\tif (!server)\n\t\treturn;\n\n\t_enter(\"%p{%d}\", server, atomic_read(&server->usage));\n\n\t_debug(\"PUT SERVER %d\", atomic_read(&server->usage));\n\n\tASSERTCMP(atomic_read(&server->usage), >, 0);\n\n\tif (likely(!atomic_dec_and_test(&server->usage))) {\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tafs_flush_callback_breaks(server);\n\n\tspin_lock(&afs_server_graveyard_lock);\n\tif (atomic_read(&server->usage) == 0) {\n\t\tlist_move_tail(&server->grave, &afs_server_graveyard);\n\t\tserver->time_of_death = get_seconds();\n\t\tqueue_delayed_work(afs_wq, &afs_server_reaper,\n\t\t\t\t   afs_server_timeout * HZ);\n\t}\n\tspin_unlock(&afs_server_graveyard_lock);\n\t_leave(\" [dead]\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned afs_server_timeout = 10;",
            "static LIST_HEAD(afs_server_graveyard);",
            "static DEFINE_SPINLOCK(afs_server_graveyard_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic unsigned afs_server_timeout = 10;\nstatic LIST_HEAD(afs_server_graveyard);\nstatic DEFINE_SPINLOCK(afs_server_graveyard_lock);\n\nvoid afs_put_server(struct afs_server *server)\n{\n\tif (!server)\n\t\treturn;\n\n\t_enter(\"%p{%d}\", server, atomic_read(&server->usage));\n\n\t_debug(\"PUT SERVER %d\", atomic_read(&server->usage));\n\n\tASSERTCMP(atomic_read(&server->usage), >, 0);\n\n\tif (likely(!atomic_dec_and_test(&server->usage))) {\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tafs_flush_callback_breaks(server);\n\n\tspin_lock(&afs_server_graveyard_lock);\n\tif (atomic_read(&server->usage) == 0) {\n\t\tlist_move_tail(&server->grave, &afs_server_graveyard);\n\t\tserver->time_of_death = get_seconds();\n\t\tqueue_delayed_work(afs_wq, &afs_server_reaper,\n\t\t\t\t   afs_server_timeout * HZ);\n\t}\n\tspin_unlock(&afs_server_graveyard_lock);\n\t_leave(\" [dead]\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = 0\""
          ],
          "line": 957
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_rehash",
          "args": [
            "dentry"
          ],
          "line": 954
        },
        "resolved": true,
        "details": {
          "function_name": "d_rehash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2403-2408",
          "snippet": "void d_rehash(struct dentry * entry)\n{\n\tspin_lock(&entry->d_lock);\n\t_d_rehash(entry);\n\tspin_unlock(&entry->d_lock);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid d_rehash(struct dentry * entry)\n{\n\tspin_lock(&entry->d_lock);\n\t_d_rehash(entry);\n\tspin_unlock(&entry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"not hashed\""
          ],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_suballoc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2634-2662",
          "snippet": "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_unhashed",
          "args": [
            "dentry"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_vnode_finalise_status_update",
          "args": [
            "vnode",
            "server"
          ],
          "line": 948
        },
        "resolved": true,
        "details": {
          "function_name": "afs_vnode_finalise_status_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vnode.c",
          "lines": "213-230",
          "snippet": "void afs_vnode_finalise_status_update(struct afs_vnode *vnode,\n\t\t\t\t      struct afs_server *server)\n{\n\tstruct afs_server *oldserver = NULL;\n\n\t_enter(\"%p,%p\", vnode, server);\n\n\tspin_lock(&vnode->lock);\n\tclear_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\tafs_vnode_note_promise(vnode, server);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\n\twake_up_all(&vnode->update_waitq);\n\tafs_put_server(oldserver);\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nvoid afs_vnode_finalise_status_update(struct afs_vnode *vnode,\n\t\t\t\t      struct afs_server *server)\n{\n\tstruct afs_server *oldserver = NULL;\n\n\t_enter(\"%p,%p\", vnode, server);\n\n\tspin_lock(&vnode->lock);\n\tclear_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\tafs_vnode_note_promise(vnode, server);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\n\twake_up_all(&vnode->update_waitq);\n\tafs_put_server(oldserver);\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vnode->lock"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&vnode->lock"
          ],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "AFS_FS_I",
          "args": [
            "inode"
          ],
          "line": 944
        },
        "resolved": true,
        "details": {
          "function_name": "AFS_FS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/internal.h",
          "lines": "687-690",
          "snippet": "static inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}",
          "includes": [
            "#include \"afs_vl.h\"",
            "#include \"afs.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/fscache.h>",
            "#include <linux/sched.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/key.h>",
            "#include <linux/rxrpc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void afs_discard_callback_on_delete(struct afs_vnode *);",
            "extern void afs_give_up_callback(struct afs_vnode *);",
            "extern void afs_lock_may_be_available(struct afs_vnode *);",
            "extern void afs_zap_data(struct afs_vnode *);",
            "extern void afs_evict_inode(struct inode *);",
            "extern int afs_drop_inode(struct inode *);",
            "extern void afs_clear_permits(struct afs_vnode *);",
            "extern int afs_permission(struct inode *, int);",
            "extern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);",
            "extern int afs_writeback_all(struct afs_vnode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_vl.h\"\n#include \"afs.h\"\n#include <linux/backing-dev.h>\n#include <linux/fscache.h>\n#include <linux/sched.h>\n#include <linux/workqueue.h>\n#include <linux/key.h>\n#include <linux/rxrpc.h>\n#include <linux/skbuff.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n\nextern void afs_discard_callback_on_delete(struct afs_vnode *);\nextern void afs_give_up_callback(struct afs_vnode *);\nextern void afs_lock_may_be_available(struct afs_vnode *);\nextern void afs_zap_data(struct afs_vnode *);\nextern void afs_evict_inode(struct inode *);\nextern int afs_drop_inode(struct inode *);\nextern void afs_clear_permits(struct afs_vnode *);\nextern int afs_permission(struct inode *, int);\nextern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);\nextern int afs_writeback_all(struct afs_vnode *);\n\nstatic inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_iget",
          "args": [
            "dir->i_sb",
            "key",
            "&fid",
            "&status",
            "&cb"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "afs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/inode.c",
          "lines": "198-285",
          "snippet": "struct inode *afs_iget(struct super_block *sb, struct key *key,\n\t\t       struct afs_fid *fid, struct afs_file_status *status,\n\t\t       struct afs_callback *cb)\n{\n\tstruct afs_iget_data data = { .fid = *fid };\n\tstruct afs_super_info *as;\n\tstruct afs_vnode *vnode;\n\tstruct inode *inode;\n\tint ret;\n\n\t_enter(\",{%x:%u.%u},,\", fid->vid, fid->vnode, fid->unique);\n\n\tas = sb->s_fs_info;\n\tdata.volume = as->volume;\n\n\tinode = iget5_locked(sb, fid->vnode, afs_iget5_test, afs_iget5_set,\n\t\t\t     &data);\n\tif (!inode) {\n\t\t_leave(\" = -ENOMEM\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t_debug(\"GOT INODE %p { vl=%x vn=%x, u=%x }\",\n\t       inode, fid->vid, fid->vnode, fid->unique);\n\n\tvnode = AFS_FS_I(inode);\n\n\t/* deal with an existing inode */\n\tif (!(inode->i_state & I_NEW)) {\n\t\t_leave(\" = %p\", inode);\n\t\treturn inode;\n\t}\n\n\tif (!status) {\n\t\t/* it's a remotely extant inode */\n\t\tset_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\t\tret = afs_vnode_fetch_status(vnode, NULL, key);\n\t\tif (ret < 0)\n\t\t\tgoto bad_inode;\n\t} else {\n\t\t/* it's an inode we just created */\n\t\tmemcpy(&vnode->status, status, sizeof(vnode->status));\n\n\t\tif (!cb) {\n\t\t\t/* it's a symlink we just created (the fileserver\n\t\t\t * didn't give us a callback) */\n\t\t\tvnode->cb_version = 0;\n\t\t\tvnode->cb_expiry = 0;\n\t\t\tvnode->cb_type = 0;\n\t\t\tvnode->cb_expires = get_seconds();\n\t\t} else {\n\t\t\tvnode->cb_version = cb->version;\n\t\t\tvnode->cb_expiry = cb->expiry;\n\t\t\tvnode->cb_type = cb->type;\n\t\t\tvnode->cb_expires = vnode->cb_expiry + get_seconds();\n\t\t}\n\t}\n\n\t/* set up caching before mapping the status, as map-status reads the\n\t * first page of symlinks to see if they're really mountpoints */\n\tinode->i_size = vnode->status.size;\n#ifdef CONFIG_AFS_FSCACHE\n\tvnode->cache = fscache_acquire_cookie(vnode->volume->cache,\n\t\t\t\t\t      &afs_vnode_cache_index_def,\n\t\t\t\t\t      vnode, true);\n#endif\n\n\tret = afs_inode_map_status(vnode, key);\n\tif (ret < 0)\n\t\tgoto bad_inode;\n\n\t/* success */\n\tclear_bit(AFS_VNODE_UNSET, &vnode->flags);\n\tinode->i_flags |= S_NOATIME;\n\tunlock_new_inode(inode);\n\t_leave(\" = %p [CB { v=%u t=%u }]\", inode, vnode->cb_version, vnode->cb_type);\n\treturn inode;\n\n\t/* failure */\nbad_inode:\n#ifdef CONFIG_AFS_FSCACHE\n\tfscache_relinquish_cookie(vnode->cache, 0);\n\tvnode->cache = NULL;\n#endif\n\tiget_failed(inode);\n\t_leave(\" = %d [bad]\", ret);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstruct inode *afs_iget(struct super_block *sb, struct key *key,\n\t\t       struct afs_fid *fid, struct afs_file_status *status,\n\t\t       struct afs_callback *cb)\n{\n\tstruct afs_iget_data data = { .fid = *fid };\n\tstruct afs_super_info *as;\n\tstruct afs_vnode *vnode;\n\tstruct inode *inode;\n\tint ret;\n\n\t_enter(\",{%x:%u.%u},,\", fid->vid, fid->vnode, fid->unique);\n\n\tas = sb->s_fs_info;\n\tdata.volume = as->volume;\n\n\tinode = iget5_locked(sb, fid->vnode, afs_iget5_test, afs_iget5_set,\n\t\t\t     &data);\n\tif (!inode) {\n\t\t_leave(\" = -ENOMEM\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t_debug(\"GOT INODE %p { vl=%x vn=%x, u=%x }\",\n\t       inode, fid->vid, fid->vnode, fid->unique);\n\n\tvnode = AFS_FS_I(inode);\n\n\t/* deal with an existing inode */\n\tif (!(inode->i_state & I_NEW)) {\n\t\t_leave(\" = %p\", inode);\n\t\treturn inode;\n\t}\n\n\tif (!status) {\n\t\t/* it's a remotely extant inode */\n\t\tset_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\t\tret = afs_vnode_fetch_status(vnode, NULL, key);\n\t\tif (ret < 0)\n\t\t\tgoto bad_inode;\n\t} else {\n\t\t/* it's an inode we just created */\n\t\tmemcpy(&vnode->status, status, sizeof(vnode->status));\n\n\t\tif (!cb) {\n\t\t\t/* it's a symlink we just created (the fileserver\n\t\t\t * didn't give us a callback) */\n\t\t\tvnode->cb_version = 0;\n\t\t\tvnode->cb_expiry = 0;\n\t\t\tvnode->cb_type = 0;\n\t\t\tvnode->cb_expires = get_seconds();\n\t\t} else {\n\t\t\tvnode->cb_version = cb->version;\n\t\t\tvnode->cb_expiry = cb->expiry;\n\t\t\tvnode->cb_type = cb->type;\n\t\t\tvnode->cb_expires = vnode->cb_expiry + get_seconds();\n\t\t}\n\t}\n\n\t/* set up caching before mapping the status, as map-status reads the\n\t * first page of symlinks to see if they're really mountpoints */\n\tinode->i_size = vnode->status.size;\n#ifdef CONFIG_AFS_FSCACHE\n\tvnode->cache = fscache_acquire_cookie(vnode->volume->cache,\n\t\t\t\t\t      &afs_vnode_cache_index_def,\n\t\t\t\t\t      vnode, true);\n#endif\n\n\tret = afs_inode_map_status(vnode, key);\n\tif (ret < 0)\n\t\tgoto bad_inode;\n\n\t/* success */\n\tclear_bit(AFS_VNODE_UNSET, &vnode->flags);\n\tinode->i_flags |= S_NOATIME;\n\tunlock_new_inode(inode);\n\t_leave(\" = %p [CB { v=%u t=%u }]\", inode, vnode->cb_version, vnode->cb_type);\n\treturn inode;\n\n\t/* failure */\nbad_inode:\n#ifdef CONFIG_AFS_FSCACHE\n\tfscache_relinquish_cookie(vnode->cache, 0);\n\tvnode->cache = NULL;\n#endif\n\tiget_failed(inode);\n\t_leave(\" = %d [bad]\", ret);\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_vnode_create",
          "args": [
            "dvnode",
            "key",
            "dentry->d_name.name",
            "mode",
            "&fid",
            "&status",
            "&cb",
            "&server"
          ],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "afs_vnode_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vnode.c",
          "lines": "450-503",
          "snippet": "int afs_vnode_create(struct afs_vnode *vnode, struct key *key,\n\t\t     const char *name, umode_t mode, struct afs_fid *newfid,\n\t\t     struct afs_file_status *newstatus,\n\t\t     struct afs_callback *newcb, struct afs_server **_server)\n{\n\tstruct afs_server *server;\n\tint ret;\n\n\t_enter(\"%s{%x:%u.%u},%x,%s,,\",\n\t       vnode->volume->vlocation->vldb.name,\n\t       vnode->fid.vid,\n\t       vnode->fid.vnode,\n\t       vnode->fid.unique,\n\t       key_serial(key),\n\t       name);\n\n\t/* this op will fetch the status on the directory we're creating in */\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt++;\n\tspin_unlock(&vnode->lock);\n\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(vnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %08x\\n\", ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_create(server, key, vnode, name, mode, newfid,\n\t\t\t\t    newstatus, newcb, &afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(vnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0) {\n\t\tafs_vnode_finalise_status_update(vnode, server);\n\t\t*_server = server;\n\t} else {\n\t\tafs_vnode_status_update_failed(vnode, ret);\n\t\t*_server = NULL;\n\t}\n\n\t_leave(\" = %d [cnt %d]\", ret, vnode->update_cnt);\n\treturn ret;\n\nno_server:\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\t_leave(\" = %ld [cnt %d]\", PTR_ERR(server), vnode->update_cnt);\n\treturn PTR_ERR(server);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint afs_vnode_create(struct afs_vnode *vnode, struct key *key,\n\t\t     const char *name, umode_t mode, struct afs_fid *newfid,\n\t\t     struct afs_file_status *newstatus,\n\t\t     struct afs_callback *newcb, struct afs_server **_server)\n{\n\tstruct afs_server *server;\n\tint ret;\n\n\t_enter(\"%s{%x:%u.%u},%x,%s,,\",\n\t       vnode->volume->vlocation->vldb.name,\n\t       vnode->fid.vid,\n\t       vnode->fid.vnode,\n\t       vnode->fid.unique,\n\t       key_serial(key),\n\t       name);\n\n\t/* this op will fetch the status on the directory we're creating in */\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt++;\n\tspin_unlock(&vnode->lock);\n\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(vnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %08x\\n\", ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_create(server, key, vnode, name, mode, newfid,\n\t\t\t\t    newstatus, newcb, &afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(vnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0) {\n\t\tafs_vnode_finalise_status_update(vnode, server);\n\t\t*_server = server;\n\t} else {\n\t\tafs_vnode_status_update_failed(vnode, ret);\n\t\t*_server = NULL;\n\t}\n\n\t_leave(\" = %d [cnt %d]\", ret, vnode->update_cnt);\n\treturn ret;\n\nno_server:\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\t_leave(\" = %ld [cnt %d]\", PTR_ERR(server), vnode->update_cnt);\n\treturn PTR_ERR(server);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "key"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "key"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_request_key",
          "args": [
            "dvnode->volume->cell"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "afs_request_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/security.c",
          "lines": "23-46",
          "snippet": "struct key *afs_request_key(struct afs_cell *cell)\n{\n\tstruct key *key;\n\n\t_enter(\"{%x}\", key_serial(cell->anonymous_key));\n\n\t_debug(\"key %s\", cell->anonymous_key->description);\n\tkey = request_key(&key_type_rxrpc, cell->anonymous_key->description,\n\t\t\t  NULL);\n\tif (IS_ERR(key)) {\n\t\tif (PTR_ERR(key) != -ENOKEY) {\n\t\t\t_leave(\" = %ld\", PTR_ERR(key));\n\t\t\treturn key;\n\t\t}\n\n\t\t/* act as anonymous user */\n\t\t_leave(\" = {%x} [anon]\", key_serial(cell->anonymous_key));\n\t\treturn key_get(cell->anonymous_key);\n\t} else {\n\t\t/* act as authorised user */\n\t\t_leave(\" = {%x} [auth]\", key_serial(key));\n\t\treturn key;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <keys/rxrpc-type.h>",
            "#include <linux/sched.h>",
            "#include <linux/ctype.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <keys/rxrpc-type.h>\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstruct key *afs_request_key(struct afs_cell *cell)\n{\n\tstruct key *key;\n\n\t_enter(\"{%x}\", key_serial(cell->anonymous_key));\n\n\t_debug(\"key %s\", cell->anonymous_key->description);\n\tkey = request_key(&key_type_rxrpc, cell->anonymous_key->description,\n\t\t\t  NULL);\n\tif (IS_ERR(key)) {\n\t\tif (PTR_ERR(key) != -ENOKEY) {\n\t\t\t_leave(\" = %ld\", PTR_ERR(key));\n\t\t\treturn key;\n\t\t}\n\n\t\t/* act as anonymous user */\n\t\t_leave(\" = {%x} [anon]\", key_serial(cell->anonymous_key));\n\t\treturn key_get(cell->anonymous_key);\n\t} else {\n\t\t/* act as authorised user */\n\t\t_leave(\" = {%x} [auth]\", key_serial(key));\n\t\treturn key;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%x:%u},{%pd},%ho,\"",
            "dvnode->fid.vid",
            "dvnode->fid.vnode",
            "dentry",
            "mode"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int afs_d_delete(const struct dentry *dentry);\nstatic void afs_d_release(struct dentry *dentry);\nstatic int afs_create(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\t      bool excl);\nstatic int afs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode);\nstatic int afs_rmdir(struct inode *dir, struct dentry *dentry);\nstatic int afs_unlink(struct inode *dir, struct dentry *dentry);\nstatic int afs_link(struct dentry *from, struct inode *dir,\n\t\t    struct dentry *dentry);\n\nstatic int afs_create(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\t      bool excl)\n{\n\tstruct afs_file_status status;\n\tstruct afs_callback cb;\n\tstruct afs_server *server;\n\tstruct afs_vnode *dvnode, *vnode;\n\tstruct afs_fid fid;\n\tstruct inode *inode;\n\tstruct key *key;\n\tint ret;\n\n\tdvnode = AFS_FS_I(dir);\n\n\t_enter(\"{%x:%u},{%pd},%ho,\",\n\t       dvnode->fid.vid, dvnode->fid.vnode, dentry, mode);\n\n\tkey = afs_request_key(dvnode->volume->cell);\n\tif (IS_ERR(key)) {\n\t\tret = PTR_ERR(key);\n\t\tgoto error;\n\t}\n\n\tmode |= S_IFREG;\n\tret = afs_vnode_create(dvnode, key, dentry->d_name.name,\n\t\t\t       mode, &fid, &status, &cb, &server);\n\tif (ret < 0)\n\t\tgoto create_error;\n\n\tinode = afs_iget(dir->i_sb, key, &fid, &status, &cb);\n\tif (IS_ERR(inode)) {\n\t\t/* ENOMEM at a really inconvenient time - just abandon the new\n\t\t * directory on the server */\n\t\tret = PTR_ERR(inode);\n\t\tgoto iget_error;\n\t}\n\n\t/* apply the status report we've got for the new vnode */\n\tvnode = AFS_FS_I(inode);\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt++;\n\tspin_unlock(&vnode->lock);\n\tafs_vnode_finalise_status_update(vnode, server);\n\tafs_put_server(server);\n\n\td_instantiate(dentry, inode);\n\tif (d_unhashed(dentry)) {\n\t\t_debug(\"not hashed\");\n\t\td_rehash(dentry);\n\t}\n\tkey_put(key);\n\t_leave(\" = 0\");\n\treturn 0;\n\niget_error:\n\tafs_put_server(server);\ncreate_error:\n\tkey_put(key);\nerror:\n\td_drop(dentry);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "afs_unlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/dir.c",
    "lines": "838-901",
    "snippet": "static int afs_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct afs_vnode *dvnode, *vnode;\n\tstruct key *key;\n\tint ret;\n\n\tdvnode = AFS_FS_I(dir);\n\n\t_enter(\"{%x:%u},{%pd}\",\n\t       dvnode->fid.vid, dvnode->fid.vnode, dentry);\n\n\tret = -ENAMETOOLONG;\n\tif (dentry->d_name.len >= AFSNAMEMAX)\n\t\tgoto error;\n\n\tkey = afs_request_key(dvnode->volume->cell);\n\tif (IS_ERR(key)) {\n\t\tret = PTR_ERR(key);\n\t\tgoto error;\n\t}\n\n\tif (dentry->d_inode) {\n\t\tvnode = AFS_FS_I(dentry->d_inode);\n\n\t\t/* make sure we have a callback promise on the victim */\n\t\tret = afs_validate(vnode, key);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t}\n\n\tret = afs_vnode_remove(dvnode, key, dentry->d_name.name, false);\n\tif (ret < 0)\n\t\tgoto remove_error;\n\n\tif (dentry->d_inode) {\n\t\t/* if the file wasn't deleted due to excess hard links, the\n\t\t * fileserver will break the callback promise on the file - if\n\t\t * it had one - before it returns to us, and if it was deleted,\n\t\t * it won't\n\t\t *\n\t\t * however, if we didn't have a callback promise outstanding,\n\t\t * or it was outstanding on a different server, then it won't\n\t\t * break it either...\n\t\t */\n\t\tvnode = AFS_FS_I(dentry->d_inode);\n\t\tif (test_bit(AFS_VNODE_DELETED, &vnode->flags))\n\t\t\t_debug(\"AFS_VNODE_DELETED\");\n\t\tif (test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags))\n\t\t\t_debug(\"AFS_VNODE_CB_BROKEN\");\n\t\tset_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\t\tret = afs_validate(vnode, key);\n\t\t_debug(\"nlink %d [val %d]\", vnode->vfs_inode.i_nlink, ret);\n\t}\n\n\tkey_put(key);\n\t_leave(\" = 0\");\n\treturn 0;\n\nremove_error:\n\tkey_put(key);\nerror:\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dentry *afs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t unsigned int flags);",
      "static int afs_dir_open(struct inode *inode, struct file *file);",
      "static int afs_d_revalidate(struct dentry *dentry, unsigned int flags);",
      "static int afs_d_delete(const struct dentry *dentry);",
      "static void afs_d_release(struct dentry *dentry);",
      "static int afs_rmdir(struct inode *dir, struct dentry *dentry);",
      "static int afs_unlink(struct inode *dir, struct dentry *dentry);",
      "static int afs_link(struct dentry *from, struct inode *dir,\n\t\t    struct dentry *dentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "key"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "expkey_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "40-49",
          "snippet": "static void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree(key);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\n\nstatic void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree(key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = 0\""
          ],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"nlink %d [val %d]\"",
            "vnode->vfs_inode.i_nlink",
            "ret"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "befs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "53-67",
          "snippet": "void\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_validate",
          "args": [
            "vnode",
            "key"
          ],
          "line": 888
        },
        "resolved": true,
        "details": {
          "function_name": "afs_validate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/inode.c",
          "lines": "313-372",
          "snippet": "int afs_validate(struct afs_vnode *vnode, struct key *key)\n{\n\tint ret;\n\n\t_enter(\"{v={%x:%u} fl=%lx},%x\",\n\t       vnode->fid.vid, vnode->fid.vnode, vnode->flags,\n\t       key_serial(key));\n\n\tif (vnode->cb_promised &&\n\t    !test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags) &&\n\t    !test_bit(AFS_VNODE_MODIFIED, &vnode->flags) &&\n\t    !test_bit(AFS_VNODE_ZAP_DATA, &vnode->flags)) {\n\t\tif (vnode->cb_expires < get_seconds() + 10) {\n\t\t\t_debug(\"callback expired\");\n\t\t\tset_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\t\t} else {\n\t\t\tgoto valid;\n\t\t}\n\t}\n\n\tif (test_bit(AFS_VNODE_DELETED, &vnode->flags))\n\t\tgoto valid;\n\n\tmutex_lock(&vnode->validate_lock);\n\n\t/* if the promise has expired, we need to check the server again to get\n\t * a new promise - note that if the (parent) directory's metadata was\n\t * changed then the security may be different and we may no longer have\n\t * access */\n\tif (!vnode->cb_promised ||\n\t    test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags)) {\n\t\t_debug(\"not promised\");\n\t\tret = afs_vnode_fetch_status(vnode, NULL, key);\n\t\tif (ret < 0)\n\t\t\tgoto error_unlock;\n\t\t_debug(\"new promise [fl=%lx]\", vnode->flags);\n\t}\n\n\tif (test_bit(AFS_VNODE_DELETED, &vnode->flags)) {\n\t\t_debug(\"file already deleted\");\n\t\tret = -ESTALE;\n\t\tgoto error_unlock;\n\t}\n\n\t/* if the vnode's data version number changed then its contents are\n\t * different */\n\tif (test_and_clear_bit(AFS_VNODE_ZAP_DATA, &vnode->flags))\n\t\tafs_zap_data(vnode);\n\n\tclear_bit(AFS_VNODE_MODIFIED, &vnode->flags);\n\tmutex_unlock(&vnode->validate_lock);\nvalid:\n\t_leave(\" = 0\");\n\treturn 0;\n\nerror_unlock:\n\tmutex_unlock(&vnode->validate_lock);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint afs_validate(struct afs_vnode *vnode, struct key *key)\n{\n\tint ret;\n\n\t_enter(\"{v={%x:%u} fl=%lx},%x\",\n\t       vnode->fid.vid, vnode->fid.vnode, vnode->flags,\n\t       key_serial(key));\n\n\tif (vnode->cb_promised &&\n\t    !test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags) &&\n\t    !test_bit(AFS_VNODE_MODIFIED, &vnode->flags) &&\n\t    !test_bit(AFS_VNODE_ZAP_DATA, &vnode->flags)) {\n\t\tif (vnode->cb_expires < get_seconds() + 10) {\n\t\t\t_debug(\"callback expired\");\n\t\t\tset_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\t\t} else {\n\t\t\tgoto valid;\n\t\t}\n\t}\n\n\tif (test_bit(AFS_VNODE_DELETED, &vnode->flags))\n\t\tgoto valid;\n\n\tmutex_lock(&vnode->validate_lock);\n\n\t/* if the promise has expired, we need to check the server again to get\n\t * a new promise - note that if the (parent) directory's metadata was\n\t * changed then the security may be different and we may no longer have\n\t * access */\n\tif (!vnode->cb_promised ||\n\t    test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags)) {\n\t\t_debug(\"not promised\");\n\t\tret = afs_vnode_fetch_status(vnode, NULL, key);\n\t\tif (ret < 0)\n\t\t\tgoto error_unlock;\n\t\t_debug(\"new promise [fl=%lx]\", vnode->flags);\n\t}\n\n\tif (test_bit(AFS_VNODE_DELETED, &vnode->flags)) {\n\t\t_debug(\"file already deleted\");\n\t\tret = -ESTALE;\n\t\tgoto error_unlock;\n\t}\n\n\t/* if the vnode's data version number changed then its contents are\n\t * different */\n\tif (test_and_clear_bit(AFS_VNODE_ZAP_DATA, &vnode->flags))\n\t\tafs_zap_data(vnode);\n\n\tclear_bit(AFS_VNODE_MODIFIED, &vnode->flags);\n\tmutex_unlock(&vnode->validate_lock);\nvalid:\n\t_leave(\" = 0\");\n\treturn 0;\n\nerror_unlock:\n\tmutex_unlock(&vnode->validate_lock);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "AFS_VNODE_CB_BROKEN",
            "&vnode->flags"
          ],
          "line": 887
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"AFS_VNODE_CB_BROKEN\""
          ],
          "line": 886
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_suballoc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2634-2662",
          "snippet": "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "AFS_VNODE_CB_BROKEN",
            "&vnode->flags"
          ],
          "line": 885
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AFS_FS_I",
          "args": [
            "dentry->d_inode"
          ],
          "line": 882
        },
        "resolved": true,
        "details": {
          "function_name": "AFS_FS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/internal.h",
          "lines": "687-690",
          "snippet": "static inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}",
          "includes": [
            "#include \"afs_vl.h\"",
            "#include \"afs.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/fscache.h>",
            "#include <linux/sched.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/key.h>",
            "#include <linux/rxrpc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void afs_discard_callback_on_delete(struct afs_vnode *);",
            "extern void afs_give_up_callback(struct afs_vnode *);",
            "extern void afs_lock_may_be_available(struct afs_vnode *);",
            "extern void afs_zap_data(struct afs_vnode *);",
            "extern void afs_evict_inode(struct inode *);",
            "extern int afs_drop_inode(struct inode *);",
            "extern void afs_clear_permits(struct afs_vnode *);",
            "extern int afs_permission(struct inode *, int);",
            "extern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);",
            "extern int afs_writeback_all(struct afs_vnode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_vl.h\"\n#include \"afs.h\"\n#include <linux/backing-dev.h>\n#include <linux/fscache.h>\n#include <linux/sched.h>\n#include <linux/workqueue.h>\n#include <linux/key.h>\n#include <linux/rxrpc.h>\n#include <linux/skbuff.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n\nextern void afs_discard_callback_on_delete(struct afs_vnode *);\nextern void afs_give_up_callback(struct afs_vnode *);\nextern void afs_lock_may_be_available(struct afs_vnode *);\nextern void afs_zap_data(struct afs_vnode *);\nextern void afs_evict_inode(struct inode *);\nextern int afs_drop_inode(struct inode *);\nextern void afs_clear_permits(struct afs_vnode *);\nextern int afs_permission(struct inode *, int);\nextern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);\nextern int afs_writeback_all(struct afs_vnode *);\n\nstatic inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_vnode_remove",
          "args": [
            "dvnode",
            "key",
            "dentry->d_name.name",
            "false"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "afs_vnode_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vnode.c",
          "lines": "508-558",
          "snippet": "int afs_vnode_remove(struct afs_vnode *vnode, struct key *key, const char *name,\n\t\t     bool isdir)\n{\n\tstruct afs_server *server;\n\tint ret;\n\n\t_enter(\"%s{%x:%u.%u},%x,%s\",\n\t       vnode->volume->vlocation->vldb.name,\n\t       vnode->fid.vid,\n\t       vnode->fid.vnode,\n\t       vnode->fid.unique,\n\t       key_serial(key),\n\t       name);\n\n\t/* this op will fetch the status on the directory we're removing from */\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt++;\n\tspin_unlock(&vnode->lock);\n\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(vnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %08x\\n\", ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_remove(server, key, vnode, name, isdir,\n\t\t\t\t    &afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(vnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0) {\n\t\tafs_vnode_finalise_status_update(vnode, server);\n\t\tafs_put_server(server);\n\t} else {\n\t\tafs_vnode_status_update_failed(vnode, ret);\n\t}\n\n\t_leave(\" = %d [cnt %d]\", ret, vnode->update_cnt);\n\treturn ret;\n\nno_server:\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\t_leave(\" = %ld [cnt %d]\", PTR_ERR(server), vnode->update_cnt);\n\treturn PTR_ERR(server);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint afs_vnode_remove(struct afs_vnode *vnode, struct key *key, const char *name,\n\t\t     bool isdir)\n{\n\tstruct afs_server *server;\n\tint ret;\n\n\t_enter(\"%s{%x:%u.%u},%x,%s\",\n\t       vnode->volume->vlocation->vldb.name,\n\t       vnode->fid.vid,\n\t       vnode->fid.vnode,\n\t       vnode->fid.unique,\n\t       key_serial(key),\n\t       name);\n\n\t/* this op will fetch the status on the directory we're removing from */\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt++;\n\tspin_unlock(&vnode->lock);\n\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(vnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %08x\\n\", ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_remove(server, key, vnode, name, isdir,\n\t\t\t\t    &afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(vnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0) {\n\t\tafs_vnode_finalise_status_update(vnode, server);\n\t\tafs_put_server(server);\n\t} else {\n\t\tafs_vnode_status_update_failed(vnode, ret);\n\t}\n\n\t_leave(\" = %d [cnt %d]\", ret, vnode->update_cnt);\n\treturn ret;\n\nno_server:\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\t_leave(\" = %ld [cnt %d]\", PTR_ERR(server), vnode->update_cnt);\n\treturn PTR_ERR(server);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "key"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "key"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_request_key",
          "args": [
            "dvnode->volume->cell"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "afs_request_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/security.c",
          "lines": "23-46",
          "snippet": "struct key *afs_request_key(struct afs_cell *cell)\n{\n\tstruct key *key;\n\n\t_enter(\"{%x}\", key_serial(cell->anonymous_key));\n\n\t_debug(\"key %s\", cell->anonymous_key->description);\n\tkey = request_key(&key_type_rxrpc, cell->anonymous_key->description,\n\t\t\t  NULL);\n\tif (IS_ERR(key)) {\n\t\tif (PTR_ERR(key) != -ENOKEY) {\n\t\t\t_leave(\" = %ld\", PTR_ERR(key));\n\t\t\treturn key;\n\t\t}\n\n\t\t/* act as anonymous user */\n\t\t_leave(\" = {%x} [anon]\", key_serial(cell->anonymous_key));\n\t\treturn key_get(cell->anonymous_key);\n\t} else {\n\t\t/* act as authorised user */\n\t\t_leave(\" = {%x} [auth]\", key_serial(key));\n\t\treturn key;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <keys/rxrpc-type.h>",
            "#include <linux/sched.h>",
            "#include <linux/ctype.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <keys/rxrpc-type.h>\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstruct key *afs_request_key(struct afs_cell *cell)\n{\n\tstruct key *key;\n\n\t_enter(\"{%x}\", key_serial(cell->anonymous_key));\n\n\t_debug(\"key %s\", cell->anonymous_key->description);\n\tkey = request_key(&key_type_rxrpc, cell->anonymous_key->description,\n\t\t\t  NULL);\n\tif (IS_ERR(key)) {\n\t\tif (PTR_ERR(key) != -ENOKEY) {\n\t\t\t_leave(\" = %ld\", PTR_ERR(key));\n\t\t\treturn key;\n\t\t}\n\n\t\t/* act as anonymous user */\n\t\t_leave(\" = {%x} [anon]\", key_serial(cell->anonymous_key));\n\t\treturn key_get(cell->anonymous_key);\n\t} else {\n\t\t/* act as authorised user */\n\t\t_leave(\" = {%x} [auth]\", key_serial(key));\n\t\treturn key;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%x:%u},{%pd}\"",
            "dvnode->fid.vid",
            "dvnode->fid.vnode",
            "dentry"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct dentry *afs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t unsigned int flags);\nstatic int afs_dir_open(struct inode *inode, struct file *file);\nstatic int afs_d_revalidate(struct dentry *dentry, unsigned int flags);\nstatic int afs_d_delete(const struct dentry *dentry);\nstatic void afs_d_release(struct dentry *dentry);\nstatic int afs_rmdir(struct inode *dir, struct dentry *dentry);\nstatic int afs_unlink(struct inode *dir, struct dentry *dentry);\nstatic int afs_link(struct dentry *from, struct inode *dir,\n\t\t    struct dentry *dentry);\n\nstatic int afs_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tstruct afs_vnode *dvnode, *vnode;\n\tstruct key *key;\n\tint ret;\n\n\tdvnode = AFS_FS_I(dir);\n\n\t_enter(\"{%x:%u},{%pd}\",\n\t       dvnode->fid.vid, dvnode->fid.vnode, dentry);\n\n\tret = -ENAMETOOLONG;\n\tif (dentry->d_name.len >= AFSNAMEMAX)\n\t\tgoto error;\n\n\tkey = afs_request_key(dvnode->volume->cell);\n\tif (IS_ERR(key)) {\n\t\tret = PTR_ERR(key);\n\t\tgoto error;\n\t}\n\n\tif (dentry->d_inode) {\n\t\tvnode = AFS_FS_I(dentry->d_inode);\n\n\t\t/* make sure we have a callback promise on the victim */\n\t\tret = afs_validate(vnode, key);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t}\n\n\tret = afs_vnode_remove(dvnode, key, dentry->d_name.name, false);\n\tif (ret < 0)\n\t\tgoto remove_error;\n\n\tif (dentry->d_inode) {\n\t\t/* if the file wasn't deleted due to excess hard links, the\n\t\t * fileserver will break the callback promise on the file - if\n\t\t * it had one - before it returns to us, and if it was deleted,\n\t\t * it won't\n\t\t *\n\t\t * however, if we didn't have a callback promise outstanding,\n\t\t * or it was outstanding on a different server, then it won't\n\t\t * break it either...\n\t\t */\n\t\tvnode = AFS_FS_I(dentry->d_inode);\n\t\tif (test_bit(AFS_VNODE_DELETED, &vnode->flags))\n\t\t\t_debug(\"AFS_VNODE_DELETED\");\n\t\tif (test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags))\n\t\t\t_debug(\"AFS_VNODE_CB_BROKEN\");\n\t\tset_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\t\tret = afs_validate(vnode, key);\n\t\t_debug(\"nlink %d [val %d]\", vnode->vfs_inode.i_nlink, ret);\n\t}\n\n\tkey_put(key);\n\t_leave(\" = 0\");\n\treturn 0;\n\nremove_error:\n\tkey_put(key);\nerror:\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "afs_rmdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/dir.c",
    "lines": "796-833",
    "snippet": "static int afs_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tstruct afs_vnode *dvnode, *vnode;\n\tstruct key *key;\n\tint ret;\n\n\tdvnode = AFS_FS_I(dir);\n\n\t_enter(\"{%x:%u},{%pd}\",\n\t       dvnode->fid.vid, dvnode->fid.vnode, dentry);\n\n\tkey = afs_request_key(dvnode->volume->cell);\n\tif (IS_ERR(key)) {\n\t\tret = PTR_ERR(key);\n\t\tgoto error;\n\t}\n\n\tret = afs_vnode_remove(dvnode, key, dentry->d_name.name, true);\n\tif (ret < 0)\n\t\tgoto rmdir_error;\n\n\tif (dentry->d_inode) {\n\t\tvnode = AFS_FS_I(dentry->d_inode);\n\t\tclear_nlink(&vnode->vfs_inode);\n\t\tset_bit(AFS_VNODE_DELETED, &vnode->flags);\n\t\tafs_discard_callback_on_delete(vnode);\n\t}\n\n\tkey_put(key);\n\t_leave(\" = 0\");\n\treturn 0;\n\nrmdir_error:\n\tkey_put(key);\nerror:\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dentry *afs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t unsigned int flags);",
      "static int afs_d_revalidate(struct dentry *dentry, unsigned int flags);",
      "static int afs_d_delete(const struct dentry *dentry);",
      "static void afs_d_release(struct dentry *dentry);",
      "static int afs_rmdir(struct inode *dir, struct dentry *dentry);",
      "static int afs_unlink(struct inode *dir, struct dentry *dentry);",
      "static int afs_link(struct dentry *from, struct inode *dir,\n\t\t    struct dentry *dentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "key"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "expkey_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "40-49",
          "snippet": "static void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree(key);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\n\nstatic void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree(key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = 0\""
          ],
          "line": 825
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_discard_callback_on_delete",
          "args": [
            "vnode"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "afs_discard_callback_on_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/callback.c",
          "lines": "262-283",
          "snippet": "void afs_discard_callback_on_delete(struct afs_vnode *vnode)\n{\n\tstruct afs_server *server = vnode->server;\n\n\t_enter(\"%d\", vnode->cb_promised);\n\n\tif (!vnode->cb_promised) {\n\t\t_leave(\" [not promised]\");\n\t\treturn;\n\t}\n\n\tASSERT(server != NULL);\n\n\tspin_lock(&server->cb_lock);\n\tif (vnode->cb_promised) {\n\t\tASSERT(server->cb_promises.rb_node != NULL);\n\t\trb_erase(&vnode->cb_promise, &server->cb_promises);\n\t\tvnode->cb_promised = false;\n\t}\n\tspin_unlock(&server->cb_lock);\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/circ_buf.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/circ_buf.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nvoid afs_discard_callback_on_delete(struct afs_vnode *vnode)\n{\n\tstruct afs_server *server = vnode->server;\n\n\t_enter(\"%d\", vnode->cb_promised);\n\n\tif (!vnode->cb_promised) {\n\t\t_leave(\" [not promised]\");\n\t\treturn;\n\t}\n\n\tASSERT(server != NULL);\n\n\tspin_lock(&server->cb_lock);\n\tif (vnode->cb_promised) {\n\t\tASSERT(server->cb_promises.rb_node != NULL);\n\t\trb_erase(&vnode->cb_promise, &server->cb_promises);\n\t\tvnode->cb_promised = false;\n\t}\n\tspin_unlock(&server->cb_lock);\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "AFS_VNODE_DELETED",
            "&vnode->flags"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_nlink",
          "args": [
            "&vnode->vfs_inode"
          ],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "clear_nlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "288-294",
          "snippet": "void clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nvoid clear_nlink(struct inode *inode)\n{\n\tif (inode->i_nlink) {\n\t\tinode->__i_nlink = 0;\n\t\tatomic_long_inc(&inode->i_sb->s_remove_count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "AFS_FS_I",
          "args": [
            "dentry->d_inode"
          ],
          "line": 818
        },
        "resolved": true,
        "details": {
          "function_name": "AFS_FS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/internal.h",
          "lines": "687-690",
          "snippet": "static inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}",
          "includes": [
            "#include \"afs_vl.h\"",
            "#include \"afs.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/fscache.h>",
            "#include <linux/sched.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/key.h>",
            "#include <linux/rxrpc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void afs_discard_callback_on_delete(struct afs_vnode *);",
            "extern void afs_give_up_callback(struct afs_vnode *);",
            "extern void afs_lock_may_be_available(struct afs_vnode *);",
            "extern void afs_zap_data(struct afs_vnode *);",
            "extern void afs_evict_inode(struct inode *);",
            "extern int afs_drop_inode(struct inode *);",
            "extern void afs_clear_permits(struct afs_vnode *);",
            "extern int afs_permission(struct inode *, int);",
            "extern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);",
            "extern int afs_writeback_all(struct afs_vnode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_vl.h\"\n#include \"afs.h\"\n#include <linux/backing-dev.h>\n#include <linux/fscache.h>\n#include <linux/sched.h>\n#include <linux/workqueue.h>\n#include <linux/key.h>\n#include <linux/rxrpc.h>\n#include <linux/skbuff.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n\nextern void afs_discard_callback_on_delete(struct afs_vnode *);\nextern void afs_give_up_callback(struct afs_vnode *);\nextern void afs_lock_may_be_available(struct afs_vnode *);\nextern void afs_zap_data(struct afs_vnode *);\nextern void afs_evict_inode(struct inode *);\nextern int afs_drop_inode(struct inode *);\nextern void afs_clear_permits(struct afs_vnode *);\nextern int afs_permission(struct inode *, int);\nextern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);\nextern int afs_writeback_all(struct afs_vnode *);\n\nstatic inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_vnode_remove",
          "args": [
            "dvnode",
            "key",
            "dentry->d_name.name",
            "true"
          ],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "afs_vnode_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vnode.c",
          "lines": "508-558",
          "snippet": "int afs_vnode_remove(struct afs_vnode *vnode, struct key *key, const char *name,\n\t\t     bool isdir)\n{\n\tstruct afs_server *server;\n\tint ret;\n\n\t_enter(\"%s{%x:%u.%u},%x,%s\",\n\t       vnode->volume->vlocation->vldb.name,\n\t       vnode->fid.vid,\n\t       vnode->fid.vnode,\n\t       vnode->fid.unique,\n\t       key_serial(key),\n\t       name);\n\n\t/* this op will fetch the status on the directory we're removing from */\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt++;\n\tspin_unlock(&vnode->lock);\n\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(vnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %08x\\n\", ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_remove(server, key, vnode, name, isdir,\n\t\t\t\t    &afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(vnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0) {\n\t\tafs_vnode_finalise_status_update(vnode, server);\n\t\tafs_put_server(server);\n\t} else {\n\t\tafs_vnode_status_update_failed(vnode, ret);\n\t}\n\n\t_leave(\" = %d [cnt %d]\", ret, vnode->update_cnt);\n\treturn ret;\n\nno_server:\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\t_leave(\" = %ld [cnt %d]\", PTR_ERR(server), vnode->update_cnt);\n\treturn PTR_ERR(server);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint afs_vnode_remove(struct afs_vnode *vnode, struct key *key, const char *name,\n\t\t     bool isdir)\n{\n\tstruct afs_server *server;\n\tint ret;\n\n\t_enter(\"%s{%x:%u.%u},%x,%s\",\n\t       vnode->volume->vlocation->vldb.name,\n\t       vnode->fid.vid,\n\t       vnode->fid.vnode,\n\t       vnode->fid.unique,\n\t       key_serial(key),\n\t       name);\n\n\t/* this op will fetch the status on the directory we're removing from */\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt++;\n\tspin_unlock(&vnode->lock);\n\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(vnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %08x\\n\", ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_remove(server, key, vnode, name, isdir,\n\t\t\t\t    &afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(vnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0) {\n\t\tafs_vnode_finalise_status_update(vnode, server);\n\t\tafs_put_server(server);\n\t} else {\n\t\tafs_vnode_status_update_failed(vnode, ret);\n\t}\n\n\t_leave(\" = %d [cnt %d]\", ret, vnode->update_cnt);\n\treturn ret;\n\nno_server:\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\t_leave(\" = %ld [cnt %d]\", PTR_ERR(server), vnode->update_cnt);\n\treturn PTR_ERR(server);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "key"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "key"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_request_key",
          "args": [
            "dvnode->volume->cell"
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "afs_request_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/security.c",
          "lines": "23-46",
          "snippet": "struct key *afs_request_key(struct afs_cell *cell)\n{\n\tstruct key *key;\n\n\t_enter(\"{%x}\", key_serial(cell->anonymous_key));\n\n\t_debug(\"key %s\", cell->anonymous_key->description);\n\tkey = request_key(&key_type_rxrpc, cell->anonymous_key->description,\n\t\t\t  NULL);\n\tif (IS_ERR(key)) {\n\t\tif (PTR_ERR(key) != -ENOKEY) {\n\t\t\t_leave(\" = %ld\", PTR_ERR(key));\n\t\t\treturn key;\n\t\t}\n\n\t\t/* act as anonymous user */\n\t\t_leave(\" = {%x} [anon]\", key_serial(cell->anonymous_key));\n\t\treturn key_get(cell->anonymous_key);\n\t} else {\n\t\t/* act as authorised user */\n\t\t_leave(\" = {%x} [auth]\", key_serial(key));\n\t\treturn key;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <keys/rxrpc-type.h>",
            "#include <linux/sched.h>",
            "#include <linux/ctype.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <keys/rxrpc-type.h>\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstruct key *afs_request_key(struct afs_cell *cell)\n{\n\tstruct key *key;\n\n\t_enter(\"{%x}\", key_serial(cell->anonymous_key));\n\n\t_debug(\"key %s\", cell->anonymous_key->description);\n\tkey = request_key(&key_type_rxrpc, cell->anonymous_key->description,\n\t\t\t  NULL);\n\tif (IS_ERR(key)) {\n\t\tif (PTR_ERR(key) != -ENOKEY) {\n\t\t\t_leave(\" = %ld\", PTR_ERR(key));\n\t\t\treturn key;\n\t\t}\n\n\t\t/* act as anonymous user */\n\t\t_leave(\" = {%x} [anon]\", key_serial(cell->anonymous_key));\n\t\treturn key_get(cell->anonymous_key);\n\t} else {\n\t\t/* act as authorised user */\n\t\t_leave(\" = {%x} [auth]\", key_serial(key));\n\t\treturn key;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%x:%u},{%pd}\"",
            "dvnode->fid.vid",
            "dvnode->fid.vnode",
            "dentry"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct dentry *afs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t unsigned int flags);\nstatic int afs_d_revalidate(struct dentry *dentry, unsigned int flags);\nstatic int afs_d_delete(const struct dentry *dentry);\nstatic void afs_d_release(struct dentry *dentry);\nstatic int afs_rmdir(struct inode *dir, struct dentry *dentry);\nstatic int afs_unlink(struct inode *dir, struct dentry *dentry);\nstatic int afs_link(struct dentry *from, struct inode *dir,\n\t\t    struct dentry *dentry);\n\nstatic int afs_rmdir(struct inode *dir, struct dentry *dentry)\n{\n\tstruct afs_vnode *dvnode, *vnode;\n\tstruct key *key;\n\tint ret;\n\n\tdvnode = AFS_FS_I(dir);\n\n\t_enter(\"{%x:%u},{%pd}\",\n\t       dvnode->fid.vid, dvnode->fid.vnode, dentry);\n\n\tkey = afs_request_key(dvnode->volume->cell);\n\tif (IS_ERR(key)) {\n\t\tret = PTR_ERR(key);\n\t\tgoto error;\n\t}\n\n\tret = afs_vnode_remove(dvnode, key, dentry->d_name.name, true);\n\tif (ret < 0)\n\t\tgoto rmdir_error;\n\n\tif (dentry->d_inode) {\n\t\tvnode = AFS_FS_I(dentry->d_inode);\n\t\tclear_nlink(&vnode->vfs_inode);\n\t\tset_bit(AFS_VNODE_DELETED, &vnode->flags);\n\t\tafs_discard_callback_on_delete(vnode);\n\t}\n\n\tkey_put(key);\n\t_leave(\" = 0\");\n\treturn 0;\n\nrmdir_error:\n\tkey_put(key);\nerror:\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "afs_mkdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/dir.c",
    "lines": "730-791",
    "snippet": "static int afs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tstruct afs_file_status status;\n\tstruct afs_callback cb;\n\tstruct afs_server *server;\n\tstruct afs_vnode *dvnode, *vnode;\n\tstruct afs_fid fid;\n\tstruct inode *inode;\n\tstruct key *key;\n\tint ret;\n\n\tdvnode = AFS_FS_I(dir);\n\n\t_enter(\"{%x:%u},{%pd},%ho\",\n\t       dvnode->fid.vid, dvnode->fid.vnode, dentry, mode);\n\n\tkey = afs_request_key(dvnode->volume->cell);\n\tif (IS_ERR(key)) {\n\t\tret = PTR_ERR(key);\n\t\tgoto error;\n\t}\n\n\tmode |= S_IFDIR;\n\tret = afs_vnode_create(dvnode, key, dentry->d_name.name,\n\t\t\t       mode, &fid, &status, &cb, &server);\n\tif (ret < 0)\n\t\tgoto mkdir_error;\n\n\tinode = afs_iget(dir->i_sb, key, &fid, &status, &cb);\n\tif (IS_ERR(inode)) {\n\t\t/* ENOMEM at a really inconvenient time - just abandon the new\n\t\t * directory on the server */\n\t\tret = PTR_ERR(inode);\n\t\tgoto iget_error;\n\t}\n\n\t/* apply the status report we've got for the new vnode */\n\tvnode = AFS_FS_I(inode);\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt++;\n\tspin_unlock(&vnode->lock);\n\tafs_vnode_finalise_status_update(vnode, server);\n\tafs_put_server(server);\n\n\td_instantiate(dentry, inode);\n\tif (d_unhashed(dentry)) {\n\t\t_debug(\"not hashed\");\n\t\td_rehash(dentry);\n\t}\n\tkey_put(key);\n\t_leave(\" = 0\");\n\treturn 0;\n\niget_error:\n\tafs_put_server(server);\nmkdir_error:\n\tkey_put(key);\nerror:\n\td_drop(dentry);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int afs_d_delete(const struct dentry *dentry);",
      "static void afs_d_release(struct dentry *dentry);",
      "static int afs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode);",
      "static int afs_rmdir(struct inode *dir, struct dentry *dentry);",
      "static int afs_unlink(struct inode *dir, struct dentry *dentry);",
      "static int afs_link(struct dentry *from, struct inode *dir,\n\t\t    struct dentry *dentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 789
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_drop",
          "args": [
            "dentry"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "check_and_drop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1447-1453",
          "snippet": "static void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void check_and_drop(void *_data)\n{\n\tstruct detach_data *data = _data;\n\n\tif (!data->mountpoint && !data->select.found)\n\t\t__d_drop(data->select.start);\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "key"
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "expkey_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "40-49",
          "snippet": "static void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree(key);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\n\nstatic void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree(key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_put_server",
          "args": [
            "server"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "afs_put_server",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/server.c",
          "lines": "219-246",
          "snippet": "void afs_put_server(struct afs_server *server)\n{\n\tif (!server)\n\t\treturn;\n\n\t_enter(\"%p{%d}\", server, atomic_read(&server->usage));\n\n\t_debug(\"PUT SERVER %d\", atomic_read(&server->usage));\n\n\tASSERTCMP(atomic_read(&server->usage), >, 0);\n\n\tif (likely(!atomic_dec_and_test(&server->usage))) {\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tafs_flush_callback_breaks(server);\n\n\tspin_lock(&afs_server_graveyard_lock);\n\tif (atomic_read(&server->usage) == 0) {\n\t\tlist_move_tail(&server->grave, &afs_server_graveyard);\n\t\tserver->time_of_death = get_seconds();\n\t\tqueue_delayed_work(afs_wq, &afs_server_reaper,\n\t\t\t\t   afs_server_timeout * HZ);\n\t}\n\tspin_unlock(&afs_server_graveyard_lock);\n\t_leave(\" [dead]\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned afs_server_timeout = 10;",
            "static LIST_HEAD(afs_server_graveyard);",
            "static DEFINE_SPINLOCK(afs_server_graveyard_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/slab.h>\n#include <linux/sched.h>\n\nstatic unsigned afs_server_timeout = 10;\nstatic LIST_HEAD(afs_server_graveyard);\nstatic DEFINE_SPINLOCK(afs_server_graveyard_lock);\n\nvoid afs_put_server(struct afs_server *server)\n{\n\tif (!server)\n\t\treturn;\n\n\t_enter(\"%p{%d}\", server, atomic_read(&server->usage));\n\n\t_debug(\"PUT SERVER %d\", atomic_read(&server->usage));\n\n\tASSERTCMP(atomic_read(&server->usage), >, 0);\n\n\tif (likely(!atomic_dec_and_test(&server->usage))) {\n\t\t_leave(\"\");\n\t\treturn;\n\t}\n\n\tafs_flush_callback_breaks(server);\n\n\tspin_lock(&afs_server_graveyard_lock);\n\tif (atomic_read(&server->usage) == 0) {\n\t\tlist_move_tail(&server->grave, &afs_server_graveyard);\n\t\tserver->time_of_death = get_seconds();\n\t\tqueue_delayed_work(afs_wq, &afs_server_reaper,\n\t\t\t\t   afs_server_timeout * HZ);\n\t}\n\tspin_unlock(&afs_server_graveyard_lock);\n\t_leave(\" [dead]\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = 0\""
          ],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_rehash",
          "args": [
            "dentry"
          ],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "d_rehash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "2403-2408",
          "snippet": "void d_rehash(struct dentry * entry)\n{\n\tspin_lock(&entry->d_lock);\n\t_d_rehash(entry);\n\tspin_unlock(&entry->d_lock);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid d_rehash(struct dentry * entry)\n{\n\tspin_lock(&entry->d_lock);\n\t_d_rehash(entry);\n\tspin_unlock(&entry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"not hashed\""
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_suballoc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2634-2662",
          "snippet": "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_unhashed",
          "args": [
            "dentry"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "d_instantiate_no_diralias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "1839-1854",
          "snippet": "int d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nint d_instantiate_no_diralias(struct dentry *entry, struct inode *inode)\n{\n\tBUG_ON(!hlist_unhashed(&entry->d_u.d_alias));\n\n\tspin_lock(&inode->i_lock);\n\tif (S_ISDIR(inode->i_mode) && !hlist_empty(&inode->i_dentry)) {\n\t\tspin_unlock(&inode->i_lock);\n\t\tiput(inode);\n\t\treturn -EBUSY;\n\t}\n\t__d_instantiate(entry, inode);\n\tspin_unlock(&inode->i_lock);\n\tsecurity_d_instantiate(entry, inode);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_vnode_finalise_status_update",
          "args": [
            "vnode",
            "server"
          ],
          "line": 771
        },
        "resolved": true,
        "details": {
          "function_name": "afs_vnode_finalise_status_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vnode.c",
          "lines": "213-230",
          "snippet": "void afs_vnode_finalise_status_update(struct afs_vnode *vnode,\n\t\t\t\t      struct afs_server *server)\n{\n\tstruct afs_server *oldserver = NULL;\n\n\t_enter(\"%p,%p\", vnode, server);\n\n\tspin_lock(&vnode->lock);\n\tclear_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\tafs_vnode_note_promise(vnode, server);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\n\twake_up_all(&vnode->update_waitq);\n\tafs_put_server(oldserver);\n\t_leave(\"\");\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nvoid afs_vnode_finalise_status_update(struct afs_vnode *vnode,\n\t\t\t\t      struct afs_server *server)\n{\n\tstruct afs_server *oldserver = NULL;\n\n\t_enter(\"%p,%p\", vnode, server);\n\n\tspin_lock(&vnode->lock);\n\tclear_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\tafs_vnode_note_promise(vnode, server);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\n\twake_up_all(&vnode->update_waitq);\n\tafs_put_server(oldserver);\n\t_leave(\"\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vnode->lock"
          ],
          "line": 770
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&vnode->lock"
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "AFS_FS_I",
          "args": [
            "inode"
          ],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "AFS_FS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/internal.h",
          "lines": "687-690",
          "snippet": "static inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}",
          "includes": [
            "#include \"afs_vl.h\"",
            "#include \"afs.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/fscache.h>",
            "#include <linux/sched.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/key.h>",
            "#include <linux/rxrpc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void afs_discard_callback_on_delete(struct afs_vnode *);",
            "extern void afs_give_up_callback(struct afs_vnode *);",
            "extern void afs_lock_may_be_available(struct afs_vnode *);",
            "extern void afs_zap_data(struct afs_vnode *);",
            "extern void afs_evict_inode(struct inode *);",
            "extern int afs_drop_inode(struct inode *);",
            "extern void afs_clear_permits(struct afs_vnode *);",
            "extern int afs_permission(struct inode *, int);",
            "extern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);",
            "extern int afs_writeback_all(struct afs_vnode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_vl.h\"\n#include \"afs.h\"\n#include <linux/backing-dev.h>\n#include <linux/fscache.h>\n#include <linux/sched.h>\n#include <linux/workqueue.h>\n#include <linux/key.h>\n#include <linux/rxrpc.h>\n#include <linux/skbuff.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n\nextern void afs_discard_callback_on_delete(struct afs_vnode *);\nextern void afs_give_up_callback(struct afs_vnode *);\nextern void afs_lock_may_be_available(struct afs_vnode *);\nextern void afs_zap_data(struct afs_vnode *);\nextern void afs_evict_inode(struct inode *);\nextern int afs_drop_inode(struct inode *);\nextern void afs_clear_permits(struct afs_vnode *);\nextern int afs_permission(struct inode *, int);\nextern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);\nextern int afs_writeback_all(struct afs_vnode *);\n\nstatic inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_iget",
          "args": [
            "dir->i_sb",
            "key",
            "&fid",
            "&status",
            "&cb"
          ],
          "line": 758
        },
        "resolved": true,
        "details": {
          "function_name": "afs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/inode.c",
          "lines": "198-285",
          "snippet": "struct inode *afs_iget(struct super_block *sb, struct key *key,\n\t\t       struct afs_fid *fid, struct afs_file_status *status,\n\t\t       struct afs_callback *cb)\n{\n\tstruct afs_iget_data data = { .fid = *fid };\n\tstruct afs_super_info *as;\n\tstruct afs_vnode *vnode;\n\tstruct inode *inode;\n\tint ret;\n\n\t_enter(\",{%x:%u.%u},,\", fid->vid, fid->vnode, fid->unique);\n\n\tas = sb->s_fs_info;\n\tdata.volume = as->volume;\n\n\tinode = iget5_locked(sb, fid->vnode, afs_iget5_test, afs_iget5_set,\n\t\t\t     &data);\n\tif (!inode) {\n\t\t_leave(\" = -ENOMEM\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t_debug(\"GOT INODE %p { vl=%x vn=%x, u=%x }\",\n\t       inode, fid->vid, fid->vnode, fid->unique);\n\n\tvnode = AFS_FS_I(inode);\n\n\t/* deal with an existing inode */\n\tif (!(inode->i_state & I_NEW)) {\n\t\t_leave(\" = %p\", inode);\n\t\treturn inode;\n\t}\n\n\tif (!status) {\n\t\t/* it's a remotely extant inode */\n\t\tset_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\t\tret = afs_vnode_fetch_status(vnode, NULL, key);\n\t\tif (ret < 0)\n\t\t\tgoto bad_inode;\n\t} else {\n\t\t/* it's an inode we just created */\n\t\tmemcpy(&vnode->status, status, sizeof(vnode->status));\n\n\t\tif (!cb) {\n\t\t\t/* it's a symlink we just created (the fileserver\n\t\t\t * didn't give us a callback) */\n\t\t\tvnode->cb_version = 0;\n\t\t\tvnode->cb_expiry = 0;\n\t\t\tvnode->cb_type = 0;\n\t\t\tvnode->cb_expires = get_seconds();\n\t\t} else {\n\t\t\tvnode->cb_version = cb->version;\n\t\t\tvnode->cb_expiry = cb->expiry;\n\t\t\tvnode->cb_type = cb->type;\n\t\t\tvnode->cb_expires = vnode->cb_expiry + get_seconds();\n\t\t}\n\t}\n\n\t/* set up caching before mapping the status, as map-status reads the\n\t * first page of symlinks to see if they're really mountpoints */\n\tinode->i_size = vnode->status.size;\n#ifdef CONFIG_AFS_FSCACHE\n\tvnode->cache = fscache_acquire_cookie(vnode->volume->cache,\n\t\t\t\t\t      &afs_vnode_cache_index_def,\n\t\t\t\t\t      vnode, true);\n#endif\n\n\tret = afs_inode_map_status(vnode, key);\n\tif (ret < 0)\n\t\tgoto bad_inode;\n\n\t/* success */\n\tclear_bit(AFS_VNODE_UNSET, &vnode->flags);\n\tinode->i_flags |= S_NOATIME;\n\tunlock_new_inode(inode);\n\t_leave(\" = %p [CB { v=%u t=%u }]\", inode, vnode->cb_version, vnode->cb_type);\n\treturn inode;\n\n\t/* failure */\nbad_inode:\n#ifdef CONFIG_AFS_FSCACHE\n\tfscache_relinquish_cookie(vnode->cache, 0);\n\tvnode->cache = NULL;\n#endif\n\tiget_failed(inode);\n\t_leave(\" = %d [bad]\", ret);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstruct inode *afs_iget(struct super_block *sb, struct key *key,\n\t\t       struct afs_fid *fid, struct afs_file_status *status,\n\t\t       struct afs_callback *cb)\n{\n\tstruct afs_iget_data data = { .fid = *fid };\n\tstruct afs_super_info *as;\n\tstruct afs_vnode *vnode;\n\tstruct inode *inode;\n\tint ret;\n\n\t_enter(\",{%x:%u.%u},,\", fid->vid, fid->vnode, fid->unique);\n\n\tas = sb->s_fs_info;\n\tdata.volume = as->volume;\n\n\tinode = iget5_locked(sb, fid->vnode, afs_iget5_test, afs_iget5_set,\n\t\t\t     &data);\n\tif (!inode) {\n\t\t_leave(\" = -ENOMEM\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t_debug(\"GOT INODE %p { vl=%x vn=%x, u=%x }\",\n\t       inode, fid->vid, fid->vnode, fid->unique);\n\n\tvnode = AFS_FS_I(inode);\n\n\t/* deal with an existing inode */\n\tif (!(inode->i_state & I_NEW)) {\n\t\t_leave(\" = %p\", inode);\n\t\treturn inode;\n\t}\n\n\tif (!status) {\n\t\t/* it's a remotely extant inode */\n\t\tset_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\t\tret = afs_vnode_fetch_status(vnode, NULL, key);\n\t\tif (ret < 0)\n\t\t\tgoto bad_inode;\n\t} else {\n\t\t/* it's an inode we just created */\n\t\tmemcpy(&vnode->status, status, sizeof(vnode->status));\n\n\t\tif (!cb) {\n\t\t\t/* it's a symlink we just created (the fileserver\n\t\t\t * didn't give us a callback) */\n\t\t\tvnode->cb_version = 0;\n\t\t\tvnode->cb_expiry = 0;\n\t\t\tvnode->cb_type = 0;\n\t\t\tvnode->cb_expires = get_seconds();\n\t\t} else {\n\t\t\tvnode->cb_version = cb->version;\n\t\t\tvnode->cb_expiry = cb->expiry;\n\t\t\tvnode->cb_type = cb->type;\n\t\t\tvnode->cb_expires = vnode->cb_expiry + get_seconds();\n\t\t}\n\t}\n\n\t/* set up caching before mapping the status, as map-status reads the\n\t * first page of symlinks to see if they're really mountpoints */\n\tinode->i_size = vnode->status.size;\n#ifdef CONFIG_AFS_FSCACHE\n\tvnode->cache = fscache_acquire_cookie(vnode->volume->cache,\n\t\t\t\t\t      &afs_vnode_cache_index_def,\n\t\t\t\t\t      vnode, true);\n#endif\n\n\tret = afs_inode_map_status(vnode, key);\n\tif (ret < 0)\n\t\tgoto bad_inode;\n\n\t/* success */\n\tclear_bit(AFS_VNODE_UNSET, &vnode->flags);\n\tinode->i_flags |= S_NOATIME;\n\tunlock_new_inode(inode);\n\t_leave(\" = %p [CB { v=%u t=%u }]\", inode, vnode->cb_version, vnode->cb_type);\n\treturn inode;\n\n\t/* failure */\nbad_inode:\n#ifdef CONFIG_AFS_FSCACHE\n\tfscache_relinquish_cookie(vnode->cache, 0);\n\tvnode->cache = NULL;\n#endif\n\tiget_failed(inode);\n\t_leave(\" = %d [bad]\", ret);\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_vnode_create",
          "args": [
            "dvnode",
            "key",
            "dentry->d_name.name",
            "mode",
            "&fid",
            "&status",
            "&cb",
            "&server"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "afs_vnode_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/vnode.c",
          "lines": "450-503",
          "snippet": "int afs_vnode_create(struct afs_vnode *vnode, struct key *key,\n\t\t     const char *name, umode_t mode, struct afs_fid *newfid,\n\t\t     struct afs_file_status *newstatus,\n\t\t     struct afs_callback *newcb, struct afs_server **_server)\n{\n\tstruct afs_server *server;\n\tint ret;\n\n\t_enter(\"%s{%x:%u.%u},%x,%s,,\",\n\t       vnode->volume->vlocation->vldb.name,\n\t       vnode->fid.vid,\n\t       vnode->fid.vnode,\n\t       vnode->fid.unique,\n\t       key_serial(key),\n\t       name);\n\n\t/* this op will fetch the status on the directory we're creating in */\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt++;\n\tspin_unlock(&vnode->lock);\n\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(vnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %08x\\n\", ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_create(server, key, vnode, name, mode, newfid,\n\t\t\t\t    newstatus, newcb, &afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(vnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0) {\n\t\tafs_vnode_finalise_status_update(vnode, server);\n\t\t*_server = server;\n\t} else {\n\t\tafs_vnode_status_update_failed(vnode, ret);\n\t\t*_server = NULL;\n\t}\n\n\t_leave(\" = %d [cnt %d]\", ret, vnode->update_cnt);\n\treturn ret;\n\nno_server:\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\t_leave(\" = %ld [cnt %d]\", PTR_ERR(server), vnode->update_cnt);\n\treturn PTR_ERR(server);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint afs_vnode_create(struct afs_vnode *vnode, struct key *key,\n\t\t     const char *name, umode_t mode, struct afs_fid *newfid,\n\t\t     struct afs_file_status *newstatus,\n\t\t     struct afs_callback *newcb, struct afs_server **_server)\n{\n\tstruct afs_server *server;\n\tint ret;\n\n\t_enter(\"%s{%x:%u.%u},%x,%s,,\",\n\t       vnode->volume->vlocation->vldb.name,\n\t       vnode->fid.vid,\n\t       vnode->fid.vnode,\n\t       vnode->fid.unique,\n\t       key_serial(key),\n\t       name);\n\n\t/* this op will fetch the status on the directory we're creating in */\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt++;\n\tspin_unlock(&vnode->lock);\n\n\tdo {\n\t\t/* pick a server to query */\n\t\tserver = afs_volume_pick_fileserver(vnode);\n\t\tif (IS_ERR(server))\n\t\t\tgoto no_server;\n\n\t\t_debug(\"USING SERVER: %08x\\n\", ntohl(server->addr.s_addr));\n\n\t\tret = afs_fs_create(server, key, vnode, name, mode, newfid,\n\t\t\t\t    newstatus, newcb, &afs_sync_call);\n\n\t} while (!afs_volume_release_fileserver(vnode, server, ret));\n\n\t/* adjust the flags */\n\tif (ret == 0) {\n\t\tafs_vnode_finalise_status_update(vnode, server);\n\t\t*_server = server;\n\t} else {\n\t\tafs_vnode_status_update_failed(vnode, ret);\n\t\t*_server = NULL;\n\t}\n\n\t_leave(\" = %d [cnt %d]\", ret, vnode->update_cnt);\n\treturn ret;\n\nno_server:\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt--;\n\tASSERTCMP(vnode->update_cnt, >=, 0);\n\tspin_unlock(&vnode->lock);\n\t_leave(\" = %ld [cnt %d]\", PTR_ERR(server), vnode->update_cnt);\n\treturn PTR_ERR(server);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "key"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "key"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_request_key",
          "args": [
            "dvnode->volume->cell"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "afs_request_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/security.c",
          "lines": "23-46",
          "snippet": "struct key *afs_request_key(struct afs_cell *cell)\n{\n\tstruct key *key;\n\n\t_enter(\"{%x}\", key_serial(cell->anonymous_key));\n\n\t_debug(\"key %s\", cell->anonymous_key->description);\n\tkey = request_key(&key_type_rxrpc, cell->anonymous_key->description,\n\t\t\t  NULL);\n\tif (IS_ERR(key)) {\n\t\tif (PTR_ERR(key) != -ENOKEY) {\n\t\t\t_leave(\" = %ld\", PTR_ERR(key));\n\t\t\treturn key;\n\t\t}\n\n\t\t/* act as anonymous user */\n\t\t_leave(\" = {%x} [anon]\", key_serial(cell->anonymous_key));\n\t\treturn key_get(cell->anonymous_key);\n\t} else {\n\t\t/* act as authorised user */\n\t\t_leave(\" = {%x} [auth]\", key_serial(key));\n\t\treturn key;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <keys/rxrpc-type.h>",
            "#include <linux/sched.h>",
            "#include <linux/ctype.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <keys/rxrpc-type.h>\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstruct key *afs_request_key(struct afs_cell *cell)\n{\n\tstruct key *key;\n\n\t_enter(\"{%x}\", key_serial(cell->anonymous_key));\n\n\t_debug(\"key %s\", cell->anonymous_key->description);\n\tkey = request_key(&key_type_rxrpc, cell->anonymous_key->description,\n\t\t\t  NULL);\n\tif (IS_ERR(key)) {\n\t\tif (PTR_ERR(key) != -ENOKEY) {\n\t\t\t_leave(\" = %ld\", PTR_ERR(key));\n\t\t\treturn key;\n\t\t}\n\n\t\t/* act as anonymous user */\n\t\t_leave(\" = {%x} [anon]\", key_serial(cell->anonymous_key));\n\t\treturn key_get(cell->anonymous_key);\n\t} else {\n\t\t/* act as authorised user */\n\t\t_leave(\" = {%x} [auth]\", key_serial(key));\n\t\treturn key;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%x:%u},{%pd},%ho\"",
            "dvnode->fid.vid",
            "dvnode->fid.vnode",
            "dentry",
            "mode"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int afs_d_delete(const struct dentry *dentry);\nstatic void afs_d_release(struct dentry *dentry);\nstatic int afs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode);\nstatic int afs_rmdir(struct inode *dir, struct dentry *dentry);\nstatic int afs_unlink(struct inode *dir, struct dentry *dentry);\nstatic int afs_link(struct dentry *from, struct inode *dir,\n\t\t    struct dentry *dentry);\n\nstatic int afs_mkdir(struct inode *dir, struct dentry *dentry, umode_t mode)\n{\n\tstruct afs_file_status status;\n\tstruct afs_callback cb;\n\tstruct afs_server *server;\n\tstruct afs_vnode *dvnode, *vnode;\n\tstruct afs_fid fid;\n\tstruct inode *inode;\n\tstruct key *key;\n\tint ret;\n\n\tdvnode = AFS_FS_I(dir);\n\n\t_enter(\"{%x:%u},{%pd},%ho\",\n\t       dvnode->fid.vid, dvnode->fid.vnode, dentry, mode);\n\n\tkey = afs_request_key(dvnode->volume->cell);\n\tif (IS_ERR(key)) {\n\t\tret = PTR_ERR(key);\n\t\tgoto error;\n\t}\n\n\tmode |= S_IFDIR;\n\tret = afs_vnode_create(dvnode, key, dentry->d_name.name,\n\t\t\t       mode, &fid, &status, &cb, &server);\n\tif (ret < 0)\n\t\tgoto mkdir_error;\n\n\tinode = afs_iget(dir->i_sb, key, &fid, &status, &cb);\n\tif (IS_ERR(inode)) {\n\t\t/* ENOMEM at a really inconvenient time - just abandon the new\n\t\t * directory on the server */\n\t\tret = PTR_ERR(inode);\n\t\tgoto iget_error;\n\t}\n\n\t/* apply the status report we've got for the new vnode */\n\tvnode = AFS_FS_I(inode);\n\tspin_lock(&vnode->lock);\n\tvnode->update_cnt++;\n\tspin_unlock(&vnode->lock);\n\tafs_vnode_finalise_status_update(vnode, server);\n\tafs_put_server(server);\n\n\td_instantiate(dentry, inode);\n\tif (d_unhashed(dentry)) {\n\t\t_debug(\"not hashed\");\n\t\td_rehash(dentry);\n\t}\n\tkey_put(key);\n\t_leave(\" = 0\");\n\treturn 0;\n\niget_error:\n\tafs_put_server(server);\nmkdir_error:\n\tkey_put(key);\nerror:\n\td_drop(dentry);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "afs_d_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/dir.c",
    "lines": "722-725",
    "snippet": "static void afs_d_release(struct dentry *dentry)\n{\n\t_enter(\"%pd\", dentry);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int afs_d_delete(const struct dentry *dentry);",
      "static void afs_d_release(struct dentry *dentry);",
      "static int afs_rmdir(struct inode *dir, struct dentry *dentry);",
      "static int afs_unlink(struct inode *dir, struct dentry *dentry);",
      "static int afs_link(struct dentry *from, struct inode *dir,\n\t\t    struct dentry *dentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"%pd\"",
            "dentry"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "30-42",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int afs_d_delete(const struct dentry *dentry);\nstatic void afs_d_release(struct dentry *dentry);\nstatic int afs_rmdir(struct inode *dir, struct dentry *dentry);\nstatic int afs_unlink(struct inode *dir, struct dentry *dentry);\nstatic int afs_link(struct dentry *from, struct inode *dir,\n\t\t    struct dentry *dentry);\n\nstatic void afs_d_release(struct dentry *dentry)\n{\n\t_enter(\"%pd\", dentry);\n}"
  },
  {
    "function_name": "afs_d_delete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/dir.c",
    "lines": "699-717",
    "snippet": "static int afs_d_delete(const struct dentry *dentry)\n{\n\t_enter(\"%pd\", dentry);\n\n\tif (dentry->d_flags & DCACHE_NFSFS_RENAMED)\n\t\tgoto zap;\n\n\tif (dentry->d_inode &&\n\t    (test_bit(AFS_VNODE_DELETED,   &AFS_FS_I(dentry->d_inode)->flags) ||\n\t     test_bit(AFS_VNODE_PSEUDODIR, &AFS_FS_I(dentry->d_inode)->flags)))\n\t\tgoto zap;\n\n\t_leave(\" = 0 [keep]\");\n\treturn 0;\n\nzap:\n\t_leave(\" = 1 [zap]\");\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dentry *afs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t unsigned int flags);",
      "static int afs_d_revalidate(struct dentry *dentry, unsigned int flags);",
      "static int afs_d_delete(const struct dentry *dentry);",
      "static void afs_d_release(struct dentry *dentry);",
      "static int afs_rmdir(struct inode *dir, struct dentry *dentry);",
      "static int afs_unlink(struct inode *dir, struct dentry *dentry);",
      "static int afs_link(struct dentry *from, struct inode *dir,\n\t\t    struct dentry *dentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = 1 [zap]\""
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "AFS_VNODE_PSEUDODIR",
            "&AFS_FS_I(dentry->d_inode)->flags"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AFS_FS_I",
          "args": [
            "dentry->d_inode"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "AFS_FS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/internal.h",
          "lines": "687-690",
          "snippet": "static inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}",
          "includes": [
            "#include \"afs_vl.h\"",
            "#include \"afs.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/fscache.h>",
            "#include <linux/sched.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/key.h>",
            "#include <linux/rxrpc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void afs_discard_callback_on_delete(struct afs_vnode *);",
            "extern void afs_give_up_callback(struct afs_vnode *);",
            "extern void afs_lock_may_be_available(struct afs_vnode *);",
            "extern void afs_zap_data(struct afs_vnode *);",
            "extern void afs_evict_inode(struct inode *);",
            "extern int afs_drop_inode(struct inode *);",
            "extern void afs_clear_permits(struct afs_vnode *);",
            "extern int afs_permission(struct inode *, int);",
            "extern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);",
            "extern int afs_writeback_all(struct afs_vnode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_vl.h\"\n#include \"afs.h\"\n#include <linux/backing-dev.h>\n#include <linux/fscache.h>\n#include <linux/sched.h>\n#include <linux/workqueue.h>\n#include <linux/key.h>\n#include <linux/rxrpc.h>\n#include <linux/skbuff.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n\nextern void afs_discard_callback_on_delete(struct afs_vnode *);\nextern void afs_give_up_callback(struct afs_vnode *);\nextern void afs_lock_may_be_available(struct afs_vnode *);\nextern void afs_zap_data(struct afs_vnode *);\nextern void afs_evict_inode(struct inode *);\nextern int afs_drop_inode(struct inode *);\nextern void afs_clear_permits(struct afs_vnode *);\nextern int afs_permission(struct inode *, int);\nextern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);\nextern int afs_writeback_all(struct afs_vnode *);\n\nstatic inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"%pd\"",
            "dentry"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "30-42",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct dentry *afs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t unsigned int flags);\nstatic int afs_d_revalidate(struct dentry *dentry, unsigned int flags);\nstatic int afs_d_delete(const struct dentry *dentry);\nstatic void afs_d_release(struct dentry *dentry);\nstatic int afs_rmdir(struct inode *dir, struct dentry *dentry);\nstatic int afs_unlink(struct inode *dir, struct dentry *dentry);\nstatic int afs_link(struct dentry *from, struct inode *dir,\n\t\t    struct dentry *dentry);\n\nstatic int afs_d_delete(const struct dentry *dentry)\n{\n\t_enter(\"%pd\", dentry);\n\n\tif (dentry->d_flags & DCACHE_NFSFS_RENAMED)\n\t\tgoto zap;\n\n\tif (dentry->d_inode &&\n\t    (test_bit(AFS_VNODE_DELETED,   &AFS_FS_I(dentry->d_inode)->flags) ||\n\t     test_bit(AFS_VNODE_PSEUDODIR, &AFS_FS_I(dentry->d_inode)->flags)))\n\t\tgoto zap;\n\n\t_leave(\" = 0 [keep]\");\n\treturn 0;\n\nzap:\n\t_leave(\" = 1 [zap]\");\n\treturn 1;\n}"
  },
  {
    "function_name": "afs_d_revalidate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/dir.c",
    "lines": "577-691",
    "snippet": "static int afs_d_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tstruct afs_vnode *vnode, *dir;\n\tstruct afs_fid uninitialized_var(fid);\n\tstruct dentry *parent;\n\tstruct key *key;\n\tvoid *dir_version;\n\tint ret;\n\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\tvnode = AFS_FS_I(dentry->d_inode);\n\n\tif (dentry->d_inode)\n\t\t_enter(\"{v={%x:%u} n=%pd fl=%lx},\",\n\t\t       vnode->fid.vid, vnode->fid.vnode, dentry,\n\t\t       vnode->flags);\n\telse\n\t\t_enter(\"{neg n=%pd}\", dentry);\n\n\tkey = afs_request_key(AFS_FS_S(dentry->d_sb)->volume->cell);\n\tif (IS_ERR(key))\n\t\tkey = NULL;\n\n\t/* lock down the parent dentry so we can peer at it */\n\tparent = dget_parent(dentry);\n\tdir = AFS_FS_I(parent->d_inode);\n\n\t/* validate the parent directory */\n\tif (test_bit(AFS_VNODE_MODIFIED, &dir->flags))\n\t\tafs_validate(dir, key);\n\n\tif (test_bit(AFS_VNODE_DELETED, &dir->flags)) {\n\t\t_debug(\"%pd: parent dir deleted\", dentry);\n\t\tgoto out_bad;\n\t}\n\n\tdir_version = (void *) (unsigned long) dir->status.data_version;\n\tif (dentry->d_fsdata == dir_version)\n\t\tgoto out_valid; /* the dir contents are unchanged */\n\n\t_debug(\"dir modified\");\n\n\t/* search the directory for this vnode */\n\tret = afs_do_lookup(&dir->vfs_inode, dentry, &fid, key);\n\tswitch (ret) {\n\tcase 0:\n\t\t/* the filename maps to something */\n\t\tif (!dentry->d_inode)\n\t\t\tgoto out_bad;\n\t\tif (is_bad_inode(dentry->d_inode)) {\n\t\t\tprintk(\"kAFS: afs_d_revalidate: %pd2 has bad inode\\n\",\n\t\t\t       dentry);\n\t\t\tgoto out_bad;\n\t\t}\n\n\t\t/* if the vnode ID has changed, then the dirent points to a\n\t\t * different file */\n\t\tif (fid.vnode != vnode->fid.vnode) {\n\t\t\t_debug(\"%pd: dirent changed [%u != %u]\",\n\t\t\t       dentry, fid.vnode,\n\t\t\t       vnode->fid.vnode);\n\t\t\tgoto not_found;\n\t\t}\n\n\t\t/* if the vnode ID uniqifier has changed, then the file has\n\t\t * been deleted and replaced, and the original vnode ID has\n\t\t * been reused */\n\t\tif (fid.unique != vnode->fid.unique) {\n\t\t\t_debug(\"%pd: file deleted (uq %u -> %u I:%u)\",\n\t\t\t       dentry, fid.unique,\n\t\t\t       vnode->fid.unique,\n\t\t\t       dentry->d_inode->i_generation);\n\t\t\tspin_lock(&vnode->lock);\n\t\t\tset_bit(AFS_VNODE_DELETED, &vnode->flags);\n\t\t\tspin_unlock(&vnode->lock);\n\t\t\tgoto not_found;\n\t\t}\n\t\tgoto out_valid;\n\n\tcase -ENOENT:\n\t\t/* the filename is unknown */\n\t\t_debug(\"%pd: dirent not found\", dentry);\n\t\tif (dentry->d_inode)\n\t\t\tgoto not_found;\n\t\tgoto out_valid;\n\n\tdefault:\n\t\t_debug(\"failed to iterate dir %pd: %d\",\n\t\t       parent, ret);\n\t\tgoto out_bad;\n\t}\n\nout_valid:\n\tdentry->d_fsdata = dir_version;\n\tdput(parent);\n\tkey_put(key);\n\t_leave(\" = 1 [valid]\");\n\treturn 1;\n\n\t/* the dirent, if it exists, now points to a different vnode */\nnot_found:\n\tspin_lock(&dentry->d_lock);\n\tdentry->d_flags |= DCACHE_NFSFS_RENAMED;\n\tspin_unlock(&dentry->d_lock);\n\nout_bad:\n\t_debug(\"dropping dentry %pd2\", dentry);\n\tdput(parent);\n\tkey_put(key);\n\n\t_leave(\" = 0 [bad]\");\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dentry *afs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t unsigned int flags);",
      "static int afs_dir_open(struct inode *inode, struct file *file);",
      "static int afs_d_revalidate(struct dentry *dentry, unsigned int flags);",
      "static int afs_d_delete(const struct dentry *dentry);",
      "static void afs_d_release(struct dentry *dentry);",
      "static int afs_rmdir(struct inode *dir, struct dentry *dentry);",
      "static int afs_unlink(struct inode *dir, struct dentry *dentry);",
      "static int afs_link(struct dentry *from, struct inode *dir,\n\t\t    struct dentry *dentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = 0 [bad]\""
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "key"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "expkey_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "40-49",
          "snippet": "static void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree(key);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\n\nstatic void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree(key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "parent"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "dput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "726-762",
          "snippet": "void dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nvoid dput(struct dentry *dentry)\n{\n\tif (unlikely(!dentry))\n\t\treturn;\n\nrepeat:\n\trcu_read_lock();\n\tif (likely(fast_dput(dentry))) {\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\n\t/* Slow case: now with the dentry lock held */\n\trcu_read_unlock();\n\n\t/* Unreachable? Get rid of it */\n\tif (unlikely(d_unhashed(dentry)))\n\t\tgoto kill_it;\n\n\tif (unlikely(dentry->d_flags & DCACHE_OP_DELETE)) {\n\t\tif (dentry->d_op->d_delete(dentry))\n\t\t\tgoto kill_it;\n\t}\n\n\tif (!(dentry->d_flags & DCACHE_REFERENCED))\n\t\tdentry->d_flags |= DCACHE_REFERENCED;\n\tdentry_lru_add(dentry);\n\n\tdentry->d_lockref.count--;\n\tspin_unlock(&dentry->d_lock);\n\treturn;\n\nkill_it:\n\tdentry = dentry_kill(dentry);\n\tif (dentry)\n\t\tgoto repeat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"dropping dentry %pd2\"",
            "dentry"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "392-395",
          "snippet": "static int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_destroy_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_destroy_inode(struct inode *inode);\n\nstatic int ocfs2_debug_release(struct inode *inode, struct file *file)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&dentry->d_lock"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"failed to iterate dir %pd: %d\"",
            "parent",
            "ret"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "befs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "53-67",
          "snippet": "void\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "AFS_VNODE_DELETED",
            "&vnode->flags"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "886-890",
          "snippet": "static inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline void ocfs2_set_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\tocfs2_set_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"kAFS: afs_d_revalidate: %pd2 has bad inode\\n\"",
            "dentry"
          ],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_bad_inode",
          "args": [
            "dentry->d_inode"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "is_bad_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/bad_inode.c",
          "lines": "195-198",
          "snippet": "int is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}",
          "includes": [
            "#include <linux/poll.h>",
            "#include <linux/namei.h>",
            "#include <linux/time.h>",
            "#include <linux/stat.h>",
            "#include <linux/export.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/poll.h>\n#include <linux/namei.h>\n#include <linux/time.h>\n#include <linux/stat.h>\n#include <linux/export.h>\n#include <linux/fs.h>\n\nstatic const struct inode_operations bad_inode_ops =\n{\n\t.create\t\t= bad_inode_create,\n\t.lookup\t\t= bad_inode_lookup,\n\t.link\t\t= bad_inode_link,\n\t.unlink\t\t= bad_inode_unlink,\n\t.symlink\t= bad_inode_symlink,\n\t.mkdir\t\t= bad_inode_mkdir,\n\t.rmdir\t\t= bad_inode_rmdir,\n\t.mknod\t\t= bad_inode_mknod,\n\t.rename2\t= bad_inode_rename2,\n\t.readlink\t= bad_inode_readlink,\n\t/* follow_link must be no-op, otherwise unmounting this inode\n\t   won't work */\n\t/* put_link returns void */\n\t/* truncate returns void */\n\t.permission\t= bad_inode_permission,\n\t.getattr\t= bad_inode_getattr,\n\t.setattr\t= bad_inode_setattr,\n\t.setxattr\t= bad_inode_setxattr,\n\t.getxattr\t= bad_inode_getxattr,\n\t.listxattr\t= bad_inode_listxattr,\n\t.removexattr\t= bad_inode_removexattr,\n};\n\nint is_bad_inode(struct inode *inode)\n{\n\treturn (inode->i_op == &bad_inode_ops);\t\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_do_lookup",
          "args": [
            "&dir->vfs_inode",
            "dentry",
            "&fid",
            "key"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "afs_do_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/dir.c",
          "lines": "426-455",
          "snippet": "static int afs_do_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t struct afs_fid *fid, struct key *key)\n{\n\tstruct afs_super_info *as = dir->i_sb->s_fs_info;\n\tstruct afs_lookup_cookie cookie = {\n\t\t.ctx.actor = afs_lookup_filldir,\n\t\t.name = dentry->d_name,\n\t\t.fid.vid = as->volume->vid\n\t};\n\tint ret;\n\n\t_enter(\"{%lu},%p{%pd},\", dir->i_ino, dentry, dentry);\n\n\t/* search the directory */\n\tret = afs_dir_iterate(dir, &cookie.ctx, key);\n\tif (ret < 0) {\n\t\t_leave(\" = %d [iter]\", ret);\n\t\treturn ret;\n\t}\n\n\tret = -ENOENT;\n\tif (!cookie.found) {\n\t\t_leave(\" = -ENOENT [not found]\");\n\t\treturn -ENOENT;\n\t}\n\n\t*fid = cookie.fid;\n\t_leave(\" = 0 { vn=%u u=%u }\", fid->vnode, fid->unique);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int afs_readdir(struct file *file, struct dir_context *ctx);",
            "static int afs_d_delete(const struct dentry *dentry);",
            "static void afs_d_release(struct dentry *dentry);",
            "static int afs_rmdir(struct inode *dir, struct dentry *dentry);",
            "static int afs_unlink(struct inode *dir, struct dentry *dentry);",
            "static int afs_link(struct dentry *from, struct inode *dir,\n\t\t    struct dentry *dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int afs_readdir(struct file *file, struct dir_context *ctx);\nstatic int afs_d_delete(const struct dentry *dentry);\nstatic void afs_d_release(struct dentry *dentry);\nstatic int afs_rmdir(struct inode *dir, struct dentry *dentry);\nstatic int afs_unlink(struct inode *dir, struct dentry *dentry);\nstatic int afs_link(struct dentry *from, struct inode *dir,\n\t\t    struct dentry *dentry);\n\nstatic int afs_do_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t struct afs_fid *fid, struct key *key)\n{\n\tstruct afs_super_info *as = dir->i_sb->s_fs_info;\n\tstruct afs_lookup_cookie cookie = {\n\t\t.ctx.actor = afs_lookup_filldir,\n\t\t.name = dentry->d_name,\n\t\t.fid.vid = as->volume->vid\n\t};\n\tint ret;\n\n\t_enter(\"{%lu},%p{%pd},\", dir->i_ino, dentry, dentry);\n\n\t/* search the directory */\n\tret = afs_dir_iterate(dir, &cookie.ctx, key);\n\tif (ret < 0) {\n\t\t_leave(\" = %d [iter]\", ret);\n\t\treturn ret;\n\t}\n\n\tret = -ENOENT;\n\tif (!cookie.found) {\n\t\t_leave(\" = -ENOENT [not found]\");\n\t\treturn -ENOENT;\n\t}\n\n\t*fid = cookie.fid;\n\t_leave(\" = 0 { vn=%u u=%u }\", fid->vnode, fid->unique);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"dir modified\""
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_debug_suballoc_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2634-2662",
          "snippet": "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe);\n\nstatic inline void ocfs2_debug_suballoc_inode(struct ocfs2_dinode *fe)\n{\n\tint i;\n\n\tprintk(\"Suballoc Inode %llu:\\n\", (unsigned long long)fe->i_blkno);\n\tprintk(\"i_signature:                  %s\\n\", fe->i_signature);\n\tprintk(\"i_size:                       %llu\\n\",\n\t       (unsigned long long)fe->i_size);\n\tprintk(\"i_clusters:                   %u\\n\", fe->i_clusters);\n\tprintk(\"i_generation:                 %u\\n\",\n\t       le32_to_cpu(fe->i_generation));\n\tprintk(\"id1.bitmap1.i_used:           %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_used));\n\tprintk(\"id1.bitmap1.i_total:          %u\\n\",\n\t       le32_to_cpu(fe->id1.bitmap1.i_total));\n\tprintk(\"id2.i_chain.cl_cpg:           %u\\n\", fe->id2.i_chain.cl_cpg);\n\tprintk(\"id2.i_chain.cl_bpc:           %u\\n\", fe->id2.i_chain.cl_bpc);\n\tprintk(\"id2.i_chain.cl_count:         %u\\n\", fe->id2.i_chain.cl_count);\n\tprintk(\"id2.i_chain.cl_next_free_rec: %u\\n\",\n\t       fe->id2.i_chain.cl_next_free_rec);\n\tfor(i = 0; i < fe->id2.i_chain.cl_next_free_rec; i++) {\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_free:  %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_free);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_total: %u\\n\", i,\n\t\t       fe->id2.i_chain.cl_recs[i].c_total);\n\t\tprintk(\"fe->id2.i_chain.cl_recs[%d].c_blkno: %llu\\n\", i,\n\t\t       (unsigned long long)fe->id2.i_chain.cl_recs[i].c_blkno);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "AFS_VNODE_DELETED",
            "&dir->flags"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_validate",
          "args": [
            "dir",
            "key"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "afs_validate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/inode.c",
          "lines": "313-372",
          "snippet": "int afs_validate(struct afs_vnode *vnode, struct key *key)\n{\n\tint ret;\n\n\t_enter(\"{v={%x:%u} fl=%lx},%x\",\n\t       vnode->fid.vid, vnode->fid.vnode, vnode->flags,\n\t       key_serial(key));\n\n\tif (vnode->cb_promised &&\n\t    !test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags) &&\n\t    !test_bit(AFS_VNODE_MODIFIED, &vnode->flags) &&\n\t    !test_bit(AFS_VNODE_ZAP_DATA, &vnode->flags)) {\n\t\tif (vnode->cb_expires < get_seconds() + 10) {\n\t\t\t_debug(\"callback expired\");\n\t\t\tset_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\t\t} else {\n\t\t\tgoto valid;\n\t\t}\n\t}\n\n\tif (test_bit(AFS_VNODE_DELETED, &vnode->flags))\n\t\tgoto valid;\n\n\tmutex_lock(&vnode->validate_lock);\n\n\t/* if the promise has expired, we need to check the server again to get\n\t * a new promise - note that if the (parent) directory's metadata was\n\t * changed then the security may be different and we may no longer have\n\t * access */\n\tif (!vnode->cb_promised ||\n\t    test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags)) {\n\t\t_debug(\"not promised\");\n\t\tret = afs_vnode_fetch_status(vnode, NULL, key);\n\t\tif (ret < 0)\n\t\t\tgoto error_unlock;\n\t\t_debug(\"new promise [fl=%lx]\", vnode->flags);\n\t}\n\n\tif (test_bit(AFS_VNODE_DELETED, &vnode->flags)) {\n\t\t_debug(\"file already deleted\");\n\t\tret = -ESTALE;\n\t\tgoto error_unlock;\n\t}\n\n\t/* if the vnode's data version number changed then its contents are\n\t * different */\n\tif (test_and_clear_bit(AFS_VNODE_ZAP_DATA, &vnode->flags))\n\t\tafs_zap_data(vnode);\n\n\tclear_bit(AFS_VNODE_MODIFIED, &vnode->flags);\n\tmutex_unlock(&vnode->validate_lock);\nvalid:\n\t_leave(\" = 0\");\n\treturn 0;\n\nerror_unlock:\n\tmutex_unlock(&vnode->validate_lock);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint afs_validate(struct afs_vnode *vnode, struct key *key)\n{\n\tint ret;\n\n\t_enter(\"{v={%x:%u} fl=%lx},%x\",\n\t       vnode->fid.vid, vnode->fid.vnode, vnode->flags,\n\t       key_serial(key));\n\n\tif (vnode->cb_promised &&\n\t    !test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags) &&\n\t    !test_bit(AFS_VNODE_MODIFIED, &vnode->flags) &&\n\t    !test_bit(AFS_VNODE_ZAP_DATA, &vnode->flags)) {\n\t\tif (vnode->cb_expires < get_seconds() + 10) {\n\t\t\t_debug(\"callback expired\");\n\t\t\tset_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\t\t} else {\n\t\t\tgoto valid;\n\t\t}\n\t}\n\n\tif (test_bit(AFS_VNODE_DELETED, &vnode->flags))\n\t\tgoto valid;\n\n\tmutex_lock(&vnode->validate_lock);\n\n\t/* if the promise has expired, we need to check the server again to get\n\t * a new promise - note that if the (parent) directory's metadata was\n\t * changed then the security may be different and we may no longer have\n\t * access */\n\tif (!vnode->cb_promised ||\n\t    test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags)) {\n\t\t_debug(\"not promised\");\n\t\tret = afs_vnode_fetch_status(vnode, NULL, key);\n\t\tif (ret < 0)\n\t\t\tgoto error_unlock;\n\t\t_debug(\"new promise [fl=%lx]\", vnode->flags);\n\t}\n\n\tif (test_bit(AFS_VNODE_DELETED, &vnode->flags)) {\n\t\t_debug(\"file already deleted\");\n\t\tret = -ESTALE;\n\t\tgoto error_unlock;\n\t}\n\n\t/* if the vnode's data version number changed then its contents are\n\t * different */\n\tif (test_and_clear_bit(AFS_VNODE_ZAP_DATA, &vnode->flags))\n\t\tafs_zap_data(vnode);\n\n\tclear_bit(AFS_VNODE_MODIFIED, &vnode->flags);\n\tmutex_unlock(&vnode->validate_lock);\nvalid:\n\t_leave(\" = 0\");\n\treturn 0;\n\nerror_unlock:\n\tmutex_unlock(&vnode->validate_lock);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AFS_FS_I",
          "args": [
            "parent->d_inode"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "AFS_FS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/internal.h",
          "lines": "687-690",
          "snippet": "static inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}",
          "includes": [
            "#include \"afs_vl.h\"",
            "#include \"afs.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/fscache.h>",
            "#include <linux/sched.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/key.h>",
            "#include <linux/rxrpc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void afs_discard_callback_on_delete(struct afs_vnode *);",
            "extern void afs_give_up_callback(struct afs_vnode *);",
            "extern void afs_lock_may_be_available(struct afs_vnode *);",
            "extern void afs_zap_data(struct afs_vnode *);",
            "extern void afs_evict_inode(struct inode *);",
            "extern int afs_drop_inode(struct inode *);",
            "extern void afs_clear_permits(struct afs_vnode *);",
            "extern int afs_permission(struct inode *, int);",
            "extern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);",
            "extern int afs_writeback_all(struct afs_vnode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_vl.h\"\n#include \"afs.h\"\n#include <linux/backing-dev.h>\n#include <linux/fscache.h>\n#include <linux/sched.h>\n#include <linux/workqueue.h>\n#include <linux/key.h>\n#include <linux/rxrpc.h>\n#include <linux/skbuff.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n\nextern void afs_discard_callback_on_delete(struct afs_vnode *);\nextern void afs_give_up_callback(struct afs_vnode *);\nextern void afs_lock_may_be_available(struct afs_vnode *);\nextern void afs_zap_data(struct afs_vnode *);\nextern void afs_evict_inode(struct inode *);\nextern int afs_drop_inode(struct inode *);\nextern void afs_clear_permits(struct afs_vnode *);\nextern int afs_permission(struct inode *, int);\nextern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);\nextern int afs_writeback_all(struct afs_vnode *);\n\nstatic inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dget_parent",
          "args": [
            "dentry"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "dget_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "777-814",
          "snippet": "struct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstruct dentry *dget_parent(struct dentry *dentry)\n{\n\tint gotref;\n\tstruct dentry *ret;\n\n\t/*\n\t * Do optimistic parent lookup without any\n\t * locking.\n\t */\n\trcu_read_lock();\n\tret = ACCESS_ONCE(dentry->d_parent);\n\tgotref = lockref_get_not_zero(&ret->d_lockref);\n\trcu_read_unlock();\n\tif (likely(gotref)) {\n\t\tif (likely(ret == ACCESS_ONCE(dentry->d_parent)))\n\t\t\treturn ret;\n\t\tdput(ret);\n\t}\n\nrepeat:\n\t/*\n\t * Don't need rcu_dereference because we re-check it was correct under\n\t * the lock.\n\t */\n\trcu_read_lock();\n\tret = dentry->d_parent;\n\tspin_lock(&ret->d_lock);\n\tif (unlikely(ret != dentry->d_parent)) {\n\t\tspin_unlock(&ret->d_lock);\n\t\trcu_read_unlock();\n\t\tgoto repeat;\n\t}\n\trcu_read_unlock();\n\tBUG_ON(!ret->d_lockref.count);\n\tret->d_lockref.count++;\n\tspin_unlock(&ret->d_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "key"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_request_key",
          "args": [
            "AFS_FS_S(dentry->d_sb)->volume->cell"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "afs_request_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/security.c",
          "lines": "23-46",
          "snippet": "struct key *afs_request_key(struct afs_cell *cell)\n{\n\tstruct key *key;\n\n\t_enter(\"{%x}\", key_serial(cell->anonymous_key));\n\n\t_debug(\"key %s\", cell->anonymous_key->description);\n\tkey = request_key(&key_type_rxrpc, cell->anonymous_key->description,\n\t\t\t  NULL);\n\tif (IS_ERR(key)) {\n\t\tif (PTR_ERR(key) != -ENOKEY) {\n\t\t\t_leave(\" = %ld\", PTR_ERR(key));\n\t\t\treturn key;\n\t\t}\n\n\t\t/* act as anonymous user */\n\t\t_leave(\" = {%x} [anon]\", key_serial(cell->anonymous_key));\n\t\treturn key_get(cell->anonymous_key);\n\t} else {\n\t\t/* act as authorised user */\n\t\t_leave(\" = {%x} [auth]\", key_serial(key));\n\t\treturn key;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <keys/rxrpc-type.h>",
            "#include <linux/sched.h>",
            "#include <linux/ctype.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <keys/rxrpc-type.h>\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstruct key *afs_request_key(struct afs_cell *cell)\n{\n\tstruct key *key;\n\n\t_enter(\"{%x}\", key_serial(cell->anonymous_key));\n\n\t_debug(\"key %s\", cell->anonymous_key->description);\n\tkey = request_key(&key_type_rxrpc, cell->anonymous_key->description,\n\t\t\t  NULL);\n\tif (IS_ERR(key)) {\n\t\tif (PTR_ERR(key) != -ENOKEY) {\n\t\t\t_leave(\" = %ld\", PTR_ERR(key));\n\t\t\treturn key;\n\t\t}\n\n\t\t/* act as anonymous user */\n\t\t_leave(\" = {%x} [anon]\", key_serial(cell->anonymous_key));\n\t\treturn key_get(cell->anonymous_key);\n\t} else {\n\t\t/* act as authorised user */\n\t\t_leave(\" = {%x} [auth]\", key_serial(key));\n\t\treturn key;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "AFS_FS_S",
          "args": [
            "dentry->d_sb"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "AFS_FS_S",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/internal.h",
          "lines": "176-179",
          "snippet": "static inline struct afs_super_info *AFS_FS_S(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}",
          "includes": [
            "#include \"afs_vl.h\"",
            "#include \"afs.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/fscache.h>",
            "#include <linux/sched.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/key.h>",
            "#include <linux/rxrpc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_vl.h\"\n#include \"afs.h\"\n#include <linux/backing-dev.h>\n#include <linux/fscache.h>\n#include <linux/sched.h>\n#include <linux/workqueue.h>\n#include <linux/key.h>\n#include <linux/rxrpc.h>\n#include <linux/skbuff.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n\nstatic inline struct afs_super_info *AFS_FS_S(struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{neg n=%pd}\"",
            "dentry"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "30-42",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{v={%x:%u} n=%pd fl=%lx},\"",
            "vnode->fid.vid",
            "vnode->fid.vnode",
            "dentry",
            "vnode->flags"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct dentry *afs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t unsigned int flags);\nstatic int afs_dir_open(struct inode *inode, struct file *file);\nstatic int afs_d_revalidate(struct dentry *dentry, unsigned int flags);\nstatic int afs_d_delete(const struct dentry *dentry);\nstatic void afs_d_release(struct dentry *dentry);\nstatic int afs_rmdir(struct inode *dir, struct dentry *dentry);\nstatic int afs_unlink(struct inode *dir, struct dentry *dentry);\nstatic int afs_link(struct dentry *from, struct inode *dir,\n\t\t    struct dentry *dentry);\n\nstatic int afs_d_revalidate(struct dentry *dentry, unsigned int flags)\n{\n\tstruct afs_vnode *vnode, *dir;\n\tstruct afs_fid uninitialized_var(fid);\n\tstruct dentry *parent;\n\tstruct key *key;\n\tvoid *dir_version;\n\tint ret;\n\n\tif (flags & LOOKUP_RCU)\n\t\treturn -ECHILD;\n\n\tvnode = AFS_FS_I(dentry->d_inode);\n\n\tif (dentry->d_inode)\n\t\t_enter(\"{v={%x:%u} n=%pd fl=%lx},\",\n\t\t       vnode->fid.vid, vnode->fid.vnode, dentry,\n\t\t       vnode->flags);\n\telse\n\t\t_enter(\"{neg n=%pd}\", dentry);\n\n\tkey = afs_request_key(AFS_FS_S(dentry->d_sb)->volume->cell);\n\tif (IS_ERR(key))\n\t\tkey = NULL;\n\n\t/* lock down the parent dentry so we can peer at it */\n\tparent = dget_parent(dentry);\n\tdir = AFS_FS_I(parent->d_inode);\n\n\t/* validate the parent directory */\n\tif (test_bit(AFS_VNODE_MODIFIED, &dir->flags))\n\t\tafs_validate(dir, key);\n\n\tif (test_bit(AFS_VNODE_DELETED, &dir->flags)) {\n\t\t_debug(\"%pd: parent dir deleted\", dentry);\n\t\tgoto out_bad;\n\t}\n\n\tdir_version = (void *) (unsigned long) dir->status.data_version;\n\tif (dentry->d_fsdata == dir_version)\n\t\tgoto out_valid; /* the dir contents are unchanged */\n\n\t_debug(\"dir modified\");\n\n\t/* search the directory for this vnode */\n\tret = afs_do_lookup(&dir->vfs_inode, dentry, &fid, key);\n\tswitch (ret) {\n\tcase 0:\n\t\t/* the filename maps to something */\n\t\tif (!dentry->d_inode)\n\t\t\tgoto out_bad;\n\t\tif (is_bad_inode(dentry->d_inode)) {\n\t\t\tprintk(\"kAFS: afs_d_revalidate: %pd2 has bad inode\\n\",\n\t\t\t       dentry);\n\t\t\tgoto out_bad;\n\t\t}\n\n\t\t/* if the vnode ID has changed, then the dirent points to a\n\t\t * different file */\n\t\tif (fid.vnode != vnode->fid.vnode) {\n\t\t\t_debug(\"%pd: dirent changed [%u != %u]\",\n\t\t\t       dentry, fid.vnode,\n\t\t\t       vnode->fid.vnode);\n\t\t\tgoto not_found;\n\t\t}\n\n\t\t/* if the vnode ID uniqifier has changed, then the file has\n\t\t * been deleted and replaced, and the original vnode ID has\n\t\t * been reused */\n\t\tif (fid.unique != vnode->fid.unique) {\n\t\t\t_debug(\"%pd: file deleted (uq %u -> %u I:%u)\",\n\t\t\t       dentry, fid.unique,\n\t\t\t       vnode->fid.unique,\n\t\t\t       dentry->d_inode->i_generation);\n\t\t\tspin_lock(&vnode->lock);\n\t\t\tset_bit(AFS_VNODE_DELETED, &vnode->flags);\n\t\t\tspin_unlock(&vnode->lock);\n\t\t\tgoto not_found;\n\t\t}\n\t\tgoto out_valid;\n\n\tcase -ENOENT:\n\t\t/* the filename is unknown */\n\t\t_debug(\"%pd: dirent not found\", dentry);\n\t\tif (dentry->d_inode)\n\t\t\tgoto not_found;\n\t\tgoto out_valid;\n\n\tdefault:\n\t\t_debug(\"failed to iterate dir %pd: %d\",\n\t\t       parent, ret);\n\t\tgoto out_bad;\n\t}\n\nout_valid:\n\tdentry->d_fsdata = dir_version;\n\tdput(parent);\n\tkey_put(key);\n\t_leave(\" = 1 [valid]\");\n\treturn 1;\n\n\t/* the dirent, if it exists, now points to a different vnode */\nnot_found:\n\tspin_lock(&dentry->d_lock);\n\tdentry->d_flags |= DCACHE_NFSFS_RENAMED;\n\tspin_unlock(&dentry->d_lock);\n\nout_bad:\n\t_debug(\"dropping dentry %pd2\", dentry);\n\tdput(parent);\n\tkey_put(key);\n\n\t_leave(\" = 0 [bad]\");\n\treturn 0;\n}"
  },
  {
    "function_name": "afs_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/dir.c",
    "lines": "494-570",
    "snippet": "static struct dentry *afs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t unsigned int flags)\n{\n\tstruct afs_vnode *vnode;\n\tstruct afs_fid fid;\n\tstruct inode *inode;\n\tstruct key *key;\n\tint ret;\n\n\tvnode = AFS_FS_I(dir);\n\n\t_enter(\"{%x:%u},%p{%pd},\",\n\t       vnode->fid.vid, vnode->fid.vnode, dentry, dentry);\n\n\tASSERTCMP(dentry->d_inode, ==, NULL);\n\n\tif (dentry->d_name.len >= AFSNAMEMAX) {\n\t\t_leave(\" = -ENAMETOOLONG\");\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\t}\n\n\tif (test_bit(AFS_VNODE_DELETED, &vnode->flags)) {\n\t\t_leave(\" = -ESTALE\");\n\t\treturn ERR_PTR(-ESTALE);\n\t}\n\n\tkey = afs_request_key(vnode->volume->cell);\n\tif (IS_ERR(key)) {\n\t\t_leave(\" = %ld [key]\", PTR_ERR(key));\n\t\treturn ERR_CAST(key);\n\t}\n\n\tret = afs_validate(vnode, key);\n\tif (ret < 0) {\n\t\tkey_put(key);\n\t\t_leave(\" = %d [val]\", ret);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tret = afs_do_lookup(dir, dentry, &fid, key);\n\tif (ret < 0) {\n\t\tinode = afs_try_auto_mntpt(ret, dentry, dir, key, &fid);\n\t\tif (!IS_ERR(inode)) {\n\t\t\tkey_put(key);\n\t\t\tgoto success;\n\t\t}\n\n\t\tret = PTR_ERR(inode);\n\t\tkey_put(key);\n\t\tif (ret == -ENOENT) {\n\t\t\td_add(dentry, NULL);\n\t\t\t_leave(\" = NULL [negative]\");\n\t\t\treturn NULL;\n\t\t}\n\t\t_leave(\" = %d [do]\", ret);\n\t\treturn ERR_PTR(ret);\n\t}\n\tdentry->d_fsdata = (void *)(unsigned long) vnode->status.data_version;\n\n\t/* instantiate the dentry */\n\tinode = afs_iget(dir->i_sb, key, &fid, NULL, NULL);\n\tkey_put(key);\n\tif (IS_ERR(inode)) {\n\t\t_leave(\" = %ld\", PTR_ERR(inode));\n\t\treturn ERR_CAST(inode);\n\t}\n\nsuccess:\n\td_add(dentry, inode);\n\t_leave(\" = 0 { vn=%u u=%u } -> { ino=%lu v=%u }\",\n\t       fid.vnode,\n\t       fid.unique,\n\t       dentry->d_inode->i_ino,\n\t       dentry->d_inode->i_generation);\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dentry *afs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t unsigned int flags);",
      "static int afs_d_revalidate(struct dentry *dentry, unsigned int flags);",
      "static int afs_d_delete(const struct dentry *dentry);",
      "static void afs_d_release(struct dentry *dentry);",
      "static int afs_rmdir(struct inode *dir, struct dentry *dentry);",
      "static int afs_unlink(struct inode *dir, struct dentry *dentry);",
      "static int afs_link(struct dentry *from, struct inode *dir,\n\t\t    struct dentry *dentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = 0 { vn=%u u=%u } -> { ino=%lu v=%u }\"",
            "fid.vnode",
            "fid.unique",
            "dentry->d_inode->i_ino",
            "dentry->d_inode->i_generation"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_add",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "v9fs_fid_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/9p/fid.c",
          "lines": "49-54",
          "snippet": "void v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}",
          "includes": [
            "#include \"fid.h\"",
            "#include \"v9fs_vfs.h\"",
            "#include \"v9fs.h\"",
            "#include <net/9p/client.h>",
            "#include <net/9p/9p.h>",
            "#include <linux/idr.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/errno.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"fid.h\"\n#include \"v9fs_vfs.h\"\n#include \"v9fs.h\"\n#include <net/9p/client.h>\n#include <net/9p/9p.h>\n#include <linux/idr.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n\nvoid v9fs_fid_add(struct dentry *dentry, struct p9_fid *fid)\n{\n\tspin_lock(&dentry->d_lock);\n\t__add_fid(dentry, fid);\n\tspin_unlock(&dentry->d_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "inode"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %ld\"",
            "PTR_ERR(inode)"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "key"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "expkey_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfsd/export.c",
          "lines": "40-49",
          "snippet": "static void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree(key);\n}",
          "includes": [
            "#include \"pnfs.h\"",
            "#include \"netns.h\"",
            "#include \"nfsfh.h\"",
            "#include \"nfsd.h\"",
            "#include <linux/sunrpc/svc_xprt.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/module.h>",
            "#include <linux/namei.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pnfs.h\"\n#include \"netns.h\"\n#include \"nfsfh.h\"\n#include \"nfsd.h\"\n#include <linux/sunrpc/svc_xprt.h>\n#include <linux/exportfs.h>\n#include <linux/module.h>\n#include <linux/namei.h>\n#include <linux/slab.h>\n\nstatic struct svc_expkey *svc_expkey_lookup(struct cache_detail *cd, struct svc_expkey *);\n\nstatic void expkey_put(struct kref *ref)\n{\n\tstruct svc_expkey *key = container_of(ref, struct svc_expkey, h.ref);\n\n\tif (test_bit(CACHE_VALID, &key->h.flags) &&\n\t    !test_bit(CACHE_NEGATIVE, &key->h.flags))\n\t\tpath_put(&key->ek_path);\n\tauth_domain_put(key->ek_client);\n\tkfree(key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_iget",
          "args": [
            "dir->i_sb",
            "key",
            "&fid",
            "NULL",
            "NULL"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "afs_iget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/inode.c",
          "lines": "198-285",
          "snippet": "struct inode *afs_iget(struct super_block *sb, struct key *key,\n\t\t       struct afs_fid *fid, struct afs_file_status *status,\n\t\t       struct afs_callback *cb)\n{\n\tstruct afs_iget_data data = { .fid = *fid };\n\tstruct afs_super_info *as;\n\tstruct afs_vnode *vnode;\n\tstruct inode *inode;\n\tint ret;\n\n\t_enter(\",{%x:%u.%u},,\", fid->vid, fid->vnode, fid->unique);\n\n\tas = sb->s_fs_info;\n\tdata.volume = as->volume;\n\n\tinode = iget5_locked(sb, fid->vnode, afs_iget5_test, afs_iget5_set,\n\t\t\t     &data);\n\tif (!inode) {\n\t\t_leave(\" = -ENOMEM\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t_debug(\"GOT INODE %p { vl=%x vn=%x, u=%x }\",\n\t       inode, fid->vid, fid->vnode, fid->unique);\n\n\tvnode = AFS_FS_I(inode);\n\n\t/* deal with an existing inode */\n\tif (!(inode->i_state & I_NEW)) {\n\t\t_leave(\" = %p\", inode);\n\t\treturn inode;\n\t}\n\n\tif (!status) {\n\t\t/* it's a remotely extant inode */\n\t\tset_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\t\tret = afs_vnode_fetch_status(vnode, NULL, key);\n\t\tif (ret < 0)\n\t\t\tgoto bad_inode;\n\t} else {\n\t\t/* it's an inode we just created */\n\t\tmemcpy(&vnode->status, status, sizeof(vnode->status));\n\n\t\tif (!cb) {\n\t\t\t/* it's a symlink we just created (the fileserver\n\t\t\t * didn't give us a callback) */\n\t\t\tvnode->cb_version = 0;\n\t\t\tvnode->cb_expiry = 0;\n\t\t\tvnode->cb_type = 0;\n\t\t\tvnode->cb_expires = get_seconds();\n\t\t} else {\n\t\t\tvnode->cb_version = cb->version;\n\t\t\tvnode->cb_expiry = cb->expiry;\n\t\t\tvnode->cb_type = cb->type;\n\t\t\tvnode->cb_expires = vnode->cb_expiry + get_seconds();\n\t\t}\n\t}\n\n\t/* set up caching before mapping the status, as map-status reads the\n\t * first page of symlinks to see if they're really mountpoints */\n\tinode->i_size = vnode->status.size;\n#ifdef CONFIG_AFS_FSCACHE\n\tvnode->cache = fscache_acquire_cookie(vnode->volume->cache,\n\t\t\t\t\t      &afs_vnode_cache_index_def,\n\t\t\t\t\t      vnode, true);\n#endif\n\n\tret = afs_inode_map_status(vnode, key);\n\tif (ret < 0)\n\t\tgoto bad_inode;\n\n\t/* success */\n\tclear_bit(AFS_VNODE_UNSET, &vnode->flags);\n\tinode->i_flags |= S_NOATIME;\n\tunlock_new_inode(inode);\n\t_leave(\" = %p [CB { v=%u t=%u }]\", inode, vnode->cb_version, vnode->cb_type);\n\treturn inode;\n\n\t/* failure */\nbad_inode:\n#ifdef CONFIG_AFS_FSCACHE\n\tfscache_relinquish_cookie(vnode->cache, 0);\n\tvnode->cache = NULL;\n#endif\n\tiget_failed(inode);\n\t_leave(\" = %d [bad]\", ret);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstruct inode *afs_iget(struct super_block *sb, struct key *key,\n\t\t       struct afs_fid *fid, struct afs_file_status *status,\n\t\t       struct afs_callback *cb)\n{\n\tstruct afs_iget_data data = { .fid = *fid };\n\tstruct afs_super_info *as;\n\tstruct afs_vnode *vnode;\n\tstruct inode *inode;\n\tint ret;\n\n\t_enter(\",{%x:%u.%u},,\", fid->vid, fid->vnode, fid->unique);\n\n\tas = sb->s_fs_info;\n\tdata.volume = as->volume;\n\n\tinode = iget5_locked(sb, fid->vnode, afs_iget5_test, afs_iget5_set,\n\t\t\t     &data);\n\tif (!inode) {\n\t\t_leave(\" = -ENOMEM\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t_debug(\"GOT INODE %p { vl=%x vn=%x, u=%x }\",\n\t       inode, fid->vid, fid->vnode, fid->unique);\n\n\tvnode = AFS_FS_I(inode);\n\n\t/* deal with an existing inode */\n\tif (!(inode->i_state & I_NEW)) {\n\t\t_leave(\" = %p\", inode);\n\t\treturn inode;\n\t}\n\n\tif (!status) {\n\t\t/* it's a remotely extant inode */\n\t\tset_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\t\tret = afs_vnode_fetch_status(vnode, NULL, key);\n\t\tif (ret < 0)\n\t\t\tgoto bad_inode;\n\t} else {\n\t\t/* it's an inode we just created */\n\t\tmemcpy(&vnode->status, status, sizeof(vnode->status));\n\n\t\tif (!cb) {\n\t\t\t/* it's a symlink we just created (the fileserver\n\t\t\t * didn't give us a callback) */\n\t\t\tvnode->cb_version = 0;\n\t\t\tvnode->cb_expiry = 0;\n\t\t\tvnode->cb_type = 0;\n\t\t\tvnode->cb_expires = get_seconds();\n\t\t} else {\n\t\t\tvnode->cb_version = cb->version;\n\t\t\tvnode->cb_expiry = cb->expiry;\n\t\t\tvnode->cb_type = cb->type;\n\t\t\tvnode->cb_expires = vnode->cb_expiry + get_seconds();\n\t\t}\n\t}\n\n\t/* set up caching before mapping the status, as map-status reads the\n\t * first page of symlinks to see if they're really mountpoints */\n\tinode->i_size = vnode->status.size;\n#ifdef CONFIG_AFS_FSCACHE\n\tvnode->cache = fscache_acquire_cookie(vnode->volume->cache,\n\t\t\t\t\t      &afs_vnode_cache_index_def,\n\t\t\t\t\t      vnode, true);\n#endif\n\n\tret = afs_inode_map_status(vnode, key);\n\tif (ret < 0)\n\t\tgoto bad_inode;\n\n\t/* success */\n\tclear_bit(AFS_VNODE_UNSET, &vnode->flags);\n\tinode->i_flags |= S_NOATIME;\n\tunlock_new_inode(inode);\n\t_leave(\" = %p [CB { v=%u t=%u }]\", inode, vnode->cb_version, vnode->cb_type);\n\treturn inode;\n\n\t/* failure */\nbad_inode:\n#ifdef CONFIG_AFS_FSCACHE\n\tfscache_relinquish_cookie(vnode->cache, 0);\n\tvnode->cache = NULL;\n#endif\n\tiget_failed(inode);\n\t_leave(\" = %d [bad]\", ret);\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = NULL [negative]\""
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_try_auto_mntpt",
          "args": [
            "ret",
            "dentry",
            "dir",
            "key",
            "&fid"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "afs_try_auto_mntpt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/dir.c",
          "lines": "461-489",
          "snippet": "static struct inode *afs_try_auto_mntpt(\n\tint ret, struct dentry *dentry, struct inode *dir, struct key *key,\n\tstruct afs_fid *fid)\n{\n\tconst char *devname = dentry->d_name.name;\n\tstruct afs_vnode *vnode = AFS_FS_I(dir);\n\tstruct inode *inode;\n\n\t_enter(\"%d, %p{%pd}, {%x:%u}, %p\",\n\t       ret, dentry, dentry, vnode->fid.vid, vnode->fid.vnode, key);\n\n\tif (ret != -ENOENT ||\n\t    !test_bit(AFS_VNODE_AUTOCELL, &vnode->flags))\n\t\tgoto out;\n\n\tinode = afs_iget_autocell(dir, devname, strlen(devname), key);\n\tif (IS_ERR(inode)) {\n\t\tret = PTR_ERR(inode);\n\t\tgoto out;\n\t}\n\n\t*fid = AFS_FS_I(inode)->fid;\n\t_leave(\"= %p\", inode);\n\treturn inode;\n\nout:\n\t_leave(\"= %d\", ret);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dentry *afs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t unsigned int flags);",
            "static int afs_d_revalidate(struct dentry *dentry, unsigned int flags);",
            "static int afs_d_delete(const struct dentry *dentry);",
            "static void afs_d_release(struct dentry *dentry);",
            "static int afs_rmdir(struct inode *dir, struct dentry *dentry);",
            "static int afs_unlink(struct inode *dir, struct dentry *dentry);",
            "static int afs_link(struct dentry *from, struct inode *dir,\n\t\t    struct dentry *dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct dentry *afs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t unsigned int flags);\nstatic int afs_d_revalidate(struct dentry *dentry, unsigned int flags);\nstatic int afs_d_delete(const struct dentry *dentry);\nstatic void afs_d_release(struct dentry *dentry);\nstatic int afs_rmdir(struct inode *dir, struct dentry *dentry);\nstatic int afs_unlink(struct inode *dir, struct dentry *dentry);\nstatic int afs_link(struct dentry *from, struct inode *dir,\n\t\t    struct dentry *dentry);\n\nstatic struct inode *afs_try_auto_mntpt(\n\tint ret, struct dentry *dentry, struct inode *dir, struct key *key,\n\tstruct afs_fid *fid)\n{\n\tconst char *devname = dentry->d_name.name;\n\tstruct afs_vnode *vnode = AFS_FS_I(dir);\n\tstruct inode *inode;\n\n\t_enter(\"%d, %p{%pd}, {%x:%u}, %p\",\n\t       ret, dentry, dentry, vnode->fid.vid, vnode->fid.vnode, key);\n\n\tif (ret != -ENOENT ||\n\t    !test_bit(AFS_VNODE_AUTOCELL, &vnode->flags))\n\t\tgoto out;\n\n\tinode = afs_iget_autocell(dir, devname, strlen(devname), key);\n\tif (IS_ERR(inode)) {\n\t\tret = PTR_ERR(inode);\n\t\tgoto out;\n\t}\n\n\t*fid = AFS_FS_I(inode)->fid;\n\t_leave(\"= %p\", inode);\n\treturn inode;\n\nout:\n\t_leave(\"= %d\", ret);\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_do_lookup",
          "args": [
            "dir",
            "dentry",
            "&fid",
            "key"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "afs_do_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/dir.c",
          "lines": "426-455",
          "snippet": "static int afs_do_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t struct afs_fid *fid, struct key *key)\n{\n\tstruct afs_super_info *as = dir->i_sb->s_fs_info;\n\tstruct afs_lookup_cookie cookie = {\n\t\t.ctx.actor = afs_lookup_filldir,\n\t\t.name = dentry->d_name,\n\t\t.fid.vid = as->volume->vid\n\t};\n\tint ret;\n\n\t_enter(\"{%lu},%p{%pd},\", dir->i_ino, dentry, dentry);\n\n\t/* search the directory */\n\tret = afs_dir_iterate(dir, &cookie.ctx, key);\n\tif (ret < 0) {\n\t\t_leave(\" = %d [iter]\", ret);\n\t\treturn ret;\n\t}\n\n\tret = -ENOENT;\n\tif (!cookie.found) {\n\t\t_leave(\" = -ENOENT [not found]\");\n\t\treturn -ENOENT;\n\t}\n\n\t*fid = cookie.fid;\n\t_leave(\" = 0 { vn=%u u=%u }\", fid->vnode, fid->unique);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int afs_readdir(struct file *file, struct dir_context *ctx);",
            "static int afs_d_delete(const struct dentry *dentry);",
            "static void afs_d_release(struct dentry *dentry);",
            "static int afs_rmdir(struct inode *dir, struct dentry *dentry);",
            "static int afs_unlink(struct inode *dir, struct dentry *dentry);",
            "static int afs_link(struct dentry *from, struct inode *dir,\n\t\t    struct dentry *dentry);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int afs_readdir(struct file *file, struct dir_context *ctx);\nstatic int afs_d_delete(const struct dentry *dentry);\nstatic void afs_d_release(struct dentry *dentry);\nstatic int afs_rmdir(struct inode *dir, struct dentry *dentry);\nstatic int afs_unlink(struct inode *dir, struct dentry *dentry);\nstatic int afs_link(struct dentry *from, struct inode *dir,\n\t\t    struct dentry *dentry);\n\nstatic int afs_do_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t struct afs_fid *fid, struct key *key)\n{\n\tstruct afs_super_info *as = dir->i_sb->s_fs_info;\n\tstruct afs_lookup_cookie cookie = {\n\t\t.ctx.actor = afs_lookup_filldir,\n\t\t.name = dentry->d_name,\n\t\t.fid.vid = as->volume->vid\n\t};\n\tint ret;\n\n\t_enter(\"{%lu},%p{%pd},\", dir->i_ino, dentry, dentry);\n\n\t/* search the directory */\n\tret = afs_dir_iterate(dir, &cookie.ctx, key);\n\tif (ret < 0) {\n\t\t_leave(\" = %d [iter]\", ret);\n\t\treturn ret;\n\t}\n\n\tret = -ENOENT;\n\tif (!cookie.found) {\n\t\t_leave(\" = -ENOENT [not found]\");\n\t\treturn -ENOENT;\n\t}\n\n\t*fid = cookie.fid;\n\t_leave(\" = 0 { vn=%u u=%u }\", fid->vnode, fid->unique);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_validate",
          "args": [
            "vnode",
            "key"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "afs_validate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/inode.c",
          "lines": "313-372",
          "snippet": "int afs_validate(struct afs_vnode *vnode, struct key *key)\n{\n\tint ret;\n\n\t_enter(\"{v={%x:%u} fl=%lx},%x\",\n\t       vnode->fid.vid, vnode->fid.vnode, vnode->flags,\n\t       key_serial(key));\n\n\tif (vnode->cb_promised &&\n\t    !test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags) &&\n\t    !test_bit(AFS_VNODE_MODIFIED, &vnode->flags) &&\n\t    !test_bit(AFS_VNODE_ZAP_DATA, &vnode->flags)) {\n\t\tif (vnode->cb_expires < get_seconds() + 10) {\n\t\t\t_debug(\"callback expired\");\n\t\t\tset_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\t\t} else {\n\t\t\tgoto valid;\n\t\t}\n\t}\n\n\tif (test_bit(AFS_VNODE_DELETED, &vnode->flags))\n\t\tgoto valid;\n\n\tmutex_lock(&vnode->validate_lock);\n\n\t/* if the promise has expired, we need to check the server again to get\n\t * a new promise - note that if the (parent) directory's metadata was\n\t * changed then the security may be different and we may no longer have\n\t * access */\n\tif (!vnode->cb_promised ||\n\t    test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags)) {\n\t\t_debug(\"not promised\");\n\t\tret = afs_vnode_fetch_status(vnode, NULL, key);\n\t\tif (ret < 0)\n\t\t\tgoto error_unlock;\n\t\t_debug(\"new promise [fl=%lx]\", vnode->flags);\n\t}\n\n\tif (test_bit(AFS_VNODE_DELETED, &vnode->flags)) {\n\t\t_debug(\"file already deleted\");\n\t\tret = -ESTALE;\n\t\tgoto error_unlock;\n\t}\n\n\t/* if the vnode's data version number changed then its contents are\n\t * different */\n\tif (test_and_clear_bit(AFS_VNODE_ZAP_DATA, &vnode->flags))\n\t\tafs_zap_data(vnode);\n\n\tclear_bit(AFS_VNODE_MODIFIED, &vnode->flags);\n\tmutex_unlock(&vnode->validate_lock);\nvalid:\n\t_leave(\" = 0\");\n\treturn 0;\n\nerror_unlock:\n\tmutex_unlock(&vnode->validate_lock);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint afs_validate(struct afs_vnode *vnode, struct key *key)\n{\n\tint ret;\n\n\t_enter(\"{v={%x:%u} fl=%lx},%x\",\n\t       vnode->fid.vid, vnode->fid.vnode, vnode->flags,\n\t       key_serial(key));\n\n\tif (vnode->cb_promised &&\n\t    !test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags) &&\n\t    !test_bit(AFS_VNODE_MODIFIED, &vnode->flags) &&\n\t    !test_bit(AFS_VNODE_ZAP_DATA, &vnode->flags)) {\n\t\tif (vnode->cb_expires < get_seconds() + 10) {\n\t\t\t_debug(\"callback expired\");\n\t\t\tset_bit(AFS_VNODE_CB_BROKEN, &vnode->flags);\n\t\t} else {\n\t\t\tgoto valid;\n\t\t}\n\t}\n\n\tif (test_bit(AFS_VNODE_DELETED, &vnode->flags))\n\t\tgoto valid;\n\n\tmutex_lock(&vnode->validate_lock);\n\n\t/* if the promise has expired, we need to check the server again to get\n\t * a new promise - note that if the (parent) directory's metadata was\n\t * changed then the security may be different and we may no longer have\n\t * access */\n\tif (!vnode->cb_promised ||\n\t    test_bit(AFS_VNODE_CB_BROKEN, &vnode->flags)) {\n\t\t_debug(\"not promised\");\n\t\tret = afs_vnode_fetch_status(vnode, NULL, key);\n\t\tif (ret < 0)\n\t\t\tgoto error_unlock;\n\t\t_debug(\"new promise [fl=%lx]\", vnode->flags);\n\t}\n\n\tif (test_bit(AFS_VNODE_DELETED, &vnode->flags)) {\n\t\t_debug(\"file already deleted\");\n\t\tret = -ESTALE;\n\t\tgoto error_unlock;\n\t}\n\n\t/* if the vnode's data version number changed then its contents are\n\t * different */\n\tif (test_and_clear_bit(AFS_VNODE_ZAP_DATA, &vnode->flags))\n\t\tafs_zap_data(vnode);\n\n\tclear_bit(AFS_VNODE_MODIFIED, &vnode->flags);\n\tmutex_unlock(&vnode->validate_lock);\nvalid:\n\t_leave(\" = 0\");\n\treturn 0;\n\nerror_unlock:\n\tmutex_unlock(&vnode->validate_lock);\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "key"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "key"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "key"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_request_key",
          "args": [
            "vnode->volume->cell"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "afs_request_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/security.c",
          "lines": "23-46",
          "snippet": "struct key *afs_request_key(struct afs_cell *cell)\n{\n\tstruct key *key;\n\n\t_enter(\"{%x}\", key_serial(cell->anonymous_key));\n\n\t_debug(\"key %s\", cell->anonymous_key->description);\n\tkey = request_key(&key_type_rxrpc, cell->anonymous_key->description,\n\t\t\t  NULL);\n\tif (IS_ERR(key)) {\n\t\tif (PTR_ERR(key) != -ENOKEY) {\n\t\t\t_leave(\" = %ld\", PTR_ERR(key));\n\t\t\treturn key;\n\t\t}\n\n\t\t/* act as anonymous user */\n\t\t_leave(\" = {%x} [anon]\", key_serial(cell->anonymous_key));\n\t\treturn key_get(cell->anonymous_key);\n\t} else {\n\t\t/* act as authorised user */\n\t\t_leave(\" = {%x} [auth]\", key_serial(key));\n\t\treturn key;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <keys/rxrpc-type.h>",
            "#include <linux/sched.h>",
            "#include <linux/ctype.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <keys/rxrpc-type.h>\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n\nstruct key *afs_request_key(struct afs_cell *cell)\n{\n\tstruct key *key;\n\n\t_enter(\"{%x}\", key_serial(cell->anonymous_key));\n\n\t_debug(\"key %s\", cell->anonymous_key->description);\n\tkey = request_key(&key_type_rxrpc, cell->anonymous_key->description,\n\t\t\t  NULL);\n\tif (IS_ERR(key)) {\n\t\tif (PTR_ERR(key) != -ENOKEY) {\n\t\t\t_leave(\" = %ld\", PTR_ERR(key));\n\t\t\treturn key;\n\t\t}\n\n\t\t/* act as anonymous user */\n\t\t_leave(\" = {%x} [anon]\", key_serial(cell->anonymous_key));\n\t\treturn key_get(cell->anonymous_key);\n\t} else {\n\t\t/* act as authorised user */\n\t\t_leave(\" = {%x} [auth]\", key_serial(key));\n\t\treturn key;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ESTALE"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "AFS_VNODE_DELETED",
            "&vnode->flags"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENAMETOOLONG"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERTCMP",
          "args": [
            "dentry->d_inode",
            "==,NULL"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%x:%u},%p{%pd},\"",
            "vnode->fid.vid",
            "vnode->fid.vnode",
            "dentry",
            "dentry"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AFS_FS_I",
          "args": [
            "dir"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "AFS_FS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/internal.h",
          "lines": "687-690",
          "snippet": "static inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}",
          "includes": [
            "#include \"afs_vl.h\"",
            "#include \"afs.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/fscache.h>",
            "#include <linux/sched.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/key.h>",
            "#include <linux/rxrpc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void afs_discard_callback_on_delete(struct afs_vnode *);",
            "extern void afs_give_up_callback(struct afs_vnode *);",
            "extern void afs_lock_may_be_available(struct afs_vnode *);",
            "extern void afs_zap_data(struct afs_vnode *);",
            "extern void afs_evict_inode(struct inode *);",
            "extern int afs_drop_inode(struct inode *);",
            "extern void afs_clear_permits(struct afs_vnode *);",
            "extern int afs_permission(struct inode *, int);",
            "extern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);",
            "extern int afs_writeback_all(struct afs_vnode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_vl.h\"\n#include \"afs.h\"\n#include <linux/backing-dev.h>\n#include <linux/fscache.h>\n#include <linux/sched.h>\n#include <linux/workqueue.h>\n#include <linux/key.h>\n#include <linux/rxrpc.h>\n#include <linux/skbuff.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n\nextern void afs_discard_callback_on_delete(struct afs_vnode *);\nextern void afs_give_up_callback(struct afs_vnode *);\nextern void afs_lock_may_be_available(struct afs_vnode *);\nextern void afs_zap_data(struct afs_vnode *);\nextern void afs_evict_inode(struct inode *);\nextern int afs_drop_inode(struct inode *);\nextern void afs_clear_permits(struct afs_vnode *);\nextern int afs_permission(struct inode *, int);\nextern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);\nextern int afs_writeback_all(struct afs_vnode *);\n\nstatic inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct dentry *afs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t unsigned int flags);\nstatic int afs_d_revalidate(struct dentry *dentry, unsigned int flags);\nstatic int afs_d_delete(const struct dentry *dentry);\nstatic void afs_d_release(struct dentry *dentry);\nstatic int afs_rmdir(struct inode *dir, struct dentry *dentry);\nstatic int afs_unlink(struct inode *dir, struct dentry *dentry);\nstatic int afs_link(struct dentry *from, struct inode *dir,\n\t\t    struct dentry *dentry);\n\nstatic struct dentry *afs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t unsigned int flags)\n{\n\tstruct afs_vnode *vnode;\n\tstruct afs_fid fid;\n\tstruct inode *inode;\n\tstruct key *key;\n\tint ret;\n\n\tvnode = AFS_FS_I(dir);\n\n\t_enter(\"{%x:%u},%p{%pd},\",\n\t       vnode->fid.vid, vnode->fid.vnode, dentry, dentry);\n\n\tASSERTCMP(dentry->d_inode, ==, NULL);\n\n\tif (dentry->d_name.len >= AFSNAMEMAX) {\n\t\t_leave(\" = -ENAMETOOLONG\");\n\t\treturn ERR_PTR(-ENAMETOOLONG);\n\t}\n\n\tif (test_bit(AFS_VNODE_DELETED, &vnode->flags)) {\n\t\t_leave(\" = -ESTALE\");\n\t\treturn ERR_PTR(-ESTALE);\n\t}\n\n\tkey = afs_request_key(vnode->volume->cell);\n\tif (IS_ERR(key)) {\n\t\t_leave(\" = %ld [key]\", PTR_ERR(key));\n\t\treturn ERR_CAST(key);\n\t}\n\n\tret = afs_validate(vnode, key);\n\tif (ret < 0) {\n\t\tkey_put(key);\n\t\t_leave(\" = %d [val]\", ret);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tret = afs_do_lookup(dir, dentry, &fid, key);\n\tif (ret < 0) {\n\t\tinode = afs_try_auto_mntpt(ret, dentry, dir, key, &fid);\n\t\tif (!IS_ERR(inode)) {\n\t\t\tkey_put(key);\n\t\t\tgoto success;\n\t\t}\n\n\t\tret = PTR_ERR(inode);\n\t\tkey_put(key);\n\t\tif (ret == -ENOENT) {\n\t\t\td_add(dentry, NULL);\n\t\t\t_leave(\" = NULL [negative]\");\n\t\t\treturn NULL;\n\t\t}\n\t\t_leave(\" = %d [do]\", ret);\n\t\treturn ERR_PTR(ret);\n\t}\n\tdentry->d_fsdata = (void *)(unsigned long) vnode->status.data_version;\n\n\t/* instantiate the dentry */\n\tinode = afs_iget(dir->i_sb, key, &fid, NULL, NULL);\n\tkey_put(key);\n\tif (IS_ERR(inode)) {\n\t\t_leave(\" = %ld\", PTR_ERR(inode));\n\t\treturn ERR_CAST(inode);\n\t}\n\nsuccess:\n\td_add(dentry, inode);\n\t_leave(\" = 0 { vn=%u u=%u } -> { ino=%lu v=%u }\",\n\t       fid.vnode,\n\t       fid.unique,\n\t       dentry->d_inode->i_ino,\n\t       dentry->d_inode->i_generation);\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "afs_try_auto_mntpt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/dir.c",
    "lines": "461-489",
    "snippet": "static struct inode *afs_try_auto_mntpt(\n\tint ret, struct dentry *dentry, struct inode *dir, struct key *key,\n\tstruct afs_fid *fid)\n{\n\tconst char *devname = dentry->d_name.name;\n\tstruct afs_vnode *vnode = AFS_FS_I(dir);\n\tstruct inode *inode;\n\n\t_enter(\"%d, %p{%pd}, {%x:%u}, %p\",\n\t       ret, dentry, dentry, vnode->fid.vid, vnode->fid.vnode, key);\n\n\tif (ret != -ENOENT ||\n\t    !test_bit(AFS_VNODE_AUTOCELL, &vnode->flags))\n\t\tgoto out;\n\n\tinode = afs_iget_autocell(dir, devname, strlen(devname), key);\n\tif (IS_ERR(inode)) {\n\t\tret = PTR_ERR(inode);\n\t\tgoto out;\n\t}\n\n\t*fid = AFS_FS_I(inode)->fid;\n\t_leave(\"= %p\", inode);\n\treturn inode;\n\nout:\n\t_leave(\"= %d\", ret);\n\treturn ERR_PTR(ret);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dentry *afs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t unsigned int flags);",
      "static int afs_d_revalidate(struct dentry *dentry, unsigned int flags);",
      "static int afs_d_delete(const struct dentry *dentry);",
      "static void afs_d_release(struct dentry *dentry);",
      "static int afs_rmdir(struct inode *dir, struct dentry *dentry);",
      "static int afs_unlink(struct inode *dir, struct dentry *dentry);",
      "static int afs_link(struct dentry *from, struct inode *dir,\n\t\t    struct dentry *dentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\"= %d\"",
            "ret"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AFS_FS_I",
          "args": [
            "inode"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "AFS_FS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/internal.h",
          "lines": "687-690",
          "snippet": "static inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}",
          "includes": [
            "#include \"afs_vl.h\"",
            "#include \"afs.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/fscache.h>",
            "#include <linux/sched.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/key.h>",
            "#include <linux/rxrpc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void afs_discard_callback_on_delete(struct afs_vnode *);",
            "extern void afs_give_up_callback(struct afs_vnode *);",
            "extern void afs_lock_may_be_available(struct afs_vnode *);",
            "extern void afs_zap_data(struct afs_vnode *);",
            "extern void afs_evict_inode(struct inode *);",
            "extern int afs_drop_inode(struct inode *);",
            "extern void afs_clear_permits(struct afs_vnode *);",
            "extern int afs_permission(struct inode *, int);",
            "extern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);",
            "extern int afs_writeback_all(struct afs_vnode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_vl.h\"\n#include \"afs.h\"\n#include <linux/backing-dev.h>\n#include <linux/fscache.h>\n#include <linux/sched.h>\n#include <linux/workqueue.h>\n#include <linux/key.h>\n#include <linux/rxrpc.h>\n#include <linux/skbuff.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n\nextern void afs_discard_callback_on_delete(struct afs_vnode *);\nextern void afs_give_up_callback(struct afs_vnode *);\nextern void afs_lock_may_be_available(struct afs_vnode *);\nextern void afs_zap_data(struct afs_vnode *);\nextern void afs_evict_inode(struct inode *);\nextern int afs_drop_inode(struct inode *);\nextern void afs_clear_permits(struct afs_vnode *);\nextern int afs_permission(struct inode *, int);\nextern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);\nextern int afs_writeback_all(struct afs_vnode *);\n\nstatic inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "inode"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "inode"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_iget_autocell",
          "args": [
            "dir",
            "devname",
            "strlen(devname)",
            "key"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "afs_iget_autocell",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/inode.c",
          "lines": "136-193",
          "snippet": "struct inode *afs_iget_autocell(struct inode *dir, const char *dev_name,\n\t\t\t\tint namesz, struct key *key)\n{\n\tstruct afs_iget_data data;\n\tstruct afs_super_info *as;\n\tstruct afs_vnode *vnode;\n\tstruct super_block *sb;\n\tstruct inode *inode;\n\tstatic atomic_t afs_autocell_ino;\n\n\t_enter(\"{%x:%u},%*.*s,\",\n\t       AFS_FS_I(dir)->fid.vid, AFS_FS_I(dir)->fid.vnode,\n\t       namesz, namesz, dev_name ?: \"\");\n\n\tsb = dir->i_sb;\n\tas = sb->s_fs_info;\n\tdata.volume = as->volume;\n\tdata.fid.vid = as->volume->vid;\n\tdata.fid.unique = 0;\n\tdata.fid.vnode = 0;\n\n\tinode = iget5_locked(sb, atomic_inc_return(&afs_autocell_ino),\n\t\t\t     afs_iget5_autocell_test, afs_iget5_set,\n\t\t\t     &data);\n\tif (!inode) {\n\t\t_leave(\" = -ENOMEM\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t_debug(\"GOT INODE %p { ino=%lu, vl=%x, vn=%x, u=%x }\",\n\t       inode, inode->i_ino, data.fid.vid, data.fid.vnode,\n\t       data.fid.unique);\n\n\tvnode = AFS_FS_I(inode);\n\n\t/* there shouldn't be an existing inode */\n\tBUG_ON(!(inode->i_state & I_NEW));\n\n\tinode->i_size\t\t= 0;\n\tinode->i_mode\t\t= S_IFDIR | S_IRUGO | S_IXUGO;\n\tinode->i_op\t\t= &afs_autocell_inode_operations;\n\tset_nlink(inode, 2);\n\tinode->i_uid\t\t= GLOBAL_ROOT_UID;\n\tinode->i_gid\t\t= GLOBAL_ROOT_GID;\n\tinode->i_ctime.tv_sec\t= get_seconds();\n\tinode->i_ctime.tv_nsec\t= 0;\n\tinode->i_atime\t\t= inode->i_mtime = inode->i_ctime;\n\tinode->i_blocks\t\t= 0;\n\tinode->i_version\t= 0;\n\tinode->i_generation\t= 0;\n\n\tset_bit(AFS_VNODE_PSEUDODIR, &vnode->flags);\n\tset_bit(AFS_VNODE_MOUNTPOINT, &vnode->flags);\n\tinode->i_flags |= S_AUTOMOUNT | S_NOATIME;\n\tunlock_new_inode(inode);\n\t_leave(\" = %p\", inode);\n\treturn inode;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/sched.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/sched.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstruct inode *afs_iget_autocell(struct inode *dir, const char *dev_name,\n\t\t\t\tint namesz, struct key *key)\n{\n\tstruct afs_iget_data data;\n\tstruct afs_super_info *as;\n\tstruct afs_vnode *vnode;\n\tstruct super_block *sb;\n\tstruct inode *inode;\n\tstatic atomic_t afs_autocell_ino;\n\n\t_enter(\"{%x:%u},%*.*s,\",\n\t       AFS_FS_I(dir)->fid.vid, AFS_FS_I(dir)->fid.vnode,\n\t       namesz, namesz, dev_name ?: \"\");\n\n\tsb = dir->i_sb;\n\tas = sb->s_fs_info;\n\tdata.volume = as->volume;\n\tdata.fid.vid = as->volume->vid;\n\tdata.fid.unique = 0;\n\tdata.fid.vnode = 0;\n\n\tinode = iget5_locked(sb, atomic_inc_return(&afs_autocell_ino),\n\t\t\t     afs_iget5_autocell_test, afs_iget5_set,\n\t\t\t     &data);\n\tif (!inode) {\n\t\t_leave(\" = -ENOMEM\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t_debug(\"GOT INODE %p { ino=%lu, vl=%x, vn=%x, u=%x }\",\n\t       inode, inode->i_ino, data.fid.vid, data.fid.vnode,\n\t       data.fid.unique);\n\n\tvnode = AFS_FS_I(inode);\n\n\t/* there shouldn't be an existing inode */\n\tBUG_ON(!(inode->i_state & I_NEW));\n\n\tinode->i_size\t\t= 0;\n\tinode->i_mode\t\t= S_IFDIR | S_IRUGO | S_IXUGO;\n\tinode->i_op\t\t= &afs_autocell_inode_operations;\n\tset_nlink(inode, 2);\n\tinode->i_uid\t\t= GLOBAL_ROOT_UID;\n\tinode->i_gid\t\t= GLOBAL_ROOT_GID;\n\tinode->i_ctime.tv_sec\t= get_seconds();\n\tinode->i_ctime.tv_nsec\t= 0;\n\tinode->i_atime\t\t= inode->i_mtime = inode->i_ctime;\n\tinode->i_blocks\t\t= 0;\n\tinode->i_version\t= 0;\n\tinode->i_generation\t= 0;\n\n\tset_bit(AFS_VNODE_PSEUDODIR, &vnode->flags);\n\tset_bit(AFS_VNODE_MOUNTPOINT, &vnode->flags);\n\tinode->i_flags |= S_AUTOMOUNT | S_NOATIME;\n\tunlock_new_inode(inode);\n\t_leave(\" = %p\", inode);\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "devname"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "AFS_VNODE_AUTOCELL",
            "&vnode->flags"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"%d, %p{%pd}, {%x:%u}, %p\"",
            "ret",
            "dentry",
            "dentry",
            "vnode->fid.vid",
            "vnode->fid.vnode",
            "key"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct dentry *afs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t unsigned int flags);\nstatic int afs_d_revalidate(struct dentry *dentry, unsigned int flags);\nstatic int afs_d_delete(const struct dentry *dentry);\nstatic void afs_d_release(struct dentry *dentry);\nstatic int afs_rmdir(struct inode *dir, struct dentry *dentry);\nstatic int afs_unlink(struct inode *dir, struct dentry *dentry);\nstatic int afs_link(struct dentry *from, struct inode *dir,\n\t\t    struct dentry *dentry);\n\nstatic struct inode *afs_try_auto_mntpt(\n\tint ret, struct dentry *dentry, struct inode *dir, struct key *key,\n\tstruct afs_fid *fid)\n{\n\tconst char *devname = dentry->d_name.name;\n\tstruct afs_vnode *vnode = AFS_FS_I(dir);\n\tstruct inode *inode;\n\n\t_enter(\"%d, %p{%pd}, {%x:%u}, %p\",\n\t       ret, dentry, dentry, vnode->fid.vid, vnode->fid.vnode, key);\n\n\tif (ret != -ENOENT ||\n\t    !test_bit(AFS_VNODE_AUTOCELL, &vnode->flags))\n\t\tgoto out;\n\n\tinode = afs_iget_autocell(dir, devname, strlen(devname), key);\n\tif (IS_ERR(inode)) {\n\t\tret = PTR_ERR(inode);\n\t\tgoto out;\n\t}\n\n\t*fid = AFS_FS_I(inode)->fid;\n\t_leave(\"= %p\", inode);\n\treturn inode;\n\nout:\n\t_leave(\"= %d\", ret);\n\treturn ERR_PTR(ret);\n}"
  },
  {
    "function_name": "afs_do_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/dir.c",
    "lines": "426-455",
    "snippet": "static int afs_do_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t struct afs_fid *fid, struct key *key)\n{\n\tstruct afs_super_info *as = dir->i_sb->s_fs_info;\n\tstruct afs_lookup_cookie cookie = {\n\t\t.ctx.actor = afs_lookup_filldir,\n\t\t.name = dentry->d_name,\n\t\t.fid.vid = as->volume->vid\n\t};\n\tint ret;\n\n\t_enter(\"{%lu},%p{%pd},\", dir->i_ino, dentry, dentry);\n\n\t/* search the directory */\n\tret = afs_dir_iterate(dir, &cookie.ctx, key);\n\tif (ret < 0) {\n\t\t_leave(\" = %d [iter]\", ret);\n\t\treturn ret;\n\t}\n\n\tret = -ENOENT;\n\tif (!cookie.found) {\n\t\t_leave(\" = -ENOENT [not found]\");\n\t\treturn -ENOENT;\n\t}\n\n\t*fid = cookie.fid;\n\t_leave(\" = 0 { vn=%u u=%u }\", fid->vnode, fid->unique);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int afs_readdir(struct file *file, struct dir_context *ctx);",
      "static int afs_d_delete(const struct dentry *dentry);",
      "static void afs_d_release(struct dentry *dentry);",
      "static int afs_rmdir(struct inode *dir, struct dentry *dentry);",
      "static int afs_unlink(struct inode *dir, struct dentry *dentry);",
      "static int afs_link(struct dentry *from, struct inode *dir,\n\t\t    struct dentry *dentry);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = 0 { vn=%u u=%u }\"",
            "fid->vnode",
            "fid->unique"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "are_leaves_removable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/fix_node.c",
          "lines": "698-757",
          "snippet": "static int are_leaves_removable(struct tree_balance *tb, int lfree, int rfree)\n{\n\tstruct virtual_node *vn = tb->tb_vn;\n\tint ih_size;\n\tstruct buffer_head *S0;\n\n\tS0 = PATH_H_PBUFFER(tb->tb_path, 0);\n\n\tih_size = 0;\n\tif (vn->vn_nr_item) {\n\t\tif (vn->vn_vi[0].vi_type & VI_TYPE_LEFT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\n\t\tif (vn->vn_vi[vn->vn_nr_item - 1].\n\t\t    vi_type & VI_TYPE_RIGHT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\t} else {\n\t\t/* there was only one item and it will be deleted */\n\t\tstruct item_head *ih;\n\n\t\tRFALSE(B_NR_ITEMS(S0) != 1,\n\t\t       \"vs-8125: item number must be 1: it is %d\",\n\t\t       B_NR_ITEMS(S0));\n\n\t\tih = item_head(S0, 0);\n\t\tif (tb->CFR[0]\n\t\t    && !comp_short_le_keys(&ih->ih_key,\n\t\t\t\t\t   internal_key(tb->CFR[0],\n\t\t\t\t\t\t\t  tb->rkey[0])))\n\t\t\t/*\n\t\t\t * Directory must be in correct state here: that is\n\t\t\t * somewhere at the left side should exist first\n\t\t\t * directory item. But the item being deleted can\n\t\t\t * not be that first one because its right neighbor\n\t\t\t * is item of the same directory. (But first item\n\t\t\t * always gets deleted in last turn). So, neighbors\n\t\t\t * of deleted item can be merged, so we can save\n\t\t\t * ih_size\n\t\t\t */\n\t\t\tif (is_direntry_le_ih(ih)) {\n\t\t\t\tih_size = IH_SIZE;\n\n\t\t\t\t/*\n\t\t\t\t * we might check that left neighbor exists\n\t\t\t\t * and is of the same directory\n\t\t\t\t */\n\t\t\t\tRFALSE(le_ih_k_offset(ih) == DOT_OFFSET,\n\t\t\t\t       \"vs-8130: first directory item can not be removed until directory is not empty\");\n\t\t\t}\n\n\t}\n\n\tif (MAX_CHILD_SIZE(S0) + vn->vn_size <= rfree + lfree + ih_size) {\n\t\tset_parameters(tb, 0, -1, -1, -1, NULL, -1, -1);\n\t\tPROC_INFO_INC(tb->tb_sb, leaves_removable);\n\t\treturn 1;\n\t}\n\treturn 0;\n\n}",
          "includes": [
            "#include <linux/buffer_head.h>",
            "#include \"reiserfs.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/buffer_head.h>\n#include \"reiserfs.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/time.h>\n\nstatic int are_leaves_removable(struct tree_balance *tb, int lfree, int rfree)\n{\n\tstruct virtual_node *vn = tb->tb_vn;\n\tint ih_size;\n\tstruct buffer_head *S0;\n\n\tS0 = PATH_H_PBUFFER(tb->tb_path, 0);\n\n\tih_size = 0;\n\tif (vn->vn_nr_item) {\n\t\tif (vn->vn_vi[0].vi_type & VI_TYPE_LEFT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\n\t\tif (vn->vn_vi[vn->vn_nr_item - 1].\n\t\t    vi_type & VI_TYPE_RIGHT_MERGEABLE)\n\t\t\tih_size += IH_SIZE;\n\t} else {\n\t\t/* there was only one item and it will be deleted */\n\t\tstruct item_head *ih;\n\n\t\tRFALSE(B_NR_ITEMS(S0) != 1,\n\t\t       \"vs-8125: item number must be 1: it is %d\",\n\t\t       B_NR_ITEMS(S0));\n\n\t\tih = item_head(S0, 0);\n\t\tif (tb->CFR[0]\n\t\t    && !comp_short_le_keys(&ih->ih_key,\n\t\t\t\t\t   internal_key(tb->CFR[0],\n\t\t\t\t\t\t\t  tb->rkey[0])))\n\t\t\t/*\n\t\t\t * Directory must be in correct state here: that is\n\t\t\t * somewhere at the left side should exist first\n\t\t\t * directory item. But the item being deleted can\n\t\t\t * not be that first one because its right neighbor\n\t\t\t * is item of the same directory. (But first item\n\t\t\t * always gets deleted in last turn). So, neighbors\n\t\t\t * of deleted item can be merged, so we can save\n\t\t\t * ih_size\n\t\t\t */\n\t\t\tif (is_direntry_le_ih(ih)) {\n\t\t\t\tih_size = IH_SIZE;\n\n\t\t\t\t/*\n\t\t\t\t * we might check that left neighbor exists\n\t\t\t\t * and is of the same directory\n\t\t\t\t */\n\t\t\t\tRFALSE(le_ih_k_offset(ih) == DOT_OFFSET,\n\t\t\t\t       \"vs-8130: first directory item can not be removed until directory is not empty\");\n\t\t\t}\n\n\t}\n\n\tif (MAX_CHILD_SIZE(S0) + vn->vn_size <= rfree + lfree + ih_size) {\n\t\tset_parameters(tb, 0, -1, -1, -1, NULL, -1, -1);\n\t\tPROC_INFO_INC(tb->tb_sb, leaves_removable);\n\t\treturn 1;\n\t}\n\treturn 0;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = -ENOENT [not found]\""
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d [iter]\"",
            "ret"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_dir_iterate",
          "args": [
            "dir",
            "&cookie.ctx",
            "key"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "afs_dir_iterate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/dir.c",
          "lines": "321-378",
          "snippet": "static int afs_dir_iterate(struct inode *dir, struct dir_context *ctx,\n\t\t\t   struct key *key)\n{\n\tunion afs_dir_block *dblock;\n\tstruct afs_dir_page *dbuf;\n\tstruct page *page;\n\tunsigned blkoff, limit;\n\tint ret;\n\n\t_enter(\"{%lu},%u,,\", dir->i_ino, (unsigned)ctx->pos);\n\n\tif (test_bit(AFS_VNODE_DELETED, &AFS_FS_I(dir)->flags)) {\n\t\t_leave(\" = -ESTALE\");\n\t\treturn -ESTALE;\n\t}\n\n\t/* round the file position up to the next entry boundary */\n\tctx->pos += sizeof(union afs_dirent) - 1;\n\tctx->pos &= ~(sizeof(union afs_dirent) - 1);\n\n\t/* walk through the blocks in sequence */\n\tret = 0;\n\twhile (ctx->pos < dir->i_size) {\n\t\tblkoff = ctx->pos & ~(sizeof(union afs_dir_block) - 1);\n\n\t\t/* fetch the appropriate page from the directory */\n\t\tpage = afs_dir_get_page(dir, blkoff / PAGE_SIZE, key);\n\t\tif (IS_ERR(page)) {\n\t\t\tret = PTR_ERR(page);\n\t\t\tbreak;\n\t\t}\n\n\t\tlimit = blkoff & ~(PAGE_SIZE - 1);\n\n\t\tdbuf = page_address(page);\n\n\t\t/* deal with the individual blocks stashed on this page */\n\t\tdo {\n\t\t\tdblock = &dbuf->blocks[(blkoff % PAGE_SIZE) /\n\t\t\t\t\t       sizeof(union afs_dir_block)];\n\t\t\tret = afs_dir_iterate_block(ctx, dblock, blkoff);\n\t\t\tif (ret != 1) {\n\t\t\t\tafs_dir_put_page(page);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tblkoff += sizeof(union afs_dir_block);\n\n\t\t} while (ctx->pos < dir->i_size && blkoff < limit);\n\n\t\tafs_dir_put_page(page);\n\t\tret = 0;\n\t}\n\nout:\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dentry *afs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t unsigned int flags);",
            "static int afs_dir_open(struct inode *inode, struct file *file);",
            "static int afs_readdir(struct file *file, struct dir_context *ctx);",
            "static int afs_d_revalidate(struct dentry *dentry, unsigned int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct dentry *afs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t unsigned int flags);\nstatic int afs_dir_open(struct inode *inode, struct file *file);\nstatic int afs_readdir(struct file *file, struct dir_context *ctx);\nstatic int afs_d_revalidate(struct dentry *dentry, unsigned int flags);\n\nstatic int afs_dir_iterate(struct inode *dir, struct dir_context *ctx,\n\t\t\t   struct key *key)\n{\n\tunion afs_dir_block *dblock;\n\tstruct afs_dir_page *dbuf;\n\tstruct page *page;\n\tunsigned blkoff, limit;\n\tint ret;\n\n\t_enter(\"{%lu},%u,,\", dir->i_ino, (unsigned)ctx->pos);\n\n\tif (test_bit(AFS_VNODE_DELETED, &AFS_FS_I(dir)->flags)) {\n\t\t_leave(\" = -ESTALE\");\n\t\treturn -ESTALE;\n\t}\n\n\t/* round the file position up to the next entry boundary */\n\tctx->pos += sizeof(union afs_dirent) - 1;\n\tctx->pos &= ~(sizeof(union afs_dirent) - 1);\n\n\t/* walk through the blocks in sequence */\n\tret = 0;\n\twhile (ctx->pos < dir->i_size) {\n\t\tblkoff = ctx->pos & ~(sizeof(union afs_dir_block) - 1);\n\n\t\t/* fetch the appropriate page from the directory */\n\t\tpage = afs_dir_get_page(dir, blkoff / PAGE_SIZE, key);\n\t\tif (IS_ERR(page)) {\n\t\t\tret = PTR_ERR(page);\n\t\t\tbreak;\n\t\t}\n\n\t\tlimit = blkoff & ~(PAGE_SIZE - 1);\n\n\t\tdbuf = page_address(page);\n\n\t\t/* deal with the individual blocks stashed on this page */\n\t\tdo {\n\t\t\tdblock = &dbuf->blocks[(blkoff % PAGE_SIZE) /\n\t\t\t\t\t       sizeof(union afs_dir_block)];\n\t\t\tret = afs_dir_iterate_block(ctx, dblock, blkoff);\n\t\t\tif (ret != 1) {\n\t\t\t\tafs_dir_put_page(page);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tblkoff += sizeof(union afs_dir_block);\n\n\t\t} while (ctx->pos < dir->i_size && blkoff < limit);\n\n\t\tafs_dir_put_page(page);\n\t\tret = 0;\n\t}\n\nout:\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%lu},%p{%pd},\"",
            "dir->i_ino",
            "dentry",
            "dentry"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int afs_readdir(struct file *file, struct dir_context *ctx);\nstatic int afs_d_delete(const struct dentry *dentry);\nstatic void afs_d_release(struct dentry *dentry);\nstatic int afs_rmdir(struct inode *dir, struct dentry *dentry);\nstatic int afs_unlink(struct inode *dir, struct dentry *dentry);\nstatic int afs_link(struct dentry *from, struct inode *dir,\n\t\t    struct dentry *dentry);\n\nstatic int afs_do_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t struct afs_fid *fid, struct key *key)\n{\n\tstruct afs_super_info *as = dir->i_sb->s_fs_info;\n\tstruct afs_lookup_cookie cookie = {\n\t\t.ctx.actor = afs_lookup_filldir,\n\t\t.name = dentry->d_name,\n\t\t.fid.vid = as->volume->vid\n\t};\n\tint ret;\n\n\t_enter(\"{%lu},%p{%pd},\", dir->i_ino, dentry, dentry);\n\n\t/* search the directory */\n\tret = afs_dir_iterate(dir, &cookie.ctx, key);\n\tif (ret < 0) {\n\t\t_leave(\" = %d [iter]\", ret);\n\t\treturn ret;\n\t}\n\n\tret = -ENOENT;\n\tif (!cookie.found) {\n\t\t_leave(\" = -ENOENT [not found]\");\n\t\treturn -ENOENT;\n\t}\n\n\t*fid = cookie.fid;\n\t_leave(\" = 0 { vn=%u u=%u }\", fid->vnode, fid->unique);\n\treturn 0;\n}"
  },
  {
    "function_name": "afs_lookup_filldir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/dir.c",
    "lines": "394-420",
    "snippet": "static int afs_lookup_filldir(struct dir_context *ctx, const char *name,\n\t\t\t      int nlen, loff_t fpos, u64 ino, unsigned dtype)\n{\n\tstruct afs_lookup_cookie *cookie =\n\t\tcontainer_of(ctx, struct afs_lookup_cookie, ctx);\n\n\t_enter(\"{%s,%u},%s,%u,,%llu,%u\",\n\t       cookie->name.name, cookie->name.len, name, nlen,\n\t       (unsigned long long) ino, dtype);\n\n\t/* insanity checks first */\n\tBUILD_BUG_ON(sizeof(union afs_dir_block) != 2048);\n\tBUILD_BUG_ON(sizeof(union afs_dirent) != 32);\n\n\tif (cookie->name.len != nlen ||\n\t    memcmp(cookie->name.name, name, nlen) != 0) {\n\t\t_leave(\" = 0 [no]\");\n\t\treturn 0;\n\t}\n\n\tcookie->fid.vnode = ino;\n\tcookie->fid.unique = dtype;\n\tcookie->found = 1;\n\n\t_leave(\" = -1 [found]\");\n\treturn -1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int afs_readdir(struct file *file, struct dir_context *ctx);",
      "static int afs_lookup_filldir(struct dir_context *ctx, const char *name, int nlen,\n\t\t\t\t  loff_t fpos, u64 ino, unsigned dtype);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = -1 [found]\""
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "cookie->name.name",
            "name",
            "nlen"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "sizeof(union afs_dirent) != 32"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "sizeof(union afs_dir_block) != 2048"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%s,%u},%s,%u,,%llu,%u\"",
            "cookie->name.name",
            "cookie->name.len",
            "name",
            "nlen",
            "(unsigned long long) ino",
            "dtype"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ctx",
            "structafs_lookup_cookie",
            "ctx"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int afs_readdir(struct file *file, struct dir_context *ctx);\nstatic int afs_lookup_filldir(struct dir_context *ctx, const char *name, int nlen,\n\t\t\t\t  loff_t fpos, u64 ino, unsigned dtype);\n\nstatic int afs_lookup_filldir(struct dir_context *ctx, const char *name,\n\t\t\t      int nlen, loff_t fpos, u64 ino, unsigned dtype)\n{\n\tstruct afs_lookup_cookie *cookie =\n\t\tcontainer_of(ctx, struct afs_lookup_cookie, ctx);\n\n\t_enter(\"{%s,%u},%s,%u,,%llu,%u\",\n\t       cookie->name.name, cookie->name.len, name, nlen,\n\t       (unsigned long long) ino, dtype);\n\n\t/* insanity checks first */\n\tBUILD_BUG_ON(sizeof(union afs_dir_block) != 2048);\n\tBUILD_BUG_ON(sizeof(union afs_dirent) != 32);\n\n\tif (cookie->name.len != nlen ||\n\t    memcmp(cookie->name.name, name, nlen) != 0) {\n\t\t_leave(\" = 0 [no]\");\n\t\treturn 0;\n\t}\n\n\tcookie->fid.vnode = ino;\n\tcookie->fid.unique = dtype;\n\tcookie->found = 1;\n\n\t_leave(\" = -1 [found]\");\n\treturn -1;\n}"
  },
  {
    "function_name": "afs_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/dir.c",
    "lines": "383-387",
    "snippet": "static int afs_readdir(struct file *file, struct dir_context *ctx)\n{\n\treturn afs_dir_iterate(file_inode(file), \n\t\t\t      ctx, file->private_data);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int afs_dir_open(struct inode *inode, struct file *file);",
      "static int afs_readdir(struct file *file, struct dir_context *ctx);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "afs_dir_iterate",
          "args": [
            "file_inode(file)",
            "ctx",
            "file->private_data"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "afs_dir_iterate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/dir.c",
          "lines": "321-378",
          "snippet": "static int afs_dir_iterate(struct inode *dir, struct dir_context *ctx,\n\t\t\t   struct key *key)\n{\n\tunion afs_dir_block *dblock;\n\tstruct afs_dir_page *dbuf;\n\tstruct page *page;\n\tunsigned blkoff, limit;\n\tint ret;\n\n\t_enter(\"{%lu},%u,,\", dir->i_ino, (unsigned)ctx->pos);\n\n\tif (test_bit(AFS_VNODE_DELETED, &AFS_FS_I(dir)->flags)) {\n\t\t_leave(\" = -ESTALE\");\n\t\treturn -ESTALE;\n\t}\n\n\t/* round the file position up to the next entry boundary */\n\tctx->pos += sizeof(union afs_dirent) - 1;\n\tctx->pos &= ~(sizeof(union afs_dirent) - 1);\n\n\t/* walk through the blocks in sequence */\n\tret = 0;\n\twhile (ctx->pos < dir->i_size) {\n\t\tblkoff = ctx->pos & ~(sizeof(union afs_dir_block) - 1);\n\n\t\t/* fetch the appropriate page from the directory */\n\t\tpage = afs_dir_get_page(dir, blkoff / PAGE_SIZE, key);\n\t\tif (IS_ERR(page)) {\n\t\t\tret = PTR_ERR(page);\n\t\t\tbreak;\n\t\t}\n\n\t\tlimit = blkoff & ~(PAGE_SIZE - 1);\n\n\t\tdbuf = page_address(page);\n\n\t\t/* deal with the individual blocks stashed on this page */\n\t\tdo {\n\t\t\tdblock = &dbuf->blocks[(blkoff % PAGE_SIZE) /\n\t\t\t\t\t       sizeof(union afs_dir_block)];\n\t\t\tret = afs_dir_iterate_block(ctx, dblock, blkoff);\n\t\t\tif (ret != 1) {\n\t\t\t\tafs_dir_put_page(page);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tblkoff += sizeof(union afs_dir_block);\n\n\t\t} while (ctx->pos < dir->i_size && blkoff < limit);\n\n\t\tafs_dir_put_page(page);\n\t\tret = 0;\n\t}\n\nout:\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct dentry *afs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t unsigned int flags);",
            "static int afs_dir_open(struct inode *inode, struct file *file);",
            "static int afs_readdir(struct file *file, struct dir_context *ctx);",
            "static int afs_d_revalidate(struct dentry *dentry, unsigned int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct dentry *afs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t unsigned int flags);\nstatic int afs_dir_open(struct inode *inode, struct file *file);\nstatic int afs_readdir(struct file *file, struct dir_context *ctx);\nstatic int afs_d_revalidate(struct dentry *dentry, unsigned int flags);\n\nstatic int afs_dir_iterate(struct inode *dir, struct dir_context *ctx,\n\t\t\t   struct key *key)\n{\n\tunion afs_dir_block *dblock;\n\tstruct afs_dir_page *dbuf;\n\tstruct page *page;\n\tunsigned blkoff, limit;\n\tint ret;\n\n\t_enter(\"{%lu},%u,,\", dir->i_ino, (unsigned)ctx->pos);\n\n\tif (test_bit(AFS_VNODE_DELETED, &AFS_FS_I(dir)->flags)) {\n\t\t_leave(\" = -ESTALE\");\n\t\treturn -ESTALE;\n\t}\n\n\t/* round the file position up to the next entry boundary */\n\tctx->pos += sizeof(union afs_dirent) - 1;\n\tctx->pos &= ~(sizeof(union afs_dirent) - 1);\n\n\t/* walk through the blocks in sequence */\n\tret = 0;\n\twhile (ctx->pos < dir->i_size) {\n\t\tblkoff = ctx->pos & ~(sizeof(union afs_dir_block) - 1);\n\n\t\t/* fetch the appropriate page from the directory */\n\t\tpage = afs_dir_get_page(dir, blkoff / PAGE_SIZE, key);\n\t\tif (IS_ERR(page)) {\n\t\t\tret = PTR_ERR(page);\n\t\t\tbreak;\n\t\t}\n\n\t\tlimit = blkoff & ~(PAGE_SIZE - 1);\n\n\t\tdbuf = page_address(page);\n\n\t\t/* deal with the individual blocks stashed on this page */\n\t\tdo {\n\t\t\tdblock = &dbuf->blocks[(blkoff % PAGE_SIZE) /\n\t\t\t\t\t       sizeof(union afs_dir_block)];\n\t\t\tret = afs_dir_iterate_block(ctx, dblock, blkoff);\n\t\t\tif (ret != 1) {\n\t\t\t\tafs_dir_put_page(page);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tblkoff += sizeof(union afs_dir_block);\n\n\t\t} while (ctx->pos < dir->i_size && blkoff < limit);\n\n\t\tafs_dir_put_page(page);\n\t\tret = 0;\n\t}\n\nout:\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int afs_dir_open(struct inode *inode, struct file *file);\nstatic int afs_readdir(struct file *file, struct dir_context *ctx);\n\nstatic int afs_readdir(struct file *file, struct dir_context *ctx)\n{\n\treturn afs_dir_iterate(file_inode(file), \n\t\t\t      ctx, file->private_data);\n}"
  },
  {
    "function_name": "afs_dir_iterate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/dir.c",
    "lines": "321-378",
    "snippet": "static int afs_dir_iterate(struct inode *dir, struct dir_context *ctx,\n\t\t\t   struct key *key)\n{\n\tunion afs_dir_block *dblock;\n\tstruct afs_dir_page *dbuf;\n\tstruct page *page;\n\tunsigned blkoff, limit;\n\tint ret;\n\n\t_enter(\"{%lu},%u,,\", dir->i_ino, (unsigned)ctx->pos);\n\n\tif (test_bit(AFS_VNODE_DELETED, &AFS_FS_I(dir)->flags)) {\n\t\t_leave(\" = -ESTALE\");\n\t\treturn -ESTALE;\n\t}\n\n\t/* round the file position up to the next entry boundary */\n\tctx->pos += sizeof(union afs_dirent) - 1;\n\tctx->pos &= ~(sizeof(union afs_dirent) - 1);\n\n\t/* walk through the blocks in sequence */\n\tret = 0;\n\twhile (ctx->pos < dir->i_size) {\n\t\tblkoff = ctx->pos & ~(sizeof(union afs_dir_block) - 1);\n\n\t\t/* fetch the appropriate page from the directory */\n\t\tpage = afs_dir_get_page(dir, blkoff / PAGE_SIZE, key);\n\t\tif (IS_ERR(page)) {\n\t\t\tret = PTR_ERR(page);\n\t\t\tbreak;\n\t\t}\n\n\t\tlimit = blkoff & ~(PAGE_SIZE - 1);\n\n\t\tdbuf = page_address(page);\n\n\t\t/* deal with the individual blocks stashed on this page */\n\t\tdo {\n\t\t\tdblock = &dbuf->blocks[(blkoff % PAGE_SIZE) /\n\t\t\t\t\t       sizeof(union afs_dir_block)];\n\t\t\tret = afs_dir_iterate_block(ctx, dblock, blkoff);\n\t\t\tif (ret != 1) {\n\t\t\t\tafs_dir_put_page(page);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tblkoff += sizeof(union afs_dir_block);\n\n\t\t} while (ctx->pos < dir->i_size && blkoff < limit);\n\n\t\tafs_dir_put_page(page);\n\t\tret = 0;\n\t}\n\nout:\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dentry *afs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t unsigned int flags);",
      "static int afs_dir_open(struct inode *inode, struct file *file);",
      "static int afs_readdir(struct file *file, struct dir_context *ctx);",
      "static int afs_d_revalidate(struct dentry *dentry, unsigned int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dx_dir_kmalloc_leaves",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dir.c",
          "lines": "2534-2546",
          "snippet": "static struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct buffer_head **ocfs2_dx_dir_kmalloc_leaves(struct super_block *sb,\n\t\t\t\t\t\t\tint *ret_num_leaves)\n{\n\tint num_dx_leaves = ocfs2_clusters_to_blocks(sb, 1);\n\tstruct buffer_head **dx_leaves;\n\n\tdx_leaves = kcalloc(num_dx_leaves, sizeof(struct buffer_head *),\n\t\t\t    GFP_NOFS);\n\tif (dx_leaves && ret_num_leaves)\n\t\t*ret_num_leaves = num_dx_leaves;\n\n\treturn dx_leaves;\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_dir_put_page",
          "args": [
            "page"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "afs_dir_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/dir.c",
          "lines": "181-185",
          "snippet": "static inline void afs_dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic inline void afs_dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_dir_iterate_block",
          "args": [
            "ctx",
            "dblock",
            "blkoff"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "afs_dir_iterate_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/dir.c",
          "lines": "231-316",
          "snippet": "static int afs_dir_iterate_block(struct dir_context *ctx,\n\t\t\t\t union afs_dir_block *block,\n\t\t\t\t unsigned blkoff)\n{\n\tunion afs_dirent *dire;\n\tunsigned offset, next, curr;\n\tsize_t nlen;\n\tint tmp;\n\n\t_enter(\"%u,%x,%p,,\",(unsigned)ctx->pos,blkoff,block);\n\n\tcurr = (ctx->pos - blkoff) / sizeof(union afs_dirent);\n\n\t/* walk through the block, an entry at a time */\n\tfor (offset = AFS_DIRENT_PER_BLOCK - block->pagehdr.nentries;\n\t     offset < AFS_DIRENT_PER_BLOCK;\n\t     offset = next\n\t     ) {\n\t\tnext = offset + 1;\n\n\t\t/* skip entries marked unused in the bitmap */\n\t\tif (!(block->pagehdr.bitmap[offset / 8] &\n\t\t      (1 << (offset % 8)))) {\n\t\t\t_debug(\"ENT[%Zu.%u]: unused\",\n\t\t\t       blkoff / sizeof(union afs_dir_block), offset);\n\t\t\tif (offset >= curr)\n\t\t\t\tctx->pos = blkoff +\n\t\t\t\t\tnext * sizeof(union afs_dirent);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* got a valid entry */\n\t\tdire = &block->dirents[offset];\n\t\tnlen = strnlen(dire->u.name,\n\t\t\t       sizeof(*block) -\n\t\t\t       offset * sizeof(union afs_dirent));\n\n\t\t_debug(\"ENT[%Zu.%u]: %s %Zu \\\"%s\\\"\",\n\t\t       blkoff / sizeof(union afs_dir_block), offset,\n\t\t       (offset < curr ? \"skip\" : \"fill\"),\n\t\t       nlen, dire->u.name);\n\n\t\t/* work out where the next possible entry is */\n\t\tfor (tmp = nlen; tmp > 15; tmp -= sizeof(union afs_dirent)) {\n\t\t\tif (next >= AFS_DIRENT_PER_BLOCK) {\n\t\t\t\t_debug(\"ENT[%Zu.%u]:\"\n\t\t\t\t       \" %u travelled beyond end dir block\"\n\t\t\t\t       \" (len %u/%Zu)\",\n\t\t\t\t       blkoff / sizeof(union afs_dir_block),\n\t\t\t\t       offset, next, tmp, nlen);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tif (!(block->pagehdr.bitmap[next / 8] &\n\t\t\t      (1 << (next % 8)))) {\n\t\t\t\t_debug(\"ENT[%Zu.%u]:\"\n\t\t\t\t       \" %u unmarked extension (len %u/%Zu)\",\n\t\t\t\t       blkoff / sizeof(union afs_dir_block),\n\t\t\t\t       offset, next, tmp, nlen);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\n\t\t\t_debug(\"ENT[%Zu.%u]: ext %u/%Zu\",\n\t\t\t       blkoff / sizeof(union afs_dir_block),\n\t\t\t       next, tmp, nlen);\n\t\t\tnext++;\n\t\t}\n\n\t\t/* skip if starts before the current position */\n\t\tif (offset < curr)\n\t\t\tcontinue;\n\n\t\t/* found the next entry */\n\t\tif (!dir_emit(ctx, dire->u.name, nlen,\n\t\t\t      ntohl(dire->u.vnode),\n\t\t\t      ctx->actor == afs_lookup_filldir ?\n\t\t\t      ntohl(dire->u.unique) : DT_UNKNOWN)) {\n\t\t\t_leave(\" = 0 [full]\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tctx->pos = blkoff + next * sizeof(union afs_dirent);\n\t}\n\n\t_leave(\" = 1 [more]\");\n\treturn 1;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define AFS_DIRENT_PER_BLOCK\t64"
          ],
          "globals_used": [
            "static int afs_readdir(struct file *file, struct dir_context *ctx);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\n#define AFS_DIRENT_PER_BLOCK\t64\n\nstatic int afs_readdir(struct file *file, struct dir_context *ctx);\n\nstatic int afs_dir_iterate_block(struct dir_context *ctx,\n\t\t\t\t union afs_dir_block *block,\n\t\t\t\t unsigned blkoff)\n{\n\tunion afs_dirent *dire;\n\tunsigned offset, next, curr;\n\tsize_t nlen;\n\tint tmp;\n\n\t_enter(\"%u,%x,%p,,\",(unsigned)ctx->pos,blkoff,block);\n\n\tcurr = (ctx->pos - blkoff) / sizeof(union afs_dirent);\n\n\t/* walk through the block, an entry at a time */\n\tfor (offset = AFS_DIRENT_PER_BLOCK - block->pagehdr.nentries;\n\t     offset < AFS_DIRENT_PER_BLOCK;\n\t     offset = next\n\t     ) {\n\t\tnext = offset + 1;\n\n\t\t/* skip entries marked unused in the bitmap */\n\t\tif (!(block->pagehdr.bitmap[offset / 8] &\n\t\t      (1 << (offset % 8)))) {\n\t\t\t_debug(\"ENT[%Zu.%u]: unused\",\n\t\t\t       blkoff / sizeof(union afs_dir_block), offset);\n\t\t\tif (offset >= curr)\n\t\t\t\tctx->pos = blkoff +\n\t\t\t\t\tnext * sizeof(union afs_dirent);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* got a valid entry */\n\t\tdire = &block->dirents[offset];\n\t\tnlen = strnlen(dire->u.name,\n\t\t\t       sizeof(*block) -\n\t\t\t       offset * sizeof(union afs_dirent));\n\n\t\t_debug(\"ENT[%Zu.%u]: %s %Zu \\\"%s\\\"\",\n\t\t       blkoff / sizeof(union afs_dir_block), offset,\n\t\t       (offset < curr ? \"skip\" : \"fill\"),\n\t\t       nlen, dire->u.name);\n\n\t\t/* work out where the next possible entry is */\n\t\tfor (tmp = nlen; tmp > 15; tmp -= sizeof(union afs_dirent)) {\n\t\t\tif (next >= AFS_DIRENT_PER_BLOCK) {\n\t\t\t\t_debug(\"ENT[%Zu.%u]:\"\n\t\t\t\t       \" %u travelled beyond end dir block\"\n\t\t\t\t       \" (len %u/%Zu)\",\n\t\t\t\t       blkoff / sizeof(union afs_dir_block),\n\t\t\t\t       offset, next, tmp, nlen);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tif (!(block->pagehdr.bitmap[next / 8] &\n\t\t\t      (1 << (next % 8)))) {\n\t\t\t\t_debug(\"ENT[%Zu.%u]:\"\n\t\t\t\t       \" %u unmarked extension (len %u/%Zu)\",\n\t\t\t\t       blkoff / sizeof(union afs_dir_block),\n\t\t\t\t       offset, next, tmp, nlen);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\n\t\t\t_debug(\"ENT[%Zu.%u]: ext %u/%Zu\",\n\t\t\t       blkoff / sizeof(union afs_dir_block),\n\t\t\t       next, tmp, nlen);\n\t\t\tnext++;\n\t\t}\n\n\t\t/* skip if starts before the current position */\n\t\tif (offset < curr)\n\t\t\tcontinue;\n\n\t\t/* found the next entry */\n\t\tif (!dir_emit(ctx, dire->u.name, nlen,\n\t\t\t      ntohl(dire->u.vnode),\n\t\t\t      ctx->actor == afs_lookup_filldir ?\n\t\t\t      ntohl(dire->u.unique) : DT_UNKNOWN)) {\n\t\t\t_leave(\" = 0 [full]\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tctx->pos = blkoff + next * sizeof(union afs_dirent);\n\t}\n\n\t_leave(\" = 1 [more]\");\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "page"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_dir_get_page",
          "args": [
            "dir",
            "blkoff / PAGE_SIZE",
            "key"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "afs_dir_get_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/dir.c",
          "lines": "190-210",
          "snippet": "static struct page *afs_dir_get_page(struct inode *dir, unsigned long index,\n\t\t\t\t     struct key *key)\n{\n\tstruct page *page;\n\t_enter(\"{%lu},%lu\", dir->i_ino, index);\n\n\tpage = read_cache_page(dir->i_mapping, index, afs_page_filler, key);\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (!PageChecked(page))\n\t\t\tafs_dir_check_page(dir, page);\n\t\tif (PageError(page))\n\t\t\tgoto fail;\n\t}\n\treturn page;\n\nfail:\n\tafs_dir_put_page(page);\n\t_leave(\" = -EIO\");\n\treturn ERR_PTR(-EIO);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct page *afs_dir_get_page(struct inode *dir, unsigned long index,\n\t\t\t\t     struct key *key)\n{\n\tstruct page *page;\n\t_enter(\"{%lu},%lu\", dir->i_ino, index);\n\n\tpage = read_cache_page(dir->i_mapping, index, afs_page_filler, key);\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (!PageChecked(page))\n\t\t\tafs_dir_check_page(dir, page);\n\t\tif (PageError(page))\n\t\t\tgoto fail;\n\t}\n\treturn page;\n\nfail:\n\tafs_dir_put_page(page);\n\t_leave(\" = -EIO\");\n\treturn ERR_PTR(-EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = -ESTALE\""
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "AFS_VNODE_DELETED",
            "&AFS_FS_I(dir)->flags"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AFS_FS_I",
          "args": [
            "dir"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "AFS_FS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/internal.h",
          "lines": "687-690",
          "snippet": "static inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}",
          "includes": [
            "#include \"afs_vl.h\"",
            "#include \"afs.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/fscache.h>",
            "#include <linux/sched.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/key.h>",
            "#include <linux/rxrpc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void afs_discard_callback_on_delete(struct afs_vnode *);",
            "extern void afs_give_up_callback(struct afs_vnode *);",
            "extern void afs_lock_may_be_available(struct afs_vnode *);",
            "extern void afs_zap_data(struct afs_vnode *);",
            "extern void afs_evict_inode(struct inode *);",
            "extern int afs_drop_inode(struct inode *);",
            "extern void afs_clear_permits(struct afs_vnode *);",
            "extern int afs_permission(struct inode *, int);",
            "extern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);",
            "extern int afs_writeback_all(struct afs_vnode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_vl.h\"\n#include \"afs.h\"\n#include <linux/backing-dev.h>\n#include <linux/fscache.h>\n#include <linux/sched.h>\n#include <linux/workqueue.h>\n#include <linux/key.h>\n#include <linux/rxrpc.h>\n#include <linux/skbuff.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n\nextern void afs_discard_callback_on_delete(struct afs_vnode *);\nextern void afs_give_up_callback(struct afs_vnode *);\nextern void afs_lock_may_be_available(struct afs_vnode *);\nextern void afs_zap_data(struct afs_vnode *);\nextern void afs_evict_inode(struct inode *);\nextern int afs_drop_inode(struct inode *);\nextern void afs_clear_permits(struct afs_vnode *);\nextern int afs_permission(struct inode *, int);\nextern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);\nextern int afs_writeback_all(struct afs_vnode *);\n\nstatic inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%lu},%u,,\"",
            "dir->i_ino",
            "(unsigned)ctx->pos"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct dentry *afs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t unsigned int flags);\nstatic int afs_dir_open(struct inode *inode, struct file *file);\nstatic int afs_readdir(struct file *file, struct dir_context *ctx);\nstatic int afs_d_revalidate(struct dentry *dentry, unsigned int flags);\n\nstatic int afs_dir_iterate(struct inode *dir, struct dir_context *ctx,\n\t\t\t   struct key *key)\n{\n\tunion afs_dir_block *dblock;\n\tstruct afs_dir_page *dbuf;\n\tstruct page *page;\n\tunsigned blkoff, limit;\n\tint ret;\n\n\t_enter(\"{%lu},%u,,\", dir->i_ino, (unsigned)ctx->pos);\n\n\tif (test_bit(AFS_VNODE_DELETED, &AFS_FS_I(dir)->flags)) {\n\t\t_leave(\" = -ESTALE\");\n\t\treturn -ESTALE;\n\t}\n\n\t/* round the file position up to the next entry boundary */\n\tctx->pos += sizeof(union afs_dirent) - 1;\n\tctx->pos &= ~(sizeof(union afs_dirent) - 1);\n\n\t/* walk through the blocks in sequence */\n\tret = 0;\n\twhile (ctx->pos < dir->i_size) {\n\t\tblkoff = ctx->pos & ~(sizeof(union afs_dir_block) - 1);\n\n\t\t/* fetch the appropriate page from the directory */\n\t\tpage = afs_dir_get_page(dir, blkoff / PAGE_SIZE, key);\n\t\tif (IS_ERR(page)) {\n\t\t\tret = PTR_ERR(page);\n\t\t\tbreak;\n\t\t}\n\n\t\tlimit = blkoff & ~(PAGE_SIZE - 1);\n\n\t\tdbuf = page_address(page);\n\n\t\t/* deal with the individual blocks stashed on this page */\n\t\tdo {\n\t\t\tdblock = &dbuf->blocks[(blkoff % PAGE_SIZE) /\n\t\t\t\t\t       sizeof(union afs_dir_block)];\n\t\t\tret = afs_dir_iterate_block(ctx, dblock, blkoff);\n\t\t\tif (ret != 1) {\n\t\t\t\tafs_dir_put_page(page);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tblkoff += sizeof(union afs_dir_block);\n\n\t\t} while (ctx->pos < dir->i_size && blkoff < limit);\n\n\t\tafs_dir_put_page(page);\n\t\tret = 0;\n\t}\n\nout:\n\t_leave(\" = %d\", ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "afs_dir_iterate_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/dir.c",
    "lines": "231-316",
    "snippet": "static int afs_dir_iterate_block(struct dir_context *ctx,\n\t\t\t\t union afs_dir_block *block,\n\t\t\t\t unsigned blkoff)\n{\n\tunion afs_dirent *dire;\n\tunsigned offset, next, curr;\n\tsize_t nlen;\n\tint tmp;\n\n\t_enter(\"%u,%x,%p,,\",(unsigned)ctx->pos,blkoff,block);\n\n\tcurr = (ctx->pos - blkoff) / sizeof(union afs_dirent);\n\n\t/* walk through the block, an entry at a time */\n\tfor (offset = AFS_DIRENT_PER_BLOCK - block->pagehdr.nentries;\n\t     offset < AFS_DIRENT_PER_BLOCK;\n\t     offset = next\n\t     ) {\n\t\tnext = offset + 1;\n\n\t\t/* skip entries marked unused in the bitmap */\n\t\tif (!(block->pagehdr.bitmap[offset / 8] &\n\t\t      (1 << (offset % 8)))) {\n\t\t\t_debug(\"ENT[%Zu.%u]: unused\",\n\t\t\t       blkoff / sizeof(union afs_dir_block), offset);\n\t\t\tif (offset >= curr)\n\t\t\t\tctx->pos = blkoff +\n\t\t\t\t\tnext * sizeof(union afs_dirent);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* got a valid entry */\n\t\tdire = &block->dirents[offset];\n\t\tnlen = strnlen(dire->u.name,\n\t\t\t       sizeof(*block) -\n\t\t\t       offset * sizeof(union afs_dirent));\n\n\t\t_debug(\"ENT[%Zu.%u]: %s %Zu \\\"%s\\\"\",\n\t\t       blkoff / sizeof(union afs_dir_block), offset,\n\t\t       (offset < curr ? \"skip\" : \"fill\"),\n\t\t       nlen, dire->u.name);\n\n\t\t/* work out where the next possible entry is */\n\t\tfor (tmp = nlen; tmp > 15; tmp -= sizeof(union afs_dirent)) {\n\t\t\tif (next >= AFS_DIRENT_PER_BLOCK) {\n\t\t\t\t_debug(\"ENT[%Zu.%u]:\"\n\t\t\t\t       \" %u travelled beyond end dir block\"\n\t\t\t\t       \" (len %u/%Zu)\",\n\t\t\t\t       blkoff / sizeof(union afs_dir_block),\n\t\t\t\t       offset, next, tmp, nlen);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tif (!(block->pagehdr.bitmap[next / 8] &\n\t\t\t      (1 << (next % 8)))) {\n\t\t\t\t_debug(\"ENT[%Zu.%u]:\"\n\t\t\t\t       \" %u unmarked extension (len %u/%Zu)\",\n\t\t\t\t       blkoff / sizeof(union afs_dir_block),\n\t\t\t\t       offset, next, tmp, nlen);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\n\t\t\t_debug(\"ENT[%Zu.%u]: ext %u/%Zu\",\n\t\t\t       blkoff / sizeof(union afs_dir_block),\n\t\t\t       next, tmp, nlen);\n\t\t\tnext++;\n\t\t}\n\n\t\t/* skip if starts before the current position */\n\t\tif (offset < curr)\n\t\t\tcontinue;\n\n\t\t/* found the next entry */\n\t\tif (!dir_emit(ctx, dire->u.name, nlen,\n\t\t\t      ntohl(dire->u.vnode),\n\t\t\t      ctx->actor == afs_lookup_filldir ?\n\t\t\t      ntohl(dire->u.unique) : DT_UNKNOWN)) {\n\t\t\t_leave(\" = 0 [full]\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tctx->pos = blkoff + next * sizeof(union afs_dirent);\n\t}\n\n\t_leave(\" = 1 [more]\");\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define AFS_DIRENT_PER_BLOCK\t64"
    ],
    "globals_used": [
      "static int afs_readdir(struct file *file, struct dir_context *ctx);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = 1 [more]\""
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "ctx",
            "dire->u.name",
            "nlen",
            "ntohl(dire->u.vnode)",
            "ctx->actor == afs_lookup_filldir ?\n\t\t\t      ntohl(dire->u.unique) : DT_UNKNOWN"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "dire->u.unique"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "dire->u.vnode"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_debug",
          "args": [
            "\"ENT[%Zu.%u]: ext %u/%Zu\"",
            "blkoff / sizeof(union afs_dir_block)",
            "next",
            "tmp",
            "nlen"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "befs_debug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/befs/debug.c",
          "lines": "53-67",
          "snippet": "void\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}",
          "includes": [
            "#include \"befs.h\"",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"befs.h\"\n#include <linux/slab.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <stdarg.h>\n\nvoid\nbefs_debug(const struct super_block *sb, const char *fmt, ...)\n{\n#ifdef CONFIG_BEFS_DEBUG\n\n\tstruct va_format vaf;\n\tva_list args;\n\tva_start(args, fmt);\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\tpr_debug(\"(%s): %pV\\n\", sb->s_id, &vaf);\n\tva_end(args);\n\n#endif\t\t\t\t//CONFIG_BEFS_DEBUG\n}"
        }
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "dire->u.name",
            "sizeof(*block) -\n\t\t\t       offset * sizeof(union afs_dirent)"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"%u,%x,%p,,\"",
            "(unsigned)ctx->pos",
            "blkoff",
            "block"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\n#define AFS_DIRENT_PER_BLOCK\t64\n\nstatic int afs_readdir(struct file *file, struct dir_context *ctx);\n\nstatic int afs_dir_iterate_block(struct dir_context *ctx,\n\t\t\t\t union afs_dir_block *block,\n\t\t\t\t unsigned blkoff)\n{\n\tunion afs_dirent *dire;\n\tunsigned offset, next, curr;\n\tsize_t nlen;\n\tint tmp;\n\n\t_enter(\"%u,%x,%p,,\",(unsigned)ctx->pos,blkoff,block);\n\n\tcurr = (ctx->pos - blkoff) / sizeof(union afs_dirent);\n\n\t/* walk through the block, an entry at a time */\n\tfor (offset = AFS_DIRENT_PER_BLOCK - block->pagehdr.nentries;\n\t     offset < AFS_DIRENT_PER_BLOCK;\n\t     offset = next\n\t     ) {\n\t\tnext = offset + 1;\n\n\t\t/* skip entries marked unused in the bitmap */\n\t\tif (!(block->pagehdr.bitmap[offset / 8] &\n\t\t      (1 << (offset % 8)))) {\n\t\t\t_debug(\"ENT[%Zu.%u]: unused\",\n\t\t\t       blkoff / sizeof(union afs_dir_block), offset);\n\t\t\tif (offset >= curr)\n\t\t\t\tctx->pos = blkoff +\n\t\t\t\t\tnext * sizeof(union afs_dirent);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* got a valid entry */\n\t\tdire = &block->dirents[offset];\n\t\tnlen = strnlen(dire->u.name,\n\t\t\t       sizeof(*block) -\n\t\t\t       offset * sizeof(union afs_dirent));\n\n\t\t_debug(\"ENT[%Zu.%u]: %s %Zu \\\"%s\\\"\",\n\t\t       blkoff / sizeof(union afs_dir_block), offset,\n\t\t       (offset < curr ? \"skip\" : \"fill\"),\n\t\t       nlen, dire->u.name);\n\n\t\t/* work out where the next possible entry is */\n\t\tfor (tmp = nlen; tmp > 15; tmp -= sizeof(union afs_dirent)) {\n\t\t\tif (next >= AFS_DIRENT_PER_BLOCK) {\n\t\t\t\t_debug(\"ENT[%Zu.%u]:\"\n\t\t\t\t       \" %u travelled beyond end dir block\"\n\t\t\t\t       \" (len %u/%Zu)\",\n\t\t\t\t       blkoff / sizeof(union afs_dir_block),\n\t\t\t\t       offset, next, tmp, nlen);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tif (!(block->pagehdr.bitmap[next / 8] &\n\t\t\t      (1 << (next % 8)))) {\n\t\t\t\t_debug(\"ENT[%Zu.%u]:\"\n\t\t\t\t       \" %u unmarked extension (len %u/%Zu)\",\n\t\t\t\t       blkoff / sizeof(union afs_dir_block),\n\t\t\t\t       offset, next, tmp, nlen);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\n\t\t\t_debug(\"ENT[%Zu.%u]: ext %u/%Zu\",\n\t\t\t       blkoff / sizeof(union afs_dir_block),\n\t\t\t       next, tmp, nlen);\n\t\t\tnext++;\n\t\t}\n\n\t\t/* skip if starts before the current position */\n\t\tif (offset < curr)\n\t\t\tcontinue;\n\n\t\t/* found the next entry */\n\t\tif (!dir_emit(ctx, dire->u.name, nlen,\n\t\t\t      ntohl(dire->u.vnode),\n\t\t\t      ctx->actor == afs_lookup_filldir ?\n\t\t\t      ntohl(dire->u.unique) : DT_UNKNOWN)) {\n\t\t\t_leave(\" = 0 [full]\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tctx->pos = blkoff + next * sizeof(union afs_dirent);\n\t}\n\n\t_leave(\" = 1 [more]\");\n\treturn 1;\n}"
  },
  {
    "function_name": "afs_dir_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/dir.c",
    "lines": "215-226",
    "snippet": "static int afs_dir_open(struct inode *inode, struct file *file)\n{\n\t_enter(\"{%lu}\", inode->i_ino);\n\n\tBUILD_BUG_ON(sizeof(union afs_dir_block) != 2048);\n\tBUILD_BUG_ON(sizeof(union afs_dirent) != 32);\n\n\tif (test_bit(AFS_VNODE_DELETED, &AFS_FS_I(inode)->flags))\n\t\treturn -ENOENT;\n\n\treturn afs_open(inode, file);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dentry *afs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t unsigned int flags);",
      "static int afs_dir_open(struct inode *inode, struct file *file);",
      "static int afs_d_revalidate(struct dentry *dentry, unsigned int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "afs_open",
          "args": [
            "inode",
            "file"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "afs_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/file.c",
          "lines": "67-90",
          "snippet": "int afs_open(struct inode *inode, struct file *file)\n{\n\tstruct afs_vnode *vnode = AFS_FS_I(inode);\n\tstruct key *key;\n\tint ret;\n\n\t_enter(\"{%x:%u},\", vnode->fid.vid, vnode->fid.vnode);\n\n\tkey = afs_request_key(vnode->volume->cell);\n\tif (IS_ERR(key)) {\n\t\t_leave(\" = %ld [key]\", PTR_ERR(key));\n\t\treturn PTR_ERR(key);\n\t}\n\n\tret = afs_validate(vnode, key);\n\tif (ret < 0) {\n\t\t_leave(\" = %d [val]\", ret);\n\t\treturn ret;\n\t}\n\n\tfile->private_data = key;\n\t_leave(\" = 0\");\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/gfp.h>",
            "#include <linux/writeback.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/gfp.h>\n#include <linux/writeback.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nint afs_open(struct inode *inode, struct file *file)\n{\n\tstruct afs_vnode *vnode = AFS_FS_I(inode);\n\tstruct key *key;\n\tint ret;\n\n\t_enter(\"{%x:%u},\", vnode->fid.vid, vnode->fid.vnode);\n\n\tkey = afs_request_key(vnode->volume->cell);\n\tif (IS_ERR(key)) {\n\t\t_leave(\" = %ld [key]\", PTR_ERR(key));\n\t\treturn PTR_ERR(key);\n\t}\n\n\tret = afs_validate(vnode, key);\n\tif (ret < 0) {\n\t\t_leave(\" = %d [val]\", ret);\n\t\treturn ret;\n\t}\n\n\tfile->private_data = key;\n\t_leave(\" = 0\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "AFS_VNODE_DELETED",
            "&AFS_FS_I(inode)->flags"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_test_bit_unaligned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "898-902",
          "snippet": "static inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [
            "#define ocfs2_test_bit test_bit_le"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\n#define ocfs2_test_bit test_bit_le\n\nstatic inline int ocfs2_test_bit_unaligned(int bit, void *bitmap)\n{\n\tbitmap = correct_addr_and_bit_unaligned(&bit, bitmap);\n\treturn ocfs2_test_bit(bit, bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AFS_FS_I",
          "args": [
            "inode"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "AFS_FS_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/internal.h",
          "lines": "687-690",
          "snippet": "static inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}",
          "includes": [
            "#include \"afs_vl.h\"",
            "#include \"afs.h\"",
            "#include <linux/backing-dev.h>",
            "#include <linux/fscache.h>",
            "#include <linux/sched.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/key.h>",
            "#include <linux/rxrpc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/compiler.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void afs_discard_callback_on_delete(struct afs_vnode *);",
            "extern void afs_give_up_callback(struct afs_vnode *);",
            "extern void afs_lock_may_be_available(struct afs_vnode *);",
            "extern void afs_zap_data(struct afs_vnode *);",
            "extern void afs_evict_inode(struct inode *);",
            "extern int afs_drop_inode(struct inode *);",
            "extern void afs_clear_permits(struct afs_vnode *);",
            "extern int afs_permission(struct inode *, int);",
            "extern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);",
            "extern int afs_writeback_all(struct afs_vnode *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"afs_vl.h\"\n#include \"afs.h\"\n#include <linux/backing-dev.h>\n#include <linux/fscache.h>\n#include <linux/sched.h>\n#include <linux/workqueue.h>\n#include <linux/key.h>\n#include <linux/rxrpc.h>\n#include <linux/skbuff.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/compiler.h>\n\nextern void afs_discard_callback_on_delete(struct afs_vnode *);\nextern void afs_give_up_callback(struct afs_vnode *);\nextern void afs_lock_may_be_available(struct afs_vnode *);\nextern void afs_zap_data(struct afs_vnode *);\nextern void afs_evict_inode(struct inode *);\nextern int afs_drop_inode(struct inode *);\nextern void afs_clear_permits(struct afs_vnode *);\nextern int afs_permission(struct inode *, int);\nextern struct afs_server *afs_volume_pick_fileserver(struct afs_vnode *);\nextern int afs_writeback_all(struct afs_vnode *);\n\nstatic inline struct afs_vnode *AFS_FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct afs_vnode, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "sizeof(union afs_dirent) != 32"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "sizeof(union afs_dir_block) != 2048"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%lu}\"",
            "inode->i_ino"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "coda_cache_enter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/coda/cache.c",
          "lines": "30-42",
          "snippet": "void coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}",
          "includes": [
            "#include \"coda_cache.h\"",
            "#include \"coda_linux.h\"",
            "#include <linux/coda_psdev.h>",
            "#include <linux/coda.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/sched.h>",
            "#include <linux/list.h>",
            "#include <linux/string.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/errno.h>",
            "#include <linux/stat.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t permission_epoch = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"coda_cache.h\"\n#include \"coda_linux.h\"\n#include <linux/coda_psdev.h>\n#include <linux/coda.h>\n#include <linux/spinlock.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/string.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/stat.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic atomic_t permission_epoch = ATOMIC_INIT(0);\n\nvoid coda_cache_enter(struct inode *inode, int mask)\n{\n\tstruct coda_inode_info *cii = ITOC(inode);\n\n\tspin_lock(&cii->c_lock);\n\tcii->c_cached_epoch = atomic_read(&permission_epoch);\n\tif (!uid_eq(cii->c_uid, current_fsuid())) {\n\t\tcii->c_uid = current_fsuid();\n                cii->c_cached_perm = mask;\n        } else\n                cii->c_cached_perm |= mask;\n\tspin_unlock(&cii->c_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct dentry *afs_lookup(struct inode *dir, struct dentry *dentry,\n\t\t\t\t unsigned int flags);\nstatic int afs_dir_open(struct inode *inode, struct file *file);\nstatic int afs_d_revalidate(struct dentry *dentry, unsigned int flags);\n\nstatic int afs_dir_open(struct inode *inode, struct file *file)\n{\n\t_enter(\"{%lu}\", inode->i_ino);\n\n\tBUILD_BUG_ON(sizeof(union afs_dir_block) != 2048);\n\tBUILD_BUG_ON(sizeof(union afs_dirent) != 32);\n\n\tif (test_bit(AFS_VNODE_DELETED, &AFS_FS_I(inode)->flags))\n\t\treturn -ENOENT;\n\n\treturn afs_open(inode, file);\n}"
  },
  {
    "function_name": "afs_dir_get_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/dir.c",
    "lines": "190-210",
    "snippet": "static struct page *afs_dir_get_page(struct inode *dir, unsigned long index,\n\t\t\t\t     struct key *key)\n{\n\tstruct page *page;\n\t_enter(\"{%lu},%lu\", dir->i_ino, index);\n\n\tpage = read_cache_page(dir->i_mapping, index, afs_page_filler, key);\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (!PageChecked(page))\n\t\t\tafs_dir_check_page(dir, page);\n\t\tif (PageError(page))\n\t\t\tgoto fail;\n\t}\n\treturn page;\n\nfail:\n\tafs_dir_put_page(page);\n\t_leave(\" = -EIO\");\n\treturn ERR_PTR(-EIO);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_leave",
          "args": [
            "\" = -EIO\""
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_leave_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/stackglue.c",
          "lines": "426-449",
          "snippet": "static void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}",
          "includes": [
            "#include \"stackglue.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include <linux/sysctl.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/kobject.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"stackglue.h\"\n#include \"ocfs2_fs.h\"\n#include <linux/sysctl.h>\n#include <linux/sysfs.h>\n#include <linux/kobject.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/list.h>\n\nstatic char ocfs2_hb_ctl_path[OCFS2_MAX_HB_CTL_PATH] = \"/sbin/ocfs2_hb_ctl\";\n\nstatic void ocfs2_leave_group(const char *group)\n{\n\tint ret;\n\tchar *argv[5], *envp[3];\n\n\targv[0] = ocfs2_hb_ctl_path;\n\targv[1] = \"-K\";\n\targv[2] = \"-u\";\n\targv[3] = (char *)group;\n\targv[4] = NULL;\n\n\t/* minimal command environment taken from cpu_run_sbin_hotplug */\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\n\tret = call_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\tif (ret < 0) {\n\t\tprintk(KERN_ERR\n\t\t       \"ocfs2: Error %d running user helper \"\n\t\t       \"\\\"%s %s %s %s\\\"\\n\",\n\t\t       ret, argv[0], argv[1], argv[2], argv[3]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "afs_dir_put_page",
          "args": [
            "page"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "afs_dir_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/dir.c",
          "lines": "181-185",
          "snippet": "static inline void afs_dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic inline void afs_dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageError",
          "args": [
            "page"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "afs_dir_check_page",
          "args": [
            "dir",
            "page"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "afs_dir_check_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/dir.c",
          "lines": "131-176",
          "snippet": "static inline void afs_dir_check_page(struct inode *dir, struct page *page)\n{\n\tstruct afs_dir_page *dbuf;\n\tloff_t latter;\n\tint tmp, qty;\n\n#if 0\n\t/* check the page count */\n\tqty = desc.size / sizeof(dbuf->blocks[0]);\n\tif (qty == 0)\n\t\tgoto error;\n\n\tif (page->index == 0 && qty != ntohs(dbuf->blocks[0].pagehdr.npages)) {\n\t\tprintk(\"kAFS: %s(%lu): wrong number of dir blocks %d!=%hu\\n\",\n\t\t       __func__, dir->i_ino, qty,\n\t\t       ntohs(dbuf->blocks[0].pagehdr.npages));\n\t\tgoto error;\n\t}\n#endif\n\n\t/* determine how many magic numbers there should be in this page */\n\tlatter = dir->i_size - page_offset(page);\n\tif (latter >= PAGE_SIZE)\n\t\tqty = PAGE_SIZE;\n\telse\n\t\tqty = latter;\n\tqty /= sizeof(union afs_dir_block);\n\n\t/* check them */\n\tdbuf = page_address(page);\n\tfor (tmp = 0; tmp < qty; tmp++) {\n\t\tif (dbuf->blocks[tmp].pagehdr.magic != AFS_DIR_MAGIC) {\n\t\t\tprintk(\"kAFS: %s(%lu): bad magic %d/%d is %04hx\\n\",\n\t\t\t       __func__, dir->i_ino, tmp, qty,\n\t\t\t       ntohs(dbuf->blocks[tmp].pagehdr.magic));\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tSetPageChecked(page);\n\treturn;\n\nerror:\n\tSetPageChecked(page);\n\tSetPageError(page);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/sched.h>",
            "#include <linux/ctype.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define AFS_DIR_MAGIC htons(1234)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\n#define AFS_DIR_MAGIC htons(1234)\n\nstatic inline void afs_dir_check_page(struct inode *dir, struct page *page)\n{\n\tstruct afs_dir_page *dbuf;\n\tloff_t latter;\n\tint tmp, qty;\n\n#if 0\n\t/* check the page count */\n\tqty = desc.size / sizeof(dbuf->blocks[0]);\n\tif (qty == 0)\n\t\tgoto error;\n\n\tif (page->index == 0 && qty != ntohs(dbuf->blocks[0].pagehdr.npages)) {\n\t\tprintk(\"kAFS: %s(%lu): wrong number of dir blocks %d!=%hu\\n\",\n\t\t       __func__, dir->i_ino, qty,\n\t\t       ntohs(dbuf->blocks[0].pagehdr.npages));\n\t\tgoto error;\n\t}\n#endif\n\n\t/* determine how many magic numbers there should be in this page */\n\tlatter = dir->i_size - page_offset(page);\n\tif (latter >= PAGE_SIZE)\n\t\tqty = PAGE_SIZE;\n\telse\n\t\tqty = latter;\n\tqty /= sizeof(union afs_dir_block);\n\n\t/* check them */\n\tdbuf = page_address(page);\n\tfor (tmp = 0; tmp < qty; tmp++) {\n\t\tif (dbuf->blocks[tmp].pagehdr.magic != AFS_DIR_MAGIC) {\n\t\t\tprintk(\"kAFS: %s(%lu): bad magic %d/%d is %04hx\\n\",\n\t\t\t       __func__, dir->i_ino, tmp, qty,\n\t\t\t       ntohs(dbuf->blocks[tmp].pagehdr.magic));\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tSetPageChecked(page);\n\treturn;\n\nerror:\n\tSetPageChecked(page);\n\tSetPageError(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageChecked",
          "args": [
            "page"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "page"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_cache_page",
          "args": [
            "dir->i_mapping",
            "index",
            "afs_page_filler",
            "key"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_enter",
          "args": [
            "\"{%lu},%lu\"",
            "dir->i_ino",
            "index"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct page *afs_dir_get_page(struct inode *dir, unsigned long index,\n\t\t\t\t     struct key *key)\n{\n\tstruct page *page;\n\t_enter(\"{%lu},%lu\", dir->i_ino, index);\n\n\tpage = read_cache_page(dir->i_mapping, index, afs_page_filler, key);\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (!PageChecked(page))\n\t\t\tafs_dir_check_page(dir, page);\n\t\tif (PageError(page))\n\t\t\tgoto fail;\n\t}\n\treturn page;\n\nfail:\n\tafs_dir_put_page(page);\n\t_leave(\" = -EIO\");\n\treturn ERR_PTR(-EIO);\n}"
  },
  {
    "function_name": "afs_dir_put_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/dir.c",
    "lines": "181-185",
    "snippet": "static inline void afs_dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic inline void afs_dir_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
  },
  {
    "function_name": "afs_dir_check_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/afs/dir.c",
    "lines": "131-176",
    "snippet": "static inline void afs_dir_check_page(struct inode *dir, struct page *page)\n{\n\tstruct afs_dir_page *dbuf;\n\tloff_t latter;\n\tint tmp, qty;\n\n#if 0\n\t/* check the page count */\n\tqty = desc.size / sizeof(dbuf->blocks[0]);\n\tif (qty == 0)\n\t\tgoto error;\n\n\tif (page->index == 0 && qty != ntohs(dbuf->blocks[0].pagehdr.npages)) {\n\t\tprintk(\"kAFS: %s(%lu): wrong number of dir blocks %d!=%hu\\n\",\n\t\t       __func__, dir->i_ino, qty,\n\t\t       ntohs(dbuf->blocks[0].pagehdr.npages));\n\t\tgoto error;\n\t}\n#endif\n\n\t/* determine how many magic numbers there should be in this page */\n\tlatter = dir->i_size - page_offset(page);\n\tif (latter >= PAGE_SIZE)\n\t\tqty = PAGE_SIZE;\n\telse\n\t\tqty = latter;\n\tqty /= sizeof(union afs_dir_block);\n\n\t/* check them */\n\tdbuf = page_address(page);\n\tfor (tmp = 0; tmp < qty; tmp++) {\n\t\tif (dbuf->blocks[tmp].pagehdr.magic != AFS_DIR_MAGIC) {\n\t\t\tprintk(\"kAFS: %s(%lu): bad magic %d/%d is %04hx\\n\",\n\t\t\t       __func__, dir->i_ino, tmp, qty,\n\t\t\t       ntohs(dbuf->blocks[tmp].pagehdr.magic));\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tSetPageChecked(page);\n\treturn;\n\nerror:\n\tSetPageChecked(page);\n\tSetPageError(page);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/sched.h>",
      "#include <linux/ctype.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define AFS_DIR_MAGIC htons(1234)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "page"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageChecked",
          "args": [
            "page"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageChecked",
          "args": [
            "page"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "\"kAFS: %s(%lu): bad magic %d/%d is %04hx\\n\"",
            "__func__",
            "dir->i_ino",
            "tmp",
            "qty",
            "ntohs(dbuf->blocks[tmp].pagehdr.magic)"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "compat_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/compat.c",
          "lines": "59-69",
          "snippet": "int compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/ioctls.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/aio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/mm.h>",
            "#include <linux/poll.h>",
            "#include <linux/signal.h>",
            "#include <linux/highmem.h>",
            "#include <linux/security.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/personality.h>",
            "#include <linux/highuid.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/dirent.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nfs4_mount.h>",
            "#include <linux/ncp_mount.h>",
            "#include <linux/init.h>",
            "#include <linux/ioctl.h>",
            "#include <linux/vfs.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/namei.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/fs.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int compat_log = 1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/ioctls.h>\n#include <asm/mmu_context.h>\n#include <asm/uaccess.h>\n#include <linux/aio.h>\n#include <linux/pagemap.h>\n#include <linux/slab.h>\n#include <linux/fs_struct.h>\n#include <linux/mm.h>\n#include <linux/poll.h>\n#include <linux/signal.h>\n#include <linux/highmem.h>\n#include <linux/security.h>\n#include <linux/tsacct_kern.h>\n#include <linux/rwsem.h>\n#include <linux/personality.h>\n#include <linux/highuid.h>\n#include <linux/fsnotify.h>\n#include <linux/dirent.h>\n#include <linux/ctype.h>\n#include <linux/syscalls.h>\n#include <linux/nfs4_mount.h>\n#include <linux/ncp_mount.h>\n#include <linux/init.h>\n#include <linux/ioctl.h>\n#include <linux/vfs.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/namei.h>\n#include <linux/fcntl.h>\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n\nint compat_log = 1;\n\nint compat_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tint ret;\n\tif (!compat_log)\n\t\treturn 0;\n\tva_start(ap, fmt);\n\tret = vprintk(fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "dbuf->blocks[tmp].pagehdr.magic"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "page"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "dbuf->blocks[0].pagehdr.npages"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "dbuf->blocks[0].pagehdr.npages"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/sched.h>\n#include <linux/ctype.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\n#define AFS_DIR_MAGIC htons(1234)\n\nstatic inline void afs_dir_check_page(struct inode *dir, struct page *page)\n{\n\tstruct afs_dir_page *dbuf;\n\tloff_t latter;\n\tint tmp, qty;\n\n#if 0\n\t/* check the page count */\n\tqty = desc.size / sizeof(dbuf->blocks[0]);\n\tif (qty == 0)\n\t\tgoto error;\n\n\tif (page->index == 0 && qty != ntohs(dbuf->blocks[0].pagehdr.npages)) {\n\t\tprintk(\"kAFS: %s(%lu): wrong number of dir blocks %d!=%hu\\n\",\n\t\t       __func__, dir->i_ino, qty,\n\t\t       ntohs(dbuf->blocks[0].pagehdr.npages));\n\t\tgoto error;\n\t}\n#endif\n\n\t/* determine how many magic numbers there should be in this page */\n\tlatter = dir->i_size - page_offset(page);\n\tif (latter >= PAGE_SIZE)\n\t\tqty = PAGE_SIZE;\n\telse\n\t\tqty = latter;\n\tqty /= sizeof(union afs_dir_block);\n\n\t/* check them */\n\tdbuf = page_address(page);\n\tfor (tmp = 0; tmp < qty; tmp++) {\n\t\tif (dbuf->blocks[tmp].pagehdr.magic != AFS_DIR_MAGIC) {\n\t\t\tprintk(\"kAFS: %s(%lu): bad magic %d/%d is %04hx\\n\",\n\t\t\t       __func__, dir->i_ino, tmp, qty,\n\t\t\t       ntohs(dbuf->blocks[tmp].pagehdr.magic));\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tSetPageChecked(page);\n\treturn;\n\nerror:\n\tSetPageChecked(page);\n\tSetPageError(page);\n}"
  }
]