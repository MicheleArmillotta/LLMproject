[
  {
    "function_name": "user_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr_user.c",
    "lines": "33-45",
    "snippet": "static size_t user_list(struct dentry *dentry, char *list, size_t list_size,\n\t\t\tconst char *name, size_t name_len, int handler_flags)\n{\n\tconst size_t len = name_len + 1;\n\n\tif (!reiserfs_xattrs_user(dentry->d_sb))\n\t\treturn 0;\n\tif (list && len <= list_size) {\n\t\tmemcpy(list, name, name_len);\n\t\tlist[name_len] = '\\0';\n\t}\n\treturn len;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include \"xattr.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include \"reiserfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "list",
            "name",
            "name_len"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reiserfs_xattrs_user",
          "args": [
            "dentry->d_sb"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n\nstatic size_t user_list(struct dentry *dentry, char *list, size_t list_size,\n\t\t\tconst char *name, size_t name_len, int handler_flags)\n{\n\tconst size_t len = name_len + 1;\n\n\tif (!reiserfs_xattrs_user(dentry->d_sb))\n\t\treturn 0;\n\tif (list && len <= list_size) {\n\t\tmemcpy(list, name, name_len);\n\t\tlist[name_len] = '\\0';\n\t}\n\treturn len;\n}"
  },
  {
    "function_name": "user_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr_user.c",
    "lines": "21-31",
    "snippet": "static int\nuser_set(struct dentry *dentry, const char *name, const void *buffer,\n\t size_t size, int flags, int handler_flags)\n{\n\tif (strlen(name) < sizeof(XATTR_USER_PREFIX))\n\t\treturn -EINVAL;\n\n\tif (!reiserfs_xattrs_user(dentry->d_sb))\n\t\treturn -EOPNOTSUPP;\n\treturn reiserfs_xattr_set(dentry->d_inode, name, buffer, size, flags);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include \"xattr.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include \"reiserfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_xattr_set",
          "args": [
            "dentry->d_inode",
            "name",
            "buffer",
            "size",
            "flags"
          ],
          "line": 30
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_xattr_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
          "lines": "597-625",
          "snippet": "int reiserfs_xattr_set(struct inode *inode, const char *name,\n\t\t       const void *buffer, size_t buffer_size, int flags)\n{\n\n\tstruct reiserfs_transaction_handle th;\n\tint error, error2;\n\tsize_t jbegin_count = reiserfs_xattr_nblocks(inode, buffer_size);\n\n\tif (!(flags & XATTR_REPLACE))\n\t\tjbegin_count += reiserfs_xattr_jcreate_nblocks(inode);\n\n\treiserfs_write_lock(inode->i_sb);\n\terror = journal_begin(&th, inode->i_sb, jbegin_count);\n\treiserfs_write_unlock(inode->i_sb);\n\tif (error) {\n\t\treturn error;\n\t}\n\n\terror = reiserfs_xattr_set_handle(&th, inode, name,\n\t\t\t\t\t  buffer, buffer_size, flags);\n\n\treiserfs_write_lock(inode->i_sb);\n\terror2 = journal_end(&th);\n\treiserfs_write_unlock(inode->i_sb);\n\tif (error == 0)\n\t\terror = error2;\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/stat.h>",
            "#include <net/checksum.h>",
            "#include <linux/uaccess.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nint reiserfs_xattr_set(struct inode *inode, const char *name,\n\t\t       const void *buffer, size_t buffer_size, int flags)\n{\n\n\tstruct reiserfs_transaction_handle th;\n\tint error, error2;\n\tsize_t jbegin_count = reiserfs_xattr_nblocks(inode, buffer_size);\n\n\tif (!(flags & XATTR_REPLACE))\n\t\tjbegin_count += reiserfs_xattr_jcreate_nblocks(inode);\n\n\treiserfs_write_lock(inode->i_sb);\n\terror = journal_begin(&th, inode->i_sb, jbegin_count);\n\treiserfs_write_unlock(inode->i_sb);\n\tif (error) {\n\t\treturn error;\n\t}\n\n\terror = reiserfs_xattr_set_handle(&th, inode, name,\n\t\t\t\t\t  buffer, buffer_size, flags);\n\n\treiserfs_write_lock(inode->i_sb);\n\terror2 = journal_end(&th);\n\treiserfs_write_unlock(inode->i_sb);\n\tif (error == 0)\n\t\terror = error2;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_xattrs_user",
          "args": [
            "dentry->d_sb"
          ],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 25
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n\nstatic int\nuser_set(struct dentry *dentry, const char *name, const void *buffer,\n\t size_t size, int flags, int handler_flags)\n{\n\tif (strlen(name) < sizeof(XATTR_USER_PREFIX))\n\t\treturn -EINVAL;\n\n\tif (!reiserfs_xattrs_user(dentry->d_sb))\n\t\treturn -EOPNOTSUPP;\n\treturn reiserfs_xattr_set(dentry->d_inode, name, buffer, size, flags);\n}"
  },
  {
    "function_name": "user_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr_user.c",
    "lines": "9-19",
    "snippet": "static int\nuser_get(struct dentry *dentry, const char *name, void *buffer, size_t size,\n\t int handler_flags)\n{\n\n\tif (strlen(name) < sizeof(XATTR_USER_PREFIX))\n\t\treturn -EINVAL;\n\tif (!reiserfs_xattrs_user(dentry->d_sb))\n\t\treturn -EOPNOTSUPP;\n\treturn reiserfs_xattr_get(dentry->d_inode, name, buffer, size);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include \"xattr.h\"",
      "#include <linux/xattr.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/fs.h>",
      "#include <linux/errno.h>",
      "#include \"reiserfs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reiserfs_xattr_get",
          "args": [
            "dentry->d_inode",
            "name",
            "buffer",
            "size"
          ],
          "line": 18
        },
        "resolved": true,
        "details": {
          "function_name": "reiserfs_xattr_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/reiserfs/xattr.c",
          "lines": "630-732",
          "snippet": "int\nreiserfs_xattr_get(struct inode *inode, const char *name, void *buffer,\n\t\t   size_t buffer_size)\n{\n\tssize_t err = 0;\n\tstruct dentry *dentry;\n\tsize_t isize;\n\tsize_t file_pos = 0;\n\tsize_t buffer_pos = 0;\n\tstruct page *page;\n\t__u32 hash = 0;\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\n\t/*\n\t * We can't have xattrs attached to v1 items since they don't have\n\t * generation numbers\n\t */\n\tif (get_inode_sd_version(inode) == STAT_DATA_V1)\n\t\treturn -EOPNOTSUPP;\n\n\tdentry = xattr_lookup(inode, name, XATTR_REPLACE);\n\tif (IS_ERR(dentry)) {\n\t\terr = PTR_ERR(dentry);\n\t\tgoto out;\n\t}\n\n\tdown_read(&REISERFS_I(inode)->i_xattr_sem);\n\n\tisize = i_size_read(dentry->d_inode);\n\n\t/* Just return the size needed */\n\tif (buffer == NULL) {\n\t\terr = isize - sizeof(struct reiserfs_xattr_header);\n\t\tgoto out_unlock;\n\t}\n\n\tif (buffer_size < isize - sizeof(struct reiserfs_xattr_header)) {\n\t\terr = -ERANGE;\n\t\tgoto out_unlock;\n\t}\n\n\twhile (file_pos < isize) {\n\t\tsize_t chunk;\n\t\tchar *data;\n\t\tsize_t skip = 0;\n\n\t\tif (isize - file_pos > PAGE_CACHE_SIZE)\n\t\t\tchunk = PAGE_CACHE_SIZE;\n\t\telse\n\t\t\tchunk = isize - file_pos;\n\n\t\tpage = reiserfs_get_page(dentry->d_inode, file_pos);\n\t\tif (IS_ERR(page)) {\n\t\t\terr = PTR_ERR(page);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tlock_page(page);\n\t\tdata = page_address(page);\n\t\tif (file_pos == 0) {\n\t\t\tstruct reiserfs_xattr_header *rxh =\n\t\t\t    (struct reiserfs_xattr_header *)data;\n\t\t\tskip = file_pos = sizeof(struct reiserfs_xattr_header);\n\t\t\tchunk -= skip;\n\t\t\t/* Magic doesn't match up.. */\n\t\t\tif (rxh->h_magic != cpu_to_le32(REISERFS_XATTR_MAGIC)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\treiserfs_put_page(page);\n\t\t\t\treiserfs_warning(inode->i_sb, \"jdm-20001\",\n\t\t\t\t\t\t \"Invalid magic for xattr (%s) \"\n\t\t\t\t\t\t \"associated with %k\", name,\n\t\t\t\t\t\t INODE_PKEY(inode));\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\thash = le32_to_cpu(rxh->h_hash);\n\t\t}\n\t\tmemcpy(buffer + buffer_pos, data + skip, chunk);\n\t\tunlock_page(page);\n\t\treiserfs_put_page(page);\n\t\tfile_pos += chunk;\n\t\tbuffer_pos += chunk;\n\t\tskip = 0;\n\t}\n\terr = isize - sizeof(struct reiserfs_xattr_header);\n\n\tif (xattr_hash(buffer, isize - sizeof(struct reiserfs_xattr_header)) !=\n\t    hash) {\n\t\treiserfs_warning(inode->i_sb, \"jdm-20002\",\n\t\t\t\t \"Invalid hash for xattr (%s) associated \"\n\t\t\t\t \"with %k\", name, INODE_PKEY(inode));\n\t\terr = -EIO;\n\t}\n\nout_unlock:\n\tup_read(&REISERFS_I(inode)->i_xattr_sem);\n\tdput(dentry);\n\nout:\n\treturn err;\n}",
          "includes": [
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/security.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/stat.h>",
            "#include <net/checksum.h>",
            "#include <linux/uaccess.h>",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include <linux/xattr.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/namei.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include \"reiserfs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl_xattr.h>\n#include <linux/security.h>\n#include <linux/quotaops.h>\n#include <linux/stat.h>\n#include <net/checksum.h>\n#include <linux/uaccess.h>\n#include \"acl.h\"\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/namei.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include \"reiserfs.h\"\n\nint\nreiserfs_xattr_get(struct inode *inode, const char *name, void *buffer,\n\t\t   size_t buffer_size)\n{\n\tssize_t err = 0;\n\tstruct dentry *dentry;\n\tsize_t isize;\n\tsize_t file_pos = 0;\n\tsize_t buffer_pos = 0;\n\tstruct page *page;\n\t__u32 hash = 0;\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\n\t/*\n\t * We can't have xattrs attached to v1 items since they don't have\n\t * generation numbers\n\t */\n\tif (get_inode_sd_version(inode) == STAT_DATA_V1)\n\t\treturn -EOPNOTSUPP;\n\n\tdentry = xattr_lookup(inode, name, XATTR_REPLACE);\n\tif (IS_ERR(dentry)) {\n\t\terr = PTR_ERR(dentry);\n\t\tgoto out;\n\t}\n\n\tdown_read(&REISERFS_I(inode)->i_xattr_sem);\n\n\tisize = i_size_read(dentry->d_inode);\n\n\t/* Just return the size needed */\n\tif (buffer == NULL) {\n\t\terr = isize - sizeof(struct reiserfs_xattr_header);\n\t\tgoto out_unlock;\n\t}\n\n\tif (buffer_size < isize - sizeof(struct reiserfs_xattr_header)) {\n\t\terr = -ERANGE;\n\t\tgoto out_unlock;\n\t}\n\n\twhile (file_pos < isize) {\n\t\tsize_t chunk;\n\t\tchar *data;\n\t\tsize_t skip = 0;\n\n\t\tif (isize - file_pos > PAGE_CACHE_SIZE)\n\t\t\tchunk = PAGE_CACHE_SIZE;\n\t\telse\n\t\t\tchunk = isize - file_pos;\n\n\t\tpage = reiserfs_get_page(dentry->d_inode, file_pos);\n\t\tif (IS_ERR(page)) {\n\t\t\terr = PTR_ERR(page);\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tlock_page(page);\n\t\tdata = page_address(page);\n\t\tif (file_pos == 0) {\n\t\t\tstruct reiserfs_xattr_header *rxh =\n\t\t\t    (struct reiserfs_xattr_header *)data;\n\t\t\tskip = file_pos = sizeof(struct reiserfs_xattr_header);\n\t\t\tchunk -= skip;\n\t\t\t/* Magic doesn't match up.. */\n\t\t\tif (rxh->h_magic != cpu_to_le32(REISERFS_XATTR_MAGIC)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\treiserfs_put_page(page);\n\t\t\t\treiserfs_warning(inode->i_sb, \"jdm-20001\",\n\t\t\t\t\t\t \"Invalid magic for xattr (%s) \"\n\t\t\t\t\t\t \"associated with %k\", name,\n\t\t\t\t\t\t INODE_PKEY(inode));\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\thash = le32_to_cpu(rxh->h_hash);\n\t\t}\n\t\tmemcpy(buffer + buffer_pos, data + skip, chunk);\n\t\tunlock_page(page);\n\t\treiserfs_put_page(page);\n\t\tfile_pos += chunk;\n\t\tbuffer_pos += chunk;\n\t\tskip = 0;\n\t}\n\terr = isize - sizeof(struct reiserfs_xattr_header);\n\n\tif (xattr_hash(buffer, isize - sizeof(struct reiserfs_xattr_header)) !=\n\t    hash) {\n\t\treiserfs_warning(inode->i_sb, \"jdm-20002\",\n\t\t\t\t \"Invalid hash for xattr (%s) associated \"\n\t\t\t\t \"with %k\", name, INODE_PKEY(inode));\n\t\terr = -EIO;\n\t}\n\nout_unlock:\n\tup_read(&REISERFS_I(inode)->i_xattr_sem);\n\tdput(dentry);\n\nout:\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "reiserfs_xattrs_user",
          "args": [
            "dentry->d_sb"
          ],
          "line": 16
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 14
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include \"xattr.h\"\n#include <linux/xattr.h>\n#include <linux/pagemap.h>\n#include <linux/fs.h>\n#include <linux/errno.h>\n#include \"reiserfs.h\"\n\nstatic int\nuser_get(struct dentry *dentry, const char *name, void *buffer, size_t size,\n\t int handler_flags)\n{\n\n\tif (strlen(name) < sizeof(XATTR_USER_PREFIX))\n\t\treturn -EINVAL;\n\tif (!reiserfs_xattrs_user(dentry->d_sb))\n\t\treturn -EOPNOTSUPP;\n\treturn reiserfs_xattr_get(dentry->d_inode, name, buffer, size);\n}"
  }
]