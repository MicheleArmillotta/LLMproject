[
  {
    "function_name": "exofs_empty_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
    "lines": "615-661",
    "snippet": "int exofs_empty_dir(struct inode *inode)\n{\n\tstruct page *page = NULL;\n\tunsigned long i, npages = dir_pages(inode);\n\n\tfor (i = 0; i < npages; i++) {\n\t\tchar *kaddr;\n\t\tstruct exofs_dir_entry *de;\n\t\tpage = exofs_get_page(inode, i);\n\n\t\tif (IS_ERR(page))\n\t\t\tcontinue;\n\n\t\tkaddr = page_address(page);\n\t\tde = (struct exofs_dir_entry *)kaddr;\n\t\tkaddr += exofs_last_byte(inode, i) - EXOFS_DIR_REC_LEN(1);\n\n\t\twhile ((char *)de <= kaddr) {\n\t\t\tif (de->rec_len == 0) {\n\t\t\t\tEXOFS_ERR(\"ERROR: exofs_empty_dir: \"\n\t\t\t\t\t  \"zero-length directory entry\"\n\t\t\t\t\t  \"kaddr=%p, de=%p\\n\", kaddr, de);\n\t\t\t\tgoto not_empty;\n\t\t\t}\n\t\t\tif (de->inode_no != 0) {\n\t\t\t\t/* check for . and .. */\n\t\t\t\tif (de->name[0] != '.')\n\t\t\t\t\tgoto not_empty;\n\t\t\t\tif (de->name_len > 2)\n\t\t\t\t\tgoto not_empty;\n\t\t\t\tif (de->name_len < 2) {\n\t\t\t\t\tif (le64_to_cpu(de->inode_no) !=\n\t\t\t\t\t    inode->i_ino)\n\t\t\t\t\t\tgoto not_empty;\n\t\t\t\t} else if (de->name[1] != '.')\n\t\t\t\t\tgoto not_empty;\n\t\t\t}\n\t\t\tde = exofs_next_entry(de);\n\t\t}\n\t\texofs_put_page(page);\n\t}\n\treturn 1;\n\nnot_empty:\n\texofs_put_page(page);\n\treturn 0;\n}",
    "includes": [
      "#include \"exofs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exofs_put_page",
          "args": [
            "page"
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
          "lines": "41-45",
          "snippet": "static inline void exofs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"exofs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n\nstatic inline void exofs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exofs_next_entry",
          "args": [
            "de"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_next_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
          "lines": "192-196",
          "snippet": "static inline\nstruct exofs_dir_entry *exofs_next_entry(struct exofs_dir_entry *p)\n{\n\treturn (struct exofs_dir_entry *)((char *)p + le16_to_cpu(p->rec_len));\n}",
          "includes": [
            "#include \"exofs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n\nstatic inline\nstruct exofs_dir_entry *exofs_next_entry(struct exofs_dir_entry *p)\n{\n\treturn (struct exofs_dir_entry *)((char *)p + le16_to_cpu(p->rec_len));\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "de->inode_no"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXOFS_ERR",
          "args": [
            "\"ERROR: exofs_empty_dir: \"\n\t\t\t\t\t  \"zero-length directory entry\"\n\t\t\t\t\t  \"kaddr=%p, de=%p\\n\"",
            "kaddr",
            "de"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXOFS_DIR_REC_LEN",
          "args": [
            "1"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exofs_last_byte",
          "args": [
            "inode",
            "i"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_last_byte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
          "lines": "53-61",
          "snippet": "static unsigned exofs_last_byte(struct inode *inode, unsigned long page_nr)\n{\n\tloff_t last_byte = inode->i_size;\n\n\tlast_byte -= page_nr << PAGE_CACHE_SHIFT;\n\tif (last_byte > PAGE_CACHE_SIZE)\n\t\tlast_byte = PAGE_CACHE_SIZE;\n\treturn last_byte;\n}",
          "includes": [
            "#include \"exofs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n\nstatic unsigned exofs_last_byte(struct inode *inode, unsigned long page_nr)\n{\n\tloff_t last_byte = inode->i_size;\n\n\tlast_byte -= page_nr << PAGE_CACHE_SHIFT;\n\tif (last_byte > PAGE_CACHE_SIZE)\n\t\tlast_byte = PAGE_CACHE_SIZE;\n\treturn last_byte;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exofs_get_page",
          "args": [
            "inode",
            "i"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_get_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
          "lines": "163-180",
          "snippet": "static struct page *exofs_get_page(struct inode *dir, unsigned long n)\n{\n\tstruct address_space *mapping = dir->i_mapping;\n\tstruct page *page = read_mapping_page(mapping, n, NULL);\n\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (!PageChecked(page))\n\t\t\texofs_check_page(page);\n\t\tif (PageError(page))\n\t\t\tgoto fail;\n\t}\n\treturn page;\n\nfail:\n\texofs_put_page(page);\n\treturn ERR_PTR(-EIO);\n}",
          "includes": [
            "#include \"exofs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n\nstatic struct page *exofs_get_page(struct inode *dir, unsigned long n)\n{\n\tstruct address_space *mapping = dir->i_mapping;\n\tstruct page *page = read_mapping_page(mapping, n, NULL);\n\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (!PageChecked(page))\n\t\t\texofs_check_page(page);\n\t\tif (PageError(page))\n\t\t\tgoto fail;\n\t}\n\treturn page;\n\nfail:\n\texofs_put_page(page);\n\treturn ERR_PTR(-EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_pages",
          "args": [
            "inode"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "dir_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
          "lines": "48-51",
          "snippet": "static inline unsigned long dir_pages(struct inode *inode)\n{\n\treturn (inode->i_size + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;\n}",
          "includes": [
            "#include \"exofs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n\nstatic inline unsigned long dir_pages(struct inode *inode)\n{\n\treturn (inode->i_size + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n\nint exofs_empty_dir(struct inode *inode)\n{\n\tstruct page *page = NULL;\n\tunsigned long i, npages = dir_pages(inode);\n\n\tfor (i = 0; i < npages; i++) {\n\t\tchar *kaddr;\n\t\tstruct exofs_dir_entry *de;\n\t\tpage = exofs_get_page(inode, i);\n\n\t\tif (IS_ERR(page))\n\t\t\tcontinue;\n\n\t\tkaddr = page_address(page);\n\t\tde = (struct exofs_dir_entry *)kaddr;\n\t\tkaddr += exofs_last_byte(inode, i) - EXOFS_DIR_REC_LEN(1);\n\n\t\twhile ((char *)de <= kaddr) {\n\t\t\tif (de->rec_len == 0) {\n\t\t\t\tEXOFS_ERR(\"ERROR: exofs_empty_dir: \"\n\t\t\t\t\t  \"zero-length directory entry\"\n\t\t\t\t\t  \"kaddr=%p, de=%p\\n\", kaddr, de);\n\t\t\t\tgoto not_empty;\n\t\t\t}\n\t\t\tif (de->inode_no != 0) {\n\t\t\t\t/* check for . and .. */\n\t\t\t\tif (de->name[0] != '.')\n\t\t\t\t\tgoto not_empty;\n\t\t\t\tif (de->name_len > 2)\n\t\t\t\t\tgoto not_empty;\n\t\t\t\tif (de->name_len < 2) {\n\t\t\t\t\tif (le64_to_cpu(de->inode_no) !=\n\t\t\t\t\t    inode->i_ino)\n\t\t\t\t\t\tgoto not_empty;\n\t\t\t\t} else if (de->name[1] != '.')\n\t\t\t\t\tgoto not_empty;\n\t\t\t}\n\t\t\tde = exofs_next_entry(de);\n\t\t}\n\t\texofs_put_page(page);\n\t}\n\treturn 1;\n\nnot_empty:\n\texofs_put_page(page);\n\treturn 0;\n}"
  },
  {
    "function_name": "exofs_make_empty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
    "lines": "575-613",
    "snippet": "int exofs_make_empty(struct inode *inode, struct inode *parent)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct page *page = grab_cache_page(mapping, 0);\n\tunsigned chunk_size = exofs_chunk_size(inode);\n\tstruct exofs_dir_entry *de;\n\tint err;\n\tvoid *kaddr;\n\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\terr = exofs_write_begin(NULL, page->mapping, 0, chunk_size, 0,\n\t\t\t\t\t\t\t&page, NULL);\n\tif (err) {\n\t\tunlock_page(page);\n\t\tgoto fail;\n\t}\n\n\tkaddr = kmap_atomic(page);\n\tde = (struct exofs_dir_entry *)kaddr;\n\tde->name_len = 1;\n\tde->rec_len = cpu_to_le16(EXOFS_DIR_REC_LEN(1));\n\tmemcpy(de->name, THIS_DIR, sizeof(THIS_DIR));\n\tde->inode_no = cpu_to_le64(inode->i_ino);\n\texofs_set_de_type(de, inode);\n\n\tde = (struct exofs_dir_entry *)(kaddr + EXOFS_DIR_REC_LEN(1));\n\tde->name_len = 2;\n\tde->rec_len = cpu_to_le16(chunk_size - EXOFS_DIR_REC_LEN(1));\n\tde->inode_no = cpu_to_le64(parent->i_ino);\n\tmemcpy(de->name, PARENT_DIR, sizeof(PARENT_DIR));\n\texofs_set_de_type(de, inode);\n\tkunmap_atomic(kaddr);\n\terr = exofs_commit_chunk(page, 0, chunk_size);\nfail:\n\tpage_cache_release(page);\n\treturn err;\n}",
    "includes": [
      "#include \"exofs.h\""
    ],
    "macros_used": [
      "#define PARENT_DIR \"..\\0\"",
      "#define THIS_DIR \".\\0\\0\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exofs_commit_chunk",
          "args": [
            "page",
            "0",
            "chunk_size"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_commit_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
          "lines": "63-86",
          "snippet": "static int exofs_commit_chunk(struct page *page, loff_t pos, unsigned len)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *dir = mapping->host;\n\tint err = 0;\n\n\tdir->i_version++;\n\n\tif (!PageUptodate(page))\n\t\tSetPageUptodate(page);\n\n\tif (pos+len > dir->i_size) {\n\t\ti_size_write(dir, pos+len);\n\t\tmark_inode_dirty(dir);\n\t}\n\tset_page_dirty(page);\n\n\tif (IS_DIRSYNC(dir))\n\t\terr = write_one_page(page, 1);\n\telse\n\t\tunlock_page(page);\n\n\treturn err;\n}",
          "includes": [
            "#include \"exofs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n\nstatic int exofs_commit_chunk(struct page *page, loff_t pos, unsigned len)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *dir = mapping->host;\n\tint err = 0;\n\n\tdir->i_version++;\n\n\tif (!PageUptodate(page))\n\t\tSetPageUptodate(page);\n\n\tif (pos+len > dir->i_size) {\n\t\ti_size_write(dir, pos+len);\n\t\tmark_inode_dirty(dir);\n\t}\n\tset_page_dirty(page);\n\n\tif (IS_DIRSYNC(dir))\n\t\terr = write_one_page(page, 1);\n\telse\n\t\tunlock_page(page);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exofs_set_de_type",
          "args": [
            "de",
            "inode"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_set_de_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
          "lines": "234-239",
          "snippet": "static inline\nvoid exofs_set_de_type(struct exofs_dir_entry *de, struct inode *inode)\n{\n\tumode_t mode = inode->i_mode;\n\tde->file_type = exofs_type_by_mode[(mode & S_IFMT) >> S_SHIFT];\n}",
          "includes": [
            "#include \"exofs.h\""
          ],
          "macros_used": [
            "#define S_SHIFT 12"
          ],
          "globals_used": [
            "static unsigned char exofs_type_by_mode[S_IFMT >> S_SHIFT] = {\n\t[S_IFREG >> S_SHIFT]\t= EXOFS_FT_REG_FILE,\n\t[S_IFDIR >> S_SHIFT]\t= EXOFS_FT_DIR,\n\t[S_IFCHR >> S_SHIFT]\t= EXOFS_FT_CHRDEV,\n\t[S_IFBLK >> S_SHIFT]\t= EXOFS_FT_BLKDEV,\n\t[S_IFIFO >> S_SHIFT]\t= EXOFS_FT_FIFO,\n\t[S_IFSOCK >> S_SHIFT]\t= EXOFS_FT_SOCK,\n\t[S_IFLNK >> S_SHIFT]\t= EXOFS_FT_SYMLINK,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n\n#define S_SHIFT 12\n\nstatic unsigned char exofs_type_by_mode[S_IFMT >> S_SHIFT] = {\n\t[S_IFREG >> S_SHIFT]\t= EXOFS_FT_REG_FILE,\n\t[S_IFDIR >> S_SHIFT]\t= EXOFS_FT_DIR,\n\t[S_IFCHR >> S_SHIFT]\t= EXOFS_FT_CHRDEV,\n\t[S_IFBLK >> S_SHIFT]\t= EXOFS_FT_BLKDEV,\n\t[S_IFIFO >> S_SHIFT]\t= EXOFS_FT_FIFO,\n\t[S_IFSOCK >> S_SHIFT]\t= EXOFS_FT_SOCK,\n\t[S_IFLNK >> S_SHIFT]\t= EXOFS_FT_SYMLINK,\n};\n\nstatic inline\nvoid exofs_set_de_type(struct exofs_dir_entry *de, struct inode *inode)\n{\n\tumode_t mode = inode->i_mode;\n\tde->file_type = exofs_type_by_mode[(mode & S_IFMT) >> S_SHIFT];\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "de->name",
            "PARENT_DIR",
            "sizeof(PARENT_DIR)"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "parent->i_ino"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "chunk_size - EXOFS_DIR_REC_LEN(1)"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXOFS_DIR_REC_LEN",
          "args": [
            "1"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXOFS_DIR_REC_LEN",
          "args": [
            "1"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "inode->i_ino"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "de->name",
            "THIS_DIR",
            "sizeof(THIS_DIR)"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "EXOFS_DIR_REC_LEN(1)"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXOFS_DIR_REC_LEN",
          "args": [
            "1"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exofs_write_begin",
          "args": [
            "NULL",
            "page->mapping",
            "0",
            "chunk_size",
            "0",
            "&page",
            "NULL"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_write_begin_export",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "919-928",
          "snippet": "static int exofs_write_begin_export(struct file *file,\n\t\tstruct address_space *mapping,\n\t\tloff_t pos, unsigned len, unsigned flags,\n\t\tstruct page **pagep, void **fsdata)\n{\n\t*pagep = NULL;\n\n\treturn exofs_write_begin(file, mapping, pos, len, flags, pagep,\n\t\t\t\t\tfsdata);\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic int exofs_write_begin_export(struct file *file,\n\t\tstruct address_space *mapping,\n\t\tloff_t pos, unsigned len, unsigned flags,\n\t\tstruct page **pagep, void **fsdata)\n{\n\t*pagep = NULL;\n\n\treturn exofs_write_begin(file, mapping, pos, len, flags, pagep,\n\t\t\t\t\tfsdata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exofs_chunk_size",
          "args": [
            "inode"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_chunk_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
          "lines": "36-39",
          "snippet": "static inline unsigned exofs_chunk_size(struct inode *inode)\n{\n\treturn inode->i_sb->s_blocksize;\n}",
          "includes": [
            "#include \"exofs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n\nstatic inline unsigned exofs_chunk_size(struct inode *inode)\n{\n\treturn inode->i_sb->s_blocksize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "grab_cache_page",
          "args": [
            "mapping",
            "0"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n\n#define PARENT_DIR \"..\\0\"\n#define THIS_DIR \".\\0\\0\"\n\nint exofs_make_empty(struct inode *inode, struct inode *parent)\n{\n\tstruct address_space *mapping = inode->i_mapping;\n\tstruct page *page = grab_cache_page(mapping, 0);\n\tunsigned chunk_size = exofs_chunk_size(inode);\n\tstruct exofs_dir_entry *de;\n\tint err;\n\tvoid *kaddr;\n\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\terr = exofs_write_begin(NULL, page->mapping, 0, chunk_size, 0,\n\t\t\t\t\t\t\t&page, NULL);\n\tif (err) {\n\t\tunlock_page(page);\n\t\tgoto fail;\n\t}\n\n\tkaddr = kmap_atomic(page);\n\tde = (struct exofs_dir_entry *)kaddr;\n\tde->name_len = 1;\n\tde->rec_len = cpu_to_le16(EXOFS_DIR_REC_LEN(1));\n\tmemcpy(de->name, THIS_DIR, sizeof(THIS_DIR));\n\tde->inode_no = cpu_to_le64(inode->i_ino);\n\texofs_set_de_type(de, inode);\n\n\tde = (struct exofs_dir_entry *)(kaddr + EXOFS_DIR_REC_LEN(1));\n\tde->name_len = 2;\n\tde->rec_len = cpu_to_le16(chunk_size - EXOFS_DIR_REC_LEN(1));\n\tde->inode_no = cpu_to_le64(parent->i_ino);\n\tmemcpy(de->name, PARENT_DIR, sizeof(PARENT_DIR));\n\texofs_set_de_type(de, inode);\n\tkunmap_atomic(kaddr);\n\terr = exofs_commit_chunk(page, 0, chunk_size);\nfail:\n\tpage_cache_release(page);\n\treturn err;\n}"
  },
  {
    "function_name": "exofs_delete_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
    "lines": "525-569",
    "snippet": "int exofs_delete_entry(struct exofs_dir_entry *dir, struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *inode = mapping->host;\n\tstruct exofs_sb_info *sbi = inode->i_sb->s_fs_info;\n\tchar *kaddr = page_address(page);\n\tunsigned from = ((char *)dir - kaddr) & ~(exofs_chunk_size(inode)-1);\n\tunsigned to = ((char *)dir - kaddr) + le16_to_cpu(dir->rec_len);\n\tloff_t pos;\n\tstruct exofs_dir_entry *pde = NULL;\n\tstruct exofs_dir_entry *de = (struct exofs_dir_entry *) (kaddr + from);\n\tint err;\n\n\twhile (de < dir) {\n\t\tif (de->rec_len == 0) {\n\t\t\tEXOFS_ERR(\"ERROR: exofs_delete_entry:\"\n\t\t\t\t  \"zero-length entry in directory(0x%lx)\\n\",\n\t\t\t\t  inode->i_ino);\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tpde = de;\n\t\tde = exofs_next_entry(de);\n\t}\n\tif (pde)\n\t\tfrom = (char *)pde - (char *)page_address(page);\n\tpos = page_offset(page) + from;\n\tlock_page(page);\n\terr = exofs_write_begin(NULL, page->mapping, pos, to - from, 0,\n\t\t\t\t\t\t\t&page, NULL);\n\tif (err)\n\t\tEXOFS_ERR(\"exofs_delete_entry: exofs_write_begin FAILED => %d\\n\",\n\t\t\t  err);\n\tif (pde)\n\t\tpde->rec_len = cpu_to_le16(to - from);\n\tdir->inode_no = 0;\n\tif (likely(!err))\n\t\terr = exofs_commit_chunk(page, pos, to - from);\n\tinode->i_ctime = inode->i_mtime = CURRENT_TIME;\n\tmark_inode_dirty(inode);\n\tsbi->s_numfiles--;\nout:\n\texofs_put_page(page);\n\treturn err;\n}",
    "includes": [
      "#include \"exofs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exofs_put_page",
          "args": [
            "page"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
          "lines": "41-45",
          "snippet": "static inline void exofs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"exofs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n\nstatic inline void exofs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "inode"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "exofs_commit_chunk",
          "args": [
            "page",
            "pos",
            "to - from"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_commit_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
          "lines": "63-86",
          "snippet": "static int exofs_commit_chunk(struct page *page, loff_t pos, unsigned len)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *dir = mapping->host;\n\tint err = 0;\n\n\tdir->i_version++;\n\n\tif (!PageUptodate(page))\n\t\tSetPageUptodate(page);\n\n\tif (pos+len > dir->i_size) {\n\t\ti_size_write(dir, pos+len);\n\t\tmark_inode_dirty(dir);\n\t}\n\tset_page_dirty(page);\n\n\tif (IS_DIRSYNC(dir))\n\t\terr = write_one_page(page, 1);\n\telse\n\t\tunlock_page(page);\n\n\treturn err;\n}",
          "includes": [
            "#include \"exofs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n\nstatic int exofs_commit_chunk(struct page *page, loff_t pos, unsigned len)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *dir = mapping->host;\n\tint err = 0;\n\n\tdir->i_version++;\n\n\tif (!PageUptodate(page))\n\t\tSetPageUptodate(page);\n\n\tif (pos+len > dir->i_size) {\n\t\ti_size_write(dir, pos+len);\n\t\tmark_inode_dirty(dir);\n\t}\n\tset_page_dirty(page);\n\n\tif (IS_DIRSYNC(dir))\n\t\terr = write_one_page(page, 1);\n\telse\n\t\tunlock_page(page);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!err"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "to - from"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXOFS_ERR",
          "args": [
            "\"exofs_delete_entry: exofs_write_begin FAILED => %d\\n\"",
            "err"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exofs_write_begin",
          "args": [
            "NULL",
            "page->mapping",
            "pos",
            "to - from",
            "0",
            "&page",
            "NULL"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_write_begin_export",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "919-928",
          "snippet": "static int exofs_write_begin_export(struct file *file,\n\t\tstruct address_space *mapping,\n\t\tloff_t pos, unsigned len, unsigned flags,\n\t\tstruct page **pagep, void **fsdata)\n{\n\t*pagep = NULL;\n\n\treturn exofs_write_begin(file, mapping, pos, len, flags, pagep,\n\t\t\t\t\tfsdata);\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic int exofs_write_begin_export(struct file *file,\n\t\tstruct address_space *mapping,\n\t\tloff_t pos, unsigned len, unsigned flags,\n\t\tstruct page **pagep, void **fsdata)\n{\n\t*pagep = NULL;\n\n\treturn exofs_write_begin(file, mapping, pos, len, flags, pagep,\n\t\t\t\t\tfsdata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_page",
          "args": [
            "page"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "page"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exofs_next_entry",
          "args": [
            "de"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_next_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
          "lines": "192-196",
          "snippet": "static inline\nstruct exofs_dir_entry *exofs_next_entry(struct exofs_dir_entry *p)\n{\n\treturn (struct exofs_dir_entry *)((char *)p + le16_to_cpu(p->rec_len));\n}",
          "includes": [
            "#include \"exofs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n\nstatic inline\nstruct exofs_dir_entry *exofs_next_entry(struct exofs_dir_entry *p)\n{\n\treturn (struct exofs_dir_entry *)((char *)p + le16_to_cpu(p->rec_len));\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXOFS_ERR",
          "args": [
            "\"ERROR: exofs_delete_entry:\"\n\t\t\t\t  \"zero-length entry in directory(0x%lx)\\n\"",
            "inode->i_ino"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "dir->rec_len"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exofs_chunk_size",
          "args": [
            "inode"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_chunk_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
          "lines": "36-39",
          "snippet": "static inline unsigned exofs_chunk_size(struct inode *inode)\n{\n\treturn inode->i_sb->s_blocksize;\n}",
          "includes": [
            "#include \"exofs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n\nstatic inline unsigned exofs_chunk_size(struct inode *inode)\n{\n\treturn inode->i_sb->s_blocksize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n\nint exofs_delete_entry(struct exofs_dir_entry *dir, struct page *page)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *inode = mapping->host;\n\tstruct exofs_sb_info *sbi = inode->i_sb->s_fs_info;\n\tchar *kaddr = page_address(page);\n\tunsigned from = ((char *)dir - kaddr) & ~(exofs_chunk_size(inode)-1);\n\tunsigned to = ((char *)dir - kaddr) + le16_to_cpu(dir->rec_len);\n\tloff_t pos;\n\tstruct exofs_dir_entry *pde = NULL;\n\tstruct exofs_dir_entry *de = (struct exofs_dir_entry *) (kaddr + from);\n\tint err;\n\n\twhile (de < dir) {\n\t\tif (de->rec_len == 0) {\n\t\t\tEXOFS_ERR(\"ERROR: exofs_delete_entry:\"\n\t\t\t\t  \"zero-length entry in directory(0x%lx)\\n\",\n\t\t\t\t  inode->i_ino);\n\t\t\terr = -EIO;\n\t\t\tgoto out;\n\t\t}\n\t\tpde = de;\n\t\tde = exofs_next_entry(de);\n\t}\n\tif (pde)\n\t\tfrom = (char *)pde - (char *)page_address(page);\n\tpos = page_offset(page) + from;\n\tlock_page(page);\n\terr = exofs_write_begin(NULL, page->mapping, pos, to - from, 0,\n\t\t\t\t\t\t\t&page, NULL);\n\tif (err)\n\t\tEXOFS_ERR(\"exofs_delete_entry: exofs_write_begin FAILED => %d\\n\",\n\t\t\t  err);\n\tif (pde)\n\t\tpde->rec_len = cpu_to_le16(to - from);\n\tdir->inode_no = 0;\n\tif (likely(!err))\n\t\terr = exofs_commit_chunk(page, pos, to - from);\n\tinode->i_ctime = inode->i_mtime = CURRENT_TIME;\n\tmark_inode_dirty(inode);\n\tsbi->s_numfiles--;\nout:\n\texofs_put_page(page);\n\treturn err;\n}"
  },
  {
    "function_name": "exofs_add_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
    "lines": "430-523",
    "snippet": "int exofs_add_link(struct dentry *dentry, struct inode *inode)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tconst unsigned char *name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tunsigned chunk_size = exofs_chunk_size(dir);\n\tunsigned reclen = EXOFS_DIR_REC_LEN(namelen);\n\tunsigned short rec_len, name_len;\n\tstruct page *page = NULL;\n\tstruct exofs_sb_info *sbi = inode->i_sb->s_fs_info;\n\tstruct exofs_dir_entry *de;\n\tunsigned long npages = dir_pages(dir);\n\tunsigned long n;\n\tchar *kaddr;\n\tloff_t pos;\n\tint err;\n\n\tfor (n = 0; n <= npages; n++) {\n\t\tchar *dir_end;\n\n\t\tpage = exofs_get_page(dir, n);\n\t\terr = PTR_ERR(page);\n\t\tif (IS_ERR(page))\n\t\t\tgoto out;\n\t\tlock_page(page);\n\t\tkaddr = page_address(page);\n\t\tdir_end = kaddr + exofs_last_byte(dir, n);\n\t\tde = (struct exofs_dir_entry *)kaddr;\n\t\tkaddr += PAGE_CACHE_SIZE - reclen;\n\t\twhile ((char *)de <= kaddr) {\n\t\t\tif ((char *)de == dir_end) {\n\t\t\t\tname_len = 0;\n\t\t\t\trec_len = chunk_size;\n\t\t\t\tde->rec_len = cpu_to_le16(chunk_size);\n\t\t\t\tde->inode_no = 0;\n\t\t\t\tgoto got_it;\n\t\t\t}\n\t\t\tif (de->rec_len == 0) {\n\t\t\t\tEXOFS_ERR(\"ERROR: exofs_add_link: \"\n\t\t\t\t      \"zero-length entry in directory(0x%lx)\\n\",\n\t\t\t\t      inode->i_ino);\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\terr = -EEXIST;\n\t\t\tif (exofs_match(namelen, name, de))\n\t\t\t\tgoto out_unlock;\n\t\t\tname_len = EXOFS_DIR_REC_LEN(de->name_len);\n\t\t\trec_len = le16_to_cpu(de->rec_len);\n\t\t\tif (!de->inode_no && rec_len >= reclen)\n\t\t\t\tgoto got_it;\n\t\t\tif (rec_len >= name_len + reclen)\n\t\t\t\tgoto got_it;\n\t\t\tde = (struct exofs_dir_entry *) ((char *) de + rec_len);\n\t\t}\n\t\tunlock_page(page);\n\t\texofs_put_page(page);\n\t}\n\n\tEXOFS_ERR(\"exofs_add_link: BAD dentry=%p or inode=0x%lx\\n\",\n\t\t  dentry, inode->i_ino);\n\treturn -EINVAL;\n\ngot_it:\n\tpos = page_offset(page) +\n\t\t(char *)de - (char *)page_address(page);\n\terr = exofs_write_begin(NULL, page->mapping, pos, rec_len, 0,\n\t\t\t\t\t\t\t&page, NULL);\n\tif (err)\n\t\tgoto out_unlock;\n\tif (de->inode_no) {\n\t\tstruct exofs_dir_entry *de1 =\n\t\t\t(struct exofs_dir_entry *)((char *)de + name_len);\n\t\tde1->rec_len = cpu_to_le16(rec_len - name_len);\n\t\tde->rec_len = cpu_to_le16(name_len);\n\t\tde = de1;\n\t}\n\tde->name_len = namelen;\n\tmemcpy(de->name, name, namelen);\n\tde->inode_no = cpu_to_le64(inode->i_ino);\n\texofs_set_de_type(de, inode);\n\terr = exofs_commit_chunk(page, pos, rec_len);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME;\n\tmark_inode_dirty(dir);\n\tsbi->s_numfiles++;\n\nout_put:\n\texofs_put_page(page);\nout:\n\treturn err;\nout_unlock:\n\tunlock_page(page);\n\tgoto out_put;\n}",
    "includes": [
      "#include \"exofs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exofs_put_page",
          "args": [
            "page"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
          "lines": "41-45",
          "snippet": "static inline void exofs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"exofs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n\nstatic inline void exofs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "dir"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "exofs_commit_chunk",
          "args": [
            "page",
            "pos",
            "rec_len"
          ],
          "line": 511
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_commit_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
          "lines": "63-86",
          "snippet": "static int exofs_commit_chunk(struct page *page, loff_t pos, unsigned len)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *dir = mapping->host;\n\tint err = 0;\n\n\tdir->i_version++;\n\n\tif (!PageUptodate(page))\n\t\tSetPageUptodate(page);\n\n\tif (pos+len > dir->i_size) {\n\t\ti_size_write(dir, pos+len);\n\t\tmark_inode_dirty(dir);\n\t}\n\tset_page_dirty(page);\n\n\tif (IS_DIRSYNC(dir))\n\t\terr = write_one_page(page, 1);\n\telse\n\t\tunlock_page(page);\n\n\treturn err;\n}",
          "includes": [
            "#include \"exofs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n\nstatic int exofs_commit_chunk(struct page *page, loff_t pos, unsigned len)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *dir = mapping->host;\n\tint err = 0;\n\n\tdir->i_version++;\n\n\tif (!PageUptodate(page))\n\t\tSetPageUptodate(page);\n\n\tif (pos+len > dir->i_size) {\n\t\ti_size_write(dir, pos+len);\n\t\tmark_inode_dirty(dir);\n\t}\n\tset_page_dirty(page);\n\n\tif (IS_DIRSYNC(dir))\n\t\terr = write_one_page(page, 1);\n\telse\n\t\tunlock_page(page);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exofs_set_de_type",
          "args": [
            "de",
            "inode"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_set_de_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
          "lines": "234-239",
          "snippet": "static inline\nvoid exofs_set_de_type(struct exofs_dir_entry *de, struct inode *inode)\n{\n\tumode_t mode = inode->i_mode;\n\tde->file_type = exofs_type_by_mode[(mode & S_IFMT) >> S_SHIFT];\n}",
          "includes": [
            "#include \"exofs.h\""
          ],
          "macros_used": [
            "#define S_SHIFT 12"
          ],
          "globals_used": [
            "static unsigned char exofs_type_by_mode[S_IFMT >> S_SHIFT] = {\n\t[S_IFREG >> S_SHIFT]\t= EXOFS_FT_REG_FILE,\n\t[S_IFDIR >> S_SHIFT]\t= EXOFS_FT_DIR,\n\t[S_IFCHR >> S_SHIFT]\t= EXOFS_FT_CHRDEV,\n\t[S_IFBLK >> S_SHIFT]\t= EXOFS_FT_BLKDEV,\n\t[S_IFIFO >> S_SHIFT]\t= EXOFS_FT_FIFO,\n\t[S_IFSOCK >> S_SHIFT]\t= EXOFS_FT_SOCK,\n\t[S_IFLNK >> S_SHIFT]\t= EXOFS_FT_SYMLINK,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n\n#define S_SHIFT 12\n\nstatic unsigned char exofs_type_by_mode[S_IFMT >> S_SHIFT] = {\n\t[S_IFREG >> S_SHIFT]\t= EXOFS_FT_REG_FILE,\n\t[S_IFDIR >> S_SHIFT]\t= EXOFS_FT_DIR,\n\t[S_IFCHR >> S_SHIFT]\t= EXOFS_FT_CHRDEV,\n\t[S_IFBLK >> S_SHIFT]\t= EXOFS_FT_BLKDEV,\n\t[S_IFIFO >> S_SHIFT]\t= EXOFS_FT_FIFO,\n\t[S_IFSOCK >> S_SHIFT]\t= EXOFS_FT_SOCK,\n\t[S_IFLNK >> S_SHIFT]\t= EXOFS_FT_SYMLINK,\n};\n\nstatic inline\nvoid exofs_set_de_type(struct exofs_dir_entry *de, struct inode *inode)\n{\n\tumode_t mode = inode->i_mode;\n\tde->file_type = exofs_type_by_mode[(mode & S_IFMT) >> S_SHIFT];\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "inode->i_ino"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "de->name",
            "name",
            "namelen"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "name_len"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "rec_len - name_len"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exofs_write_begin",
          "args": [
            "NULL",
            "page->mapping",
            "pos",
            "rec_len",
            "0",
            "&page",
            "NULL"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_write_begin_export",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "919-928",
          "snippet": "static int exofs_write_begin_export(struct file *file,\n\t\tstruct address_space *mapping,\n\t\tloff_t pos, unsigned len, unsigned flags,\n\t\tstruct page **pagep, void **fsdata)\n{\n\t*pagep = NULL;\n\n\treturn exofs_write_begin(file, mapping, pos, len, flags, pagep,\n\t\t\t\t\tfsdata);\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic int exofs_write_begin_export(struct file *file,\n\t\tstruct address_space *mapping,\n\t\tloff_t pos, unsigned len, unsigned flags,\n\t\tstruct page **pagep, void **fsdata)\n{\n\t*pagep = NULL;\n\n\treturn exofs_write_begin(file, mapping, pos, len, flags, pagep,\n\t\t\t\t\tfsdata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "page"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXOFS_ERR",
          "args": [
            "\"exofs_add_link: BAD dentry=%p or inode=0x%lx\\n\"",
            "dentry",
            "inode->i_ino"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "de->rec_len"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXOFS_DIR_REC_LEN",
          "args": [
            "de->name_len"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exofs_match",
          "args": [
            "namelen",
            "name",
            "de"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
          "lines": "182-190",
          "snippet": "static inline int exofs_match(int len, const unsigned char *name,\n\t\t\t\t\tstruct exofs_dir_entry *de)\n{\n\tif (len != de->name_len)\n\t\treturn 0;\n\tif (!de->inode_no)\n\t\treturn 0;\n\treturn !memcmp(name, de->name, len);\n}",
          "includes": [
            "#include \"exofs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n\nstatic inline int exofs_match(int len, const unsigned char *name,\n\t\t\t\t\tstruct exofs_dir_entry *de)\n{\n\tif (len != de->name_len)\n\t\treturn 0;\n\tif (!de->inode_no)\n\t\treturn 0;\n\treturn !memcmp(name, de->name, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXOFS_ERR",
          "args": [
            "\"ERROR: exofs_add_link: \"\n\t\t\t\t      \"zero-length entry in directory(0x%lx)\\n\"",
            "inode->i_ino"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "chunk_size"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exofs_last_byte",
          "args": [
            "dir",
            "n"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_last_byte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
          "lines": "53-61",
          "snippet": "static unsigned exofs_last_byte(struct inode *inode, unsigned long page_nr)\n{\n\tloff_t last_byte = inode->i_size;\n\n\tlast_byte -= page_nr << PAGE_CACHE_SHIFT;\n\tif (last_byte > PAGE_CACHE_SIZE)\n\t\tlast_byte = PAGE_CACHE_SIZE;\n\treturn last_byte;\n}",
          "includes": [
            "#include \"exofs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n\nstatic unsigned exofs_last_byte(struct inode *inode, unsigned long page_nr)\n{\n\tloff_t last_byte = inode->i_size;\n\n\tlast_byte -= page_nr << PAGE_CACHE_SHIFT;\n\tif (last_byte > PAGE_CACHE_SIZE)\n\t\tlast_byte = PAGE_CACHE_SIZE;\n\treturn last_byte;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "page"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exofs_get_page",
          "args": [
            "dir",
            "n"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_get_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
          "lines": "163-180",
          "snippet": "static struct page *exofs_get_page(struct inode *dir, unsigned long n)\n{\n\tstruct address_space *mapping = dir->i_mapping;\n\tstruct page *page = read_mapping_page(mapping, n, NULL);\n\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (!PageChecked(page))\n\t\t\texofs_check_page(page);\n\t\tif (PageError(page))\n\t\t\tgoto fail;\n\t}\n\treturn page;\n\nfail:\n\texofs_put_page(page);\n\treturn ERR_PTR(-EIO);\n}",
          "includes": [
            "#include \"exofs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n\nstatic struct page *exofs_get_page(struct inode *dir, unsigned long n)\n{\n\tstruct address_space *mapping = dir->i_mapping;\n\tstruct page *page = read_mapping_page(mapping, n, NULL);\n\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (!PageChecked(page))\n\t\t\texofs_check_page(page);\n\t\tif (PageError(page))\n\t\t\tgoto fail;\n\t}\n\treturn page;\n\nfail:\n\texofs_put_page(page);\n\treturn ERR_PTR(-EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_pages",
          "args": [
            "dir"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "dir_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
          "lines": "48-51",
          "snippet": "static inline unsigned long dir_pages(struct inode *inode)\n{\n\treturn (inode->i_size + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;\n}",
          "includes": [
            "#include \"exofs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n\nstatic inline unsigned long dir_pages(struct inode *inode)\n{\n\treturn (inode->i_size + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXOFS_DIR_REC_LEN",
          "args": [
            "namelen"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exofs_chunk_size",
          "args": [
            "dir"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_chunk_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
          "lines": "36-39",
          "snippet": "static inline unsigned exofs_chunk_size(struct inode *inode)\n{\n\treturn inode->i_sb->s_blocksize;\n}",
          "includes": [
            "#include \"exofs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n\nstatic inline unsigned exofs_chunk_size(struct inode *inode)\n{\n\treturn inode->i_sb->s_blocksize;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n\nint exofs_add_link(struct dentry *dentry, struct inode *inode)\n{\n\tstruct inode *dir = dentry->d_parent->d_inode;\n\tconst unsigned char *name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tunsigned chunk_size = exofs_chunk_size(dir);\n\tunsigned reclen = EXOFS_DIR_REC_LEN(namelen);\n\tunsigned short rec_len, name_len;\n\tstruct page *page = NULL;\n\tstruct exofs_sb_info *sbi = inode->i_sb->s_fs_info;\n\tstruct exofs_dir_entry *de;\n\tunsigned long npages = dir_pages(dir);\n\tunsigned long n;\n\tchar *kaddr;\n\tloff_t pos;\n\tint err;\n\n\tfor (n = 0; n <= npages; n++) {\n\t\tchar *dir_end;\n\n\t\tpage = exofs_get_page(dir, n);\n\t\terr = PTR_ERR(page);\n\t\tif (IS_ERR(page))\n\t\t\tgoto out;\n\t\tlock_page(page);\n\t\tkaddr = page_address(page);\n\t\tdir_end = kaddr + exofs_last_byte(dir, n);\n\t\tde = (struct exofs_dir_entry *)kaddr;\n\t\tkaddr += PAGE_CACHE_SIZE - reclen;\n\t\twhile ((char *)de <= kaddr) {\n\t\t\tif ((char *)de == dir_end) {\n\t\t\t\tname_len = 0;\n\t\t\t\trec_len = chunk_size;\n\t\t\t\tde->rec_len = cpu_to_le16(chunk_size);\n\t\t\t\tde->inode_no = 0;\n\t\t\t\tgoto got_it;\n\t\t\t}\n\t\t\tif (de->rec_len == 0) {\n\t\t\t\tEXOFS_ERR(\"ERROR: exofs_add_link: \"\n\t\t\t\t      \"zero-length entry in directory(0x%lx)\\n\",\n\t\t\t\t      inode->i_ino);\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\terr = -EEXIST;\n\t\t\tif (exofs_match(namelen, name, de))\n\t\t\t\tgoto out_unlock;\n\t\t\tname_len = EXOFS_DIR_REC_LEN(de->name_len);\n\t\t\trec_len = le16_to_cpu(de->rec_len);\n\t\t\tif (!de->inode_no && rec_len >= reclen)\n\t\t\t\tgoto got_it;\n\t\t\tif (rec_len >= name_len + reclen)\n\t\t\t\tgoto got_it;\n\t\t\tde = (struct exofs_dir_entry *) ((char *) de + rec_len);\n\t\t}\n\t\tunlock_page(page);\n\t\texofs_put_page(page);\n\t}\n\n\tEXOFS_ERR(\"exofs_add_link: BAD dentry=%p or inode=0x%lx\\n\",\n\t\t  dentry, inode->i_ino);\n\treturn -EINVAL;\n\ngot_it:\n\tpos = page_offset(page) +\n\t\t(char *)de - (char *)page_address(page);\n\terr = exofs_write_begin(NULL, page->mapping, pos, rec_len, 0,\n\t\t\t\t\t\t\t&page, NULL);\n\tif (err)\n\t\tgoto out_unlock;\n\tif (de->inode_no) {\n\t\tstruct exofs_dir_entry *de1 =\n\t\t\t(struct exofs_dir_entry *)((char *)de + name_len);\n\t\tde1->rec_len = cpu_to_le16(rec_len - name_len);\n\t\tde->rec_len = cpu_to_le16(name_len);\n\t\tde = de1;\n\t}\n\tde->name_len = namelen;\n\tmemcpy(de->name, name, namelen);\n\tde->inode_no = cpu_to_le64(inode->i_ino);\n\texofs_set_de_type(de, inode);\n\terr = exofs_commit_chunk(page, pos, rec_len);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME;\n\tmark_inode_dirty(dir);\n\tsbi->s_numfiles++;\n\nout_put:\n\texofs_put_page(page);\nout:\n\treturn err;\nout_unlock:\n\tunlock_page(page);\n\tgoto out_put;\n}"
  },
  {
    "function_name": "exofs_set_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
    "lines": "405-428",
    "snippet": "int exofs_set_link(struct inode *dir, struct exofs_dir_entry *de,\n\t\t\tstruct page *page, struct inode *inode)\n{\n\tloff_t pos = page_offset(page) +\n\t\t\t(char *) de - (char *) page_address(page);\n\tunsigned len = le16_to_cpu(de->rec_len);\n\tint err;\n\n\tlock_page(page);\n\terr = exofs_write_begin(NULL, page->mapping, pos, len,\n\t\t\t\tAOP_FLAG_UNINTERRUPTIBLE, &page, NULL);\n\tif (err)\n\t\tEXOFS_ERR(\"exofs_set_link: exofs_write_begin FAILED => %d\\n\",\n\t\t\t  err);\n\n\tde->inode_no = cpu_to_le64(inode->i_ino);\n\texofs_set_de_type(de, inode);\n\tif (likely(!err))\n\t\terr = exofs_commit_chunk(page, pos, len);\n\texofs_put_page(page);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME;\n\tmark_inode_dirty(dir);\n\treturn err;\n}",
    "includes": [
      "#include \"exofs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "dir"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "exofs_put_page",
          "args": [
            "page"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
          "lines": "41-45",
          "snippet": "static inline void exofs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"exofs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n\nstatic inline void exofs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exofs_commit_chunk",
          "args": [
            "page",
            "pos",
            "len"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_commit_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
          "lines": "63-86",
          "snippet": "static int exofs_commit_chunk(struct page *page, loff_t pos, unsigned len)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *dir = mapping->host;\n\tint err = 0;\n\n\tdir->i_version++;\n\n\tif (!PageUptodate(page))\n\t\tSetPageUptodate(page);\n\n\tif (pos+len > dir->i_size) {\n\t\ti_size_write(dir, pos+len);\n\t\tmark_inode_dirty(dir);\n\t}\n\tset_page_dirty(page);\n\n\tif (IS_DIRSYNC(dir))\n\t\terr = write_one_page(page, 1);\n\telse\n\t\tunlock_page(page);\n\n\treturn err;\n}",
          "includes": [
            "#include \"exofs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n\nstatic int exofs_commit_chunk(struct page *page, loff_t pos, unsigned len)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *dir = mapping->host;\n\tint err = 0;\n\n\tdir->i_version++;\n\n\tif (!PageUptodate(page))\n\t\tSetPageUptodate(page);\n\n\tif (pos+len > dir->i_size) {\n\t\ti_size_write(dir, pos+len);\n\t\tmark_inode_dirty(dir);\n\t}\n\tset_page_dirty(page);\n\n\tif (IS_DIRSYNC(dir))\n\t\terr = write_one_page(page, 1);\n\telse\n\t\tunlock_page(page);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!err"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exofs_set_de_type",
          "args": [
            "de",
            "inode"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_set_de_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
          "lines": "234-239",
          "snippet": "static inline\nvoid exofs_set_de_type(struct exofs_dir_entry *de, struct inode *inode)\n{\n\tumode_t mode = inode->i_mode;\n\tde->file_type = exofs_type_by_mode[(mode & S_IFMT) >> S_SHIFT];\n}",
          "includes": [
            "#include \"exofs.h\""
          ],
          "macros_used": [
            "#define S_SHIFT 12"
          ],
          "globals_used": [
            "static unsigned char exofs_type_by_mode[S_IFMT >> S_SHIFT] = {\n\t[S_IFREG >> S_SHIFT]\t= EXOFS_FT_REG_FILE,\n\t[S_IFDIR >> S_SHIFT]\t= EXOFS_FT_DIR,\n\t[S_IFCHR >> S_SHIFT]\t= EXOFS_FT_CHRDEV,\n\t[S_IFBLK >> S_SHIFT]\t= EXOFS_FT_BLKDEV,\n\t[S_IFIFO >> S_SHIFT]\t= EXOFS_FT_FIFO,\n\t[S_IFSOCK >> S_SHIFT]\t= EXOFS_FT_SOCK,\n\t[S_IFLNK >> S_SHIFT]\t= EXOFS_FT_SYMLINK,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n\n#define S_SHIFT 12\n\nstatic unsigned char exofs_type_by_mode[S_IFMT >> S_SHIFT] = {\n\t[S_IFREG >> S_SHIFT]\t= EXOFS_FT_REG_FILE,\n\t[S_IFDIR >> S_SHIFT]\t= EXOFS_FT_DIR,\n\t[S_IFCHR >> S_SHIFT]\t= EXOFS_FT_CHRDEV,\n\t[S_IFBLK >> S_SHIFT]\t= EXOFS_FT_BLKDEV,\n\t[S_IFIFO >> S_SHIFT]\t= EXOFS_FT_FIFO,\n\t[S_IFSOCK >> S_SHIFT]\t= EXOFS_FT_SOCK,\n\t[S_IFLNK >> S_SHIFT]\t= EXOFS_FT_SYMLINK,\n};\n\nstatic inline\nvoid exofs_set_de_type(struct exofs_dir_entry *de, struct inode *inode)\n{\n\tumode_t mode = inode->i_mode;\n\tde->file_type = exofs_type_by_mode[(mode & S_IFMT) >> S_SHIFT];\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "inode->i_ino"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXOFS_ERR",
          "args": [
            "\"exofs_set_link: exofs_write_begin FAILED => %d\\n\"",
            "err"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exofs_write_begin",
          "args": [
            "NULL",
            "page->mapping",
            "pos",
            "len",
            "AOP_FLAG_UNINTERRUPTIBLE",
            "&page",
            "NULL"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_write_begin_export",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "919-928",
          "snippet": "static int exofs_write_begin_export(struct file *file,\n\t\tstruct address_space *mapping,\n\t\tloff_t pos, unsigned len, unsigned flags,\n\t\tstruct page **pagep, void **fsdata)\n{\n\t*pagep = NULL;\n\n\treturn exofs_write_begin(file, mapping, pos, len, flags, pagep,\n\t\t\t\t\tfsdata);\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic int exofs_write_begin_export(struct file *file,\n\t\tstruct address_space *mapping,\n\t\tloff_t pos, unsigned len, unsigned flags,\n\t\tstruct page **pagep, void **fsdata)\n{\n\t*pagep = NULL;\n\n\treturn exofs_write_begin(file, mapping, pos, len, flags, pagep,\n\t\t\t\t\tfsdata);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_page",
          "args": [
            "page"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "de->rec_len"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_offset",
          "args": [
            "page"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n\nint exofs_set_link(struct inode *dir, struct exofs_dir_entry *de,\n\t\t\tstruct page *page, struct inode *inode)\n{\n\tloff_t pos = page_offset(page) +\n\t\t\t(char *) de - (char *) page_address(page);\n\tunsigned len = le16_to_cpu(de->rec_len);\n\tint err;\n\n\tlock_page(page);\n\terr = exofs_write_begin(NULL, page->mapping, pos, len,\n\t\t\t\tAOP_FLAG_UNINTERRUPTIBLE, &page, NULL);\n\tif (err)\n\t\tEXOFS_ERR(\"exofs_set_link: exofs_write_begin FAILED => %d\\n\",\n\t\t\t  err);\n\n\tde->inode_no = cpu_to_le64(inode->i_ino);\n\texofs_set_de_type(de, inode);\n\tif (likely(!err))\n\t\terr = exofs_commit_chunk(page, pos, len);\n\texofs_put_page(page);\n\tdir->i_mtime = dir->i_ctime = CURRENT_TIME;\n\tmark_inode_dirty(dir);\n\treturn err;\n}"
  },
  {
    "function_name": "exofs_inode_by_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
    "lines": "391-403",
    "snippet": "ino_t exofs_inode_by_name(struct inode *dir, struct dentry *dentry)\n{\n\tino_t res = 0;\n\tstruct exofs_dir_entry *de;\n\tstruct page *page;\n\n\tde = exofs_find_entry(dir, dentry, &page);\n\tif (de) {\n\t\tres = le64_to_cpu(de->inode_no);\n\t\texofs_put_page(page);\n\t}\n\treturn res;\n}",
    "includes": [
      "#include \"exofs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exofs_put_page",
          "args": [
            "page"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
          "lines": "41-45",
          "snippet": "static inline void exofs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"exofs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n\nstatic inline void exofs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "de->inode_no"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exofs_find_entry",
          "args": [
            "dir",
            "dentry",
            "&page"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
          "lines": "309-361",
          "snippet": "struct exofs_dir_entry *exofs_find_entry(struct inode *dir,\n\t\t\tstruct dentry *dentry, struct page **res_page)\n{\n\tconst unsigned char *name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tunsigned reclen = EXOFS_DIR_REC_LEN(namelen);\n\tunsigned long start, n;\n\tunsigned long npages = dir_pages(dir);\n\tstruct page *page = NULL;\n\tstruct exofs_i_info *oi = exofs_i(dir);\n\tstruct exofs_dir_entry *de;\n\n\tif (npages == 0)\n\t\tgoto out;\n\n\t*res_page = NULL;\n\n\tstart = oi->i_dir_start_lookup;\n\tif (start >= npages)\n\t\tstart = 0;\n\tn = start;\n\tdo {\n\t\tchar *kaddr;\n\t\tpage = exofs_get_page(dir, n);\n\t\tif (!IS_ERR(page)) {\n\t\t\tkaddr = page_address(page);\n\t\t\tde = (struct exofs_dir_entry *) kaddr;\n\t\t\tkaddr += exofs_last_byte(dir, n) - reclen;\n\t\t\twhile ((char *) de <= kaddr) {\n\t\t\t\tif (de->rec_len == 0) {\n\t\t\t\t\tEXOFS_ERR(\"ERROR: zero-length entry in \"\n\t\t\t\t\t\t  \"directory(0x%lx)\\n\",\n\t\t\t\t\t\t  dir->i_ino);\n\t\t\t\t\texofs_put_page(page);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (exofs_match(namelen, name, de))\n\t\t\t\t\tgoto found;\n\t\t\t\tde = exofs_next_entry(de);\n\t\t\t}\n\t\t\texofs_put_page(page);\n\t\t}\n\t\tif (++n >= npages)\n\t\t\tn = 0;\n\t} while (n != start);\nout:\n\treturn NULL;\n\nfound:\n\t*res_page = page;\n\toi->i_dir_start_lookup = n;\n\treturn de;\n}",
          "includes": [
            "#include \"exofs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n\nstruct exofs_dir_entry *exofs_find_entry(struct inode *dir,\n\t\t\tstruct dentry *dentry, struct page **res_page)\n{\n\tconst unsigned char *name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tunsigned reclen = EXOFS_DIR_REC_LEN(namelen);\n\tunsigned long start, n;\n\tunsigned long npages = dir_pages(dir);\n\tstruct page *page = NULL;\n\tstruct exofs_i_info *oi = exofs_i(dir);\n\tstruct exofs_dir_entry *de;\n\n\tif (npages == 0)\n\t\tgoto out;\n\n\t*res_page = NULL;\n\n\tstart = oi->i_dir_start_lookup;\n\tif (start >= npages)\n\t\tstart = 0;\n\tn = start;\n\tdo {\n\t\tchar *kaddr;\n\t\tpage = exofs_get_page(dir, n);\n\t\tif (!IS_ERR(page)) {\n\t\t\tkaddr = page_address(page);\n\t\t\tde = (struct exofs_dir_entry *) kaddr;\n\t\t\tkaddr += exofs_last_byte(dir, n) - reclen;\n\t\t\twhile ((char *) de <= kaddr) {\n\t\t\t\tif (de->rec_len == 0) {\n\t\t\t\t\tEXOFS_ERR(\"ERROR: zero-length entry in \"\n\t\t\t\t\t\t  \"directory(0x%lx)\\n\",\n\t\t\t\t\t\t  dir->i_ino);\n\t\t\t\t\texofs_put_page(page);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (exofs_match(namelen, name, de))\n\t\t\t\t\tgoto found;\n\t\t\t\tde = exofs_next_entry(de);\n\t\t\t}\n\t\t\texofs_put_page(page);\n\t\t}\n\t\tif (++n >= npages)\n\t\t\tn = 0;\n\t} while (n != start);\nout:\n\treturn NULL;\n\nfound:\n\t*res_page = page;\n\toi->i_dir_start_lookup = n;\n\treturn de;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n\nino_t exofs_inode_by_name(struct inode *dir, struct dentry *dentry)\n{\n\tino_t res = 0;\n\tstruct exofs_dir_entry *de;\n\tstruct page *page;\n\n\tde = exofs_find_entry(dir, dentry, &page);\n\tif (de) {\n\t\tres = le64_to_cpu(de->inode_no);\n\t\texofs_put_page(page);\n\t}\n\treturn res;\n}"
  },
  {
    "function_name": "exofs_parent_ino",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
    "lines": "376-389",
    "snippet": "ino_t exofs_parent_ino(struct dentry *child)\n{\n\tstruct page *page;\n\tstruct exofs_dir_entry *de;\n\tino_t ino;\n\n\tde = exofs_dotdot(child->d_inode, &page);\n\tif (!de)\n\t\treturn 0;\n\n\tino = le64_to_cpu(de->inode_no);\n\texofs_put_page(page);\n\treturn ino;\n}",
    "includes": [
      "#include \"exofs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exofs_put_page",
          "args": [
            "page"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
          "lines": "41-45",
          "snippet": "static inline void exofs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"exofs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n\nstatic inline void exofs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "de->inode_no"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exofs_dotdot",
          "args": [
            "child->d_inode",
            "&page"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_dotdot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
          "lines": "363-374",
          "snippet": "struct exofs_dir_entry *exofs_dotdot(struct inode *dir, struct page **p)\n{\n\tstruct page *page = exofs_get_page(dir, 0);\n\tstruct exofs_dir_entry *de = NULL;\n\n\tif (!IS_ERR(page)) {\n\t\tde = exofs_next_entry(\n\t\t\t\t(struct exofs_dir_entry *)page_address(page));\n\t\t*p = page;\n\t}\n\treturn de;\n}",
          "includes": [
            "#include \"exofs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n\nstruct exofs_dir_entry *exofs_dotdot(struct inode *dir, struct page **p)\n{\n\tstruct page *page = exofs_get_page(dir, 0);\n\tstruct exofs_dir_entry *de = NULL;\n\n\tif (!IS_ERR(page)) {\n\t\tde = exofs_next_entry(\n\t\t\t\t(struct exofs_dir_entry *)page_address(page));\n\t\t*p = page;\n\t}\n\treturn de;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n\nino_t exofs_parent_ino(struct dentry *child)\n{\n\tstruct page *page;\n\tstruct exofs_dir_entry *de;\n\tino_t ino;\n\n\tde = exofs_dotdot(child->d_inode, &page);\n\tif (!de)\n\t\treturn 0;\n\n\tino = le64_to_cpu(de->inode_no);\n\texofs_put_page(page);\n\treturn ino;\n}"
  },
  {
    "function_name": "exofs_dotdot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
    "lines": "363-374",
    "snippet": "struct exofs_dir_entry *exofs_dotdot(struct inode *dir, struct page **p)\n{\n\tstruct page *page = exofs_get_page(dir, 0);\n\tstruct exofs_dir_entry *de = NULL;\n\n\tif (!IS_ERR(page)) {\n\t\tde = exofs_next_entry(\n\t\t\t\t(struct exofs_dir_entry *)page_address(page));\n\t\t*p = page;\n\t}\n\treturn de;\n}",
    "includes": [
      "#include \"exofs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exofs_next_entry",
          "args": [
            "(struct exofs_dir_entry *)page_address(page)"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_next_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
          "lines": "192-196",
          "snippet": "static inline\nstruct exofs_dir_entry *exofs_next_entry(struct exofs_dir_entry *p)\n{\n\treturn (struct exofs_dir_entry *)((char *)p + le16_to_cpu(p->rec_len));\n}",
          "includes": [
            "#include \"exofs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n\nstatic inline\nstruct exofs_dir_entry *exofs_next_entry(struct exofs_dir_entry *p)\n{\n\treturn (struct exofs_dir_entry *)((char *)p + le16_to_cpu(p->rec_len));\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exofs_get_page",
          "args": [
            "dir",
            "0"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_get_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
          "lines": "163-180",
          "snippet": "static struct page *exofs_get_page(struct inode *dir, unsigned long n)\n{\n\tstruct address_space *mapping = dir->i_mapping;\n\tstruct page *page = read_mapping_page(mapping, n, NULL);\n\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (!PageChecked(page))\n\t\t\texofs_check_page(page);\n\t\tif (PageError(page))\n\t\t\tgoto fail;\n\t}\n\treturn page;\n\nfail:\n\texofs_put_page(page);\n\treturn ERR_PTR(-EIO);\n}",
          "includes": [
            "#include \"exofs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n\nstatic struct page *exofs_get_page(struct inode *dir, unsigned long n)\n{\n\tstruct address_space *mapping = dir->i_mapping;\n\tstruct page *page = read_mapping_page(mapping, n, NULL);\n\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (!PageChecked(page))\n\t\t\texofs_check_page(page);\n\t\tif (PageError(page))\n\t\t\tgoto fail;\n\t}\n\treturn page;\n\nfail:\n\texofs_put_page(page);\n\treturn ERR_PTR(-EIO);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n\nstruct exofs_dir_entry *exofs_dotdot(struct inode *dir, struct page **p)\n{\n\tstruct page *page = exofs_get_page(dir, 0);\n\tstruct exofs_dir_entry *de = NULL;\n\n\tif (!IS_ERR(page)) {\n\t\tde = exofs_next_entry(\n\t\t\t\t(struct exofs_dir_entry *)page_address(page));\n\t\t*p = page;\n\t}\n\treturn de;\n}"
  },
  {
    "function_name": "exofs_find_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
    "lines": "309-361",
    "snippet": "struct exofs_dir_entry *exofs_find_entry(struct inode *dir,\n\t\t\tstruct dentry *dentry, struct page **res_page)\n{\n\tconst unsigned char *name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tunsigned reclen = EXOFS_DIR_REC_LEN(namelen);\n\tunsigned long start, n;\n\tunsigned long npages = dir_pages(dir);\n\tstruct page *page = NULL;\n\tstruct exofs_i_info *oi = exofs_i(dir);\n\tstruct exofs_dir_entry *de;\n\n\tif (npages == 0)\n\t\tgoto out;\n\n\t*res_page = NULL;\n\n\tstart = oi->i_dir_start_lookup;\n\tif (start >= npages)\n\t\tstart = 0;\n\tn = start;\n\tdo {\n\t\tchar *kaddr;\n\t\tpage = exofs_get_page(dir, n);\n\t\tif (!IS_ERR(page)) {\n\t\t\tkaddr = page_address(page);\n\t\t\tde = (struct exofs_dir_entry *) kaddr;\n\t\t\tkaddr += exofs_last_byte(dir, n) - reclen;\n\t\t\twhile ((char *) de <= kaddr) {\n\t\t\t\tif (de->rec_len == 0) {\n\t\t\t\t\tEXOFS_ERR(\"ERROR: zero-length entry in \"\n\t\t\t\t\t\t  \"directory(0x%lx)\\n\",\n\t\t\t\t\t\t  dir->i_ino);\n\t\t\t\t\texofs_put_page(page);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (exofs_match(namelen, name, de))\n\t\t\t\t\tgoto found;\n\t\t\t\tde = exofs_next_entry(de);\n\t\t\t}\n\t\t\texofs_put_page(page);\n\t\t}\n\t\tif (++n >= npages)\n\t\t\tn = 0;\n\t} while (n != start);\nout:\n\treturn NULL;\n\nfound:\n\t*res_page = page;\n\toi->i_dir_start_lookup = n;\n\treturn de;\n}",
    "includes": [
      "#include \"exofs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exofs_put_page",
          "args": [
            "page"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
          "lines": "41-45",
          "snippet": "static inline void exofs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"exofs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n\nstatic inline void exofs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exofs_next_entry",
          "args": [
            "de"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_next_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
          "lines": "192-196",
          "snippet": "static inline\nstruct exofs_dir_entry *exofs_next_entry(struct exofs_dir_entry *p)\n{\n\treturn (struct exofs_dir_entry *)((char *)p + le16_to_cpu(p->rec_len));\n}",
          "includes": [
            "#include \"exofs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n\nstatic inline\nstruct exofs_dir_entry *exofs_next_entry(struct exofs_dir_entry *p)\n{\n\treturn (struct exofs_dir_entry *)((char *)p + le16_to_cpu(p->rec_len));\n}"
        }
      },
      {
        "call_info": {
          "callee": "exofs_match",
          "args": [
            "namelen",
            "name",
            "de"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
          "lines": "182-190",
          "snippet": "static inline int exofs_match(int len, const unsigned char *name,\n\t\t\t\t\tstruct exofs_dir_entry *de)\n{\n\tif (len != de->name_len)\n\t\treturn 0;\n\tif (!de->inode_no)\n\t\treturn 0;\n\treturn !memcmp(name, de->name, len);\n}",
          "includes": [
            "#include \"exofs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n\nstatic inline int exofs_match(int len, const unsigned char *name,\n\t\t\t\t\tstruct exofs_dir_entry *de)\n{\n\tif (len != de->name_len)\n\t\treturn 0;\n\tif (!de->inode_no)\n\t\treturn 0;\n\treturn !memcmp(name, de->name, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXOFS_ERR",
          "args": [
            "\"ERROR: zero-length entry in \"\n\t\t\t\t\t\t  \"directory(0x%lx)\\n\"",
            "dir->i_ino"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exofs_last_byte",
          "args": [
            "dir",
            "n"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_last_byte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
          "lines": "53-61",
          "snippet": "static unsigned exofs_last_byte(struct inode *inode, unsigned long page_nr)\n{\n\tloff_t last_byte = inode->i_size;\n\n\tlast_byte -= page_nr << PAGE_CACHE_SHIFT;\n\tif (last_byte > PAGE_CACHE_SIZE)\n\t\tlast_byte = PAGE_CACHE_SIZE;\n\treturn last_byte;\n}",
          "includes": [
            "#include \"exofs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n\nstatic unsigned exofs_last_byte(struct inode *inode, unsigned long page_nr)\n{\n\tloff_t last_byte = inode->i_size;\n\n\tlast_byte -= page_nr << PAGE_CACHE_SHIFT;\n\tif (last_byte > PAGE_CACHE_SIZE)\n\t\tlast_byte = PAGE_CACHE_SIZE;\n\treturn last_byte;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exofs_get_page",
          "args": [
            "dir",
            "n"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_get_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
          "lines": "163-180",
          "snippet": "static struct page *exofs_get_page(struct inode *dir, unsigned long n)\n{\n\tstruct address_space *mapping = dir->i_mapping;\n\tstruct page *page = read_mapping_page(mapping, n, NULL);\n\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (!PageChecked(page))\n\t\t\texofs_check_page(page);\n\t\tif (PageError(page))\n\t\t\tgoto fail;\n\t}\n\treturn page;\n\nfail:\n\texofs_put_page(page);\n\treturn ERR_PTR(-EIO);\n}",
          "includes": [
            "#include \"exofs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n\nstatic struct page *exofs_get_page(struct inode *dir, unsigned long n)\n{\n\tstruct address_space *mapping = dir->i_mapping;\n\tstruct page *page = read_mapping_page(mapping, n, NULL);\n\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (!PageChecked(page))\n\t\t\texofs_check_page(page);\n\t\tif (PageError(page))\n\t\t\tgoto fail;\n\t}\n\treturn page;\n\nfail:\n\texofs_put_page(page);\n\treturn ERR_PTR(-EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "exofs_i",
          "args": [
            "dir"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_inode_is_fast_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/inode.c",
          "lines": "1001-1006",
          "snippet": "static inline int exofs_inode_is_fast_symlink(struct inode *inode)\n{\n\tstruct exofs_i_info *oi = exofs_i(inode);\n\n\treturn S_ISLNK(inode->i_mode) && (oi->i_data[0] != 0);\n}",
          "includes": [
            "#include \"exofs.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n#include <linux/slab.h>\n\nstatic inline int exofs_inode_is_fast_symlink(struct inode *inode)\n{\n\tstruct exofs_i_info *oi = exofs_i(inode);\n\n\treturn S_ISLNK(inode->i_mode) && (oi->i_data[0] != 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_pages",
          "args": [
            "dir"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "dir_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
          "lines": "48-51",
          "snippet": "static inline unsigned long dir_pages(struct inode *inode)\n{\n\treturn (inode->i_size + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;\n}",
          "includes": [
            "#include \"exofs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n\nstatic inline unsigned long dir_pages(struct inode *inode)\n{\n\treturn (inode->i_size + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXOFS_DIR_REC_LEN",
          "args": [
            "namelen"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n\nstruct exofs_dir_entry *exofs_find_entry(struct inode *dir,\n\t\t\tstruct dentry *dentry, struct page **res_page)\n{\n\tconst unsigned char *name = dentry->d_name.name;\n\tint namelen = dentry->d_name.len;\n\tunsigned reclen = EXOFS_DIR_REC_LEN(namelen);\n\tunsigned long start, n;\n\tunsigned long npages = dir_pages(dir);\n\tstruct page *page = NULL;\n\tstruct exofs_i_info *oi = exofs_i(dir);\n\tstruct exofs_dir_entry *de;\n\n\tif (npages == 0)\n\t\tgoto out;\n\n\t*res_page = NULL;\n\n\tstart = oi->i_dir_start_lookup;\n\tif (start >= npages)\n\t\tstart = 0;\n\tn = start;\n\tdo {\n\t\tchar *kaddr;\n\t\tpage = exofs_get_page(dir, n);\n\t\tif (!IS_ERR(page)) {\n\t\t\tkaddr = page_address(page);\n\t\t\tde = (struct exofs_dir_entry *) kaddr;\n\t\t\tkaddr += exofs_last_byte(dir, n) - reclen;\n\t\t\twhile ((char *) de <= kaddr) {\n\t\t\t\tif (de->rec_len == 0) {\n\t\t\t\t\tEXOFS_ERR(\"ERROR: zero-length entry in \"\n\t\t\t\t\t\t  \"directory(0x%lx)\\n\",\n\t\t\t\t\t\t  dir->i_ino);\n\t\t\t\t\texofs_put_page(page);\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tif (exofs_match(namelen, name, de))\n\t\t\t\t\tgoto found;\n\t\t\t\tde = exofs_next_entry(de);\n\t\t\t}\n\t\t\texofs_put_page(page);\n\t\t}\n\t\tif (++n >= npages)\n\t\t\tn = 0;\n\t} while (n != start);\nout:\n\treturn NULL;\n\nfound:\n\t*res_page = page;\n\toi->i_dir_start_lookup = n;\n\treturn de;\n}"
  },
  {
    "function_name": "exofs_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
    "lines": "241-307",
    "snippet": "static int\nexofs_readdir(struct file *file, struct dir_context *ctx)\n{\n\tloff_t pos = ctx->pos;\n\tstruct inode *inode = file_inode(file);\n\tunsigned int offset = pos & ~PAGE_CACHE_MASK;\n\tunsigned long n = pos >> PAGE_CACHE_SHIFT;\n\tunsigned long npages = dir_pages(inode);\n\tunsigned chunk_mask = ~(exofs_chunk_size(inode)-1);\n\tint need_revalidate = (file->f_version != inode->i_version);\n\n\tif (pos > inode->i_size - EXOFS_DIR_REC_LEN(1))\n\t\treturn 0;\n\n\tfor ( ; n < npages; n++, offset = 0) {\n\t\tchar *kaddr, *limit;\n\t\tstruct exofs_dir_entry *de;\n\t\tstruct page *page = exofs_get_page(inode, n);\n\n\t\tif (IS_ERR(page)) {\n\t\t\tEXOFS_ERR(\"ERROR: bad page in directory(0x%lx)\\n\",\n\t\t\t\t  inode->i_ino);\n\t\t\tctx->pos += PAGE_CACHE_SIZE - offset;\n\t\t\treturn PTR_ERR(page);\n\t\t}\n\t\tkaddr = page_address(page);\n\t\tif (unlikely(need_revalidate)) {\n\t\t\tif (offset) {\n\t\t\t\toffset = exofs_validate_entry(kaddr, offset,\n\t\t\t\t\t\t\t\tchunk_mask);\n\t\t\t\tctx->pos = (n<<PAGE_CACHE_SHIFT) + offset;\n\t\t\t}\n\t\t\tfile->f_version = inode->i_version;\n\t\t\tneed_revalidate = 0;\n\t\t}\n\t\tde = (struct exofs_dir_entry *)(kaddr + offset);\n\t\tlimit = kaddr + exofs_last_byte(inode, n) -\n\t\t\t\t\t\t\tEXOFS_DIR_REC_LEN(1);\n\t\tfor (; (char *)de <= limit; de = exofs_next_entry(de)) {\n\t\t\tif (de->rec_len == 0) {\n\t\t\t\tEXOFS_ERR(\"ERROR: \"\n\t\t\t\t     \"zero-length entry in directory(0x%lx)\\n\",\n\t\t\t\t     inode->i_ino);\n\t\t\t\texofs_put_page(page);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tif (de->inode_no) {\n\t\t\t\tunsigned char t;\n\n\t\t\t\tif (de->file_type < EXOFS_FT_MAX)\n\t\t\t\t\tt = exofs_filetype_table[de->file_type];\n\t\t\t\telse\n\t\t\t\t\tt = DT_UNKNOWN;\n\n\t\t\t\tif (!dir_emit(ctx, de->name, de->name_len,\n\t\t\t\t\t\tle64_to_cpu(de->inode_no),\n\t\t\t\t\t\tt)) {\n\t\t\t\t\texofs_put_page(page);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tctx->pos += le16_to_cpu(de->rec_len);\n\t\t}\n\t\texofs_put_page(page);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"exofs.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned char exofs_filetype_table[EXOFS_FT_MAX] = {\n\t[EXOFS_FT_UNKNOWN]\t= DT_UNKNOWN,\n\t[EXOFS_FT_REG_FILE]\t= DT_REG,\n\t[EXOFS_FT_DIR]\t\t= DT_DIR,\n\t[EXOFS_FT_CHRDEV]\t= DT_CHR,\n\t[EXOFS_FT_BLKDEV]\t= DT_BLK,\n\t[EXOFS_FT_FIFO]\t\t= DT_FIFO,\n\t[EXOFS_FT_SOCK]\t\t= DT_SOCK,\n\t[EXOFS_FT_SYMLINK]\t= DT_LNK,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exofs_put_page",
          "args": [
            "page"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
          "lines": "41-45",
          "snippet": "static inline void exofs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"exofs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n\nstatic inline void exofs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "de->rec_len"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_emit",
          "args": [
            "ctx",
            "de->name",
            "de->name_len",
            "le64_to_cpu(de->inode_no)",
            "t"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "de->inode_no"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXOFS_ERR",
          "args": [
            "\"ERROR: \"\n\t\t\t\t     \"zero-length entry in directory(0x%lx)\\n\"",
            "inode->i_ino"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exofs_next_entry",
          "args": [
            "de"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_next_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
          "lines": "192-196",
          "snippet": "static inline\nstruct exofs_dir_entry *exofs_next_entry(struct exofs_dir_entry *p)\n{\n\treturn (struct exofs_dir_entry *)((char *)p + le16_to_cpu(p->rec_len));\n}",
          "includes": [
            "#include \"exofs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n\nstatic inline\nstruct exofs_dir_entry *exofs_next_entry(struct exofs_dir_entry *p)\n{\n\treturn (struct exofs_dir_entry *)((char *)p + le16_to_cpu(p->rec_len));\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXOFS_DIR_REC_LEN",
          "args": [
            "1"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exofs_last_byte",
          "args": [
            "inode",
            "n"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_last_byte",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
          "lines": "53-61",
          "snippet": "static unsigned exofs_last_byte(struct inode *inode, unsigned long page_nr)\n{\n\tloff_t last_byte = inode->i_size;\n\n\tlast_byte -= page_nr << PAGE_CACHE_SHIFT;\n\tif (last_byte > PAGE_CACHE_SIZE)\n\t\tlast_byte = PAGE_CACHE_SIZE;\n\treturn last_byte;\n}",
          "includes": [
            "#include \"exofs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n\nstatic unsigned exofs_last_byte(struct inode *inode, unsigned long page_nr)\n{\n\tloff_t last_byte = inode->i_size;\n\n\tlast_byte -= page_nr << PAGE_CACHE_SHIFT;\n\tif (last_byte > PAGE_CACHE_SIZE)\n\t\tlast_byte = PAGE_CACHE_SIZE;\n\treturn last_byte;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exofs_validate_entry",
          "args": [
            "kaddr",
            "offset",
            "chunk_mask"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_validate_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
          "lines": "198-210",
          "snippet": "static inline unsigned\nexofs_validate_entry(char *base, unsigned offset, unsigned mask)\n{\n\tstruct exofs_dir_entry *de = (struct exofs_dir_entry *)(base + offset);\n\tstruct exofs_dir_entry *p =\n\t\t\t(struct exofs_dir_entry *)(base + (offset&mask));\n\twhile ((char *)p < (char *)de) {\n\t\tif (p->rec_len == 0)\n\t\t\tbreak;\n\t\tp = exofs_next_entry(p);\n\t}\n\treturn (char *)p - base;\n}",
          "includes": [
            "#include \"exofs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n\nstatic inline unsigned\nexofs_validate_entry(char *base, unsigned offset, unsigned mask)\n{\n\tstruct exofs_dir_entry *de = (struct exofs_dir_entry *)(base + offset);\n\tstruct exofs_dir_entry *p =\n\t\t\t(struct exofs_dir_entry *)(base + (offset&mask));\n\twhile ((char *)p < (char *)de) {\n\t\tif (p->rec_len == 0)\n\t\t\tbreak;\n\t\tp = exofs_next_entry(p);\n\t}\n\treturn (char *)p - base;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "need_revalidate"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "page"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXOFS_ERR",
          "args": [
            "\"ERROR: bad page in directory(0x%lx)\\n\"",
            "inode->i_ino"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exofs_get_page",
          "args": [
            "inode",
            "n"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_get_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
          "lines": "163-180",
          "snippet": "static struct page *exofs_get_page(struct inode *dir, unsigned long n)\n{\n\tstruct address_space *mapping = dir->i_mapping;\n\tstruct page *page = read_mapping_page(mapping, n, NULL);\n\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (!PageChecked(page))\n\t\t\texofs_check_page(page);\n\t\tif (PageError(page))\n\t\t\tgoto fail;\n\t}\n\treturn page;\n\nfail:\n\texofs_put_page(page);\n\treturn ERR_PTR(-EIO);\n}",
          "includes": [
            "#include \"exofs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n\nstatic struct page *exofs_get_page(struct inode *dir, unsigned long n)\n{\n\tstruct address_space *mapping = dir->i_mapping;\n\tstruct page *page = read_mapping_page(mapping, n, NULL);\n\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (!PageChecked(page))\n\t\t\texofs_check_page(page);\n\t\tif (PageError(page))\n\t\t\tgoto fail;\n\t}\n\treturn page;\n\nfail:\n\texofs_put_page(page);\n\treturn ERR_PTR(-EIO);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXOFS_DIR_REC_LEN",
          "args": [
            "1"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exofs_chunk_size",
          "args": [
            "inode"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_chunk_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
          "lines": "36-39",
          "snippet": "static inline unsigned exofs_chunk_size(struct inode *inode)\n{\n\treturn inode->i_sb->s_blocksize;\n}",
          "includes": [
            "#include \"exofs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n\nstatic inline unsigned exofs_chunk_size(struct inode *inode)\n{\n\treturn inode->i_sb->s_blocksize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dir_pages",
          "args": [
            "inode"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "dir_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
          "lines": "48-51",
          "snippet": "static inline unsigned long dir_pages(struct inode *inode)\n{\n\treturn (inode->i_size + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;\n}",
          "includes": [
            "#include \"exofs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n\nstatic inline unsigned long dir_pages(struct inode *inode)\n{\n\treturn (inode->i_size + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_init_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fuse/file.c",
          "lines": "3009-3013",
          "snippet": "void fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}",
          "includes": [
            "#include <linux/falloc.h>",
            "#include <linux/aio.h>",
            "#include <linux/swap.h>",
            "#include <linux/compat.h>",
            "#include <linux/module.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include \"fuse_i.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};",
            "static const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/falloc.h>\n#include <linux/aio.h>\n#include <linux/swap.h>\n#include <linux/compat.h>\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include \"fuse_i.h\"\n\nstatic const struct file_operations fuse_file_operations = {\n\t.llseek\t\t= fuse_file_llseek,\n\t.read\t\t= new_sync_read,\n\t.read_iter\t= fuse_file_read_iter,\n\t.write\t\t= new_sync_write,\n\t.write_iter\t= fuse_file_write_iter,\n\t.mmap\t\t= fuse_file_mmap,\n\t.open\t\t= fuse_open,\n\t.flush\t\t= fuse_flush,\n\t.release\t= fuse_release,\n\t.fsync\t\t= fuse_fsync,\n\t.lock\t\t= fuse_file_lock,\n\t.flock\t\t= fuse_file_flock,\n\t.splice_read\t= generic_file_splice_read,\n\t.unlocked_ioctl\t= fuse_file_ioctl,\n\t.compat_ioctl\t= fuse_file_compat_ioctl,\n\t.poll\t\t= fuse_file_poll,\n\t.fallocate\t= fuse_file_fallocate,\n};\nstatic const struct address_space_operations fuse_file_aops  = {\n\t.readpage\t= fuse_readpage,\n\t.writepage\t= fuse_writepage,\n\t.writepages\t= fuse_writepages,\n\t.launder_page\t= fuse_launder_page,\n\t.readpages\t= fuse_readpages,\n\t.set_page_dirty\t= __set_page_dirty_nobuffers,\n\t.bmap\t\t= fuse_bmap,\n\t.direct_IO\t= fuse_direct_IO,\n\t.write_begin\t= fuse_write_begin,\n\t.write_end\t= fuse_write_end,\n};\n\nvoid fuse_init_file_inode(struct inode *inode)\n{\n\tinode->i_fop = &fuse_file_operations;\n\tinode->i_data.a_ops = &fuse_file_aops;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n\nstatic unsigned char exofs_filetype_table[EXOFS_FT_MAX] = {\n\t[EXOFS_FT_UNKNOWN]\t= DT_UNKNOWN,\n\t[EXOFS_FT_REG_FILE]\t= DT_REG,\n\t[EXOFS_FT_DIR]\t\t= DT_DIR,\n\t[EXOFS_FT_CHRDEV]\t= DT_CHR,\n\t[EXOFS_FT_BLKDEV]\t= DT_BLK,\n\t[EXOFS_FT_FIFO]\t\t= DT_FIFO,\n\t[EXOFS_FT_SOCK]\t\t= DT_SOCK,\n\t[EXOFS_FT_SYMLINK]\t= DT_LNK,\n};\n\nstatic int\nexofs_readdir(struct file *file, struct dir_context *ctx)\n{\n\tloff_t pos = ctx->pos;\n\tstruct inode *inode = file_inode(file);\n\tunsigned int offset = pos & ~PAGE_CACHE_MASK;\n\tunsigned long n = pos >> PAGE_CACHE_SHIFT;\n\tunsigned long npages = dir_pages(inode);\n\tunsigned chunk_mask = ~(exofs_chunk_size(inode)-1);\n\tint need_revalidate = (file->f_version != inode->i_version);\n\n\tif (pos > inode->i_size - EXOFS_DIR_REC_LEN(1))\n\t\treturn 0;\n\n\tfor ( ; n < npages; n++, offset = 0) {\n\t\tchar *kaddr, *limit;\n\t\tstruct exofs_dir_entry *de;\n\t\tstruct page *page = exofs_get_page(inode, n);\n\n\t\tif (IS_ERR(page)) {\n\t\t\tEXOFS_ERR(\"ERROR: bad page in directory(0x%lx)\\n\",\n\t\t\t\t  inode->i_ino);\n\t\t\tctx->pos += PAGE_CACHE_SIZE - offset;\n\t\t\treturn PTR_ERR(page);\n\t\t}\n\t\tkaddr = page_address(page);\n\t\tif (unlikely(need_revalidate)) {\n\t\t\tif (offset) {\n\t\t\t\toffset = exofs_validate_entry(kaddr, offset,\n\t\t\t\t\t\t\t\tchunk_mask);\n\t\t\t\tctx->pos = (n<<PAGE_CACHE_SHIFT) + offset;\n\t\t\t}\n\t\t\tfile->f_version = inode->i_version;\n\t\t\tneed_revalidate = 0;\n\t\t}\n\t\tde = (struct exofs_dir_entry *)(kaddr + offset);\n\t\tlimit = kaddr + exofs_last_byte(inode, n) -\n\t\t\t\t\t\t\tEXOFS_DIR_REC_LEN(1);\n\t\tfor (; (char *)de <= limit; de = exofs_next_entry(de)) {\n\t\t\tif (de->rec_len == 0) {\n\t\t\t\tEXOFS_ERR(\"ERROR: \"\n\t\t\t\t     \"zero-length entry in directory(0x%lx)\\n\",\n\t\t\t\t     inode->i_ino);\n\t\t\t\texofs_put_page(page);\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t\tif (de->inode_no) {\n\t\t\t\tunsigned char t;\n\n\t\t\t\tif (de->file_type < EXOFS_FT_MAX)\n\t\t\t\t\tt = exofs_filetype_table[de->file_type];\n\t\t\t\telse\n\t\t\t\t\tt = DT_UNKNOWN;\n\n\t\t\t\tif (!dir_emit(ctx, de->name, de->name_len,\n\t\t\t\t\t\tle64_to_cpu(de->inode_no),\n\t\t\t\t\t\tt)) {\n\t\t\t\t\texofs_put_page(page);\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tctx->pos += le16_to_cpu(de->rec_len);\n\t\t}\n\t\texofs_put_page(page);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "exofs_set_de_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
    "lines": "234-239",
    "snippet": "static inline\nvoid exofs_set_de_type(struct exofs_dir_entry *de, struct inode *inode)\n{\n\tumode_t mode = inode->i_mode;\n\tde->file_type = exofs_type_by_mode[(mode & S_IFMT) >> S_SHIFT];\n}",
    "includes": [
      "#include \"exofs.h\""
    ],
    "macros_used": [
      "#define S_SHIFT 12"
    ],
    "globals_used": [
      "static unsigned char exofs_type_by_mode[S_IFMT >> S_SHIFT] = {\n\t[S_IFREG >> S_SHIFT]\t= EXOFS_FT_REG_FILE,\n\t[S_IFDIR >> S_SHIFT]\t= EXOFS_FT_DIR,\n\t[S_IFCHR >> S_SHIFT]\t= EXOFS_FT_CHRDEV,\n\t[S_IFBLK >> S_SHIFT]\t= EXOFS_FT_BLKDEV,\n\t[S_IFIFO >> S_SHIFT]\t= EXOFS_FT_FIFO,\n\t[S_IFSOCK >> S_SHIFT]\t= EXOFS_FT_SOCK,\n\t[S_IFLNK >> S_SHIFT]\t= EXOFS_FT_SYMLINK,\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"exofs.h\"\n\n#define S_SHIFT 12\n\nstatic unsigned char exofs_type_by_mode[S_IFMT >> S_SHIFT] = {\n\t[S_IFREG >> S_SHIFT]\t= EXOFS_FT_REG_FILE,\n\t[S_IFDIR >> S_SHIFT]\t= EXOFS_FT_DIR,\n\t[S_IFCHR >> S_SHIFT]\t= EXOFS_FT_CHRDEV,\n\t[S_IFBLK >> S_SHIFT]\t= EXOFS_FT_BLKDEV,\n\t[S_IFIFO >> S_SHIFT]\t= EXOFS_FT_FIFO,\n\t[S_IFSOCK >> S_SHIFT]\t= EXOFS_FT_SOCK,\n\t[S_IFLNK >> S_SHIFT]\t= EXOFS_FT_SYMLINK,\n};\n\nstatic inline\nvoid exofs_set_de_type(struct exofs_dir_entry *de, struct inode *inode)\n{\n\tumode_t mode = inode->i_mode;\n\tde->file_type = exofs_type_by_mode[(mode & S_IFMT) >> S_SHIFT];\n}"
  },
  {
    "function_name": "exofs_validate_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
    "lines": "198-210",
    "snippet": "static inline unsigned\nexofs_validate_entry(char *base, unsigned offset, unsigned mask)\n{\n\tstruct exofs_dir_entry *de = (struct exofs_dir_entry *)(base + offset);\n\tstruct exofs_dir_entry *p =\n\t\t\t(struct exofs_dir_entry *)(base + (offset&mask));\n\twhile ((char *)p < (char *)de) {\n\t\tif (p->rec_len == 0)\n\t\t\tbreak;\n\t\tp = exofs_next_entry(p);\n\t}\n\treturn (char *)p - base;\n}",
    "includes": [
      "#include \"exofs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exofs_next_entry",
          "args": [
            "p"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_next_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
          "lines": "192-196",
          "snippet": "static inline\nstruct exofs_dir_entry *exofs_next_entry(struct exofs_dir_entry *p)\n{\n\treturn (struct exofs_dir_entry *)((char *)p + le16_to_cpu(p->rec_len));\n}",
          "includes": [
            "#include \"exofs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n\nstatic inline\nstruct exofs_dir_entry *exofs_next_entry(struct exofs_dir_entry *p)\n{\n\treturn (struct exofs_dir_entry *)((char *)p + le16_to_cpu(p->rec_len));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n\nstatic inline unsigned\nexofs_validate_entry(char *base, unsigned offset, unsigned mask)\n{\n\tstruct exofs_dir_entry *de = (struct exofs_dir_entry *)(base + offset);\n\tstruct exofs_dir_entry *p =\n\t\t\t(struct exofs_dir_entry *)(base + (offset&mask));\n\twhile ((char *)p < (char *)de) {\n\t\tif (p->rec_len == 0)\n\t\t\tbreak;\n\t\tp = exofs_next_entry(p);\n\t}\n\treturn (char *)p - base;\n}"
  },
  {
    "function_name": "exofs_next_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
    "lines": "192-196",
    "snippet": "static inline\nstruct exofs_dir_entry *exofs_next_entry(struct exofs_dir_entry *p)\n{\n\treturn (struct exofs_dir_entry *)((char *)p + le16_to_cpu(p->rec_len));\n}",
    "includes": [
      "#include \"exofs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "p->rec_len"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n\nstatic inline\nstruct exofs_dir_entry *exofs_next_entry(struct exofs_dir_entry *p)\n{\n\treturn (struct exofs_dir_entry *)((char *)p + le16_to_cpu(p->rec_len));\n}"
  },
  {
    "function_name": "exofs_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
    "lines": "182-190",
    "snippet": "static inline int exofs_match(int len, const unsigned char *name,\n\t\t\t\t\tstruct exofs_dir_entry *de)\n{\n\tif (len != de->name_len)\n\t\treturn 0;\n\tif (!de->inode_no)\n\t\treturn 0;\n\treturn !memcmp(name, de->name, len);\n}",
    "includes": [
      "#include \"exofs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "name",
            "de->name",
            "len"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n\nstatic inline int exofs_match(int len, const unsigned char *name,\n\t\t\t\t\tstruct exofs_dir_entry *de)\n{\n\tif (len != de->name_len)\n\t\treturn 0;\n\tif (!de->inode_no)\n\t\treturn 0;\n\treturn !memcmp(name, de->name, len);\n}"
  },
  {
    "function_name": "exofs_get_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
    "lines": "163-180",
    "snippet": "static struct page *exofs_get_page(struct inode *dir, unsigned long n)\n{\n\tstruct address_space *mapping = dir->i_mapping;\n\tstruct page *page = read_mapping_page(mapping, n, NULL);\n\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (!PageChecked(page))\n\t\t\texofs_check_page(page);\n\t\tif (PageError(page))\n\t\t\tgoto fail;\n\t}\n\treturn page;\n\nfail:\n\texofs_put_page(page);\n\treturn ERR_PTR(-EIO);\n}",
    "includes": [
      "#include \"exofs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exofs_put_page",
          "args": [
            "page"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_put_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
          "lines": "41-45",
          "snippet": "static inline void exofs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include \"exofs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n\nstatic inline void exofs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageError",
          "args": [
            "page"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exofs_check_page",
          "args": [
            "page"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_check_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
          "lines": "88-161",
          "snippet": "static void exofs_check_page(struct page *page)\n{\n\tstruct inode *dir = page->mapping->host;\n\tunsigned chunk_size = exofs_chunk_size(dir);\n\tchar *kaddr = page_address(page);\n\tunsigned offs, rec_len;\n\tunsigned limit = PAGE_CACHE_SIZE;\n\tstruct exofs_dir_entry *p;\n\tchar *error;\n\n\t/* if the page is the last one in the directory */\n\tif ((dir->i_size >> PAGE_CACHE_SHIFT) == page->index) {\n\t\tlimit = dir->i_size & ~PAGE_CACHE_MASK;\n\t\tif (limit & (chunk_size - 1))\n\t\t\tgoto Ebadsize;\n\t\tif (!limit)\n\t\t\tgoto out;\n\t}\n\tfor (offs = 0; offs <= limit - EXOFS_DIR_REC_LEN(1); offs += rec_len) {\n\t\tp = (struct exofs_dir_entry *)(kaddr + offs);\n\t\trec_len = le16_to_cpu(p->rec_len);\n\n\t\tif (rec_len < EXOFS_DIR_REC_LEN(1))\n\t\t\tgoto Eshort;\n\t\tif (rec_len & 3)\n\t\t\tgoto Ealign;\n\t\tif (rec_len < EXOFS_DIR_REC_LEN(p->name_len))\n\t\t\tgoto Enamelen;\n\t\tif (((offs + rec_len - 1) ^ offs) & ~(chunk_size-1))\n\t\t\tgoto Espan;\n\t}\n\tif (offs != limit)\n\t\tgoto Eend;\nout:\n\tSetPageChecked(page);\n\treturn;\n\nEbadsize:\n\tEXOFS_ERR(\"ERROR [exofs_check_page]: \"\n\t\t\"size of directory(0x%lx) is not a multiple of chunk size\\n\",\n\t\tdir->i_ino\n\t);\n\tgoto fail;\nEshort:\n\terror = \"rec_len is smaller than minimal\";\n\tgoto bad_entry;\nEalign:\n\terror = \"unaligned directory entry\";\n\tgoto bad_entry;\nEnamelen:\n\terror = \"rec_len is too small for name_len\";\n\tgoto bad_entry;\nEspan:\n\terror = \"directory entry across blocks\";\n\tgoto bad_entry;\nbad_entry:\n\tEXOFS_ERR(\n\t\t\"ERROR [exofs_check_page]: bad entry in directory(0x%lx): %s - \"\n\t\t\"offset=%lu, inode=0x%llu, rec_len=%d, name_len=%d\\n\",\n\t\tdir->i_ino, error, (page->index<<PAGE_CACHE_SHIFT)+offs,\n\t\t_LLU(le64_to_cpu(p->inode_no)),\n\t\trec_len, p->name_len);\n\tgoto fail;\nEend:\n\tp = (struct exofs_dir_entry *)(kaddr + offs);\n\tEXOFS_ERR(\"ERROR [exofs_check_page]: \"\n\t\t\"entry in directory(0x%lx) spans the page boundary\"\n\t\t\"offset=%lu, inode=0x%llx\\n\",\n\t\tdir->i_ino, (page->index<<PAGE_CACHE_SHIFT)+offs,\n\t\t_LLU(le64_to_cpu(p->inode_no)));\nfail:\n\tSetPageChecked(page);\n\tSetPageError(page);\n}",
          "includes": [
            "#include \"exofs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n\nstatic void exofs_check_page(struct page *page)\n{\n\tstruct inode *dir = page->mapping->host;\n\tunsigned chunk_size = exofs_chunk_size(dir);\n\tchar *kaddr = page_address(page);\n\tunsigned offs, rec_len;\n\tunsigned limit = PAGE_CACHE_SIZE;\n\tstruct exofs_dir_entry *p;\n\tchar *error;\n\n\t/* if the page is the last one in the directory */\n\tif ((dir->i_size >> PAGE_CACHE_SHIFT) == page->index) {\n\t\tlimit = dir->i_size & ~PAGE_CACHE_MASK;\n\t\tif (limit & (chunk_size - 1))\n\t\t\tgoto Ebadsize;\n\t\tif (!limit)\n\t\t\tgoto out;\n\t}\n\tfor (offs = 0; offs <= limit - EXOFS_DIR_REC_LEN(1); offs += rec_len) {\n\t\tp = (struct exofs_dir_entry *)(kaddr + offs);\n\t\trec_len = le16_to_cpu(p->rec_len);\n\n\t\tif (rec_len < EXOFS_DIR_REC_LEN(1))\n\t\t\tgoto Eshort;\n\t\tif (rec_len & 3)\n\t\t\tgoto Ealign;\n\t\tif (rec_len < EXOFS_DIR_REC_LEN(p->name_len))\n\t\t\tgoto Enamelen;\n\t\tif (((offs + rec_len - 1) ^ offs) & ~(chunk_size-1))\n\t\t\tgoto Espan;\n\t}\n\tif (offs != limit)\n\t\tgoto Eend;\nout:\n\tSetPageChecked(page);\n\treturn;\n\nEbadsize:\n\tEXOFS_ERR(\"ERROR [exofs_check_page]: \"\n\t\t\"size of directory(0x%lx) is not a multiple of chunk size\\n\",\n\t\tdir->i_ino\n\t);\n\tgoto fail;\nEshort:\n\terror = \"rec_len is smaller than minimal\";\n\tgoto bad_entry;\nEalign:\n\terror = \"unaligned directory entry\";\n\tgoto bad_entry;\nEnamelen:\n\terror = \"rec_len is too small for name_len\";\n\tgoto bad_entry;\nEspan:\n\terror = \"directory entry across blocks\";\n\tgoto bad_entry;\nbad_entry:\n\tEXOFS_ERR(\n\t\t\"ERROR [exofs_check_page]: bad entry in directory(0x%lx): %s - \"\n\t\t\"offset=%lu, inode=0x%llu, rec_len=%d, name_len=%d\\n\",\n\t\tdir->i_ino, error, (page->index<<PAGE_CACHE_SHIFT)+offs,\n\t\t_LLU(le64_to_cpu(p->inode_no)),\n\t\trec_len, p->name_len);\n\tgoto fail;\nEend:\n\tp = (struct exofs_dir_entry *)(kaddr + offs);\n\tEXOFS_ERR(\"ERROR [exofs_check_page]: \"\n\t\t\"entry in directory(0x%lx) spans the page boundary\"\n\t\t\"offset=%lu, inode=0x%llx\\n\",\n\t\tdir->i_ino, (page->index<<PAGE_CACHE_SHIFT)+offs,\n\t\t_LLU(le64_to_cpu(p->inode_no)));\nfail:\n\tSetPageChecked(page);\n\tSetPageError(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageChecked",
          "args": [
            "page"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap",
          "args": [
            "page"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "page"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_mapping_page",
          "args": [
            "mapping",
            "n",
            "NULL"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n\nstatic struct page *exofs_get_page(struct inode *dir, unsigned long n)\n{\n\tstruct address_space *mapping = dir->i_mapping;\n\tstruct page *page = read_mapping_page(mapping, n, NULL);\n\n\tif (!IS_ERR(page)) {\n\t\tkmap(page);\n\t\tif (!PageChecked(page))\n\t\t\texofs_check_page(page);\n\t\tif (PageError(page))\n\t\t\tgoto fail;\n\t}\n\treturn page;\n\nfail:\n\texofs_put_page(page);\n\treturn ERR_PTR(-EIO);\n}"
  },
  {
    "function_name": "exofs_check_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
    "lines": "88-161",
    "snippet": "static void exofs_check_page(struct page *page)\n{\n\tstruct inode *dir = page->mapping->host;\n\tunsigned chunk_size = exofs_chunk_size(dir);\n\tchar *kaddr = page_address(page);\n\tunsigned offs, rec_len;\n\tunsigned limit = PAGE_CACHE_SIZE;\n\tstruct exofs_dir_entry *p;\n\tchar *error;\n\n\t/* if the page is the last one in the directory */\n\tif ((dir->i_size >> PAGE_CACHE_SHIFT) == page->index) {\n\t\tlimit = dir->i_size & ~PAGE_CACHE_MASK;\n\t\tif (limit & (chunk_size - 1))\n\t\t\tgoto Ebadsize;\n\t\tif (!limit)\n\t\t\tgoto out;\n\t}\n\tfor (offs = 0; offs <= limit - EXOFS_DIR_REC_LEN(1); offs += rec_len) {\n\t\tp = (struct exofs_dir_entry *)(kaddr + offs);\n\t\trec_len = le16_to_cpu(p->rec_len);\n\n\t\tif (rec_len < EXOFS_DIR_REC_LEN(1))\n\t\t\tgoto Eshort;\n\t\tif (rec_len & 3)\n\t\t\tgoto Ealign;\n\t\tif (rec_len < EXOFS_DIR_REC_LEN(p->name_len))\n\t\t\tgoto Enamelen;\n\t\tif (((offs + rec_len - 1) ^ offs) & ~(chunk_size-1))\n\t\t\tgoto Espan;\n\t}\n\tif (offs != limit)\n\t\tgoto Eend;\nout:\n\tSetPageChecked(page);\n\treturn;\n\nEbadsize:\n\tEXOFS_ERR(\"ERROR [exofs_check_page]: \"\n\t\t\"size of directory(0x%lx) is not a multiple of chunk size\\n\",\n\t\tdir->i_ino\n\t);\n\tgoto fail;\nEshort:\n\terror = \"rec_len is smaller than minimal\";\n\tgoto bad_entry;\nEalign:\n\terror = \"unaligned directory entry\";\n\tgoto bad_entry;\nEnamelen:\n\terror = \"rec_len is too small for name_len\";\n\tgoto bad_entry;\nEspan:\n\terror = \"directory entry across blocks\";\n\tgoto bad_entry;\nbad_entry:\n\tEXOFS_ERR(\n\t\t\"ERROR [exofs_check_page]: bad entry in directory(0x%lx): %s - \"\n\t\t\"offset=%lu, inode=0x%llu, rec_len=%d, name_len=%d\\n\",\n\t\tdir->i_ino, error, (page->index<<PAGE_CACHE_SHIFT)+offs,\n\t\t_LLU(le64_to_cpu(p->inode_no)),\n\t\trec_len, p->name_len);\n\tgoto fail;\nEend:\n\tp = (struct exofs_dir_entry *)(kaddr + offs);\n\tEXOFS_ERR(\"ERROR [exofs_check_page]: \"\n\t\t\"entry in directory(0x%lx) spans the page boundary\"\n\t\t\"offset=%lu, inode=0x%llx\\n\",\n\t\tdir->i_ino, (page->index<<PAGE_CACHE_SHIFT)+offs,\n\t\t_LLU(le64_to_cpu(p->inode_no)));\nfail:\n\tSetPageChecked(page);\n\tSetPageError(page);\n}",
    "includes": [
      "#include \"exofs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SetPageError",
          "args": [
            "page"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageChecked",
          "args": [
            "page"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXOFS_ERR",
          "args": [
            "\"ERROR [exofs_check_page]: \"\n\t\t\"entry in directory(0x%lx) spans the page boundary\"\n\t\t\"offset=%lu, inode=0x%llx\\n\"",
            "dir->i_ino",
            "(page->index<<PAGE_CACHE_SHIFT)+offs",
            "_LLU(le64_to_cpu(p->inode_no))"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_LLU",
          "args": [
            "le64_to_cpu(p->inode_no)"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "p->inode_no"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXOFS_ERR",
          "args": [
            "\"ERROR [exofs_check_page]: bad entry in directory(0x%lx): %s - \"\n\t\t\"offset=%lu, inode=0x%llu, rec_len=%d, name_len=%d\\n\"",
            "dir->i_ino",
            "error",
            "(page->index<<PAGE_CACHE_SHIFT)+offs",
            "_LLU(le64_to_cpu(p->inode_no))",
            "rec_len",
            "p->name_len"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_LLU",
          "args": [
            "le64_to_cpu(p->inode_no)"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXOFS_ERR",
          "args": [
            "\"ERROR [exofs_check_page]: \"\n\t\t\"size of directory(0x%lx) is not a multiple of chunk size\\n\"",
            "dir->i_ino"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SetPageChecked",
          "args": [
            "page"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXOFS_DIR_REC_LEN",
          "args": [
            "p->name_len"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "EXOFS_DIR_REC_LEN",
          "args": [
            "1"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "p->rec_len"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "EXOFS_DIR_REC_LEN",
          "args": [
            "1"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exofs_chunk_size",
          "args": [
            "dir"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "exofs_chunk_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
          "lines": "36-39",
          "snippet": "static inline unsigned exofs_chunk_size(struct inode *inode)\n{\n\treturn inode->i_sb->s_blocksize;\n}",
          "includes": [
            "#include \"exofs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"exofs.h\"\n\nstatic inline unsigned exofs_chunk_size(struct inode *inode)\n{\n\treturn inode->i_sb->s_blocksize;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n\nstatic void exofs_check_page(struct page *page)\n{\n\tstruct inode *dir = page->mapping->host;\n\tunsigned chunk_size = exofs_chunk_size(dir);\n\tchar *kaddr = page_address(page);\n\tunsigned offs, rec_len;\n\tunsigned limit = PAGE_CACHE_SIZE;\n\tstruct exofs_dir_entry *p;\n\tchar *error;\n\n\t/* if the page is the last one in the directory */\n\tif ((dir->i_size >> PAGE_CACHE_SHIFT) == page->index) {\n\t\tlimit = dir->i_size & ~PAGE_CACHE_MASK;\n\t\tif (limit & (chunk_size - 1))\n\t\t\tgoto Ebadsize;\n\t\tif (!limit)\n\t\t\tgoto out;\n\t}\n\tfor (offs = 0; offs <= limit - EXOFS_DIR_REC_LEN(1); offs += rec_len) {\n\t\tp = (struct exofs_dir_entry *)(kaddr + offs);\n\t\trec_len = le16_to_cpu(p->rec_len);\n\n\t\tif (rec_len < EXOFS_DIR_REC_LEN(1))\n\t\t\tgoto Eshort;\n\t\tif (rec_len & 3)\n\t\t\tgoto Ealign;\n\t\tif (rec_len < EXOFS_DIR_REC_LEN(p->name_len))\n\t\t\tgoto Enamelen;\n\t\tif (((offs + rec_len - 1) ^ offs) & ~(chunk_size-1))\n\t\t\tgoto Espan;\n\t}\n\tif (offs != limit)\n\t\tgoto Eend;\nout:\n\tSetPageChecked(page);\n\treturn;\n\nEbadsize:\n\tEXOFS_ERR(\"ERROR [exofs_check_page]: \"\n\t\t\"size of directory(0x%lx) is not a multiple of chunk size\\n\",\n\t\tdir->i_ino\n\t);\n\tgoto fail;\nEshort:\n\terror = \"rec_len is smaller than minimal\";\n\tgoto bad_entry;\nEalign:\n\terror = \"unaligned directory entry\";\n\tgoto bad_entry;\nEnamelen:\n\terror = \"rec_len is too small for name_len\";\n\tgoto bad_entry;\nEspan:\n\terror = \"directory entry across blocks\";\n\tgoto bad_entry;\nbad_entry:\n\tEXOFS_ERR(\n\t\t\"ERROR [exofs_check_page]: bad entry in directory(0x%lx): %s - \"\n\t\t\"offset=%lu, inode=0x%llu, rec_len=%d, name_len=%d\\n\",\n\t\tdir->i_ino, error, (page->index<<PAGE_CACHE_SHIFT)+offs,\n\t\t_LLU(le64_to_cpu(p->inode_no)),\n\t\trec_len, p->name_len);\n\tgoto fail;\nEend:\n\tp = (struct exofs_dir_entry *)(kaddr + offs);\n\tEXOFS_ERR(\"ERROR [exofs_check_page]: \"\n\t\t\"entry in directory(0x%lx) spans the page boundary\"\n\t\t\"offset=%lu, inode=0x%llx\\n\",\n\t\tdir->i_ino, (page->index<<PAGE_CACHE_SHIFT)+offs,\n\t\t_LLU(le64_to_cpu(p->inode_no)));\nfail:\n\tSetPageChecked(page);\n\tSetPageError(page);\n}"
  },
  {
    "function_name": "exofs_commit_chunk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
    "lines": "63-86",
    "snippet": "static int exofs_commit_chunk(struct page *page, loff_t pos, unsigned len)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *dir = mapping->host;\n\tint err = 0;\n\n\tdir->i_version++;\n\n\tif (!PageUptodate(page))\n\t\tSetPageUptodate(page);\n\n\tif (pos+len > dir->i_size) {\n\t\ti_size_write(dir, pos+len);\n\t\tmark_inode_dirty(dir);\n\t}\n\tset_page_dirty(page);\n\n\tif (IS_DIRSYNC(dir))\n\t\terr = write_one_page(page, 1);\n\telse\n\t\tunlock_page(page);\n\n\treturn err;\n}",
    "includes": [
      "#include \"exofs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_one_page",
          "args": [
            "page",
            "1"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_DIRSYNC",
          "args": [
            "dir"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_dirty",
          "args": [
            "page"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "anon_set_page_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/libfs.c",
          "lines": "1040-1043",
          "snippet": "static int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/buffer_head.h> /* sync_mapping_buffers */",
            "#include <linux/writeback.h>",
            "#include <linux/exportfs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mutex.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/vfs.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/export.h>",
            "#include <linux/blkdev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/buffer_head.h> /* sync_mapping_buffers */\n#include <linux/writeback.h>\n#include <linux/exportfs.h>\n#include <linux/namei.h>\n#include <linux/mutex.h>\n#include <linux/quotaops.h>\n#include <linux/vfs.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/blkdev.h>\n\nstatic int anon_set_page_dirty(struct page *page)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_inode_dirty",
          "args": [
            "dir"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "block_dump___mark_inode_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/fs-writeback.c",
          "lines": "1134-1154",
          "snippet": "static noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/writeback.h>",
            "#include \"internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/writeback.h>",
            "#include <linux/kthread.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/writeback.h>\n#include \"internal.h\"\n#include <linux/device.h>\n#include <linux/tracepoint.h>\n#include <linux/backing-dev.h>\n#include <linux/blkdev.h>\n#include <linux/writeback.h>\n#include <linux/kthread.h>\n#include <linux/pagemap.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n\nstatic noinline void block_dump___mark_inode_dirty(struct inode *inode)\n{\n\tif (inode->i_ino || strcmp(inode->i_sb->s_id, \"bdev\")) {\n\t\tstruct dentry *dentry;\n\t\tconst char *name = \"?\";\n\n\t\tdentry = d_find_alias(inode);\n\t\tif (dentry) {\n\t\t\tspin_lock(&dentry->d_lock);\n\t\t\tname = (const char *) dentry->d_name.name;\n\t\t}\n\t\tprintk(KERN_DEBUG\n\t\t       \"%s(%d): dirtied inode %lu (%s) on %s\\n\",\n\t\t       current->comm, task_pid_nr(current), inode->i_ino,\n\t\t       name, inode->i_sb->s_id);\n\t\tif (dentry) {\n\t\t\tspin_unlock(&dentry->d_lock);\n\t\t\tdput(dentry);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "dir",
            "pos+len"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "SetPageUptodate",
          "args": [
            "page"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n\nstatic int exofs_commit_chunk(struct page *page, loff_t pos, unsigned len)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *dir = mapping->host;\n\tint err = 0;\n\n\tdir->i_version++;\n\n\tif (!PageUptodate(page))\n\t\tSetPageUptodate(page);\n\n\tif (pos+len > dir->i_size) {\n\t\ti_size_write(dir, pos+len);\n\t\tmark_inode_dirty(dir);\n\t}\n\tset_page_dirty(page);\n\n\tif (IS_DIRSYNC(dir))\n\t\terr = write_one_page(page, 1);\n\telse\n\t\tunlock_page(page);\n\n\treturn err;\n}"
  },
  {
    "function_name": "exofs_last_byte",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
    "lines": "53-61",
    "snippet": "static unsigned exofs_last_byte(struct inode *inode, unsigned long page_nr)\n{\n\tloff_t last_byte = inode->i_size;\n\n\tlast_byte -= page_nr << PAGE_CACHE_SHIFT;\n\tif (last_byte > PAGE_CACHE_SIZE)\n\t\tlast_byte = PAGE_CACHE_SIZE;\n\treturn last_byte;\n}",
    "includes": [
      "#include \"exofs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"exofs.h\"\n\nstatic unsigned exofs_last_byte(struct inode *inode, unsigned long page_nr)\n{\n\tloff_t last_byte = inode->i_size;\n\n\tlast_byte -= page_nr << PAGE_CACHE_SHIFT;\n\tif (last_byte > PAGE_CACHE_SIZE)\n\t\tlast_byte = PAGE_CACHE_SIZE;\n\treturn last_byte;\n}"
  },
  {
    "function_name": "dir_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
    "lines": "48-51",
    "snippet": "static inline unsigned long dir_pages(struct inode *inode)\n{\n\treturn (inode->i_size + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;\n}",
    "includes": [
      "#include \"exofs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"exofs.h\"\n\nstatic inline unsigned long dir_pages(struct inode *inode)\n{\n\treturn (inode->i_size + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;\n}"
  },
  {
    "function_name": "exofs_put_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
    "lines": "41-45",
    "snippet": "static inline void exofs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}",
    "includes": [
      "#include \"exofs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap",
          "args": [
            "page"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"exofs.h\"\n\nstatic inline void exofs_put_page(struct page *page)\n{\n\tkunmap(page);\n\tpage_cache_release(page);\n}"
  },
  {
    "function_name": "exofs_chunk_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/exofs/dir.c",
    "lines": "36-39",
    "snippet": "static inline unsigned exofs_chunk_size(struct inode *inode)\n{\n\treturn inode->i_sb->s_blocksize;\n}",
    "includes": [
      "#include \"exofs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"exofs.h\"\n\nstatic inline unsigned exofs_chunk_size(struct inode *inode)\n{\n\treturn inode->i_sb->s_blocksize;\n}"
  }
]