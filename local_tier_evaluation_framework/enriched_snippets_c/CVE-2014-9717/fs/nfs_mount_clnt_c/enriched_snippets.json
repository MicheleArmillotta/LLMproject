[
  {
    "function_name": "mnt_xdr_dec_mountres3",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/mount_clnt.c",
    "lines": "452-467",
    "snippet": "static int mnt_xdr_dec_mountres3(struct rpc_rqst *req,\n\t\t\t\t struct xdr_stream *xdr,\n\t\t\t\t struct mountres *res)\n{\n\tint status;\n\n\tstatus = decode_fhs_status(xdr, res);\n\tif (unlikely(status != 0 || res->errno != 0))\n\t\treturn status;\n\tstatus = decode_fhandle3(xdr, res);\n\tif (unlikely(status != 0)) {\n\t\tres->errno = -EBADHANDLE;\n\t\treturn 0;\n\t}\n\treturn decode_auth_flavors(xdr, res);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/sched.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/in.h>",
      "#include <linux/net.h>",
      "#include <linux/uio.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/socket.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "decode_auth_flavors",
          "args": [
            "xdr",
            "res"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "decode_auth_flavors",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/mount_clnt.c",
          "lines": "418-450",
          "snippet": "static int decode_auth_flavors(struct xdr_stream *xdr, struct mountres *res)\n{\n\trpc_authflavor_t *flavors = res->auth_flavors;\n\tunsigned int *count = res->auth_count;\n\tu32 entries, i;\n\t__be32 *p;\n\n\tif (*count == 0)\n\t\treturn 0;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\treturn -EIO;\n\tentries = be32_to_cpup(p);\n\tdprintk(\"NFS: received %u auth flavors\\n\", entries);\n\tif (entries > NFS_MAX_SECFLAVORS)\n\t\tentries = NFS_MAX_SECFLAVORS;\n\n\tp = xdr_inline_decode(xdr, 4 * entries);\n\tif (unlikely(p == NULL))\n\t\treturn -EIO;\n\n\tif (entries > *count)\n\t\tentries = *count;\n\n\tfor (i = 0; i < entries; i++) {\n\t\tflavors[i] = be32_to_cpup(p++);\n\t\tdprintk(\"NFS:   auth flavor[%u]: %d\\n\", i, flavors[i]);\n\t}\n\t*count = i;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/sched.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/in.h>",
            "#include <linux/net.h>",
            "#include <linux/uio.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/socket.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in.h>\n#include <linux/net.h>\n#include <linux/uio.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/socket.h>\n#include <linux/types.h>\n\nstatic int decode_auth_flavors(struct xdr_stream *xdr, struct mountres *res)\n{\n\trpc_authflavor_t *flavors = res->auth_flavors;\n\tunsigned int *count = res->auth_count;\n\tu32 entries, i;\n\t__be32 *p;\n\n\tif (*count == 0)\n\t\treturn 0;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\treturn -EIO;\n\tentries = be32_to_cpup(p);\n\tdprintk(\"NFS: received %u auth flavors\\n\", entries);\n\tif (entries > NFS_MAX_SECFLAVORS)\n\t\tentries = NFS_MAX_SECFLAVORS;\n\n\tp = xdr_inline_decode(xdr, 4 * entries);\n\tif (unlikely(p == NULL))\n\t\treturn -EIO;\n\n\tif (entries > *count)\n\t\tentries = *count;\n\n\tfor (i = 0; i < entries; i++) {\n\t\tflavors[i] = be32_to_cpup(p++);\n\t\tdprintk(\"NFS:   auth flavor[%u]: %d\\n\", i, flavors[i]);\n\t}\n\t*count = i;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "status != 0"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decode_fhandle3",
          "args": [
            "xdr",
            "res"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "decode_fhandle3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/mount_clnt.c",
          "lines": "395-416",
          "snippet": "static int decode_fhandle3(struct xdr_stream *xdr, struct mountres *res)\n{\n\tstruct nfs_fh *fh = res->fh;\n\tu32 size;\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\treturn -EIO;\n\n\tsize = be32_to_cpup(p);\n\tif (size > NFS3_FHSIZE || size == 0)\n\t\treturn -EIO;\n\n\tp = xdr_inline_decode(xdr, size);\n\tif (unlikely(p == NULL))\n\t\treturn -EIO;\n\n\tfh->size = size;\n\tmemcpy(fh->data, p, size);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/sched.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/in.h>",
            "#include <linux/net.h>",
            "#include <linux/uio.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/socket.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in.h>\n#include <linux/net.h>\n#include <linux/uio.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/socket.h>\n#include <linux/types.h>\n\nstatic int decode_fhandle3(struct xdr_stream *xdr, struct mountres *res)\n{\n\tstruct nfs_fh *fh = res->fh;\n\tu32 size;\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\treturn -EIO;\n\n\tsize = be32_to_cpup(p);\n\tif (size > NFS3_FHSIZE || size == 0)\n\t\treturn -EIO;\n\n\tp = xdr_inline_decode(xdr, size);\n\tif (unlikely(p == NULL))\n\t\treturn -EIO;\n\n\tfh->size = size;\n\tmemcpy(fh->data, p, size);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "status != 0 || res->errno != 0"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decode_fhs_status",
          "args": [
            "xdr",
            "res"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "decode_fhs_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/mount_clnt.c",
          "lines": "372-393",
          "snippet": "static int decode_fhs_status(struct xdr_stream *xdr, struct mountres *res)\n{\n\tunsigned int i;\n\tu32 status;\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\treturn -EIO;\n\tstatus = be32_to_cpup(p);\n\n\tfor (i = 0; i < ARRAY_SIZE(mnt3_errtbl); i++) {\n\t\tif (mnt3_errtbl[i].status == status) {\n\t\t\tres->errno = mnt3_errtbl[i].errno;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tdprintk(\"NFS: unrecognized MNT3 status code: %u\\n\", status);\n\tres->errno = -EACCES;\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/sched.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/in.h>",
            "#include <linux/net.h>",
            "#include <linux/uio.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/socket.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tu32 status;\n\tint errno;\n} mnt3_errtbl[] = {\n\t{ .status = MNT3_OK,\t\t\t.errno = 0,\t\t},\n\t{ .status = MNT3ERR_PERM,\t\t.errno = -EPERM,\t},\n\t{ .status = MNT3ERR_NOENT,\t\t.errno = -ENOENT,\t},\n\t{ .status = MNT3ERR_IO,\t\t\t.errno = -EIO,\t\t},\n\t{ .status = MNT3ERR_ACCES,\t\t.errno = -EACCES,\t},\n\t{ .status = MNT3ERR_NOTDIR,\t\t.errno = -ENOTDIR,\t},\n\t{ .status = MNT3ERR_INVAL,\t\t.errno = -EINVAL,\t},\n\t{ .status = MNT3ERR_NAMETOOLONG,\t.errno = -ENAMETOOLONG,\t},\n\t{ .status = MNT3ERR_NOTSUPP,\t\t.errno = -ENOTSUPP,\t},\n\t{ .status = MNT3ERR_SERVERFAULT,\t.errno = -EREMOTEIO,\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in.h>\n#include <linux/net.h>\n#include <linux/uio.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/socket.h>\n#include <linux/types.h>\n\nstatic struct {\n\tu32 status;\n\tint errno;\n} mnt3_errtbl[] = {\n\t{ .status = MNT3_OK,\t\t\t.errno = 0,\t\t},\n\t{ .status = MNT3ERR_PERM,\t\t.errno = -EPERM,\t},\n\t{ .status = MNT3ERR_NOENT,\t\t.errno = -ENOENT,\t},\n\t{ .status = MNT3ERR_IO,\t\t\t.errno = -EIO,\t\t},\n\t{ .status = MNT3ERR_ACCES,\t\t.errno = -EACCES,\t},\n\t{ .status = MNT3ERR_NOTDIR,\t\t.errno = -ENOTDIR,\t},\n\t{ .status = MNT3ERR_INVAL,\t\t.errno = -EINVAL,\t},\n\t{ .status = MNT3ERR_NAMETOOLONG,\t.errno = -ENAMETOOLONG,\t},\n\t{ .status = MNT3ERR_NOTSUPP,\t\t.errno = -ENOTSUPP,\t},\n\t{ .status = MNT3ERR_SERVERFAULT,\t.errno = -EREMOTEIO,\t},\n};\n\nstatic int decode_fhs_status(struct xdr_stream *xdr, struct mountres *res)\n{\n\tunsigned int i;\n\tu32 status;\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\treturn -EIO;\n\tstatus = be32_to_cpup(p);\n\n\tfor (i = 0; i < ARRAY_SIZE(mnt3_errtbl); i++) {\n\t\tif (mnt3_errtbl[i].status == status) {\n\t\t\tres->errno = mnt3_errtbl[i].errno;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tdprintk(\"NFS: unrecognized MNT3 status code: %u\\n\", status);\n\tres->errno = -EACCES;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in.h>\n#include <linux/net.h>\n#include <linux/uio.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/socket.h>\n#include <linux/types.h>\n\nstatic int mnt_xdr_dec_mountres3(struct rpc_rqst *req,\n\t\t\t\t struct xdr_stream *xdr,\n\t\t\t\t struct mountres *res)\n{\n\tint status;\n\n\tstatus = decode_fhs_status(xdr, res);\n\tif (unlikely(status != 0 || res->errno != 0))\n\t\treturn status;\n\tstatus = decode_fhandle3(xdr, res);\n\tif (unlikely(status != 0)) {\n\t\tres->errno = -EBADHANDLE;\n\t\treturn 0;\n\t}\n\treturn decode_auth_flavors(xdr, res);\n}"
  },
  {
    "function_name": "decode_auth_flavors",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/mount_clnt.c",
    "lines": "418-450",
    "snippet": "static int decode_auth_flavors(struct xdr_stream *xdr, struct mountres *res)\n{\n\trpc_authflavor_t *flavors = res->auth_flavors;\n\tunsigned int *count = res->auth_count;\n\tu32 entries, i;\n\t__be32 *p;\n\n\tif (*count == 0)\n\t\treturn 0;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\treturn -EIO;\n\tentries = be32_to_cpup(p);\n\tdprintk(\"NFS: received %u auth flavors\\n\", entries);\n\tif (entries > NFS_MAX_SECFLAVORS)\n\t\tentries = NFS_MAX_SECFLAVORS;\n\n\tp = xdr_inline_decode(xdr, 4 * entries);\n\tif (unlikely(p == NULL))\n\t\treturn -EIO;\n\n\tif (entries > *count)\n\t\tentries = *count;\n\n\tfor (i = 0; i < entries; i++) {\n\t\tflavors[i] = be32_to_cpup(p++);\n\t\tdprintk(\"NFS:   auth flavor[%u]: %d\\n\", i, flavors[i]);\n\t}\n\t*count = i;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/sched.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/in.h>",
      "#include <linux/net.h>",
      "#include <linux/uio.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/socket.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFS:   auth flavor[%u]: %d\\n\"",
            "i",
            "flavors[i]"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p++"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p == NULL"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_inline_decode",
          "args": [
            "xdr",
            "4 * entries"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFS: received %u auth flavors\\n\"",
            "entries"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p == NULL"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_inline_decode",
          "args": [
            "xdr",
            "4"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in.h>\n#include <linux/net.h>\n#include <linux/uio.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/socket.h>\n#include <linux/types.h>\n\nstatic int decode_auth_flavors(struct xdr_stream *xdr, struct mountres *res)\n{\n\trpc_authflavor_t *flavors = res->auth_flavors;\n\tunsigned int *count = res->auth_count;\n\tu32 entries, i;\n\t__be32 *p;\n\n\tif (*count == 0)\n\t\treturn 0;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\treturn -EIO;\n\tentries = be32_to_cpup(p);\n\tdprintk(\"NFS: received %u auth flavors\\n\", entries);\n\tif (entries > NFS_MAX_SECFLAVORS)\n\t\tentries = NFS_MAX_SECFLAVORS;\n\n\tp = xdr_inline_decode(xdr, 4 * entries);\n\tif (unlikely(p == NULL))\n\t\treturn -EIO;\n\n\tif (entries > *count)\n\t\tentries = *count;\n\n\tfor (i = 0; i < entries; i++) {\n\t\tflavors[i] = be32_to_cpup(p++);\n\t\tdprintk(\"NFS:   auth flavor[%u]: %d\\n\", i, flavors[i]);\n\t}\n\t*count = i;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "decode_fhandle3",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/mount_clnt.c",
    "lines": "395-416",
    "snippet": "static int decode_fhandle3(struct xdr_stream *xdr, struct mountres *res)\n{\n\tstruct nfs_fh *fh = res->fh;\n\tu32 size;\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\treturn -EIO;\n\n\tsize = be32_to_cpup(p);\n\tif (size > NFS3_FHSIZE || size == 0)\n\t\treturn -EIO;\n\n\tp = xdr_inline_decode(xdr, size);\n\tif (unlikely(p == NULL))\n\t\treturn -EIO;\n\n\tfh->size = size;\n\tmemcpy(fh->data, p, size);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/sched.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/in.h>",
      "#include <linux/net.h>",
      "#include <linux/uio.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/socket.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "fh->data",
            "p",
            "size"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p == NULL"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_inline_decode",
          "args": [
            "xdr",
            "size"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p == NULL"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_inline_decode",
          "args": [
            "xdr",
            "4"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in.h>\n#include <linux/net.h>\n#include <linux/uio.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/socket.h>\n#include <linux/types.h>\n\nstatic int decode_fhandle3(struct xdr_stream *xdr, struct mountres *res)\n{\n\tstruct nfs_fh *fh = res->fh;\n\tu32 size;\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\treturn -EIO;\n\n\tsize = be32_to_cpup(p);\n\tif (size > NFS3_FHSIZE || size == 0)\n\t\treturn -EIO;\n\n\tp = xdr_inline_decode(xdr, size);\n\tif (unlikely(p == NULL))\n\t\treturn -EIO;\n\n\tfh->size = size;\n\tmemcpy(fh->data, p, size);\n\treturn 0;\n}"
  },
  {
    "function_name": "decode_fhs_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/mount_clnt.c",
    "lines": "372-393",
    "snippet": "static int decode_fhs_status(struct xdr_stream *xdr, struct mountres *res)\n{\n\tunsigned int i;\n\tu32 status;\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\treturn -EIO;\n\tstatus = be32_to_cpup(p);\n\n\tfor (i = 0; i < ARRAY_SIZE(mnt3_errtbl); i++) {\n\t\tif (mnt3_errtbl[i].status == status) {\n\t\t\tres->errno = mnt3_errtbl[i].errno;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tdprintk(\"NFS: unrecognized MNT3 status code: %u\\n\", status);\n\tres->errno = -EACCES;\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/sched.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/in.h>",
      "#include <linux/net.h>",
      "#include <linux/uio.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/socket.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct {\n\tu32 status;\n\tint errno;\n} mnt3_errtbl[] = {\n\t{ .status = MNT3_OK,\t\t\t.errno = 0,\t\t},\n\t{ .status = MNT3ERR_PERM,\t\t.errno = -EPERM,\t},\n\t{ .status = MNT3ERR_NOENT,\t\t.errno = -ENOENT,\t},\n\t{ .status = MNT3ERR_IO,\t\t\t.errno = -EIO,\t\t},\n\t{ .status = MNT3ERR_ACCES,\t\t.errno = -EACCES,\t},\n\t{ .status = MNT3ERR_NOTDIR,\t\t.errno = -ENOTDIR,\t},\n\t{ .status = MNT3ERR_INVAL,\t\t.errno = -EINVAL,\t},\n\t{ .status = MNT3ERR_NAMETOOLONG,\t.errno = -ENAMETOOLONG,\t},\n\t{ .status = MNT3ERR_NOTSUPP,\t\t.errno = -ENOTSUPP,\t},\n\t{ .status = MNT3ERR_SERVERFAULT,\t.errno = -EREMOTEIO,\t},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFS: unrecognized MNT3 status code: %u\\n\"",
            "status"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "mnt3_errtbl"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p == NULL"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_inline_decode",
          "args": [
            "xdr",
            "4"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in.h>\n#include <linux/net.h>\n#include <linux/uio.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/socket.h>\n#include <linux/types.h>\n\nstatic struct {\n\tu32 status;\n\tint errno;\n} mnt3_errtbl[] = {\n\t{ .status = MNT3_OK,\t\t\t.errno = 0,\t\t},\n\t{ .status = MNT3ERR_PERM,\t\t.errno = -EPERM,\t},\n\t{ .status = MNT3ERR_NOENT,\t\t.errno = -ENOENT,\t},\n\t{ .status = MNT3ERR_IO,\t\t\t.errno = -EIO,\t\t},\n\t{ .status = MNT3ERR_ACCES,\t\t.errno = -EACCES,\t},\n\t{ .status = MNT3ERR_NOTDIR,\t\t.errno = -ENOTDIR,\t},\n\t{ .status = MNT3ERR_INVAL,\t\t.errno = -EINVAL,\t},\n\t{ .status = MNT3ERR_NAMETOOLONG,\t.errno = -ENAMETOOLONG,\t},\n\t{ .status = MNT3ERR_NOTSUPP,\t\t.errno = -ENOTSUPP,\t},\n\t{ .status = MNT3ERR_SERVERFAULT,\t.errno = -EREMOTEIO,\t},\n};\n\nstatic int decode_fhs_status(struct xdr_stream *xdr, struct mountres *res)\n{\n\tunsigned int i;\n\tu32 status;\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\treturn -EIO;\n\tstatus = be32_to_cpup(p);\n\n\tfor (i = 0; i < ARRAY_SIZE(mnt3_errtbl); i++) {\n\t\tif (mnt3_errtbl[i].status == status) {\n\t\t\tres->errno = mnt3_errtbl[i].errno;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tdprintk(\"NFS: unrecognized MNT3 status code: %u\\n\", status);\n\tres->errno = -EACCES;\n\treturn 0;\n}"
  },
  {
    "function_name": "mnt_xdr_dec_mountres",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/mount_clnt.c",
    "lines": "360-370",
    "snippet": "static int mnt_xdr_dec_mountres(struct rpc_rqst *req,\n\t\t\t\tstruct xdr_stream *xdr,\n\t\t\t\tstruct mountres *res)\n{\n\tint status;\n\n\tstatus = decode_status(xdr, res);\n\tif (unlikely(status != 0 || res->errno != 0))\n\t\treturn status;\n\treturn decode_fhandle(xdr, res);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/sched.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/in.h>",
      "#include <linux/net.h>",
      "#include <linux/uio.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/socket.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "decode_fhandle",
          "args": [
            "xdr",
            "res"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "decode_fhandle3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/mount_clnt.c",
          "lines": "395-416",
          "snippet": "static int decode_fhandle3(struct xdr_stream *xdr, struct mountres *res)\n{\n\tstruct nfs_fh *fh = res->fh;\n\tu32 size;\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\treturn -EIO;\n\n\tsize = be32_to_cpup(p);\n\tif (size > NFS3_FHSIZE || size == 0)\n\t\treturn -EIO;\n\n\tp = xdr_inline_decode(xdr, size);\n\tif (unlikely(p == NULL))\n\t\treturn -EIO;\n\n\tfh->size = size;\n\tmemcpy(fh->data, p, size);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/sched.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/in.h>",
            "#include <linux/net.h>",
            "#include <linux/uio.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/socket.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in.h>\n#include <linux/net.h>\n#include <linux/uio.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/socket.h>\n#include <linux/types.h>\n\nstatic int decode_fhandle3(struct xdr_stream *xdr, struct mountres *res)\n{\n\tstruct nfs_fh *fh = res->fh;\n\tu32 size;\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\treturn -EIO;\n\n\tsize = be32_to_cpup(p);\n\tif (size > NFS3_FHSIZE || size == 0)\n\t\treturn -EIO;\n\n\tp = xdr_inline_decode(xdr, size);\n\tif (unlikely(p == NULL))\n\t\treturn -EIO;\n\n\tfh->size = size;\n\tmemcpy(fh->data, p, size);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "status != 0 || res->errno != 0"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decode_status",
          "args": [
            "xdr",
            "res"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "decode_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/mount_clnt.c",
          "lines": "323-344",
          "snippet": "static int decode_status(struct xdr_stream *xdr, struct mountres *res)\n{\n\tunsigned int i;\n\tu32 status;\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\treturn -EIO;\n\tstatus = be32_to_cpup(p);\n\n\tfor (i = 0; i < ARRAY_SIZE(mnt_errtbl); i++) {\n\t\tif (mnt_errtbl[i].status == status) {\n\t\t\tres->errno = mnt_errtbl[i].errno;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tdprintk(\"NFS: unrecognized MNT status code: %u\\n\", status);\n\tres->errno = -EACCES;\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/sched.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/in.h>",
            "#include <linux/net.h>",
            "#include <linux/uio.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/socket.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n\tu32 status;\n\tint errno;\n} mnt_errtbl[] = {\n\t{ .status = MNT_OK,\t\t\t.errno = 0,\t\t},\n\t{ .status = MNT_EPERM,\t\t\t.errno = -EPERM,\t},\n\t{ .status = MNT_ENOENT,\t\t\t.errno = -ENOENT,\t},\n\t{ .status = MNT_EACCES,\t\t\t.errno = -EACCES,\t},\n\t{ .status = MNT_EINVAL,\t\t\t.errno = -EINVAL,\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in.h>\n#include <linux/net.h>\n#include <linux/uio.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/socket.h>\n#include <linux/types.h>\n\nstatic struct {\n\tu32 status;\n\tint errno;\n} mnt_errtbl[] = {\n\t{ .status = MNT_OK,\t\t\t.errno = 0,\t\t},\n\t{ .status = MNT_EPERM,\t\t\t.errno = -EPERM,\t},\n\t{ .status = MNT_ENOENT,\t\t\t.errno = -ENOENT,\t},\n\t{ .status = MNT_EACCES,\t\t\t.errno = -EACCES,\t},\n\t{ .status = MNT_EINVAL,\t\t\t.errno = -EINVAL,\t},\n};\n\nstatic int decode_status(struct xdr_stream *xdr, struct mountres *res)\n{\n\tunsigned int i;\n\tu32 status;\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\treturn -EIO;\n\tstatus = be32_to_cpup(p);\n\n\tfor (i = 0; i < ARRAY_SIZE(mnt_errtbl); i++) {\n\t\tif (mnt_errtbl[i].status == status) {\n\t\t\tres->errno = mnt_errtbl[i].errno;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tdprintk(\"NFS: unrecognized MNT status code: %u\\n\", status);\n\tres->errno = -EACCES;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in.h>\n#include <linux/net.h>\n#include <linux/uio.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/socket.h>\n#include <linux/types.h>\n\nstatic int mnt_xdr_dec_mountres(struct rpc_rqst *req,\n\t\t\t\tstruct xdr_stream *xdr,\n\t\t\t\tstruct mountres *res)\n{\n\tint status;\n\n\tstatus = decode_status(xdr, res);\n\tif (unlikely(status != 0 || res->errno != 0))\n\t\treturn status;\n\treturn decode_fhandle(xdr, res);\n}"
  },
  {
    "function_name": "decode_fhandle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/mount_clnt.c",
    "lines": "346-358",
    "snippet": "static int decode_fhandle(struct xdr_stream *xdr, struct mountres *res)\n{\n\tstruct nfs_fh *fh = res->fh;\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, NFS2_FHSIZE);\n\tif (unlikely(p == NULL))\n\t\treturn -EIO;\n\n\tfh->size = NFS2_FHSIZE;\n\tmemcpy(fh->data, p, NFS2_FHSIZE);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/sched.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/in.h>",
      "#include <linux/net.h>",
      "#include <linux/uio.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/socket.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "fh->data",
            "p",
            "NFS2_FHSIZE"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p == NULL"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_inline_decode",
          "args": [
            "xdr",
            "NFS2_FHSIZE"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in.h>\n#include <linux/net.h>\n#include <linux/uio.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/socket.h>\n#include <linux/types.h>\n\nstatic int decode_fhandle(struct xdr_stream *xdr, struct mountres *res)\n{\n\tstruct nfs_fh *fh = res->fh;\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, NFS2_FHSIZE);\n\tif (unlikely(p == NULL))\n\t\treturn -EIO;\n\n\tfh->size = NFS2_FHSIZE;\n\tmemcpy(fh->data, p, NFS2_FHSIZE);\n\treturn 0;\n}"
  },
  {
    "function_name": "decode_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/mount_clnt.c",
    "lines": "323-344",
    "snippet": "static int decode_status(struct xdr_stream *xdr, struct mountres *res)\n{\n\tunsigned int i;\n\tu32 status;\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\treturn -EIO;\n\tstatus = be32_to_cpup(p);\n\n\tfor (i = 0; i < ARRAY_SIZE(mnt_errtbl); i++) {\n\t\tif (mnt_errtbl[i].status == status) {\n\t\t\tres->errno = mnt_errtbl[i].errno;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tdprintk(\"NFS: unrecognized MNT status code: %u\\n\", status);\n\tres->errno = -EACCES;\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/sched.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/in.h>",
      "#include <linux/net.h>",
      "#include <linux/uio.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/socket.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct {\n\tu32 status;\n\tint errno;\n} mnt_errtbl[] = {\n\t{ .status = MNT_OK,\t\t\t.errno = 0,\t\t},\n\t{ .status = MNT_EPERM,\t\t\t.errno = -EPERM,\t},\n\t{ .status = MNT_ENOENT,\t\t\t.errno = -ENOENT,\t},\n\t{ .status = MNT_EACCES,\t\t\t.errno = -EACCES,\t},\n\t{ .status = MNT_EINVAL,\t\t\t.errno = -EINVAL,\t},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFS: unrecognized MNT status code: %u\\n\"",
            "status"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "mnt_errtbl"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpup",
          "args": [
            "p"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "p == NULL"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_inline_decode",
          "args": [
            "xdr",
            "4"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in.h>\n#include <linux/net.h>\n#include <linux/uio.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/socket.h>\n#include <linux/types.h>\n\nstatic struct {\n\tu32 status;\n\tint errno;\n} mnt_errtbl[] = {\n\t{ .status = MNT_OK,\t\t\t.errno = 0,\t\t},\n\t{ .status = MNT_EPERM,\t\t\t.errno = -EPERM,\t},\n\t{ .status = MNT_ENOENT,\t\t\t.errno = -ENOENT,\t},\n\t{ .status = MNT_EACCES,\t\t\t.errno = -EACCES,\t},\n\t{ .status = MNT_EINVAL,\t\t\t.errno = -EINVAL,\t},\n};\n\nstatic int decode_status(struct xdr_stream *xdr, struct mountres *res)\n{\n\tunsigned int i;\n\tu32 status;\n\t__be32 *p;\n\n\tp = xdr_inline_decode(xdr, 4);\n\tif (unlikely(p == NULL))\n\t\treturn -EIO;\n\tstatus = be32_to_cpup(p);\n\n\tfor (i = 0; i < ARRAY_SIZE(mnt_errtbl); i++) {\n\t\tif (mnt_errtbl[i].status == status) {\n\t\t\tres->errno = mnt_errtbl[i].errno;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tdprintk(\"NFS: unrecognized MNT status code: %u\\n\", status);\n\tres->errno = -EACCES;\n\treturn 0;\n}"
  },
  {
    "function_name": "mnt_xdr_enc_dirpath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/mount_clnt.c",
    "lines": "308-312",
    "snippet": "static void mnt_xdr_enc_dirpath(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\tconst char *dirpath)\n{\n\tencode_mntdirpath(xdr, dirpath);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/sched.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/in.h>",
      "#include <linux/net.h>",
      "#include <linux/uio.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/socket.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "encode_mntdirpath",
          "args": [
            "xdr",
            "dirpath"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "encode_mntdirpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/mount_clnt.c",
          "lines": "299-306",
          "snippet": "static void encode_mntdirpath(struct xdr_stream *xdr, const char *pathname)\n{\n\tconst u32 pathname_len = strlen(pathname);\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4 + pathname_len);\n\txdr_encode_opaque(p, pathname, pathname_len);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/nfs_fs.h>",
            "#include <linux/sunrpc/sched.h>",
            "#include <linux/sunrpc/clnt.h>",
            "#include <linux/in.h>",
            "#include <linux/net.h>",
            "#include <linux/uio.h>",
            "#include <linux/errno.h>",
            "#include <linux/kernel.h>",
            "#include <linux/socket.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in.h>\n#include <linux/net.h>\n#include <linux/uio.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/socket.h>\n#include <linux/types.h>\n\nstatic void encode_mntdirpath(struct xdr_stream *xdr, const char *pathname)\n{\n\tconst u32 pathname_len = strlen(pathname);\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4 + pathname_len);\n\txdr_encode_opaque(p, pathname, pathname_len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in.h>\n#include <linux/net.h>\n#include <linux/uio.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/socket.h>\n#include <linux/types.h>\n\nstatic void mnt_xdr_enc_dirpath(struct rpc_rqst *req, struct xdr_stream *xdr,\n\t\t\t\tconst char *dirpath)\n{\n\tencode_mntdirpath(xdr, dirpath);\n}"
  },
  {
    "function_name": "encode_mntdirpath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/mount_clnt.c",
    "lines": "299-306",
    "snippet": "static void encode_mntdirpath(struct xdr_stream *xdr, const char *pathname)\n{\n\tconst u32 pathname_len = strlen(pathname);\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4 + pathname_len);\n\txdr_encode_opaque(p, pathname, pathname_len);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/sched.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/in.h>",
      "#include <linux/net.h>",
      "#include <linux/uio.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/socket.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xdr_encode_opaque",
          "args": [
            "p",
            "pathname",
            "pathname_len"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xdr_reserve_space",
          "args": [
            "xdr",
            "4 + pathname_len"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "pathname"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in.h>\n#include <linux/net.h>\n#include <linux/uio.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/socket.h>\n#include <linux/types.h>\n\nstatic void encode_mntdirpath(struct xdr_stream *xdr, const char *pathname)\n{\n\tconst u32 pathname_len = strlen(pathname);\n\t__be32 *p;\n\n\tp = xdr_reserve_space(xdr, 4 + pathname_len);\n\txdr_encode_opaque(p, pathname, pathname_len);\n}"
  },
  {
    "function_name": "nfs_umount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/mount_clnt.c",
    "lines": "235-293",
    "snippet": "void nfs_umount(const struct nfs_mount_request *info)\n{\n\tstatic const struct rpc_timeout nfs_umnt_timeout = {\n\t\t.to_initval = 1 * HZ,\n\t\t.to_maxval = 3 * HZ,\n\t\t.to_retries = 2,\n\t};\n\tstruct rpc_create_args args = {\n\t\t.net\t\t= info->net,\n\t\t.protocol\t= IPPROTO_UDP,\n\t\t.address\t= info->sap,\n\t\t.addrsize\t= info->salen,\n\t\t.timeout\t= &nfs_umnt_timeout,\n\t\t.servername\t= info->hostname,\n\t\t.program\t= &mnt_program,\n\t\t.version\t= info->version,\n\t\t.authflavor\t= RPC_AUTH_UNIX,\n\t\t.flags\t\t= RPC_CLNT_CREATE_NOPING,\n\t};\n\tstruct rpc_message msg\t= {\n\t\t.rpc_argp\t= info->dirpath,\n\t};\n\tstruct rpc_clnt *clnt;\n\tint status;\n\n\tif (strlen(info->dirpath) > MNTPATHLEN)\n\t\treturn;\n\n\tif (info->noresvport)\n\t\targs.flags |= RPC_CLNT_CREATE_NONPRIVPORT;\n\n\tclnt = rpc_create(&args);\n\tif (IS_ERR(clnt))\n\t\tgoto out_clnt_err;\n\n\tdprintk(\"NFS: sending UMNT request for %s:%s\\n\",\n\t\t(info->hostname ? info->hostname : \"server\"), info->dirpath);\n\n\tif (info->version == NFS_MNT3_VERSION)\n\t\tmsg.rpc_proc = &clnt->cl_procinfo[MOUNTPROC3_UMNT];\n\telse\n\t\tmsg.rpc_proc = &clnt->cl_procinfo[MOUNTPROC_UMNT];\n\n\tstatus = rpc_call_sync(clnt, &msg, 0);\n\trpc_shutdown_client(clnt);\n\n\tif (unlikely(status < 0))\n\t\tgoto out_call_err;\n\n\treturn;\n\nout_clnt_err:\n\tdprintk(\"NFS: failed to create UMNT RPC client, status=%ld\\n\",\n\t\t\tPTR_ERR(clnt));\n\treturn;\n\nout_call_err:\n\tdprintk(\"NFS: UMNT request failed, status=%d\\n\", status);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/sched.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/in.h>",
      "#include <linux/net.h>",
      "#include <linux/uio.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/socket.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define MNTPATHLEN\t\t(1024)"
    ],
    "globals_used": [
      "static const struct rpc_program mnt_program;",
      "static const struct rpc_program mnt_program = {\n\t.name\t\t= \"mount\",\n\t.number\t\t= NFS_MNT_PROGRAM,\n\t.nrvers\t\t= ARRAY_SIZE(mnt_version),\n\t.version\t= mnt_version,\n\t.stats\t\t= &mnt_stats,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFS: UMNT request failed, status=%d\\n\"",
            "status"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFS: failed to create UMNT RPC client, status=%ld\\n\"",
            "PTR_ERR(clnt)"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "clnt"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "status < 0"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_shutdown_client",
          "args": [
            "clnt"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_call_sync",
          "args": [
            "clnt",
            "&msg",
            "0"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFS: sending UMNT request for %s:%s\\n\"",
            "(info->hostname ? info->hostname : \"server\")",
            "info->dirpath"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "clnt"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_create",
          "args": [
            "&args"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "info->dirpath"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in.h>\n#include <linux/net.h>\n#include <linux/uio.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/socket.h>\n#include <linux/types.h>\n\n#define MNTPATHLEN\t\t(1024)\n\nstatic const struct rpc_program mnt_program;\nstatic const struct rpc_program mnt_program = {\n\t.name\t\t= \"mount\",\n\t.number\t\t= NFS_MNT_PROGRAM,\n\t.nrvers\t\t= ARRAY_SIZE(mnt_version),\n\t.version\t= mnt_version,\n\t.stats\t\t= &mnt_stats,\n};\n\nvoid nfs_umount(const struct nfs_mount_request *info)\n{\n\tstatic const struct rpc_timeout nfs_umnt_timeout = {\n\t\t.to_initval = 1 * HZ,\n\t\t.to_maxval = 3 * HZ,\n\t\t.to_retries = 2,\n\t};\n\tstruct rpc_create_args args = {\n\t\t.net\t\t= info->net,\n\t\t.protocol\t= IPPROTO_UDP,\n\t\t.address\t= info->sap,\n\t\t.addrsize\t= info->salen,\n\t\t.timeout\t= &nfs_umnt_timeout,\n\t\t.servername\t= info->hostname,\n\t\t.program\t= &mnt_program,\n\t\t.version\t= info->version,\n\t\t.authflavor\t= RPC_AUTH_UNIX,\n\t\t.flags\t\t= RPC_CLNT_CREATE_NOPING,\n\t};\n\tstruct rpc_message msg\t= {\n\t\t.rpc_argp\t= info->dirpath,\n\t};\n\tstruct rpc_clnt *clnt;\n\tint status;\n\n\tif (strlen(info->dirpath) > MNTPATHLEN)\n\t\treturn;\n\n\tif (info->noresvport)\n\t\targs.flags |= RPC_CLNT_CREATE_NONPRIVPORT;\n\n\tclnt = rpc_create(&args);\n\tif (IS_ERR(clnt))\n\t\tgoto out_clnt_err;\n\n\tdprintk(\"NFS: sending UMNT request for %s:%s\\n\",\n\t\t(info->hostname ? info->hostname : \"server\"), info->dirpath);\n\n\tif (info->version == NFS_MNT3_VERSION)\n\t\tmsg.rpc_proc = &clnt->cl_procinfo[MOUNTPROC3_UMNT];\n\telse\n\t\tmsg.rpc_proc = &clnt->cl_procinfo[MOUNTPROC_UMNT];\n\n\tstatus = rpc_call_sync(clnt, &msg, 0);\n\trpc_shutdown_client(clnt);\n\n\tif (unlikely(status < 0))\n\t\tgoto out_call_err;\n\n\treturn;\n\nout_clnt_err:\n\tdprintk(\"NFS: failed to create UMNT RPC client, status=%ld\\n\",\n\t\t\tPTR_ERR(clnt));\n\treturn;\n\nout_call_err:\n\tdprintk(\"NFS: UMNT request failed, status=%d\\n\", status);\n}"
  },
  {
    "function_name": "nfs_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/nfs/mount_clnt.c",
    "lines": "147-226",
    "snippet": "int nfs_mount(struct nfs_mount_request *info)\n{\n\tstruct mountres\tresult = {\n\t\t.fh\t\t= info->fh,\n\t\t.auth_count\t= info->auth_flav_len,\n\t\t.auth_flavors\t= info->auth_flavs,\n\t};\n\tstruct rpc_message msg\t= {\n\t\t.rpc_argp\t= info->dirpath,\n\t\t.rpc_resp\t= &result,\n\t};\n\tstruct rpc_create_args args = {\n\t\t.net\t\t= info->net,\n\t\t.protocol\t= info->protocol,\n\t\t.address\t= info->sap,\n\t\t.addrsize\t= info->salen,\n\t\t.servername\t= info->hostname,\n\t\t.program\t= &mnt_program,\n\t\t.version\t= info->version,\n\t\t.authflavor\t= RPC_AUTH_UNIX,\n\t};\n\tstruct rpc_clnt\t\t*mnt_clnt;\n\tint\t\t\tstatus;\n\n\tdprintk(\"NFS: sending MNT request for %s:%s\\n\",\n\t\t(info->hostname ? info->hostname : \"server\"),\n\t\t\tinfo->dirpath);\n\n\tif (strlen(info->dirpath) > MNTPATHLEN)\n\t\treturn -ENAMETOOLONG;\n\n\tif (info->noresvport)\n\t\targs.flags |= RPC_CLNT_CREATE_NONPRIVPORT;\n\n\tmnt_clnt = rpc_create(&args);\n\tif (IS_ERR(mnt_clnt))\n\t\tgoto out_clnt_err;\n\n\tif (info->version == NFS_MNT3_VERSION)\n\t\tmsg.rpc_proc = &mnt_clnt->cl_procinfo[MOUNTPROC3_MNT];\n\telse\n\t\tmsg.rpc_proc = &mnt_clnt->cl_procinfo[MOUNTPROC_MNT];\n\n\tstatus = rpc_call_sync(mnt_clnt, &msg, RPC_TASK_SOFT|RPC_TASK_TIMEOUT);\n\trpc_shutdown_client(mnt_clnt);\n\n\tif (status < 0)\n\t\tgoto out_call_err;\n\tif (result.errno != 0)\n\t\tgoto out_mnt_err;\n\n\tdprintk(\"NFS: MNT request succeeded\\n\");\n\tstatus = 0;\n\n\t/*\n\t * If the server didn't provide a flavor list, allow the\n\t * client to try any flavor.\n\t */\n\tif (info->version != NFS_MNT3_VERSION || *info->auth_flav_len == 0) {\n\t\tdprintk(\"NFS: Faking up auth_flavs list\\n\");\n\t\tinfo->auth_flavs[0] = RPC_AUTH_NULL;\n\t\t*info->auth_flav_len = 1;\n\t}\nout:\n\treturn status;\n\nout_clnt_err:\n\tstatus = PTR_ERR(mnt_clnt);\n\tdprintk(\"NFS: failed to create MNT RPC client, status=%d\\n\", status);\n\tgoto out;\n\nout_call_err:\n\tdprintk(\"NFS: MNT request failed, status=%d\\n\", status);\n\tgoto out;\n\nout_mnt_err:\n\tdprintk(\"NFS: MNT server returned result %d\\n\", result.errno);\n\tstatus = result.errno;\n\tgoto out;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/nfs_fs.h>",
      "#include <linux/sunrpc/sched.h>",
      "#include <linux/sunrpc/clnt.h>",
      "#include <linux/in.h>",
      "#include <linux/net.h>",
      "#include <linux/uio.h>",
      "#include <linux/errno.h>",
      "#include <linux/kernel.h>",
      "#include <linux/socket.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define MNTPATHLEN\t\t(1024)"
    ],
    "globals_used": [
      "static const struct rpc_program mnt_program;",
      "static const struct rpc_program mnt_program = {\n\t.name\t\t= \"mount\",\n\t.number\t\t= NFS_MNT_PROGRAM,\n\t.nrvers\t\t= ARRAY_SIZE(mnt_version),\n\t.version\t= mnt_version,\n\t.stats\t\t= &mnt_stats,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFS: MNT server returned result %d\\n\"",
            "result.errno"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFS: MNT request failed, status=%d\\n\"",
            "status"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFS: failed to create MNT RPC client, status=%d\\n\"",
            "status"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "mnt_clnt"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFS: Faking up auth_flavs list\\n\""
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFS: MNT request succeeded\\n\""
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_shutdown_client",
          "args": [
            "mnt_clnt"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_call_sync",
          "args": [
            "mnt_clnt",
            "&msg",
            "RPC_TASK_SOFT|RPC_TASK_TIMEOUT"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "mnt_clnt"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rpc_create",
          "args": [
            "&args"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "info->dirpath"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "gfs2_ea_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/gfs2/xattr.c",
          "lines": "351-363",
          "snippet": "static inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"util.h\"",
            "#include \"trans.h\"",
            "#include \"rgrp.h\"",
            "#include \"quota.h\"",
            "#include \"meta_io.h\"",
            "#include \"inode.h\"",
            "#include \"glock.h\"",
            "#include \"xattr.h\"",
            "#include \"acl.h\"",
            "#include \"incore.h\"",
            "#include \"gfs2.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/gfs2_ondisk.h>",
            "#include <linux/xattr.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/completion.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util.h\"\n#include \"trans.h\"\n#include \"rgrp.h\"\n#include \"quota.h\"\n#include \"meta_io.h\"\n#include \"inode.h\"\n#include \"glock.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"incore.h\"\n#include \"gfs2.h\"\n#include <asm/uaccess.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/gfs2_ondisk.h>\n#include <linux/xattr.h>\n#include <linux/buffer_head.h>\n#include <linux/completion.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int gfs2_ea_strlen(struct gfs2_ea_header *ea)\n{\n\tswitch (ea->ea_type) {\n\tcase GFS2_EATYPE_USR:\n\t\treturn 5 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SYS:\n\t\treturn 7 + ea->ea_name_len + 1;\n\tcase GFS2_EATYPE_SECURITY:\n\t\treturn 9 + ea->ea_name_len + 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dprintk",
          "args": [
            "\"NFS: sending MNT request for %s:%s\\n\"",
            "(info->hostname ? info->hostname : \"server\")",
            "info->dirpath"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/nfs_fs.h>\n#include <linux/sunrpc/sched.h>\n#include <linux/sunrpc/clnt.h>\n#include <linux/in.h>\n#include <linux/net.h>\n#include <linux/uio.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/socket.h>\n#include <linux/types.h>\n\n#define MNTPATHLEN\t\t(1024)\n\nstatic const struct rpc_program mnt_program;\nstatic const struct rpc_program mnt_program = {\n\t.name\t\t= \"mount\",\n\t.number\t\t= NFS_MNT_PROGRAM,\n\t.nrvers\t\t= ARRAY_SIZE(mnt_version),\n\t.version\t= mnt_version,\n\t.stats\t\t= &mnt_stats,\n};\n\nint nfs_mount(struct nfs_mount_request *info)\n{\n\tstruct mountres\tresult = {\n\t\t.fh\t\t= info->fh,\n\t\t.auth_count\t= info->auth_flav_len,\n\t\t.auth_flavors\t= info->auth_flavs,\n\t};\n\tstruct rpc_message msg\t= {\n\t\t.rpc_argp\t= info->dirpath,\n\t\t.rpc_resp\t= &result,\n\t};\n\tstruct rpc_create_args args = {\n\t\t.net\t\t= info->net,\n\t\t.protocol\t= info->protocol,\n\t\t.address\t= info->sap,\n\t\t.addrsize\t= info->salen,\n\t\t.servername\t= info->hostname,\n\t\t.program\t= &mnt_program,\n\t\t.version\t= info->version,\n\t\t.authflavor\t= RPC_AUTH_UNIX,\n\t};\n\tstruct rpc_clnt\t\t*mnt_clnt;\n\tint\t\t\tstatus;\n\n\tdprintk(\"NFS: sending MNT request for %s:%s\\n\",\n\t\t(info->hostname ? info->hostname : \"server\"),\n\t\t\tinfo->dirpath);\n\n\tif (strlen(info->dirpath) > MNTPATHLEN)\n\t\treturn -ENAMETOOLONG;\n\n\tif (info->noresvport)\n\t\targs.flags |= RPC_CLNT_CREATE_NONPRIVPORT;\n\n\tmnt_clnt = rpc_create(&args);\n\tif (IS_ERR(mnt_clnt))\n\t\tgoto out_clnt_err;\n\n\tif (info->version == NFS_MNT3_VERSION)\n\t\tmsg.rpc_proc = &mnt_clnt->cl_procinfo[MOUNTPROC3_MNT];\n\telse\n\t\tmsg.rpc_proc = &mnt_clnt->cl_procinfo[MOUNTPROC_MNT];\n\n\tstatus = rpc_call_sync(mnt_clnt, &msg, RPC_TASK_SOFT|RPC_TASK_TIMEOUT);\n\trpc_shutdown_client(mnt_clnt);\n\n\tif (status < 0)\n\t\tgoto out_call_err;\n\tif (result.errno != 0)\n\t\tgoto out_mnt_err;\n\n\tdprintk(\"NFS: MNT request succeeded\\n\");\n\tstatus = 0;\n\n\t/*\n\t * If the server didn't provide a flavor list, allow the\n\t * client to try any flavor.\n\t */\n\tif (info->version != NFS_MNT3_VERSION || *info->auth_flav_len == 0) {\n\t\tdprintk(\"NFS: Faking up auth_flavs list\\n\");\n\t\tinfo->auth_flavs[0] = RPC_AUTH_NULL;\n\t\t*info->auth_flav_len = 1;\n\t}\nout:\n\treturn status;\n\nout_clnt_err:\n\tstatus = PTR_ERR(mnt_clnt);\n\tdprintk(\"NFS: failed to create MNT RPC client, status=%d\\n\", status);\n\tgoto out;\n\nout_call_err:\n\tdprintk(\"NFS: MNT request failed, status=%d\\n\", status);\n\tgoto out;\n\nout_mnt_err:\n\tdprintk(\"NFS: MNT server returned result %d\\n\", result.errno);\n\tstatus = result.errno;\n\tgoto out;\n}"
  }
]