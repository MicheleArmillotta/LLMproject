[
  {
    "function_name": "ocfs2_reflink_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "4434-4474",
    "snippet": "int ocfs2_reflink_ioctl(struct inode *inode,\n\t\t\tconst char __user *oldname,\n\t\t\tconst char __user *newname,\n\t\t\tbool preserve)\n{\n\tstruct dentry *new_dentry;\n\tstruct path old_path, new_path;\n\tint error;\n\n\tif (!ocfs2_refcount_tree(OCFS2_SB(inode->i_sb)))\n\t\treturn -EOPNOTSUPP;\n\n\terror = user_path_at(AT_FDCWD, oldname, 0, &old_path);\n\tif (error) {\n\t\tmlog_errno(error);\n\t\treturn error;\n\t}\n\n\tnew_dentry = user_path_create(AT_FDCWD, newname, &new_path, 0);\n\terror = PTR_ERR(new_dentry);\n\tif (IS_ERR(new_dentry)) {\n\t\tmlog_errno(error);\n\t\tgoto out;\n\t}\n\n\terror = -EXDEV;\n\tif (old_path.mnt != new_path.mnt) {\n\t\tmlog_errno(error);\n\t\tgoto out_dput;\n\t}\n\n\terror = ocfs2_vfs_reflink(old_path.dentry,\n\t\t\t\t  new_path.dentry->d_inode,\n\t\t\t\t  new_dentry, preserve);\nout_dput:\n\tdone_path_create(&new_path, new_dentry);\nout:\n\tpath_put(&old_path);\n\n\treturn error;\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&old_path"
          ],
          "line": 4471
        },
        "resolved": true,
        "details": {
          "function_name": "path_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "489-493",
          "snippet": "void path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid path_put(const struct path *path)\n{\n\tdput(path->dentry);\n\tmntput(path->mnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "done_path_create",
          "args": [
            "&new_path",
            "new_dentry"
          ],
          "line": 4469
        },
        "resolved": true,
        "details": {
          "function_name": "done_path_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "3401-3407",
          "snippet": "void done_path_create(struct path *path, struct dentry *dentry)\n{\n\tdput(dentry);\n\tmutex_unlock(&path->dentry->d_inode->i_mutex);\n\tmnt_drop_write(path->mnt);\n\tpath_put(path);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nvoid done_path_create(struct path *path, struct dentry *dentry)\n{\n\tdput(dentry);\n\tmutex_unlock(&path->dentry->d_inode->i_mutex);\n\tmnt_drop_write(path->mnt);\n\tpath_put(path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_vfs_reflink",
          "args": [
            "old_path.dentry",
            "new_path.dentry->d_inode",
            "new_dentry",
            "preserve"
          ],
          "line": 4465
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_vfs_reflink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "4375-4430",
          "snippet": "static int ocfs2_vfs_reflink(struct dentry *old_dentry, struct inode *dir,\n\t\t\t     struct dentry *new_dentry, bool preserve)\n{\n\tstruct inode *inode = old_dentry->d_inode;\n\tint error;\n\n\tif (!inode)\n\t\treturn -ENOENT;\n\n\terror = ocfs2_may_create(dir, new_dentry);\n\tif (error)\n\t\treturn error;\n\n\tif (dir->i_sb != inode->i_sb)\n\t\treturn -EXDEV;\n\n\t/*\n\t * A reflink to an append-only or immutable file cannot be created.\n\t */\n\tif (IS_APPEND(inode) || IS_IMMUTABLE(inode))\n\t\treturn -EPERM;\n\n\t/* Only regular files can be reflinked. */\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EPERM;\n\n\t/*\n\t * If the caller wants to preserve ownership, they require the\n\t * rights to do so.\n\t */\n\tif (preserve) {\n\t\tif (!uid_eq(current_fsuid(), inode->i_uid) && !capable(CAP_CHOWN))\n\t\t\treturn -EPERM;\n\t\tif (!in_group_p(inode->i_gid) && !capable(CAP_CHOWN))\n\t\t\treturn -EPERM;\n\t}\n\n\t/*\n\t * If the caller is modifying any aspect of the attributes, they\n\t * are not creating a snapshot.  They need read permission on the\n\t * file.\n\t */\n\tif (!preserve) {\n\t\terror = inode_permission(inode, MAY_READ);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tmutex_lock(&inode->i_mutex);\n\tdquot_initialize(dir);\n\terror = ocfs2_reflink(old_dentry, dir, new_dentry, preserve);\n\tmutex_unlock(&inode->i_mutex);\n\tif (!error)\n\t\tfsnotify_create(dir, new_dentry);\n\treturn error;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_vfs_reflink(struct dentry *old_dentry, struct inode *dir,\n\t\t\t     struct dentry *new_dentry, bool preserve)\n{\n\tstruct inode *inode = old_dentry->d_inode;\n\tint error;\n\n\tif (!inode)\n\t\treturn -ENOENT;\n\n\terror = ocfs2_may_create(dir, new_dentry);\n\tif (error)\n\t\treturn error;\n\n\tif (dir->i_sb != inode->i_sb)\n\t\treturn -EXDEV;\n\n\t/*\n\t * A reflink to an append-only or immutable file cannot be created.\n\t */\n\tif (IS_APPEND(inode) || IS_IMMUTABLE(inode))\n\t\treturn -EPERM;\n\n\t/* Only regular files can be reflinked. */\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EPERM;\n\n\t/*\n\t * If the caller wants to preserve ownership, they require the\n\t * rights to do so.\n\t */\n\tif (preserve) {\n\t\tif (!uid_eq(current_fsuid(), inode->i_uid) && !capable(CAP_CHOWN))\n\t\t\treturn -EPERM;\n\t\tif (!in_group_p(inode->i_gid) && !capable(CAP_CHOWN))\n\t\t\treturn -EPERM;\n\t}\n\n\t/*\n\t * If the caller is modifying any aspect of the attributes, they\n\t * are not creating a snapshot.  They need read permission on the\n\t * file.\n\t */\n\tif (!preserve) {\n\t\terror = inode_permission(inode, MAY_READ);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tmutex_lock(&inode->i_mutex);\n\tdquot_initialize(dir);\n\terror = ocfs2_reflink(old_dentry, dir, new_dentry, preserve);\n\tmutex_unlock(&inode->i_mutex);\n\tif (!error)\n\t\tfsnotify_create(dir, new_dentry);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "error"
          ],
          "line": 4461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "error"
          ],
          "line": 4455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "new_dentry"
          ],
          "line": 4454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "new_dentry"
          ],
          "line": 4453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_path_create",
          "args": [
            "AT_FDCWD",
            "newname",
            "&new_path",
            "0"
          ],
          "line": 4452
        },
        "resolved": true,
        "details": {
          "function_name": "user_path_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "3410-3420",
          "snippet": "struct dentry *user_path_create(int dfd, const char __user *pathname,\n\t\t\t\tstruct path *path, unsigned int lookup_flags)\n{\n\tstruct filename *tmp = getname(pathname);\n\tstruct dentry *res;\n\tif (IS_ERR(tmp))\n\t\treturn ERR_CAST(tmp);\n\tres = filename_create(dfd, tmp, path, lookup_flags);\n\tputname(tmp);\n\treturn res;\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nstruct dentry *user_path_create(int dfd, const char __user *pathname,\n\t\t\t\tstruct path *path, unsigned int lookup_flags)\n{\n\tstruct filename *tmp = getname(pathname);\n\tstruct dentry *res;\n\tif (IS_ERR(tmp))\n\t\treturn ERR_CAST(tmp);\n\tres = filename_create(dfd, tmp, path, lookup_flags);\n\tputname(tmp);\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "error"
          ],
          "line": 4448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_path_at",
          "args": [
            "AT_FDCWD",
            "oldname",
            "0",
            "&old_path"
          ],
          "line": 4446
        },
        "resolved": true,
        "details": {
          "function_name": "user_path_at",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "2205-2209",
          "snippet": "int user_path_at(int dfd, const char __user *name, unsigned flags,\n\t\t struct path *path)\n{\n\treturn user_path_at_empty(dfd, name, flags, path, NULL);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint user_path_at(int dfd, const char __user *name, unsigned flags,\n\t\t struct path *path)\n{\n\treturn user_path_at_empty(dfd, name, flags, path, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_refcount_tree",
          "args": [
            "OCFS2_SB(inode->i_sb)"
          ],
          "line": 4443
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_refcount_tree_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "292-296",
          "snippet": "static inline void\nocfs2_refcount_tree_put(struct ocfs2_refcount_tree *tree)\n{\n\tkref_put(&tree->rf_getcnt, ocfs2_kref_remove_refcount_tree);\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic inline void\nocfs2_refcount_tree_put(struct ocfs2_refcount_tree *tree)\n{\n\tkref_put(&tree->rf_getcnt, ocfs2_kref_remove_refcount_tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 4443
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nint ocfs2_reflink_ioctl(struct inode *inode,\n\t\t\tconst char __user *oldname,\n\t\t\tconst char __user *newname,\n\t\t\tbool preserve)\n{\n\tstruct dentry *new_dentry;\n\tstruct path old_path, new_path;\n\tint error;\n\n\tif (!ocfs2_refcount_tree(OCFS2_SB(inode->i_sb)))\n\t\treturn -EOPNOTSUPP;\n\n\terror = user_path_at(AT_FDCWD, oldname, 0, &old_path);\n\tif (error) {\n\t\tmlog_errno(error);\n\t\treturn error;\n\t}\n\n\tnew_dentry = user_path_create(AT_FDCWD, newname, &new_path, 0);\n\terror = PTR_ERR(new_dentry);\n\tif (IS_ERR(new_dentry)) {\n\t\tmlog_errno(error);\n\t\tgoto out;\n\t}\n\n\terror = -EXDEV;\n\tif (old_path.mnt != new_path.mnt) {\n\t\tmlog_errno(error);\n\t\tgoto out_dput;\n\t}\n\n\terror = ocfs2_vfs_reflink(old_path.dentry,\n\t\t\t\t  new_path.dentry->d_inode,\n\t\t\t\t  new_dentry, preserve);\nout_dput:\n\tdone_path_create(&new_path, new_dentry);\nout:\n\tpath_put(&old_path);\n\n\treturn error;\n}"
  },
  {
    "function_name": "ocfs2_vfs_reflink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "4375-4430",
    "snippet": "static int ocfs2_vfs_reflink(struct dentry *old_dentry, struct inode *dir,\n\t\t\t     struct dentry *new_dentry, bool preserve)\n{\n\tstruct inode *inode = old_dentry->d_inode;\n\tint error;\n\n\tif (!inode)\n\t\treturn -ENOENT;\n\n\terror = ocfs2_may_create(dir, new_dentry);\n\tif (error)\n\t\treturn error;\n\n\tif (dir->i_sb != inode->i_sb)\n\t\treturn -EXDEV;\n\n\t/*\n\t * A reflink to an append-only or immutable file cannot be created.\n\t */\n\tif (IS_APPEND(inode) || IS_IMMUTABLE(inode))\n\t\treturn -EPERM;\n\n\t/* Only regular files can be reflinked. */\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EPERM;\n\n\t/*\n\t * If the caller wants to preserve ownership, they require the\n\t * rights to do so.\n\t */\n\tif (preserve) {\n\t\tif (!uid_eq(current_fsuid(), inode->i_uid) && !capable(CAP_CHOWN))\n\t\t\treturn -EPERM;\n\t\tif (!in_group_p(inode->i_gid) && !capable(CAP_CHOWN))\n\t\t\treturn -EPERM;\n\t}\n\n\t/*\n\t * If the caller is modifying any aspect of the attributes, they\n\t * are not creating a snapshot.  They need read permission on the\n\t * file.\n\t */\n\tif (!preserve) {\n\t\terror = inode_permission(inode, MAY_READ);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tmutex_lock(&inode->i_mutex);\n\tdquot_initialize(dir);\n\terror = ocfs2_reflink(old_dentry, dir, new_dentry, preserve);\n\tmutex_unlock(&inode->i_mutex);\n\tif (!error)\n\t\tfsnotify_create(dir, new_dentry);\n\treturn error;\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fsnotify_create",
          "args": [
            "dir",
            "new_dentry"
          ],
          "line": 4428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 4426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_reflink",
          "args": [
            "old_dentry",
            "dir",
            "new_dentry",
            "preserve"
          ],
          "line": 4425
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reflink_ioctl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "4434-4474",
          "snippet": "int ocfs2_reflink_ioctl(struct inode *inode,\n\t\t\tconst char __user *oldname,\n\t\t\tconst char __user *newname,\n\t\t\tbool preserve)\n{\n\tstruct dentry *new_dentry;\n\tstruct path old_path, new_path;\n\tint error;\n\n\tif (!ocfs2_refcount_tree(OCFS2_SB(inode->i_sb)))\n\t\treturn -EOPNOTSUPP;\n\n\terror = user_path_at(AT_FDCWD, oldname, 0, &old_path);\n\tif (error) {\n\t\tmlog_errno(error);\n\t\treturn error;\n\t}\n\n\tnew_dentry = user_path_create(AT_FDCWD, newname, &new_path, 0);\n\terror = PTR_ERR(new_dentry);\n\tif (IS_ERR(new_dentry)) {\n\t\tmlog_errno(error);\n\t\tgoto out;\n\t}\n\n\terror = -EXDEV;\n\tif (old_path.mnt != new_path.mnt) {\n\t\tmlog_errno(error);\n\t\tgoto out_dput;\n\t}\n\n\terror = ocfs2_vfs_reflink(old_path.dentry,\n\t\t\t\t  new_path.dentry->d_inode,\n\t\t\t\t  new_dentry, preserve);\nout_dput:\n\tdone_path_create(&new_path, new_dentry);\nout:\n\tpath_put(&old_path);\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nint ocfs2_reflink_ioctl(struct inode *inode,\n\t\t\tconst char __user *oldname,\n\t\t\tconst char __user *newname,\n\t\t\tbool preserve)\n{\n\tstruct dentry *new_dentry;\n\tstruct path old_path, new_path;\n\tint error;\n\n\tif (!ocfs2_refcount_tree(OCFS2_SB(inode->i_sb)))\n\t\treturn -EOPNOTSUPP;\n\n\terror = user_path_at(AT_FDCWD, oldname, 0, &old_path);\n\tif (error) {\n\t\tmlog_errno(error);\n\t\treturn error;\n\t}\n\n\tnew_dentry = user_path_create(AT_FDCWD, newname, &new_path, 0);\n\terror = PTR_ERR(new_dentry);\n\tif (IS_ERR(new_dentry)) {\n\t\tmlog_errno(error);\n\t\tgoto out;\n\t}\n\n\terror = -EXDEV;\n\tif (old_path.mnt != new_path.mnt) {\n\t\tmlog_errno(error);\n\t\tgoto out_dput;\n\t}\n\n\terror = ocfs2_vfs_reflink(old_path.dentry,\n\t\t\t\t  new_path.dentry->d_inode,\n\t\t\t\t  new_dentry, preserve);\nout_dput:\n\tdone_path_create(&new_path, new_dentry);\nout:\n\tpath_put(&old_path);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dquot_initialize",
          "args": [
            "dir"
          ],
          "line": 4424
        },
        "resolved": true,
        "details": {
          "function_name": "dquot_initialize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/quota/dquot.c",
          "lines": "1459-1462",
          "snippet": "void dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include \"../internal.h\" /* ugh */",
            "#include <linux/quotaops.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/kmod.h>",
            "#include <linux/sched.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/file.h>",
            "#include <linux/tty.h>",
            "#include <linux/stat.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/time.h>",
            "#include <linux/mm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qsize_t inode_get_rsv_space(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include \"../internal.h\" /* ugh */\n#include <linux/quotaops.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/kmod.h>\n#include <linux/sched.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/file.h>\n#include <linux/tty.h>\n#include <linux/stat.h>\n#include <linux/fcntl.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/time.h>\n#include <linux/mm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nstatic qsize_t inode_get_rsv_space(struct inode *inode);\n\nvoid dquot_initialize(struct inode *inode)\n{\n\t__dquot_initialize(inode, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&inode->i_mutex"
          ],
          "line": 4423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_permission",
          "args": [
            "inode",
            "MAY_READ"
          ],
          "line": 4418
        },
        "resolved": true,
        "details": {
          "function_name": "inode_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "459-467",
          "snippet": "int inode_permission(struct inode *inode, int mask)\n{\n\tint retval;\n\n\tretval = sb_permission(inode->i_sb, inode, mask);\n\tif (retval)\n\t\treturn retval;\n\treturn __inode_permission(inode, mask);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint inode_permission(struct inode *inode, int mask)\n{\n\tint retval;\n\n\tretval = sb_permission(inode->i_sb, inode, mask);\n\tif (retval)\n\t\treturn retval;\n\treturn __inode_permission(inode, mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_CHOWN"
          ],
          "line": 4408
        },
        "resolved": true,
        "details": {
          "function_name": "inode_owner_or_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/inode.c",
          "lines": "1901-1912",
          "snippet": "bool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <trace/events/writeback.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/buffer_head.h> /* for inode_has_buffers */",
            "#include <linux/prefetch.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/cdev.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/hash.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __wait_on_freeing_inode(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <trace/events/writeback.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/buffer_head.h> /* for inode_has_buffers */\n#include <linux/prefetch.h>\n#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/fsnotify.h>\n#include <linux/bootmem.h>\n#include <linux/cdev.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/hash.h>\n#include <linux/backing-dev.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/export.h>\n\nstatic void __wait_on_freeing_inode(struct inode *inode);\n\nbool inode_owner_or_capable(const struct inode *inode)\n{\n\tstruct user_namespace *ns;\n\n\tif (uid_eq(current_fsuid(), inode->i_uid))\n\t\treturn true;\n\n\tns = current_user_ns();\n\tif (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))\n\t\treturn true;\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "in_group_p",
          "args": [
            "inode->i_gid"
          ],
          "line": 4408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "current_fsuid()",
            "inode->i_uid"
          ],
          "line": 4406
        },
        "resolved": true,
        "details": {
          "function_name": "uuid_equal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/xfs/uuid.c",
          "lines": "59-63",
          "snippet": "int\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}",
          "includes": [
            "#include <xfs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <xfs.h>\n\nint\nuuid_equal(uuid_t *uuid1, uuid_t *uuid2)\n{\n\treturn memcmp(uuid1, uuid2, sizeof(uuid_t)) ? 0 : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_fsuid",
          "args": [],
          "line": 4406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 4398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_IMMUTABLE",
          "args": [
            "inode"
          ],
          "line": 4394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_APPEND",
          "args": [
            "inode"
          ],
          "line": 4394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_may_create",
          "args": [
            "dir",
            "new_dentry"
          ],
          "line": 4384
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_may_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "4358-4365",
          "snippet": "static inline int ocfs2_may_create(struct inode *dir, struct dentry *child)\n{\n\tif (child->d_inode)\n\t\treturn -EEXIST;\n\tif (IS_DEADDIR(dir))\n\t\treturn -ENOENT;\n\treturn inode_permission(dir, MAY_WRITE | MAY_EXEC);\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic inline int ocfs2_may_create(struct inode *dir, struct dentry *child)\n{\n\tif (child->d_inode)\n\t\treturn -EEXIST;\n\tif (IS_DEADDIR(dir))\n\t\treturn -ENOENT;\n\treturn inode_permission(dir, MAY_WRITE | MAY_EXEC);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_vfs_reflink(struct dentry *old_dentry, struct inode *dir,\n\t\t\t     struct dentry *new_dentry, bool preserve)\n{\n\tstruct inode *inode = old_dentry->d_inode;\n\tint error;\n\n\tif (!inode)\n\t\treturn -ENOENT;\n\n\terror = ocfs2_may_create(dir, new_dentry);\n\tif (error)\n\t\treturn error;\n\n\tif (dir->i_sb != inode->i_sb)\n\t\treturn -EXDEV;\n\n\t/*\n\t * A reflink to an append-only or immutable file cannot be created.\n\t */\n\tif (IS_APPEND(inode) || IS_IMMUTABLE(inode))\n\t\treturn -EPERM;\n\n\t/* Only regular files can be reflinked. */\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EPERM;\n\n\t/*\n\t * If the caller wants to preserve ownership, they require the\n\t * rights to do so.\n\t */\n\tif (preserve) {\n\t\tif (!uid_eq(current_fsuid(), inode->i_uid) && !capable(CAP_CHOWN))\n\t\t\treturn -EPERM;\n\t\tif (!in_group_p(inode->i_gid) && !capable(CAP_CHOWN))\n\t\t\treturn -EPERM;\n\t}\n\n\t/*\n\t * If the caller is modifying any aspect of the attributes, they\n\t * are not creating a snapshot.  They need read permission on the\n\t * file.\n\t */\n\tif (!preserve) {\n\t\terror = inode_permission(inode, MAY_READ);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tmutex_lock(&inode->i_mutex);\n\tdquot_initialize(dir);\n\terror = ocfs2_reflink(old_dentry, dir, new_dentry, preserve);\n\tmutex_unlock(&inode->i_mutex);\n\tif (!error)\n\t\tfsnotify_create(dir, new_dentry);\n\treturn error;\n}"
  },
  {
    "function_name": "ocfs2_may_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "4358-4365",
    "snippet": "static inline int ocfs2_may_create(struct inode *dir, struct dentry *child)\n{\n\tif (child->d_inode)\n\t\treturn -EEXIST;\n\tif (IS_DEADDIR(dir))\n\t\treturn -ENOENT;\n\treturn inode_permission(dir, MAY_WRITE | MAY_EXEC);\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inode_permission",
          "args": [
            "dir",
            "MAY_WRITE | MAY_EXEC"
          ],
          "line": 4364
        },
        "resolved": true,
        "details": {
          "function_name": "inode_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/namei.c",
          "lines": "459-467",
          "snippet": "int inode_permission(struct inode *inode, int mask)\n{\n\tint retval;\n\n\tretval = sb_permission(inode->i_sb, inode, mask);\n\tif (retval)\n\t\treturn retval;\n\treturn __inode_permission(inode, mask);\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/hash.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/device_cgroup.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/ima.h>",
            "#include <linux/security.h>",
            "#include <linux/personality.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <asm/uaccess.h>\n#include <linux/hash.h>\n#include <linux/posix_acl.h>\n#include <linux/fs_struct.h>\n#include <linux/device_cgroup.h>\n#include <linux/fcntl.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/ima.h>\n#include <linux/security.h>\n#include <linux/personality.h>\n#include <linux/fsnotify.h>\n#include <linux/pagemap.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n#include <linux/init.h>\n\nint inode_permission(struct inode *inode, int mask)\n{\n\tint retval;\n\n\tretval = sb_permission(inode->i_sb, inode, mask);\n\tif (retval)\n\t\treturn retval;\n\treturn __inode_permission(inode, mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_DEADDIR",
          "args": [
            "dir"
          ],
          "line": 4362
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic inline int ocfs2_may_create(struct inode *dir, struct dentry *child)\n{\n\tif (child->d_inode)\n\t\treturn -EEXIST;\n\tif (IS_DEADDIR(dir))\n\t\treturn -ENOENT;\n\treturn inode_permission(dir, MAY_WRITE | MAY_EXEC);\n}"
  },
  {
    "function_name": "ocfs2_reflink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "4262-4349",
    "snippet": "static int ocfs2_reflink(struct dentry *old_dentry, struct inode *dir,\n\t\t\t struct dentry *new_dentry, bool preserve)\n{\n\tint error;\n\tstruct inode *inode = old_dentry->d_inode;\n\tstruct buffer_head *old_bh = NULL;\n\tstruct inode *new_orphan_inode = NULL;\n\tstruct posix_acl *default_acl, *acl;\n\tumode_t mode;\n\n\tif (!ocfs2_refcount_tree(OCFS2_SB(inode->i_sb)))\n\t\treturn -EOPNOTSUPP;\n\n\tmode = inode->i_mode;\n\terror = posix_acl_create(dir, &mode, &default_acl, &acl);\n\tif (error) {\n\t\tmlog_errno(error);\n\t\tgoto out;\n\t}\n\n\terror = ocfs2_create_inode_in_orphan(dir, mode,\n\t\t\t\t\t     &new_orphan_inode);\n\tif (error) {\n\t\tmlog_errno(error);\n\t\tgoto out;\n\t}\n\n\terror = ocfs2_rw_lock(inode, 1);\n\tif (error) {\n\t\tmlog_errno(error);\n\t\tgoto out;\n\t}\n\n\terror = ocfs2_inode_lock(inode, &old_bh, 1);\n\tif (error) {\n\t\tmlog_errno(error);\n\t\tocfs2_rw_unlock(inode, 1);\n\t\tgoto out;\n\t}\n\n\tdown_write(&OCFS2_I(inode)->ip_xattr_sem);\n\tdown_write(&OCFS2_I(inode)->ip_alloc_sem);\n\terror = __ocfs2_reflink(old_dentry, old_bh,\n\t\t\t\tnew_orphan_inode, preserve);\n\tup_write(&OCFS2_I(inode)->ip_alloc_sem);\n\tup_write(&OCFS2_I(inode)->ip_xattr_sem);\n\n\tocfs2_inode_unlock(inode, 1);\n\tocfs2_rw_unlock(inode, 1);\n\tbrelse(old_bh);\n\n\tif (error) {\n\t\tmlog_errno(error);\n\t\tgoto out;\n\t}\n\n\t/* If the security isn't preserved, we need to re-initialize them. */\n\tif (!preserve) {\n\t\terror = ocfs2_init_security_and_acl(dir, new_orphan_inode,\n\t\t\t\t\t\t    &new_dentry->d_name,\n\t\t\t\t\t\t    default_acl, acl);\n\t\tif (error)\n\t\t\tmlog_errno(error);\n\t}\nout:\n\tif (default_acl)\n\t\tposix_acl_release(default_acl);\n\tif (acl)\n\t\tposix_acl_release(acl);\n\tif (!error) {\n\t\terror = ocfs2_mv_orphaned_inode_to_new(dir, new_orphan_inode,\n\t\t\t\t\t\t       new_dentry);\n\t\tif (error)\n\t\t\tmlog_errno(error);\n\t}\n\n\tif (new_orphan_inode) {\n\t\t/*\n\t\t * We need to open_unlock the inode no matter whether we\n\t\t * succeed or not, so that other nodes can delete it later.\n\t\t */\n\t\tocfs2_open_unlock(new_orphan_inode);\n\t\tif (error)\n\t\t\tiput(new_orphan_inode);\n\t}\n\n\treturn error;\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "new_orphan_inode"
          ],
          "line": 4345
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_open_unlock",
          "args": [
            "new_orphan_inode"
          ],
          "line": 4343
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_open_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1775-1795",
          "snippet": "void ocfs2_open_unlock(struct inode *inode)\n{\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_open_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop open lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tif (ocfs2_mount_local(osb))\n\t\tgoto out;\n\n\tif(lockres->l_ro_holders)\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres,\n\t\t\t\t     DLM_LOCK_PR);\n\tif(lockres->l_ex_holders)\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres,\n\t\t\t\t     DLM_LOCK_EX);\n\nout:\n\treturn;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_open_unlock(struct inode *inode)\n{\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_open_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop open lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tif (ocfs2_mount_local(osb))\n\t\tgoto out;\n\n\tif(lockres->l_ro_holders)\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres,\n\t\t\t\t     DLM_LOCK_PR);\n\tif(lockres->l_ex_holders)\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres,\n\t\t\t\t     DLM_LOCK_EX);\n\nout:\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "error"
          ],
          "line": 4335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_mv_orphaned_inode_to_new",
          "args": [
            "dir",
            "new_orphan_inode",
            "new_dentry"
          ],
          "line": 4332
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mv_orphaned_inode_to_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
          "lines": "2760-2899",
          "snippet": "int ocfs2_mv_orphaned_inode_to_new(struct inode *dir,\n\t\t\t\t   struct inode *inode,\n\t\t\t\t   struct dentry *dentry)\n{\n\tint status = 0;\n\tstruct buffer_head *parent_di_bh = NULL;\n\thandle_t *handle = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tstruct ocfs2_dinode *dir_di, *di;\n\tstruct inode *orphan_dir_inode = NULL;\n\tstruct buffer_head *orphan_dir_bh = NULL;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_dir_lookup_result lookup = { NULL, };\n\n\ttrace_ocfs2_mv_orphaned_inode_to_new(dir, dentry,\n\t\t\t\tdentry->d_name.len, dentry->d_name.name,\n\t\t\t\t(unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tstatus = ocfs2_inode_lock(dir, &parent_di_bh, 1);\n\tif (status < 0) {\n\t\tif (status != -ENOENT)\n\t\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\n\tdir_di = (struct ocfs2_dinode *) parent_di_bh->b_data;\n\tif (!dir_di->i_links_count) {\n\t\t/* can't make a file in a deleted directory. */\n\t\tstatus = -ENOENT;\n\t\tgoto leave;\n\t}\n\n\tstatus = ocfs2_check_dir_for_entry(dir, dentry->d_name.name,\n\t\t\t\t\t   dentry->d_name.len);\n\tif (status)\n\t\tgoto leave;\n\n\t/* get a spot inside the dir. */\n\tstatus = ocfs2_prepare_dir_for_insert(osb, dir, parent_di_bh,\n\t\t\t\t\t      dentry->d_name.name,\n\t\t\t\t\t      dentry->d_name.len, &lookup);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\torphan_dir_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t       ORPHAN_DIR_SYSTEM_INODE,\n\t\t\t\t\t\t       osb->slot_num);\n\tif (!orphan_dir_inode) {\n\t\tstatus = -EEXIST;\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tmutex_lock(&orphan_dir_inode->i_mutex);\n\n\tstatus = ocfs2_inode_lock(orphan_dir_inode, &orphan_dir_bh, 1);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tmutex_unlock(&orphan_dir_inode->i_mutex);\n\t\tiput(orphan_dir_inode);\n\t\tgoto leave;\n\t}\n\n\tstatus = ocfs2_read_inode_block(inode, &di_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto orphan_unlock;\n\t}\n\n\thandle = ocfs2_start_trans(osb, ocfs2_rename_credits(osb->sb));\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tmlog_errno(status);\n\t\tgoto orphan_unlock;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode),\n\t\t\t\t\t di_bh, OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_commit;\n\t}\n\n\tstatus = ocfs2_orphan_del(osb, handle, orphan_dir_inode, inode,\n\t\t\t\t  orphan_dir_bh, false);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_commit;\n\t}\n\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\tdi->i_flags &= ~cpu_to_le32(OCFS2_ORPHANED_FL);\n\tdi->i_orphaned_slot = 0;\n\tset_nlink(inode, 1);\n\tocfs2_set_links_count(di, inode->i_nlink);\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\n\tocfs2_journal_dirty(handle, di_bh);\n\n\tstatus = ocfs2_add_entry(handle, dentry, inode,\n\t\t\t\t OCFS2_I(inode)->ip_blkno, parent_di_bh,\n\t\t\t\t &lookup);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_commit;\n\t}\n\n\tstatus = ocfs2_dentry_attach_lock(dentry, inode,\n\t\t\t\t\t  OCFS2_I(dir)->ip_blkno);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto out_commit;\n\t}\n\n\td_instantiate(dentry, inode);\n\tstatus = 0;\nout_commit:\n\tocfs2_commit_trans(osb, handle);\norphan_unlock:\n\tocfs2_inode_unlock(orphan_dir_inode, 1);\n\tmutex_unlock(&orphan_dir_inode->i_mutex);\n\tiput(orphan_dir_inode);\nleave:\n\n\tocfs2_inode_unlock(dir, 1);\n\n\tbrelse(di_bh);\n\tbrelse(parent_di_bh);\n\tbrelse(orphan_dir_bh);\n\n\tocfs2_free_dir_lookup_result(&lookup);\n\n\tif (status)\n\t\tmlog_errno(status);\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_mv_orphaned_inode_to_new(struct inode *dir,\n\t\t\t\t   struct inode *inode,\n\t\t\t\t   struct dentry *dentry)\n{\n\tint status = 0;\n\tstruct buffer_head *parent_di_bh = NULL;\n\thandle_t *handle = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tstruct ocfs2_dinode *dir_di, *di;\n\tstruct inode *orphan_dir_inode = NULL;\n\tstruct buffer_head *orphan_dir_bh = NULL;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_dir_lookup_result lookup = { NULL, };\n\n\ttrace_ocfs2_mv_orphaned_inode_to_new(dir, dentry,\n\t\t\t\tdentry->d_name.len, dentry->d_name.name,\n\t\t\t\t(unsigned long long)OCFS2_I(dir)->ip_blkno,\n\t\t\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tstatus = ocfs2_inode_lock(dir, &parent_di_bh, 1);\n\tif (status < 0) {\n\t\tif (status != -ENOENT)\n\t\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\n\tdir_di = (struct ocfs2_dinode *) parent_di_bh->b_data;\n\tif (!dir_di->i_links_count) {\n\t\t/* can't make a file in a deleted directory. */\n\t\tstatus = -ENOENT;\n\t\tgoto leave;\n\t}\n\n\tstatus = ocfs2_check_dir_for_entry(dir, dentry->d_name.name,\n\t\t\t\t\t   dentry->d_name.len);\n\tif (status)\n\t\tgoto leave;\n\n\t/* get a spot inside the dir. */\n\tstatus = ocfs2_prepare_dir_for_insert(osb, dir, parent_di_bh,\n\t\t\t\t\t      dentry->d_name.name,\n\t\t\t\t\t      dentry->d_name.len, &lookup);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\torphan_dir_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\t\t       ORPHAN_DIR_SYSTEM_INODE,\n\t\t\t\t\t\t       osb->slot_num);\n\tif (!orphan_dir_inode) {\n\t\tstatus = -EEXIST;\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tmutex_lock(&orphan_dir_inode->i_mutex);\n\n\tstatus = ocfs2_inode_lock(orphan_dir_inode, &orphan_dir_bh, 1);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tmutex_unlock(&orphan_dir_inode->i_mutex);\n\t\tiput(orphan_dir_inode);\n\t\tgoto leave;\n\t}\n\n\tstatus = ocfs2_read_inode_block(inode, &di_bh);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto orphan_unlock;\n\t}\n\n\thandle = ocfs2_start_trans(osb, ocfs2_rename_credits(osb->sb));\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tmlog_errno(status);\n\t\tgoto orphan_unlock;\n\t}\n\n\tstatus = ocfs2_journal_access_di(handle, INODE_CACHE(inode),\n\t\t\t\t\t di_bh, OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_commit;\n\t}\n\n\tstatus = ocfs2_orphan_del(osb, handle, orphan_dir_inode, inode,\n\t\t\t\t  orphan_dir_bh, false);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_commit;\n\t}\n\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\tdi->i_flags &= ~cpu_to_le32(OCFS2_ORPHANED_FL);\n\tdi->i_orphaned_slot = 0;\n\tset_nlink(inode, 1);\n\tocfs2_set_links_count(di, inode->i_nlink);\n\tocfs2_update_inode_fsync_trans(handle, inode, 1);\n\tocfs2_journal_dirty(handle, di_bh);\n\n\tstatus = ocfs2_add_entry(handle, dentry, inode,\n\t\t\t\t OCFS2_I(inode)->ip_blkno, parent_di_bh,\n\t\t\t\t &lookup);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto out_commit;\n\t}\n\n\tstatus = ocfs2_dentry_attach_lock(dentry, inode,\n\t\t\t\t\t  OCFS2_I(dir)->ip_blkno);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto out_commit;\n\t}\n\n\td_instantiate(dentry, inode);\n\tstatus = 0;\nout_commit:\n\tocfs2_commit_trans(osb, handle);\norphan_unlock:\n\tocfs2_inode_unlock(orphan_dir_inode, 1);\n\tmutex_unlock(&orphan_dir_inode->i_mutex);\n\tiput(orphan_dir_inode);\nleave:\n\n\tocfs2_inode_unlock(dir, 1);\n\n\tbrelse(di_bh);\n\tbrelse(parent_di_bh);\n\tbrelse(orphan_dir_bh);\n\n\tocfs2_free_dir_lookup_result(&lookup);\n\n\tif (status)\n\t\tmlog_errno(status);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "acl"
          ],
          "line": 4330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_release",
          "args": [
            "default_acl"
          ],
          "line": 4328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "error"
          ],
          "line": 4324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_init_security_and_acl",
          "args": [
            "dir",
            "new_orphan_inode",
            "&new_dentry->d_name",
            "default_acl",
            "acl"
          ],
          "line": 4320
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_security_and_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "7198-7228",
          "snippet": "int ocfs2_init_security_and_acl(struct inode *dir,\n\t\t\t\tstruct inode *inode,\n\t\t\t\tconst struct qstr *qstr,\n\t\t\t\tstruct posix_acl *default_acl,\n\t\t\t\tstruct posix_acl *acl)\n{\n\tstruct buffer_head *dir_bh = NULL;\n\tint ret = 0;\n\n\tret = ocfs2_init_security_get(inode, dir, qstr, NULL);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto leave;\n\t}\n\n\tret = ocfs2_inode_lock(dir, &dir_bh, 0);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto leave;\n\t}\n\n\tif (!ret && default_acl)\n\t\tret = ocfs2_iop_set_acl(inode, default_acl, ACL_TYPE_DEFAULT);\n\tif (!ret && acl)\n\t\tret = ocfs2_iop_set_acl(inode, acl, ACL_TYPE_ACCESS);\n\n\tocfs2_inode_unlock(dir, 0);\n\tbrelse(dir_bh);\nleave:\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nint ocfs2_init_security_and_acl(struct inode *dir,\n\t\t\t\tstruct inode *inode,\n\t\t\t\tconst struct qstr *qstr,\n\t\t\t\tstruct posix_acl *default_acl,\n\t\t\t\tstruct posix_acl *acl)\n{\n\tstruct buffer_head *dir_bh = NULL;\n\tint ret = 0;\n\n\tret = ocfs2_init_security_get(inode, dir, qstr, NULL);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto leave;\n\t}\n\n\tret = ocfs2_inode_lock(dir, &dir_bh, 0);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto leave;\n\t}\n\n\tif (!ret && default_acl)\n\t\tret = ocfs2_iop_set_acl(inode, default_acl, ACL_TYPE_DEFAULT);\n\tif (!ret && acl)\n\t\tret = ocfs2_iop_set_acl(inode, acl, ACL_TYPE_ACCESS);\n\n\tocfs2_inode_unlock(dir, 0);\n\tbrelse(dir_bh);\nleave:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "error"
          ],
          "line": 4314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "old_bh"
          ],
          "line": 4311
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_rw_unlock",
          "args": [
            "inode",
            "1"
          ],
          "line": 4310
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rw_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1692-1704",
          "snippet": "void ocfs2_rw_unlock(struct inode *inode, int write)\n{\n\tint level = write ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_rw_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s RW lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     write ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_rw_unlock(struct inode *inode, int write)\n{\n\tint level = write ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_rw_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s RW lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     write ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "inode",
            "1"
          ],
          "line": 4309
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&OCFS2_I(inode)->ip_xattr_sem"
          ],
          "line": 4307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 4307
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&OCFS2_I(inode)->ip_alloc_sem"
          ],
          "line": 4306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ocfs2_reflink",
          "args": [
            "old_dentry",
            "old_bh",
            "new_orphan_inode",
            "preserve"
          ],
          "line": 4304
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_reflink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "4191-4260",
          "snippet": "static int __ocfs2_reflink(struct dentry *old_dentry,\n\t\t\t   struct buffer_head *old_bh,\n\t\t\t   struct inode *new_inode,\n\t\t\t   bool preserve)\n{\n\tint ret;\n\tstruct inode *inode = old_dentry->d_inode;\n\tstruct buffer_head *new_bh = NULL;\n\n\tif (OCFS2_I(inode)->ip_flags & OCFS2_INODE_SYSTEM_FILE) {\n\t\tret = -EINVAL;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = filemap_fdatawrite(inode->i_mapping);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_attach_refcount_tree(inode, old_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tmutex_lock_nested(&new_inode->i_mutex, I_MUTEX_CHILD);\n\tret = ocfs2_inode_lock_nested(new_inode, &new_bh, 1,\n\t\t\t\t      OI_LS_REFLINK_TARGET);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_unlock;\n\t}\n\n\tret = ocfs2_create_reflink_node(inode, old_bh,\n\t\t\t\t\tnew_inode, new_bh, preserve);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto inode_unlock;\n\t}\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_HAS_XATTR_FL) {\n\t\tret = ocfs2_reflink_xattrs(inode, old_bh,\n\t\t\t\t\t   new_inode, new_bh,\n\t\t\t\t\t   preserve);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto inode_unlock;\n\t\t}\n\t}\n\n\tret = ocfs2_complete_reflink(inode, old_bh,\n\t\t\t\t     new_inode, new_bh, preserve);\n\tif (ret)\n\t\tmlog_errno(ret);\n\ninode_unlock:\n\tocfs2_inode_unlock(new_inode, 1);\n\tbrelse(new_bh);\nout_unlock:\n\tmutex_unlock(&new_inode->i_mutex);\nout:\n\tif (!ret) {\n\t\tret = filemap_fdatawait(inode->i_mapping);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int __ocfs2_reflink(struct dentry *old_dentry,\n\t\t\t   struct buffer_head *old_bh,\n\t\t\t   struct inode *new_inode,\n\t\t\t   bool preserve)\n{\n\tint ret;\n\tstruct inode *inode = old_dentry->d_inode;\n\tstruct buffer_head *new_bh = NULL;\n\n\tif (OCFS2_I(inode)->ip_flags & OCFS2_INODE_SYSTEM_FILE) {\n\t\tret = -EINVAL;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = filemap_fdatawrite(inode->i_mapping);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_attach_refcount_tree(inode, old_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tmutex_lock_nested(&new_inode->i_mutex, I_MUTEX_CHILD);\n\tret = ocfs2_inode_lock_nested(new_inode, &new_bh, 1,\n\t\t\t\t      OI_LS_REFLINK_TARGET);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_unlock;\n\t}\n\n\tret = ocfs2_create_reflink_node(inode, old_bh,\n\t\t\t\t\tnew_inode, new_bh, preserve);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto inode_unlock;\n\t}\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_HAS_XATTR_FL) {\n\t\tret = ocfs2_reflink_xattrs(inode, old_bh,\n\t\t\t\t\t   new_inode, new_bh,\n\t\t\t\t\t   preserve);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto inode_unlock;\n\t\t}\n\t}\n\n\tret = ocfs2_complete_reflink(inode, old_bh,\n\t\t\t\t     new_inode, new_bh, preserve);\n\tif (ret)\n\t\tmlog_errno(ret);\n\ninode_unlock:\n\tocfs2_inode_unlock(new_inode, 1);\n\tbrelse(new_bh);\nout_unlock:\n\tmutex_unlock(&new_inode->i_mutex);\nout:\n\tif (!ret) {\n\t\tret = filemap_fdatawait(inode->i_mapping);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&OCFS2_I(inode)->ip_alloc_sem"
          ],
          "line": 4303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&OCFS2_I(inode)->ip_xattr_sem"
          ],
          "line": 4302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "error"
          ],
          "line": 4297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock",
          "args": [
            "inode",
            "&old_bh",
            "1"
          ],
          "line": 4295
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_lock_atime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2455-2489",
          "snippet": "int ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);",
            "static inline int ocfs2_highest_compat_lock_level(int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\n\nint ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "error"
          ],
          "line": 4291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_rw_lock",
          "args": [
            "inode",
            "1"
          ],
          "line": 4289
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rw_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "1665-1690",
          "snippet": "int ocfs2_rw_lock(struct inode *inode, int write)\n{\n\tint status, level;\n\tstruct ocfs2_lock_res *lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tBUG_ON(!inode);\n\n\tmlog(0, \"inode %llu take %s RW lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     write ? \"EXMODE\" : \"PRMODE\");\n\n\tif (ocfs2_mount_local(osb))\n\t\treturn 0;\n\n\tlockres = &OCFS2_I(inode)->ip_rw_lockres;\n\n\tlevel = write ? DLM_LOCK_EX : DLM_LOCK_PR;\n\n\tstatus = ocfs2_cluster_lock(OCFS2_SB(inode->i_sb), lockres, level, 0,\n\t\t\t\t    0);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nint ocfs2_rw_lock(struct inode *inode, int write)\n{\n\tint status, level;\n\tstruct ocfs2_lock_res *lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tBUG_ON(!inode);\n\n\tmlog(0, \"inode %llu take %s RW lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     write ? \"EXMODE\" : \"PRMODE\");\n\n\tif (ocfs2_mount_local(osb))\n\t\treturn 0;\n\n\tlockres = &OCFS2_I(inode)->ip_rw_lockres;\n\n\tlevel = write ? DLM_LOCK_EX : DLM_LOCK_PR;\n\n\tstatus = ocfs2_cluster_lock(OCFS2_SB(inode->i_sb), lockres, level, 0,\n\t\t\t\t    0);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "error"
          ],
          "line": 4285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_create_inode_in_orphan",
          "args": [
            "dir",
            "mode",
            "&new_orphan_inode"
          ],
          "line": 4282
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_create_inode_in_orphan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/namei.c",
          "lines": "2460-2578",
          "snippet": "int ocfs2_create_inode_in_orphan(struct inode *dir,\n\t\t\t\t int mode,\n\t\t\t\t struct inode **new_inode)\n{\n\tint status, did_quota_inode = 0;\n\tstruct inode *inode = NULL;\n\tstruct inode *orphan_dir = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tstruct ocfs2_dinode *di = NULL;\n\thandle_t *handle = NULL;\n\tchar orphan_name[OCFS2_ORPHAN_NAMELEN + 1];\n\tstruct buffer_head *parent_di_bh = NULL;\n\tstruct buffer_head *new_di_bh = NULL;\n\tstruct ocfs2_alloc_context *inode_ac = NULL;\n\tstruct ocfs2_dir_lookup_result orphan_insert = { NULL, };\n\tu64 uninitialized_var(di_blkno), suballoc_loc;\n\tu16 suballoc_bit;\n\n\tstatus = ocfs2_inode_lock(dir, &parent_di_bh, 1);\n\tif (status < 0) {\n\t\tif (status != -ENOENT)\n\t\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\n\tstatus = ocfs2_prep_new_orphaned_file(dir, parent_di_bh,\n\t\t\t\t\t      orphan_name, &orphan_dir,\n\t\t\t\t\t      &di_blkno, &orphan_insert, &inode_ac);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tinode = ocfs2_get_init_inode(dir, mode);\n\tif (!inode) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\thandle = ocfs2_start_trans(osb, ocfs2_mknod_credits(osb->sb, 0, 0));\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tstatus = dquot_alloc_inode(inode);\n\tif (status)\n\t\tgoto leave;\n\tdid_quota_inode = 1;\n\n\tstatus = ocfs2_claim_new_inode_at_loc(handle, dir, inode_ac,\n\t\t\t\t\t      &suballoc_loc,\n\t\t\t\t\t      &suballoc_bit, di_blkno);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tclear_nlink(inode);\n\t/* do the real work now. */\n\tstatus = __ocfs2_mknod_locked(dir, inode,\n\t\t\t\t      0, &new_di_bh, parent_di_bh, handle,\n\t\t\t\t      inode_ac, di_blkno, suballoc_loc,\n\t\t\t\t      suballoc_bit);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tdi = (struct ocfs2_dinode *)new_di_bh->b_data;\n\tstatus = ocfs2_orphan_add(osb, handle, inode, new_di_bh, orphan_name,\n\t\t\t\t  &orphan_insert, orphan_dir, false);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/* get open lock so that only nodes can't remove it from orphan dir. */\n\tstatus = ocfs2_open_lock(inode);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\tinsert_inode_hash(inode);\nleave:\n\tif (status < 0 && did_quota_inode)\n\t\tdquot_free_inode(inode);\n\tif (handle)\n\t\tocfs2_commit_trans(osb, handle);\n\n\tif (orphan_dir) {\n\t\t/* This was locked for us in ocfs2_prepare_orphan_dir() */\n\t\tocfs2_inode_unlock(orphan_dir, 1);\n\t\tmutex_unlock(&orphan_dir->i_mutex);\n\t\tiput(orphan_dir);\n\t}\n\n\tif ((status < 0) && inode) {\n\t\tclear_nlink(inode);\n\t\tiput(inode);\n\t}\n\n\tif (inode_ac)\n\t\tocfs2_free_alloc_context(inode_ac);\n\n\tbrelse(new_di_bh);\n\n\tif (!status)\n\t\t*new_inode = inode;\n\n\tocfs2_free_dir_lookup_result(&orphan_insert);\n\n\tocfs2_inode_unlock(dir, 1);\n\tbrelse(parent_di_bh);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_ORPHAN_NAMELEN ((int)(2 * sizeof(u64)))"
          ],
          "globals_used": [
            "static int ocfs2_mknod_locked(struct ocfs2_super *osb,\n\t\t\t      struct inode *dir,\n\t\t\t      struct inode *inode,\n\t\t\t      dev_t dev,\n\t\t\t      struct buffer_head **new_fe_bh,\n\t\t\t      struct buffer_head *parent_fe_bh,\n\t\t\t      handle_t *handle,\n\t\t\t      struct ocfs2_alloc_context *inode_ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define OCFS2_ORPHAN_NAMELEN ((int)(2 * sizeof(u64)))\n\nstatic int ocfs2_mknod_locked(struct ocfs2_super *osb,\n\t\t\t      struct inode *dir,\n\t\t\t      struct inode *inode,\n\t\t\t      dev_t dev,\n\t\t\t      struct buffer_head **new_fe_bh,\n\t\t\t      struct buffer_head *parent_fe_bh,\n\t\t\t      handle_t *handle,\n\t\t\t      struct ocfs2_alloc_context *inode_ac);\n\nint ocfs2_create_inode_in_orphan(struct inode *dir,\n\t\t\t\t int mode,\n\t\t\t\t struct inode **new_inode)\n{\n\tint status, did_quota_inode = 0;\n\tstruct inode *inode = NULL;\n\tstruct inode *orphan_dir = NULL;\n\tstruct ocfs2_super *osb = OCFS2_SB(dir->i_sb);\n\tstruct ocfs2_dinode *di = NULL;\n\thandle_t *handle = NULL;\n\tchar orphan_name[OCFS2_ORPHAN_NAMELEN + 1];\n\tstruct buffer_head *parent_di_bh = NULL;\n\tstruct buffer_head *new_di_bh = NULL;\n\tstruct ocfs2_alloc_context *inode_ac = NULL;\n\tstruct ocfs2_dir_lookup_result orphan_insert = { NULL, };\n\tu64 uninitialized_var(di_blkno), suballoc_loc;\n\tu16 suballoc_bit;\n\n\tstatus = ocfs2_inode_lock(dir, &parent_di_bh, 1);\n\tif (status < 0) {\n\t\tif (status != -ENOENT)\n\t\t\tmlog_errno(status);\n\t\treturn status;\n\t}\n\n\tstatus = ocfs2_prep_new_orphaned_file(dir, parent_di_bh,\n\t\t\t\t\t      orphan_name, &orphan_dir,\n\t\t\t\t\t      &di_blkno, &orphan_insert, &inode_ac);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tinode = ocfs2_get_init_inode(dir, mode);\n\tif (!inode) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\thandle = ocfs2_start_trans(osb, ocfs2_mknod_credits(osb->sb, 0, 0));\n\tif (IS_ERR(handle)) {\n\t\tstatus = PTR_ERR(handle);\n\t\thandle = NULL;\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tstatus = dquot_alloc_inode(inode);\n\tif (status)\n\t\tgoto leave;\n\tdid_quota_inode = 1;\n\n\tstatus = ocfs2_claim_new_inode_at_loc(handle, dir, inode_ac,\n\t\t\t\t\t      &suballoc_loc,\n\t\t\t\t\t      &suballoc_bit, di_blkno);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tclear_nlink(inode);\n\t/* do the real work now. */\n\tstatus = __ocfs2_mknod_locked(dir, inode,\n\t\t\t\t      0, &new_di_bh, parent_di_bh, handle,\n\t\t\t\t      inode_ac, di_blkno, suballoc_loc,\n\t\t\t\t      suballoc_bit);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\tdi = (struct ocfs2_dinode *)new_di_bh->b_data;\n\tstatus = ocfs2_orphan_add(osb, handle, inode, new_di_bh, orphan_name,\n\t\t\t\t  &orphan_insert, orphan_dir, false);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto leave;\n\t}\n\n\t/* get open lock so that only nodes can't remove it from orphan dir. */\n\tstatus = ocfs2_open_lock(inode);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\tinsert_inode_hash(inode);\nleave:\n\tif (status < 0 && did_quota_inode)\n\t\tdquot_free_inode(inode);\n\tif (handle)\n\t\tocfs2_commit_trans(osb, handle);\n\n\tif (orphan_dir) {\n\t\t/* This was locked for us in ocfs2_prepare_orphan_dir() */\n\t\tocfs2_inode_unlock(orphan_dir, 1);\n\t\tmutex_unlock(&orphan_dir->i_mutex);\n\t\tiput(orphan_dir);\n\t}\n\n\tif ((status < 0) && inode) {\n\t\tclear_nlink(inode);\n\t\tiput(inode);\n\t}\n\n\tif (inode_ac)\n\t\tocfs2_free_alloc_context(inode_ac);\n\n\tbrelse(new_di_bh);\n\n\tif (!status)\n\t\t*new_inode = inode;\n\n\tocfs2_free_dir_lookup_result(&orphan_insert);\n\n\tocfs2_inode_unlock(dir, 1);\n\tbrelse(parent_di_bh);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "error"
          ],
          "line": 4278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "posix_acl_create",
          "args": [
            "dir",
            "&mode",
            "&default_acl",
            "&acl"
          ],
          "line": 4276
        },
        "resolved": true,
        "details": {
          "function_name": "posix_acl_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/posix_acl.c",
          "lines": "545-598",
          "snippet": "int\nposix_acl_create(struct inode *dir, umode_t *mode,\n\t\tstruct posix_acl **default_acl, struct posix_acl **acl)\n{\n\tstruct posix_acl *p;\n\tint ret;\n\n\tif (S_ISLNK(*mode) || !IS_POSIXACL(dir))\n\t\tgoto no_acl;\n\n\tp = get_acl(dir, ACL_TYPE_DEFAULT);\n\tif (IS_ERR(p)) {\n\t\tif (p == ERR_PTR(-EOPNOTSUPP))\n\t\t\tgoto apply_umask;\n\t\treturn PTR_ERR(p);\n\t}\n\n\tif (!p)\n\t\tgoto apply_umask;\n\n\t*acl = posix_acl_clone(p, GFP_NOFS);\n\tif (!*acl)\n\t\tgoto no_mem;\n\n\tret = posix_acl_create_masq(*acl, mode);\n\tif (ret < 0)\n\t\tgoto no_mem_clone;\n\n\tif (ret == 0) {\n\t\tposix_acl_release(*acl);\n\t\t*acl = NULL;\n\t}\n\n\tif (!S_ISDIR(*mode)) {\n\t\tposix_acl_release(p);\n\t\t*default_acl = NULL;\n\t} else {\n\t\t*default_acl = p;\n\t}\n\treturn 0;\n\napply_umask:\n\t*mode &= ~current_umask();\nno_acl:\n\t*default_acl = NULL;\n\t*acl = NULL;\n\treturn 0;\n\nno_mem_clone:\n\tposix_acl_release(*acl);\nno_mem:\n\tposix_acl_release(p);\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/xattr.h>",
            "#include <linux/posix_acl_xattr.h>",
            "#include <linux/posix_acl.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/xattr.h>\n#include <linux/posix_acl_xattr.h>\n#include <linux/posix_acl.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint\nposix_acl_create(struct inode *dir, umode_t *mode,\n\t\tstruct posix_acl **default_acl, struct posix_acl **acl)\n{\n\tstruct posix_acl *p;\n\tint ret;\n\n\tif (S_ISLNK(*mode) || !IS_POSIXACL(dir))\n\t\tgoto no_acl;\n\n\tp = get_acl(dir, ACL_TYPE_DEFAULT);\n\tif (IS_ERR(p)) {\n\t\tif (p == ERR_PTR(-EOPNOTSUPP))\n\t\t\tgoto apply_umask;\n\t\treturn PTR_ERR(p);\n\t}\n\n\tif (!p)\n\t\tgoto apply_umask;\n\n\t*acl = posix_acl_clone(p, GFP_NOFS);\n\tif (!*acl)\n\t\tgoto no_mem;\n\n\tret = posix_acl_create_masq(*acl, mode);\n\tif (ret < 0)\n\t\tgoto no_mem_clone;\n\n\tif (ret == 0) {\n\t\tposix_acl_release(*acl);\n\t\t*acl = NULL;\n\t}\n\n\tif (!S_ISDIR(*mode)) {\n\t\tposix_acl_release(p);\n\t\t*default_acl = NULL;\n\t} else {\n\t\t*default_acl = p;\n\t}\n\treturn 0;\n\napply_umask:\n\t*mode &= ~current_umask();\nno_acl:\n\t*default_acl = NULL;\n\t*acl = NULL;\n\treturn 0;\n\nno_mem_clone:\n\tposix_acl_release(*acl);\nno_mem:\n\tposix_acl_release(p);\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_refcount_tree",
          "args": [
            "OCFS2_SB(inode->i_sb)"
          ],
          "line": 4272
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_refcount_tree_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "292-296",
          "snippet": "static inline void\nocfs2_refcount_tree_put(struct ocfs2_refcount_tree *tree)\n{\n\tkref_put(&tree->rf_getcnt, ocfs2_kref_remove_refcount_tree);\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic inline void\nocfs2_refcount_tree_put(struct ocfs2_refcount_tree *tree)\n{\n\tkref_put(&tree->rf_getcnt, ocfs2_kref_remove_refcount_tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 4272
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_reflink(struct dentry *old_dentry, struct inode *dir,\n\t\t\t struct dentry *new_dentry, bool preserve)\n{\n\tint error;\n\tstruct inode *inode = old_dentry->d_inode;\n\tstruct buffer_head *old_bh = NULL;\n\tstruct inode *new_orphan_inode = NULL;\n\tstruct posix_acl *default_acl, *acl;\n\tumode_t mode;\n\n\tif (!ocfs2_refcount_tree(OCFS2_SB(inode->i_sb)))\n\t\treturn -EOPNOTSUPP;\n\n\tmode = inode->i_mode;\n\terror = posix_acl_create(dir, &mode, &default_acl, &acl);\n\tif (error) {\n\t\tmlog_errno(error);\n\t\tgoto out;\n\t}\n\n\terror = ocfs2_create_inode_in_orphan(dir, mode,\n\t\t\t\t\t     &new_orphan_inode);\n\tif (error) {\n\t\tmlog_errno(error);\n\t\tgoto out;\n\t}\n\n\terror = ocfs2_rw_lock(inode, 1);\n\tif (error) {\n\t\tmlog_errno(error);\n\t\tgoto out;\n\t}\n\n\terror = ocfs2_inode_lock(inode, &old_bh, 1);\n\tif (error) {\n\t\tmlog_errno(error);\n\t\tocfs2_rw_unlock(inode, 1);\n\t\tgoto out;\n\t}\n\n\tdown_write(&OCFS2_I(inode)->ip_xattr_sem);\n\tdown_write(&OCFS2_I(inode)->ip_alloc_sem);\n\terror = __ocfs2_reflink(old_dentry, old_bh,\n\t\t\t\tnew_orphan_inode, preserve);\n\tup_write(&OCFS2_I(inode)->ip_alloc_sem);\n\tup_write(&OCFS2_I(inode)->ip_xattr_sem);\n\n\tocfs2_inode_unlock(inode, 1);\n\tocfs2_rw_unlock(inode, 1);\n\tbrelse(old_bh);\n\n\tif (error) {\n\t\tmlog_errno(error);\n\t\tgoto out;\n\t}\n\n\t/* If the security isn't preserved, we need to re-initialize them. */\n\tif (!preserve) {\n\t\terror = ocfs2_init_security_and_acl(dir, new_orphan_inode,\n\t\t\t\t\t\t    &new_dentry->d_name,\n\t\t\t\t\t\t    default_acl, acl);\n\t\tif (error)\n\t\t\tmlog_errno(error);\n\t}\nout:\n\tif (default_acl)\n\t\tposix_acl_release(default_acl);\n\tif (acl)\n\t\tposix_acl_release(acl);\n\tif (!error) {\n\t\terror = ocfs2_mv_orphaned_inode_to_new(dir, new_orphan_inode,\n\t\t\t\t\t\t       new_dentry);\n\t\tif (error)\n\t\t\tmlog_errno(error);\n\t}\n\n\tif (new_orphan_inode) {\n\t\t/*\n\t\t * We need to open_unlock the inode no matter whether we\n\t\t * succeed or not, so that other nodes can delete it later.\n\t\t */\n\t\tocfs2_open_unlock(new_orphan_inode);\n\t\tif (error)\n\t\t\tiput(new_orphan_inode);\n\t}\n\n\treturn error;\n}"
  },
  {
    "function_name": "__ocfs2_reflink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "4191-4260",
    "snippet": "static int __ocfs2_reflink(struct dentry *old_dentry,\n\t\t\t   struct buffer_head *old_bh,\n\t\t\t   struct inode *new_inode,\n\t\t\t   bool preserve)\n{\n\tint ret;\n\tstruct inode *inode = old_dentry->d_inode;\n\tstruct buffer_head *new_bh = NULL;\n\n\tif (OCFS2_I(inode)->ip_flags & OCFS2_INODE_SYSTEM_FILE) {\n\t\tret = -EINVAL;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = filemap_fdatawrite(inode->i_mapping);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_attach_refcount_tree(inode, old_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tmutex_lock_nested(&new_inode->i_mutex, I_MUTEX_CHILD);\n\tret = ocfs2_inode_lock_nested(new_inode, &new_bh, 1,\n\t\t\t\t      OI_LS_REFLINK_TARGET);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_unlock;\n\t}\n\n\tret = ocfs2_create_reflink_node(inode, old_bh,\n\t\t\t\t\tnew_inode, new_bh, preserve);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto inode_unlock;\n\t}\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_HAS_XATTR_FL) {\n\t\tret = ocfs2_reflink_xattrs(inode, old_bh,\n\t\t\t\t\t   new_inode, new_bh,\n\t\t\t\t\t   preserve);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto inode_unlock;\n\t\t}\n\t}\n\n\tret = ocfs2_complete_reflink(inode, old_bh,\n\t\t\t\t     new_inode, new_bh, preserve);\n\tif (ret)\n\t\tmlog_errno(ret);\n\ninode_unlock:\n\tocfs2_inode_unlock(new_inode, 1);\n\tbrelse(new_bh);\nout_unlock:\n\tmutex_unlock(&new_inode->i_mutex);\nout:\n\tif (!ret) {\n\t\tret = filemap_fdatawait(inode->i_mapping);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_fdatawait",
          "args": [
            "inode->i_mapping"
          ],
          "line": 4255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&new_inode->i_mutex"
          ],
          "line": 4252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "new_bh"
          ],
          "line": 4250
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "new_inode",
            "1"
          ],
          "line": 4249
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_complete_reflink",
          "args": [
            "inode",
            "old_bh",
            "new_inode",
            "new_bh",
            "preserve"
          ],
          "line": 4243
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_complete_reflink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "4061-4130",
          "snippet": "static int ocfs2_complete_reflink(struct inode *s_inode,\n\t\t\t\t  struct buffer_head *s_bh,\n\t\t\t\t  struct inode *t_inode,\n\t\t\t\t  struct buffer_head *t_bh,\n\t\t\t\t  bool preserve)\n{\n\tint ret;\n\thandle_t *handle;\n\tstruct ocfs2_dinode *s_di = (struct ocfs2_dinode *)s_bh->b_data;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)t_bh->b_data;\n\tloff_t size = i_size_read(s_inode);\n\n\thandle = ocfs2_start_trans(OCFS2_SB(t_inode->i_sb),\n\t\t\t\t   OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(t_inode), t_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tspin_lock(&OCFS2_I(t_inode)->ip_lock);\n\tOCFS2_I(t_inode)->ip_clusters = OCFS2_I(s_inode)->ip_clusters;\n\tOCFS2_I(t_inode)->ip_attr = OCFS2_I(s_inode)->ip_attr;\n\tOCFS2_I(t_inode)->ip_dyn_features = OCFS2_I(s_inode)->ip_dyn_features;\n\tspin_unlock(&OCFS2_I(t_inode)->ip_lock);\n\ti_size_write(t_inode, size);\n\tt_inode->i_blocks = s_inode->i_blocks;\n\n\tdi->i_xattr_inline_size = s_di->i_xattr_inline_size;\n\tdi->i_clusters = s_di->i_clusters;\n\tdi->i_size = s_di->i_size;\n\tdi->i_dyn_features = s_di->i_dyn_features;\n\tdi->i_attr = s_di->i_attr;\n\n\tif (preserve) {\n\t\tt_inode->i_uid = s_inode->i_uid;\n\t\tt_inode->i_gid = s_inode->i_gid;\n\t\tt_inode->i_mode = s_inode->i_mode;\n\t\tdi->i_uid = s_di->i_uid;\n\t\tdi->i_gid = s_di->i_gid;\n\t\tdi->i_mode = s_di->i_mode;\n\n\t\t/*\n\t\t * update time.\n\t\t * we want mtime to appear identical to the source and\n\t\t * update ctime.\n\t\t */\n\t\tt_inode->i_ctime = CURRENT_TIME;\n\n\t\tdi->i_ctime = cpu_to_le64(t_inode->i_ctime.tv_sec);\n\t\tdi->i_ctime_nsec = cpu_to_le32(t_inode->i_ctime.tv_nsec);\n\n\t\tt_inode->i_mtime = s_inode->i_mtime;\n\t\tdi->i_mtime = s_di->i_mtime;\n\t\tdi->i_mtime_nsec = s_di->i_mtime_nsec;\n\t}\n\n\tocfs2_journal_dirty(handle, t_bh);\n\nout_commit:\n\tocfs2_commit_trans(OCFS2_SB(t_inode->i_sb), handle);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_complete_reflink(struct inode *s_inode,\n\t\t\t\t  struct buffer_head *s_bh,\n\t\t\t\t  struct inode *t_inode,\n\t\t\t\t  struct buffer_head *t_bh,\n\t\t\t\t  bool preserve)\n{\n\tint ret;\n\thandle_t *handle;\n\tstruct ocfs2_dinode *s_di = (struct ocfs2_dinode *)s_bh->b_data;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)t_bh->b_data;\n\tloff_t size = i_size_read(s_inode);\n\n\thandle = ocfs2_start_trans(OCFS2_SB(t_inode->i_sb),\n\t\t\t\t   OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(t_inode), t_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tspin_lock(&OCFS2_I(t_inode)->ip_lock);\n\tOCFS2_I(t_inode)->ip_clusters = OCFS2_I(s_inode)->ip_clusters;\n\tOCFS2_I(t_inode)->ip_attr = OCFS2_I(s_inode)->ip_attr;\n\tOCFS2_I(t_inode)->ip_dyn_features = OCFS2_I(s_inode)->ip_dyn_features;\n\tspin_unlock(&OCFS2_I(t_inode)->ip_lock);\n\ti_size_write(t_inode, size);\n\tt_inode->i_blocks = s_inode->i_blocks;\n\n\tdi->i_xattr_inline_size = s_di->i_xattr_inline_size;\n\tdi->i_clusters = s_di->i_clusters;\n\tdi->i_size = s_di->i_size;\n\tdi->i_dyn_features = s_di->i_dyn_features;\n\tdi->i_attr = s_di->i_attr;\n\n\tif (preserve) {\n\t\tt_inode->i_uid = s_inode->i_uid;\n\t\tt_inode->i_gid = s_inode->i_gid;\n\t\tt_inode->i_mode = s_inode->i_mode;\n\t\tdi->i_uid = s_di->i_uid;\n\t\tdi->i_gid = s_di->i_gid;\n\t\tdi->i_mode = s_di->i_mode;\n\n\t\t/*\n\t\t * update time.\n\t\t * we want mtime to appear identical to the source and\n\t\t * update ctime.\n\t\t */\n\t\tt_inode->i_ctime = CURRENT_TIME;\n\n\t\tdi->i_ctime = cpu_to_le64(t_inode->i_ctime.tv_sec);\n\t\tdi->i_ctime_nsec = cpu_to_le32(t_inode->i_ctime.tv_nsec);\n\n\t\tt_inode->i_mtime = s_inode->i_mtime;\n\t\tdi->i_mtime = s_di->i_mtime;\n\t\tdi->i_mtime_nsec = s_di->i_mtime_nsec;\n\t}\n\n\tocfs2_journal_dirty(handle, t_bh);\n\nout_commit:\n\tocfs2_commit_trans(OCFS2_SB(t_inode->i_sb), handle);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_reflink_xattrs",
          "args": [
            "inode",
            "old_bh",
            "new_inode",
            "new_bh",
            "preserve"
          ],
          "line": 4234
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reflink_xattrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "7116-7189",
          "snippet": "int ocfs2_reflink_xattrs(struct inode *old_inode,\n\t\t\t struct buffer_head *old_bh,\n\t\t\t struct inode *new_inode,\n\t\t\t struct buffer_head *new_bh,\n\t\t\t bool preserve_security)\n{\n\tint ret;\n\tstruct ocfs2_xattr_reflink args;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(old_inode);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)old_bh->b_data;\n\tstruct buffer_head *blk_bh = NULL;\n\tstruct ocfs2_cached_dealloc_ctxt dealloc;\n\tstruct ocfs2_refcount_tree *ref_tree;\n\tstruct buffer_head *ref_root_bh = NULL;\n\n\tret = ocfs2_lock_refcount_tree(OCFS2_SB(old_inode->i_sb),\n\t\t\t\t       le64_to_cpu(di->i_refcount_loc),\n\t\t\t\t       1, &ref_tree, &ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_init_dealloc_ctxt(&dealloc);\n\n\targs.old_inode = old_inode;\n\targs.new_inode = new_inode;\n\targs.old_bh = old_bh;\n\targs.new_bh = new_bh;\n\targs.ref_ci = &ref_tree->rf_ci;\n\targs.ref_root_bh = ref_root_bh;\n\targs.dealloc = &dealloc;\n\tif (preserve_security)\n\t\targs.xattr_reflinked = NULL;\n\telse\n\t\targs.xattr_reflinked = ocfs2_reflink_xattr_no_security;\n\n\tif (oi->ip_dyn_features & OCFS2_INLINE_XATTR_FL) {\n\t\tret = ocfs2_reflink_xattr_inline(&args);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tif (!di->i_xattr_loc)\n\t\tgoto out_unlock;\n\n\tret = ocfs2_read_xattr_block(old_inode, le64_to_cpu(di->i_xattr_loc),\n\t\t\t\t     &blk_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out_unlock;\n\t}\n\n\tret = ocfs2_reflink_xattr_in_block(&args, blk_bh);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\tbrelse(blk_bh);\n\nout_unlock:\n\tocfs2_unlock_refcount_tree(OCFS2_SB(old_inode->i_sb),\n\t\t\t\t   ref_tree, 1);\n\tbrelse(ref_root_bh);\n\n\tif (ocfs2_dealloc_has_cluster(&dealloc)) {\n\t\tocfs2_schedule_truncate_log_flush(OCFS2_SB(old_inode->i_sb), 1);\n\t\tocfs2_run_deallocs(OCFS2_SB(old_inode->i_sb), &dealloc);\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nint ocfs2_reflink_xattrs(struct inode *old_inode,\n\t\t\t struct buffer_head *old_bh,\n\t\t\t struct inode *new_inode,\n\t\t\t struct buffer_head *new_bh,\n\t\t\t bool preserve_security)\n{\n\tint ret;\n\tstruct ocfs2_xattr_reflink args;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(old_inode);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)old_bh->b_data;\n\tstruct buffer_head *blk_bh = NULL;\n\tstruct ocfs2_cached_dealloc_ctxt dealloc;\n\tstruct ocfs2_refcount_tree *ref_tree;\n\tstruct buffer_head *ref_root_bh = NULL;\n\n\tret = ocfs2_lock_refcount_tree(OCFS2_SB(old_inode->i_sb),\n\t\t\t\t       le64_to_cpu(di->i_refcount_loc),\n\t\t\t\t       1, &ref_tree, &ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_init_dealloc_ctxt(&dealloc);\n\n\targs.old_inode = old_inode;\n\targs.new_inode = new_inode;\n\targs.old_bh = old_bh;\n\targs.new_bh = new_bh;\n\targs.ref_ci = &ref_tree->rf_ci;\n\targs.ref_root_bh = ref_root_bh;\n\targs.dealloc = &dealloc;\n\tif (preserve_security)\n\t\targs.xattr_reflinked = NULL;\n\telse\n\t\targs.xattr_reflinked = ocfs2_reflink_xattr_no_security;\n\n\tif (oi->ip_dyn_features & OCFS2_INLINE_XATTR_FL) {\n\t\tret = ocfs2_reflink_xattr_inline(&args);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tif (!di->i_xattr_loc)\n\t\tgoto out_unlock;\n\n\tret = ocfs2_read_xattr_block(old_inode, le64_to_cpu(di->i_xattr_loc),\n\t\t\t\t     &blk_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out_unlock;\n\t}\n\n\tret = ocfs2_reflink_xattr_in_block(&args, blk_bh);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\tbrelse(blk_bh);\n\nout_unlock:\n\tocfs2_unlock_refcount_tree(OCFS2_SB(old_inode->i_sb),\n\t\t\t\t   ref_tree, 1);\n\tbrelse(ref_root_bh);\n\n\tif (ocfs2_dealloc_has_cluster(&dealloc)) {\n\t\tocfs2_schedule_truncate_log_flush(OCFS2_SB(old_inode->i_sb), 1);\n\t\tocfs2_run_deallocs(OCFS2_SB(old_inode->i_sb), &dealloc);\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 4233
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_create_reflink_node",
          "args": [
            "inode",
            "old_bh",
            "new_inode",
            "new_bh",
            "preserve"
          ],
          "line": 4226
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_create_reflink_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "4132-4189",
          "snippet": "static int ocfs2_create_reflink_node(struct inode *s_inode,\n\t\t\t\t     struct buffer_head *s_bh,\n\t\t\t\t     struct inode *t_inode,\n\t\t\t\t     struct buffer_head *t_bh,\n\t\t\t\t     bool preserve)\n{\n\tint ret;\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_cached_dealloc_ctxt dealloc;\n\tstruct ocfs2_super *osb = OCFS2_SB(s_inode->i_sb);\n\tstruct ocfs2_refcount_block *rb;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)s_bh->b_data;\n\tstruct ocfs2_refcount_tree *ref_tree;\n\n\tocfs2_init_dealloc_ctxt(&dealloc);\n\n\tret = ocfs2_set_refcount_tree(t_inode, t_bh,\n\t\t\t\t      le64_to_cpu(di->i_refcount_loc));\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (OCFS2_I(s_inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tret = ocfs2_duplicate_inline_data(s_inode, s_bh,\n\t\t\t\t\t\t  t_inode, t_bh);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_lock_refcount_tree(osb, le64_to_cpu(di->i_refcount_loc),\n\t\t\t\t       1, &ref_tree, &ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\trb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\n\tret = ocfs2_duplicate_extent_list(s_inode, t_inode, t_bh,\n\t\t\t\t\t  &ref_tree->rf_ci, ref_root_bh,\n\t\t\t\t\t  &dealloc);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_unlock_refcount;\n\t}\n\nout_unlock_refcount:\n\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\tbrelse(ref_root_bh);\nout:\n\tif (ocfs2_dealloc_has_cluster(&dealloc)) {\n\t\tocfs2_schedule_truncate_log_flush(osb, 1);\n\t\tocfs2_run_deallocs(osb, &dealloc);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_create_reflink_node(struct inode *s_inode,\n\t\t\t\t     struct buffer_head *s_bh,\n\t\t\t\t     struct inode *t_inode,\n\t\t\t\t     struct buffer_head *t_bh,\n\t\t\t\t     bool preserve)\n{\n\tint ret;\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_cached_dealloc_ctxt dealloc;\n\tstruct ocfs2_super *osb = OCFS2_SB(s_inode->i_sb);\n\tstruct ocfs2_refcount_block *rb;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)s_bh->b_data;\n\tstruct ocfs2_refcount_tree *ref_tree;\n\n\tocfs2_init_dealloc_ctxt(&dealloc);\n\n\tret = ocfs2_set_refcount_tree(t_inode, t_bh,\n\t\t\t\t      le64_to_cpu(di->i_refcount_loc));\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (OCFS2_I(s_inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tret = ocfs2_duplicate_inline_data(s_inode, s_bh,\n\t\t\t\t\t\t  t_inode, t_bh);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_lock_refcount_tree(osb, le64_to_cpu(di->i_refcount_loc),\n\t\t\t\t       1, &ref_tree, &ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\trb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\n\tret = ocfs2_duplicate_extent_list(s_inode, t_inode, t_bh,\n\t\t\t\t\t  &ref_tree->rf_ci, ref_root_bh,\n\t\t\t\t\t  &dealloc);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_unlock_refcount;\n\t}\n\nout_unlock_refcount:\n\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\tbrelse(ref_root_bh);\nout:\n\tif (ocfs2_dealloc_has_cluster(&dealloc)) {\n\t\tocfs2_schedule_truncate_log_flush(osb, 1);\n\t\tocfs2_run_deallocs(osb, &dealloc);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock_nested",
          "args": [
            "new_inode",
            "&new_bh",
            "1",
            "OI_LS_REFLINK_TARGET"
          ],
          "line": 4219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock_nested",
          "args": [
            "&new_inode->i_mutex",
            "I_MUTEX_CHILD"
          ],
          "line": 4218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_attach_refcount_tree",
          "args": [
            "inode",
            "old_bh"
          ],
          "line": 4212
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_attach_refcount_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "3811-3911",
          "snippet": "static int ocfs2_attach_refcount_tree(struct inode *inode,\n\t\t\t\t      struct buffer_head *di_bh)\n{\n\tint ret, data_changed = 0;\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_refcount_tree *ref_tree;\n\tunsigned int ext_flags;\n\tloff_t size;\n\tu32 cpos, num_clusters, clusters, p_cluster;\n\tstruct ocfs2_cached_dealloc_ctxt dealloc;\n\tstruct ocfs2_extent_tree di_et;\n\n\tocfs2_init_dealloc_ctxt(&dealloc);\n\n\tif (!(oi->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL)) {\n\t\tret = ocfs2_create_refcount_tree(inode, di_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tBUG_ON(!di->i_refcount_loc);\n\tret = ocfs2_lock_refcount_tree(osb,\n\t\t\t\t       le64_to_cpu(di->i_refcount_loc), 1,\n\t\t\t\t       &ref_tree, &ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (oi->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\tgoto attach_xattr;\n\n\tocfs2_init_dinode_extent_tree(&di_et, INODE_CACHE(inode), di_bh);\n\n\tsize = i_size_read(inode);\n\tclusters = ocfs2_clusters_for_bytes(inode->i_sb, size);\n\n\tcpos = 0;\n\twhile (cpos < clusters) {\n\t\tret = ocfs2_get_clusters(inode, cpos, &p_cluster,\n\t\t\t\t\t &num_clusters, &ext_flags);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto unlock;\n\t\t}\n\t\tif (p_cluster && !(ext_flags & OCFS2_EXT_REFCOUNTED)) {\n\t\t\tret = ocfs2_add_refcount_flag(inode, &di_et,\n\t\t\t\t\t\t      &ref_tree->rf_ci,\n\t\t\t\t\t\t      ref_root_bh, cpos,\n\t\t\t\t\t\t      p_cluster, num_clusters,\n\t\t\t\t\t\t      &dealloc, NULL);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto unlock;\n\t\t\t}\n\n\t\t\tdata_changed = 1;\n\t\t}\n\t\tcpos += num_clusters;\n\t}\n\nattach_xattr:\n\tif (oi->ip_dyn_features & OCFS2_HAS_XATTR_FL) {\n\t\tret = ocfs2_xattr_attach_refcount_tree(inode, di_bh,\n\t\t\t\t\t\t       &ref_tree->rf_ci,\n\t\t\t\t\t\t       ref_root_bh,\n\t\t\t\t\t\t       &dealloc);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\tif (data_changed) {\n\t\tret = ocfs2_change_ctime(inode, di_bh);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\nunlock:\n\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\tbrelse(ref_root_bh);\n\n\tif (!ret && ocfs2_dealloc_has_cluster(&dealloc)) {\n\t\tocfs2_schedule_truncate_log_flush(osb, 1);\n\t\tocfs2_run_deallocs(osb, &dealloc);\n\t}\nout:\n\t/*\n\t * Empty the extent map so that we may get the right extent\n\t * record from the disk.\n\t */\n\tocfs2_extent_map_trunc(inode, 0);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_attach_refcount_tree(struct inode *inode,\n\t\t\t\t      struct buffer_head *di_bh)\n{\n\tint ret, data_changed = 0;\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_refcount_tree *ref_tree;\n\tunsigned int ext_flags;\n\tloff_t size;\n\tu32 cpos, num_clusters, clusters, p_cluster;\n\tstruct ocfs2_cached_dealloc_ctxt dealloc;\n\tstruct ocfs2_extent_tree di_et;\n\n\tocfs2_init_dealloc_ctxt(&dealloc);\n\n\tif (!(oi->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL)) {\n\t\tret = ocfs2_create_refcount_tree(inode, di_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tBUG_ON(!di->i_refcount_loc);\n\tret = ocfs2_lock_refcount_tree(osb,\n\t\t\t\t       le64_to_cpu(di->i_refcount_loc), 1,\n\t\t\t\t       &ref_tree, &ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (oi->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\tgoto attach_xattr;\n\n\tocfs2_init_dinode_extent_tree(&di_et, INODE_CACHE(inode), di_bh);\n\n\tsize = i_size_read(inode);\n\tclusters = ocfs2_clusters_for_bytes(inode->i_sb, size);\n\n\tcpos = 0;\n\twhile (cpos < clusters) {\n\t\tret = ocfs2_get_clusters(inode, cpos, &p_cluster,\n\t\t\t\t\t &num_clusters, &ext_flags);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto unlock;\n\t\t}\n\t\tif (p_cluster && !(ext_flags & OCFS2_EXT_REFCOUNTED)) {\n\t\t\tret = ocfs2_add_refcount_flag(inode, &di_et,\n\t\t\t\t\t\t      &ref_tree->rf_ci,\n\t\t\t\t\t\t      ref_root_bh, cpos,\n\t\t\t\t\t\t      p_cluster, num_clusters,\n\t\t\t\t\t\t      &dealloc, NULL);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto unlock;\n\t\t\t}\n\n\t\t\tdata_changed = 1;\n\t\t}\n\t\tcpos += num_clusters;\n\t}\n\nattach_xattr:\n\tif (oi->ip_dyn_features & OCFS2_HAS_XATTR_FL) {\n\t\tret = ocfs2_xattr_attach_refcount_tree(inode, di_bh,\n\t\t\t\t\t\t       &ref_tree->rf_ci,\n\t\t\t\t\t\t       ref_root_bh,\n\t\t\t\t\t\t       &dealloc);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\tif (data_changed) {\n\t\tret = ocfs2_change_ctime(inode, di_bh);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\nunlock:\n\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\tbrelse(ref_root_bh);\n\n\tif (!ret && ocfs2_dealloc_has_cluster(&dealloc)) {\n\t\tocfs2_schedule_truncate_log_flush(osb, 1);\n\t\tocfs2_run_deallocs(osb, &dealloc);\n\t}\nout:\n\t/*\n\t * Empty the extent map so that we may get the right extent\n\t * record from the disk.\n\t */\n\tocfs2_extent_map_trunc(inode, 0);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_fdatawrite",
          "args": [
            "inode->i_mapping"
          ],
          "line": 4206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4202
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int __ocfs2_reflink(struct dentry *old_dentry,\n\t\t\t   struct buffer_head *old_bh,\n\t\t\t   struct inode *new_inode,\n\t\t\t   bool preserve)\n{\n\tint ret;\n\tstruct inode *inode = old_dentry->d_inode;\n\tstruct buffer_head *new_bh = NULL;\n\n\tif (OCFS2_I(inode)->ip_flags & OCFS2_INODE_SYSTEM_FILE) {\n\t\tret = -EINVAL;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = filemap_fdatawrite(inode->i_mapping);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_attach_refcount_tree(inode, old_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tmutex_lock_nested(&new_inode->i_mutex, I_MUTEX_CHILD);\n\tret = ocfs2_inode_lock_nested(new_inode, &new_bh, 1,\n\t\t\t\t      OI_LS_REFLINK_TARGET);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_unlock;\n\t}\n\n\tret = ocfs2_create_reflink_node(inode, old_bh,\n\t\t\t\t\tnew_inode, new_bh, preserve);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto inode_unlock;\n\t}\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_HAS_XATTR_FL) {\n\t\tret = ocfs2_reflink_xattrs(inode, old_bh,\n\t\t\t\t\t   new_inode, new_bh,\n\t\t\t\t\t   preserve);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto inode_unlock;\n\t\t}\n\t}\n\n\tret = ocfs2_complete_reflink(inode, old_bh,\n\t\t\t\t     new_inode, new_bh, preserve);\n\tif (ret)\n\t\tmlog_errno(ret);\n\ninode_unlock:\n\tocfs2_inode_unlock(new_inode, 1);\n\tbrelse(new_bh);\nout_unlock:\n\tmutex_unlock(&new_inode->i_mutex);\nout:\n\tif (!ret) {\n\t\tret = filemap_fdatawait(inode->i_mapping);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_create_reflink_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "4132-4189",
    "snippet": "static int ocfs2_create_reflink_node(struct inode *s_inode,\n\t\t\t\t     struct buffer_head *s_bh,\n\t\t\t\t     struct inode *t_inode,\n\t\t\t\t     struct buffer_head *t_bh,\n\t\t\t\t     bool preserve)\n{\n\tint ret;\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_cached_dealloc_ctxt dealloc;\n\tstruct ocfs2_super *osb = OCFS2_SB(s_inode->i_sb);\n\tstruct ocfs2_refcount_block *rb;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)s_bh->b_data;\n\tstruct ocfs2_refcount_tree *ref_tree;\n\n\tocfs2_init_dealloc_ctxt(&dealloc);\n\n\tret = ocfs2_set_refcount_tree(t_inode, t_bh,\n\t\t\t\t      le64_to_cpu(di->i_refcount_loc));\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (OCFS2_I(s_inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tret = ocfs2_duplicate_inline_data(s_inode, s_bh,\n\t\t\t\t\t\t  t_inode, t_bh);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_lock_refcount_tree(osb, le64_to_cpu(di->i_refcount_loc),\n\t\t\t\t       1, &ref_tree, &ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\trb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\n\tret = ocfs2_duplicate_extent_list(s_inode, t_inode, t_bh,\n\t\t\t\t\t  &ref_tree->rf_ci, ref_root_bh,\n\t\t\t\t\t  &dealloc);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_unlock_refcount;\n\t}\n\nout_unlock_refcount:\n\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\tbrelse(ref_root_bh);\nout:\n\tif (ocfs2_dealloc_has_cluster(&dealloc)) {\n\t\tocfs2_schedule_truncate_log_flush(osb, 1);\n\t\tocfs2_run_deallocs(osb, &dealloc);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_run_deallocs",
          "args": [
            "osb",
            "&dealloc"
          ],
          "line": 4185
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_run_deallocs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "6472-6513",
          "snippet": "int ocfs2_run_deallocs(struct ocfs2_super *osb,\n\t\t       struct ocfs2_cached_dealloc_ctxt *ctxt)\n{\n\tint ret = 0, ret2;\n\tstruct ocfs2_per_slot_free_list *fl;\n\n\tif (!ctxt)\n\t\treturn 0;\n\n\twhile (ctxt->c_first_suballocator) {\n\t\tfl = ctxt->c_first_suballocator;\n\n\t\tif (fl->f_first) {\n\t\t\ttrace_ocfs2_run_deallocs(fl->f_inode_type,\n\t\t\t\t\t\t fl->f_slot);\n\t\t\tret2 = ocfs2_free_cached_blocks(osb,\n\t\t\t\t\t\t\tfl->f_inode_type,\n\t\t\t\t\t\t\tfl->f_slot,\n\t\t\t\t\t\t\tfl->f_first);\n\t\t\tif (ret2)\n\t\t\t\tmlog_errno(ret2);\n\t\t\tif (!ret)\n\t\t\t\tret = ret2;\n\t\t}\n\n\t\tctxt->c_first_suballocator = fl->f_next_suballocator;\n\t\tkfree(fl);\n\t}\n\n\tif (ctxt->c_global_allocator) {\n\t\tret2 = ocfs2_free_cached_clusters(osb,\n\t\t\t\t\t\t  ctxt->c_global_allocator);\n\t\tif (ret2)\n\t\t\tmlog_errno(ret2);\n\t\tif (!ret)\n\t\t\tret = ret2;\n\n\t\tctxt->c_global_allocator = NULL;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_run_deallocs(struct ocfs2_super *osb,\n\t\t       struct ocfs2_cached_dealloc_ctxt *ctxt)\n{\n\tint ret = 0, ret2;\n\tstruct ocfs2_per_slot_free_list *fl;\n\n\tif (!ctxt)\n\t\treturn 0;\n\n\twhile (ctxt->c_first_suballocator) {\n\t\tfl = ctxt->c_first_suballocator;\n\n\t\tif (fl->f_first) {\n\t\t\ttrace_ocfs2_run_deallocs(fl->f_inode_type,\n\t\t\t\t\t\t fl->f_slot);\n\t\t\tret2 = ocfs2_free_cached_blocks(osb,\n\t\t\t\t\t\t\tfl->f_inode_type,\n\t\t\t\t\t\t\tfl->f_slot,\n\t\t\t\t\t\t\tfl->f_first);\n\t\t\tif (ret2)\n\t\t\t\tmlog_errno(ret2);\n\t\t\tif (!ret)\n\t\t\t\tret = ret2;\n\t\t}\n\n\t\tctxt->c_first_suballocator = fl->f_next_suballocator;\n\t\tkfree(fl);\n\t}\n\n\tif (ctxt->c_global_allocator) {\n\t\tret2 = ocfs2_free_cached_clusters(osb,\n\t\t\t\t\t\t  ctxt->c_global_allocator);\n\t\tif (ret2)\n\t\t\tmlog_errno(ret2);\n\t\tif (!ret)\n\t\t\tret = ret2;\n\n\t\tctxt->c_global_allocator = NULL;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_schedule_truncate_log_flush",
          "args": [
            "osb",
            "1"
          ],
          "line": 4184
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_schedule_truncate_log_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "6057-6070",
          "snippet": "void ocfs2_schedule_truncate_log_flush(struct ocfs2_super *osb,\n\t\t\t\t       int cancel)\n{\n\tif (osb->osb_tl_inode &&\n\t\t\tatomic_read(&osb->osb_tl_disable) == 0) {\n\t\t/* We want to push off log flushes while truncates are\n\t\t * still running. */\n\t\tif (cancel)\n\t\t\tcancel_delayed_work(&osb->osb_truncate_log_wq);\n\n\t\tqueue_delayed_work(ocfs2_wq, &osb->osb_truncate_log_wq,\n\t\t\t\t   OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL (2 * HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL (2 * HZ)\n\nvoid ocfs2_schedule_truncate_log_flush(struct ocfs2_super *osb,\n\t\t\t\t       int cancel)\n{\n\tif (osb->osb_tl_inode &&\n\t\t\tatomic_read(&osb->osb_tl_disable) == 0) {\n\t\t/* We want to push off log flushes while truncates are\n\t\t * still running. */\n\t\tif (cancel)\n\t\t\tcancel_delayed_work(&osb->osb_truncate_log_wq);\n\n\t\tqueue_delayed_work(ocfs2_wq, &osb->osb_truncate_log_wq,\n\t\t\t\t   OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_dealloc_has_cluster",
          "args": [
            "&dealloc"
          ],
          "line": 4183
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dealloc_has_cluster",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
          "lines": "215-218",
          "snippet": "static inline int ocfs2_dealloc_has_cluster(struct ocfs2_cached_dealloc_ctxt *c)\n{\n\treturn c->c_global_allocator != NULL;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_dealloc_has_cluster(struct ocfs2_cached_dealloc_ctxt *c)\n{\n\treturn c->c_global_allocator != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "ref_root_bh"
          ],
          "line": 4181
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_unlock_refcount_tree",
          "args": [
            "osb",
            "ref_tree",
            "1"
          ],
          "line": 4180
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_refcount_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "526-536",
          "snippet": "void ocfs2_unlock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_refcount_tree *tree, int rw)\n{\n\tif (rw)\n\t\tup_write(&tree->rf_sem);\n\telse\n\t\tup_read(&tree->rf_sem);\n\n\tocfs2_refcount_unlock(tree, rw);\n\tocfs2_refcount_tree_put(tree);\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nvoid ocfs2_unlock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_refcount_tree *tree, int rw)\n{\n\tif (rw)\n\t\tup_write(&tree->rf_sem);\n\telse\n\t\tup_read(&tree->rf_sem);\n\n\tocfs2_refcount_unlock(tree, rw);\n\tocfs2_refcount_tree_put(tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_duplicate_extent_list",
          "args": [
            "s_inode",
            "t_inode",
            "t_bh",
            "&ref_tree->rf_ci",
            "ref_root_bh",
            "&dealloc"
          ],
          "line": 4171
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_duplicate_extent_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "4009-4053",
          "snippet": "static int ocfs2_duplicate_extent_list(struct inode *s_inode,\n\t\t\t\tstruct inode *t_inode,\n\t\t\t\tstruct buffer_head *t_bh,\n\t\t\t\tstruct ocfs2_caching_info *ref_ci,\n\t\t\t\tstruct buffer_head *ref_root_bh,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret = 0;\n\tu32 p_cluster, num_clusters, clusters, cpos;\n\tloff_t size;\n\tunsigned int ext_flags;\n\tstruct ocfs2_extent_tree et;\n\n\tocfs2_init_dinode_extent_tree(&et, INODE_CACHE(t_inode), t_bh);\n\n\tsize = i_size_read(s_inode);\n\tclusters = ocfs2_clusters_for_bytes(s_inode->i_sb, size);\n\n\tcpos = 0;\n\twhile (cpos < clusters) {\n\t\tret = ocfs2_get_clusters(s_inode, cpos, &p_cluster,\n\t\t\t\t\t &num_clusters, &ext_flags);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\tif (p_cluster) {\n\t\t\tret = ocfs2_add_refcounted_extent(t_inode, &et,\n\t\t\t\t\t\t\t  ref_ci, ref_root_bh,\n\t\t\t\t\t\t\t  cpos, p_cluster,\n\t\t\t\t\t\t\t  num_clusters,\n\t\t\t\t\t\t\t  ext_flags,\n\t\t\t\t\t\t\t  dealloc);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tcpos += num_clusters;\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_duplicate_extent_list(struct inode *s_inode,\n\t\t\t\tstruct inode *t_inode,\n\t\t\t\tstruct buffer_head *t_bh,\n\t\t\t\tstruct ocfs2_caching_info *ref_ci,\n\t\t\t\tstruct buffer_head *ref_root_bh,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret = 0;\n\tu32 p_cluster, num_clusters, clusters, cpos;\n\tloff_t size;\n\tunsigned int ext_flags;\n\tstruct ocfs2_extent_tree et;\n\n\tocfs2_init_dinode_extent_tree(&et, INODE_CACHE(t_inode), t_bh);\n\n\tsize = i_size_read(s_inode);\n\tclusters = ocfs2_clusters_for_bytes(s_inode->i_sb, size);\n\n\tcpos = 0;\n\twhile (cpos < clusters) {\n\t\tret = ocfs2_get_clusters(s_inode, cpos, &p_cluster,\n\t\t\t\t\t &num_clusters, &ext_flags);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\tif (p_cluster) {\n\t\t\tret = ocfs2_add_refcounted_extent(t_inode, &et,\n\t\t\t\t\t\t\t  ref_ci, ref_root_bh,\n\t\t\t\t\t\t\t  cpos, p_cluster,\n\t\t\t\t\t\t\t  num_clusters,\n\t\t\t\t\t\t\t  ext_flags,\n\t\t\t\t\t\t\t  dealloc);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tcpos += num_clusters;\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_lock_refcount_tree",
          "args": [
            "osb",
            "le64_to_cpu(di->i_refcount_loc)",
            "1",
            "&ref_tree",
            "&ref_root_bh"
          ],
          "line": 4163
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_refcount_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "452-524",
          "snippet": "int ocfs2_lock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t     u64 ref_blkno, int rw,\n\t\t\t     struct ocfs2_refcount_tree **ret_tree,\n\t\t\t     struct buffer_head **ref_bh)\n{\n\tint ret, delete_tree = 0;\n\tstruct ocfs2_refcount_tree *tree = NULL;\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_block *rb;\n\nagain:\n\tret = ocfs2_get_refcount_tree(osb, ref_blkno, &tree);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tocfs2_refcount_tree_get(tree);\n\n\tret = __ocfs2_lock_refcount_tree(osb, tree, rw);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_refcount_tree_put(tree);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_refcount_block(&tree->rf_ci, tree->rf_blkno,\n\t\t\t\t\t&ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_unlock_refcount_tree(osb, tree, rw);\n\t\tocfs2_refcount_tree_put(tree);\n\t\tgoto out;\n\t}\n\n\trb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\t/*\n\t * If the refcount block has been freed and re-created, we may need\n\t * to recreate the refcount tree also.\n\t *\n\t * Here we just remove the tree from the rb-tree, and the last\n\t * kref holder will unlock and delete this refcount_tree.\n\t * Then we goto \"again\" and ocfs2_get_refcount_tree will create\n\t * the new refcount tree for us.\n\t */\n\tif (tree->rf_generation != le32_to_cpu(rb->rf_generation)) {\n\t\tif (!tree->rf_removed) {\n\t\t\tocfs2_erase_refcount_tree_from_list(osb, tree);\n\t\t\ttree->rf_removed = 1;\n\t\t\tdelete_tree = 1;\n\t\t}\n\n\t\tocfs2_unlock_refcount_tree(osb, tree, rw);\n\t\t/*\n\t\t * We get an extra reference when we create the refcount\n\t\t * tree, so another put will destroy it.\n\t\t */\n\t\tif (delete_tree)\n\t\t\tocfs2_refcount_tree_put(tree);\n\t\tbrelse(ref_root_bh);\n\t\tref_root_bh = NULL;\n\t\tgoto again;\n\t}\n\n\t*ret_tree = tree;\n\tif (ref_bh) {\n\t\t*ref_bh = ref_root_bh;\n\t\tref_root_bh = NULL;\n\t}\nout:\n\tbrelse(ref_root_bh);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nint ocfs2_lock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t     u64 ref_blkno, int rw,\n\t\t\t     struct ocfs2_refcount_tree **ret_tree,\n\t\t\t     struct buffer_head **ref_bh)\n{\n\tint ret, delete_tree = 0;\n\tstruct ocfs2_refcount_tree *tree = NULL;\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_block *rb;\n\nagain:\n\tret = ocfs2_get_refcount_tree(osb, ref_blkno, &tree);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tocfs2_refcount_tree_get(tree);\n\n\tret = __ocfs2_lock_refcount_tree(osb, tree, rw);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_refcount_tree_put(tree);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_refcount_block(&tree->rf_ci, tree->rf_blkno,\n\t\t\t\t\t&ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_unlock_refcount_tree(osb, tree, rw);\n\t\tocfs2_refcount_tree_put(tree);\n\t\tgoto out;\n\t}\n\n\trb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\t/*\n\t * If the refcount block has been freed and re-created, we may need\n\t * to recreate the refcount tree also.\n\t *\n\t * Here we just remove the tree from the rb-tree, and the last\n\t * kref holder will unlock and delete this refcount_tree.\n\t * Then we goto \"again\" and ocfs2_get_refcount_tree will create\n\t * the new refcount tree for us.\n\t */\n\tif (tree->rf_generation != le32_to_cpu(rb->rf_generation)) {\n\t\tif (!tree->rf_removed) {\n\t\t\tocfs2_erase_refcount_tree_from_list(osb, tree);\n\t\t\ttree->rf_removed = 1;\n\t\t\tdelete_tree = 1;\n\t\t}\n\n\t\tocfs2_unlock_refcount_tree(osb, tree, rw);\n\t\t/*\n\t\t * We get an extra reference when we create the refcount\n\t\t * tree, so another put will destroy it.\n\t\t */\n\t\tif (delete_tree)\n\t\t\tocfs2_refcount_tree_put(tree);\n\t\tbrelse(ref_root_bh);\n\t\tref_root_bh = NULL;\n\t\tgoto again;\n\t}\n\n\t*ret_tree = tree;\n\tif (ref_bh) {\n\t\t*ref_bh = ref_root_bh;\n\t\tref_root_bh = NULL;\n\t}\nout:\n\tbrelse(ref_root_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "di->i_refcount_loc"
          ],
          "line": 4163
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_duplicate_inline_data",
          "args": [
            "s_inode",
            "s_bh",
            "t_inode",
            "t_bh"
          ],
          "line": 4156
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_duplicate_inline_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "3966-4007",
          "snippet": "static int ocfs2_duplicate_inline_data(struct inode *s_inode,\n\t\t\t\t       struct buffer_head *s_bh,\n\t\t\t\t       struct inode *t_inode,\n\t\t\t\t       struct buffer_head *t_bh)\n{\n\tint ret;\n\thandle_t *handle;\n\tstruct ocfs2_super *osb = OCFS2_SB(s_inode->i_sb);\n\tstruct ocfs2_dinode *s_di = (struct ocfs2_dinode *)s_bh->b_data;\n\tstruct ocfs2_dinode *t_di = (struct ocfs2_dinode *)t_bh->b_data;\n\n\tBUG_ON(!(OCFS2_I(s_inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL));\n\n\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(t_inode), t_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tt_di->id2.i_data.id_count = s_di->id2.i_data.id_count;\n\tmemcpy(t_di->id2.i_data.id_data, s_di->id2.i_data.id_data,\n\t       le16_to_cpu(s_di->id2.i_data.id_count));\n\tspin_lock(&OCFS2_I(t_inode)->ip_lock);\n\tOCFS2_I(t_inode)->ip_dyn_features |= OCFS2_INLINE_DATA_FL;\n\tt_di->i_dyn_features = cpu_to_le16(OCFS2_I(t_inode)->ip_dyn_features);\n\tspin_unlock(&OCFS2_I(t_inode)->ip_lock);\n\n\tocfs2_journal_dirty(handle, t_bh);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_duplicate_inline_data(struct inode *s_inode,\n\t\t\t\t       struct buffer_head *s_bh,\n\t\t\t\t       struct inode *t_inode,\n\t\t\t\t       struct buffer_head *t_bh)\n{\n\tint ret;\n\thandle_t *handle;\n\tstruct ocfs2_super *osb = OCFS2_SB(s_inode->i_sb);\n\tstruct ocfs2_dinode *s_di = (struct ocfs2_dinode *)s_bh->b_data;\n\tstruct ocfs2_dinode *t_di = (struct ocfs2_dinode *)t_bh->b_data;\n\n\tBUG_ON(!(OCFS2_I(s_inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL));\n\n\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(t_inode), t_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tt_di->id2.i_data.id_count = s_di->id2.i_data.id_count;\n\tmemcpy(t_di->id2.i_data.id_data, s_di->id2.i_data.id_data,\n\t       le16_to_cpu(s_di->id2.i_data.id_count));\n\tspin_lock(&OCFS2_I(t_inode)->ip_lock);\n\tOCFS2_I(t_inode)->ip_dyn_features |= OCFS2_INLINE_DATA_FL;\n\tt_di->i_dyn_features = cpu_to_le16(OCFS2_I(t_inode)->ip_dyn_features);\n\tspin_unlock(&OCFS2_I(t_inode)->ip_lock);\n\n\tocfs2_journal_dirty(handle, t_bh);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "s_inode"
          ],
          "line": 4155
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_set_refcount_tree",
          "args": [
            "t_inode",
            "t_bh",
            "le64_to_cpu(di->i_refcount_loc)"
          ],
          "line": 4148
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_refcount_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "700-762",
          "snippet": "static int ocfs2_set_refcount_tree(struct inode *inode,\n\t\t\t\t   struct buffer_head *di_bh,\n\t\t\t\t   u64 refcount_loc)\n{\n\tint ret;\n\thandle_t *handle = NULL;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_block *rb;\n\tstruct ocfs2_refcount_tree *ref_tree;\n\n\tBUG_ON(oi->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL);\n\n\tret = ocfs2_lock_refcount_tree(osb, refcount_loc, 1,\n\t\t\t\t       &ref_tree, &ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_REFCOUNT_TREE_SET_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tret = ocfs2_journal_access_rb(handle, &ref_tree->rf_ci, ref_root_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\trb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\tle32_add_cpu(&rb->rf_count, 1);\n\n\tocfs2_journal_dirty(handle, ref_root_bh);\n\n\tspin_lock(&oi->ip_lock);\n\toi->ip_dyn_features |= OCFS2_HAS_REFCOUNT_FL;\n\tdi->i_dyn_features = cpu_to_le16(oi->ip_dyn_features);\n\tdi->i_refcount_loc = cpu_to_le64(refcount_loc);\n\tspin_unlock(&oi->ip_lock);\n\tocfs2_journal_dirty(handle, di_bh);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\nout:\n\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\tbrelse(ref_root_bh);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_set_refcount_tree(struct inode *inode,\n\t\t\t\t   struct buffer_head *di_bh,\n\t\t\t\t   u64 refcount_loc)\n{\n\tint ret;\n\thandle_t *handle = NULL;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_block *rb;\n\tstruct ocfs2_refcount_tree *ref_tree;\n\n\tBUG_ON(oi->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL);\n\n\tret = ocfs2_lock_refcount_tree(osb, refcount_loc, 1,\n\t\t\t\t       &ref_tree, &ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_REFCOUNT_TREE_SET_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tret = ocfs2_journal_access_rb(handle, &ref_tree->rf_ci, ref_root_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\trb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\tle32_add_cpu(&rb->rf_count, 1);\n\n\tocfs2_journal_dirty(handle, ref_root_bh);\n\n\tspin_lock(&oi->ip_lock);\n\toi->ip_dyn_features |= OCFS2_HAS_REFCOUNT_FL;\n\tdi->i_dyn_features = cpu_to_le16(oi->ip_dyn_features);\n\tdi->i_refcount_loc = cpu_to_le64(refcount_loc);\n\tspin_unlock(&oi->ip_lock);\n\tocfs2_journal_dirty(handle, di_bh);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\nout:\n\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\tbrelse(ref_root_bh);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_init_dealloc_ctxt",
          "args": [
            "&dealloc"
          ],
          "line": 4146
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_dealloc_ctxt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
          "lines": "205-209",
          "snippet": "static inline void ocfs2_init_dealloc_ctxt(struct ocfs2_cached_dealloc_ctxt *c)\n{\n\tc->c_first_suballocator = NULL;\n\tc->c_global_allocator = NULL;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void ocfs2_init_dealloc_ctxt(struct ocfs2_cached_dealloc_ctxt *c)\n{\n\tc->c_first_suballocator = NULL;\n\tc->c_global_allocator = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "s_inode->i_sb"
          ],
          "line": 4141
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_create_reflink_node(struct inode *s_inode,\n\t\t\t\t     struct buffer_head *s_bh,\n\t\t\t\t     struct inode *t_inode,\n\t\t\t\t     struct buffer_head *t_bh,\n\t\t\t\t     bool preserve)\n{\n\tint ret;\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_cached_dealloc_ctxt dealloc;\n\tstruct ocfs2_super *osb = OCFS2_SB(s_inode->i_sb);\n\tstruct ocfs2_refcount_block *rb;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)s_bh->b_data;\n\tstruct ocfs2_refcount_tree *ref_tree;\n\n\tocfs2_init_dealloc_ctxt(&dealloc);\n\n\tret = ocfs2_set_refcount_tree(t_inode, t_bh,\n\t\t\t\t      le64_to_cpu(di->i_refcount_loc));\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (OCFS2_I(s_inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tret = ocfs2_duplicate_inline_data(s_inode, s_bh,\n\t\t\t\t\t\t  t_inode, t_bh);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_lock_refcount_tree(osb, le64_to_cpu(di->i_refcount_loc),\n\t\t\t\t       1, &ref_tree, &ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\trb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\n\tret = ocfs2_duplicate_extent_list(s_inode, t_inode, t_bh,\n\t\t\t\t\t  &ref_tree->rf_ci, ref_root_bh,\n\t\t\t\t\t  &dealloc);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_unlock_refcount;\n\t}\n\nout_unlock_refcount:\n\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\tbrelse(ref_root_bh);\nout:\n\tif (ocfs2_dealloc_has_cluster(&dealloc)) {\n\t\tocfs2_schedule_truncate_log_flush(osb, 1);\n\t\tocfs2_run_deallocs(osb, &dealloc);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_complete_reflink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "4061-4130",
    "snippet": "static int ocfs2_complete_reflink(struct inode *s_inode,\n\t\t\t\t  struct buffer_head *s_bh,\n\t\t\t\t  struct inode *t_inode,\n\t\t\t\t  struct buffer_head *t_bh,\n\t\t\t\t  bool preserve)\n{\n\tint ret;\n\thandle_t *handle;\n\tstruct ocfs2_dinode *s_di = (struct ocfs2_dinode *)s_bh->b_data;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)t_bh->b_data;\n\tloff_t size = i_size_read(s_inode);\n\n\thandle = ocfs2_start_trans(OCFS2_SB(t_inode->i_sb),\n\t\t\t\t   OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(t_inode), t_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tspin_lock(&OCFS2_I(t_inode)->ip_lock);\n\tOCFS2_I(t_inode)->ip_clusters = OCFS2_I(s_inode)->ip_clusters;\n\tOCFS2_I(t_inode)->ip_attr = OCFS2_I(s_inode)->ip_attr;\n\tOCFS2_I(t_inode)->ip_dyn_features = OCFS2_I(s_inode)->ip_dyn_features;\n\tspin_unlock(&OCFS2_I(t_inode)->ip_lock);\n\ti_size_write(t_inode, size);\n\tt_inode->i_blocks = s_inode->i_blocks;\n\n\tdi->i_xattr_inline_size = s_di->i_xattr_inline_size;\n\tdi->i_clusters = s_di->i_clusters;\n\tdi->i_size = s_di->i_size;\n\tdi->i_dyn_features = s_di->i_dyn_features;\n\tdi->i_attr = s_di->i_attr;\n\n\tif (preserve) {\n\t\tt_inode->i_uid = s_inode->i_uid;\n\t\tt_inode->i_gid = s_inode->i_gid;\n\t\tt_inode->i_mode = s_inode->i_mode;\n\t\tdi->i_uid = s_di->i_uid;\n\t\tdi->i_gid = s_di->i_gid;\n\t\tdi->i_mode = s_di->i_mode;\n\n\t\t/*\n\t\t * update time.\n\t\t * we want mtime to appear identical to the source and\n\t\t * update ctime.\n\t\t */\n\t\tt_inode->i_ctime = CURRENT_TIME;\n\n\t\tdi->i_ctime = cpu_to_le64(t_inode->i_ctime.tv_sec);\n\t\tdi->i_ctime_nsec = cpu_to_le32(t_inode->i_ctime.tv_nsec);\n\n\t\tt_inode->i_mtime = s_inode->i_mtime;\n\t\tdi->i_mtime = s_di->i_mtime;\n\t\tdi->i_mtime_nsec = s_di->i_mtime_nsec;\n\t}\n\n\tocfs2_journal_dirty(handle, t_bh);\n\nout_commit:\n\tocfs2_commit_trans(OCFS2_SB(t_inode->i_sb), handle);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "OCFS2_SB(t_inode->i_sb)",
            "handle"
          ],
          "line": 4128
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "t_inode->i_sb"
          ],
          "line": 4128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "t_bh"
          ],
          "line": 4125
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "t_inode->i_ctime.tv_nsec"
          ],
          "line": 4118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "t_inode->i_ctime.tv_sec"
          ],
          "line": 4117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_write",
          "args": [
            "t_inode",
            "size"
          ],
          "line": 4093
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_i_size_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/btrfs_inode.h",
          "lines": "233-237",
          "snippet": "static inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}",
          "includes": [
            "#include \"delayed-inode.h\"",
            "#include \"ordered-data.h\"",
            "#include \"extent_io.h\"",
            "#include \"extent_map.h\"",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"delayed-inode.h\"\n#include \"ordered-data.h\"\n#include \"extent_io.h\"\n#include \"extent_map.h\"\n#include <linux/hash.h>\n\nstatic inline void btrfs_i_size_write(struct inode *inode, u64 size)\n{\n\ti_size_write(inode, size);\n\tBTRFS_I(inode)->disk_i_size = size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&OCFS2_I(t_inode)->ip_lock"
          ],
          "line": 4092
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "t_inode"
          ],
          "line": 4092
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&OCFS2_I(t_inode)->ip_lock"
          ],
          "line": 4088
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_di",
          "args": [
            "handle",
            "INODE_CACHE(t_inode)",
            "t_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 4081
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_di",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "710-714",
          "snippet": "int ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};\n\nint ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "t_inode"
          ],
          "line": 4081
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 4076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 4075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "OCFS2_SB(t_inode->i_sb)",
            "OCFS2_INODE_UPDATE_CREDITS"
          ],
          "line": 4073
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "t_inode->i_sb"
          ],
          "line": 4073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "s_inode"
          ],
          "line": 4071
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_complete_reflink(struct inode *s_inode,\n\t\t\t\t  struct buffer_head *s_bh,\n\t\t\t\t  struct inode *t_inode,\n\t\t\t\t  struct buffer_head *t_bh,\n\t\t\t\t  bool preserve)\n{\n\tint ret;\n\thandle_t *handle;\n\tstruct ocfs2_dinode *s_di = (struct ocfs2_dinode *)s_bh->b_data;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)t_bh->b_data;\n\tloff_t size = i_size_read(s_inode);\n\n\thandle = ocfs2_start_trans(OCFS2_SB(t_inode->i_sb),\n\t\t\t\t   OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(t_inode), t_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tspin_lock(&OCFS2_I(t_inode)->ip_lock);\n\tOCFS2_I(t_inode)->ip_clusters = OCFS2_I(s_inode)->ip_clusters;\n\tOCFS2_I(t_inode)->ip_attr = OCFS2_I(s_inode)->ip_attr;\n\tOCFS2_I(t_inode)->ip_dyn_features = OCFS2_I(s_inode)->ip_dyn_features;\n\tspin_unlock(&OCFS2_I(t_inode)->ip_lock);\n\ti_size_write(t_inode, size);\n\tt_inode->i_blocks = s_inode->i_blocks;\n\n\tdi->i_xattr_inline_size = s_di->i_xattr_inline_size;\n\tdi->i_clusters = s_di->i_clusters;\n\tdi->i_size = s_di->i_size;\n\tdi->i_dyn_features = s_di->i_dyn_features;\n\tdi->i_attr = s_di->i_attr;\n\n\tif (preserve) {\n\t\tt_inode->i_uid = s_inode->i_uid;\n\t\tt_inode->i_gid = s_inode->i_gid;\n\t\tt_inode->i_mode = s_inode->i_mode;\n\t\tdi->i_uid = s_di->i_uid;\n\t\tdi->i_gid = s_di->i_gid;\n\t\tdi->i_mode = s_di->i_mode;\n\n\t\t/*\n\t\t * update time.\n\t\t * we want mtime to appear identical to the source and\n\t\t * update ctime.\n\t\t */\n\t\tt_inode->i_ctime = CURRENT_TIME;\n\n\t\tdi->i_ctime = cpu_to_le64(t_inode->i_ctime.tv_sec);\n\t\tdi->i_ctime_nsec = cpu_to_le32(t_inode->i_ctime.tv_nsec);\n\n\t\tt_inode->i_mtime = s_inode->i_mtime;\n\t\tdi->i_mtime = s_di->i_mtime;\n\t\tdi->i_mtime_nsec = s_di->i_mtime_nsec;\n\t}\n\n\tocfs2_journal_dirty(handle, t_bh);\n\nout_commit:\n\tocfs2_commit_trans(OCFS2_SB(t_inode->i_sb), handle);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_duplicate_extent_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "4009-4053",
    "snippet": "static int ocfs2_duplicate_extent_list(struct inode *s_inode,\n\t\t\t\tstruct inode *t_inode,\n\t\t\t\tstruct buffer_head *t_bh,\n\t\t\t\tstruct ocfs2_caching_info *ref_ci,\n\t\t\t\tstruct buffer_head *ref_root_bh,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret = 0;\n\tu32 p_cluster, num_clusters, clusters, cpos;\n\tloff_t size;\n\tunsigned int ext_flags;\n\tstruct ocfs2_extent_tree et;\n\n\tocfs2_init_dinode_extent_tree(&et, INODE_CACHE(t_inode), t_bh);\n\n\tsize = i_size_read(s_inode);\n\tclusters = ocfs2_clusters_for_bytes(s_inode->i_sb, size);\n\n\tcpos = 0;\n\twhile (cpos < clusters) {\n\t\tret = ocfs2_get_clusters(s_inode, cpos, &p_cluster,\n\t\t\t\t\t &num_clusters, &ext_flags);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\tif (p_cluster) {\n\t\t\tret = ocfs2_add_refcounted_extent(t_inode, &et,\n\t\t\t\t\t\t\t  ref_ci, ref_root_bh,\n\t\t\t\t\t\t\t  cpos, p_cluster,\n\t\t\t\t\t\t\t  num_clusters,\n\t\t\t\t\t\t\t  ext_flags,\n\t\t\t\t\t\t\t  dealloc);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tcpos += num_clusters;\n\t}\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_add_refcounted_extent",
          "args": [
            "t_inode",
            "&et",
            "ref_ci",
            "ref_root_bh",
            "cpos",
            "p_cluster",
            "num_clusters",
            "ext_flags",
            "dealloc"
          ],
          "line": 4036
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_add_refcounted_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "3913-3964",
          "snippet": "static int ocfs2_add_refcounted_extent(struct inode *inode,\n\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t   struct ocfs2_caching_info *ref_ci,\n\t\t\t\t   struct buffer_head *ref_root_bh,\n\t\t\t\t   u32 cpos, u32 p_cluster, u32 num_clusters,\n\t\t\t\t   unsigned int ext_flags,\n\t\t\t\t   struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret;\n\thandle_t *handle;\n\tint credits = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\n\tret = ocfs2_lock_refcount_allocators(inode->i_sb,\n\t\t\t\t\t     p_cluster, num_clusters,\n\t\t\t\t\t     et, ref_ci,\n\t\t\t\t\t     ref_root_bh, &meta_ac,\n\t\t\t\t\t     NULL, &credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_insert_extent(handle, et, cpos,\n\t\t\tocfs2_clusters_to_blocks(inode->i_sb, p_cluster),\n\t\t\tnum_clusters, ext_flags, meta_ac);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tret = ocfs2_increase_refcount(handle, ref_ci, ref_root_bh,\n\t\t\t\t      p_cluster, num_clusters,\n\t\t\t\t      meta_ac, dealloc);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\nout:\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_add_refcounted_extent(struct inode *inode,\n\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t   struct ocfs2_caching_info *ref_ci,\n\t\t\t\t   struct buffer_head *ref_root_bh,\n\t\t\t\t   u32 cpos, u32 p_cluster, u32 num_clusters,\n\t\t\t\t   unsigned int ext_flags,\n\t\t\t\t   struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret;\n\thandle_t *handle;\n\tint credits = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\n\tret = ocfs2_lock_refcount_allocators(inode->i_sb,\n\t\t\t\t\t     p_cluster, num_clusters,\n\t\t\t\t\t     et, ref_ci,\n\t\t\t\t\t     ref_root_bh, &meta_ac,\n\t\t\t\t\t     NULL, &credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_insert_extent(handle, et, cpos,\n\t\t\tocfs2_clusters_to_blocks(inode->i_sb, p_cluster),\n\t\t\tnum_clusters, ext_flags, meta_ac);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tret = ocfs2_increase_refcount(handle, ref_ci, ref_root_bh,\n\t\t\t\t      p_cluster, num_clusters,\n\t\t\t\t      meta_ac, dealloc);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\nout:\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 4032
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_clusters",
          "args": [
            "s_inode",
            "cpos",
            "&p_cluster",
            "&num_clusters",
            "&ext_flags"
          ],
          "line": 4029
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_get_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
          "lines": "608-665",
          "snippet": "int ocfs2_get_clusters(struct inode *inode, u32 v_cluster,\n\t\t       u32 *p_cluster, u32 *num_clusters,\n\t\t       unsigned int *extent_flags)\n{\n\tint ret;\n\tunsigned int uninitialized_var(hole_len), flags = 0;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_extent_rec rec;\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tret = -ERANGE;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_extent_map_lookup(inode, v_cluster, p_cluster,\n\t\t\t\t      num_clusters, extent_flags);\n\tif (ret == 0)\n\t\tgoto out;\n\n\tret = ocfs2_read_inode_block(inode, &di_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_get_clusters_nocache(inode, di_bh, v_cluster, &hole_len,\n\t\t\t\t\t &rec, NULL);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (rec.e_blkno == 0ULL) {\n\t\t/*\n\t\t * A hole was found. Return some canned values that\n\t\t * callers can key on. If asked for, num_clusters will\n\t\t * be populated with the size of the hole.\n\t\t */\n\t\t*p_cluster = 0;\n\t\tif (num_clusters) {\n\t\t\t*num_clusters = hole_len;\n\t\t}\n\t} else {\n\t\tocfs2_relative_extent_offsets(inode->i_sb, v_cluster, &rec,\n\t\t\t\t\t      p_cluster, num_clusters);\n\t\tflags = rec.e_flags;\n\n\t\tocfs2_extent_map_insert_rec(inode, &rec);\n\t}\n\n\tif (extent_flags)\n\t\t*extent_flags = flags;\n\nout:\n\tbrelse(di_bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nint ocfs2_get_clusters(struct inode *inode, u32 v_cluster,\n\t\t       u32 *p_cluster, u32 *num_clusters,\n\t\t       unsigned int *extent_flags)\n{\n\tint ret;\n\tunsigned int uninitialized_var(hole_len), flags = 0;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_extent_rec rec;\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tret = -ERANGE;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_extent_map_lookup(inode, v_cluster, p_cluster,\n\t\t\t\t      num_clusters, extent_flags);\n\tif (ret == 0)\n\t\tgoto out;\n\n\tret = ocfs2_read_inode_block(inode, &di_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_get_clusters_nocache(inode, di_bh, v_cluster, &hole_len,\n\t\t\t\t\t &rec, NULL);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (rec.e_blkno == 0ULL) {\n\t\t/*\n\t\t * A hole was found. Return some canned values that\n\t\t * callers can key on. If asked for, num_clusters will\n\t\t * be populated with the size of the hole.\n\t\t */\n\t\t*p_cluster = 0;\n\t\tif (num_clusters) {\n\t\t\t*num_clusters = hole_len;\n\t\t}\n\t} else {\n\t\tocfs2_relative_extent_offsets(inode->i_sb, v_cluster, &rec,\n\t\t\t\t\t      p_cluster, num_clusters);\n\t\tflags = rec.e_flags;\n\n\t\tocfs2_extent_map_insert_rec(inode, &rec);\n\t}\n\n\tif (extent_flags)\n\t\t*extent_flags = flags;\n\nout:\n\tbrelse(di_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_for_bytes",
          "args": [
            "s_inode->i_sb",
            "size"
          ],
          "line": 4025
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_for_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "729-740",
          "snippet": "static inline unsigned int ocfs2_clusters_for_bytes(struct super_block *sb,\n\t\t\t\t\t\t    u64 bytes)\n{\n\tint cl_bits = OCFS2_SB(sb)->s_clustersize_bits;\n\tunsigned int clusters;\n\n\tbytes += OCFS2_SB(sb)->s_clustersize - 1;\n\t/* OCFS2 just cannot have enough clusters to overflow this */\n\tclusters = (unsigned int)(bytes >> cl_bits);\n\n\treturn clusters;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline unsigned int ocfs2_clusters_for_bytes(struct super_block *sb,\n\t\t\t\t\t\t    u64 bytes)\n{\n\tint cl_bits = OCFS2_SB(sb)->s_clustersize_bits;\n\tunsigned int clusters;\n\n\tbytes += OCFS2_SB(sb)->s_clustersize - 1;\n\t/* OCFS2 just cannot have enough clusters to overflow this */\n\tclusters = (unsigned int)(bytes >> cl_bits);\n\n\treturn clusters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "s_inode"
          ],
          "line": 4024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_init_dinode_extent_tree",
          "args": [
            "&et",
            "INODE_CACHE(t_inode)",
            "t_bh"
          ],
          "line": 4022
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_dinode_extent_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "458-464",
          "snippet": "void ocfs2_init_dinode_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t   struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_di,\n\t\t\t\t NULL, &ocfs2_dinode_et_ops);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static struct ocfs2_extent_tree_operations ocfs2_dinode_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_dinode_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_dinode_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_dinode_update_clusters,\n\t.eo_extent_map_insert\t= ocfs2_dinode_extent_map_insert,\n\t.eo_extent_map_truncate\t= ocfs2_dinode_extent_map_truncate,\n\t.eo_insert_check\t= ocfs2_dinode_insert_check,\n\t.eo_sanity_check\t= ocfs2_dinode_sanity_check,\n\t.eo_fill_root_el\t= ocfs2_dinode_fill_root_el,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic struct ocfs2_extent_tree_operations ocfs2_dinode_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_dinode_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_dinode_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_dinode_update_clusters,\n\t.eo_extent_map_insert\t= ocfs2_dinode_extent_map_insert,\n\t.eo_extent_map_truncate\t= ocfs2_dinode_extent_map_truncate,\n\t.eo_insert_check\t= ocfs2_dinode_insert_check,\n\t.eo_sanity_check\t= ocfs2_dinode_sanity_check,\n\t.eo_fill_root_el\t= ocfs2_dinode_fill_root_el,\n};\n\nvoid ocfs2_init_dinode_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t   struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_di,\n\t\t\t\t NULL, &ocfs2_dinode_et_ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "t_inode"
          ],
          "line": 4022
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_duplicate_extent_list(struct inode *s_inode,\n\t\t\t\tstruct inode *t_inode,\n\t\t\t\tstruct buffer_head *t_bh,\n\t\t\t\tstruct ocfs2_caching_info *ref_ci,\n\t\t\t\tstruct buffer_head *ref_root_bh,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret = 0;\n\tu32 p_cluster, num_clusters, clusters, cpos;\n\tloff_t size;\n\tunsigned int ext_flags;\n\tstruct ocfs2_extent_tree et;\n\n\tocfs2_init_dinode_extent_tree(&et, INODE_CACHE(t_inode), t_bh);\n\n\tsize = i_size_read(s_inode);\n\tclusters = ocfs2_clusters_for_bytes(s_inode->i_sb, size);\n\n\tcpos = 0;\n\twhile (cpos < clusters) {\n\t\tret = ocfs2_get_clusters(s_inode, cpos, &p_cluster,\n\t\t\t\t\t &num_clusters, &ext_flags);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\tif (p_cluster) {\n\t\t\tret = ocfs2_add_refcounted_extent(t_inode, &et,\n\t\t\t\t\t\t\t  ref_ci, ref_root_bh,\n\t\t\t\t\t\t\t  cpos, p_cluster,\n\t\t\t\t\t\t\t  num_clusters,\n\t\t\t\t\t\t\t  ext_flags,\n\t\t\t\t\t\t\t  dealloc);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tcpos += num_clusters;\n\t}\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_duplicate_inline_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "3966-4007",
    "snippet": "static int ocfs2_duplicate_inline_data(struct inode *s_inode,\n\t\t\t\t       struct buffer_head *s_bh,\n\t\t\t\t       struct inode *t_inode,\n\t\t\t\t       struct buffer_head *t_bh)\n{\n\tint ret;\n\thandle_t *handle;\n\tstruct ocfs2_super *osb = OCFS2_SB(s_inode->i_sb);\n\tstruct ocfs2_dinode *s_di = (struct ocfs2_dinode *)s_bh->b_data;\n\tstruct ocfs2_dinode *t_di = (struct ocfs2_dinode *)t_bh->b_data;\n\n\tBUG_ON(!(OCFS2_I(s_inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL));\n\n\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(t_inode), t_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tt_di->id2.i_data.id_count = s_di->id2.i_data.id_count;\n\tmemcpy(t_di->id2.i_data.id_data, s_di->id2.i_data.id_data,\n\t       le16_to_cpu(s_di->id2.i_data.id_count));\n\tspin_lock(&OCFS2_I(t_inode)->ip_lock);\n\tOCFS2_I(t_inode)->ip_dyn_features |= OCFS2_INLINE_DATA_FL;\n\tt_di->i_dyn_features = cpu_to_le16(OCFS2_I(t_inode)->ip_dyn_features);\n\tspin_unlock(&OCFS2_I(t_inode)->ip_lock);\n\n\tocfs2_journal_dirty(handle, t_bh);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "handle"
          ],
          "line": 4004
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "t_bh"
          ],
          "line": 4001
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&OCFS2_I(t_inode)->ip_lock"
          ],
          "line": 3999
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "t_inode"
          ],
          "line": 3999
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "OCFS2_I(t_inode)->ip_dyn_features"
          ],
          "line": 3998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&OCFS2_I(t_inode)->ip_lock"
          ],
          "line": 3996
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "t_di->id2.i_data.id_data",
            "s_di->id2.i_data.id_data",
            "le16_to_cpu(s_di->id2.i_data.id_count)"
          ],
          "line": 3994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "s_di->id2.i_data.id_count"
          ],
          "line": 3995
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_di",
          "args": [
            "handle",
            "INODE_CACHE(t_inode)",
            "t_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 3986
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_di",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "710-714",
          "snippet": "int ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};\n\nint ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "t_inode"
          ],
          "line": 3986
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 3981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 3980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "OCFS2_INODE_UPDATE_CREDITS"
          ],
          "line": 3979
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(OCFS2_I(s_inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL)"
          ],
          "line": 3977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "s_inode->i_sb"
          ],
          "line": 3973
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_duplicate_inline_data(struct inode *s_inode,\n\t\t\t\t       struct buffer_head *s_bh,\n\t\t\t\t       struct inode *t_inode,\n\t\t\t\t       struct buffer_head *t_bh)\n{\n\tint ret;\n\thandle_t *handle;\n\tstruct ocfs2_super *osb = OCFS2_SB(s_inode->i_sb);\n\tstruct ocfs2_dinode *s_di = (struct ocfs2_dinode *)s_bh->b_data;\n\tstruct ocfs2_dinode *t_di = (struct ocfs2_dinode *)t_bh->b_data;\n\n\tBUG_ON(!(OCFS2_I(s_inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL));\n\n\thandle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(t_inode), t_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tt_di->id2.i_data.id_count = s_di->id2.i_data.id_count;\n\tmemcpy(t_di->id2.i_data.id_data, s_di->id2.i_data.id_data,\n\t       le16_to_cpu(s_di->id2.i_data.id_count));\n\tspin_lock(&OCFS2_I(t_inode)->ip_lock);\n\tOCFS2_I(t_inode)->ip_dyn_features |= OCFS2_INLINE_DATA_FL;\n\tt_di->i_dyn_features = cpu_to_le16(OCFS2_I(t_inode)->ip_dyn_features);\n\tspin_unlock(&OCFS2_I(t_inode)->ip_lock);\n\n\tocfs2_journal_dirty(handle, t_bh);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_add_refcounted_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "3913-3964",
    "snippet": "static int ocfs2_add_refcounted_extent(struct inode *inode,\n\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t   struct ocfs2_caching_info *ref_ci,\n\t\t\t\t   struct buffer_head *ref_root_bh,\n\t\t\t\t   u32 cpos, u32 p_cluster, u32 num_clusters,\n\t\t\t\t   unsigned int ext_flags,\n\t\t\t\t   struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret;\n\thandle_t *handle;\n\tint credits = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\n\tret = ocfs2_lock_refcount_allocators(inode->i_sb,\n\t\t\t\t\t     p_cluster, num_clusters,\n\t\t\t\t\t     et, ref_ci,\n\t\t\t\t\t     ref_root_bh, &meta_ac,\n\t\t\t\t\t     NULL, &credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_insert_extent(handle, et, cpos,\n\t\t\tocfs2_clusters_to_blocks(inode->i_sb, p_cluster),\n\t\t\tnum_clusters, ext_flags, meta_ac);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tret = ocfs2_increase_refcount(handle, ref_ci, ref_root_bh,\n\t\t\t\t      p_cluster, num_clusters,\n\t\t\t\t      meta_ac, dealloc);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\nout:\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_free_alloc_context",
          "args": [
            "meta_ac"
          ],
          "line": 3962
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_alloc_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "158-162",
          "snippet": "void ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nvoid ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "handle"
          ],
          "line": 3959
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_increase_refcount",
          "args": [
            "handle",
            "ref_ci",
            "ref_root_bh",
            "p_cluster",
            "num_clusters",
            "meta_ac",
            "dealloc"
          ],
          "line": 3952
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_increase_refcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "2166-2176",
          "snippet": "int ocfs2_increase_refcount(handle_t *handle,\n\t\t\t    struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *ref_root_bh,\n\t\t\t    u64 cpos, u32 len,\n\t\t\t    struct ocfs2_alloc_context *meta_ac,\n\t\t\t    struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\treturn __ocfs2_increase_refcount(handle, ci, ref_root_bh,\n\t\t\t\t\t cpos, len, 1,\n\t\t\t\t\t meta_ac, dealloc);\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nint ocfs2_increase_refcount(handle_t *handle,\n\t\t\t    struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *ref_root_bh,\n\t\t\t    u64 cpos, u32 len,\n\t\t\t    struct ocfs2_alloc_context *meta_ac,\n\t\t\t    struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\treturn __ocfs2_increase_refcount(handle, ci, ref_root_bh,\n\t\t\t\t\t cpos, len, 1,\n\t\t\t\t\t meta_ac, dealloc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_insert_extent",
          "args": [
            "handle",
            "et",
            "cpos",
            "ocfs2_clusters_to_blocks(inode->i_sb, p_cluster)",
            "num_clusters",
            "ext_flags",
            "meta_ac"
          ],
          "line": 3944
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_insert_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "4665-4726",
          "snippet": "int ocfs2_insert_extent(handle_t *handle,\n\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\tu32 cpos,\n\t\t\tu64 start_blk,\n\t\t\tu32 new_clusters,\n\t\t\tu8 flags,\n\t\t\tstruct ocfs2_alloc_context *meta_ac)\n{\n\tint status;\n\tint uninitialized_var(free_records);\n\tstruct buffer_head *last_eb_bh = NULL;\n\tstruct ocfs2_insert_type insert = {0, };\n\tstruct ocfs2_extent_rec rec;\n\n\ttrace_ocfs2_insert_extent_start(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\tcpos, new_clusters);\n\n\tmemset(&rec, 0, sizeof(rec));\n\trec.e_cpos = cpu_to_le32(cpos);\n\trec.e_blkno = cpu_to_le64(start_blk);\n\trec.e_leaf_clusters = cpu_to_le16(new_clusters);\n\trec.e_flags = flags;\n\tstatus = ocfs2_et_insert_check(et, &rec);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_figure_insert_type(et, &last_eb_bh, &rec,\n\t\t\t\t\t  &free_records, &insert);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_insert_extent(insert.ins_appending, insert.ins_contig,\n\t\t\t\t  insert.ins_contig_index, free_records,\n\t\t\t\t  insert.ins_tree_depth);\n\n\tif (insert.ins_contig == CONTIG_NONE && free_records == 0) {\n\t\tstatus = ocfs2_grow_tree(handle, et,\n\t\t\t\t\t &insert.ins_tree_depth, &last_eb_bh,\n\t\t\t\t\t meta_ac);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* Finally, we can add clusters. This might rotate the tree for us. */\n\tstatus = ocfs2_do_insert_extent(handle, et, &rec, &insert);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\telse\n\t\tocfs2_et_extent_map_insert(et, &rec);\n\nbail:\n\tbrelse(last_eb_bh);\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nint ocfs2_insert_extent(handle_t *handle,\n\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\tu32 cpos,\n\t\t\tu64 start_blk,\n\t\t\tu32 new_clusters,\n\t\t\tu8 flags,\n\t\t\tstruct ocfs2_alloc_context *meta_ac)\n{\n\tint status;\n\tint uninitialized_var(free_records);\n\tstruct buffer_head *last_eb_bh = NULL;\n\tstruct ocfs2_insert_type insert = {0, };\n\tstruct ocfs2_extent_rec rec;\n\n\ttrace_ocfs2_insert_extent_start(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\tcpos, new_clusters);\n\n\tmemset(&rec, 0, sizeof(rec));\n\trec.e_cpos = cpu_to_le32(cpos);\n\trec.e_blkno = cpu_to_le64(start_blk);\n\trec.e_leaf_clusters = cpu_to_le16(new_clusters);\n\trec.e_flags = flags;\n\tstatus = ocfs2_et_insert_check(et, &rec);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_figure_insert_type(et, &last_eb_bh, &rec,\n\t\t\t\t\t  &free_records, &insert);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_insert_extent(insert.ins_appending, insert.ins_contig,\n\t\t\t\t  insert.ins_contig_index, free_records,\n\t\t\t\t  insert.ins_tree_depth);\n\n\tif (insert.ins_contig == CONTIG_NONE && free_records == 0) {\n\t\tstatus = ocfs2_grow_tree(handle, et,\n\t\t\t\t\t &insert.ins_tree_depth, &last_eb_bh,\n\t\t\t\t\t meta_ac);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* Finally, we can add clusters. This might rotate the tree for us. */\n\tstatus = ocfs2_do_insert_extent(handle, et, &rec, &insert);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\telse\n\t\tocfs2_et_extent_map_insert(et, &rec);\n\nbail:\n\tbrelse(last_eb_bh);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_blocks",
          "args": [
            "inode->i_sb",
            "p_cluster"
          ],
          "line": 3945
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "711-718",
          "snippet": "static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 3939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 3938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "credits"
          ],
          "line": 3937
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_lock_refcount_allocators",
          "args": [
            "inode->i_sb",
            "p_cluster",
            "num_clusters",
            "et",
            "ref_ci",
            "ref_root_bh",
            "&meta_ac",
            "NULL",
            "&credits"
          ],
          "line": 3927
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_refcount_allocators",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "2857-2913",
          "snippet": "static int ocfs2_lock_refcount_allocators(struct super_block *sb,\n\t\t\t\t\tu32 p_cluster, u32 num_clusters,\n\t\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\t\tstruct ocfs2_caching_info *ref_ci,\n\t\t\t\t\tstruct buffer_head *ref_root_bh,\n\t\t\t\t\tstruct ocfs2_alloc_context **meta_ac,\n\t\t\t\t\tstruct ocfs2_alloc_context **data_ac,\n\t\t\t\t\tint *credits)\n{\n\tint ret = 0, meta_add = 0;\n\tint num_free_extents = ocfs2_num_free_extents(OCFS2_SB(sb), et);\n\n\tif (num_free_extents < 0) {\n\t\tret = num_free_extents;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (num_free_extents < num_clusters + 2)\n\t\tmeta_add =\n\t\t\tocfs2_extend_meta_needed(et->et_root_el);\n\n\t*credits += ocfs2_calc_extend_credits(sb, et->et_root_el);\n\n\tret = ocfs2_calc_refcount_meta_credits(sb, ref_ci, ref_root_bh,\n\t\t\t\t\t       p_cluster, num_clusters,\n\t\t\t\t\t       &meta_add, credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_lock_refcount_allocators(meta_add, *credits);\n\tret = ocfs2_reserve_new_metadata_blocks(OCFS2_SB(sb), meta_add,\n\t\t\t\t\t\tmeta_ac);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (data_ac) {\n\t\tret = ocfs2_reserve_clusters(OCFS2_SB(sb), num_clusters,\n\t\t\t\t\t     data_ac);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\nout:\n\tif (ret) {\n\t\tif (*meta_ac) {\n\t\t\tocfs2_free_alloc_context(*meta_ac);\n\t\t\t*meta_ac = NULL;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_lock_refcount_allocators(struct super_block *sb,\n\t\t\t\t\tu32 p_cluster, u32 num_clusters,\n\t\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\t\tstruct ocfs2_caching_info *ref_ci,\n\t\t\t\t\tstruct buffer_head *ref_root_bh,\n\t\t\t\t\tstruct ocfs2_alloc_context **meta_ac,\n\t\t\t\t\tstruct ocfs2_alloc_context **data_ac,\n\t\t\t\t\tint *credits)\n{\n\tint ret = 0, meta_add = 0;\n\tint num_free_extents = ocfs2_num_free_extents(OCFS2_SB(sb), et);\n\n\tif (num_free_extents < 0) {\n\t\tret = num_free_extents;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (num_free_extents < num_clusters + 2)\n\t\tmeta_add =\n\t\t\tocfs2_extend_meta_needed(et->et_root_el);\n\n\t*credits += ocfs2_calc_extend_credits(sb, et->et_root_el);\n\n\tret = ocfs2_calc_refcount_meta_credits(sb, ref_ci, ref_root_bh,\n\t\t\t\t\t       p_cluster, num_clusters,\n\t\t\t\t\t       &meta_add, credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_lock_refcount_allocators(meta_add, *credits);\n\tret = ocfs2_reserve_new_metadata_blocks(OCFS2_SB(sb), meta_add,\n\t\t\t\t\t\tmeta_ac);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (data_ac) {\n\t\tret = ocfs2_reserve_clusters(OCFS2_SB(sb), num_clusters,\n\t\t\t\t\t     data_ac);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\nout:\n\tif (ret) {\n\t\tif (*meta_ac) {\n\t\t\tocfs2_free_alloc_context(*meta_ac);\n\t\t\t*meta_ac = NULL;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 3924
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_add_refcounted_extent(struct inode *inode,\n\t\t\t\t   struct ocfs2_extent_tree *et,\n\t\t\t\t   struct ocfs2_caching_info *ref_ci,\n\t\t\t\t   struct buffer_head *ref_root_bh,\n\t\t\t\t   u32 cpos, u32 p_cluster, u32 num_clusters,\n\t\t\t\t   unsigned int ext_flags,\n\t\t\t\t   struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret;\n\thandle_t *handle;\n\tint credits = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\n\tret = ocfs2_lock_refcount_allocators(inode->i_sb,\n\t\t\t\t\t     p_cluster, num_clusters,\n\t\t\t\t\t     et, ref_ci,\n\t\t\t\t\t     ref_root_bh, &meta_ac,\n\t\t\t\t\t     NULL, &credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_insert_extent(handle, et, cpos,\n\t\t\tocfs2_clusters_to_blocks(inode->i_sb, p_cluster),\n\t\t\tnum_clusters, ext_flags, meta_ac);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tret = ocfs2_increase_refcount(handle, ref_ci, ref_root_bh,\n\t\t\t\t      p_cluster, num_clusters,\n\t\t\t\t      meta_ac, dealloc);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\nout:\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_attach_refcount_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "3811-3911",
    "snippet": "static int ocfs2_attach_refcount_tree(struct inode *inode,\n\t\t\t\t      struct buffer_head *di_bh)\n{\n\tint ret, data_changed = 0;\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_refcount_tree *ref_tree;\n\tunsigned int ext_flags;\n\tloff_t size;\n\tu32 cpos, num_clusters, clusters, p_cluster;\n\tstruct ocfs2_cached_dealloc_ctxt dealloc;\n\tstruct ocfs2_extent_tree di_et;\n\n\tocfs2_init_dealloc_ctxt(&dealloc);\n\n\tif (!(oi->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL)) {\n\t\tret = ocfs2_create_refcount_tree(inode, di_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tBUG_ON(!di->i_refcount_loc);\n\tret = ocfs2_lock_refcount_tree(osb,\n\t\t\t\t       le64_to_cpu(di->i_refcount_loc), 1,\n\t\t\t\t       &ref_tree, &ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (oi->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\tgoto attach_xattr;\n\n\tocfs2_init_dinode_extent_tree(&di_et, INODE_CACHE(inode), di_bh);\n\n\tsize = i_size_read(inode);\n\tclusters = ocfs2_clusters_for_bytes(inode->i_sb, size);\n\n\tcpos = 0;\n\twhile (cpos < clusters) {\n\t\tret = ocfs2_get_clusters(inode, cpos, &p_cluster,\n\t\t\t\t\t &num_clusters, &ext_flags);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto unlock;\n\t\t}\n\t\tif (p_cluster && !(ext_flags & OCFS2_EXT_REFCOUNTED)) {\n\t\t\tret = ocfs2_add_refcount_flag(inode, &di_et,\n\t\t\t\t\t\t      &ref_tree->rf_ci,\n\t\t\t\t\t\t      ref_root_bh, cpos,\n\t\t\t\t\t\t      p_cluster, num_clusters,\n\t\t\t\t\t\t      &dealloc, NULL);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto unlock;\n\t\t\t}\n\n\t\t\tdata_changed = 1;\n\t\t}\n\t\tcpos += num_clusters;\n\t}\n\nattach_xattr:\n\tif (oi->ip_dyn_features & OCFS2_HAS_XATTR_FL) {\n\t\tret = ocfs2_xattr_attach_refcount_tree(inode, di_bh,\n\t\t\t\t\t\t       &ref_tree->rf_ci,\n\t\t\t\t\t\t       ref_root_bh,\n\t\t\t\t\t\t       &dealloc);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\tif (data_changed) {\n\t\tret = ocfs2_change_ctime(inode, di_bh);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\nunlock:\n\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\tbrelse(ref_root_bh);\n\n\tif (!ret && ocfs2_dealloc_has_cluster(&dealloc)) {\n\t\tocfs2_schedule_truncate_log_flush(osb, 1);\n\t\tocfs2_run_deallocs(osb, &dealloc);\n\t}\nout:\n\t/*\n\t * Empty the extent map so that we may get the right extent\n\t * record from the disk.\n\t */\n\tocfs2_extent_map_trunc(inode, 0);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_extent_map_trunc",
          "args": [
            "inode",
            "0"
          ],
          "line": 3908
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extent_map_trunc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
          "lines": "114-144",
          "snippet": "void ocfs2_extent_map_trunc(struct inode *inode, unsigned int cpos)\n{\n\tstruct ocfs2_extent_map_item *emi, *n;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_extent_map *em = &oi->ip_extent_map;\n\tLIST_HEAD(tmp_list);\n\tunsigned int range;\n\n\tspin_lock(&oi->ip_lock);\n\tlist_for_each_entry_safe(emi, n, &em->em_list, ei_list) {\n\t\tif (emi->ei_cpos >= cpos) {\n\t\t\t/* Full truncate of this record. */\n\t\t\tlist_move(&emi->ei_list, &tmp_list);\n\t\t\tBUG_ON(em->em_num_items == 0);\n\t\t\tem->em_num_items--;\n\t\t\tcontinue;\n\t\t}\n\n\t\trange = emi->ei_cpos + emi->ei_clusters;\n\t\tif (range > cpos) {\n\t\t\t/* Partial truncate */\n\t\t\temi->ei_clusters = cpos - emi->ei_cpos;\n\t\t}\n\t}\n\tspin_unlock(&oi->ip_lock);\n\n\tlist_for_each_entry_safe(emi, n, &tmp_list, ei_list) {\n\t\tlist_del(&emi->ei_list);\n\t\tkfree(emi);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid ocfs2_extent_map_trunc(struct inode *inode, unsigned int cpos)\n{\n\tstruct ocfs2_extent_map_item *emi, *n;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_extent_map *em = &oi->ip_extent_map;\n\tLIST_HEAD(tmp_list);\n\tunsigned int range;\n\n\tspin_lock(&oi->ip_lock);\n\tlist_for_each_entry_safe(emi, n, &em->em_list, ei_list) {\n\t\tif (emi->ei_cpos >= cpos) {\n\t\t\t/* Full truncate of this record. */\n\t\t\tlist_move(&emi->ei_list, &tmp_list);\n\t\t\tBUG_ON(em->em_num_items == 0);\n\t\t\tem->em_num_items--;\n\t\t\tcontinue;\n\t\t}\n\n\t\trange = emi->ei_cpos + emi->ei_clusters;\n\t\tif (range > cpos) {\n\t\t\t/* Partial truncate */\n\t\t\temi->ei_clusters = cpos - emi->ei_cpos;\n\t\t}\n\t}\n\tspin_unlock(&oi->ip_lock);\n\n\tlist_for_each_entry_safe(emi, n, &tmp_list, ei_list) {\n\t\tlist_del(&emi->ei_list);\n\t\tkfree(emi);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_run_deallocs",
          "args": [
            "osb",
            "&dealloc"
          ],
          "line": 3901
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_run_deallocs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "6472-6513",
          "snippet": "int ocfs2_run_deallocs(struct ocfs2_super *osb,\n\t\t       struct ocfs2_cached_dealloc_ctxt *ctxt)\n{\n\tint ret = 0, ret2;\n\tstruct ocfs2_per_slot_free_list *fl;\n\n\tif (!ctxt)\n\t\treturn 0;\n\n\twhile (ctxt->c_first_suballocator) {\n\t\tfl = ctxt->c_first_suballocator;\n\n\t\tif (fl->f_first) {\n\t\t\ttrace_ocfs2_run_deallocs(fl->f_inode_type,\n\t\t\t\t\t\t fl->f_slot);\n\t\t\tret2 = ocfs2_free_cached_blocks(osb,\n\t\t\t\t\t\t\tfl->f_inode_type,\n\t\t\t\t\t\t\tfl->f_slot,\n\t\t\t\t\t\t\tfl->f_first);\n\t\t\tif (ret2)\n\t\t\t\tmlog_errno(ret2);\n\t\t\tif (!ret)\n\t\t\t\tret = ret2;\n\t\t}\n\n\t\tctxt->c_first_suballocator = fl->f_next_suballocator;\n\t\tkfree(fl);\n\t}\n\n\tif (ctxt->c_global_allocator) {\n\t\tret2 = ocfs2_free_cached_clusters(osb,\n\t\t\t\t\t\t  ctxt->c_global_allocator);\n\t\tif (ret2)\n\t\t\tmlog_errno(ret2);\n\t\tif (!ret)\n\t\t\tret = ret2;\n\n\t\tctxt->c_global_allocator = NULL;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_run_deallocs(struct ocfs2_super *osb,\n\t\t       struct ocfs2_cached_dealloc_ctxt *ctxt)\n{\n\tint ret = 0, ret2;\n\tstruct ocfs2_per_slot_free_list *fl;\n\n\tif (!ctxt)\n\t\treturn 0;\n\n\twhile (ctxt->c_first_suballocator) {\n\t\tfl = ctxt->c_first_suballocator;\n\n\t\tif (fl->f_first) {\n\t\t\ttrace_ocfs2_run_deallocs(fl->f_inode_type,\n\t\t\t\t\t\t fl->f_slot);\n\t\t\tret2 = ocfs2_free_cached_blocks(osb,\n\t\t\t\t\t\t\tfl->f_inode_type,\n\t\t\t\t\t\t\tfl->f_slot,\n\t\t\t\t\t\t\tfl->f_first);\n\t\t\tif (ret2)\n\t\t\t\tmlog_errno(ret2);\n\t\t\tif (!ret)\n\t\t\t\tret = ret2;\n\t\t}\n\n\t\tctxt->c_first_suballocator = fl->f_next_suballocator;\n\t\tkfree(fl);\n\t}\n\n\tif (ctxt->c_global_allocator) {\n\t\tret2 = ocfs2_free_cached_clusters(osb,\n\t\t\t\t\t\t  ctxt->c_global_allocator);\n\t\tif (ret2)\n\t\t\tmlog_errno(ret2);\n\t\tif (!ret)\n\t\t\tret = ret2;\n\n\t\tctxt->c_global_allocator = NULL;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_schedule_truncate_log_flush",
          "args": [
            "osb",
            "1"
          ],
          "line": 3900
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_schedule_truncate_log_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "6057-6070",
          "snippet": "void ocfs2_schedule_truncate_log_flush(struct ocfs2_super *osb,\n\t\t\t\t       int cancel)\n{\n\tif (osb->osb_tl_inode &&\n\t\t\tatomic_read(&osb->osb_tl_disable) == 0) {\n\t\t/* We want to push off log flushes while truncates are\n\t\t * still running. */\n\t\tif (cancel)\n\t\t\tcancel_delayed_work(&osb->osb_truncate_log_wq);\n\n\t\tqueue_delayed_work(ocfs2_wq, &osb->osb_truncate_log_wq,\n\t\t\t\t   OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL (2 * HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL (2 * HZ)\n\nvoid ocfs2_schedule_truncate_log_flush(struct ocfs2_super *osb,\n\t\t\t\t       int cancel)\n{\n\tif (osb->osb_tl_inode &&\n\t\t\tatomic_read(&osb->osb_tl_disable) == 0) {\n\t\t/* We want to push off log flushes while truncates are\n\t\t * still running. */\n\t\tif (cancel)\n\t\t\tcancel_delayed_work(&osb->osb_truncate_log_wq);\n\n\t\tqueue_delayed_work(ocfs2_wq, &osb->osb_truncate_log_wq,\n\t\t\t\t   OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_dealloc_has_cluster",
          "args": [
            "&dealloc"
          ],
          "line": 3899
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dealloc_has_cluster",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
          "lines": "215-218",
          "snippet": "static inline int ocfs2_dealloc_has_cluster(struct ocfs2_cached_dealloc_ctxt *c)\n{\n\treturn c->c_global_allocator != NULL;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_dealloc_has_cluster(struct ocfs2_cached_dealloc_ctxt *c)\n{\n\treturn c->c_global_allocator != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "ref_root_bh"
          ],
          "line": 3897
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_unlock_refcount_tree",
          "args": [
            "osb",
            "ref_tree",
            "1"
          ],
          "line": 3896
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_refcount_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "526-536",
          "snippet": "void ocfs2_unlock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_refcount_tree *tree, int rw)\n{\n\tif (rw)\n\t\tup_write(&tree->rf_sem);\n\telse\n\t\tup_read(&tree->rf_sem);\n\n\tocfs2_refcount_unlock(tree, rw);\n\tocfs2_refcount_tree_put(tree);\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nvoid ocfs2_unlock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_refcount_tree *tree, int rw)\n{\n\tif (rw)\n\t\tup_write(&tree->rf_sem);\n\telse\n\t\tup_read(&tree->rf_sem);\n\n\tocfs2_refcount_unlock(tree, rw);\n\tocfs2_refcount_tree_put(tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_change_ctime",
          "args": [
            "inode",
            "di_bh"
          ],
          "line": 3890
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_change_ctime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "3777-3809",
          "snippet": "static int ocfs2_change_ctime(struct inode *inode,\n\t\t\t      struct buffer_head *di_bh)\n{\n\tint ret;\n\thandle_t *handle;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\n\thandle = ocfs2_start_trans(OCFS2_SB(inode->i_sb),\n\t\t\t\t   OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tinode->i_ctime = CURRENT_TIME;\n\tdi->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tdi->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\n\tocfs2_journal_dirty(handle, di_bh);\n\nout_commit:\n\tocfs2_commit_trans(OCFS2_SB(inode->i_sb), handle);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_change_ctime(struct inode *inode,\n\t\t\t      struct buffer_head *di_bh)\n{\n\tint ret;\n\thandle_t *handle;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\n\thandle = ocfs2_start_trans(OCFS2_SB(inode->i_sb),\n\t\t\t\t   OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tinode->i_ctime = CURRENT_TIME;\n\tdi->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tdi->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\n\tocfs2_journal_dirty(handle, di_bh);\n\nout_commit:\n\tocfs2_commit_trans(OCFS2_SB(inode->i_sb), handle);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_attach_refcount_tree",
          "args": [
            "inode",
            "di_bh",
            "&ref_tree->rf_ci",
            "ref_root_bh",
            "&dealloc"
          ],
          "line": 3879
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_attach_refcount_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "6124-6164",
          "snippet": "int ocfs2_xattr_attach_refcount_tree(struct inode *inode,\n\t\t\t\t     struct buffer_head *fe_bh,\n\t\t\t\t     struct ocfs2_caching_info *ref_ci,\n\t\t\t\t     struct buffer_head *ref_root_bh,\n\t\t\t\t     struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret = 0;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)fe_bh->b_data;\n\tstruct buffer_head *blk_bh = NULL;\n\n\tif (oi->ip_dyn_features & OCFS2_INLINE_XATTR_FL) {\n\t\tret = ocfs2_xattr_inline_attach_refcount(inode, fe_bh,\n\t\t\t\t\t\t\t ref_ci, ref_root_bh,\n\t\t\t\t\t\t\t dealloc);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!di->i_xattr_loc)\n\t\tgoto out;\n\n\tret = ocfs2_read_xattr_block(inode, le64_to_cpu(di->i_xattr_loc),\n\t\t\t\t     &blk_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_xattr_block_attach_refcount(inode, blk_bh, ref_ci,\n\t\t\t\t\t\tref_root_bh, dealloc);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\tbrelse(blk_bh);\nout:\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nint ocfs2_xattr_attach_refcount_tree(struct inode *inode,\n\t\t\t\t     struct buffer_head *fe_bh,\n\t\t\t\t     struct ocfs2_caching_info *ref_ci,\n\t\t\t\t     struct buffer_head *ref_root_bh,\n\t\t\t\t     struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret = 0;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)fe_bh->b_data;\n\tstruct buffer_head *blk_bh = NULL;\n\n\tif (oi->ip_dyn_features & OCFS2_INLINE_XATTR_FL) {\n\t\tret = ocfs2_xattr_inline_attach_refcount(inode, fe_bh,\n\t\t\t\t\t\t\t ref_ci, ref_root_bh,\n\t\t\t\t\t\t\t dealloc);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (!di->i_xattr_loc)\n\t\tgoto out;\n\n\tret = ocfs2_read_xattr_block(inode, le64_to_cpu(di->i_xattr_loc),\n\t\t\t\t     &blk_bh);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_xattr_block_attach_refcount(inode, blk_bh, ref_ci,\n\t\t\t\t\t\tref_root_bh, dealloc);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\tbrelse(blk_bh);\nout:\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_add_refcount_flag",
          "args": [
            "inode",
            "&di_et",
            "&ref_tree->rf_ci",
            "ref_root_bh",
            "cpos",
            "p_cluster",
            "num_clusters",
            "&dealloc",
            "NULL"
          ],
          "line": 3862
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_add_refcount_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "3703-3775",
          "snippet": "int ocfs2_add_refcount_flag(struct inode *inode,\n\t\t\t    struct ocfs2_extent_tree *data_et,\n\t\t\t    struct ocfs2_caching_info *ref_ci,\n\t\t\t    struct buffer_head *ref_root_bh,\n\t\t\t    u32 cpos, u32 p_cluster, u32 num_clusters,\n\t\t\t    struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t    struct ocfs2_post_refcount *post)\n{\n\tint ret;\n\thandle_t *handle;\n\tint credits = 1, ref_blocks = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\n\tret = ocfs2_calc_refcount_meta_credits(inode->i_sb,\n\t\t\t\t\t       ref_ci, ref_root_bh,\n\t\t\t\t\t       p_cluster, num_clusters,\n\t\t\t\t\t       &ref_blocks, &credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_add_refcount_flag(ref_blocks, credits);\n\n\tif (ref_blocks) {\n\t\tret = ocfs2_reserve_new_metadata_blocks(OCFS2_SB(inode->i_sb),\n\t\t\t\t\t\t\tref_blocks, &meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (post)\n\t\tcredits += post->credits;\n\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_mark_extent_refcounted(inode, data_et, handle,\n\t\t\t\t\t   cpos, num_clusters, p_cluster,\n\t\t\t\t\t   meta_ac, dealloc);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tret = __ocfs2_increase_refcount(handle, ref_ci, ref_root_bh,\n\t\t\t\t\tp_cluster, num_clusters, 0,\n\t\t\t\t\tmeta_ac, dealloc);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tif (post && post->func) {\n\t\tret = post->func(inode, handle, post->para);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\nout:\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nint ocfs2_add_refcount_flag(struct inode *inode,\n\t\t\t    struct ocfs2_extent_tree *data_et,\n\t\t\t    struct ocfs2_caching_info *ref_ci,\n\t\t\t    struct buffer_head *ref_root_bh,\n\t\t\t    u32 cpos, u32 p_cluster, u32 num_clusters,\n\t\t\t    struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t    struct ocfs2_post_refcount *post)\n{\n\tint ret;\n\thandle_t *handle;\n\tint credits = 1, ref_blocks = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\n\tret = ocfs2_calc_refcount_meta_credits(inode->i_sb,\n\t\t\t\t\t       ref_ci, ref_root_bh,\n\t\t\t\t\t       p_cluster, num_clusters,\n\t\t\t\t\t       &ref_blocks, &credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_add_refcount_flag(ref_blocks, credits);\n\n\tif (ref_blocks) {\n\t\tret = ocfs2_reserve_new_metadata_blocks(OCFS2_SB(inode->i_sb),\n\t\t\t\t\t\t\tref_blocks, &meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (post)\n\t\tcredits += post->credits;\n\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_mark_extent_refcounted(inode, data_et, handle,\n\t\t\t\t\t   cpos, num_clusters, p_cluster,\n\t\t\t\t\t   meta_ac, dealloc);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tret = __ocfs2_increase_refcount(handle, ref_ci, ref_root_bh,\n\t\t\t\t\tp_cluster, num_clusters, 0,\n\t\t\t\t\tmeta_ac, dealloc);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tif (post && post->func) {\n\t\tret = post->func(inode, handle, post->para);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\nout:\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_clusters",
          "args": [
            "inode",
            "cpos",
            "&p_cluster",
            "&num_clusters",
            "&ext_flags"
          ],
          "line": 3855
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_get_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
          "lines": "608-665",
          "snippet": "int ocfs2_get_clusters(struct inode *inode, u32 v_cluster,\n\t\t       u32 *p_cluster, u32 *num_clusters,\n\t\t       unsigned int *extent_flags)\n{\n\tint ret;\n\tunsigned int uninitialized_var(hole_len), flags = 0;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_extent_rec rec;\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tret = -ERANGE;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_extent_map_lookup(inode, v_cluster, p_cluster,\n\t\t\t\t      num_clusters, extent_flags);\n\tif (ret == 0)\n\t\tgoto out;\n\n\tret = ocfs2_read_inode_block(inode, &di_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_get_clusters_nocache(inode, di_bh, v_cluster, &hole_len,\n\t\t\t\t\t &rec, NULL);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (rec.e_blkno == 0ULL) {\n\t\t/*\n\t\t * A hole was found. Return some canned values that\n\t\t * callers can key on. If asked for, num_clusters will\n\t\t * be populated with the size of the hole.\n\t\t */\n\t\t*p_cluster = 0;\n\t\tif (num_clusters) {\n\t\t\t*num_clusters = hole_len;\n\t\t}\n\t} else {\n\t\tocfs2_relative_extent_offsets(inode->i_sb, v_cluster, &rec,\n\t\t\t\t\t      p_cluster, num_clusters);\n\t\tflags = rec.e_flags;\n\n\t\tocfs2_extent_map_insert_rec(inode, &rec);\n\t}\n\n\tif (extent_flags)\n\t\t*extent_flags = flags;\n\nout:\n\tbrelse(di_bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nint ocfs2_get_clusters(struct inode *inode, u32 v_cluster,\n\t\t       u32 *p_cluster, u32 *num_clusters,\n\t\t       unsigned int *extent_flags)\n{\n\tint ret;\n\tunsigned int uninitialized_var(hole_len), flags = 0;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_extent_rec rec;\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tret = -ERANGE;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_extent_map_lookup(inode, v_cluster, p_cluster,\n\t\t\t\t      num_clusters, extent_flags);\n\tif (ret == 0)\n\t\tgoto out;\n\n\tret = ocfs2_read_inode_block(inode, &di_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_get_clusters_nocache(inode, di_bh, v_cluster, &hole_len,\n\t\t\t\t\t &rec, NULL);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (rec.e_blkno == 0ULL) {\n\t\t/*\n\t\t * A hole was found. Return some canned values that\n\t\t * callers can key on. If asked for, num_clusters will\n\t\t * be populated with the size of the hole.\n\t\t */\n\t\t*p_cluster = 0;\n\t\tif (num_clusters) {\n\t\t\t*num_clusters = hole_len;\n\t\t}\n\t} else {\n\t\tocfs2_relative_extent_offsets(inode->i_sb, v_cluster, &rec,\n\t\t\t\t\t      p_cluster, num_clusters);\n\t\tflags = rec.e_flags;\n\n\t\tocfs2_extent_map_insert_rec(inode, &rec);\n\t}\n\n\tif (extent_flags)\n\t\t*extent_flags = flags;\n\nout:\n\tbrelse(di_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_for_bytes",
          "args": [
            "inode->i_sb",
            "size"
          ],
          "line": 3851
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_for_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "729-740",
          "snippet": "static inline unsigned int ocfs2_clusters_for_bytes(struct super_block *sb,\n\t\t\t\t\t\t    u64 bytes)\n{\n\tint cl_bits = OCFS2_SB(sb)->s_clustersize_bits;\n\tunsigned int clusters;\n\n\tbytes += OCFS2_SB(sb)->s_clustersize - 1;\n\t/* OCFS2 just cannot have enough clusters to overflow this */\n\tclusters = (unsigned int)(bytes >> cl_bits);\n\n\treturn clusters;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline unsigned int ocfs2_clusters_for_bytes(struct super_block *sb,\n\t\t\t\t\t\t    u64 bytes)\n{\n\tint cl_bits = OCFS2_SB(sb)->s_clustersize_bits;\n\tunsigned int clusters;\n\n\tbytes += OCFS2_SB(sb)->s_clustersize - 1;\n\t/* OCFS2 just cannot have enough clusters to overflow this */\n\tclusters = (unsigned int)(bytes >> cl_bits);\n\n\treturn clusters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 3850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_init_dinode_extent_tree",
          "args": [
            "&di_et",
            "INODE_CACHE(inode)",
            "di_bh"
          ],
          "line": 3848
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_dinode_extent_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "458-464",
          "snippet": "void ocfs2_init_dinode_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t   struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_di,\n\t\t\t\t NULL, &ocfs2_dinode_et_ops);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static struct ocfs2_extent_tree_operations ocfs2_dinode_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_dinode_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_dinode_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_dinode_update_clusters,\n\t.eo_extent_map_insert\t= ocfs2_dinode_extent_map_insert,\n\t.eo_extent_map_truncate\t= ocfs2_dinode_extent_map_truncate,\n\t.eo_insert_check\t= ocfs2_dinode_insert_check,\n\t.eo_sanity_check\t= ocfs2_dinode_sanity_check,\n\t.eo_fill_root_el\t= ocfs2_dinode_fill_root_el,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic struct ocfs2_extent_tree_operations ocfs2_dinode_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_dinode_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_dinode_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_dinode_update_clusters,\n\t.eo_extent_map_insert\t= ocfs2_dinode_extent_map_insert,\n\t.eo_extent_map_truncate\t= ocfs2_dinode_extent_map_truncate,\n\t.eo_insert_check\t= ocfs2_dinode_insert_check,\n\t.eo_sanity_check\t= ocfs2_dinode_sanity_check,\n\t.eo_fill_root_el\t= ocfs2_dinode_fill_root_el,\n};\n\nvoid ocfs2_init_dinode_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t   struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_di,\n\t\t\t\t NULL, &ocfs2_dinode_et_ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 3848
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_lock_refcount_tree",
          "args": [
            "osb",
            "le64_to_cpu(di->i_refcount_loc)",
            "1",
            "&ref_tree",
            "&ref_root_bh"
          ],
          "line": 3837
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_refcount_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "452-524",
          "snippet": "int ocfs2_lock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t     u64 ref_blkno, int rw,\n\t\t\t     struct ocfs2_refcount_tree **ret_tree,\n\t\t\t     struct buffer_head **ref_bh)\n{\n\tint ret, delete_tree = 0;\n\tstruct ocfs2_refcount_tree *tree = NULL;\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_block *rb;\n\nagain:\n\tret = ocfs2_get_refcount_tree(osb, ref_blkno, &tree);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tocfs2_refcount_tree_get(tree);\n\n\tret = __ocfs2_lock_refcount_tree(osb, tree, rw);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_refcount_tree_put(tree);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_refcount_block(&tree->rf_ci, tree->rf_blkno,\n\t\t\t\t\t&ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_unlock_refcount_tree(osb, tree, rw);\n\t\tocfs2_refcount_tree_put(tree);\n\t\tgoto out;\n\t}\n\n\trb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\t/*\n\t * If the refcount block has been freed and re-created, we may need\n\t * to recreate the refcount tree also.\n\t *\n\t * Here we just remove the tree from the rb-tree, and the last\n\t * kref holder will unlock and delete this refcount_tree.\n\t * Then we goto \"again\" and ocfs2_get_refcount_tree will create\n\t * the new refcount tree for us.\n\t */\n\tif (tree->rf_generation != le32_to_cpu(rb->rf_generation)) {\n\t\tif (!tree->rf_removed) {\n\t\t\tocfs2_erase_refcount_tree_from_list(osb, tree);\n\t\t\ttree->rf_removed = 1;\n\t\t\tdelete_tree = 1;\n\t\t}\n\n\t\tocfs2_unlock_refcount_tree(osb, tree, rw);\n\t\t/*\n\t\t * We get an extra reference when we create the refcount\n\t\t * tree, so another put will destroy it.\n\t\t */\n\t\tif (delete_tree)\n\t\t\tocfs2_refcount_tree_put(tree);\n\t\tbrelse(ref_root_bh);\n\t\tref_root_bh = NULL;\n\t\tgoto again;\n\t}\n\n\t*ret_tree = tree;\n\tif (ref_bh) {\n\t\t*ref_bh = ref_root_bh;\n\t\tref_root_bh = NULL;\n\t}\nout:\n\tbrelse(ref_root_bh);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nint ocfs2_lock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t     u64 ref_blkno, int rw,\n\t\t\t     struct ocfs2_refcount_tree **ret_tree,\n\t\t\t     struct buffer_head **ref_bh)\n{\n\tint ret, delete_tree = 0;\n\tstruct ocfs2_refcount_tree *tree = NULL;\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_block *rb;\n\nagain:\n\tret = ocfs2_get_refcount_tree(osb, ref_blkno, &tree);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tocfs2_refcount_tree_get(tree);\n\n\tret = __ocfs2_lock_refcount_tree(osb, tree, rw);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_refcount_tree_put(tree);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_refcount_block(&tree->rf_ci, tree->rf_blkno,\n\t\t\t\t\t&ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_unlock_refcount_tree(osb, tree, rw);\n\t\tocfs2_refcount_tree_put(tree);\n\t\tgoto out;\n\t}\n\n\trb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\t/*\n\t * If the refcount block has been freed and re-created, we may need\n\t * to recreate the refcount tree also.\n\t *\n\t * Here we just remove the tree from the rb-tree, and the last\n\t * kref holder will unlock and delete this refcount_tree.\n\t * Then we goto \"again\" and ocfs2_get_refcount_tree will create\n\t * the new refcount tree for us.\n\t */\n\tif (tree->rf_generation != le32_to_cpu(rb->rf_generation)) {\n\t\tif (!tree->rf_removed) {\n\t\t\tocfs2_erase_refcount_tree_from_list(osb, tree);\n\t\t\ttree->rf_removed = 1;\n\t\t\tdelete_tree = 1;\n\t\t}\n\n\t\tocfs2_unlock_refcount_tree(osb, tree, rw);\n\t\t/*\n\t\t * We get an extra reference when we create the refcount\n\t\t * tree, so another put will destroy it.\n\t\t */\n\t\tif (delete_tree)\n\t\t\tocfs2_refcount_tree_put(tree);\n\t\tbrelse(ref_root_bh);\n\t\tref_root_bh = NULL;\n\t\tgoto again;\n\t}\n\n\t*ret_tree = tree;\n\tif (ref_bh) {\n\t\t*ref_bh = ref_root_bh;\n\t\tref_root_bh = NULL;\n\t}\nout:\n\tbrelse(ref_root_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "di->i_refcount_loc"
          ],
          "line": 3838
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!di->i_refcount_loc"
          ],
          "line": 3836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_create_refcount_tree",
          "args": [
            "inode",
            "di_bh"
          ],
          "line": 3829
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_create_refcount_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "559-698",
          "snippet": "static int ocfs2_create_refcount_tree(struct inode *inode,\n\t\t\t\t      struct buffer_head *di_bh)\n{\n\tint ret;\n\thandle_t *handle = NULL;\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct buffer_head *new_bh = NULL;\n\tstruct ocfs2_refcount_block *rb;\n\tstruct ocfs2_refcount_tree *new_tree = NULL, *tree = NULL;\n\tu16 suballoc_bit_start;\n\tu32 num_got;\n\tu64 suballoc_loc, first_blkno;\n\n\tBUG_ON(oi->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL);\n\n\ttrace_ocfs2_create_refcount_tree(\n\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tret = ocfs2_reserve_new_metadata_blocks(osb, 1, &meta_ac);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_REFCOUNT_TREE_CREATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tret = ocfs2_claim_metadata(handle, meta_ac, 1, &suballoc_loc,\n\t\t\t\t   &suballoc_bit_start, &num_got,\n\t\t\t\t   &first_blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tnew_tree = ocfs2_allocate_refcount_tree(osb, first_blkno);\n\tif (!new_tree) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tnew_bh = sb_getblk(inode->i_sb, first_blkno);\n\tif (!new_bh) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\tocfs2_set_new_buffer_uptodate(&new_tree->rf_ci, new_bh);\n\n\tret = ocfs2_journal_access_rb(handle, &new_tree->rf_ci, new_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\t/* Initialize ocfs2_refcount_block. */\n\trb = (struct ocfs2_refcount_block *)new_bh->b_data;\n\tmemset(rb, 0, inode->i_sb->s_blocksize);\n\tstrcpy((void *)rb, OCFS2_REFCOUNT_BLOCK_SIGNATURE);\n\trb->rf_suballoc_slot = cpu_to_le16(meta_ac->ac_alloc_slot);\n\trb->rf_suballoc_loc = cpu_to_le64(suballoc_loc);\n\trb->rf_suballoc_bit = cpu_to_le16(suballoc_bit_start);\n\trb->rf_fs_generation = cpu_to_le32(osb->fs_generation);\n\trb->rf_blkno = cpu_to_le64(first_blkno);\n\trb->rf_count = cpu_to_le32(1);\n\trb->rf_records.rl_count =\n\t\t\tcpu_to_le16(ocfs2_refcount_recs_per_rb(osb->sb));\n\tspin_lock(&osb->osb_lock);\n\trb->rf_generation = osb->s_next_generation++;\n\tspin_unlock(&osb->osb_lock);\n\n\tocfs2_journal_dirty(handle, new_bh);\n\n\tspin_lock(&oi->ip_lock);\n\toi->ip_dyn_features |= OCFS2_HAS_REFCOUNT_FL;\n\tdi->i_dyn_features = cpu_to_le16(oi->ip_dyn_features);\n\tdi->i_refcount_loc = cpu_to_le64(first_blkno);\n\tspin_unlock(&oi->ip_lock);\n\n\ttrace_ocfs2_create_refcount_tree_blkno((unsigned long long)first_blkno);\n\n\tocfs2_journal_dirty(handle, di_bh);\n\n\t/*\n\t * We have to init the tree lock here since it will use\n\t * the generation number to create it.\n\t */\n\tnew_tree->rf_generation = le32_to_cpu(rb->rf_generation);\n\tocfs2_init_refcount_tree_lock(osb, new_tree, first_blkno,\n\t\t\t\t      new_tree->rf_generation);\n\n\tspin_lock(&osb->osb_lock);\n\ttree = ocfs2_find_refcount_tree(osb, first_blkno);\n\n\t/*\n\t * We've just created a new refcount tree in this block.  If\n\t * we found a refcount tree on the ocfs2_super, it must be\n\t * one we just deleted.  We free the old tree before\n\t * inserting the new tree.\n\t */\n\tBUG_ON(tree && tree->rf_generation == new_tree->rf_generation);\n\tif (tree)\n\t\tocfs2_erase_refcount_tree_from_list_no_lock(osb, tree);\n\tocfs2_insert_refcount_tree(osb, new_tree);\n\tspin_unlock(&osb->osb_lock);\n\tnew_tree = NULL;\n\tif (tree)\n\t\tocfs2_refcount_tree_put(tree);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\n\nout:\n\tif (new_tree) {\n\t\tocfs2_metadata_cache_exit(&new_tree->rf_ci);\n\t\tkfree(new_tree);\n\t}\n\n\tbrelse(new_bh);\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_create_refcount_tree(struct inode *inode,\n\t\t\t\t      struct buffer_head *di_bh)\n{\n\tint ret;\n\thandle_t *handle = NULL;\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct buffer_head *new_bh = NULL;\n\tstruct ocfs2_refcount_block *rb;\n\tstruct ocfs2_refcount_tree *new_tree = NULL, *tree = NULL;\n\tu16 suballoc_bit_start;\n\tu32 num_got;\n\tu64 suballoc_loc, first_blkno;\n\n\tBUG_ON(oi->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL);\n\n\ttrace_ocfs2_create_refcount_tree(\n\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tret = ocfs2_reserve_new_metadata_blocks(osb, 1, &meta_ac);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_REFCOUNT_TREE_CREATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tret = ocfs2_claim_metadata(handle, meta_ac, 1, &suballoc_loc,\n\t\t\t\t   &suballoc_bit_start, &num_got,\n\t\t\t\t   &first_blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tnew_tree = ocfs2_allocate_refcount_tree(osb, first_blkno);\n\tif (!new_tree) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tnew_bh = sb_getblk(inode->i_sb, first_blkno);\n\tif (!new_bh) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\tocfs2_set_new_buffer_uptodate(&new_tree->rf_ci, new_bh);\n\n\tret = ocfs2_journal_access_rb(handle, &new_tree->rf_ci, new_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\t/* Initialize ocfs2_refcount_block. */\n\trb = (struct ocfs2_refcount_block *)new_bh->b_data;\n\tmemset(rb, 0, inode->i_sb->s_blocksize);\n\tstrcpy((void *)rb, OCFS2_REFCOUNT_BLOCK_SIGNATURE);\n\trb->rf_suballoc_slot = cpu_to_le16(meta_ac->ac_alloc_slot);\n\trb->rf_suballoc_loc = cpu_to_le64(suballoc_loc);\n\trb->rf_suballoc_bit = cpu_to_le16(suballoc_bit_start);\n\trb->rf_fs_generation = cpu_to_le32(osb->fs_generation);\n\trb->rf_blkno = cpu_to_le64(first_blkno);\n\trb->rf_count = cpu_to_le32(1);\n\trb->rf_records.rl_count =\n\t\t\tcpu_to_le16(ocfs2_refcount_recs_per_rb(osb->sb));\n\tspin_lock(&osb->osb_lock);\n\trb->rf_generation = osb->s_next_generation++;\n\tspin_unlock(&osb->osb_lock);\n\n\tocfs2_journal_dirty(handle, new_bh);\n\n\tspin_lock(&oi->ip_lock);\n\toi->ip_dyn_features |= OCFS2_HAS_REFCOUNT_FL;\n\tdi->i_dyn_features = cpu_to_le16(oi->ip_dyn_features);\n\tdi->i_refcount_loc = cpu_to_le64(first_blkno);\n\tspin_unlock(&oi->ip_lock);\n\n\ttrace_ocfs2_create_refcount_tree_blkno((unsigned long long)first_blkno);\n\n\tocfs2_journal_dirty(handle, di_bh);\n\n\t/*\n\t * We have to init the tree lock here since it will use\n\t * the generation number to create it.\n\t */\n\tnew_tree->rf_generation = le32_to_cpu(rb->rf_generation);\n\tocfs2_init_refcount_tree_lock(osb, new_tree, first_blkno,\n\t\t\t\t      new_tree->rf_generation);\n\n\tspin_lock(&osb->osb_lock);\n\ttree = ocfs2_find_refcount_tree(osb, first_blkno);\n\n\t/*\n\t * We've just created a new refcount tree in this block.  If\n\t * we found a refcount tree on the ocfs2_super, it must be\n\t * one we just deleted.  We free the old tree before\n\t * inserting the new tree.\n\t */\n\tBUG_ON(tree && tree->rf_generation == new_tree->rf_generation);\n\tif (tree)\n\t\tocfs2_erase_refcount_tree_from_list_no_lock(osb, tree);\n\tocfs2_insert_refcount_tree(osb, new_tree);\n\tspin_unlock(&osb->osb_lock);\n\tnew_tree = NULL;\n\tif (tree)\n\t\tocfs2_refcount_tree_put(tree);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\n\nout:\n\tif (new_tree) {\n\t\tocfs2_metadata_cache_exit(&new_tree->rf_ci);\n\t\tkfree(new_tree);\n\t}\n\n\tbrelse(new_bh);\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_init_dealloc_ctxt",
          "args": [
            "&dealloc"
          ],
          "line": 3826
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_dealloc_ctxt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
          "lines": "205-209",
          "snippet": "static inline void ocfs2_init_dealloc_ctxt(struct ocfs2_cached_dealloc_ctxt *c)\n{\n\tc->c_first_suballocator = NULL;\n\tc->c_global_allocator = NULL;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void ocfs2_init_dealloc_ctxt(struct ocfs2_cached_dealloc_ctxt *c)\n{\n\tc->c_first_suballocator = NULL;\n\tc->c_global_allocator = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 3818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 3816
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_attach_refcount_tree(struct inode *inode,\n\t\t\t\t      struct buffer_head *di_bh)\n{\n\tint ret, data_changed = 0;\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_refcount_tree *ref_tree;\n\tunsigned int ext_flags;\n\tloff_t size;\n\tu32 cpos, num_clusters, clusters, p_cluster;\n\tstruct ocfs2_cached_dealloc_ctxt dealloc;\n\tstruct ocfs2_extent_tree di_et;\n\n\tocfs2_init_dealloc_ctxt(&dealloc);\n\n\tif (!(oi->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL)) {\n\t\tret = ocfs2_create_refcount_tree(inode, di_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tBUG_ON(!di->i_refcount_loc);\n\tret = ocfs2_lock_refcount_tree(osb,\n\t\t\t\t       le64_to_cpu(di->i_refcount_loc), 1,\n\t\t\t\t       &ref_tree, &ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (oi->ip_dyn_features & OCFS2_INLINE_DATA_FL)\n\t\tgoto attach_xattr;\n\n\tocfs2_init_dinode_extent_tree(&di_et, INODE_CACHE(inode), di_bh);\n\n\tsize = i_size_read(inode);\n\tclusters = ocfs2_clusters_for_bytes(inode->i_sb, size);\n\n\tcpos = 0;\n\twhile (cpos < clusters) {\n\t\tret = ocfs2_get_clusters(inode, cpos, &p_cluster,\n\t\t\t\t\t &num_clusters, &ext_flags);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto unlock;\n\t\t}\n\t\tif (p_cluster && !(ext_flags & OCFS2_EXT_REFCOUNTED)) {\n\t\t\tret = ocfs2_add_refcount_flag(inode, &di_et,\n\t\t\t\t\t\t      &ref_tree->rf_ci,\n\t\t\t\t\t\t      ref_root_bh, cpos,\n\t\t\t\t\t\t      p_cluster, num_clusters,\n\t\t\t\t\t\t      &dealloc, NULL);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto unlock;\n\t\t\t}\n\n\t\t\tdata_changed = 1;\n\t\t}\n\t\tcpos += num_clusters;\n\t}\n\nattach_xattr:\n\tif (oi->ip_dyn_features & OCFS2_HAS_XATTR_FL) {\n\t\tret = ocfs2_xattr_attach_refcount_tree(inode, di_bh,\n\t\t\t\t\t\t       &ref_tree->rf_ci,\n\t\t\t\t\t\t       ref_root_bh,\n\t\t\t\t\t\t       &dealloc);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\tif (data_changed) {\n\t\tret = ocfs2_change_ctime(inode, di_bh);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\nunlock:\n\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\tbrelse(ref_root_bh);\n\n\tif (!ret && ocfs2_dealloc_has_cluster(&dealloc)) {\n\t\tocfs2_schedule_truncate_log_flush(osb, 1);\n\t\tocfs2_run_deallocs(osb, &dealloc);\n\t}\nout:\n\t/*\n\t * Empty the extent map so that we may get the right extent\n\t * record from the disk.\n\t */\n\tocfs2_extent_map_trunc(inode, 0);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_change_ctime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "3777-3809",
    "snippet": "static int ocfs2_change_ctime(struct inode *inode,\n\t\t\t      struct buffer_head *di_bh)\n{\n\tint ret;\n\thandle_t *handle;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\n\thandle = ocfs2_start_trans(OCFS2_SB(inode->i_sb),\n\t\t\t\t   OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tinode->i_ctime = CURRENT_TIME;\n\tdi->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tdi->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\n\tocfs2_journal_dirty(handle, di_bh);\n\nout_commit:\n\tocfs2_commit_trans(OCFS2_SB(inode->i_sb), handle);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "OCFS2_SB(inode->i_sb)",
            "handle"
          ],
          "line": 3806
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 3806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "di_bh"
          ],
          "line": 3803
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "inode->i_ctime.tv_nsec"
          ],
          "line": 3801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "inode->i_ctime.tv_sec"
          ],
          "line": 3800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_di",
          "args": [
            "handle",
            "INODE_CACHE(inode)",
            "di_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 3792
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_di",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "710-714",
          "snippet": "int ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};\n\nint ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 3792
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 3787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 3786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "OCFS2_SB(inode->i_sb)",
            "OCFS2_INODE_UPDATE_CREDITS"
          ],
          "line": 3784
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 3784
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_change_ctime(struct inode *inode,\n\t\t\t      struct buffer_head *di_bh)\n{\n\tint ret;\n\thandle_t *handle;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\n\thandle = ocfs2_start_trans(OCFS2_SB(inode->i_sb),\n\t\t\t\t   OCFS2_INODE_UPDATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tinode->i_ctime = CURRENT_TIME;\n\tdi->i_ctime = cpu_to_le64(inode->i_ctime.tv_sec);\n\tdi->i_ctime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);\n\n\tocfs2_journal_dirty(handle, di_bh);\n\nout_commit:\n\tocfs2_commit_trans(OCFS2_SB(inode->i_sb), handle);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_add_refcount_flag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "3703-3775",
    "snippet": "int ocfs2_add_refcount_flag(struct inode *inode,\n\t\t\t    struct ocfs2_extent_tree *data_et,\n\t\t\t    struct ocfs2_caching_info *ref_ci,\n\t\t\t    struct buffer_head *ref_root_bh,\n\t\t\t    u32 cpos, u32 p_cluster, u32 num_clusters,\n\t\t\t    struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t    struct ocfs2_post_refcount *post)\n{\n\tint ret;\n\thandle_t *handle;\n\tint credits = 1, ref_blocks = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\n\tret = ocfs2_calc_refcount_meta_credits(inode->i_sb,\n\t\t\t\t\t       ref_ci, ref_root_bh,\n\t\t\t\t\t       p_cluster, num_clusters,\n\t\t\t\t\t       &ref_blocks, &credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_add_refcount_flag(ref_blocks, credits);\n\n\tif (ref_blocks) {\n\t\tret = ocfs2_reserve_new_metadata_blocks(OCFS2_SB(inode->i_sb),\n\t\t\t\t\t\t\tref_blocks, &meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (post)\n\t\tcredits += post->credits;\n\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_mark_extent_refcounted(inode, data_et, handle,\n\t\t\t\t\t   cpos, num_clusters, p_cluster,\n\t\t\t\t\t   meta_ac, dealloc);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tret = __ocfs2_increase_refcount(handle, ref_ci, ref_root_bh,\n\t\t\t\t\tp_cluster, num_clusters, 0,\n\t\t\t\t\tmeta_ac, dealloc);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tif (post && post->func) {\n\t\tret = post->func(inode, handle, post->para);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\nout:\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_free_alloc_context",
          "args": [
            "meta_ac"
          ],
          "line": 3773
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_alloc_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "158-162",
          "snippet": "void ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nvoid ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "handle"
          ],
          "line": 3770
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "post->func",
          "args": [
            "inode",
            "handle",
            "post->para"
          ],
          "line": 3764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ocfs2_increase_refcount",
          "args": [
            "handle",
            "ref_ci",
            "ref_root_bh",
            "p_cluster",
            "num_clusters",
            "0",
            "meta_ac",
            "dealloc"
          ],
          "line": 3755
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_increase_refcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "1992-2084",
          "snippet": "static int __ocfs2_increase_refcount(handle_t *handle,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *ref_root_bh,\n\t\t\t\t     u64 cpos, u32 len, int merge,\n\t\t\t\t     struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t     struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret = 0, index;\n\tstruct buffer_head *ref_leaf_bh = NULL;\n\tstruct ocfs2_refcount_rec rec;\n\tunsigned int set_len = 0;\n\n\ttrace_ocfs2_increase_refcount_begin(\n\t     (unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t     (unsigned long long)cpos, len);\n\n\twhile (len) {\n\t\tret = ocfs2_get_refcount_rec(ci, ref_root_bh,\n\t\t\t\t\t     cpos, len, &rec, &index,\n\t\t\t\t\t     &ref_leaf_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tset_len = le32_to_cpu(rec.r_clusters);\n\n\t\t/*\n\t\t * Here we may meet with 3 situations:\n\t\t *\n\t\t * 1. If we find an already existing record, and the length\n\t\t *    is the same, cool, we just need to increase the r_refcount\n\t\t *    and it is OK.\n\t\t * 2. If we find a hole, just insert it with r_refcount = 1.\n\t\t * 3. If we are in the middle of one extent record, split\n\t\t *    it.\n\t\t */\n\t\tif (rec.r_refcount && le64_to_cpu(rec.r_cpos) == cpos &&\n\t\t    set_len <= len) {\n\t\t\ttrace_ocfs2_increase_refcount_change(\n\t\t\t\t(unsigned long long)cpos, set_len,\n\t\t\t\tle32_to_cpu(rec.r_refcount));\n\t\t\tret = ocfs2_change_refcount_rec(handle, ci,\n\t\t\t\t\t\t\tref_leaf_bh, index,\n\t\t\t\t\t\t\tmerge, 1);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else if (!rec.r_refcount) {\n\t\t\trec.r_refcount = cpu_to_le32(1);\n\n\t\t\ttrace_ocfs2_increase_refcount_insert(\n\t\t\t     (unsigned long long)le64_to_cpu(rec.r_cpos),\n\t\t\t     set_len);\n\t\t\tret = ocfs2_insert_refcount_rec(handle, ci, ref_root_bh,\n\t\t\t\t\t\t\tref_leaf_bh,\n\t\t\t\t\t\t\t&rec, index,\n\t\t\t\t\t\t\tmerge, meta_ac);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else  {\n\t\t\tset_len = min((u64)(cpos + len),\n\t\t\t\t      le64_to_cpu(rec.r_cpos) + set_len) - cpos;\n\t\t\trec.r_cpos = cpu_to_le64(cpos);\n\t\t\trec.r_clusters = cpu_to_le32(set_len);\n\t\t\tle32_add_cpu(&rec.r_refcount, 1);\n\n\t\t\ttrace_ocfs2_increase_refcount_split(\n\t\t\t     (unsigned long long)le64_to_cpu(rec.r_cpos),\n\t\t\t     set_len, le32_to_cpu(rec.r_refcount));\n\t\t\tret = ocfs2_split_refcount_rec(handle, ci,\n\t\t\t\t\t\t       ref_root_bh, ref_leaf_bh,\n\t\t\t\t\t\t       &rec, index, merge,\n\t\t\t\t\t\t       meta_ac, dealloc);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tcpos += set_len;\n\t\tlen -= set_len;\n\t\tbrelse(ref_leaf_bh);\n\t\tref_leaf_bh = NULL;\n\t}\n\nout:\n\tbrelse(ref_leaf_bh);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int __ocfs2_increase_refcount(handle_t *handle,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *ref_root_bh,\n\t\t\t\t     u64 cpos, u32 len, int merge,\n\t\t\t\t     struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t     struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret = 0, index;\n\tstruct buffer_head *ref_leaf_bh = NULL;\n\tstruct ocfs2_refcount_rec rec;\n\tunsigned int set_len = 0;\n\n\ttrace_ocfs2_increase_refcount_begin(\n\t     (unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t     (unsigned long long)cpos, len);\n\n\twhile (len) {\n\t\tret = ocfs2_get_refcount_rec(ci, ref_root_bh,\n\t\t\t\t\t     cpos, len, &rec, &index,\n\t\t\t\t\t     &ref_leaf_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tset_len = le32_to_cpu(rec.r_clusters);\n\n\t\t/*\n\t\t * Here we may meet with 3 situations:\n\t\t *\n\t\t * 1. If we find an already existing record, and the length\n\t\t *    is the same, cool, we just need to increase the r_refcount\n\t\t *    and it is OK.\n\t\t * 2. If we find a hole, just insert it with r_refcount = 1.\n\t\t * 3. If we are in the middle of one extent record, split\n\t\t *    it.\n\t\t */\n\t\tif (rec.r_refcount && le64_to_cpu(rec.r_cpos) == cpos &&\n\t\t    set_len <= len) {\n\t\t\ttrace_ocfs2_increase_refcount_change(\n\t\t\t\t(unsigned long long)cpos, set_len,\n\t\t\t\tle32_to_cpu(rec.r_refcount));\n\t\t\tret = ocfs2_change_refcount_rec(handle, ci,\n\t\t\t\t\t\t\tref_leaf_bh, index,\n\t\t\t\t\t\t\tmerge, 1);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else if (!rec.r_refcount) {\n\t\t\trec.r_refcount = cpu_to_le32(1);\n\n\t\t\ttrace_ocfs2_increase_refcount_insert(\n\t\t\t     (unsigned long long)le64_to_cpu(rec.r_cpos),\n\t\t\t     set_len);\n\t\t\tret = ocfs2_insert_refcount_rec(handle, ci, ref_root_bh,\n\t\t\t\t\t\t\tref_leaf_bh,\n\t\t\t\t\t\t\t&rec, index,\n\t\t\t\t\t\t\tmerge, meta_ac);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else  {\n\t\t\tset_len = min((u64)(cpos + len),\n\t\t\t\t      le64_to_cpu(rec.r_cpos) + set_len) - cpos;\n\t\t\trec.r_cpos = cpu_to_le64(cpos);\n\t\t\trec.r_clusters = cpu_to_le32(set_len);\n\t\t\tle32_add_cpu(&rec.r_refcount, 1);\n\n\t\t\ttrace_ocfs2_increase_refcount_split(\n\t\t\t     (unsigned long long)le64_to_cpu(rec.r_cpos),\n\t\t\t     set_len, le32_to_cpu(rec.r_refcount));\n\t\t\tret = ocfs2_split_refcount_rec(handle, ci,\n\t\t\t\t\t\t       ref_root_bh, ref_leaf_bh,\n\t\t\t\t\t\t       &rec, index, merge,\n\t\t\t\t\t\t       meta_ac, dealloc);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tcpos += set_len;\n\t\tlen -= set_len;\n\t\tbrelse(ref_leaf_bh);\n\t\tref_leaf_bh = NULL;\n\t}\n\nout:\n\tbrelse(ref_leaf_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_mark_extent_refcounted",
          "args": [
            "inode",
            "data_et",
            "handle",
            "cpos",
            "num_clusters",
            "p_cluster",
            "meta_ac",
            "dealloc"
          ],
          "line": 3747
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_mark_extent_refcounted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "2351-2379",
          "snippet": "static int ocfs2_mark_extent_refcounted(struct inode *inode,\n\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\thandle_t *handle, u32 cpos,\n\t\t\t\tu32 len, u32 phys,\n\t\t\t\tstruct ocfs2_alloc_context *meta_ac,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret;\n\n\ttrace_ocfs2_mark_extent_refcounted(OCFS2_I(inode)->ip_blkno,\n\t\t\t\t\t   cpos, len, phys);\n\n\tif (!ocfs2_refcount_tree(OCFS2_SB(inode->i_sb))) {\n\t\tocfs2_error(inode->i_sb, \"Inode %lu want to use refcount \"\n\t\t\t    \"tree, but the feature bit is not set in the \"\n\t\t\t    \"super block.\", inode->i_ino);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_change_extent_flag(handle, et, cpos,\n\t\t\t\t       len, phys, meta_ac, dealloc,\n\t\t\t\t       OCFS2_EXT_REFCOUNTED, 0);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_mark_extent_refcounted(struct inode *inode,\n\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\thandle_t *handle, u32 cpos,\n\t\t\t\tu32 len, u32 phys,\n\t\t\t\tstruct ocfs2_alloc_context *meta_ac,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret;\n\n\ttrace_ocfs2_mark_extent_refcounted(OCFS2_I(inode)->ip_blkno,\n\t\t\t\t\t   cpos, len, phys);\n\n\tif (!ocfs2_refcount_tree(OCFS2_SB(inode->i_sb))) {\n\t\tocfs2_error(inode->i_sb, \"Inode %lu want to use refcount \"\n\t\t\t    \"tree, but the feature bit is not set in the \"\n\t\t\t    \"super block.\", inode->i_ino);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_change_extent_flag(handle, et, cpos,\n\t\t\t\t       len, phys, meta_ac, dealloc,\n\t\t\t\t       OCFS2_EXT_REFCOUNTED, 0);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 3742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 3741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "credits"
          ],
          "line": 3740
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_reserve_new_metadata_blocks",
          "args": [
            "OCFS2_SB(inode->i_sb)",
            "ref_blocks",
            "&meta_ac"
          ],
          "line": 3729
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reserve_new_metadata_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "989-1049",
          "snippet": "int ocfs2_reserve_new_metadata_blocks(struct ocfs2_super *osb,\n\t\t\t\t      int blocks,\n\t\t\t\t      struct ocfs2_alloc_context **ac)\n{\n\tint status;\n\tint slot = ocfs2_get_meta_steal_slot(osb);\n\n\t*ac = kzalloc(sizeof(struct ocfs2_alloc_context), GFP_KERNEL);\n\tif (!(*ac)) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t(*ac)->ac_bits_wanted = blocks;\n\t(*ac)->ac_which = OCFS2_AC_USE_META;\n\t(*ac)->ac_group_search = ocfs2_block_group_search;\n\n\tif (slot != OCFS2_INVALID_SLOT &&\n\t\tatomic_read(&osb->s_num_meta_stolen) < OCFS2_MAX_TO_STEAL)\n\t\tgoto extent_steal;\n\n\tatomic_set(&osb->s_num_meta_stolen, 0);\n\tstatus = ocfs2_reserve_suballoc_bits(osb, (*ac),\n\t\t\t\t\t     EXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t     (u32)osb->slot_num, NULL,\n\t\t\t\t\t     ALLOC_GROUPS_FROM_GLOBAL|ALLOC_NEW_GROUP);\n\n\n\tif (status >= 0) {\n\t\tstatus = 0;\n\t\tif (slot != OCFS2_INVALID_SLOT)\n\t\t\tocfs2_init_meta_steal_slot(osb);\n\t\tgoto bail;\n\t} else if (status < 0 && status != -ENOSPC) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_free_ac_resource(*ac);\n\nextent_steal:\n\tstatus = ocfs2_steal_meta(osb, *ac);\n\tatomic_inc(&osb->s_num_meta_stolen);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = 0;\nbail:\n\tif ((status < 0) && *ac) {\n\t\tocfs2_free_alloc_context(*ac);\n\t\t*ac = NULL;\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_MAX_TO_STEAL\t\t1024",
            "#define ALLOC_GROUPS_FROM_GLOBAL\t0x2",
            "#define ALLOC_NEW_GROUP\t\t\t0x1"
          ],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define OCFS2_MAX_TO_STEAL\t\t1024\n#define ALLOC_GROUPS_FROM_GLOBAL\t0x2\n#define ALLOC_NEW_GROUP\t\t\t0x1\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint ocfs2_reserve_new_metadata_blocks(struct ocfs2_super *osb,\n\t\t\t\t      int blocks,\n\t\t\t\t      struct ocfs2_alloc_context **ac)\n{\n\tint status;\n\tint slot = ocfs2_get_meta_steal_slot(osb);\n\n\t*ac = kzalloc(sizeof(struct ocfs2_alloc_context), GFP_KERNEL);\n\tif (!(*ac)) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t(*ac)->ac_bits_wanted = blocks;\n\t(*ac)->ac_which = OCFS2_AC_USE_META;\n\t(*ac)->ac_group_search = ocfs2_block_group_search;\n\n\tif (slot != OCFS2_INVALID_SLOT &&\n\t\tatomic_read(&osb->s_num_meta_stolen) < OCFS2_MAX_TO_STEAL)\n\t\tgoto extent_steal;\n\n\tatomic_set(&osb->s_num_meta_stolen, 0);\n\tstatus = ocfs2_reserve_suballoc_bits(osb, (*ac),\n\t\t\t\t\t     EXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t     (u32)osb->slot_num, NULL,\n\t\t\t\t\t     ALLOC_GROUPS_FROM_GLOBAL|ALLOC_NEW_GROUP);\n\n\n\tif (status >= 0) {\n\t\tstatus = 0;\n\t\tif (slot != OCFS2_INVALID_SLOT)\n\t\t\tocfs2_init_meta_steal_slot(osb);\n\t\tgoto bail;\n\t} else if (status < 0 && status != -ENOSPC) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_free_ac_resource(*ac);\n\nextent_steal:\n\tstatus = ocfs2_steal_meta(osb, *ac);\n\tatomic_inc(&osb->s_num_meta_stolen);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = 0;\nbail:\n\tif ((status < 0) && *ac) {\n\t\tocfs2_free_alloc_context(*ac);\n\t\t*ac = NULL;\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 3729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_add_refcount_flag",
          "args": [
            "ref_blocks",
            "credits"
          ],
          "line": 3726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_calc_refcount_meta_credits",
          "args": [
            "inode->i_sb",
            "ref_ci",
            "ref_root_bh",
            "p_cluster",
            "num_clusters",
            "&ref_blocks",
            "&credits"
          ],
          "line": 3717
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_calc_refcount_meta_credits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "2385-2522",
          "snippet": "static int ocfs2_calc_refcount_meta_credits(struct super_block *sb,\n\t\t\t\t\t    struct ocfs2_caching_info *ci,\n\t\t\t\t\t    struct buffer_head *ref_root_bh,\n\t\t\t\t\t    u64 start_cpos,\n\t\t\t\t\t    u32 clusters,\n\t\t\t\t\t    int *meta_add,\n\t\t\t\t\t    int *credits)\n{\n\tint ret = 0, index, ref_blocks = 0, recs_add = 0;\n\tu64 cpos = start_cpos;\n\tstruct ocfs2_refcount_block *rb;\n\tstruct ocfs2_refcount_rec rec;\n\tstruct buffer_head *ref_leaf_bh = NULL, *prev_bh = NULL;\n\tu32 len;\n\n\twhile (clusters) {\n\t\tret = ocfs2_get_refcount_rec(ci, ref_root_bh,\n\t\t\t\t\t     cpos, clusters, &rec,\n\t\t\t\t\t     &index, &ref_leaf_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (ref_leaf_bh != prev_bh) {\n\t\t\t/*\n\t\t\t * Now we encounter a new leaf block, so calculate\n\t\t\t * whether we need to extend the old leaf.\n\t\t\t */\n\t\t\tif (prev_bh) {\n\t\t\t\trb = (struct ocfs2_refcount_block *)\n\t\t\t\t\t\t\tprev_bh->b_data;\n\n\t\t\t\tif (le16_to_cpu(rb->rf_records.rl_used) +\n\t\t\t\t    recs_add >\n\t\t\t\t    le16_to_cpu(rb->rf_records.rl_count))\n\t\t\t\t\tref_blocks++;\n\t\t\t}\n\n\t\t\trecs_add = 0;\n\t\t\t*credits += 1;\n\t\t\tbrelse(prev_bh);\n\t\t\tprev_bh = ref_leaf_bh;\n\t\t\tget_bh(prev_bh);\n\t\t}\n\n\t\ttrace_ocfs2_calc_refcount_meta_credits_iterate(\n\t\t\t\trecs_add, (unsigned long long)cpos, clusters,\n\t\t\t\t(unsigned long long)le64_to_cpu(rec.r_cpos),\n\t\t\t\tle32_to_cpu(rec.r_clusters),\n\t\t\t\tle32_to_cpu(rec.r_refcount), index);\n\n\t\tlen = min((u64)cpos + clusters, le64_to_cpu(rec.r_cpos) +\n\t\t\t  le32_to_cpu(rec.r_clusters)) - cpos;\n\t\t/*\n\t\t * We record all the records which will be inserted to the\n\t\t * same refcount block, so that we can tell exactly whether\n\t\t * we need a new refcount block or not.\n\t\t *\n\t\t * If we will insert a new one, this is easy and only happens\n\t\t * during adding refcounted flag to the extent, so we don't\n\t\t * have a chance of spliting. We just need one record.\n\t\t *\n\t\t * If the refcount rec already exists, that would be a little\n\t\t * complicated. we may have to:\n\t\t * 1) split at the beginning if the start pos isn't aligned.\n\t\t *    we need 1 more record in this case.\n\t\t * 2) split int the end if the end pos isn't aligned.\n\t\t *    we need 1 more record in this case.\n\t\t * 3) split in the middle because of file system fragmentation.\n\t\t *    we need 2 more records in this case(we can't detect this\n\t\t *    beforehand, so always think of the worst case).\n\t\t */\n\t\tif (rec.r_refcount) {\n\t\t\trecs_add += 2;\n\t\t\t/* Check whether we need a split at the beginning. */\n\t\t\tif (cpos == start_cpos &&\n\t\t\t    cpos != le64_to_cpu(rec.r_cpos))\n\t\t\t\trecs_add++;\n\n\t\t\t/* Check whether we need a split in the end. */\n\t\t\tif (cpos + clusters < le64_to_cpu(rec.r_cpos) +\n\t\t\t    le32_to_cpu(rec.r_clusters))\n\t\t\t\trecs_add++;\n\t\t} else\n\t\t\trecs_add++;\n\n\t\tbrelse(ref_leaf_bh);\n\t\tref_leaf_bh = NULL;\n\t\tclusters -= len;\n\t\tcpos += len;\n\t}\n\n\tif (prev_bh) {\n\t\trb = (struct ocfs2_refcount_block *)prev_bh->b_data;\n\n\t\tif (le16_to_cpu(rb->rf_records.rl_used) + recs_add >\n\t\t    le16_to_cpu(rb->rf_records.rl_count))\n\t\t\tref_blocks++;\n\n\t\t*credits += 1;\n\t}\n\n\tif (!ref_blocks)\n\t\tgoto out;\n\n\t*meta_add += ref_blocks;\n\t*credits += ref_blocks;\n\n\t/*\n\t * So we may need ref_blocks to insert into the tree.\n\t * That also means we need to change the b-tree and add that number\n\t * of records since we never merge them.\n\t * We need one more block for expansion since the new created leaf\n\t * block is also full and needs split.\n\t */\n\trb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\tif (le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL) {\n\t\tstruct ocfs2_extent_tree et;\n\n\t\tocfs2_init_refcount_extent_tree(&et, ci, ref_root_bh);\n\t\t*meta_add += ocfs2_extend_meta_needed(et.et_root_el);\n\t\t*credits += ocfs2_calc_extend_credits(sb,\n\t\t\t\t\t\t      et.et_root_el);\n\t} else {\n\t\t*credits += OCFS2_EXPAND_REFCOUNT_TREE_CREDITS;\n\t\t*meta_add += 1;\n\t}\n\nout:\n\n\ttrace_ocfs2_calc_refcount_meta_credits(\n\t\t(unsigned long long)start_cpos, clusters,\n\t\t*meta_add, *credits);\n\tbrelse(ref_leaf_bh);\n\tbrelse(prev_bh);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_calc_refcount_meta_credits(struct super_block *sb,\n\t\t\t\t\t    struct ocfs2_caching_info *ci,\n\t\t\t\t\t    struct buffer_head *ref_root_bh,\n\t\t\t\t\t    u64 start_cpos,\n\t\t\t\t\t    u32 clusters,\n\t\t\t\t\t    int *meta_add,\n\t\t\t\t\t    int *credits)\n{\n\tint ret = 0, index, ref_blocks = 0, recs_add = 0;\n\tu64 cpos = start_cpos;\n\tstruct ocfs2_refcount_block *rb;\n\tstruct ocfs2_refcount_rec rec;\n\tstruct buffer_head *ref_leaf_bh = NULL, *prev_bh = NULL;\n\tu32 len;\n\n\twhile (clusters) {\n\t\tret = ocfs2_get_refcount_rec(ci, ref_root_bh,\n\t\t\t\t\t     cpos, clusters, &rec,\n\t\t\t\t\t     &index, &ref_leaf_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (ref_leaf_bh != prev_bh) {\n\t\t\t/*\n\t\t\t * Now we encounter a new leaf block, so calculate\n\t\t\t * whether we need to extend the old leaf.\n\t\t\t */\n\t\t\tif (prev_bh) {\n\t\t\t\trb = (struct ocfs2_refcount_block *)\n\t\t\t\t\t\t\tprev_bh->b_data;\n\n\t\t\t\tif (le16_to_cpu(rb->rf_records.rl_used) +\n\t\t\t\t    recs_add >\n\t\t\t\t    le16_to_cpu(rb->rf_records.rl_count))\n\t\t\t\t\tref_blocks++;\n\t\t\t}\n\n\t\t\trecs_add = 0;\n\t\t\t*credits += 1;\n\t\t\tbrelse(prev_bh);\n\t\t\tprev_bh = ref_leaf_bh;\n\t\t\tget_bh(prev_bh);\n\t\t}\n\n\t\ttrace_ocfs2_calc_refcount_meta_credits_iterate(\n\t\t\t\trecs_add, (unsigned long long)cpos, clusters,\n\t\t\t\t(unsigned long long)le64_to_cpu(rec.r_cpos),\n\t\t\t\tle32_to_cpu(rec.r_clusters),\n\t\t\t\tle32_to_cpu(rec.r_refcount), index);\n\n\t\tlen = min((u64)cpos + clusters, le64_to_cpu(rec.r_cpos) +\n\t\t\t  le32_to_cpu(rec.r_clusters)) - cpos;\n\t\t/*\n\t\t * We record all the records which will be inserted to the\n\t\t * same refcount block, so that we can tell exactly whether\n\t\t * we need a new refcount block or not.\n\t\t *\n\t\t * If we will insert a new one, this is easy and only happens\n\t\t * during adding refcounted flag to the extent, so we don't\n\t\t * have a chance of spliting. We just need one record.\n\t\t *\n\t\t * If the refcount rec already exists, that would be a little\n\t\t * complicated. we may have to:\n\t\t * 1) split at the beginning if the start pos isn't aligned.\n\t\t *    we need 1 more record in this case.\n\t\t * 2) split int the end if the end pos isn't aligned.\n\t\t *    we need 1 more record in this case.\n\t\t * 3) split in the middle because of file system fragmentation.\n\t\t *    we need 2 more records in this case(we can't detect this\n\t\t *    beforehand, so always think of the worst case).\n\t\t */\n\t\tif (rec.r_refcount) {\n\t\t\trecs_add += 2;\n\t\t\t/* Check whether we need a split at the beginning. */\n\t\t\tif (cpos == start_cpos &&\n\t\t\t    cpos != le64_to_cpu(rec.r_cpos))\n\t\t\t\trecs_add++;\n\n\t\t\t/* Check whether we need a split in the end. */\n\t\t\tif (cpos + clusters < le64_to_cpu(rec.r_cpos) +\n\t\t\t    le32_to_cpu(rec.r_clusters))\n\t\t\t\trecs_add++;\n\t\t} else\n\t\t\trecs_add++;\n\n\t\tbrelse(ref_leaf_bh);\n\t\tref_leaf_bh = NULL;\n\t\tclusters -= len;\n\t\tcpos += len;\n\t}\n\n\tif (prev_bh) {\n\t\trb = (struct ocfs2_refcount_block *)prev_bh->b_data;\n\n\t\tif (le16_to_cpu(rb->rf_records.rl_used) + recs_add >\n\t\t    le16_to_cpu(rb->rf_records.rl_count))\n\t\t\tref_blocks++;\n\n\t\t*credits += 1;\n\t}\n\n\tif (!ref_blocks)\n\t\tgoto out;\n\n\t*meta_add += ref_blocks;\n\t*credits += ref_blocks;\n\n\t/*\n\t * So we may need ref_blocks to insert into the tree.\n\t * That also means we need to change the b-tree and add that number\n\t * of records since we never merge them.\n\t * We need one more block for expansion since the new created leaf\n\t * block is also full and needs split.\n\t */\n\trb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\tif (le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL) {\n\t\tstruct ocfs2_extent_tree et;\n\n\t\tocfs2_init_refcount_extent_tree(&et, ci, ref_root_bh);\n\t\t*meta_add += ocfs2_extend_meta_needed(et.et_root_el);\n\t\t*credits += ocfs2_calc_extend_credits(sb,\n\t\t\t\t\t\t      et.et_root_el);\n\t} else {\n\t\t*credits += OCFS2_EXPAND_REFCOUNT_TREE_CREDITS;\n\t\t*meta_add += 1;\n\t}\n\nout:\n\n\ttrace_ocfs2_calc_refcount_meta_credits(\n\t\t(unsigned long long)start_cpos, clusters,\n\t\t*meta_add, *credits);\n\tbrelse(ref_leaf_bh);\n\tbrelse(prev_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 3714
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nint ocfs2_add_refcount_flag(struct inode *inode,\n\t\t\t    struct ocfs2_extent_tree *data_et,\n\t\t\t    struct ocfs2_caching_info *ref_ci,\n\t\t\t    struct buffer_head *ref_root_bh,\n\t\t\t    u32 cpos, u32 p_cluster, u32 num_clusters,\n\t\t\t    struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t    struct ocfs2_post_refcount *post)\n{\n\tint ret;\n\thandle_t *handle;\n\tint credits = 1, ref_blocks = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\n\tret = ocfs2_calc_refcount_meta_credits(inode->i_sb,\n\t\t\t\t\t       ref_ci, ref_root_bh,\n\t\t\t\t\t       p_cluster, num_clusters,\n\t\t\t\t\t       &ref_blocks, &credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_add_refcount_flag(ref_blocks, credits);\n\n\tif (ref_blocks) {\n\t\tret = ocfs2_reserve_new_metadata_blocks(OCFS2_SB(inode->i_sb),\n\t\t\t\t\t\t\tref_blocks, &meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (post)\n\t\tcredits += post->credits;\n\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_mark_extent_refcounted(inode, data_et, handle,\n\t\t\t\t\t   cpos, num_clusters, p_cluster,\n\t\t\t\t\t   meta_ac, dealloc);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tret = __ocfs2_increase_refcount(handle, ref_ci, ref_root_bh,\n\t\t\t\t\tp_cluster, num_clusters, 0,\n\t\t\t\t\tmeta_ac, dealloc);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tif (post && post->func) {\n\t\tret = post->func(inode, handle, post->para);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\nout:\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_refcount_cow_xattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "3640-3697",
    "snippet": "int ocfs2_refcount_cow_xattr(struct inode *inode,\n\t\t\t     struct ocfs2_dinode *di,\n\t\t\t     struct ocfs2_xattr_value_buf *vb,\n\t\t\t     struct ocfs2_refcount_tree *ref_tree,\n\t\t\t     struct buffer_head *ref_root_bh,\n\t\t\t     u32 cpos, u32 write_len,\n\t\t\t     struct ocfs2_post_refcount *post)\n{\n\tint ret;\n\tstruct ocfs2_xattr_value_root *xv = vb->vb_xv;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_cow_context *context = NULL;\n\tu32 cow_start, cow_len;\n\n\tBUG_ON(!(oi->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL));\n\n\tret = ocfs2_refcount_cal_cow_clusters(inode, &xv->xr_list,\n\t\t\t\t\t      cpos, write_len, UINT_MAX,\n\t\t\t\t\t      &cow_start, &cow_len);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tBUG_ON(cow_len == 0);\n\n\tcontext = kzalloc(sizeof(struct ocfs2_cow_context), GFP_NOFS);\n\tif (!context) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tcontext->inode = inode;\n\tcontext->cow_start = cow_start;\n\tcontext->cow_len = cow_len;\n\tcontext->ref_tree = ref_tree;\n\tcontext->ref_root_bh = ref_root_bh;\n\tcontext->cow_object = xv;\n\n\tcontext->cow_duplicate_clusters = ocfs2_duplicate_clusters_by_jbd;\n\t/* We need the extra credits for duplicate_clusters by jbd. */\n\tcontext->extra_credits =\n\t\tocfs2_clusters_to_blocks(inode->i_sb, 1) * cow_len;\n\tcontext->get_clusters = ocfs2_xattr_value_get_clusters;\n\tcontext->post_refcount = post;\n\n\tocfs2_init_xattr_value_extent_tree(&context->data_et,\n\t\t\t\t\t   INODE_CACHE(inode), vb);\n\n\tret = ocfs2_replace_cow(context);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\tkfree(context);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "context"
          ],
          "line": 3695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_replace_cow",
          "args": [
            "context"
          ],
          "line": 3690
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_replace_cow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "3371-3420",
          "snippet": "static int ocfs2_replace_cow(struct ocfs2_cow_context *context)\n{\n\tint ret = 0;\n\tstruct inode *inode = context->inode;\n\tu32 cow_start = context->cow_start, cow_len = context->cow_len;\n\tu32 p_cluster, num_clusters;\n\tunsigned int ext_flags;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (!ocfs2_refcount_tree(OCFS2_SB(inode->i_sb))) {\n\t\tocfs2_error(inode->i_sb, \"Inode %lu want to use refcount \"\n\t\t\t    \"tree, but the feature bit is not set in the \"\n\t\t\t    \"super block.\", inode->i_ino);\n\t\treturn -EROFS;\n\t}\n\n\tocfs2_init_dealloc_ctxt(&context->dealloc);\n\n\twhile (cow_len) {\n\t\tret = context->get_clusters(context, cow_start, &p_cluster,\n\t\t\t\t\t    &num_clusters, &ext_flags);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tBUG_ON(!(ext_flags & OCFS2_EXT_REFCOUNTED));\n\n\t\tif (cow_len < num_clusters)\n\t\t\tnum_clusters = cow_len;\n\n\t\tret = ocfs2_make_clusters_writable(inode->i_sb, context,\n\t\t\t\t\t\t   cow_start, p_cluster,\n\t\t\t\t\t\t   num_clusters, ext_flags);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tcow_len -= num_clusters;\n\t\tcow_start += num_clusters;\n\t}\n\n\tif (ocfs2_dealloc_has_cluster(&context->dealloc)) {\n\t\tocfs2_schedule_truncate_log_flush(osb, 1);\n\t\tocfs2_run_deallocs(osb, &context->dealloc);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_replace_cow(struct ocfs2_cow_context *context)\n{\n\tint ret = 0;\n\tstruct inode *inode = context->inode;\n\tu32 cow_start = context->cow_start, cow_len = context->cow_len;\n\tu32 p_cluster, num_clusters;\n\tunsigned int ext_flags;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (!ocfs2_refcount_tree(OCFS2_SB(inode->i_sb))) {\n\t\tocfs2_error(inode->i_sb, \"Inode %lu want to use refcount \"\n\t\t\t    \"tree, but the feature bit is not set in the \"\n\t\t\t    \"super block.\", inode->i_ino);\n\t\treturn -EROFS;\n\t}\n\n\tocfs2_init_dealloc_ctxt(&context->dealloc);\n\n\twhile (cow_len) {\n\t\tret = context->get_clusters(context, cow_start, &p_cluster,\n\t\t\t\t\t    &num_clusters, &ext_flags);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tBUG_ON(!(ext_flags & OCFS2_EXT_REFCOUNTED));\n\n\t\tif (cow_len < num_clusters)\n\t\t\tnum_clusters = cow_len;\n\n\t\tret = ocfs2_make_clusters_writable(inode->i_sb, context,\n\t\t\t\t\t\t   cow_start, p_cluster,\n\t\t\t\t\t\t   num_clusters, ext_flags);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tcow_len -= num_clusters;\n\t\tcow_start += num_clusters;\n\t}\n\n\tif (ocfs2_dealloc_has_cluster(&context->dealloc)) {\n\t\tocfs2_schedule_truncate_log_flush(osb, 1);\n\t\tocfs2_run_deallocs(osb, &context->dealloc);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_init_xattr_value_extent_tree",
          "args": [
            "&context->data_et",
            "INODE_CACHE(inode)",
            "vb"
          ],
          "line": 3687
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_xattr_value_extent_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "474-480",
          "snippet": "void ocfs2_init_xattr_value_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t\tstruct ocfs2_caching_info *ci,\n\t\t\t\t\tstruct ocfs2_xattr_value_buf *vb)\n{\n\t__ocfs2_init_extent_tree(et, ci, vb->vb_bh, vb->vb_access, vb,\n\t\t\t\t &ocfs2_xattr_value_et_ops);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static struct ocfs2_extent_tree_operations ocfs2_xattr_value_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_xattr_value_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_xattr_value_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_xattr_value_update_clusters,\n\t.eo_fill_root_el\t= ocfs2_xattr_value_fill_root_el,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic struct ocfs2_extent_tree_operations ocfs2_xattr_value_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_xattr_value_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_xattr_value_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_xattr_value_update_clusters,\n\t.eo_fill_root_el\t= ocfs2_xattr_value_fill_root_el,\n};\n\nvoid ocfs2_init_xattr_value_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t\tstruct ocfs2_caching_info *ci,\n\t\t\t\t\tstruct ocfs2_xattr_value_buf *vb)\n{\n\t__ocfs2_init_extent_tree(et, ci, vb->vb_bh, vb->vb_access, vb,\n\t\t\t\t &ocfs2_xattr_value_et_ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 3688
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_blocks",
          "args": [
            "inode->i_sb",
            "1"
          ],
          "line": 3683
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "711-718",
          "snippet": "static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct ocfs2_cow_context)",
            "GFP_NOFS"
          ],
          "line": 3666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "cow_len == 0"
          ],
          "line": 3664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_refcount_cal_cow_clusters",
          "args": [
            "inode",
            "&xv->xr_list",
            "cpos",
            "write_len",
            "UINT_MAX",
            "&cow_start",
            "&cow_len"
          ],
          "line": 3656
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_refcount_cal_cow_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "2647-2844",
          "snippet": "static int ocfs2_refcount_cal_cow_clusters(struct inode *inode,\n\t\t\t\t\t   struct ocfs2_extent_list *el,\n\t\t\t\t\t   u32 cpos,\n\t\t\t\t\t   u32 write_len,\n\t\t\t\t\t   u32 max_cpos,\n\t\t\t\t\t   u32 *cow_start,\n\t\t\t\t\t   u32 *cow_len)\n{\n\tint ret = 0;\n\tint tree_height = le16_to_cpu(el->l_tree_depth), i;\n\tstruct buffer_head *eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb = NULL;\n\tstruct ocfs2_extent_rec *rec;\n\tunsigned int want_clusters, rec_end = 0;\n\tint contig_clusters = ocfs2_cow_contig_clusters(inode->i_sb);\n\tint leaf_clusters;\n\n\tBUG_ON(cpos + write_len > max_cpos);\n\n\tif (tree_height > 0) {\n\t\tret = ocfs2_find_leaf(INODE_CACHE(inode), el, cpos, &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tocfs2_error(inode->i_sb,\n\t\t\t\t    \"Inode %lu has non zero tree depth in \"\n\t\t\t\t    \"leaf block %llu\\n\", inode->i_ino,\n\t\t\t\t    (unsigned long long)eb_bh->b_blocknr);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t*cow_len = 0;\n\tfor (i = 0; i < le16_to_cpu(el->l_next_free_rec); i++) {\n\t\trec = &el->l_recs[i];\n\n\t\tif (ocfs2_is_empty_extent(rec)) {\n\t\t\tmlog_bug_on_msg(i != 0, \"Inode %lu has empty record in \"\n\t\t\t\t\t\"index %d\\n\", inode->i_ino, i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (le32_to_cpu(rec->e_cpos) +\n\t\t    le16_to_cpu(rec->e_leaf_clusters) <= cpos)\n\t\t\tcontinue;\n\n\t\tif (*cow_len == 0) {\n\t\t\t/*\n\t\t\t * We should find a refcounted record in the\n\t\t\t * first pass.\n\t\t\t */\n\t\t\tBUG_ON(!(rec->e_flags & OCFS2_EXT_REFCOUNTED));\n\t\t\t*cow_start = le32_to_cpu(rec->e_cpos);\n\t\t}\n\n\t\t/*\n\t\t * If we encounter a hole, a non-refcounted record or\n\t\t * pass the max_cpos, stop the search.\n\t\t */\n\t\tif ((!(rec->e_flags & OCFS2_EXT_REFCOUNTED)) ||\n\t\t    (*cow_len && rec_end != le32_to_cpu(rec->e_cpos)) ||\n\t\t    (max_cpos <= le32_to_cpu(rec->e_cpos)))\n\t\t\tbreak;\n\n\t\tleaf_clusters = le16_to_cpu(rec->e_leaf_clusters);\n\t\trec_end = le32_to_cpu(rec->e_cpos) + leaf_clusters;\n\t\tif (rec_end > max_cpos) {\n\t\t\trec_end = max_cpos;\n\t\t\tleaf_clusters = rec_end - le32_to_cpu(rec->e_cpos);\n\t\t}\n\n\t\t/*\n\t\t * How many clusters do we actually need from\n\t\t * this extent?  First we see how many we actually\n\t\t * need to complete the write.  If that's smaller\n\t\t * than contig_clusters, we try for contig_clusters.\n\t\t */\n\t\tif (!*cow_len)\n\t\t\twant_clusters = write_len;\n\t\telse\n\t\t\twant_clusters = (cpos + write_len) -\n\t\t\t\t(*cow_start + *cow_len);\n\t\tif (want_clusters < contig_clusters)\n\t\t\twant_clusters = contig_clusters;\n\n\t\t/*\n\t\t * If the write does not cover the whole extent, we\n\t\t * need to calculate how we're going to split the extent.\n\t\t * We try to do it on contig_clusters boundaries.\n\t\t *\n\t\t * Any extent smaller than contig_clusters will be\n\t\t * CoWed in its entirety.\n\t\t */\n\t\tif (leaf_clusters <= contig_clusters)\n\t\t\t*cow_len += leaf_clusters;\n\t\telse if (*cow_len || (*cow_start == cpos)) {\n\t\t\t/*\n\t\t\t * This extent needs to be CoW'd from its\n\t\t\t * beginning, so all we have to do is compute\n\t\t\t * how many clusters to grab.  We align\n\t\t\t * want_clusters to the edge of contig_clusters\n\t\t\t * to get better I/O.\n\t\t\t */\n\t\t\twant_clusters = ocfs2_cow_align_length(inode->i_sb,\n\t\t\t\t\t\t\t       want_clusters);\n\n\t\t\tif (leaf_clusters < want_clusters)\n\t\t\t\t*cow_len += leaf_clusters;\n\t\t\telse\n\t\t\t\t*cow_len += want_clusters;\n\t\t} else if ((*cow_start + contig_clusters) >=\n\t\t\t   (cpos + write_len)) {\n\t\t\t/*\n\t\t\t * Breaking off contig_clusters at the front\n\t\t\t * of the extent will cover our write.  That's\n\t\t\t * easy.\n\t\t\t */\n\t\t\t*cow_len = contig_clusters;\n\t\t} else if ((rec_end - cpos) <= contig_clusters) {\n\t\t\t/*\n\t\t\t * Breaking off contig_clusters at the tail of\n\t\t\t * this extent will cover cpos.\n\t\t\t */\n\t\t\t*cow_start = rec_end - contig_clusters;\n\t\t\t*cow_len = contig_clusters;\n\t\t} else if ((rec_end - cpos) <= want_clusters) {\n\t\t\t/*\n\t\t\t * While we can't fit the entire write in this\n\t\t\t * extent, we know that the write goes from cpos\n\t\t\t * to the end of the extent.  Break that off.\n\t\t\t * We try to break it at some multiple of\n\t\t\t * contig_clusters from the front of the extent.\n\t\t\t * Failing that (ie, cpos is within\n\t\t\t * contig_clusters of the front), we'll CoW the\n\t\t\t * entire extent.\n\t\t\t */\n\t\t\t*cow_start = ocfs2_cow_align_start(inode->i_sb,\n\t\t\t\t\t\t\t   *cow_start, cpos);\n\t\t\t*cow_len = rec_end - *cow_start;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Ok, the entire write lives in the middle of\n\t\t\t * this extent.  Let's try to slice the extent up\n\t\t\t * nicely.  Optimally, our CoW region starts at\n\t\t\t * m*contig_clusters from the beginning of the\n\t\t\t * extent and goes for n*contig_clusters,\n\t\t\t * covering the entire write.\n\t\t\t */\n\t\t\t*cow_start = ocfs2_cow_align_start(inode->i_sb,\n\t\t\t\t\t\t\t   *cow_start, cpos);\n\n\t\t\twant_clusters = (cpos + write_len) - *cow_start;\n\t\t\twant_clusters = ocfs2_cow_align_length(inode->i_sb,\n\t\t\t\t\t\t\t       want_clusters);\n\t\t\tif (*cow_start + want_clusters <= rec_end)\n\t\t\t\t*cow_len = want_clusters;\n\t\t\telse\n\t\t\t\t*cow_len = rec_end - *cow_start;\n\t\t}\n\n\t\t/* Have we covered our entire write yet? */\n\t\tif ((*cow_start + *cow_len) >= (cpos + write_len))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * If we reach the end of the extent block and don't get enough\n\t\t * clusters, continue with the next extent block if possible.\n\t\t */\n\t\tif (i + 1 == le16_to_cpu(el->l_next_free_rec) &&\n\t\t    eb && eb->h_next_leaf_blk) {\n\t\t\tbrelse(eb_bh);\n\t\t\teb_bh = NULL;\n\n\t\t\tret = ocfs2_read_extent_block(INODE_CACHE(inode),\n\t\t\t\t\t       le64_to_cpu(eb->h_next_leaf_blk),\n\t\t\t\t\t       &eb_bh);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\t\tel = &eb->h_list;\n\t\t\ti = -1;\n\t\t}\n\t}\n\nout:\n\tbrelse(eb_bh);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_refcount_cal_cow_clusters(struct inode *inode,\n\t\t\t\t\t   struct ocfs2_extent_list *el,\n\t\t\t\t\t   u32 cpos,\n\t\t\t\t\t   u32 write_len,\n\t\t\t\t\t   u32 max_cpos,\n\t\t\t\t\t   u32 *cow_start,\n\t\t\t\t\t   u32 *cow_len)\n{\n\tint ret = 0;\n\tint tree_height = le16_to_cpu(el->l_tree_depth), i;\n\tstruct buffer_head *eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb = NULL;\n\tstruct ocfs2_extent_rec *rec;\n\tunsigned int want_clusters, rec_end = 0;\n\tint contig_clusters = ocfs2_cow_contig_clusters(inode->i_sb);\n\tint leaf_clusters;\n\n\tBUG_ON(cpos + write_len > max_cpos);\n\n\tif (tree_height > 0) {\n\t\tret = ocfs2_find_leaf(INODE_CACHE(inode), el, cpos, &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tocfs2_error(inode->i_sb,\n\t\t\t\t    \"Inode %lu has non zero tree depth in \"\n\t\t\t\t    \"leaf block %llu\\n\", inode->i_ino,\n\t\t\t\t    (unsigned long long)eb_bh->b_blocknr);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t*cow_len = 0;\n\tfor (i = 0; i < le16_to_cpu(el->l_next_free_rec); i++) {\n\t\trec = &el->l_recs[i];\n\n\t\tif (ocfs2_is_empty_extent(rec)) {\n\t\t\tmlog_bug_on_msg(i != 0, \"Inode %lu has empty record in \"\n\t\t\t\t\t\"index %d\\n\", inode->i_ino, i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (le32_to_cpu(rec->e_cpos) +\n\t\t    le16_to_cpu(rec->e_leaf_clusters) <= cpos)\n\t\t\tcontinue;\n\n\t\tif (*cow_len == 0) {\n\t\t\t/*\n\t\t\t * We should find a refcounted record in the\n\t\t\t * first pass.\n\t\t\t */\n\t\t\tBUG_ON(!(rec->e_flags & OCFS2_EXT_REFCOUNTED));\n\t\t\t*cow_start = le32_to_cpu(rec->e_cpos);\n\t\t}\n\n\t\t/*\n\t\t * If we encounter a hole, a non-refcounted record or\n\t\t * pass the max_cpos, stop the search.\n\t\t */\n\t\tif ((!(rec->e_flags & OCFS2_EXT_REFCOUNTED)) ||\n\t\t    (*cow_len && rec_end != le32_to_cpu(rec->e_cpos)) ||\n\t\t    (max_cpos <= le32_to_cpu(rec->e_cpos)))\n\t\t\tbreak;\n\n\t\tleaf_clusters = le16_to_cpu(rec->e_leaf_clusters);\n\t\trec_end = le32_to_cpu(rec->e_cpos) + leaf_clusters;\n\t\tif (rec_end > max_cpos) {\n\t\t\trec_end = max_cpos;\n\t\t\tleaf_clusters = rec_end - le32_to_cpu(rec->e_cpos);\n\t\t}\n\n\t\t/*\n\t\t * How many clusters do we actually need from\n\t\t * this extent?  First we see how many we actually\n\t\t * need to complete the write.  If that's smaller\n\t\t * than contig_clusters, we try for contig_clusters.\n\t\t */\n\t\tif (!*cow_len)\n\t\t\twant_clusters = write_len;\n\t\telse\n\t\t\twant_clusters = (cpos + write_len) -\n\t\t\t\t(*cow_start + *cow_len);\n\t\tif (want_clusters < contig_clusters)\n\t\t\twant_clusters = contig_clusters;\n\n\t\t/*\n\t\t * If the write does not cover the whole extent, we\n\t\t * need to calculate how we're going to split the extent.\n\t\t * We try to do it on contig_clusters boundaries.\n\t\t *\n\t\t * Any extent smaller than contig_clusters will be\n\t\t * CoWed in its entirety.\n\t\t */\n\t\tif (leaf_clusters <= contig_clusters)\n\t\t\t*cow_len += leaf_clusters;\n\t\telse if (*cow_len || (*cow_start == cpos)) {\n\t\t\t/*\n\t\t\t * This extent needs to be CoW'd from its\n\t\t\t * beginning, so all we have to do is compute\n\t\t\t * how many clusters to grab.  We align\n\t\t\t * want_clusters to the edge of contig_clusters\n\t\t\t * to get better I/O.\n\t\t\t */\n\t\t\twant_clusters = ocfs2_cow_align_length(inode->i_sb,\n\t\t\t\t\t\t\t       want_clusters);\n\n\t\t\tif (leaf_clusters < want_clusters)\n\t\t\t\t*cow_len += leaf_clusters;\n\t\t\telse\n\t\t\t\t*cow_len += want_clusters;\n\t\t} else if ((*cow_start + contig_clusters) >=\n\t\t\t   (cpos + write_len)) {\n\t\t\t/*\n\t\t\t * Breaking off contig_clusters at the front\n\t\t\t * of the extent will cover our write.  That's\n\t\t\t * easy.\n\t\t\t */\n\t\t\t*cow_len = contig_clusters;\n\t\t} else if ((rec_end - cpos) <= contig_clusters) {\n\t\t\t/*\n\t\t\t * Breaking off contig_clusters at the tail of\n\t\t\t * this extent will cover cpos.\n\t\t\t */\n\t\t\t*cow_start = rec_end - contig_clusters;\n\t\t\t*cow_len = contig_clusters;\n\t\t} else if ((rec_end - cpos) <= want_clusters) {\n\t\t\t/*\n\t\t\t * While we can't fit the entire write in this\n\t\t\t * extent, we know that the write goes from cpos\n\t\t\t * to the end of the extent.  Break that off.\n\t\t\t * We try to break it at some multiple of\n\t\t\t * contig_clusters from the front of the extent.\n\t\t\t * Failing that (ie, cpos is within\n\t\t\t * contig_clusters of the front), we'll CoW the\n\t\t\t * entire extent.\n\t\t\t */\n\t\t\t*cow_start = ocfs2_cow_align_start(inode->i_sb,\n\t\t\t\t\t\t\t   *cow_start, cpos);\n\t\t\t*cow_len = rec_end - *cow_start;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Ok, the entire write lives in the middle of\n\t\t\t * this extent.  Let's try to slice the extent up\n\t\t\t * nicely.  Optimally, our CoW region starts at\n\t\t\t * m*contig_clusters from the beginning of the\n\t\t\t * extent and goes for n*contig_clusters,\n\t\t\t * covering the entire write.\n\t\t\t */\n\t\t\t*cow_start = ocfs2_cow_align_start(inode->i_sb,\n\t\t\t\t\t\t\t   *cow_start, cpos);\n\n\t\t\twant_clusters = (cpos + write_len) - *cow_start;\n\t\t\twant_clusters = ocfs2_cow_align_length(inode->i_sb,\n\t\t\t\t\t\t\t       want_clusters);\n\t\t\tif (*cow_start + want_clusters <= rec_end)\n\t\t\t\t*cow_len = want_clusters;\n\t\t\telse\n\t\t\t\t*cow_len = rec_end - *cow_start;\n\t\t}\n\n\t\t/* Have we covered our entire write yet? */\n\t\tif ((*cow_start + *cow_len) >= (cpos + write_len))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * If we reach the end of the extent block and don't get enough\n\t\t * clusters, continue with the next extent block if possible.\n\t\t */\n\t\tif (i + 1 == le16_to_cpu(el->l_next_free_rec) &&\n\t\t    eb && eb->h_next_leaf_blk) {\n\t\t\tbrelse(eb_bh);\n\t\t\teb_bh = NULL;\n\n\t\t\tret = ocfs2_read_extent_block(INODE_CACHE(inode),\n\t\t\t\t\t       le64_to_cpu(eb->h_next_leaf_blk),\n\t\t\t\t\t       &eb_bh);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\t\tel = &eb->h_list;\n\t\t\ti = -1;\n\t\t}\n\t}\n\nout:\n\tbrelse(eb_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(oi->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL)"
          ],
          "line": 3654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 3650
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nint ocfs2_refcount_cow_xattr(struct inode *inode,\n\t\t\t     struct ocfs2_dinode *di,\n\t\t\t     struct ocfs2_xattr_value_buf *vb,\n\t\t\t     struct ocfs2_refcount_tree *ref_tree,\n\t\t\t     struct buffer_head *ref_root_bh,\n\t\t\t     u32 cpos, u32 write_len,\n\t\t\t     struct ocfs2_post_refcount *post)\n{\n\tint ret;\n\tstruct ocfs2_xattr_value_root *xv = vb->vb_xv;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_cow_context *context = NULL;\n\tu32 cow_start, cow_len;\n\n\tBUG_ON(!(oi->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL));\n\n\tret = ocfs2_refcount_cal_cow_clusters(inode, &xv->xr_list,\n\t\t\t\t\t      cpos, write_len, UINT_MAX,\n\t\t\t\t\t      &cow_start, &cow_len);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tBUG_ON(cow_len == 0);\n\n\tcontext = kzalloc(sizeof(struct ocfs2_cow_context), GFP_NOFS);\n\tif (!context) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tcontext->inode = inode;\n\tcontext->cow_start = cow_start;\n\tcontext->cow_len = cow_len;\n\tcontext->ref_tree = ref_tree;\n\tcontext->ref_root_bh = ref_root_bh;\n\tcontext->cow_object = xv;\n\n\tcontext->cow_duplicate_clusters = ocfs2_duplicate_clusters_by_jbd;\n\t/* We need the extra credits for duplicate_clusters by jbd. */\n\tcontext->extra_credits =\n\t\tocfs2_clusters_to_blocks(inode->i_sb, 1) * cow_len;\n\tcontext->get_clusters = ocfs2_xattr_value_get_clusters;\n\tcontext->post_refcount = post;\n\n\tocfs2_init_xattr_value_extent_tree(&context->data_et,\n\t\t\t\t\t   INODE_CACHE(inode), vb);\n\n\tret = ocfs2_replace_cow(context);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\tkfree(context);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_refcounted_xattr_delete_need",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "3556-3635",
    "snippet": "int ocfs2_refcounted_xattr_delete_need(struct inode *inode,\n\t\t\t\t       struct ocfs2_caching_info *ref_ci,\n\t\t\t\t       struct buffer_head *ref_root_bh,\n\t\t\t\t       struct ocfs2_xattr_value_root *xv,\n\t\t\t\t       int *meta_add, int *credits)\n{\n\tint ret = 0, index, ref_blocks = 0;\n\tu32 p_cluster, num_clusters;\n\tu32 cpos = 0, clusters = le32_to_cpu(xv->xr_clusters);\n\tstruct ocfs2_refcount_block *rb;\n\tstruct ocfs2_refcount_rec rec;\n\tstruct buffer_head *ref_leaf_bh = NULL;\n\n\twhile (cpos < clusters) {\n\t\tret = ocfs2_xattr_get_clusters(inode, cpos, &p_cluster,\n\t\t\t\t\t       &num_clusters, &xv->xr_list,\n\t\t\t\t\t       NULL);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tcpos += num_clusters;\n\n\t\twhile (num_clusters) {\n\t\t\tret = ocfs2_get_refcount_rec(ref_ci, ref_root_bh,\n\t\t\t\t\t\t     p_cluster, num_clusters,\n\t\t\t\t\t\t     &rec, &index,\n\t\t\t\t\t\t     &ref_leaf_bh);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tBUG_ON(!rec.r_refcount);\n\n\t\t\trb = (struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\n\n\t\t\t/*\n\t\t\t * We really don't know whether the other clusters is in\n\t\t\t * this refcount block or not, so just take the worst\n\t\t\t * case that all the clusters are in this block and each\n\t\t\t * one will split a refcount rec, so totally we need\n\t\t\t * clusters * 2 new refcount rec.\n\t\t\t */\n\t\t\tif (le16_to_cpu(rb->rf_records.rl_used) + clusters * 2 >\n\t\t\t    le16_to_cpu(rb->rf_records.rl_count))\n\t\t\t\tref_blocks++;\n\n\t\t\t*credits += 1;\n\t\t\tbrelse(ref_leaf_bh);\n\t\t\tref_leaf_bh = NULL;\n\n\t\t\tif (num_clusters <= le32_to_cpu(rec.r_clusters))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tnum_clusters -= le32_to_cpu(rec.r_clusters);\n\t\t\tp_cluster += num_clusters;\n\t\t}\n\t}\n\n\t*meta_add += ref_blocks;\n\tif (!ref_blocks)\n\t\tgoto out;\n\n\trb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\tif (le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL)\n\t\t*credits += OCFS2_EXPAND_REFCOUNT_TREE_CREDITS;\n\telse {\n\t\tstruct ocfs2_extent_tree et;\n\n\t\tocfs2_init_refcount_extent_tree(&et, ref_ci, ref_root_bh);\n\t\t*credits += ocfs2_calc_extend_credits(inode->i_sb,\n\t\t\t\t\t\t      et.et_root_el);\n\t}\n\nout:\n\tbrelse(ref_leaf_bh);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "ref_leaf_bh"
          ],
          "line": 3633
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_calc_extend_credits",
          "args": [
            "inode->i_sb",
            "et.et_root_el"
          ],
          "line": 3628
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_calc_extend_credits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "531-556",
          "snippet": "static inline int ocfs2_calc_extend_credits(struct super_block *sb,\n\t\t\t\t\t    struct ocfs2_extent_list *root_el)\n{\n\tint bitmap_blocks, sysfile_bitmap_blocks, extent_blocks;\n\n\t/* bitmap dinode, group desc. + relinked group. */\n\tbitmap_blocks = OCFS2_SUBALLOC_ALLOC;\n\n\t/* we might need to shift tree depth so lets assume an\n\t * absolute worst case of complete fragmentation.  Even with\n\t * that, we only need one update for the dinode, and then\n\t * however many metadata chunks needed * a remaining suballoc\n\t * alloc. */\n\tsysfile_bitmap_blocks = 1 +\n\t\t(OCFS2_SUBALLOC_ALLOC - 1) * ocfs2_extend_meta_needed(root_el);\n\n\t/* this does not include *new* metadata blocks, which are\n\t * accounted for in sysfile_bitmap_blocks. root_el +\n\t * prev. last_eb_blk + blocks along edge of tree.\n\t * calc_symlink_credits passes because we just need 1\n\t * credit for the dinode there. */\n\textent_blocks = 1 + 1 + le16_to_cpu(root_el->l_tree_depth);\n\n\treturn bitmap_blocks + sysfile_bitmap_blocks + extent_blocks +\n\t       ocfs2_quota_trans_credits(sb);\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_SUBALLOC_ALLOC (3)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\n#define OCFS2_SUBALLOC_ALLOC (3)\n\nstatic inline int ocfs2_calc_extend_credits(struct super_block *sb,\n\t\t\t\t\t    struct ocfs2_extent_list *root_el)\n{\n\tint bitmap_blocks, sysfile_bitmap_blocks, extent_blocks;\n\n\t/* bitmap dinode, group desc. + relinked group. */\n\tbitmap_blocks = OCFS2_SUBALLOC_ALLOC;\n\n\t/* we might need to shift tree depth so lets assume an\n\t * absolute worst case of complete fragmentation.  Even with\n\t * that, we only need one update for the dinode, and then\n\t * however many metadata chunks needed * a remaining suballoc\n\t * alloc. */\n\tsysfile_bitmap_blocks = 1 +\n\t\t(OCFS2_SUBALLOC_ALLOC - 1) * ocfs2_extend_meta_needed(root_el);\n\n\t/* this does not include *new* metadata blocks, which are\n\t * accounted for in sysfile_bitmap_blocks. root_el +\n\t * prev. last_eb_blk + blocks along edge of tree.\n\t * calc_symlink_credits passes because we just need 1\n\t * credit for the dinode there. */\n\textent_blocks = 1 + 1 + le16_to_cpu(root_el->l_tree_depth);\n\n\treturn bitmap_blocks + sysfile_bitmap_blocks + extent_blocks +\n\t       ocfs2_quota_trans_credits(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_init_refcount_extent_tree",
          "args": [
            "&et",
            "ref_ci",
            "ref_root_bh"
          ],
          "line": 3627
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_refcount_extent_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "490-496",
          "snippet": "void ocfs2_init_refcount_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_rb,\n\t\t\t\t NULL, &ocfs2_refcount_tree_et_ops);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static struct ocfs2_extent_tree_operations ocfs2_refcount_tree_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_refcount_tree_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_refcount_tree_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_refcount_tree_update_clusters,\n\t.eo_fill_root_el\t= ocfs2_refcount_tree_fill_root_el,\n\t.eo_extent_contig\t= ocfs2_refcount_tree_extent_contig,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic struct ocfs2_extent_tree_operations ocfs2_refcount_tree_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_refcount_tree_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_refcount_tree_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_refcount_tree_update_clusters,\n\t.eo_fill_root_el\t= ocfs2_refcount_tree_fill_root_el,\n\t.eo_extent_contig\t= ocfs2_refcount_tree_extent_contig,\n};\n\nvoid ocfs2_init_refcount_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_rb,\n\t\t\t\t NULL, &ocfs2_refcount_tree_et_ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rb->rf_flags"
          ],
          "line": 3622
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "rb->rf_records.rl_count"
          ],
          "line": 3602
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!rec.r_refcount"
          ],
          "line": 3590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_refcount_rec",
          "args": [
            "ref_ci",
            "ref_root_bh",
            "p_cluster",
            "num_clusters",
            "&rec",
            "&index",
            "&ref_leaf_bh"
          ],
          "line": 3581
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_get_refcount_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "1066-1150",
          "snippet": "static int ocfs2_get_refcount_rec(struct ocfs2_caching_info *ci,\n\t\t\t\t  struct buffer_head *ref_root_bh,\n\t\t\t\t  u64 cpos, unsigned int len,\n\t\t\t\t  struct ocfs2_refcount_rec *ret_rec,\n\t\t\t\t  int *index,\n\t\t\t\t  struct buffer_head **ret_bh)\n{\n\tint ret = 0, i, found;\n\tu32 low_cpos, uninitialized_var(cpos_end);\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec = NULL;\n\tstruct ocfs2_extent_block *eb = NULL;\n\tstruct buffer_head *eb_bh = NULL, *ref_leaf_bh = NULL;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\n\tstruct ocfs2_refcount_block *rb =\n\t\t\t(struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\n\tif (!(le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL)) {\n\t\tocfs2_find_refcount_rec_in_rl(ci, ref_root_bh, cpos, len,\n\t\t\t\t\t      ret_rec, index);\n\t\t*ret_bh = ref_root_bh;\n\t\tget_bh(ref_root_bh);\n\t\treturn 0;\n\t}\n\n\tel = &rb->rf_list;\n\tlow_cpos = cpos & OCFS2_32BIT_POS_MASK;\n\n\tif (el->l_tree_depth) {\n\t\tret = ocfs2_find_leaf(ci, el, low_cpos, &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tocfs2_error(sb,\n\t\t\t\"refcount tree %llu has non zero tree \"\n\t\t\t\"depth in leaf btree tree block %llu\\n\",\n\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t\t(unsigned long long)eb_bh->b_blocknr);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfound = 0;\n\tfor (i = le16_to_cpu(el->l_next_free_rec) - 1; i >= 0; i--) {\n\t\trec = &el->l_recs[i];\n\n\t\tif (le32_to_cpu(rec->e_cpos) <= low_cpos) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found) {\n\t\tret = ocfs2_get_refcount_cpos_end(ci, ref_root_bh,\n\t\t\t\t\t\t  eb, el, i, &cpos_end);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (cpos_end < low_cpos + len)\n\t\t\tlen = cpos_end - low_cpos;\n\t}\n\n\tret = ocfs2_read_refcount_block(ci, le64_to_cpu(rec->e_blkno),\n\t\t\t\t\t&ref_leaf_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_find_refcount_rec_in_rl(ci, ref_leaf_bh, cpos, len,\n\t\t\t\t      ret_rec, index);\n\t*ret_bh = ref_leaf_bh;\nout:\n\tbrelse(eb_bh);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_get_refcount_rec(struct ocfs2_caching_info *ci,\n\t\t\t\t  struct buffer_head *ref_root_bh,\n\t\t\t\t  u64 cpos, unsigned int len,\n\t\t\t\t  struct ocfs2_refcount_rec *ret_rec,\n\t\t\t\t  int *index,\n\t\t\t\t  struct buffer_head **ret_bh)\n{\n\tint ret = 0, i, found;\n\tu32 low_cpos, uninitialized_var(cpos_end);\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec = NULL;\n\tstruct ocfs2_extent_block *eb = NULL;\n\tstruct buffer_head *eb_bh = NULL, *ref_leaf_bh = NULL;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\n\tstruct ocfs2_refcount_block *rb =\n\t\t\t(struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\n\tif (!(le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL)) {\n\t\tocfs2_find_refcount_rec_in_rl(ci, ref_root_bh, cpos, len,\n\t\t\t\t\t      ret_rec, index);\n\t\t*ret_bh = ref_root_bh;\n\t\tget_bh(ref_root_bh);\n\t\treturn 0;\n\t}\n\n\tel = &rb->rf_list;\n\tlow_cpos = cpos & OCFS2_32BIT_POS_MASK;\n\n\tif (el->l_tree_depth) {\n\t\tret = ocfs2_find_leaf(ci, el, low_cpos, &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tocfs2_error(sb,\n\t\t\t\"refcount tree %llu has non zero tree \"\n\t\t\t\"depth in leaf btree tree block %llu\\n\",\n\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t\t(unsigned long long)eb_bh->b_blocknr);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfound = 0;\n\tfor (i = le16_to_cpu(el->l_next_free_rec) - 1; i >= 0; i--) {\n\t\trec = &el->l_recs[i];\n\n\t\tif (le32_to_cpu(rec->e_cpos) <= low_cpos) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found) {\n\t\tret = ocfs2_get_refcount_cpos_end(ci, ref_root_bh,\n\t\t\t\t\t\t  eb, el, i, &cpos_end);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (cpos_end < low_cpos + len)\n\t\t\tlen = cpos_end - low_cpos;\n\t}\n\n\tret = ocfs2_read_refcount_block(ci, le64_to_cpu(rec->e_blkno),\n\t\t\t\t\t&ref_leaf_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_find_refcount_rec_in_rl(ci, ref_leaf_bh, cpos, len,\n\t\t\t\t      ret_rec, index);\n\t*ret_bh = ref_leaf_bh;\nout:\n\tbrelse(eb_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_xattr_get_clusters",
          "args": [
            "inode",
            "cpos",
            "&p_cluster",
            "&num_clusters",
            "&xv->xr_list",
            "NULL"
          ],
          "line": 3570
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_get_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
          "lines": "543-606",
          "snippet": "int ocfs2_xattr_get_clusters(struct inode *inode, u32 v_cluster,\n\t\t\t     u32 *p_cluster, u32 *num_clusters,\n\t\t\t     struct ocfs2_extent_list *el,\n\t\t\t     unsigned int *extent_flags)\n{\n\tint ret = 0, i;\n\tstruct buffer_head *eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_rec *rec;\n\tu32 coff;\n\n\tif (el->l_tree_depth) {\n\t\tret = ocfs2_find_leaf(INODE_CACHE(inode), el, v_cluster,\n\t\t\t\t      &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tocfs2_error(inode->i_sb,\n\t\t\t\t    \"Inode %lu has non zero tree depth in \"\n\t\t\t\t    \"xattr leaf block %llu\\n\", inode->i_ino,\n\t\t\t\t    (unsigned long long)eb_bh->b_blocknr);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\ti = ocfs2_search_extent_list(el, v_cluster);\n\tif (i == -1) {\n\t\tret = -EROFS;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t} else {\n\t\trec = &el->l_recs[i];\n\t\tBUG_ON(v_cluster < le32_to_cpu(rec->e_cpos));\n\n\t\tif (!rec->e_blkno) {\n\t\t\tocfs2_error(inode->i_sb, \"Inode %lu has bad extent \"\n\t\t\t\t    \"record (%u, %u, 0) in xattr\", inode->i_ino,\n\t\t\t\t    le32_to_cpu(rec->e_cpos),\n\t\t\t\t    ocfs2_rec_clusters(el, rec));\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t\tcoff = v_cluster - le32_to_cpu(rec->e_cpos);\n\t\t*p_cluster = ocfs2_blocks_to_clusters(inode->i_sb,\n\t\t\t\t\t\t    le64_to_cpu(rec->e_blkno));\n\t\t*p_cluster = *p_cluster + coff;\n\t\tif (num_clusters)\n\t\t\t*num_clusters = ocfs2_rec_clusters(el, rec) - coff;\n\n\t\tif (extent_flags)\n\t\t\t*extent_flags = rec->e_flags;\n\t}\nout:\n\tif (eb_bh)\n\t\tbrelse(eb_bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nint ocfs2_xattr_get_clusters(struct inode *inode, u32 v_cluster,\n\t\t\t     u32 *p_cluster, u32 *num_clusters,\n\t\t\t     struct ocfs2_extent_list *el,\n\t\t\t     unsigned int *extent_flags)\n{\n\tint ret = 0, i;\n\tstruct buffer_head *eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_rec *rec;\n\tu32 coff;\n\n\tif (el->l_tree_depth) {\n\t\tret = ocfs2_find_leaf(INODE_CACHE(inode), el, v_cluster,\n\t\t\t\t      &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tocfs2_error(inode->i_sb,\n\t\t\t\t    \"Inode %lu has non zero tree depth in \"\n\t\t\t\t    \"xattr leaf block %llu\\n\", inode->i_ino,\n\t\t\t\t    (unsigned long long)eb_bh->b_blocknr);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\ti = ocfs2_search_extent_list(el, v_cluster);\n\tif (i == -1) {\n\t\tret = -EROFS;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t} else {\n\t\trec = &el->l_recs[i];\n\t\tBUG_ON(v_cluster < le32_to_cpu(rec->e_cpos));\n\n\t\tif (!rec->e_blkno) {\n\t\t\tocfs2_error(inode->i_sb, \"Inode %lu has bad extent \"\n\t\t\t\t    \"record (%u, %u, 0) in xattr\", inode->i_ino,\n\t\t\t\t    le32_to_cpu(rec->e_cpos),\n\t\t\t\t    ocfs2_rec_clusters(el, rec));\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t\tcoff = v_cluster - le32_to_cpu(rec->e_cpos);\n\t\t*p_cluster = ocfs2_blocks_to_clusters(inode->i_sb,\n\t\t\t\t\t\t    le64_to_cpu(rec->e_blkno));\n\t\t*p_cluster = *p_cluster + coff;\n\t\tif (num_clusters)\n\t\t\t*num_clusters = ocfs2_rec_clusters(el, rec) - coff;\n\n\t\tif (extent_flags)\n\t\t\t*extent_flags = rec->e_flags;\n\t}\nout:\n\tif (eb_bh)\n\t\tbrelse(eb_bh);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nint ocfs2_refcounted_xattr_delete_need(struct inode *inode,\n\t\t\t\t       struct ocfs2_caching_info *ref_ci,\n\t\t\t\t       struct buffer_head *ref_root_bh,\n\t\t\t\t       struct ocfs2_xattr_value_root *xv,\n\t\t\t\t       int *meta_add, int *credits)\n{\n\tint ret = 0, index, ref_blocks = 0;\n\tu32 p_cluster, num_clusters;\n\tu32 cpos = 0, clusters = le32_to_cpu(xv->xr_clusters);\n\tstruct ocfs2_refcount_block *rb;\n\tstruct ocfs2_refcount_rec rec;\n\tstruct buffer_head *ref_leaf_bh = NULL;\n\n\twhile (cpos < clusters) {\n\t\tret = ocfs2_xattr_get_clusters(inode, cpos, &p_cluster,\n\t\t\t\t\t       &num_clusters, &xv->xr_list,\n\t\t\t\t\t       NULL);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tcpos += num_clusters;\n\n\t\twhile (num_clusters) {\n\t\t\tret = ocfs2_get_refcount_rec(ref_ci, ref_root_bh,\n\t\t\t\t\t\t     p_cluster, num_clusters,\n\t\t\t\t\t\t     &rec, &index,\n\t\t\t\t\t\t     &ref_leaf_bh);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tBUG_ON(!rec.r_refcount);\n\n\t\t\trb = (struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\n\n\t\t\t/*\n\t\t\t * We really don't know whether the other clusters is in\n\t\t\t * this refcount block or not, so just take the worst\n\t\t\t * case that all the clusters are in this block and each\n\t\t\t * one will split a refcount rec, so totally we need\n\t\t\t * clusters * 2 new refcount rec.\n\t\t\t */\n\t\t\tif (le16_to_cpu(rb->rf_records.rl_used) + clusters * 2 >\n\t\t\t    le16_to_cpu(rb->rf_records.rl_count))\n\t\t\t\tref_blocks++;\n\n\t\t\t*credits += 1;\n\t\t\tbrelse(ref_leaf_bh);\n\t\t\tref_leaf_bh = NULL;\n\n\t\t\tif (num_clusters <= le32_to_cpu(rec.r_clusters))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tnum_clusters -= le32_to_cpu(rec.r_clusters);\n\t\t\tp_cluster += num_clusters;\n\t\t}\n\t}\n\n\t*meta_add += ref_blocks;\n\tif (!ref_blocks)\n\t\tgoto out;\n\n\trb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\tif (le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL)\n\t\t*credits += OCFS2_EXPAND_REFCOUNT_TREE_CREDITS;\n\telse {\n\t\tstruct ocfs2_extent_tree et;\n\n\t\tocfs2_init_refcount_extent_tree(&et, ref_ci, ref_root_bh);\n\t\t*credits += ocfs2_calc_extend_credits(inode->i_sb,\n\t\t\t\t\t\t      et.et_root_el);\n\t}\n\nout:\n\tbrelse(ref_leaf_bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_xattr_value_get_clusters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "3539-3550",
    "snippet": "static int ocfs2_xattr_value_get_clusters(struct ocfs2_cow_context *context,\n\t\t\t\t\t  u32 v_cluster, u32 *p_cluster,\n\t\t\t\t\t  u32 *num_clusters,\n\t\t\t\t\t  unsigned int *extent_flags)\n{\n\tstruct inode *inode = context->inode;\n\tstruct ocfs2_xattr_value_root *xv = context->cow_object;\n\n\treturn ocfs2_xattr_get_clusters(inode, v_cluster, p_cluster,\n\t\t\t\t\tnum_clusters, &xv->xr_list,\n\t\t\t\t\textent_flags);\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_xattr_get_clusters",
          "args": [
            "inode",
            "v_cluster",
            "p_cluster",
            "num_clusters",
            "&xv->xr_list",
            "extent_flags"
          ],
          "line": 3547
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_xattr_get_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
          "lines": "543-606",
          "snippet": "int ocfs2_xattr_get_clusters(struct inode *inode, u32 v_cluster,\n\t\t\t     u32 *p_cluster, u32 *num_clusters,\n\t\t\t     struct ocfs2_extent_list *el,\n\t\t\t     unsigned int *extent_flags)\n{\n\tint ret = 0, i;\n\tstruct buffer_head *eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_rec *rec;\n\tu32 coff;\n\n\tif (el->l_tree_depth) {\n\t\tret = ocfs2_find_leaf(INODE_CACHE(inode), el, v_cluster,\n\t\t\t\t      &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tocfs2_error(inode->i_sb,\n\t\t\t\t    \"Inode %lu has non zero tree depth in \"\n\t\t\t\t    \"xattr leaf block %llu\\n\", inode->i_ino,\n\t\t\t\t    (unsigned long long)eb_bh->b_blocknr);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\ti = ocfs2_search_extent_list(el, v_cluster);\n\tif (i == -1) {\n\t\tret = -EROFS;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t} else {\n\t\trec = &el->l_recs[i];\n\t\tBUG_ON(v_cluster < le32_to_cpu(rec->e_cpos));\n\n\t\tif (!rec->e_blkno) {\n\t\t\tocfs2_error(inode->i_sb, \"Inode %lu has bad extent \"\n\t\t\t\t    \"record (%u, %u, 0) in xattr\", inode->i_ino,\n\t\t\t\t    le32_to_cpu(rec->e_cpos),\n\t\t\t\t    ocfs2_rec_clusters(el, rec));\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t\tcoff = v_cluster - le32_to_cpu(rec->e_cpos);\n\t\t*p_cluster = ocfs2_blocks_to_clusters(inode->i_sb,\n\t\t\t\t\t\t    le64_to_cpu(rec->e_blkno));\n\t\t*p_cluster = *p_cluster + coff;\n\t\tif (num_clusters)\n\t\t\t*num_clusters = ocfs2_rec_clusters(el, rec) - coff;\n\n\t\tif (extent_flags)\n\t\t\t*extent_flags = rec->e_flags;\n\t}\nout:\n\tif (eb_bh)\n\t\tbrelse(eb_bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nint ocfs2_xattr_get_clusters(struct inode *inode, u32 v_cluster,\n\t\t\t     u32 *p_cluster, u32 *num_clusters,\n\t\t\t     struct ocfs2_extent_list *el,\n\t\t\t     unsigned int *extent_flags)\n{\n\tint ret = 0, i;\n\tstruct buffer_head *eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct ocfs2_extent_rec *rec;\n\tu32 coff;\n\n\tif (el->l_tree_depth) {\n\t\tret = ocfs2_find_leaf(INODE_CACHE(inode), el, v_cluster,\n\t\t\t\t      &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tocfs2_error(inode->i_sb,\n\t\t\t\t    \"Inode %lu has non zero tree depth in \"\n\t\t\t\t    \"xattr leaf block %llu\\n\", inode->i_ino,\n\t\t\t\t    (unsigned long long)eb_bh->b_blocknr);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\ti = ocfs2_search_extent_list(el, v_cluster);\n\tif (i == -1) {\n\t\tret = -EROFS;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t} else {\n\t\trec = &el->l_recs[i];\n\t\tBUG_ON(v_cluster < le32_to_cpu(rec->e_cpos));\n\n\t\tif (!rec->e_blkno) {\n\t\t\tocfs2_error(inode->i_sb, \"Inode %lu has bad extent \"\n\t\t\t\t    \"record (%u, %u, 0) in xattr\", inode->i_ino,\n\t\t\t\t    le32_to_cpu(rec->e_cpos),\n\t\t\t\t    ocfs2_rec_clusters(el, rec));\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t\tcoff = v_cluster - le32_to_cpu(rec->e_cpos);\n\t\t*p_cluster = ocfs2_blocks_to_clusters(inode->i_sb,\n\t\t\t\t\t\t    le64_to_cpu(rec->e_blkno));\n\t\t*p_cluster = *p_cluster + coff;\n\t\tif (num_clusters)\n\t\t\t*num_clusters = ocfs2_rec_clusters(el, rec) - coff;\n\n\t\tif (extent_flags)\n\t\t\t*extent_flags = rec->e_flags;\n\t}\nout:\n\tif (eb_bh)\n\t\tbrelse(eb_bh);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_xattr_value_get_clusters(struct ocfs2_cow_context *context,\n\t\t\t\t\t  u32 v_cluster, u32 *p_cluster,\n\t\t\t\t\t  u32 *num_clusters,\n\t\t\t\t\t  unsigned int *extent_flags)\n{\n\tstruct inode *inode = context->inode;\n\tstruct ocfs2_xattr_value_root *xv = context->cow_object;\n\n\treturn ocfs2_xattr_get_clusters(inode, v_cluster, p_cluster,\n\t\t\t\t\tnum_clusters, &xv->xr_list,\n\t\t\t\t\textent_flags);\n}"
  },
  {
    "function_name": "ocfs2_refcount_cow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "3504-3537",
    "snippet": "int ocfs2_refcount_cow(struct inode *inode,\n\t\t       struct buffer_head *di_bh,\n\t\t       u32 cpos, u32 write_len, u32 max_cpos)\n{\n\tint ret = 0;\n\tu32 p_cluster, num_clusters;\n\tunsigned int ext_flags;\n\n\twhile (write_len) {\n\t\tret = ocfs2_get_clusters(inode, cpos, &p_cluster,\n\t\t\t\t\t &num_clusters, &ext_flags);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (write_len < num_clusters)\n\t\t\tnum_clusters = write_len;\n\n\t\tif (ext_flags & OCFS2_EXT_REFCOUNTED) {\n\t\t\tret = ocfs2_refcount_cow_hunk(inode, di_bh, cpos,\n\t\t\t\t\t\t      num_clusters, max_cpos);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\twrite_len -= num_clusters;\n\t\tcpos += num_clusters;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_refcount_cow_hunk",
          "args": [
            "inode",
            "di_bh",
            "cpos",
            "num_clusters",
            "max_cpos"
          ],
          "line": 3524
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_refcount_cow_hunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "3427-3497",
          "snippet": "static int ocfs2_refcount_cow_hunk(struct inode *inode,\n\t\t\t\t   struct buffer_head *di_bh,\n\t\t\t\t   u32 cpos, u32 write_len, u32 max_cpos)\n{\n\tint ret;\n\tu32 cow_start = 0, cow_len = 0;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_tree *ref_tree;\n\tstruct ocfs2_cow_context *context = NULL;\n\n\tBUG_ON(!(oi->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL));\n\n\tret = ocfs2_refcount_cal_cow_clusters(inode, &di->id2.i_list,\n\t\t\t\t\t      cpos, write_len, max_cpos,\n\t\t\t\t\t      &cow_start, &cow_len);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_refcount_cow_hunk(OCFS2_I(inode)->ip_blkno,\n\t\t\t\t      cpos, write_len, max_cpos,\n\t\t\t\t      cow_start, cow_len);\n\n\tBUG_ON(cow_len == 0);\n\n\tcontext = kzalloc(sizeof(struct ocfs2_cow_context), GFP_NOFS);\n\tif (!context) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_lock_refcount_tree(osb, le64_to_cpu(di->i_refcount_loc),\n\t\t\t\t       1, &ref_tree, &ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tcontext->inode = inode;\n\tcontext->cow_start = cow_start;\n\tcontext->cow_len = cow_len;\n\tcontext->ref_tree = ref_tree;\n\tcontext->ref_root_bh = ref_root_bh;\n\tcontext->cow_duplicate_clusters = ocfs2_duplicate_clusters_by_page;\n\tcontext->get_clusters = ocfs2_di_get_clusters;\n\n\tocfs2_init_dinode_extent_tree(&context->data_et,\n\t\t\t\t      INODE_CACHE(inode), di_bh);\n\n\tret = ocfs2_replace_cow(context);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\t/*\n\t * truncate the extent map here since no matter whether we meet with\n\t * any error during the action, we shouldn't trust cached extent map\n\t * any more.\n\t */\n\tocfs2_extent_map_trunc(inode, cow_start);\n\n\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\tbrelse(ref_root_bh);\nout:\n\tkfree(context);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_refcount_cow_hunk(struct inode *inode,\n\t\t\t\t   struct buffer_head *di_bh,\n\t\t\t\t   u32 cpos, u32 write_len, u32 max_cpos)\n{\n\tint ret;\n\tu32 cow_start = 0, cow_len = 0;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_tree *ref_tree;\n\tstruct ocfs2_cow_context *context = NULL;\n\n\tBUG_ON(!(oi->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL));\n\n\tret = ocfs2_refcount_cal_cow_clusters(inode, &di->id2.i_list,\n\t\t\t\t\t      cpos, write_len, max_cpos,\n\t\t\t\t\t      &cow_start, &cow_len);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_refcount_cow_hunk(OCFS2_I(inode)->ip_blkno,\n\t\t\t\t      cpos, write_len, max_cpos,\n\t\t\t\t      cow_start, cow_len);\n\n\tBUG_ON(cow_len == 0);\n\n\tcontext = kzalloc(sizeof(struct ocfs2_cow_context), GFP_NOFS);\n\tif (!context) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_lock_refcount_tree(osb, le64_to_cpu(di->i_refcount_loc),\n\t\t\t\t       1, &ref_tree, &ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tcontext->inode = inode;\n\tcontext->cow_start = cow_start;\n\tcontext->cow_len = cow_len;\n\tcontext->ref_tree = ref_tree;\n\tcontext->ref_root_bh = ref_root_bh;\n\tcontext->cow_duplicate_clusters = ocfs2_duplicate_clusters_by_page;\n\tcontext->get_clusters = ocfs2_di_get_clusters;\n\n\tocfs2_init_dinode_extent_tree(&context->data_et,\n\t\t\t\t      INODE_CACHE(inode), di_bh);\n\n\tret = ocfs2_replace_cow(context);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\t/*\n\t * truncate the extent map here since no matter whether we meet with\n\t * any error during the action, we shouldn't trust cached extent map\n\t * any more.\n\t */\n\tocfs2_extent_map_trunc(inode, cow_start);\n\n\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\tbrelse(ref_root_bh);\nout:\n\tkfree(context);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_clusters",
          "args": [
            "inode",
            "cpos",
            "&p_cluster",
            "&num_clusters",
            "&ext_flags"
          ],
          "line": 3513
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_get_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
          "lines": "608-665",
          "snippet": "int ocfs2_get_clusters(struct inode *inode, u32 v_cluster,\n\t\t       u32 *p_cluster, u32 *num_clusters,\n\t\t       unsigned int *extent_flags)\n{\n\tint ret;\n\tunsigned int uninitialized_var(hole_len), flags = 0;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_extent_rec rec;\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tret = -ERANGE;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_extent_map_lookup(inode, v_cluster, p_cluster,\n\t\t\t\t      num_clusters, extent_flags);\n\tif (ret == 0)\n\t\tgoto out;\n\n\tret = ocfs2_read_inode_block(inode, &di_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_get_clusters_nocache(inode, di_bh, v_cluster, &hole_len,\n\t\t\t\t\t &rec, NULL);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (rec.e_blkno == 0ULL) {\n\t\t/*\n\t\t * A hole was found. Return some canned values that\n\t\t * callers can key on. If asked for, num_clusters will\n\t\t * be populated with the size of the hole.\n\t\t */\n\t\t*p_cluster = 0;\n\t\tif (num_clusters) {\n\t\t\t*num_clusters = hole_len;\n\t\t}\n\t} else {\n\t\tocfs2_relative_extent_offsets(inode->i_sb, v_cluster, &rec,\n\t\t\t\t\t      p_cluster, num_clusters);\n\t\tflags = rec.e_flags;\n\n\t\tocfs2_extent_map_insert_rec(inode, &rec);\n\t}\n\n\tif (extent_flags)\n\t\t*extent_flags = flags;\n\nout:\n\tbrelse(di_bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nint ocfs2_get_clusters(struct inode *inode, u32 v_cluster,\n\t\t       u32 *p_cluster, u32 *num_clusters,\n\t\t       unsigned int *extent_flags)\n{\n\tint ret;\n\tunsigned int uninitialized_var(hole_len), flags = 0;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_extent_rec rec;\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tret = -ERANGE;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_extent_map_lookup(inode, v_cluster, p_cluster,\n\t\t\t\t      num_clusters, extent_flags);\n\tif (ret == 0)\n\t\tgoto out;\n\n\tret = ocfs2_read_inode_block(inode, &di_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_get_clusters_nocache(inode, di_bh, v_cluster, &hole_len,\n\t\t\t\t\t &rec, NULL);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (rec.e_blkno == 0ULL) {\n\t\t/*\n\t\t * A hole was found. Return some canned values that\n\t\t * callers can key on. If asked for, num_clusters will\n\t\t * be populated with the size of the hole.\n\t\t */\n\t\t*p_cluster = 0;\n\t\tif (num_clusters) {\n\t\t\t*num_clusters = hole_len;\n\t\t}\n\t} else {\n\t\tocfs2_relative_extent_offsets(inode->i_sb, v_cluster, &rec,\n\t\t\t\t\t      p_cluster, num_clusters);\n\t\tflags = rec.e_flags;\n\n\t\tocfs2_extent_map_insert_rec(inode, &rec);\n\t}\n\n\tif (extent_flags)\n\t\t*extent_flags = flags;\n\nout:\n\tbrelse(di_bh);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nint ocfs2_refcount_cow(struct inode *inode,\n\t\t       struct buffer_head *di_bh,\n\t\t       u32 cpos, u32 write_len, u32 max_cpos)\n{\n\tint ret = 0;\n\tu32 p_cluster, num_clusters;\n\tunsigned int ext_flags;\n\n\twhile (write_len) {\n\t\tret = ocfs2_get_clusters(inode, cpos, &p_cluster,\n\t\t\t\t\t &num_clusters, &ext_flags);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (write_len < num_clusters)\n\t\t\tnum_clusters = write_len;\n\n\t\tif (ext_flags & OCFS2_EXT_REFCOUNTED) {\n\t\t\tret = ocfs2_refcount_cow_hunk(inode, di_bh, cpos,\n\t\t\t\t\t\t      num_clusters, max_cpos);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\twrite_len -= num_clusters;\n\t\tcpos += num_clusters;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_refcount_cow_hunk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "3427-3497",
    "snippet": "static int ocfs2_refcount_cow_hunk(struct inode *inode,\n\t\t\t\t   struct buffer_head *di_bh,\n\t\t\t\t   u32 cpos, u32 write_len, u32 max_cpos)\n{\n\tint ret;\n\tu32 cow_start = 0, cow_len = 0;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_tree *ref_tree;\n\tstruct ocfs2_cow_context *context = NULL;\n\n\tBUG_ON(!(oi->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL));\n\n\tret = ocfs2_refcount_cal_cow_clusters(inode, &di->id2.i_list,\n\t\t\t\t\t      cpos, write_len, max_cpos,\n\t\t\t\t\t      &cow_start, &cow_len);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_refcount_cow_hunk(OCFS2_I(inode)->ip_blkno,\n\t\t\t\t      cpos, write_len, max_cpos,\n\t\t\t\t      cow_start, cow_len);\n\n\tBUG_ON(cow_len == 0);\n\n\tcontext = kzalloc(sizeof(struct ocfs2_cow_context), GFP_NOFS);\n\tif (!context) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_lock_refcount_tree(osb, le64_to_cpu(di->i_refcount_loc),\n\t\t\t\t       1, &ref_tree, &ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tcontext->inode = inode;\n\tcontext->cow_start = cow_start;\n\tcontext->cow_len = cow_len;\n\tcontext->ref_tree = ref_tree;\n\tcontext->ref_root_bh = ref_root_bh;\n\tcontext->cow_duplicate_clusters = ocfs2_duplicate_clusters_by_page;\n\tcontext->get_clusters = ocfs2_di_get_clusters;\n\n\tocfs2_init_dinode_extent_tree(&context->data_et,\n\t\t\t\t      INODE_CACHE(inode), di_bh);\n\n\tret = ocfs2_replace_cow(context);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\t/*\n\t * truncate the extent map here since no matter whether we meet with\n\t * any error during the action, we shouldn't trust cached extent map\n\t * any more.\n\t */\n\tocfs2_extent_map_trunc(inode, cow_start);\n\n\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\tbrelse(ref_root_bh);\nout:\n\tkfree(context);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "context"
          ],
          "line": 3495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "ref_root_bh"
          ],
          "line": 3493
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_unlock_refcount_tree",
          "args": [
            "osb",
            "ref_tree",
            "1"
          ],
          "line": 3492
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_refcount_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "526-536",
          "snippet": "void ocfs2_unlock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_refcount_tree *tree, int rw)\n{\n\tif (rw)\n\t\tup_write(&tree->rf_sem);\n\telse\n\t\tup_read(&tree->rf_sem);\n\n\tocfs2_refcount_unlock(tree, rw);\n\tocfs2_refcount_tree_put(tree);\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nvoid ocfs2_unlock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_refcount_tree *tree, int rw)\n{\n\tif (rw)\n\t\tup_write(&tree->rf_sem);\n\telse\n\t\tup_read(&tree->rf_sem);\n\n\tocfs2_refcount_unlock(tree, rw);\n\tocfs2_refcount_tree_put(tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_extent_map_trunc",
          "args": [
            "inode",
            "cow_start"
          ],
          "line": 3490
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extent_map_trunc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
          "lines": "114-144",
          "snippet": "void ocfs2_extent_map_trunc(struct inode *inode, unsigned int cpos)\n{\n\tstruct ocfs2_extent_map_item *emi, *n;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_extent_map *em = &oi->ip_extent_map;\n\tLIST_HEAD(tmp_list);\n\tunsigned int range;\n\n\tspin_lock(&oi->ip_lock);\n\tlist_for_each_entry_safe(emi, n, &em->em_list, ei_list) {\n\t\tif (emi->ei_cpos >= cpos) {\n\t\t\t/* Full truncate of this record. */\n\t\t\tlist_move(&emi->ei_list, &tmp_list);\n\t\t\tBUG_ON(em->em_num_items == 0);\n\t\t\tem->em_num_items--;\n\t\t\tcontinue;\n\t\t}\n\n\t\trange = emi->ei_cpos + emi->ei_clusters;\n\t\tif (range > cpos) {\n\t\t\t/* Partial truncate */\n\t\t\temi->ei_clusters = cpos - emi->ei_cpos;\n\t\t}\n\t}\n\tspin_unlock(&oi->ip_lock);\n\n\tlist_for_each_entry_safe(emi, n, &tmp_list, ei_list) {\n\t\tlist_del(&emi->ei_list);\n\t\tkfree(emi);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nvoid ocfs2_extent_map_trunc(struct inode *inode, unsigned int cpos)\n{\n\tstruct ocfs2_extent_map_item *emi, *n;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_extent_map *em = &oi->ip_extent_map;\n\tLIST_HEAD(tmp_list);\n\tunsigned int range;\n\n\tspin_lock(&oi->ip_lock);\n\tlist_for_each_entry_safe(emi, n, &em->em_list, ei_list) {\n\t\tif (emi->ei_cpos >= cpos) {\n\t\t\t/* Full truncate of this record. */\n\t\t\tlist_move(&emi->ei_list, &tmp_list);\n\t\t\tBUG_ON(em->em_num_items == 0);\n\t\t\tem->em_num_items--;\n\t\t\tcontinue;\n\t\t}\n\n\t\trange = emi->ei_cpos + emi->ei_clusters;\n\t\tif (range > cpos) {\n\t\t\t/* Partial truncate */\n\t\t\temi->ei_clusters = cpos - emi->ei_cpos;\n\t\t}\n\t}\n\tspin_unlock(&oi->ip_lock);\n\n\tlist_for_each_entry_safe(emi, n, &tmp_list, ei_list) {\n\t\tlist_del(&emi->ei_list);\n\t\tkfree(emi);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_replace_cow",
          "args": [
            "context"
          ],
          "line": 3481
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_replace_cow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "3371-3420",
          "snippet": "static int ocfs2_replace_cow(struct ocfs2_cow_context *context)\n{\n\tint ret = 0;\n\tstruct inode *inode = context->inode;\n\tu32 cow_start = context->cow_start, cow_len = context->cow_len;\n\tu32 p_cluster, num_clusters;\n\tunsigned int ext_flags;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (!ocfs2_refcount_tree(OCFS2_SB(inode->i_sb))) {\n\t\tocfs2_error(inode->i_sb, \"Inode %lu want to use refcount \"\n\t\t\t    \"tree, but the feature bit is not set in the \"\n\t\t\t    \"super block.\", inode->i_ino);\n\t\treturn -EROFS;\n\t}\n\n\tocfs2_init_dealloc_ctxt(&context->dealloc);\n\n\twhile (cow_len) {\n\t\tret = context->get_clusters(context, cow_start, &p_cluster,\n\t\t\t\t\t    &num_clusters, &ext_flags);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tBUG_ON(!(ext_flags & OCFS2_EXT_REFCOUNTED));\n\n\t\tif (cow_len < num_clusters)\n\t\t\tnum_clusters = cow_len;\n\n\t\tret = ocfs2_make_clusters_writable(inode->i_sb, context,\n\t\t\t\t\t\t   cow_start, p_cluster,\n\t\t\t\t\t\t   num_clusters, ext_flags);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tcow_len -= num_clusters;\n\t\tcow_start += num_clusters;\n\t}\n\n\tif (ocfs2_dealloc_has_cluster(&context->dealloc)) {\n\t\tocfs2_schedule_truncate_log_flush(osb, 1);\n\t\tocfs2_run_deallocs(osb, &context->dealloc);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_replace_cow(struct ocfs2_cow_context *context)\n{\n\tint ret = 0;\n\tstruct inode *inode = context->inode;\n\tu32 cow_start = context->cow_start, cow_len = context->cow_len;\n\tu32 p_cluster, num_clusters;\n\tunsigned int ext_flags;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (!ocfs2_refcount_tree(OCFS2_SB(inode->i_sb))) {\n\t\tocfs2_error(inode->i_sb, \"Inode %lu want to use refcount \"\n\t\t\t    \"tree, but the feature bit is not set in the \"\n\t\t\t    \"super block.\", inode->i_ino);\n\t\treturn -EROFS;\n\t}\n\n\tocfs2_init_dealloc_ctxt(&context->dealloc);\n\n\twhile (cow_len) {\n\t\tret = context->get_clusters(context, cow_start, &p_cluster,\n\t\t\t\t\t    &num_clusters, &ext_flags);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tBUG_ON(!(ext_flags & OCFS2_EXT_REFCOUNTED));\n\n\t\tif (cow_len < num_clusters)\n\t\t\tnum_clusters = cow_len;\n\n\t\tret = ocfs2_make_clusters_writable(inode->i_sb, context,\n\t\t\t\t\t\t   cow_start, p_cluster,\n\t\t\t\t\t\t   num_clusters, ext_flags);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tcow_len -= num_clusters;\n\t\tcow_start += num_clusters;\n\t}\n\n\tif (ocfs2_dealloc_has_cluster(&context->dealloc)) {\n\t\tocfs2_schedule_truncate_log_flush(osb, 1);\n\t\tocfs2_run_deallocs(osb, &context->dealloc);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_init_dinode_extent_tree",
          "args": [
            "&context->data_et",
            "INODE_CACHE(inode)",
            "di_bh"
          ],
          "line": 3478
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_dinode_extent_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "458-464",
          "snippet": "void ocfs2_init_dinode_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t   struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_di,\n\t\t\t\t NULL, &ocfs2_dinode_et_ops);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static struct ocfs2_extent_tree_operations ocfs2_dinode_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_dinode_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_dinode_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_dinode_update_clusters,\n\t.eo_extent_map_insert\t= ocfs2_dinode_extent_map_insert,\n\t.eo_extent_map_truncate\t= ocfs2_dinode_extent_map_truncate,\n\t.eo_insert_check\t= ocfs2_dinode_insert_check,\n\t.eo_sanity_check\t= ocfs2_dinode_sanity_check,\n\t.eo_fill_root_el\t= ocfs2_dinode_fill_root_el,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic struct ocfs2_extent_tree_operations ocfs2_dinode_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_dinode_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_dinode_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_dinode_update_clusters,\n\t.eo_extent_map_insert\t= ocfs2_dinode_extent_map_insert,\n\t.eo_extent_map_truncate\t= ocfs2_dinode_extent_map_truncate,\n\t.eo_insert_check\t= ocfs2_dinode_insert_check,\n\t.eo_sanity_check\t= ocfs2_dinode_sanity_check,\n\t.eo_fill_root_el\t= ocfs2_dinode_fill_root_el,\n};\n\nvoid ocfs2_init_dinode_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t   struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_di,\n\t\t\t\t NULL, &ocfs2_dinode_et_ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 3479
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_lock_refcount_tree",
          "args": [
            "osb",
            "le64_to_cpu(di->i_refcount_loc)",
            "1",
            "&ref_tree",
            "&ref_root_bh"
          ],
          "line": 3463
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_refcount_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "452-524",
          "snippet": "int ocfs2_lock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t     u64 ref_blkno, int rw,\n\t\t\t     struct ocfs2_refcount_tree **ret_tree,\n\t\t\t     struct buffer_head **ref_bh)\n{\n\tint ret, delete_tree = 0;\n\tstruct ocfs2_refcount_tree *tree = NULL;\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_block *rb;\n\nagain:\n\tret = ocfs2_get_refcount_tree(osb, ref_blkno, &tree);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tocfs2_refcount_tree_get(tree);\n\n\tret = __ocfs2_lock_refcount_tree(osb, tree, rw);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_refcount_tree_put(tree);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_refcount_block(&tree->rf_ci, tree->rf_blkno,\n\t\t\t\t\t&ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_unlock_refcount_tree(osb, tree, rw);\n\t\tocfs2_refcount_tree_put(tree);\n\t\tgoto out;\n\t}\n\n\trb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\t/*\n\t * If the refcount block has been freed and re-created, we may need\n\t * to recreate the refcount tree also.\n\t *\n\t * Here we just remove the tree from the rb-tree, and the last\n\t * kref holder will unlock and delete this refcount_tree.\n\t * Then we goto \"again\" and ocfs2_get_refcount_tree will create\n\t * the new refcount tree for us.\n\t */\n\tif (tree->rf_generation != le32_to_cpu(rb->rf_generation)) {\n\t\tif (!tree->rf_removed) {\n\t\t\tocfs2_erase_refcount_tree_from_list(osb, tree);\n\t\t\ttree->rf_removed = 1;\n\t\t\tdelete_tree = 1;\n\t\t}\n\n\t\tocfs2_unlock_refcount_tree(osb, tree, rw);\n\t\t/*\n\t\t * We get an extra reference when we create the refcount\n\t\t * tree, so another put will destroy it.\n\t\t */\n\t\tif (delete_tree)\n\t\t\tocfs2_refcount_tree_put(tree);\n\t\tbrelse(ref_root_bh);\n\t\tref_root_bh = NULL;\n\t\tgoto again;\n\t}\n\n\t*ret_tree = tree;\n\tif (ref_bh) {\n\t\t*ref_bh = ref_root_bh;\n\t\tref_root_bh = NULL;\n\t}\nout:\n\tbrelse(ref_root_bh);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nint ocfs2_lock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t     u64 ref_blkno, int rw,\n\t\t\t     struct ocfs2_refcount_tree **ret_tree,\n\t\t\t     struct buffer_head **ref_bh)\n{\n\tint ret, delete_tree = 0;\n\tstruct ocfs2_refcount_tree *tree = NULL;\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_block *rb;\n\nagain:\n\tret = ocfs2_get_refcount_tree(osb, ref_blkno, &tree);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tocfs2_refcount_tree_get(tree);\n\n\tret = __ocfs2_lock_refcount_tree(osb, tree, rw);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_refcount_tree_put(tree);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_refcount_block(&tree->rf_ci, tree->rf_blkno,\n\t\t\t\t\t&ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_unlock_refcount_tree(osb, tree, rw);\n\t\tocfs2_refcount_tree_put(tree);\n\t\tgoto out;\n\t}\n\n\trb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\t/*\n\t * If the refcount block has been freed and re-created, we may need\n\t * to recreate the refcount tree also.\n\t *\n\t * Here we just remove the tree from the rb-tree, and the last\n\t * kref holder will unlock and delete this refcount_tree.\n\t * Then we goto \"again\" and ocfs2_get_refcount_tree will create\n\t * the new refcount tree for us.\n\t */\n\tif (tree->rf_generation != le32_to_cpu(rb->rf_generation)) {\n\t\tif (!tree->rf_removed) {\n\t\t\tocfs2_erase_refcount_tree_from_list(osb, tree);\n\t\t\ttree->rf_removed = 1;\n\t\t\tdelete_tree = 1;\n\t\t}\n\n\t\tocfs2_unlock_refcount_tree(osb, tree, rw);\n\t\t/*\n\t\t * We get an extra reference when we create the refcount\n\t\t * tree, so another put will destroy it.\n\t\t */\n\t\tif (delete_tree)\n\t\t\tocfs2_refcount_tree_put(tree);\n\t\tbrelse(ref_root_bh);\n\t\tref_root_bh = NULL;\n\t\tgoto again;\n\t}\n\n\t*ret_tree = tree;\n\tif (ref_bh) {\n\t\t*ref_bh = ref_root_bh;\n\t\tref_root_bh = NULL;\n\t}\nout:\n\tbrelse(ref_root_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "di->i_refcount_loc"
          ],
          "line": 3463
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct ocfs2_cow_context)",
            "GFP_NOFS"
          ],
          "line": 3456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "cow_len == 0"
          ],
          "line": 3454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_refcount_cow_hunk",
          "args": [
            "OCFS2_I(inode)->ip_blkno",
            "cpos",
            "write_len",
            "max_cpos",
            "cow_start",
            "cow_len"
          ],
          "line": 3450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 3450
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_refcount_cal_cow_clusters",
          "args": [
            "inode",
            "&di->id2.i_list",
            "cpos",
            "write_len",
            "max_cpos",
            "&cow_start",
            "&cow_len"
          ],
          "line": 3442
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_refcount_cal_cow_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "2647-2844",
          "snippet": "static int ocfs2_refcount_cal_cow_clusters(struct inode *inode,\n\t\t\t\t\t   struct ocfs2_extent_list *el,\n\t\t\t\t\t   u32 cpos,\n\t\t\t\t\t   u32 write_len,\n\t\t\t\t\t   u32 max_cpos,\n\t\t\t\t\t   u32 *cow_start,\n\t\t\t\t\t   u32 *cow_len)\n{\n\tint ret = 0;\n\tint tree_height = le16_to_cpu(el->l_tree_depth), i;\n\tstruct buffer_head *eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb = NULL;\n\tstruct ocfs2_extent_rec *rec;\n\tunsigned int want_clusters, rec_end = 0;\n\tint contig_clusters = ocfs2_cow_contig_clusters(inode->i_sb);\n\tint leaf_clusters;\n\n\tBUG_ON(cpos + write_len > max_cpos);\n\n\tif (tree_height > 0) {\n\t\tret = ocfs2_find_leaf(INODE_CACHE(inode), el, cpos, &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tocfs2_error(inode->i_sb,\n\t\t\t\t    \"Inode %lu has non zero tree depth in \"\n\t\t\t\t    \"leaf block %llu\\n\", inode->i_ino,\n\t\t\t\t    (unsigned long long)eb_bh->b_blocknr);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t*cow_len = 0;\n\tfor (i = 0; i < le16_to_cpu(el->l_next_free_rec); i++) {\n\t\trec = &el->l_recs[i];\n\n\t\tif (ocfs2_is_empty_extent(rec)) {\n\t\t\tmlog_bug_on_msg(i != 0, \"Inode %lu has empty record in \"\n\t\t\t\t\t\"index %d\\n\", inode->i_ino, i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (le32_to_cpu(rec->e_cpos) +\n\t\t    le16_to_cpu(rec->e_leaf_clusters) <= cpos)\n\t\t\tcontinue;\n\n\t\tif (*cow_len == 0) {\n\t\t\t/*\n\t\t\t * We should find a refcounted record in the\n\t\t\t * first pass.\n\t\t\t */\n\t\t\tBUG_ON(!(rec->e_flags & OCFS2_EXT_REFCOUNTED));\n\t\t\t*cow_start = le32_to_cpu(rec->e_cpos);\n\t\t}\n\n\t\t/*\n\t\t * If we encounter a hole, a non-refcounted record or\n\t\t * pass the max_cpos, stop the search.\n\t\t */\n\t\tif ((!(rec->e_flags & OCFS2_EXT_REFCOUNTED)) ||\n\t\t    (*cow_len && rec_end != le32_to_cpu(rec->e_cpos)) ||\n\t\t    (max_cpos <= le32_to_cpu(rec->e_cpos)))\n\t\t\tbreak;\n\n\t\tleaf_clusters = le16_to_cpu(rec->e_leaf_clusters);\n\t\trec_end = le32_to_cpu(rec->e_cpos) + leaf_clusters;\n\t\tif (rec_end > max_cpos) {\n\t\t\trec_end = max_cpos;\n\t\t\tleaf_clusters = rec_end - le32_to_cpu(rec->e_cpos);\n\t\t}\n\n\t\t/*\n\t\t * How many clusters do we actually need from\n\t\t * this extent?  First we see how many we actually\n\t\t * need to complete the write.  If that's smaller\n\t\t * than contig_clusters, we try for contig_clusters.\n\t\t */\n\t\tif (!*cow_len)\n\t\t\twant_clusters = write_len;\n\t\telse\n\t\t\twant_clusters = (cpos + write_len) -\n\t\t\t\t(*cow_start + *cow_len);\n\t\tif (want_clusters < contig_clusters)\n\t\t\twant_clusters = contig_clusters;\n\n\t\t/*\n\t\t * If the write does not cover the whole extent, we\n\t\t * need to calculate how we're going to split the extent.\n\t\t * We try to do it on contig_clusters boundaries.\n\t\t *\n\t\t * Any extent smaller than contig_clusters will be\n\t\t * CoWed in its entirety.\n\t\t */\n\t\tif (leaf_clusters <= contig_clusters)\n\t\t\t*cow_len += leaf_clusters;\n\t\telse if (*cow_len || (*cow_start == cpos)) {\n\t\t\t/*\n\t\t\t * This extent needs to be CoW'd from its\n\t\t\t * beginning, so all we have to do is compute\n\t\t\t * how many clusters to grab.  We align\n\t\t\t * want_clusters to the edge of contig_clusters\n\t\t\t * to get better I/O.\n\t\t\t */\n\t\t\twant_clusters = ocfs2_cow_align_length(inode->i_sb,\n\t\t\t\t\t\t\t       want_clusters);\n\n\t\t\tif (leaf_clusters < want_clusters)\n\t\t\t\t*cow_len += leaf_clusters;\n\t\t\telse\n\t\t\t\t*cow_len += want_clusters;\n\t\t} else if ((*cow_start + contig_clusters) >=\n\t\t\t   (cpos + write_len)) {\n\t\t\t/*\n\t\t\t * Breaking off contig_clusters at the front\n\t\t\t * of the extent will cover our write.  That's\n\t\t\t * easy.\n\t\t\t */\n\t\t\t*cow_len = contig_clusters;\n\t\t} else if ((rec_end - cpos) <= contig_clusters) {\n\t\t\t/*\n\t\t\t * Breaking off contig_clusters at the tail of\n\t\t\t * this extent will cover cpos.\n\t\t\t */\n\t\t\t*cow_start = rec_end - contig_clusters;\n\t\t\t*cow_len = contig_clusters;\n\t\t} else if ((rec_end - cpos) <= want_clusters) {\n\t\t\t/*\n\t\t\t * While we can't fit the entire write in this\n\t\t\t * extent, we know that the write goes from cpos\n\t\t\t * to the end of the extent.  Break that off.\n\t\t\t * We try to break it at some multiple of\n\t\t\t * contig_clusters from the front of the extent.\n\t\t\t * Failing that (ie, cpos is within\n\t\t\t * contig_clusters of the front), we'll CoW the\n\t\t\t * entire extent.\n\t\t\t */\n\t\t\t*cow_start = ocfs2_cow_align_start(inode->i_sb,\n\t\t\t\t\t\t\t   *cow_start, cpos);\n\t\t\t*cow_len = rec_end - *cow_start;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Ok, the entire write lives in the middle of\n\t\t\t * this extent.  Let's try to slice the extent up\n\t\t\t * nicely.  Optimally, our CoW region starts at\n\t\t\t * m*contig_clusters from the beginning of the\n\t\t\t * extent and goes for n*contig_clusters,\n\t\t\t * covering the entire write.\n\t\t\t */\n\t\t\t*cow_start = ocfs2_cow_align_start(inode->i_sb,\n\t\t\t\t\t\t\t   *cow_start, cpos);\n\n\t\t\twant_clusters = (cpos + write_len) - *cow_start;\n\t\t\twant_clusters = ocfs2_cow_align_length(inode->i_sb,\n\t\t\t\t\t\t\t       want_clusters);\n\t\t\tif (*cow_start + want_clusters <= rec_end)\n\t\t\t\t*cow_len = want_clusters;\n\t\t\telse\n\t\t\t\t*cow_len = rec_end - *cow_start;\n\t\t}\n\n\t\t/* Have we covered our entire write yet? */\n\t\tif ((*cow_start + *cow_len) >= (cpos + write_len))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * If we reach the end of the extent block and don't get enough\n\t\t * clusters, continue with the next extent block if possible.\n\t\t */\n\t\tif (i + 1 == le16_to_cpu(el->l_next_free_rec) &&\n\t\t    eb && eb->h_next_leaf_blk) {\n\t\t\tbrelse(eb_bh);\n\t\t\teb_bh = NULL;\n\n\t\t\tret = ocfs2_read_extent_block(INODE_CACHE(inode),\n\t\t\t\t\t       le64_to_cpu(eb->h_next_leaf_blk),\n\t\t\t\t\t       &eb_bh);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\t\tel = &eb->h_list;\n\t\t\ti = -1;\n\t\t}\n\t}\n\nout:\n\tbrelse(eb_bh);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_refcount_cal_cow_clusters(struct inode *inode,\n\t\t\t\t\t   struct ocfs2_extent_list *el,\n\t\t\t\t\t   u32 cpos,\n\t\t\t\t\t   u32 write_len,\n\t\t\t\t\t   u32 max_cpos,\n\t\t\t\t\t   u32 *cow_start,\n\t\t\t\t\t   u32 *cow_len)\n{\n\tint ret = 0;\n\tint tree_height = le16_to_cpu(el->l_tree_depth), i;\n\tstruct buffer_head *eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb = NULL;\n\tstruct ocfs2_extent_rec *rec;\n\tunsigned int want_clusters, rec_end = 0;\n\tint contig_clusters = ocfs2_cow_contig_clusters(inode->i_sb);\n\tint leaf_clusters;\n\n\tBUG_ON(cpos + write_len > max_cpos);\n\n\tif (tree_height > 0) {\n\t\tret = ocfs2_find_leaf(INODE_CACHE(inode), el, cpos, &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tocfs2_error(inode->i_sb,\n\t\t\t\t    \"Inode %lu has non zero tree depth in \"\n\t\t\t\t    \"leaf block %llu\\n\", inode->i_ino,\n\t\t\t\t    (unsigned long long)eb_bh->b_blocknr);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t*cow_len = 0;\n\tfor (i = 0; i < le16_to_cpu(el->l_next_free_rec); i++) {\n\t\trec = &el->l_recs[i];\n\n\t\tif (ocfs2_is_empty_extent(rec)) {\n\t\t\tmlog_bug_on_msg(i != 0, \"Inode %lu has empty record in \"\n\t\t\t\t\t\"index %d\\n\", inode->i_ino, i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (le32_to_cpu(rec->e_cpos) +\n\t\t    le16_to_cpu(rec->e_leaf_clusters) <= cpos)\n\t\t\tcontinue;\n\n\t\tif (*cow_len == 0) {\n\t\t\t/*\n\t\t\t * We should find a refcounted record in the\n\t\t\t * first pass.\n\t\t\t */\n\t\t\tBUG_ON(!(rec->e_flags & OCFS2_EXT_REFCOUNTED));\n\t\t\t*cow_start = le32_to_cpu(rec->e_cpos);\n\t\t}\n\n\t\t/*\n\t\t * If we encounter a hole, a non-refcounted record or\n\t\t * pass the max_cpos, stop the search.\n\t\t */\n\t\tif ((!(rec->e_flags & OCFS2_EXT_REFCOUNTED)) ||\n\t\t    (*cow_len && rec_end != le32_to_cpu(rec->e_cpos)) ||\n\t\t    (max_cpos <= le32_to_cpu(rec->e_cpos)))\n\t\t\tbreak;\n\n\t\tleaf_clusters = le16_to_cpu(rec->e_leaf_clusters);\n\t\trec_end = le32_to_cpu(rec->e_cpos) + leaf_clusters;\n\t\tif (rec_end > max_cpos) {\n\t\t\trec_end = max_cpos;\n\t\t\tleaf_clusters = rec_end - le32_to_cpu(rec->e_cpos);\n\t\t}\n\n\t\t/*\n\t\t * How many clusters do we actually need from\n\t\t * this extent?  First we see how many we actually\n\t\t * need to complete the write.  If that's smaller\n\t\t * than contig_clusters, we try for contig_clusters.\n\t\t */\n\t\tif (!*cow_len)\n\t\t\twant_clusters = write_len;\n\t\telse\n\t\t\twant_clusters = (cpos + write_len) -\n\t\t\t\t(*cow_start + *cow_len);\n\t\tif (want_clusters < contig_clusters)\n\t\t\twant_clusters = contig_clusters;\n\n\t\t/*\n\t\t * If the write does not cover the whole extent, we\n\t\t * need to calculate how we're going to split the extent.\n\t\t * We try to do it on contig_clusters boundaries.\n\t\t *\n\t\t * Any extent smaller than contig_clusters will be\n\t\t * CoWed in its entirety.\n\t\t */\n\t\tif (leaf_clusters <= contig_clusters)\n\t\t\t*cow_len += leaf_clusters;\n\t\telse if (*cow_len || (*cow_start == cpos)) {\n\t\t\t/*\n\t\t\t * This extent needs to be CoW'd from its\n\t\t\t * beginning, so all we have to do is compute\n\t\t\t * how many clusters to grab.  We align\n\t\t\t * want_clusters to the edge of contig_clusters\n\t\t\t * to get better I/O.\n\t\t\t */\n\t\t\twant_clusters = ocfs2_cow_align_length(inode->i_sb,\n\t\t\t\t\t\t\t       want_clusters);\n\n\t\t\tif (leaf_clusters < want_clusters)\n\t\t\t\t*cow_len += leaf_clusters;\n\t\t\telse\n\t\t\t\t*cow_len += want_clusters;\n\t\t} else if ((*cow_start + contig_clusters) >=\n\t\t\t   (cpos + write_len)) {\n\t\t\t/*\n\t\t\t * Breaking off contig_clusters at the front\n\t\t\t * of the extent will cover our write.  That's\n\t\t\t * easy.\n\t\t\t */\n\t\t\t*cow_len = contig_clusters;\n\t\t} else if ((rec_end - cpos) <= contig_clusters) {\n\t\t\t/*\n\t\t\t * Breaking off contig_clusters at the tail of\n\t\t\t * this extent will cover cpos.\n\t\t\t */\n\t\t\t*cow_start = rec_end - contig_clusters;\n\t\t\t*cow_len = contig_clusters;\n\t\t} else if ((rec_end - cpos) <= want_clusters) {\n\t\t\t/*\n\t\t\t * While we can't fit the entire write in this\n\t\t\t * extent, we know that the write goes from cpos\n\t\t\t * to the end of the extent.  Break that off.\n\t\t\t * We try to break it at some multiple of\n\t\t\t * contig_clusters from the front of the extent.\n\t\t\t * Failing that (ie, cpos is within\n\t\t\t * contig_clusters of the front), we'll CoW the\n\t\t\t * entire extent.\n\t\t\t */\n\t\t\t*cow_start = ocfs2_cow_align_start(inode->i_sb,\n\t\t\t\t\t\t\t   *cow_start, cpos);\n\t\t\t*cow_len = rec_end - *cow_start;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Ok, the entire write lives in the middle of\n\t\t\t * this extent.  Let's try to slice the extent up\n\t\t\t * nicely.  Optimally, our CoW region starts at\n\t\t\t * m*contig_clusters from the beginning of the\n\t\t\t * extent and goes for n*contig_clusters,\n\t\t\t * covering the entire write.\n\t\t\t */\n\t\t\t*cow_start = ocfs2_cow_align_start(inode->i_sb,\n\t\t\t\t\t\t\t   *cow_start, cpos);\n\n\t\t\twant_clusters = (cpos + write_len) - *cow_start;\n\t\t\twant_clusters = ocfs2_cow_align_length(inode->i_sb,\n\t\t\t\t\t\t\t       want_clusters);\n\t\t\tif (*cow_start + want_clusters <= rec_end)\n\t\t\t\t*cow_len = want_clusters;\n\t\t\telse\n\t\t\t\t*cow_len = rec_end - *cow_start;\n\t\t}\n\n\t\t/* Have we covered our entire write yet? */\n\t\tif ((*cow_start + *cow_len) >= (cpos + write_len))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * If we reach the end of the extent block and don't get enough\n\t\t * clusters, continue with the next extent block if possible.\n\t\t */\n\t\tif (i + 1 == le16_to_cpu(el->l_next_free_rec) &&\n\t\t    eb && eb->h_next_leaf_blk) {\n\t\t\tbrelse(eb_bh);\n\t\t\teb_bh = NULL;\n\n\t\t\tret = ocfs2_read_extent_block(INODE_CACHE(inode),\n\t\t\t\t\t       le64_to_cpu(eb->h_next_leaf_blk),\n\t\t\t\t\t       &eb_bh);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\t\tel = &eb->h_list;\n\t\t\ti = -1;\n\t\t}\n\t}\n\nout:\n\tbrelse(eb_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(oi->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL)"
          ],
          "line": 3440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 3434
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_refcount_cow_hunk(struct inode *inode,\n\t\t\t\t   struct buffer_head *di_bh,\n\t\t\t\t   u32 cpos, u32 write_len, u32 max_cpos)\n{\n\tint ret;\n\tu32 cow_start = 0, cow_len = 0;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_tree *ref_tree;\n\tstruct ocfs2_cow_context *context = NULL;\n\n\tBUG_ON(!(oi->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL));\n\n\tret = ocfs2_refcount_cal_cow_clusters(inode, &di->id2.i_list,\n\t\t\t\t\t      cpos, write_len, max_cpos,\n\t\t\t\t\t      &cow_start, &cow_len);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_refcount_cow_hunk(OCFS2_I(inode)->ip_blkno,\n\t\t\t\t      cpos, write_len, max_cpos,\n\t\t\t\t      cow_start, cow_len);\n\n\tBUG_ON(cow_len == 0);\n\n\tcontext = kzalloc(sizeof(struct ocfs2_cow_context), GFP_NOFS);\n\tif (!context) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_lock_refcount_tree(osb, le64_to_cpu(di->i_refcount_loc),\n\t\t\t\t       1, &ref_tree, &ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tcontext->inode = inode;\n\tcontext->cow_start = cow_start;\n\tcontext->cow_len = cow_len;\n\tcontext->ref_tree = ref_tree;\n\tcontext->ref_root_bh = ref_root_bh;\n\tcontext->cow_duplicate_clusters = ocfs2_duplicate_clusters_by_page;\n\tcontext->get_clusters = ocfs2_di_get_clusters;\n\n\tocfs2_init_dinode_extent_tree(&context->data_et,\n\t\t\t\t      INODE_CACHE(inode), di_bh);\n\n\tret = ocfs2_replace_cow(context);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\t/*\n\t * truncate the extent map here since no matter whether we meet with\n\t * any error during the action, we shouldn't trust cached extent map\n\t * any more.\n\t */\n\tocfs2_extent_map_trunc(inode, cow_start);\n\n\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\tbrelse(ref_root_bh);\nout:\n\tkfree(context);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_replace_cow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "3371-3420",
    "snippet": "static int ocfs2_replace_cow(struct ocfs2_cow_context *context)\n{\n\tint ret = 0;\n\tstruct inode *inode = context->inode;\n\tu32 cow_start = context->cow_start, cow_len = context->cow_len;\n\tu32 p_cluster, num_clusters;\n\tunsigned int ext_flags;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (!ocfs2_refcount_tree(OCFS2_SB(inode->i_sb))) {\n\t\tocfs2_error(inode->i_sb, \"Inode %lu want to use refcount \"\n\t\t\t    \"tree, but the feature bit is not set in the \"\n\t\t\t    \"super block.\", inode->i_ino);\n\t\treturn -EROFS;\n\t}\n\n\tocfs2_init_dealloc_ctxt(&context->dealloc);\n\n\twhile (cow_len) {\n\t\tret = context->get_clusters(context, cow_start, &p_cluster,\n\t\t\t\t\t    &num_clusters, &ext_flags);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tBUG_ON(!(ext_flags & OCFS2_EXT_REFCOUNTED));\n\n\t\tif (cow_len < num_clusters)\n\t\t\tnum_clusters = cow_len;\n\n\t\tret = ocfs2_make_clusters_writable(inode->i_sb, context,\n\t\t\t\t\t\t   cow_start, p_cluster,\n\t\t\t\t\t\t   num_clusters, ext_flags);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tcow_len -= num_clusters;\n\t\tcow_start += num_clusters;\n\t}\n\n\tif (ocfs2_dealloc_has_cluster(&context->dealloc)) {\n\t\tocfs2_schedule_truncate_log_flush(osb, 1);\n\t\tocfs2_run_deallocs(osb, &context->dealloc);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_run_deallocs",
          "args": [
            "osb",
            "&context->dealloc"
          ],
          "line": 3416
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_run_deallocs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "6472-6513",
          "snippet": "int ocfs2_run_deallocs(struct ocfs2_super *osb,\n\t\t       struct ocfs2_cached_dealloc_ctxt *ctxt)\n{\n\tint ret = 0, ret2;\n\tstruct ocfs2_per_slot_free_list *fl;\n\n\tif (!ctxt)\n\t\treturn 0;\n\n\twhile (ctxt->c_first_suballocator) {\n\t\tfl = ctxt->c_first_suballocator;\n\n\t\tif (fl->f_first) {\n\t\t\ttrace_ocfs2_run_deallocs(fl->f_inode_type,\n\t\t\t\t\t\t fl->f_slot);\n\t\t\tret2 = ocfs2_free_cached_blocks(osb,\n\t\t\t\t\t\t\tfl->f_inode_type,\n\t\t\t\t\t\t\tfl->f_slot,\n\t\t\t\t\t\t\tfl->f_first);\n\t\t\tif (ret2)\n\t\t\t\tmlog_errno(ret2);\n\t\t\tif (!ret)\n\t\t\t\tret = ret2;\n\t\t}\n\n\t\tctxt->c_first_suballocator = fl->f_next_suballocator;\n\t\tkfree(fl);\n\t}\n\n\tif (ctxt->c_global_allocator) {\n\t\tret2 = ocfs2_free_cached_clusters(osb,\n\t\t\t\t\t\t  ctxt->c_global_allocator);\n\t\tif (ret2)\n\t\t\tmlog_errno(ret2);\n\t\tif (!ret)\n\t\t\tret = ret2;\n\n\t\tctxt->c_global_allocator = NULL;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_run_deallocs(struct ocfs2_super *osb,\n\t\t       struct ocfs2_cached_dealloc_ctxt *ctxt)\n{\n\tint ret = 0, ret2;\n\tstruct ocfs2_per_slot_free_list *fl;\n\n\tif (!ctxt)\n\t\treturn 0;\n\n\twhile (ctxt->c_first_suballocator) {\n\t\tfl = ctxt->c_first_suballocator;\n\n\t\tif (fl->f_first) {\n\t\t\ttrace_ocfs2_run_deallocs(fl->f_inode_type,\n\t\t\t\t\t\t fl->f_slot);\n\t\t\tret2 = ocfs2_free_cached_blocks(osb,\n\t\t\t\t\t\t\tfl->f_inode_type,\n\t\t\t\t\t\t\tfl->f_slot,\n\t\t\t\t\t\t\tfl->f_first);\n\t\t\tif (ret2)\n\t\t\t\tmlog_errno(ret2);\n\t\t\tif (!ret)\n\t\t\t\tret = ret2;\n\t\t}\n\n\t\tctxt->c_first_suballocator = fl->f_next_suballocator;\n\t\tkfree(fl);\n\t}\n\n\tif (ctxt->c_global_allocator) {\n\t\tret2 = ocfs2_free_cached_clusters(osb,\n\t\t\t\t\t\t  ctxt->c_global_allocator);\n\t\tif (ret2)\n\t\t\tmlog_errno(ret2);\n\t\tif (!ret)\n\t\t\tret = ret2;\n\n\t\tctxt->c_global_allocator = NULL;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_schedule_truncate_log_flush",
          "args": [
            "osb",
            "1"
          ],
          "line": 3415
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_schedule_truncate_log_flush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "6057-6070",
          "snippet": "void ocfs2_schedule_truncate_log_flush(struct ocfs2_super *osb,\n\t\t\t\t       int cancel)\n{\n\tif (osb->osb_tl_inode &&\n\t\t\tatomic_read(&osb->osb_tl_disable) == 0) {\n\t\t/* We want to push off log flushes while truncates are\n\t\t * still running. */\n\t\tif (cancel)\n\t\t\tcancel_delayed_work(&osb->osb_truncate_log_wq);\n\n\t\tqueue_delayed_work(ocfs2_wq, &osb->osb_truncate_log_wq,\n\t\t\t\t   OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL (2 * HZ)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL (2 * HZ)\n\nvoid ocfs2_schedule_truncate_log_flush(struct ocfs2_super *osb,\n\t\t\t\t       int cancel)\n{\n\tif (osb->osb_tl_inode &&\n\t\t\tatomic_read(&osb->osb_tl_disable) == 0) {\n\t\t/* We want to push off log flushes while truncates are\n\t\t * still running. */\n\t\tif (cancel)\n\t\t\tcancel_delayed_work(&osb->osb_truncate_log_wq);\n\n\t\tqueue_delayed_work(ocfs2_wq, &osb->osb_truncate_log_wq,\n\t\t\t\t   OCFS2_TRUNCATE_LOG_FLUSH_INTERVAL);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_dealloc_has_cluster",
          "args": [
            "&context->dealloc"
          ],
          "line": 3414
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_dealloc_has_cluster",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
          "lines": "215-218",
          "snippet": "static inline int ocfs2_dealloc_has_cluster(struct ocfs2_cached_dealloc_ctxt *c)\n{\n\treturn c->c_global_allocator != NULL;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_dealloc_has_cluster(struct ocfs2_cached_dealloc_ctxt *c)\n{\n\treturn c->c_global_allocator != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_make_clusters_writable",
          "args": [
            "inode->i_sb",
            "context",
            "cow_start",
            "p_cluster",
            "num_clusters",
            "ext_flags"
          ],
          "line": 3402
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_make_clusters_writable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "3220-3369",
          "snippet": "static int ocfs2_make_clusters_writable(struct super_block *sb,\n\t\t\t\t\tstruct ocfs2_cow_context *context,\n\t\t\t\t\tu32 cpos, u32 p_cluster,\n\t\t\t\t\tu32 num_clusters, unsigned int e_flags)\n{\n\tint ret, delete, index, credits =  0;\n\tu32 new_bit, new_len, orig_num_clusters;\n\tunsigned int set_len;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\thandle_t *handle;\n\tstruct buffer_head *ref_leaf_bh = NULL;\n\tstruct ocfs2_caching_info *ref_ci = &context->ref_tree->rf_ci;\n\tstruct ocfs2_refcount_rec rec;\n\n\ttrace_ocfs2_make_clusters_writable(cpos, p_cluster,\n\t\t\t\t\t   num_clusters, e_flags);\n\n\tret = ocfs2_lock_refcount_allocators(sb, p_cluster, num_clusters,\n\t\t\t\t\t     &context->data_et,\n\t\t\t\t\t     ref_ci,\n\t\t\t\t\t     context->ref_root_bh,\n\t\t\t\t\t     &context->meta_ac,\n\t\t\t\t\t     &context->data_ac, &credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tif (context->post_refcount)\n\t\tcredits += context->post_refcount->credits;\n\n\tcredits += context->extra_credits;\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\torig_num_clusters = num_clusters;\n\n\twhile (num_clusters) {\n\t\tret = ocfs2_get_refcount_rec(ref_ci, context->ref_root_bh,\n\t\t\t\t\t     p_cluster, num_clusters,\n\t\t\t\t\t     &rec, &index, &ref_leaf_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_commit;\n\t\t}\n\n\t\tBUG_ON(!rec.r_refcount);\n\t\tset_len = min((u64)p_cluster + num_clusters,\n\t\t\t      le64_to_cpu(rec.r_cpos) +\n\t\t\t      le32_to_cpu(rec.r_clusters)) - p_cluster;\n\n\t\t/*\n\t\t * There are many different situation here.\n\t\t * 1. If refcount == 1, remove the flag and don't COW.\n\t\t * 2. If refcount > 1, allocate clusters.\n\t\t *    Here we may not allocate r_len once at a time, so continue\n\t\t *    until we reach num_clusters.\n\t\t */\n\t\tif (le32_to_cpu(rec.r_refcount) == 1) {\n\t\t\tdelete = 0;\n\t\t\tret = ocfs2_clear_ext_refcount(handle,\n\t\t\t\t\t\t       &context->data_et,\n\t\t\t\t\t\t       cpos, p_cluster,\n\t\t\t\t\t\t       set_len, e_flags,\n\t\t\t\t\t\t       context->meta_ac,\n\t\t\t\t\t\t       &context->dealloc);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out_commit;\n\t\t\t}\n\t\t} else {\n\t\t\tdelete = 1;\n\n\t\t\tret = __ocfs2_claim_clusters(handle,\n\t\t\t\t\t\t     context->data_ac,\n\t\t\t\t\t\t     1, set_len,\n\t\t\t\t\t\t     &new_bit, &new_len);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out_commit;\n\t\t\t}\n\n\t\t\tret = ocfs2_replace_clusters(handle, context,\n\t\t\t\t\t\t     cpos, p_cluster, new_bit,\n\t\t\t\t\t\t     new_len, e_flags);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out_commit;\n\t\t\t}\n\t\t\tset_len = new_len;\n\t\t}\n\n\t\tret = __ocfs2_decrease_refcount(handle, ref_ci,\n\t\t\t\t\t\tcontext->ref_root_bh,\n\t\t\t\t\t\tp_cluster, set_len,\n\t\t\t\t\t\tcontext->meta_ac,\n\t\t\t\t\t\t&context->dealloc, delete);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_commit;\n\t\t}\n\n\t\tcpos += set_len;\n\t\tp_cluster += set_len;\n\t\tnum_clusters -= set_len;\n\t\tbrelse(ref_leaf_bh);\n\t\tref_leaf_bh = NULL;\n\t}\n\n\t/* handle any post_cow action. */\n\tif (context->post_refcount && context->post_refcount->func) {\n\t\tret = context->post_refcount->func(context->inode, handle,\n\t\t\t\t\t\tcontext->post_refcount->para);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_commit;\n\t\t}\n\t}\n\n\t/*\n\t * Here we should write the new page out first if we are\n\t * in write-back mode.\n\t */\n\tif (context->get_clusters == ocfs2_di_get_clusters) {\n\t\tret = ocfs2_cow_sync_writeback(sb, context->inode, cpos,\n\t\t\t\t\t       orig_num_clusters);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\n\nout:\n\tif (context->data_ac) {\n\t\tocfs2_free_alloc_context(context->data_ac);\n\t\tcontext->data_ac = NULL;\n\t}\n\tif (context->meta_ac) {\n\t\tocfs2_free_alloc_context(context->meta_ac);\n\t\tcontext->meta_ac = NULL;\n\t}\n\tbrelse(ref_leaf_bh);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_make_clusters_writable(struct super_block *sb,\n\t\t\t\t\tstruct ocfs2_cow_context *context,\n\t\t\t\t\tu32 cpos, u32 p_cluster,\n\t\t\t\t\tu32 num_clusters, unsigned int e_flags)\n{\n\tint ret, delete, index, credits =  0;\n\tu32 new_bit, new_len, orig_num_clusters;\n\tunsigned int set_len;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\thandle_t *handle;\n\tstruct buffer_head *ref_leaf_bh = NULL;\n\tstruct ocfs2_caching_info *ref_ci = &context->ref_tree->rf_ci;\n\tstruct ocfs2_refcount_rec rec;\n\n\ttrace_ocfs2_make_clusters_writable(cpos, p_cluster,\n\t\t\t\t\t   num_clusters, e_flags);\n\n\tret = ocfs2_lock_refcount_allocators(sb, p_cluster, num_clusters,\n\t\t\t\t\t     &context->data_et,\n\t\t\t\t\t     ref_ci,\n\t\t\t\t\t     context->ref_root_bh,\n\t\t\t\t\t     &context->meta_ac,\n\t\t\t\t\t     &context->data_ac, &credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tif (context->post_refcount)\n\t\tcredits += context->post_refcount->credits;\n\n\tcredits += context->extra_credits;\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\torig_num_clusters = num_clusters;\n\n\twhile (num_clusters) {\n\t\tret = ocfs2_get_refcount_rec(ref_ci, context->ref_root_bh,\n\t\t\t\t\t     p_cluster, num_clusters,\n\t\t\t\t\t     &rec, &index, &ref_leaf_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_commit;\n\t\t}\n\n\t\tBUG_ON(!rec.r_refcount);\n\t\tset_len = min((u64)p_cluster + num_clusters,\n\t\t\t      le64_to_cpu(rec.r_cpos) +\n\t\t\t      le32_to_cpu(rec.r_clusters)) - p_cluster;\n\n\t\t/*\n\t\t * There are many different situation here.\n\t\t * 1. If refcount == 1, remove the flag and don't COW.\n\t\t * 2. If refcount > 1, allocate clusters.\n\t\t *    Here we may not allocate r_len once at a time, so continue\n\t\t *    until we reach num_clusters.\n\t\t */\n\t\tif (le32_to_cpu(rec.r_refcount) == 1) {\n\t\t\tdelete = 0;\n\t\t\tret = ocfs2_clear_ext_refcount(handle,\n\t\t\t\t\t\t       &context->data_et,\n\t\t\t\t\t\t       cpos, p_cluster,\n\t\t\t\t\t\t       set_len, e_flags,\n\t\t\t\t\t\t       context->meta_ac,\n\t\t\t\t\t\t       &context->dealloc);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out_commit;\n\t\t\t}\n\t\t} else {\n\t\t\tdelete = 1;\n\n\t\t\tret = __ocfs2_claim_clusters(handle,\n\t\t\t\t\t\t     context->data_ac,\n\t\t\t\t\t\t     1, set_len,\n\t\t\t\t\t\t     &new_bit, &new_len);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out_commit;\n\t\t\t}\n\n\t\t\tret = ocfs2_replace_clusters(handle, context,\n\t\t\t\t\t\t     cpos, p_cluster, new_bit,\n\t\t\t\t\t\t     new_len, e_flags);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out_commit;\n\t\t\t}\n\t\t\tset_len = new_len;\n\t\t}\n\n\t\tret = __ocfs2_decrease_refcount(handle, ref_ci,\n\t\t\t\t\t\tcontext->ref_root_bh,\n\t\t\t\t\t\tp_cluster, set_len,\n\t\t\t\t\t\tcontext->meta_ac,\n\t\t\t\t\t\t&context->dealloc, delete);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_commit;\n\t\t}\n\n\t\tcpos += set_len;\n\t\tp_cluster += set_len;\n\t\tnum_clusters -= set_len;\n\t\tbrelse(ref_leaf_bh);\n\t\tref_leaf_bh = NULL;\n\t}\n\n\t/* handle any post_cow action. */\n\tif (context->post_refcount && context->post_refcount->func) {\n\t\tret = context->post_refcount->func(context->inode, handle,\n\t\t\t\t\t\tcontext->post_refcount->para);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_commit;\n\t\t}\n\t}\n\n\t/*\n\t * Here we should write the new page out first if we are\n\t * in write-back mode.\n\t */\n\tif (context->get_clusters == ocfs2_di_get_clusters) {\n\t\tret = ocfs2_cow_sync_writeback(sb, context->inode, cpos,\n\t\t\t\t\t       orig_num_clusters);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\n\nout:\n\tif (context->data_ac) {\n\t\tocfs2_free_alloc_context(context->data_ac);\n\t\tcontext->data_ac = NULL;\n\t}\n\tif (context->meta_ac) {\n\t\tocfs2_free_alloc_context(context->meta_ac);\n\t\tcontext->meta_ac = NULL;\n\t}\n\tbrelse(ref_leaf_bh);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(ext_flags & OCFS2_EXT_REFCOUNTED)"
          ],
          "line": 3397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context->get_clusters",
          "args": [
            "context",
            "cow_start",
            "&p_cluster",
            "&num_clusters",
            "&ext_flags"
          ],
          "line": 3390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_init_dealloc_ctxt",
          "args": [
            "&context->dealloc"
          ],
          "line": 3387
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_dealloc_ctxt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
          "lines": "205-209",
          "snippet": "static inline void ocfs2_init_dealloc_ctxt(struct ocfs2_cached_dealloc_ctxt *c)\n{\n\tc->c_first_suballocator = NULL;\n\tc->c_global_allocator = NULL;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void ocfs2_init_dealloc_ctxt(struct ocfs2_cached_dealloc_ctxt *c)\n{\n\tc->c_first_suballocator = NULL;\n\tc->c_global_allocator = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_error",
          "args": [
            "inode->i_sb",
            "\"Inode %lu want to use refcount \"\n\t\t\t    \"tree, but the feature bit is not set in the \"\n\t\t\t    \"super block.\"",
            "inode->i_ino"
          ],
          "line": 3381
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2568-2584",
          "snippet": "void __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic char error_buf[1024];\n\nvoid __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_refcount_tree",
          "args": [
            "OCFS2_SB(inode->i_sb)"
          ],
          "line": 3380
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_refcount_tree_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "292-296",
          "snippet": "static inline void\nocfs2_refcount_tree_put(struct ocfs2_refcount_tree *tree)\n{\n\tkref_put(&tree->rf_getcnt, ocfs2_kref_remove_refcount_tree);\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic inline void\nocfs2_refcount_tree_put(struct ocfs2_refcount_tree *tree)\n{\n\tkref_put(&tree->rf_getcnt, ocfs2_kref_remove_refcount_tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 3380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 3378
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_replace_cow(struct ocfs2_cow_context *context)\n{\n\tint ret = 0;\n\tstruct inode *inode = context->inode;\n\tu32 cow_start = context->cow_start, cow_len = context->cow_len;\n\tu32 p_cluster, num_clusters;\n\tunsigned int ext_flags;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tif (!ocfs2_refcount_tree(OCFS2_SB(inode->i_sb))) {\n\t\tocfs2_error(inode->i_sb, \"Inode %lu want to use refcount \"\n\t\t\t    \"tree, but the feature bit is not set in the \"\n\t\t\t    \"super block.\", inode->i_ino);\n\t\treturn -EROFS;\n\t}\n\n\tocfs2_init_dealloc_ctxt(&context->dealloc);\n\n\twhile (cow_len) {\n\t\tret = context->get_clusters(context, cow_start, &p_cluster,\n\t\t\t\t\t    &num_clusters, &ext_flags);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tBUG_ON(!(ext_flags & OCFS2_EXT_REFCOUNTED));\n\n\t\tif (cow_len < num_clusters)\n\t\t\tnum_clusters = cow_len;\n\n\t\tret = ocfs2_make_clusters_writable(inode->i_sb, context,\n\t\t\t\t\t\t   cow_start, p_cluster,\n\t\t\t\t\t\t   num_clusters, ext_flags);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tcow_len -= num_clusters;\n\t\tcow_start += num_clusters;\n\t}\n\n\tif (ocfs2_dealloc_has_cluster(&context->dealloc)) {\n\t\tocfs2_schedule_truncate_log_flush(osb, 1);\n\t\tocfs2_run_deallocs(osb, &context->dealloc);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_make_clusters_writable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "3220-3369",
    "snippet": "static int ocfs2_make_clusters_writable(struct super_block *sb,\n\t\t\t\t\tstruct ocfs2_cow_context *context,\n\t\t\t\t\tu32 cpos, u32 p_cluster,\n\t\t\t\t\tu32 num_clusters, unsigned int e_flags)\n{\n\tint ret, delete, index, credits =  0;\n\tu32 new_bit, new_len, orig_num_clusters;\n\tunsigned int set_len;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\thandle_t *handle;\n\tstruct buffer_head *ref_leaf_bh = NULL;\n\tstruct ocfs2_caching_info *ref_ci = &context->ref_tree->rf_ci;\n\tstruct ocfs2_refcount_rec rec;\n\n\ttrace_ocfs2_make_clusters_writable(cpos, p_cluster,\n\t\t\t\t\t   num_clusters, e_flags);\n\n\tret = ocfs2_lock_refcount_allocators(sb, p_cluster, num_clusters,\n\t\t\t\t\t     &context->data_et,\n\t\t\t\t\t     ref_ci,\n\t\t\t\t\t     context->ref_root_bh,\n\t\t\t\t\t     &context->meta_ac,\n\t\t\t\t\t     &context->data_ac, &credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tif (context->post_refcount)\n\t\tcredits += context->post_refcount->credits;\n\n\tcredits += context->extra_credits;\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\torig_num_clusters = num_clusters;\n\n\twhile (num_clusters) {\n\t\tret = ocfs2_get_refcount_rec(ref_ci, context->ref_root_bh,\n\t\t\t\t\t     p_cluster, num_clusters,\n\t\t\t\t\t     &rec, &index, &ref_leaf_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_commit;\n\t\t}\n\n\t\tBUG_ON(!rec.r_refcount);\n\t\tset_len = min((u64)p_cluster + num_clusters,\n\t\t\t      le64_to_cpu(rec.r_cpos) +\n\t\t\t      le32_to_cpu(rec.r_clusters)) - p_cluster;\n\n\t\t/*\n\t\t * There are many different situation here.\n\t\t * 1. If refcount == 1, remove the flag and don't COW.\n\t\t * 2. If refcount > 1, allocate clusters.\n\t\t *    Here we may not allocate r_len once at a time, so continue\n\t\t *    until we reach num_clusters.\n\t\t */\n\t\tif (le32_to_cpu(rec.r_refcount) == 1) {\n\t\t\tdelete = 0;\n\t\t\tret = ocfs2_clear_ext_refcount(handle,\n\t\t\t\t\t\t       &context->data_et,\n\t\t\t\t\t\t       cpos, p_cluster,\n\t\t\t\t\t\t       set_len, e_flags,\n\t\t\t\t\t\t       context->meta_ac,\n\t\t\t\t\t\t       &context->dealloc);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out_commit;\n\t\t\t}\n\t\t} else {\n\t\t\tdelete = 1;\n\n\t\t\tret = __ocfs2_claim_clusters(handle,\n\t\t\t\t\t\t     context->data_ac,\n\t\t\t\t\t\t     1, set_len,\n\t\t\t\t\t\t     &new_bit, &new_len);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out_commit;\n\t\t\t}\n\n\t\t\tret = ocfs2_replace_clusters(handle, context,\n\t\t\t\t\t\t     cpos, p_cluster, new_bit,\n\t\t\t\t\t\t     new_len, e_flags);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out_commit;\n\t\t\t}\n\t\t\tset_len = new_len;\n\t\t}\n\n\t\tret = __ocfs2_decrease_refcount(handle, ref_ci,\n\t\t\t\t\t\tcontext->ref_root_bh,\n\t\t\t\t\t\tp_cluster, set_len,\n\t\t\t\t\t\tcontext->meta_ac,\n\t\t\t\t\t\t&context->dealloc, delete);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_commit;\n\t\t}\n\n\t\tcpos += set_len;\n\t\tp_cluster += set_len;\n\t\tnum_clusters -= set_len;\n\t\tbrelse(ref_leaf_bh);\n\t\tref_leaf_bh = NULL;\n\t}\n\n\t/* handle any post_cow action. */\n\tif (context->post_refcount && context->post_refcount->func) {\n\t\tret = context->post_refcount->func(context->inode, handle,\n\t\t\t\t\t\tcontext->post_refcount->para);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_commit;\n\t\t}\n\t}\n\n\t/*\n\t * Here we should write the new page out first if we are\n\t * in write-back mode.\n\t */\n\tif (context->get_clusters == ocfs2_di_get_clusters) {\n\t\tret = ocfs2_cow_sync_writeback(sb, context->inode, cpos,\n\t\t\t\t\t       orig_num_clusters);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\n\nout:\n\tif (context->data_ac) {\n\t\tocfs2_free_alloc_context(context->data_ac);\n\t\tcontext->data_ac = NULL;\n\t}\n\tif (context->meta_ac) {\n\t\tocfs2_free_alloc_context(context->meta_ac);\n\t\tcontext->meta_ac = NULL;\n\t}\n\tbrelse(ref_leaf_bh);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "ref_leaf_bh"
          ],
          "line": 3366
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_free_alloc_context",
          "args": [
            "context->meta_ac"
          ],
          "line": 3363
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_alloc_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "158-162",
          "snippet": "void ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nvoid ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "handle"
          ],
          "line": 3355
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_cow_sync_writeback",
          "args": [
            "sb",
            "context->inode",
            "cpos",
            "orig_num_clusters"
          ],
          "line": 3348
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_cow_sync_writeback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "3161-3209",
          "snippet": "int ocfs2_cow_sync_writeback(struct super_block *sb,\n\t\t\t     struct inode *inode,\n\t\t\t     u32 cpos, u32 num_clusters)\n{\n\tint ret = 0;\n\tloff_t offset, end, map_end;\n\tpgoff_t page_index;\n\tstruct page *page;\n\n\tif (ocfs2_should_order_data(inode))\n\t\treturn 0;\n\n\toffset = ((loff_t)cpos) << OCFS2_SB(sb)->s_clustersize_bits;\n\tend = offset + (num_clusters << OCFS2_SB(sb)->s_clustersize_bits);\n\n\tret = filemap_fdatawrite_range(inode->i_mapping,\n\t\t\t\t       offset, end - 1);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\twhile (offset < end) {\n\t\tpage_index = offset >> PAGE_CACHE_SHIFT;\n\t\tmap_end = ((loff_t)page_index + 1) << PAGE_CACHE_SHIFT;\n\t\tif (map_end > end)\n\t\t\tmap_end = end;\n\n\t\tpage = find_or_create_page(inode->i_mapping,\n\t\t\t\t\t   page_index, GFP_NOFS);\n\t\tBUG_ON(!page);\n\n\t\twait_on_page_writeback(page);\n\t\tif (PageError(page)) {\n\t\t\tret = -EIO;\n\t\t\tmlog_errno(ret);\n\t\t} else\n\t\t\tmark_page_accessed(page);\n\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tpage = NULL;\n\t\toffset = map_end;\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nint ocfs2_cow_sync_writeback(struct super_block *sb,\n\t\t\t     struct inode *inode,\n\t\t\t     u32 cpos, u32 num_clusters)\n{\n\tint ret = 0;\n\tloff_t offset, end, map_end;\n\tpgoff_t page_index;\n\tstruct page *page;\n\n\tif (ocfs2_should_order_data(inode))\n\t\treturn 0;\n\n\toffset = ((loff_t)cpos) << OCFS2_SB(sb)->s_clustersize_bits;\n\tend = offset + (num_clusters << OCFS2_SB(sb)->s_clustersize_bits);\n\n\tret = filemap_fdatawrite_range(inode->i_mapping,\n\t\t\t\t       offset, end - 1);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\twhile (offset < end) {\n\t\tpage_index = offset >> PAGE_CACHE_SHIFT;\n\t\tmap_end = ((loff_t)page_index + 1) << PAGE_CACHE_SHIFT;\n\t\tif (map_end > end)\n\t\t\tmap_end = end;\n\n\t\tpage = find_or_create_page(inode->i_mapping,\n\t\t\t\t\t   page_index, GFP_NOFS);\n\t\tBUG_ON(!page);\n\n\t\twait_on_page_writeback(page);\n\t\tif (PageError(page)) {\n\t\t\tret = -EIO;\n\t\t\tmlog_errno(ret);\n\t\t} else\n\t\t\tmark_page_accessed(page);\n\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tpage = NULL;\n\t\toffset = map_end;\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context->post_refcount->func",
          "args": [
            "context->inode",
            "handle",
            "context->post_refcount->para"
          ],
          "line": 3335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ocfs2_decrease_refcount",
          "args": [
            "handle",
            "ref_ci",
            "context->ref_root_bh",
            "p_cluster",
            "set_len",
            "context->meta_ac",
            "&context->dealloc",
            "delete"
          ],
          "line": 3316
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_decrease_refcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "2234-2297",
          "snippet": "static int __ocfs2_decrease_refcount(handle_t *handle,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *ref_root_bh,\n\t\t\t\t     u64 cpos, u32 len,\n\t\t\t\t     struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t     struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t\t     int delete)\n{\n\tint ret = 0, index = 0;\n\tstruct ocfs2_refcount_rec rec;\n\tunsigned int r_count = 0, r_len;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\n\tstruct buffer_head *ref_leaf_bh = NULL;\n\n\ttrace_ocfs2_decrease_refcount(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t(unsigned long long)cpos, len, delete);\n\n\twhile (len) {\n\t\tret = ocfs2_get_refcount_rec(ci, ref_root_bh,\n\t\t\t\t\t     cpos, len, &rec, &index,\n\t\t\t\t\t     &ref_leaf_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tr_count = le32_to_cpu(rec.r_refcount);\n\t\tBUG_ON(r_count == 0);\n\t\tif (!delete)\n\t\t\tBUG_ON(r_count > 1);\n\n\t\tr_len = min((u64)(cpos + len), le64_to_cpu(rec.r_cpos) +\n\t\t\t      le32_to_cpu(rec.r_clusters)) - cpos;\n\n\t\tret = ocfs2_decrease_refcount_rec(handle, ci, ref_root_bh,\n\t\t\t\t\t\t  ref_leaf_bh, index,\n\t\t\t\t\t\t  cpos, r_len,\n\t\t\t\t\t\t  meta_ac, dealloc);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (le32_to_cpu(rec.r_refcount) == 1 && delete) {\n\t\t\tret = ocfs2_cache_cluster_dealloc(dealloc,\n\t\t\t\t\t  ocfs2_clusters_to_blocks(sb, cpos),\n\t\t\t\t\t\t\t  r_len);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tcpos += r_len;\n\t\tlen -= r_len;\n\t\tbrelse(ref_leaf_bh);\n\t\tref_leaf_bh = NULL;\n\t}\n\nout:\n\tbrelse(ref_leaf_bh);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int __ocfs2_decrease_refcount(handle_t *handle,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *ref_root_bh,\n\t\t\t\t     u64 cpos, u32 len,\n\t\t\t\t     struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t     struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t\t     int delete)\n{\n\tint ret = 0, index = 0;\n\tstruct ocfs2_refcount_rec rec;\n\tunsigned int r_count = 0, r_len;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\n\tstruct buffer_head *ref_leaf_bh = NULL;\n\n\ttrace_ocfs2_decrease_refcount(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t(unsigned long long)cpos, len, delete);\n\n\twhile (len) {\n\t\tret = ocfs2_get_refcount_rec(ci, ref_root_bh,\n\t\t\t\t\t     cpos, len, &rec, &index,\n\t\t\t\t\t     &ref_leaf_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tr_count = le32_to_cpu(rec.r_refcount);\n\t\tBUG_ON(r_count == 0);\n\t\tif (!delete)\n\t\t\tBUG_ON(r_count > 1);\n\n\t\tr_len = min((u64)(cpos + len), le64_to_cpu(rec.r_cpos) +\n\t\t\t      le32_to_cpu(rec.r_clusters)) - cpos;\n\n\t\tret = ocfs2_decrease_refcount_rec(handle, ci, ref_root_bh,\n\t\t\t\t\t\t  ref_leaf_bh, index,\n\t\t\t\t\t\t  cpos, r_len,\n\t\t\t\t\t\t  meta_ac, dealloc);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (le32_to_cpu(rec.r_refcount) == 1 && delete) {\n\t\t\tret = ocfs2_cache_cluster_dealloc(dealloc,\n\t\t\t\t\t  ocfs2_clusters_to_blocks(sb, cpos),\n\t\t\t\t\t\t\t  r_len);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tcpos += r_len;\n\t\tlen -= r_len;\n\t\tbrelse(ref_leaf_bh);\n\t\tref_leaf_bh = NULL;\n\t}\n\nout:\n\tbrelse(ref_leaf_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_replace_clusters",
          "args": [
            "handle",
            "context",
            "cpos",
            "p_cluster",
            "new_bit",
            "new_len",
            "e_flags"
          ],
          "line": 3306
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_replace_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "3129-3159",
          "snippet": "static int ocfs2_replace_clusters(handle_t *handle,\n\t\t\t\t  struct ocfs2_cow_context *context,\n\t\t\t\t  u32 cpos, u32 old,\n\t\t\t\t  u32 new, u32 len,\n\t\t\t\t  unsigned int ext_flags)\n{\n\tint ret;\n\tstruct ocfs2_caching_info *ci = context->data_et.et_ci;\n\tu64 ino = ocfs2_metadata_cache_owner(ci);\n\n\ttrace_ocfs2_replace_clusters((unsigned long long)ino,\n\t\t\t\t     cpos, old, new, len, ext_flags);\n\n\t/*If the old clusters is unwritten, no need to duplicate. */\n\tif (!(ext_flags & OCFS2_EXT_UNWRITTEN)) {\n\t\tret = context->cow_duplicate_clusters(handle, context->inode,\n\t\t\t\t\t\t      cpos, old, new, len);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ocfs2_clear_ext_refcount(handle, &context->data_et,\n\t\t\t\t       cpos, new, len, ext_flags,\n\t\t\t\t       context->meta_ac, &context->dealloc);\n\tif (ret)\n\t\tmlog_errno(ret);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_replace_clusters(handle_t *handle,\n\t\t\t\t  struct ocfs2_cow_context *context,\n\t\t\t\t  u32 cpos, u32 old,\n\t\t\t\t  u32 new, u32 len,\n\t\t\t\t  unsigned int ext_flags)\n{\n\tint ret;\n\tstruct ocfs2_caching_info *ci = context->data_et.et_ci;\n\tu64 ino = ocfs2_metadata_cache_owner(ci);\n\n\ttrace_ocfs2_replace_clusters((unsigned long long)ino,\n\t\t\t\t     cpos, old, new, len, ext_flags);\n\n\t/*If the old clusters is unwritten, no need to duplicate. */\n\tif (!(ext_flags & OCFS2_EXT_UNWRITTEN)) {\n\t\tret = context->cow_duplicate_clusters(handle, context->inode,\n\t\t\t\t\t\t      cpos, old, new, len);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ocfs2_clear_ext_refcount(handle, &context->data_et,\n\t\t\t\t       cpos, new, len, ext_flags,\n\t\t\t\t       context->meta_ac, &context->dealloc);\n\tif (ret)\n\t\tmlog_errno(ret);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ocfs2_claim_clusters",
          "args": [
            "handle",
            "context->data_ac",
            "1",
            "set_len",
            "&new_bit",
            "&new_len"
          ],
          "line": 3297
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_claim_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2302-2371",
          "snippet": "int __ocfs2_claim_clusters(handle_t *handle,\n\t\t\t   struct ocfs2_alloc_context *ac,\n\t\t\t   u32 min_clusters,\n\t\t\t   u32 max_clusters,\n\t\t\t   u32 *cluster_start,\n\t\t\t   u32 *num_clusters)\n{\n\tint status;\n\tunsigned int bits_wanted = max_clusters;\n\tstruct ocfs2_suballoc_result res = { .sr_blkno = 0, };\n\tstruct ocfs2_super *osb = OCFS2_SB(ac->ac_inode->i_sb);\n\n\tBUG_ON(ac->ac_bits_given >= ac->ac_bits_wanted);\n\n\tBUG_ON(ac->ac_which != OCFS2_AC_USE_LOCAL\n\t       && ac->ac_which != OCFS2_AC_USE_MAIN);\n\n\tif (ac->ac_which == OCFS2_AC_USE_LOCAL) {\n\t\tWARN_ON(min_clusters > 1);\n\n\t\tstatus = ocfs2_claim_local_alloc_bits(osb,\n\t\t\t\t\t\t      handle,\n\t\t\t\t\t\t      ac,\n\t\t\t\t\t\t      bits_wanted,\n\t\t\t\t\t\t      cluster_start,\n\t\t\t\t\t\t      num_clusters);\n\t\tif (!status)\n\t\t\tatomic_inc(&osb->alloc_stats.local_data);\n\t} else {\n\t\tif (min_clusters > (osb->bitmap_cpg - 1)) {\n\t\t\t/* The only paths asking for contiguousness\n\t\t\t * should know about this already. */\n\t\t\tmlog(ML_ERROR, \"minimum allocation requested %u exceeds \"\n\t\t\t     \"group bitmap size %u!\\n\", min_clusters,\n\t\t\t     osb->bitmap_cpg);\n\t\t\tstatus = -ENOSPC;\n\t\t\tgoto bail;\n\t\t}\n\t\t/* clamp the current request down to a realistic size. */\n\t\tif (bits_wanted > (osb->bitmap_cpg - 1))\n\t\t\tbits_wanted = osb->bitmap_cpg - 1;\n\n\t\tstatus = ocfs2_claim_suballoc_bits(ac,\n\t\t\t\t\t\t   handle,\n\t\t\t\t\t\t   bits_wanted,\n\t\t\t\t\t\t   min_clusters,\n\t\t\t\t\t\t   &res);\n\t\tif (!status) {\n\t\t\tBUG_ON(res.sr_blkno); /* cluster alloc can't set */\n\t\t\t*cluster_start =\n\t\t\t\tocfs2_desc_bitmap_to_cluster_off(ac->ac_inode,\n\t\t\t\t\t\t\t\t res.sr_bg_blkno,\n\t\t\t\t\t\t\t\t res.sr_bit_offset);\n\t\t\tatomic_inc(&osb->alloc_stats.bitmap_data);\n\t\t\t*num_clusters = res.sr_bits;\n\t\t}\n\t}\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tac->ac_bits_given += *num_clusters;\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);",
            "static int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);",
            "static int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);",
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);\nstatic int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);\nstatic int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint __ocfs2_claim_clusters(handle_t *handle,\n\t\t\t   struct ocfs2_alloc_context *ac,\n\t\t\t   u32 min_clusters,\n\t\t\t   u32 max_clusters,\n\t\t\t   u32 *cluster_start,\n\t\t\t   u32 *num_clusters)\n{\n\tint status;\n\tunsigned int bits_wanted = max_clusters;\n\tstruct ocfs2_suballoc_result res = { .sr_blkno = 0, };\n\tstruct ocfs2_super *osb = OCFS2_SB(ac->ac_inode->i_sb);\n\n\tBUG_ON(ac->ac_bits_given >= ac->ac_bits_wanted);\n\n\tBUG_ON(ac->ac_which != OCFS2_AC_USE_LOCAL\n\t       && ac->ac_which != OCFS2_AC_USE_MAIN);\n\n\tif (ac->ac_which == OCFS2_AC_USE_LOCAL) {\n\t\tWARN_ON(min_clusters > 1);\n\n\t\tstatus = ocfs2_claim_local_alloc_bits(osb,\n\t\t\t\t\t\t      handle,\n\t\t\t\t\t\t      ac,\n\t\t\t\t\t\t      bits_wanted,\n\t\t\t\t\t\t      cluster_start,\n\t\t\t\t\t\t      num_clusters);\n\t\tif (!status)\n\t\t\tatomic_inc(&osb->alloc_stats.local_data);\n\t} else {\n\t\tif (min_clusters > (osb->bitmap_cpg - 1)) {\n\t\t\t/* The only paths asking for contiguousness\n\t\t\t * should know about this already. */\n\t\t\tmlog(ML_ERROR, \"minimum allocation requested %u exceeds \"\n\t\t\t     \"group bitmap size %u!\\n\", min_clusters,\n\t\t\t     osb->bitmap_cpg);\n\t\t\tstatus = -ENOSPC;\n\t\t\tgoto bail;\n\t\t}\n\t\t/* clamp the current request down to a realistic size. */\n\t\tif (bits_wanted > (osb->bitmap_cpg - 1))\n\t\t\tbits_wanted = osb->bitmap_cpg - 1;\n\n\t\tstatus = ocfs2_claim_suballoc_bits(ac,\n\t\t\t\t\t\t   handle,\n\t\t\t\t\t\t   bits_wanted,\n\t\t\t\t\t\t   min_clusters,\n\t\t\t\t\t\t   &res);\n\t\tif (!status) {\n\t\t\tBUG_ON(res.sr_blkno); /* cluster alloc can't set */\n\t\t\t*cluster_start =\n\t\t\t\tocfs2_desc_bitmap_to_cluster_off(ac->ac_inode,\n\t\t\t\t\t\t\t\t res.sr_bg_blkno,\n\t\t\t\t\t\t\t\t res.sr_bit_offset);\n\t\t\tatomic_inc(&osb->alloc_stats.bitmap_data);\n\t\t\t*num_clusters = res.sr_bits;\n\t\t}\n\t}\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tac->ac_bits_given += *num_clusters;\n\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_clear_ext_refcount",
          "args": [
            "handle",
            "&context->data_et",
            "cpos",
            "p_cluster",
            "set_len",
            "e_flags",
            "context->meta_ac",
            "&context->dealloc"
          ],
          "line": 3284
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_ext_refcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "3069-3127",
          "snippet": "static int ocfs2_clear_ext_refcount(handle_t *handle,\n\t\t\t\t    struct ocfs2_extent_tree *et,\n\t\t\t\t    u32 cpos, u32 p_cluster, u32 len,\n\t\t\t\t    unsigned int ext_flags,\n\t\t\t\t    struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t    struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret, index;\n\tstruct ocfs2_extent_rec replace_rec;\n\tstruct ocfs2_path *path = NULL;\n\tstruct ocfs2_extent_list *el;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(et->et_ci);\n\tu64 ino = ocfs2_metadata_cache_owner(et->et_ci);\n\n\ttrace_ocfs2_clear_ext_refcount((unsigned long long)ino,\n\t\t\t\t       cpos, len, p_cluster, ext_flags);\n\n\tmemset(&replace_rec, 0, sizeof(replace_rec));\n\treplace_rec.e_cpos = cpu_to_le32(cpos);\n\treplace_rec.e_leaf_clusters = cpu_to_le16(len);\n\treplace_rec.e_blkno = cpu_to_le64(ocfs2_clusters_to_blocks(sb,\n\t\t\t\t\t\t\t\t   p_cluster));\n\treplace_rec.e_flags = ext_flags;\n\treplace_rec.e_flags &= ~OCFS2_EXT_REFCOUNTED;\n\n\tpath = ocfs2_new_path_from_et(et);\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_path(et->et_ci, path, cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tel = path_leaf_el(path);\n\n\tindex = ocfs2_search_extent_list(el, cpos);\n\tif (index == -1) {\n\t\tocfs2_error(sb,\n\t\t\t    \"Inode %llu has an extent at cpos %u which can no \"\n\t\t\t    \"longer be found.\\n\",\n\t\t\t    (unsigned long long)ino, cpos);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_split_extent(handle, et, path, index,\n\t\t\t\t &replace_rec, meta_ac, dealloc);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\tocfs2_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_clear_ext_refcount(handle_t *handle,\n\t\t\t\t    struct ocfs2_extent_tree *et,\n\t\t\t\t    u32 cpos, u32 p_cluster, u32 len,\n\t\t\t\t    unsigned int ext_flags,\n\t\t\t\t    struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t    struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret, index;\n\tstruct ocfs2_extent_rec replace_rec;\n\tstruct ocfs2_path *path = NULL;\n\tstruct ocfs2_extent_list *el;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(et->et_ci);\n\tu64 ino = ocfs2_metadata_cache_owner(et->et_ci);\n\n\ttrace_ocfs2_clear_ext_refcount((unsigned long long)ino,\n\t\t\t\t       cpos, len, p_cluster, ext_flags);\n\n\tmemset(&replace_rec, 0, sizeof(replace_rec));\n\treplace_rec.e_cpos = cpu_to_le32(cpos);\n\treplace_rec.e_leaf_clusters = cpu_to_le16(len);\n\treplace_rec.e_blkno = cpu_to_le64(ocfs2_clusters_to_blocks(sb,\n\t\t\t\t\t\t\t\t   p_cluster));\n\treplace_rec.e_flags = ext_flags;\n\treplace_rec.e_flags &= ~OCFS2_EXT_REFCOUNTED;\n\n\tpath = ocfs2_new_path_from_et(et);\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_path(et->et_ci, path, cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tel = path_leaf_el(path);\n\n\tindex = ocfs2_search_extent_list(el, cpos);\n\tif (index == -1) {\n\t\tocfs2_error(sb,\n\t\t\t    \"Inode %llu has an extent at cpos %u which can no \"\n\t\t\t    \"longer be found.\\n\",\n\t\t\t    (unsigned long long)ino, cpos);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_split_extent(handle, et, path, index,\n\t\t\t\t &replace_rec, meta_ac, dealloc);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\tocfs2_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rec.r_refcount"
          ],
          "line": 3282
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "(u64)p_cluster + num_clusters",
            "le64_to_cpu(rec.r_cpos) +\n\t\t\t      le32_to_cpu(rec.r_clusters)"
          ],
          "line": 3271
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_hamming_encode_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
          "lines": "154-157",
          "snippet": "u32 ocfs2_hamming_encode_block(void *data, unsigned int blocksize)\n{\n\treturn ocfs2_hamming_encode(0, data, blocksize * 8, 0);\n}",
          "includes": [
            "#include \"blockcheck.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nu32 ocfs2_hamming_encode_block(void *data, unsigned int blocksize)\n{\n\treturn ocfs2_hamming_encode(0, data, blocksize * 8, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "rec.r_cpos"
          ],
          "line": 3272
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!rec.r_refcount"
          ],
          "line": 3270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_refcount_rec",
          "args": [
            "ref_ci",
            "context->ref_root_bh",
            "p_cluster",
            "num_clusters",
            "&rec",
            "&index",
            "&ref_leaf_bh"
          ],
          "line": 3262
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_get_refcount_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "1066-1150",
          "snippet": "static int ocfs2_get_refcount_rec(struct ocfs2_caching_info *ci,\n\t\t\t\t  struct buffer_head *ref_root_bh,\n\t\t\t\t  u64 cpos, unsigned int len,\n\t\t\t\t  struct ocfs2_refcount_rec *ret_rec,\n\t\t\t\t  int *index,\n\t\t\t\t  struct buffer_head **ret_bh)\n{\n\tint ret = 0, i, found;\n\tu32 low_cpos, uninitialized_var(cpos_end);\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec = NULL;\n\tstruct ocfs2_extent_block *eb = NULL;\n\tstruct buffer_head *eb_bh = NULL, *ref_leaf_bh = NULL;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\n\tstruct ocfs2_refcount_block *rb =\n\t\t\t(struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\n\tif (!(le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL)) {\n\t\tocfs2_find_refcount_rec_in_rl(ci, ref_root_bh, cpos, len,\n\t\t\t\t\t      ret_rec, index);\n\t\t*ret_bh = ref_root_bh;\n\t\tget_bh(ref_root_bh);\n\t\treturn 0;\n\t}\n\n\tel = &rb->rf_list;\n\tlow_cpos = cpos & OCFS2_32BIT_POS_MASK;\n\n\tif (el->l_tree_depth) {\n\t\tret = ocfs2_find_leaf(ci, el, low_cpos, &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tocfs2_error(sb,\n\t\t\t\"refcount tree %llu has non zero tree \"\n\t\t\t\"depth in leaf btree tree block %llu\\n\",\n\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t\t(unsigned long long)eb_bh->b_blocknr);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfound = 0;\n\tfor (i = le16_to_cpu(el->l_next_free_rec) - 1; i >= 0; i--) {\n\t\trec = &el->l_recs[i];\n\n\t\tif (le32_to_cpu(rec->e_cpos) <= low_cpos) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found) {\n\t\tret = ocfs2_get_refcount_cpos_end(ci, ref_root_bh,\n\t\t\t\t\t\t  eb, el, i, &cpos_end);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (cpos_end < low_cpos + len)\n\t\t\tlen = cpos_end - low_cpos;\n\t}\n\n\tret = ocfs2_read_refcount_block(ci, le64_to_cpu(rec->e_blkno),\n\t\t\t\t\t&ref_leaf_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_find_refcount_rec_in_rl(ci, ref_leaf_bh, cpos, len,\n\t\t\t\t      ret_rec, index);\n\t*ret_bh = ref_leaf_bh;\nout:\n\tbrelse(eb_bh);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_get_refcount_rec(struct ocfs2_caching_info *ci,\n\t\t\t\t  struct buffer_head *ref_root_bh,\n\t\t\t\t  u64 cpos, unsigned int len,\n\t\t\t\t  struct ocfs2_refcount_rec *ret_rec,\n\t\t\t\t  int *index,\n\t\t\t\t  struct buffer_head **ret_bh)\n{\n\tint ret = 0, i, found;\n\tu32 low_cpos, uninitialized_var(cpos_end);\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec = NULL;\n\tstruct ocfs2_extent_block *eb = NULL;\n\tstruct buffer_head *eb_bh = NULL, *ref_leaf_bh = NULL;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\n\tstruct ocfs2_refcount_block *rb =\n\t\t\t(struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\n\tif (!(le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL)) {\n\t\tocfs2_find_refcount_rec_in_rl(ci, ref_root_bh, cpos, len,\n\t\t\t\t\t      ret_rec, index);\n\t\t*ret_bh = ref_root_bh;\n\t\tget_bh(ref_root_bh);\n\t\treturn 0;\n\t}\n\n\tel = &rb->rf_list;\n\tlow_cpos = cpos & OCFS2_32BIT_POS_MASK;\n\n\tif (el->l_tree_depth) {\n\t\tret = ocfs2_find_leaf(ci, el, low_cpos, &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tocfs2_error(sb,\n\t\t\t\"refcount tree %llu has non zero tree \"\n\t\t\t\"depth in leaf btree tree block %llu\\n\",\n\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t\t(unsigned long long)eb_bh->b_blocknr);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfound = 0;\n\tfor (i = le16_to_cpu(el->l_next_free_rec) - 1; i >= 0; i--) {\n\t\trec = &el->l_recs[i];\n\n\t\tif (le32_to_cpu(rec->e_cpos) <= low_cpos) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found) {\n\t\tret = ocfs2_get_refcount_cpos_end(ci, ref_root_bh,\n\t\t\t\t\t\t  eb, el, i, &cpos_end);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (cpos_end < low_cpos + len)\n\t\t\tlen = cpos_end - low_cpos;\n\t}\n\n\tret = ocfs2_read_refcount_block(ci, le64_to_cpu(rec->e_blkno),\n\t\t\t\t\t&ref_leaf_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_find_refcount_rec_in_rl(ci, ref_leaf_bh, cpos, len,\n\t\t\t\t      ret_rec, index);\n\t*ret_bh = ref_leaf_bh;\nout:\n\tbrelse(eb_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 3254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 3253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "credits"
          ],
          "line": 3252
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_lock_refcount_allocators",
          "args": [
            "sb",
            "p_cluster",
            "num_clusters",
            "&context->data_et",
            "ref_ci",
            "context->ref_root_bh",
            "&context->meta_ac",
            "&context->data_ac",
            "&credits"
          ],
          "line": 3237
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_refcount_allocators",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "2857-2913",
          "snippet": "static int ocfs2_lock_refcount_allocators(struct super_block *sb,\n\t\t\t\t\tu32 p_cluster, u32 num_clusters,\n\t\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\t\tstruct ocfs2_caching_info *ref_ci,\n\t\t\t\t\tstruct buffer_head *ref_root_bh,\n\t\t\t\t\tstruct ocfs2_alloc_context **meta_ac,\n\t\t\t\t\tstruct ocfs2_alloc_context **data_ac,\n\t\t\t\t\tint *credits)\n{\n\tint ret = 0, meta_add = 0;\n\tint num_free_extents = ocfs2_num_free_extents(OCFS2_SB(sb), et);\n\n\tif (num_free_extents < 0) {\n\t\tret = num_free_extents;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (num_free_extents < num_clusters + 2)\n\t\tmeta_add =\n\t\t\tocfs2_extend_meta_needed(et->et_root_el);\n\n\t*credits += ocfs2_calc_extend_credits(sb, et->et_root_el);\n\n\tret = ocfs2_calc_refcount_meta_credits(sb, ref_ci, ref_root_bh,\n\t\t\t\t\t       p_cluster, num_clusters,\n\t\t\t\t\t       &meta_add, credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_lock_refcount_allocators(meta_add, *credits);\n\tret = ocfs2_reserve_new_metadata_blocks(OCFS2_SB(sb), meta_add,\n\t\t\t\t\t\tmeta_ac);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (data_ac) {\n\t\tret = ocfs2_reserve_clusters(OCFS2_SB(sb), num_clusters,\n\t\t\t\t\t     data_ac);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\nout:\n\tif (ret) {\n\t\tif (*meta_ac) {\n\t\t\tocfs2_free_alloc_context(*meta_ac);\n\t\t\t*meta_ac = NULL;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_lock_refcount_allocators(struct super_block *sb,\n\t\t\t\t\tu32 p_cluster, u32 num_clusters,\n\t\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\t\tstruct ocfs2_caching_info *ref_ci,\n\t\t\t\t\tstruct buffer_head *ref_root_bh,\n\t\t\t\t\tstruct ocfs2_alloc_context **meta_ac,\n\t\t\t\t\tstruct ocfs2_alloc_context **data_ac,\n\t\t\t\t\tint *credits)\n{\n\tint ret = 0, meta_add = 0;\n\tint num_free_extents = ocfs2_num_free_extents(OCFS2_SB(sb), et);\n\n\tif (num_free_extents < 0) {\n\t\tret = num_free_extents;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (num_free_extents < num_clusters + 2)\n\t\tmeta_add =\n\t\t\tocfs2_extend_meta_needed(et->et_root_el);\n\n\t*credits += ocfs2_calc_extend_credits(sb, et->et_root_el);\n\n\tret = ocfs2_calc_refcount_meta_credits(sb, ref_ci, ref_root_bh,\n\t\t\t\t\t       p_cluster, num_clusters,\n\t\t\t\t\t       &meta_add, credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_lock_refcount_allocators(meta_add, *credits);\n\tret = ocfs2_reserve_new_metadata_blocks(OCFS2_SB(sb), meta_add,\n\t\t\t\t\t\tmeta_ac);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (data_ac) {\n\t\tret = ocfs2_reserve_clusters(OCFS2_SB(sb), num_clusters,\n\t\t\t\t\t     data_ac);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\nout:\n\tif (ret) {\n\t\tif (*meta_ac) {\n\t\t\tocfs2_free_alloc_context(*meta_ac);\n\t\t\t*meta_ac = NULL;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_make_clusters_writable",
          "args": [
            "cpos",
            "p_cluster",
            "num_clusters",
            "e_flags"
          ],
          "line": 3234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 3228
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_make_clusters_writable(struct super_block *sb,\n\t\t\t\t\tstruct ocfs2_cow_context *context,\n\t\t\t\t\tu32 cpos, u32 p_cluster,\n\t\t\t\t\tu32 num_clusters, unsigned int e_flags)\n{\n\tint ret, delete, index, credits =  0;\n\tu32 new_bit, new_len, orig_num_clusters;\n\tunsigned int set_len;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\thandle_t *handle;\n\tstruct buffer_head *ref_leaf_bh = NULL;\n\tstruct ocfs2_caching_info *ref_ci = &context->ref_tree->rf_ci;\n\tstruct ocfs2_refcount_rec rec;\n\n\ttrace_ocfs2_make_clusters_writable(cpos, p_cluster,\n\t\t\t\t\t   num_clusters, e_flags);\n\n\tret = ocfs2_lock_refcount_allocators(sb, p_cluster, num_clusters,\n\t\t\t\t\t     &context->data_et,\n\t\t\t\t\t     ref_ci,\n\t\t\t\t\t     context->ref_root_bh,\n\t\t\t\t\t     &context->meta_ac,\n\t\t\t\t\t     &context->data_ac, &credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tif (context->post_refcount)\n\t\tcredits += context->post_refcount->credits;\n\n\tcredits += context->extra_credits;\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\torig_num_clusters = num_clusters;\n\n\twhile (num_clusters) {\n\t\tret = ocfs2_get_refcount_rec(ref_ci, context->ref_root_bh,\n\t\t\t\t\t     p_cluster, num_clusters,\n\t\t\t\t\t     &rec, &index, &ref_leaf_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_commit;\n\t\t}\n\n\t\tBUG_ON(!rec.r_refcount);\n\t\tset_len = min((u64)p_cluster + num_clusters,\n\t\t\t      le64_to_cpu(rec.r_cpos) +\n\t\t\t      le32_to_cpu(rec.r_clusters)) - p_cluster;\n\n\t\t/*\n\t\t * There are many different situation here.\n\t\t * 1. If refcount == 1, remove the flag and don't COW.\n\t\t * 2. If refcount > 1, allocate clusters.\n\t\t *    Here we may not allocate r_len once at a time, so continue\n\t\t *    until we reach num_clusters.\n\t\t */\n\t\tif (le32_to_cpu(rec.r_refcount) == 1) {\n\t\t\tdelete = 0;\n\t\t\tret = ocfs2_clear_ext_refcount(handle,\n\t\t\t\t\t\t       &context->data_et,\n\t\t\t\t\t\t       cpos, p_cluster,\n\t\t\t\t\t\t       set_len, e_flags,\n\t\t\t\t\t\t       context->meta_ac,\n\t\t\t\t\t\t       &context->dealloc);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out_commit;\n\t\t\t}\n\t\t} else {\n\t\t\tdelete = 1;\n\n\t\t\tret = __ocfs2_claim_clusters(handle,\n\t\t\t\t\t\t     context->data_ac,\n\t\t\t\t\t\t     1, set_len,\n\t\t\t\t\t\t     &new_bit, &new_len);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out_commit;\n\t\t\t}\n\n\t\t\tret = ocfs2_replace_clusters(handle, context,\n\t\t\t\t\t\t     cpos, p_cluster, new_bit,\n\t\t\t\t\t\t     new_len, e_flags);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out_commit;\n\t\t\t}\n\t\t\tset_len = new_len;\n\t\t}\n\n\t\tret = __ocfs2_decrease_refcount(handle, ref_ci,\n\t\t\t\t\t\tcontext->ref_root_bh,\n\t\t\t\t\t\tp_cluster, set_len,\n\t\t\t\t\t\tcontext->meta_ac,\n\t\t\t\t\t\t&context->dealloc, delete);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_commit;\n\t\t}\n\n\t\tcpos += set_len;\n\t\tp_cluster += set_len;\n\t\tnum_clusters -= set_len;\n\t\tbrelse(ref_leaf_bh);\n\t\tref_leaf_bh = NULL;\n\t}\n\n\t/* handle any post_cow action. */\n\tif (context->post_refcount && context->post_refcount->func) {\n\t\tret = context->post_refcount->func(context->inode, handle,\n\t\t\t\t\t\tcontext->post_refcount->para);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_commit;\n\t\t}\n\t}\n\n\t/*\n\t * Here we should write the new page out first if we are\n\t * in write-back mode.\n\t */\n\tif (context->get_clusters == ocfs2_di_get_clusters) {\n\t\tret = ocfs2_cow_sync_writeback(sb, context->inode, cpos,\n\t\t\t\t\t       orig_num_clusters);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\n\nout:\n\tif (context->data_ac) {\n\t\tocfs2_free_alloc_context(context->data_ac);\n\t\tcontext->data_ac = NULL;\n\t}\n\tif (context->meta_ac) {\n\t\tocfs2_free_alloc_context(context->meta_ac);\n\t\tcontext->meta_ac = NULL;\n\t}\n\tbrelse(ref_leaf_bh);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_di_get_clusters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "3211-3218",
    "snippet": "static int ocfs2_di_get_clusters(struct ocfs2_cow_context *context,\n\t\t\t\t u32 v_cluster, u32 *p_cluster,\n\t\t\t\t u32 *num_clusters,\n\t\t\t\t unsigned int *extent_flags)\n{\n\treturn ocfs2_get_clusters(context->inode, v_cluster, p_cluster,\n\t\t\t\t  num_clusters, extent_flags);\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_get_clusters",
          "args": [
            "context->inode",
            "v_cluster",
            "p_cluster",
            "num_clusters",
            "extent_flags"
          ],
          "line": 3216
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_get_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/extent_map.c",
          "lines": "608-665",
          "snippet": "int ocfs2_get_clusters(struct inode *inode, u32 v_cluster,\n\t\t       u32 *p_cluster, u32 *num_clusters,\n\t\t       unsigned int *extent_flags)\n{\n\tint ret;\n\tunsigned int uninitialized_var(hole_len), flags = 0;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_extent_rec rec;\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tret = -ERANGE;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_extent_map_lookup(inode, v_cluster, p_cluster,\n\t\t\t\t      num_clusters, extent_flags);\n\tif (ret == 0)\n\t\tgoto out;\n\n\tret = ocfs2_read_inode_block(inode, &di_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_get_clusters_nocache(inode, di_bh, v_cluster, &hole_len,\n\t\t\t\t\t &rec, NULL);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (rec.e_blkno == 0ULL) {\n\t\t/*\n\t\t * A hole was found. Return some canned values that\n\t\t * callers can key on. If asked for, num_clusters will\n\t\t * be populated with the size of the hole.\n\t\t */\n\t\t*p_cluster = 0;\n\t\tif (num_clusters) {\n\t\t\t*num_clusters = hole_len;\n\t\t}\n\t} else {\n\t\tocfs2_relative_extent_offsets(inode->i_sb, v_cluster, &rec,\n\t\t\t\t\t      p_cluster, num_clusters);\n\t\tflags = rec.e_flags;\n\n\t\tocfs2_extent_map_insert_rec(inode, &rec);\n\t}\n\n\tif (extent_flags)\n\t\t*extent_flags = flags;\n\nout:\n\tbrelse(di_bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/fiemap.h>",
            "#include <linux/types.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/fiemap.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n\nint ocfs2_get_clusters(struct inode *inode, u32 v_cluster,\n\t\t       u32 *p_cluster, u32 *num_clusters,\n\t\t       unsigned int *extent_flags)\n{\n\tint ret;\n\tunsigned int uninitialized_var(hole_len), flags = 0;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_extent_rec rec;\n\n\tif (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {\n\t\tret = -ERANGE;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_extent_map_lookup(inode, v_cluster, p_cluster,\n\t\t\t\t      num_clusters, extent_flags);\n\tif (ret == 0)\n\t\tgoto out;\n\n\tret = ocfs2_read_inode_block(inode, &di_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_get_clusters_nocache(inode, di_bh, v_cluster, &hole_len,\n\t\t\t\t\t &rec, NULL);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (rec.e_blkno == 0ULL) {\n\t\t/*\n\t\t * A hole was found. Return some canned values that\n\t\t * callers can key on. If asked for, num_clusters will\n\t\t * be populated with the size of the hole.\n\t\t */\n\t\t*p_cluster = 0;\n\t\tif (num_clusters) {\n\t\t\t*num_clusters = hole_len;\n\t\t}\n\t} else {\n\t\tocfs2_relative_extent_offsets(inode->i_sb, v_cluster, &rec,\n\t\t\t\t\t      p_cluster, num_clusters);\n\t\tflags = rec.e_flags;\n\n\t\tocfs2_extent_map_insert_rec(inode, &rec);\n\t}\n\n\tif (extent_flags)\n\t\t*extent_flags = flags;\n\nout:\n\tbrelse(di_bh);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_di_get_clusters(struct ocfs2_cow_context *context,\n\t\t\t\t u32 v_cluster, u32 *p_cluster,\n\t\t\t\t u32 *num_clusters,\n\t\t\t\t unsigned int *extent_flags)\n{\n\treturn ocfs2_get_clusters(context->inode, v_cluster, p_cluster,\n\t\t\t\t  num_clusters, extent_flags);\n}"
  },
  {
    "function_name": "ocfs2_cow_sync_writeback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "3161-3209",
    "snippet": "int ocfs2_cow_sync_writeback(struct super_block *sb,\n\t\t\t     struct inode *inode,\n\t\t\t     u32 cpos, u32 num_clusters)\n{\n\tint ret = 0;\n\tloff_t offset, end, map_end;\n\tpgoff_t page_index;\n\tstruct page *page;\n\n\tif (ocfs2_should_order_data(inode))\n\t\treturn 0;\n\n\toffset = ((loff_t)cpos) << OCFS2_SB(sb)->s_clustersize_bits;\n\tend = offset + (num_clusters << OCFS2_SB(sb)->s_clustersize_bits);\n\n\tret = filemap_fdatawrite_range(inode->i_mapping,\n\t\t\t\t       offset, end - 1);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\twhile (offset < end) {\n\t\tpage_index = offset >> PAGE_CACHE_SHIFT;\n\t\tmap_end = ((loff_t)page_index + 1) << PAGE_CACHE_SHIFT;\n\t\tif (map_end > end)\n\t\t\tmap_end = end;\n\n\t\tpage = find_or_create_page(inode->i_mapping,\n\t\t\t\t\t   page_index, GFP_NOFS);\n\t\tBUG_ON(!page);\n\n\t\twait_on_page_writeback(page);\n\t\tif (PageError(page)) {\n\t\t\tret = -EIO;\n\t\t\tmlog_errno(ret);\n\t\t} else\n\t\t\tmark_page_accessed(page);\n\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tpage = NULL;\n\t\toffset = map_end;\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 3201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 3200
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_page_accessed",
          "args": [
            "page"
          ],
          "line": 3198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageError",
          "args": [
            "page"
          ],
          "line": 3194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_on_page_writeback",
          "args": [
            "page"
          ],
          "line": 3193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!page"
          ],
          "line": 3191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_or_create_page",
          "args": [
            "inode->i_mapping",
            "page_index",
            "GFP_NOFS"
          ],
          "line": 3189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "filemap_fdatawrite_range",
          "args": [
            "inode->i_mapping",
            "offset",
            "end - 1"
          ],
          "line": 3176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 3174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 3173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_should_order_data",
          "args": [
            "inode"
          ],
          "line": 3170
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_should_order_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "474-481",
          "snippet": "static inline int ocfs2_should_order_data(struct inode *inode)\n{\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 0;\n\tif (OCFS2_SB(inode->i_sb)->s_mount_opt & OCFS2_MOUNT_DATA_WRITEBACK)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline int ocfs2_should_order_data(struct inode *inode)\n{\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn 0;\n\tif (OCFS2_SB(inode->i_sb)->s_mount_opt & OCFS2_MOUNT_DATA_WRITEBACK)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nint ocfs2_cow_sync_writeback(struct super_block *sb,\n\t\t\t     struct inode *inode,\n\t\t\t     u32 cpos, u32 num_clusters)\n{\n\tint ret = 0;\n\tloff_t offset, end, map_end;\n\tpgoff_t page_index;\n\tstruct page *page;\n\n\tif (ocfs2_should_order_data(inode))\n\t\treturn 0;\n\n\toffset = ((loff_t)cpos) << OCFS2_SB(sb)->s_clustersize_bits;\n\tend = offset + (num_clusters << OCFS2_SB(sb)->s_clustersize_bits);\n\n\tret = filemap_fdatawrite_range(inode->i_mapping,\n\t\t\t\t       offset, end - 1);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\twhile (offset < end) {\n\t\tpage_index = offset >> PAGE_CACHE_SHIFT;\n\t\tmap_end = ((loff_t)page_index + 1) << PAGE_CACHE_SHIFT;\n\t\tif (map_end > end)\n\t\t\tmap_end = end;\n\n\t\tpage = find_or_create_page(inode->i_mapping,\n\t\t\t\t\t   page_index, GFP_NOFS);\n\t\tBUG_ON(!page);\n\n\t\twait_on_page_writeback(page);\n\t\tif (PageError(page)) {\n\t\t\tret = -EIO;\n\t\t\tmlog_errno(ret);\n\t\t} else\n\t\t\tmark_page_accessed(page);\n\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tpage = NULL;\n\t\toffset = map_end;\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_replace_clusters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "3129-3159",
    "snippet": "static int ocfs2_replace_clusters(handle_t *handle,\n\t\t\t\t  struct ocfs2_cow_context *context,\n\t\t\t\t  u32 cpos, u32 old,\n\t\t\t\t  u32 new, u32 len,\n\t\t\t\t  unsigned int ext_flags)\n{\n\tint ret;\n\tstruct ocfs2_caching_info *ci = context->data_et.et_ci;\n\tu64 ino = ocfs2_metadata_cache_owner(ci);\n\n\ttrace_ocfs2_replace_clusters((unsigned long long)ino,\n\t\t\t\t     cpos, old, new, len, ext_flags);\n\n\t/*If the old clusters is unwritten, no need to duplicate. */\n\tif (!(ext_flags & OCFS2_EXT_UNWRITTEN)) {\n\t\tret = context->cow_duplicate_clusters(handle, context->inode,\n\t\t\t\t\t\t      cpos, old, new, len);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ocfs2_clear_ext_refcount(handle, &context->data_et,\n\t\t\t\t       cpos, new, len, ext_flags,\n\t\t\t\t       context->meta_ac, &context->dealloc);\n\tif (ret)\n\t\tmlog_errno(ret);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_clear_ext_refcount",
          "args": [
            "handle",
            "&context->data_et",
            "cpos",
            "new",
            "len",
            "ext_flags",
            "context->meta_ac",
            "&context->dealloc"
          ],
          "line": 3152
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clear_ext_refcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "3069-3127",
          "snippet": "static int ocfs2_clear_ext_refcount(handle_t *handle,\n\t\t\t\t    struct ocfs2_extent_tree *et,\n\t\t\t\t    u32 cpos, u32 p_cluster, u32 len,\n\t\t\t\t    unsigned int ext_flags,\n\t\t\t\t    struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t    struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret, index;\n\tstruct ocfs2_extent_rec replace_rec;\n\tstruct ocfs2_path *path = NULL;\n\tstruct ocfs2_extent_list *el;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(et->et_ci);\n\tu64 ino = ocfs2_metadata_cache_owner(et->et_ci);\n\n\ttrace_ocfs2_clear_ext_refcount((unsigned long long)ino,\n\t\t\t\t       cpos, len, p_cluster, ext_flags);\n\n\tmemset(&replace_rec, 0, sizeof(replace_rec));\n\treplace_rec.e_cpos = cpu_to_le32(cpos);\n\treplace_rec.e_leaf_clusters = cpu_to_le16(len);\n\treplace_rec.e_blkno = cpu_to_le64(ocfs2_clusters_to_blocks(sb,\n\t\t\t\t\t\t\t\t   p_cluster));\n\treplace_rec.e_flags = ext_flags;\n\treplace_rec.e_flags &= ~OCFS2_EXT_REFCOUNTED;\n\n\tpath = ocfs2_new_path_from_et(et);\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_path(et->et_ci, path, cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tel = path_leaf_el(path);\n\n\tindex = ocfs2_search_extent_list(el, cpos);\n\tif (index == -1) {\n\t\tocfs2_error(sb,\n\t\t\t    \"Inode %llu has an extent at cpos %u which can no \"\n\t\t\t    \"longer be found.\\n\",\n\t\t\t    (unsigned long long)ino, cpos);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_split_extent(handle, et, path, index,\n\t\t\t\t &replace_rec, meta_ac, dealloc);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\tocfs2_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_clear_ext_refcount(handle_t *handle,\n\t\t\t\t    struct ocfs2_extent_tree *et,\n\t\t\t\t    u32 cpos, u32 p_cluster, u32 len,\n\t\t\t\t    unsigned int ext_flags,\n\t\t\t\t    struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t    struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret, index;\n\tstruct ocfs2_extent_rec replace_rec;\n\tstruct ocfs2_path *path = NULL;\n\tstruct ocfs2_extent_list *el;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(et->et_ci);\n\tu64 ino = ocfs2_metadata_cache_owner(et->et_ci);\n\n\ttrace_ocfs2_clear_ext_refcount((unsigned long long)ino,\n\t\t\t\t       cpos, len, p_cluster, ext_flags);\n\n\tmemset(&replace_rec, 0, sizeof(replace_rec));\n\treplace_rec.e_cpos = cpu_to_le32(cpos);\n\treplace_rec.e_leaf_clusters = cpu_to_le16(len);\n\treplace_rec.e_blkno = cpu_to_le64(ocfs2_clusters_to_blocks(sb,\n\t\t\t\t\t\t\t\t   p_cluster));\n\treplace_rec.e_flags = ext_flags;\n\treplace_rec.e_flags &= ~OCFS2_EXT_REFCOUNTED;\n\n\tpath = ocfs2_new_path_from_et(et);\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_path(et->et_ci, path, cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tel = path_leaf_el(path);\n\n\tindex = ocfs2_search_extent_list(el, cpos);\n\tif (index == -1) {\n\t\tocfs2_error(sb,\n\t\t\t    \"Inode %llu has an extent at cpos %u which can no \"\n\t\t\t    \"longer be found.\\n\",\n\t\t\t    (unsigned long long)ino, cpos);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_split_extent(handle, et, path, index,\n\t\t\t\t &replace_rec, meta_ac, dealloc);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\tocfs2_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "context->cow_duplicate_clusters",
          "args": [
            "handle",
            "context->inode",
            "cpos",
            "old",
            "new",
            "len"
          ],
          "line": 3144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_replace_clusters",
          "args": [
            "(unsigned long long)ino",
            "cpos",
            "old",
            "new",
            "len",
            "ext_flags"
          ],
          "line": 3139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_owner",
          "args": [
            "ci"
          ],
          "line": 3137
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "72-77",
          "snippet": "u64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nu64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_replace_clusters(handle_t *handle,\n\t\t\t\t  struct ocfs2_cow_context *context,\n\t\t\t\t  u32 cpos, u32 old,\n\t\t\t\t  u32 new, u32 len,\n\t\t\t\t  unsigned int ext_flags)\n{\n\tint ret;\n\tstruct ocfs2_caching_info *ci = context->data_et.et_ci;\n\tu64 ino = ocfs2_metadata_cache_owner(ci);\n\n\ttrace_ocfs2_replace_clusters((unsigned long long)ino,\n\t\t\t\t     cpos, old, new, len, ext_flags);\n\n\t/*If the old clusters is unwritten, no need to duplicate. */\n\tif (!(ext_flags & OCFS2_EXT_UNWRITTEN)) {\n\t\tret = context->cow_duplicate_clusters(handle, context->inode,\n\t\t\t\t\t\t      cpos, old, new, len);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ocfs2_clear_ext_refcount(handle, &context->data_et,\n\t\t\t\t       cpos, new, len, ext_flags,\n\t\t\t\t       context->meta_ac, &context->dealloc);\n\tif (ret)\n\t\tmlog_errno(ret);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_clear_ext_refcount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "3069-3127",
    "snippet": "static int ocfs2_clear_ext_refcount(handle_t *handle,\n\t\t\t\t    struct ocfs2_extent_tree *et,\n\t\t\t\t    u32 cpos, u32 p_cluster, u32 len,\n\t\t\t\t    unsigned int ext_flags,\n\t\t\t\t    struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t    struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret, index;\n\tstruct ocfs2_extent_rec replace_rec;\n\tstruct ocfs2_path *path = NULL;\n\tstruct ocfs2_extent_list *el;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(et->et_ci);\n\tu64 ino = ocfs2_metadata_cache_owner(et->et_ci);\n\n\ttrace_ocfs2_clear_ext_refcount((unsigned long long)ino,\n\t\t\t\t       cpos, len, p_cluster, ext_flags);\n\n\tmemset(&replace_rec, 0, sizeof(replace_rec));\n\treplace_rec.e_cpos = cpu_to_le32(cpos);\n\treplace_rec.e_leaf_clusters = cpu_to_le16(len);\n\treplace_rec.e_blkno = cpu_to_le64(ocfs2_clusters_to_blocks(sb,\n\t\t\t\t\t\t\t\t   p_cluster));\n\treplace_rec.e_flags = ext_flags;\n\treplace_rec.e_flags &= ~OCFS2_EXT_REFCOUNTED;\n\n\tpath = ocfs2_new_path_from_et(et);\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_path(et->et_ci, path, cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tel = path_leaf_el(path);\n\n\tindex = ocfs2_search_extent_list(el, cpos);\n\tif (index == -1) {\n\t\tocfs2_error(sb,\n\t\t\t    \"Inode %llu has an extent at cpos %u which can no \"\n\t\t\t    \"longer be found.\\n\",\n\t\t\t    (unsigned long long)ino, cpos);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_split_extent(handle, et, path, index,\n\t\t\t\t &replace_rec, meta_ac, dealloc);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\tocfs2_free_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_free_path",
          "args": [
            "path"
          ],
          "line": 3125
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "609-615",
          "snippet": "void ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_split_extent",
          "args": [
            "handle",
            "et",
            "path",
            "index",
            "&replace_rec",
            "meta_ac",
            "dealloc"
          ],
          "line": 3119
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_split_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "5022-5103",
          "snippet": "int ocfs2_split_extent(handle_t *handle,\n\t\t       struct ocfs2_extent_tree *et,\n\t\t       struct ocfs2_path *path,\n\t\t       int split_index,\n\t\t       struct ocfs2_extent_rec *split_rec,\n\t\t       struct ocfs2_alloc_context *meta_ac,\n\t\t       struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret = 0;\n\tstruct ocfs2_extent_list *el = path_leaf_el(path);\n\tstruct buffer_head *last_eb_bh = NULL;\n\tstruct ocfs2_extent_rec *rec = &el->l_recs[split_index];\n\tstruct ocfs2_merge_ctxt ctxt;\n\tstruct ocfs2_extent_list *rightmost_el;\n\n\tif (le32_to_cpu(rec->e_cpos) > le32_to_cpu(split_rec->e_cpos) ||\n\t    ((le32_to_cpu(rec->e_cpos) + le16_to_cpu(rec->e_leaf_clusters)) <\n\t     (le32_to_cpu(split_rec->e_cpos) + le16_to_cpu(split_rec->e_leaf_clusters)))) {\n\t\tret = -EIO;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tctxt.c_contig_type = ocfs2_figure_merge_contig_type(et, path, el,\n\t\t\t\t\t\t\t    split_index,\n\t\t\t\t\t\t\t    split_rec);\n\n\t/*\n\t * The core merge / split code wants to know how much room is\n\t * left in this allocation tree, so we pass the\n\t * rightmost extent list.\n\t */\n\tif (path->p_tree_depth) {\n\t\tstruct ocfs2_extent_block *eb;\n\n\t\tret = ocfs2_read_extent_block(et->et_ci,\n\t\t\t\t\t      ocfs2_et_get_last_eb_blk(et),\n\t\t\t\t\t      &last_eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) last_eb_bh->b_data;\n\t\trightmost_el = &eb->h_list;\n\t} else\n\t\trightmost_el = path_root_el(path);\n\n\tif (rec->e_cpos == split_rec->e_cpos &&\n\t    rec->e_leaf_clusters == split_rec->e_leaf_clusters)\n\t\tctxt.c_split_covers_rec = 1;\n\telse\n\t\tctxt.c_split_covers_rec = 0;\n\n\tctxt.c_has_empty_extent = ocfs2_is_empty_extent(&el->l_recs[0]);\n\n\ttrace_ocfs2_split_extent(split_index, ctxt.c_contig_type,\n\t\t\t\t ctxt.c_has_empty_extent,\n\t\t\t\t ctxt.c_split_covers_rec);\n\n\tif (ctxt.c_contig_type == CONTIG_NONE) {\n\t\tif (ctxt.c_split_covers_rec)\n\t\t\tret = ocfs2_replace_extent_rec(handle, et, path, el,\n\t\t\t\t\t\t       split_index, split_rec);\n\t\telse\n\t\t\tret = ocfs2_split_and_insert(handle, et, path,\n\t\t\t\t\t\t     &last_eb_bh, split_index,\n\t\t\t\t\t\t     split_rec, meta_ac);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t} else {\n\t\tret = ocfs2_try_to_merge_extent(handle, et, path,\n\t\t\t\t\t\tsplit_index, split_rec,\n\t\t\t\t\t\tdealloc, &ctxt);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\nout:\n\tbrelse(last_eb_bh);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nint ocfs2_split_extent(handle_t *handle,\n\t\t       struct ocfs2_extent_tree *et,\n\t\t       struct ocfs2_path *path,\n\t\t       int split_index,\n\t\t       struct ocfs2_extent_rec *split_rec,\n\t\t       struct ocfs2_alloc_context *meta_ac,\n\t\t       struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret = 0;\n\tstruct ocfs2_extent_list *el = path_leaf_el(path);\n\tstruct buffer_head *last_eb_bh = NULL;\n\tstruct ocfs2_extent_rec *rec = &el->l_recs[split_index];\n\tstruct ocfs2_merge_ctxt ctxt;\n\tstruct ocfs2_extent_list *rightmost_el;\n\n\tif (le32_to_cpu(rec->e_cpos) > le32_to_cpu(split_rec->e_cpos) ||\n\t    ((le32_to_cpu(rec->e_cpos) + le16_to_cpu(rec->e_leaf_clusters)) <\n\t     (le32_to_cpu(split_rec->e_cpos) + le16_to_cpu(split_rec->e_leaf_clusters)))) {\n\t\tret = -EIO;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tctxt.c_contig_type = ocfs2_figure_merge_contig_type(et, path, el,\n\t\t\t\t\t\t\t    split_index,\n\t\t\t\t\t\t\t    split_rec);\n\n\t/*\n\t * The core merge / split code wants to know how much room is\n\t * left in this allocation tree, so we pass the\n\t * rightmost extent list.\n\t */\n\tif (path->p_tree_depth) {\n\t\tstruct ocfs2_extent_block *eb;\n\n\t\tret = ocfs2_read_extent_block(et->et_ci,\n\t\t\t\t\t      ocfs2_et_get_last_eb_blk(et),\n\t\t\t\t\t      &last_eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) last_eb_bh->b_data;\n\t\trightmost_el = &eb->h_list;\n\t} else\n\t\trightmost_el = path_root_el(path);\n\n\tif (rec->e_cpos == split_rec->e_cpos &&\n\t    rec->e_leaf_clusters == split_rec->e_leaf_clusters)\n\t\tctxt.c_split_covers_rec = 1;\n\telse\n\t\tctxt.c_split_covers_rec = 0;\n\n\tctxt.c_has_empty_extent = ocfs2_is_empty_extent(&el->l_recs[0]);\n\n\ttrace_ocfs2_split_extent(split_index, ctxt.c_contig_type,\n\t\t\t\t ctxt.c_has_empty_extent,\n\t\t\t\t ctxt.c_split_covers_rec);\n\n\tif (ctxt.c_contig_type == CONTIG_NONE) {\n\t\tif (ctxt.c_split_covers_rec)\n\t\t\tret = ocfs2_replace_extent_rec(handle, et, path, el,\n\t\t\t\t\t\t       split_index, split_rec);\n\t\telse\n\t\t\tret = ocfs2_split_and_insert(handle, et, path,\n\t\t\t\t\t\t     &last_eb_bh, split_index,\n\t\t\t\t\t\t     split_rec, meta_ac);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t} else {\n\t\tret = ocfs2_try_to_merge_extent(handle, et, path,\n\t\t\t\t\t\tsplit_index, split_rec,\n\t\t\t\t\t\tdealloc, &ctxt);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\nout:\n\tbrelse(last_eb_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_error",
          "args": [
            "sb",
            "\"Inode %llu has an extent at cpos %u which can no \"\n\t\t\t    \"longer be found.\\n\"",
            "(unsigned long long)ino",
            "cpos"
          ],
          "line": 3111
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2568-2584",
          "snippet": "void __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic char error_buf[1024];\n\nvoid __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_search_extent_list",
          "args": [
            "el",
            "cpos"
          ],
          "line": 3109
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_search_extent_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "773-795",
          "snippet": "int ocfs2_search_extent_list(struct ocfs2_extent_list *el, u32 v_cluster)\n{\n\tint ret = -1;\n\tint i;\n\tstruct ocfs2_extent_rec *rec;\n\tu32 rec_end, rec_start, clusters;\n\n\tfor(i = 0; i < le16_to_cpu(el->l_next_free_rec); i++) {\n\t\trec = &el->l_recs[i];\n\n\t\trec_start = le32_to_cpu(rec->e_cpos);\n\t\tclusters = ocfs2_rec_clusters(el, rec);\n\n\t\trec_end = rec_start + clusters;\n\n\t\tif (v_cluster >= rec_start && v_cluster < rec_end) {\n\t\t\tret = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\n\nint ocfs2_search_extent_list(struct ocfs2_extent_list *el, u32 v_cluster)\n{\n\tint ret = -1;\n\tint i;\n\tstruct ocfs2_extent_rec *rec;\n\tu32 rec_end, rec_start, clusters;\n\n\tfor(i = 0; i < le16_to_cpu(el->l_next_free_rec); i++) {\n\t\trec = &el->l_recs[i];\n\n\t\trec_start = le32_to_cpu(rec->e_cpos);\n\t\tclusters = ocfs2_rec_clusters(el, rec);\n\n\t\trec_end = rec_start + clusters;\n\n\t\tif (v_cluster >= rec_start && v_cluster < rec_end) {\n\t\t\tret = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "path"
          ],
          "line": 3107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_path",
          "args": [
            "et->et_ci",
            "path",
            "cpos"
          ],
          "line": 3101
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "1885-1894",
          "snippet": "int ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_new_path_from_et",
          "args": [
            "et"
          ],
          "line": 3094
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_new_path_from_et",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "713-717",
          "snippet": "struct ocfs2_path *ocfs2_new_path_from_et(struct ocfs2_extent_tree *et)\n{\n\treturn ocfs2_new_path(et->et_root_bh, et->et_root_el,\n\t\t\t      et->et_root_journal_access);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstruct ocfs2_path *ocfs2_new_path_from_et(struct ocfs2_extent_tree *et)\n{\n\treturn ocfs2_new_path(et->et_root_bh, et->et_root_el,\n\t\t\t      et->et_root_journal_access);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "ocfs2_clusters_to_blocks(sb,\n\t\t\t\t\t\t\t\t   p_cluster)"
          ],
          "line": 3089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_blocks",
          "args": [
            "sb",
            "p_cluster"
          ],
          "line": 3089
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "711-718",
          "snippet": "static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "len"
          ],
          "line": 3088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "cpos"
          ],
          "line": 3087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&replace_rec",
            "0",
            "sizeof(replace_rec)"
          ],
          "line": 3086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_clear_ext_refcount",
          "args": [
            "(unsigned long long)ino",
            "cpos",
            "len",
            "p_cluster",
            "ext_flags"
          ],
          "line": 3083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_owner",
          "args": [
            "et->et_ci"
          ],
          "line": 3081
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "72-77",
          "snippet": "u64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nu64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_get_super",
          "args": [
            "et->et_ci"
          ],
          "line": 3080
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_get_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "79-84",
          "snippet": "struct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_clear_ext_refcount(handle_t *handle,\n\t\t\t\t    struct ocfs2_extent_tree *et,\n\t\t\t\t    u32 cpos, u32 p_cluster, u32 len,\n\t\t\t\t    unsigned int ext_flags,\n\t\t\t\t    struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t    struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret, index;\n\tstruct ocfs2_extent_rec replace_rec;\n\tstruct ocfs2_path *path = NULL;\n\tstruct ocfs2_extent_list *el;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(et->et_ci);\n\tu64 ino = ocfs2_metadata_cache_owner(et->et_ci);\n\n\ttrace_ocfs2_clear_ext_refcount((unsigned long long)ino,\n\t\t\t\t       cpos, len, p_cluster, ext_flags);\n\n\tmemset(&replace_rec, 0, sizeof(replace_rec));\n\treplace_rec.e_cpos = cpu_to_le32(cpos);\n\treplace_rec.e_leaf_clusters = cpu_to_le16(len);\n\treplace_rec.e_blkno = cpu_to_le64(ocfs2_clusters_to_blocks(sb,\n\t\t\t\t\t\t\t\t   p_cluster));\n\treplace_rec.e_flags = ext_flags;\n\treplace_rec.e_flags &= ~OCFS2_EXT_REFCOUNTED;\n\n\tpath = ocfs2_new_path_from_et(et);\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_path(et->et_ci, path, cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tel = path_leaf_el(path);\n\n\tindex = ocfs2_search_extent_list(el, cpos);\n\tif (index == -1) {\n\t\tocfs2_error(sb,\n\t\t\t    \"Inode %llu has an extent at cpos %u which can no \"\n\t\t\t    \"longer be found.\\n\",\n\t\t\t    (unsigned long long)ino, cpos);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_split_extent(handle, et, path, index,\n\t\t\t\t &replace_rec, meta_ac, dealloc);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\tocfs2_free_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_duplicate_clusters_by_jbd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "3014-3067",
    "snippet": "int ocfs2_duplicate_clusters_by_jbd(handle_t *handle,\n\t\t\t\t    struct inode *inode,\n\t\t\t\t    u32 cpos, u32 old_cluster,\n\t\t\t\t    u32 new_cluster, u32 new_len)\n{\n\tint ret = 0;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ocfs2_caching_info *ci = INODE_CACHE(inode);\n\tint i, blocks = ocfs2_clusters_to_blocks(sb, new_len);\n\tu64 old_block = ocfs2_clusters_to_blocks(sb, old_cluster);\n\tu64 new_block = ocfs2_clusters_to_blocks(sb, new_cluster);\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\tstruct buffer_head *old_bh = NULL;\n\tstruct buffer_head *new_bh = NULL;\n\n\ttrace_ocfs2_duplicate_clusters_by_page(cpos, old_cluster,\n\t\t\t\t\t       new_cluster, new_len);\n\n\tfor (i = 0; i < blocks; i++, old_block++, new_block++) {\n\t\tnew_bh = sb_getblk(osb->sb, new_block);\n\t\tif (new_bh == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tocfs2_set_new_buffer_uptodate(ci, new_bh);\n\n\t\tret = ocfs2_read_block(ci, old_block, &old_bh, NULL);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = ocfs2_journal_access(handle, ci, new_bh,\n\t\t\t\t\t   OCFS2_JOURNAL_ACCESS_CREATE);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tmemcpy(new_bh->b_data, old_bh->b_data, sb->s_blocksize);\n\t\tocfs2_journal_dirty(handle, new_bh);\n\n\t\tbrelse(new_bh);\n\t\tbrelse(old_bh);\n\t\tnew_bh = NULL;\n\t\told_bh = NULL;\n\t}\n\n\tbrelse(new_bh);\n\tbrelse(old_bh);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "old_bh"
          ],
          "line": 3065
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "new_bh"
          ],
          "line": 3056
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "new_bh->b_data",
            "old_bh->b_data",
            "sb->s_blocksize"
          ],
          "line": 3055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access",
          "args": [
            "handle",
            "ci",
            "new_bh",
            "OCFS2_JOURNAL_ACCESS_CREATE"
          ],
          "line": 3048
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "765-769",
          "snippet": "int ocfs2_journal_access(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, NULL, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_journal_access(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, NULL, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_block",
          "args": [
            "ci",
            "old_block",
            "&old_bh",
            "NULL"
          ],
          "line": 3042
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_blocks_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/buffer_head_io.c",
          "lines": "101-174",
          "snippet": "int ocfs2_read_blocks_sync(struct ocfs2_super *osb, u64 block,\n\t\t\t   unsigned int nr, struct buffer_head *bhs[])\n{\n\tint status = 0;\n\tunsigned int i;\n\tstruct buffer_head *bh;\n\n\ttrace_ocfs2_read_blocks_sync((unsigned long long)block, nr);\n\n\tif (!nr)\n\t\tgoto bail;\n\n\tfor (i = 0 ; i < nr ; i++) {\n\t\tif (bhs[i] == NULL) {\n\t\t\tbhs[i] = sb_getblk(osb->sb, block++);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tbh = bhs[i];\n\n\t\tif (buffer_jbd(bh)) {\n\t\t\ttrace_ocfs2_read_blocks_sync_jbd(\n\t\t\t\t\t(unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (buffer_dirty(bh)) {\n\t\t\t/* This should probably be a BUG, or\n\t\t\t * at least return an error. */\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"trying to sync read a dirty \"\n\t\t\t     \"buffer! (blocknr = %llu), skipping\\n\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlock_buffer(bh);\n\t\tif (buffer_jbd(bh)) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"block %llu had the JBD bit set \"\n\t\t\t     \"while I was in lock_buffer!\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tBUG();\n\t\t}\n\n\t\tclear_buffer_uptodate(bh);\n\t\tget_bh(bh); /* for end_buffer_read_sync() */\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(READ, bh);\n\t}\n\n\tfor (i = nr; i > 0; i--) {\n\t\tbh = bhs[i - 1];\n\n\t\t/* No need to wait on the buffer if it's managed by JBD. */\n\t\tif (!buffer_jbd(bh))\n\t\t\twait_on_buffer(bh);\n\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* Status won't be cleared from here on out,\n\t\t\t * so we can safely record this and loop back\n\t\t\t * to cleanup the other buffers. */\n\t\t\tstatus = -EIO;\n\t\t\tput_bh(bh);\n\t\t\tbhs[i - 1] = NULL;\n\t\t}\n\t}\n\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_blocks_sync(struct ocfs2_super *osb, u64 block,\n\t\t\t   unsigned int nr, struct buffer_head *bhs[])\n{\n\tint status = 0;\n\tunsigned int i;\n\tstruct buffer_head *bh;\n\n\ttrace_ocfs2_read_blocks_sync((unsigned long long)block, nr);\n\n\tif (!nr)\n\t\tgoto bail;\n\n\tfor (i = 0 ; i < nr ; i++) {\n\t\tif (bhs[i] == NULL) {\n\t\t\tbhs[i] = sb_getblk(osb->sb, block++);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tbh = bhs[i];\n\n\t\tif (buffer_jbd(bh)) {\n\t\t\ttrace_ocfs2_read_blocks_sync_jbd(\n\t\t\t\t\t(unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (buffer_dirty(bh)) {\n\t\t\t/* This should probably be a BUG, or\n\t\t\t * at least return an error. */\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"trying to sync read a dirty \"\n\t\t\t     \"buffer! (blocknr = %llu), skipping\\n\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlock_buffer(bh);\n\t\tif (buffer_jbd(bh)) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"block %llu had the JBD bit set \"\n\t\t\t     \"while I was in lock_buffer!\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tBUG();\n\t\t}\n\n\t\tclear_buffer_uptodate(bh);\n\t\tget_bh(bh); /* for end_buffer_read_sync() */\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(READ, bh);\n\t}\n\n\tfor (i = nr; i > 0; i--) {\n\t\tbh = bhs[i - 1];\n\n\t\t/* No need to wait on the buffer if it's managed by JBD. */\n\t\tif (!buffer_jbd(bh))\n\t\t\twait_on_buffer(bh);\n\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* Status won't be cleared from here on out,\n\t\t\t * so we can safely record this and loop back\n\t\t\t * to cleanup the other buffers. */\n\t\t\tstatus = -EIO;\n\t\t\tput_bh(bh);\n\t\t\tbhs[i - 1] = NULL;\n\t\t}\n\t}\n\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_set_new_buffer_uptodate",
          "args": [
            "ci",
            "new_bh"
          ],
          "line": 3040
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_new_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "521-532",
          "snippet": "void ocfs2_set_new_buffer_uptodate(struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t/* This should definitely *not* exist in our cache */\n\tBUG_ON(ocfs2_buffer_cached(ci, bh));\n\n\tset_buffer_uptodate(bh);\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tocfs2_set_buffer_uptodate(ci, bh);\n\tocfs2_metadata_cache_io_unlock(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_set_new_buffer_uptodate(struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t/* This should definitely *not* exist in our cache */\n\tBUG_ON(ocfs2_buffer_cached(ci, bh));\n\n\tset_buffer_uptodate(bh);\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tocfs2_set_buffer_uptodate(ci, bh);\n\tocfs2_metadata_cache_io_unlock(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 3036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "osb->sb",
            "new_block"
          ],
          "line": 3033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_duplicate_clusters_by_page",
          "args": [
            "cpos",
            "old_cluster",
            "new_cluster",
            "new_len"
          ],
          "line": 3029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 3025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_blocks",
          "args": [
            "sb",
            "new_cluster"
          ],
          "line": 3024
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "711-718",
          "snippet": "static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 3021
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nint ocfs2_duplicate_clusters_by_jbd(handle_t *handle,\n\t\t\t\t    struct inode *inode,\n\t\t\t\t    u32 cpos, u32 old_cluster,\n\t\t\t\t    u32 new_cluster, u32 new_len)\n{\n\tint ret = 0;\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ocfs2_caching_info *ci = INODE_CACHE(inode);\n\tint i, blocks = ocfs2_clusters_to_blocks(sb, new_len);\n\tu64 old_block = ocfs2_clusters_to_blocks(sb, old_cluster);\n\tu64 new_block = ocfs2_clusters_to_blocks(sb, new_cluster);\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\tstruct buffer_head *old_bh = NULL;\n\tstruct buffer_head *new_bh = NULL;\n\n\ttrace_ocfs2_duplicate_clusters_by_page(cpos, old_cluster,\n\t\t\t\t\t       new_cluster, new_len);\n\n\tfor (i = 0; i < blocks; i++, old_block++, new_block++) {\n\t\tnew_bh = sb_getblk(osb->sb, new_block);\n\t\tif (new_bh == NULL) {\n\t\t\tret = -ENOMEM;\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tocfs2_set_new_buffer_uptodate(ci, new_bh);\n\n\t\tret = ocfs2_read_block(ci, old_block, &old_bh, NULL);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tret = ocfs2_journal_access(handle, ci, new_bh,\n\t\t\t\t\t   OCFS2_JOURNAL_ACCESS_CREATE);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\tmemcpy(new_bh->b_data, old_bh->b_data, sb->s_blocksize);\n\t\tocfs2_journal_dirty(handle, new_bh);\n\n\t\tbrelse(new_bh);\n\t\tbrelse(old_bh);\n\t\tnew_bh = NULL;\n\t\told_bh = NULL;\n\t}\n\n\tbrelse(new_bh);\n\tbrelse(old_bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_duplicate_clusters_by_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "2924-3012",
    "snippet": "int ocfs2_duplicate_clusters_by_page(handle_t *handle,\n\t\t\t\t     struct inode *inode,\n\t\t\t\t     u32 cpos, u32 old_cluster,\n\t\t\t\t     u32 new_cluster, u32 new_len)\n{\n\tint ret = 0, partial;\n\tstruct super_block *sb = inode->i_sb;\n\tu64 new_block = ocfs2_clusters_to_blocks(sb, new_cluster);\n\tstruct page *page;\n\tpgoff_t page_index;\n\tunsigned int from, to, readahead_pages;\n\tloff_t offset, end, map_end;\n\tstruct address_space *mapping = inode->i_mapping;\n\n\ttrace_ocfs2_duplicate_clusters_by_page(cpos, old_cluster,\n\t\t\t\t\t       new_cluster, new_len);\n\n\treadahead_pages =\n\t\t(ocfs2_cow_contig_clusters(sb) <<\n\t\t OCFS2_SB(sb)->s_clustersize_bits) >> PAGE_CACHE_SHIFT;\n\toffset = ((loff_t)cpos) << OCFS2_SB(sb)->s_clustersize_bits;\n\tend = offset + (new_len << OCFS2_SB(sb)->s_clustersize_bits);\n\t/*\n\t * We only duplicate pages until we reach the page contains i_size - 1.\n\t * So trim 'end' to i_size.\n\t */\n\tif (end > i_size_read(inode))\n\t\tend = i_size_read(inode);\n\n\twhile (offset < end) {\n\t\tpage_index = offset >> PAGE_CACHE_SHIFT;\n\t\tmap_end = ((loff_t)page_index + 1) << PAGE_CACHE_SHIFT;\n\t\tif (map_end > end)\n\t\t\tmap_end = end;\n\n\t\t/* from, to is the offset within the page. */\n\t\tfrom = offset & (PAGE_CACHE_SIZE - 1);\n\t\tto = PAGE_CACHE_SIZE;\n\t\tif (map_end & (PAGE_CACHE_SIZE - 1))\n\t\t\tto = map_end & (PAGE_CACHE_SIZE - 1);\n\n\t\tpage = find_or_create_page(mapping, page_index, GFP_NOFS);\n\t\tif (!page) {\n\t\t\tret = -ENOMEM;\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * In case PAGE_CACHE_SIZE <= CLUSTER_SIZE, This page\n\t\t * can't be dirtied before we CoW it out.\n\t\t */\n\t\tif (PAGE_CACHE_SIZE <= OCFS2_SB(sb)->s_clustersize)\n\t\t\tBUG_ON(PageDirty(page));\n\n\t\tif (!PageUptodate(page)) {\n\t\t\tret = block_read_full_page(page, ocfs2_get_block);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t\tlock_page(page);\n\t\t}\n\n\t\tif (page_has_buffers(page)) {\n\t\t\tret = walk_page_buffers(handle, page_buffers(page),\n\t\t\t\t\t\tfrom, to, &partial,\n\t\t\t\t\t\tocfs2_clear_cow_buffer);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t}\n\n\t\tocfs2_map_and_dirty_page(inode,\n\t\t\t\t\t handle, from, to,\n\t\t\t\t\t page, 0, &new_block);\n\t\tmark_page_accessed(page);\nunlock:\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tpage = NULL;\n\t\toffset = map_end;\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_cache_release",
          "args": [
            "page"
          ],
          "line": 3004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlock_page",
          "args": [
            "page"
          ],
          "line": 3003
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "1127-1148",
          "snippet": "static void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_unlock_pages(struct ocfs2_write_ctxt *wc)\n{\n\tint i;\n\n\t/*\n\t * w_target_locked is only set to true in the page_mkwrite() case.\n\t * The intent is to allow us to lock the target page from write_begin()\n\t * to write_end(). The caller must hold a ref on w_target_page.\n\t */\n\tif (wc->w_target_locked) {\n\t\tBUG_ON(!wc->w_target_page);\n\t\tfor (i = 0; i < wc->w_num_pages; i++) {\n\t\t\tif (wc->w_target_page == wc->w_pages[i]) {\n\t\t\t\twc->w_pages[i] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tmark_page_accessed(wc->w_target_page);\n\t\tpage_cache_release(wc->w_target_page);\n\t}\n\tocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_page_accessed",
          "args": [
            "page"
          ],
          "line": 3001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_map_and_dirty_page",
          "args": [
            "inode",
            "handle",
            "from",
            "to",
            "page",
            "0",
            "&new_block"
          ],
          "line": 2998
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_map_and_dirty_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "6596-6629",
          "snippet": "void ocfs2_map_and_dirty_page(struct inode *inode, handle_t *handle,\n\t\t\t      unsigned int from, unsigned int to,\n\t\t\t      struct page *page, int zero, u64 *phys)\n{\n\tint ret, partial = 0;\n\n\tret = ocfs2_map_page_blocks(page, phys, inode, from, to, 0);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\tif (zero)\n\t\tzero_user_segment(page, from, to);\n\n\t/*\n\t * Need to set the buffers we zero'd into uptodate\n\t * here if they aren't - ocfs2_map_page_blocks()\n\t * might've skipped some\n\t */\n\tret = walk_page_buffers(handle, page_buffers(page),\n\t\t\t\tfrom, to, &partial,\n\t\t\t\tocfs2_zero_func);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\telse if (ocfs2_should_order_data(inode)) {\n\t\tret = ocfs2_jbd2_file_inode(handle, inode);\n\t\tif (ret < 0)\n\t\t\tmlog_errno(ret);\n\t}\n\n\tif (!partial)\n\t\tSetPageUptodate(page);\n\n\tflush_dcache_page(page);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_map_and_dirty_page(struct inode *inode, handle_t *handle,\n\t\t\t      unsigned int from, unsigned int to,\n\t\t\t      struct page *page, int zero, u64 *phys)\n{\n\tint ret, partial = 0;\n\n\tret = ocfs2_map_page_blocks(page, phys, inode, from, to, 0);\n\tif (ret)\n\t\tmlog_errno(ret);\n\n\tif (zero)\n\t\tzero_user_segment(page, from, to);\n\n\t/*\n\t * Need to set the buffers we zero'd into uptodate\n\t * here if they aren't - ocfs2_map_page_blocks()\n\t * might've skipped some\n\t */\n\tret = walk_page_buffers(handle, page_buffers(page),\n\t\t\t\tfrom, to, &partial,\n\t\t\t\tocfs2_zero_func);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\telse if (ocfs2_should_order_data(inode)) {\n\t\tret = ocfs2_jbd2_file_inode(handle, inode);\n\t\tif (ret < 0)\n\t\t\tmlog_errno(ret);\n\t}\n\n\tif (!partial)\n\t\tSetPageUptodate(page);\n\n\tflush_dcache_page(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "walk_page_buffers",
          "args": [
            "handle",
            "page_buffers(page)",
            "from",
            "to",
            "&partial",
            "ocfs2_clear_cow_buffer"
          ],
          "line": 2989
        },
        "resolved": true,
        "details": {
          "function_name": "walk_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/aops.c",
          "lines": "424-454",
          "snippet": "int walk_page_buffers(\thandle_t *handle,\n\t\t\tstruct buffer_head *head,\n\t\t\tunsigned from,\n\t\t\tunsigned to,\n\t\t\tint *partial,\n\t\t\tint (*fn)(\thandle_t *handle,\n\t\t\t\t\tstruct buffer_head *bh))\n{\n\tstruct buffer_head *bh;\n\tunsigned block_start, block_end;\n\tunsigned blocksize = head->b_size;\n\tint err, ret = 0;\n\tstruct buffer_head *next;\n\n\tfor (\tbh = head, block_start = 0;\n\t\tret == 0 && (bh != head || !block_start);\n\t    \tblock_start = block_end, bh = next)\n\t{\n\t\tnext = bh->b_this_page;\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (partial && !buffer_uptodate(bh))\n\t\t\t\t*partial = 1;\n\t\t\tcontinue;\n\t\t}\n\t\terr = (*fn)(handle, bh);\n\t\tif (!ret)\n\t\t\tret = err;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"sysfile.h\"",
            "#include \"namei.h\"",
            "#include \"dir.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/mpage.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/swap.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sysfile.h\"\n#include \"namei.h\"\n#include \"dir.h\"\n#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/mpage.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/swap.h>\n#include <asm/byteorder.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/fs.h>\n\nint walk_page_buffers(\thandle_t *handle,\n\t\t\tstruct buffer_head *head,\n\t\t\tunsigned from,\n\t\t\tunsigned to,\n\t\t\tint *partial,\n\t\t\tint (*fn)(\thandle_t *handle,\n\t\t\t\t\tstruct buffer_head *bh))\n{\n\tstruct buffer_head *bh;\n\tunsigned block_start, block_end;\n\tunsigned blocksize = head->b_size;\n\tint err, ret = 0;\n\tstruct buffer_head *next;\n\n\tfor (\tbh = head, block_start = 0;\n\t\tret == 0 && (bh != head || !block_start);\n\t    \tblock_start = block_end, bh = next)\n\t{\n\t\tnext = bh->b_this_page;\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (partial && !buffer_uptodate(bh))\n\t\t\t\t*partial = 1;\n\t\t\tcontinue;\n\t\t}\n\t\terr = (*fn)(handle, bh);\n\t\tif (!ret)\n\t\t\tret = err;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_buffers",
          "args": [
            "page"
          ],
          "line": 2989
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_page_buffers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "123-129",
          "snippet": "static void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nstatic void\n__clear_page_buffers(struct page *page)\n{\n\tClearPagePrivate(page);\n\tset_page_private(page, 0);\n\tpage_cache_release(page);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_has_buffers",
          "args": [
            "page"
          ],
          "line": 2988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "block_read_full_page",
          "args": [
            "page",
            "ocfs2_get_block"
          ],
          "line": 2980
        },
        "resolved": true,
        "details": {
          "function_name": "block_read_full_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "2159-2242",
          "snippet": "int block_read_full_page(struct page *page, get_block_t *get_block)\n{\n\tstruct inode *inode = page->mapping->host;\n\tsector_t iblock, lblock;\n\tstruct buffer_head *bh, *head, *arr[MAX_BUF_PER_PAGE];\n\tunsigned int blocksize, bbits;\n\tint nr, i;\n\tint fully_mapped = 1;\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tiblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\tlblock = (i_size_read(inode)+blocksize-1) >> bbits;\n\tbh = head;\n\tnr = 0;\n\ti = 0;\n\n\tdo {\n\t\tif (buffer_uptodate(bh))\n\t\t\tcontinue;\n\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tint err = 0;\n\n\t\t\tfully_mapped = 0;\n\t\t\tif (iblock < lblock) {\n\t\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\t\terr = get_block(inode, iblock, bh, 0);\n\t\t\t\tif (err)\n\t\t\t\t\tSetPageError(page);\n\t\t\t}\n\t\t\tif (!buffer_mapped(bh)) {\n\t\t\t\tzero_user(page, i * blocksize, blocksize);\n\t\t\t\tif (!err)\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * get_block() might have updated the buffer\n\t\t\t * synchronously\n\t\t\t */\n\t\t\tif (buffer_uptodate(bh))\n\t\t\t\tcontinue;\n\t\t}\n\t\tarr[nr++] = bh;\n\t} while (i++, iblock++, (bh = bh->b_this_page) != head);\n\n\tif (fully_mapped)\n\t\tSetPageMappedToDisk(page);\n\n\tif (!nr) {\n\t\t/*\n\t\t * All buffers are uptodate - we can set the page uptodate\n\t\t * as well. But not if get_block() returned an error.\n\t\t */\n\t\tif (!PageError(page))\n\t\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\n\t/* Stage two: lock the buffers */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tlock_buffer(bh);\n\t\tmark_buffer_async_read(bh);\n\t}\n\n\t/*\n\t * Stage 3: start the IO.  Check for uptodateness\n\t * inside the buffer lock in case another process reading\n\t * the underlying blockdev brought it uptodate (the sct fix).\n\t */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tif (buffer_uptodate(bh))\n\t\t\tend_buffer_async_read(bh, 1);\n\t\telse\n\t\t\tsubmit_bh(READ, bh);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nint block_read_full_page(struct page *page, get_block_t *get_block)\n{\n\tstruct inode *inode = page->mapping->host;\n\tsector_t iblock, lblock;\n\tstruct buffer_head *bh, *head, *arr[MAX_BUF_PER_PAGE];\n\tunsigned int blocksize, bbits;\n\tint nr, i;\n\tint fully_mapped = 1;\n\n\thead = create_page_buffers(page, inode, 0);\n\tblocksize = head->b_size;\n\tbbits = block_size_bits(blocksize);\n\n\tiblock = (sector_t)page->index << (PAGE_CACHE_SHIFT - bbits);\n\tlblock = (i_size_read(inode)+blocksize-1) >> bbits;\n\tbh = head;\n\tnr = 0;\n\ti = 0;\n\n\tdo {\n\t\tif (buffer_uptodate(bh))\n\t\t\tcontinue;\n\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tint err = 0;\n\n\t\t\tfully_mapped = 0;\n\t\t\tif (iblock < lblock) {\n\t\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\t\terr = get_block(inode, iblock, bh, 0);\n\t\t\t\tif (err)\n\t\t\t\t\tSetPageError(page);\n\t\t\t}\n\t\t\tif (!buffer_mapped(bh)) {\n\t\t\t\tzero_user(page, i * blocksize, blocksize);\n\t\t\t\tif (!err)\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*\n\t\t\t * get_block() might have updated the buffer\n\t\t\t * synchronously\n\t\t\t */\n\t\t\tif (buffer_uptodate(bh))\n\t\t\t\tcontinue;\n\t\t}\n\t\tarr[nr++] = bh;\n\t} while (i++, iblock++, (bh = bh->b_this_page) != head);\n\n\tif (fully_mapped)\n\t\tSetPageMappedToDisk(page);\n\n\tif (!nr) {\n\t\t/*\n\t\t * All buffers are uptodate - we can set the page uptodate\n\t\t * as well. But not if get_block() returned an error.\n\t\t */\n\t\tif (!PageError(page))\n\t\t\tSetPageUptodate(page);\n\t\tunlock_page(page);\n\t\treturn 0;\n\t}\n\n\t/* Stage two: lock the buffers */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tlock_buffer(bh);\n\t\tmark_buffer_async_read(bh);\n\t}\n\n\t/*\n\t * Stage 3: start the IO.  Check for uptodateness\n\t * inside the buffer lock in case another process reading\n\t * the underlying blockdev brought it uptodate (the sct fix).\n\t */\n\tfor (i = 0; i < nr; i++) {\n\t\tbh = arr[i];\n\t\tif (buffer_uptodate(bh))\n\t\t\tend_buffer_async_read(bh, 1);\n\t\telse\n\t\t\tsubmit_bh(READ, bh);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageUptodate",
          "args": [
            "page"
          ],
          "line": 2979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "PageDirty(page)"
          ],
          "line": 2977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageDirty",
          "args": [
            "page"
          ],
          "line": 2977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 2976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_or_create_page",
          "args": [
            "mapping",
            "page_index",
            "GFP_NOFS"
          ],
          "line": 2965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 2951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "inode"
          ],
          "line": 2950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 2945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 2944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 2943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_cow_contig_clusters",
          "args": [
            "sb"
          ],
          "line": 2942
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_cow_contig_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "2592-2595",
          "snippet": "static inline unsigned int ocfs2_cow_contig_clusters(struct super_block *sb)\n{\n\treturn ocfs2_clusters_for_bytes(sb, MAX_CONTIG_BYTES);\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [
            "#define\tMAX_CONTIG_BYTES\t1048576"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\n#define\tMAX_CONTIG_BYTES\t1048576\n\nstatic inline unsigned int ocfs2_cow_contig_clusters(struct super_block *sb)\n{\n\treturn ocfs2_clusters_for_bytes(sb, MAX_CONTIG_BYTES);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_duplicate_clusters_by_page",
          "args": [
            "cpos",
            "old_cluster",
            "new_cluster",
            "new_len"
          ],
          "line": 2938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_blocks",
          "args": [
            "sb",
            "new_cluster"
          ],
          "line": 2931
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "711-718",
          "snippet": "static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nint ocfs2_duplicate_clusters_by_page(handle_t *handle,\n\t\t\t\t     struct inode *inode,\n\t\t\t\t     u32 cpos, u32 old_cluster,\n\t\t\t\t     u32 new_cluster, u32 new_len)\n{\n\tint ret = 0, partial;\n\tstruct super_block *sb = inode->i_sb;\n\tu64 new_block = ocfs2_clusters_to_blocks(sb, new_cluster);\n\tstruct page *page;\n\tpgoff_t page_index;\n\tunsigned int from, to, readahead_pages;\n\tloff_t offset, end, map_end;\n\tstruct address_space *mapping = inode->i_mapping;\n\n\ttrace_ocfs2_duplicate_clusters_by_page(cpos, old_cluster,\n\t\t\t\t\t       new_cluster, new_len);\n\n\treadahead_pages =\n\t\t(ocfs2_cow_contig_clusters(sb) <<\n\t\t OCFS2_SB(sb)->s_clustersize_bits) >> PAGE_CACHE_SHIFT;\n\toffset = ((loff_t)cpos) << OCFS2_SB(sb)->s_clustersize_bits;\n\tend = offset + (new_len << OCFS2_SB(sb)->s_clustersize_bits);\n\t/*\n\t * We only duplicate pages until we reach the page contains i_size - 1.\n\t * So trim 'end' to i_size.\n\t */\n\tif (end > i_size_read(inode))\n\t\tend = i_size_read(inode);\n\n\twhile (offset < end) {\n\t\tpage_index = offset >> PAGE_CACHE_SHIFT;\n\t\tmap_end = ((loff_t)page_index + 1) << PAGE_CACHE_SHIFT;\n\t\tif (map_end > end)\n\t\t\tmap_end = end;\n\n\t\t/* from, to is the offset within the page. */\n\t\tfrom = offset & (PAGE_CACHE_SIZE - 1);\n\t\tto = PAGE_CACHE_SIZE;\n\t\tif (map_end & (PAGE_CACHE_SIZE - 1))\n\t\t\tto = map_end & (PAGE_CACHE_SIZE - 1);\n\n\t\tpage = find_or_create_page(mapping, page_index, GFP_NOFS);\n\t\tif (!page) {\n\t\t\tret = -ENOMEM;\n\t\t\tmlog_errno(ret);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * In case PAGE_CACHE_SIZE <= CLUSTER_SIZE, This page\n\t\t * can't be dirtied before we CoW it out.\n\t\t */\n\t\tif (PAGE_CACHE_SIZE <= OCFS2_SB(sb)->s_clustersize)\n\t\t\tBUG_ON(PageDirty(page));\n\n\t\tif (!PageUptodate(page)) {\n\t\t\tret = block_read_full_page(page, ocfs2_get_block);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t\tlock_page(page);\n\t\t}\n\n\t\tif (page_has_buffers(page)) {\n\t\t\tret = walk_page_buffers(handle, page_buffers(page),\n\t\t\t\t\t\tfrom, to, &partial,\n\t\t\t\t\t\tocfs2_clear_cow_buffer);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t}\n\n\t\tocfs2_map_and_dirty_page(inode,\n\t\t\t\t\t handle, from, to,\n\t\t\t\t\t page, 0, &new_block);\n\t\tmark_page_accessed(page);\nunlock:\n\t\tunlock_page(page);\n\t\tpage_cache_release(page);\n\t\tpage = NULL;\n\t\toffset = map_end;\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_clear_cow_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "2915-2922",
    "snippet": "static int ocfs2_clear_cow_buffer(handle_t *handle, struct buffer_head *bh)\n{\n\tBUG_ON(buffer_dirty(bh));\n\n\tclear_buffer_mapped(bh);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_buffer_mapped",
          "args": [
            "bh"
          ],
          "line": 2919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "buffer_dirty(bh)"
          ],
          "line": 2917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_dirty",
          "args": [
            "bh"
          ],
          "line": 2917
        },
        "resolved": true,
        "details": {
          "function_name": "mark_buffer_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1141-1167",
          "snippet": "void mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid mark_buffer_dirty(struct buffer_head *bh)\n{\n\tWARN_ON_ONCE(!buffer_uptodate(bh));\n\n\ttrace_block_dirty_buffer(bh);\n\n\t/*\n\t * Very *carefully* optimize the it-is-already-dirty case.\n\t *\n\t * Don't let the final \"is it dirty\" escape to before we\n\t * perhaps modified the buffer.\n\t */\n\tif (buffer_dirty(bh)) {\n\t\tsmp_mb();\n\t\tif (buffer_dirty(bh))\n\t\t\treturn;\n\t}\n\n\tif (!test_set_buffer_dirty(bh)) {\n\t\tstruct page *page = bh->b_page;\n\t\tif (!TestSetPageDirty(page)) {\n\t\t\tstruct address_space *mapping = page_mapping(page);\n\t\t\tif (mapping)\n\t\t\t\t__set_page_dirty(page, mapping, 0);\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_clear_cow_buffer(handle_t *handle, struct buffer_head *bh)\n{\n\tBUG_ON(buffer_dirty(bh));\n\n\tclear_buffer_mapped(bh);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_lock_refcount_allocators",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "2857-2913",
    "snippet": "static int ocfs2_lock_refcount_allocators(struct super_block *sb,\n\t\t\t\t\tu32 p_cluster, u32 num_clusters,\n\t\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\t\tstruct ocfs2_caching_info *ref_ci,\n\t\t\t\t\tstruct buffer_head *ref_root_bh,\n\t\t\t\t\tstruct ocfs2_alloc_context **meta_ac,\n\t\t\t\t\tstruct ocfs2_alloc_context **data_ac,\n\t\t\t\t\tint *credits)\n{\n\tint ret = 0, meta_add = 0;\n\tint num_free_extents = ocfs2_num_free_extents(OCFS2_SB(sb), et);\n\n\tif (num_free_extents < 0) {\n\t\tret = num_free_extents;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (num_free_extents < num_clusters + 2)\n\t\tmeta_add =\n\t\t\tocfs2_extend_meta_needed(et->et_root_el);\n\n\t*credits += ocfs2_calc_extend_credits(sb, et->et_root_el);\n\n\tret = ocfs2_calc_refcount_meta_credits(sb, ref_ci, ref_root_bh,\n\t\t\t\t\t       p_cluster, num_clusters,\n\t\t\t\t\t       &meta_add, credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_lock_refcount_allocators(meta_add, *credits);\n\tret = ocfs2_reserve_new_metadata_blocks(OCFS2_SB(sb), meta_add,\n\t\t\t\t\t\tmeta_ac);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (data_ac) {\n\t\tret = ocfs2_reserve_clusters(OCFS2_SB(sb), num_clusters,\n\t\t\t\t\t     data_ac);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\nout:\n\tif (ret) {\n\t\tif (*meta_ac) {\n\t\t\tocfs2_free_alloc_context(*meta_ac);\n\t\t\t*meta_ac = NULL;\n\t\t}\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_free_alloc_context",
          "args": [
            "*meta_ac"
          ],
          "line": 2907
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_alloc_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "158-162",
          "snippet": "void ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nvoid ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_reserve_clusters",
          "args": [
            "OCFS2_SB(sb)",
            "num_clusters",
            "data_ac"
          ],
          "line": 2898
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reserve_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "1228-1234",
          "snippet": "int ocfs2_reserve_clusters(struct ocfs2_super *osb,\n\t\t\t   u32 bits_wanted,\n\t\t\t   struct ocfs2_alloc_context **ac)\n{\n\treturn ocfs2_reserve_clusters_with_limit(osb, bits_wanted, 0,\n\t\t\t\t\t\t ALLOC_NEW_GROUP, ac);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define ALLOC_NEW_GROUP\t\t\t0x1"
          ],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define ALLOC_NEW_GROUP\t\t\t0x1\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint ocfs2_reserve_clusters(struct ocfs2_super *osb,\n\t\t\t   u32 bits_wanted,\n\t\t\t   struct ocfs2_alloc_context **ac)\n{\n\treturn ocfs2_reserve_clusters_with_limit(osb, bits_wanted, 0,\n\t\t\t\t\t\t ALLOC_NEW_GROUP, ac);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 2898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_reserve_new_metadata_blocks",
          "args": [
            "OCFS2_SB(sb)",
            "meta_add",
            "meta_ac"
          ],
          "line": 2890
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reserve_new_metadata_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "989-1049",
          "snippet": "int ocfs2_reserve_new_metadata_blocks(struct ocfs2_super *osb,\n\t\t\t\t      int blocks,\n\t\t\t\t      struct ocfs2_alloc_context **ac)\n{\n\tint status;\n\tint slot = ocfs2_get_meta_steal_slot(osb);\n\n\t*ac = kzalloc(sizeof(struct ocfs2_alloc_context), GFP_KERNEL);\n\tif (!(*ac)) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t(*ac)->ac_bits_wanted = blocks;\n\t(*ac)->ac_which = OCFS2_AC_USE_META;\n\t(*ac)->ac_group_search = ocfs2_block_group_search;\n\n\tif (slot != OCFS2_INVALID_SLOT &&\n\t\tatomic_read(&osb->s_num_meta_stolen) < OCFS2_MAX_TO_STEAL)\n\t\tgoto extent_steal;\n\n\tatomic_set(&osb->s_num_meta_stolen, 0);\n\tstatus = ocfs2_reserve_suballoc_bits(osb, (*ac),\n\t\t\t\t\t     EXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t     (u32)osb->slot_num, NULL,\n\t\t\t\t\t     ALLOC_GROUPS_FROM_GLOBAL|ALLOC_NEW_GROUP);\n\n\n\tif (status >= 0) {\n\t\tstatus = 0;\n\t\tif (slot != OCFS2_INVALID_SLOT)\n\t\t\tocfs2_init_meta_steal_slot(osb);\n\t\tgoto bail;\n\t} else if (status < 0 && status != -ENOSPC) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_free_ac_resource(*ac);\n\nextent_steal:\n\tstatus = ocfs2_steal_meta(osb, *ac);\n\tatomic_inc(&osb->s_num_meta_stolen);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = 0;\nbail:\n\tif ((status < 0) && *ac) {\n\t\tocfs2_free_alloc_context(*ac);\n\t\t*ac = NULL;\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_MAX_TO_STEAL\t\t1024",
            "#define ALLOC_GROUPS_FROM_GLOBAL\t0x2",
            "#define ALLOC_NEW_GROUP\t\t\t0x1"
          ],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define OCFS2_MAX_TO_STEAL\t\t1024\n#define ALLOC_GROUPS_FROM_GLOBAL\t0x2\n#define ALLOC_NEW_GROUP\t\t\t0x1\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint ocfs2_reserve_new_metadata_blocks(struct ocfs2_super *osb,\n\t\t\t\t      int blocks,\n\t\t\t\t      struct ocfs2_alloc_context **ac)\n{\n\tint status;\n\tint slot = ocfs2_get_meta_steal_slot(osb);\n\n\t*ac = kzalloc(sizeof(struct ocfs2_alloc_context), GFP_KERNEL);\n\tif (!(*ac)) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t(*ac)->ac_bits_wanted = blocks;\n\t(*ac)->ac_which = OCFS2_AC_USE_META;\n\t(*ac)->ac_group_search = ocfs2_block_group_search;\n\n\tif (slot != OCFS2_INVALID_SLOT &&\n\t\tatomic_read(&osb->s_num_meta_stolen) < OCFS2_MAX_TO_STEAL)\n\t\tgoto extent_steal;\n\n\tatomic_set(&osb->s_num_meta_stolen, 0);\n\tstatus = ocfs2_reserve_suballoc_bits(osb, (*ac),\n\t\t\t\t\t     EXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t     (u32)osb->slot_num, NULL,\n\t\t\t\t\t     ALLOC_GROUPS_FROM_GLOBAL|ALLOC_NEW_GROUP);\n\n\n\tif (status >= 0) {\n\t\tstatus = 0;\n\t\tif (slot != OCFS2_INVALID_SLOT)\n\t\t\tocfs2_init_meta_steal_slot(osb);\n\t\tgoto bail;\n\t} else if (status < 0 && status != -ENOSPC) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_free_ac_resource(*ac);\n\nextent_steal:\n\tstatus = ocfs2_steal_meta(osb, *ac);\n\tatomic_inc(&osb->s_num_meta_stolen);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = 0;\nbail:\n\tif ((status < 0) && *ac) {\n\t\tocfs2_free_alloc_context(*ac);\n\t\t*ac = NULL;\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 2890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_lock_refcount_allocators",
          "args": [
            "meta_add",
            "*credits"
          ],
          "line": 2889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_calc_refcount_meta_credits",
          "args": [
            "sb",
            "ref_ci",
            "ref_root_bh",
            "p_cluster",
            "num_clusters",
            "&meta_add",
            "credits"
          ],
          "line": 2881
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_calc_refcount_meta_credits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "2385-2522",
          "snippet": "static int ocfs2_calc_refcount_meta_credits(struct super_block *sb,\n\t\t\t\t\t    struct ocfs2_caching_info *ci,\n\t\t\t\t\t    struct buffer_head *ref_root_bh,\n\t\t\t\t\t    u64 start_cpos,\n\t\t\t\t\t    u32 clusters,\n\t\t\t\t\t    int *meta_add,\n\t\t\t\t\t    int *credits)\n{\n\tint ret = 0, index, ref_blocks = 0, recs_add = 0;\n\tu64 cpos = start_cpos;\n\tstruct ocfs2_refcount_block *rb;\n\tstruct ocfs2_refcount_rec rec;\n\tstruct buffer_head *ref_leaf_bh = NULL, *prev_bh = NULL;\n\tu32 len;\n\n\twhile (clusters) {\n\t\tret = ocfs2_get_refcount_rec(ci, ref_root_bh,\n\t\t\t\t\t     cpos, clusters, &rec,\n\t\t\t\t\t     &index, &ref_leaf_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (ref_leaf_bh != prev_bh) {\n\t\t\t/*\n\t\t\t * Now we encounter a new leaf block, so calculate\n\t\t\t * whether we need to extend the old leaf.\n\t\t\t */\n\t\t\tif (prev_bh) {\n\t\t\t\trb = (struct ocfs2_refcount_block *)\n\t\t\t\t\t\t\tprev_bh->b_data;\n\n\t\t\t\tif (le16_to_cpu(rb->rf_records.rl_used) +\n\t\t\t\t    recs_add >\n\t\t\t\t    le16_to_cpu(rb->rf_records.rl_count))\n\t\t\t\t\tref_blocks++;\n\t\t\t}\n\n\t\t\trecs_add = 0;\n\t\t\t*credits += 1;\n\t\t\tbrelse(prev_bh);\n\t\t\tprev_bh = ref_leaf_bh;\n\t\t\tget_bh(prev_bh);\n\t\t}\n\n\t\ttrace_ocfs2_calc_refcount_meta_credits_iterate(\n\t\t\t\trecs_add, (unsigned long long)cpos, clusters,\n\t\t\t\t(unsigned long long)le64_to_cpu(rec.r_cpos),\n\t\t\t\tle32_to_cpu(rec.r_clusters),\n\t\t\t\tle32_to_cpu(rec.r_refcount), index);\n\n\t\tlen = min((u64)cpos + clusters, le64_to_cpu(rec.r_cpos) +\n\t\t\t  le32_to_cpu(rec.r_clusters)) - cpos;\n\t\t/*\n\t\t * We record all the records which will be inserted to the\n\t\t * same refcount block, so that we can tell exactly whether\n\t\t * we need a new refcount block or not.\n\t\t *\n\t\t * If we will insert a new one, this is easy and only happens\n\t\t * during adding refcounted flag to the extent, so we don't\n\t\t * have a chance of spliting. We just need one record.\n\t\t *\n\t\t * If the refcount rec already exists, that would be a little\n\t\t * complicated. we may have to:\n\t\t * 1) split at the beginning if the start pos isn't aligned.\n\t\t *    we need 1 more record in this case.\n\t\t * 2) split int the end if the end pos isn't aligned.\n\t\t *    we need 1 more record in this case.\n\t\t * 3) split in the middle because of file system fragmentation.\n\t\t *    we need 2 more records in this case(we can't detect this\n\t\t *    beforehand, so always think of the worst case).\n\t\t */\n\t\tif (rec.r_refcount) {\n\t\t\trecs_add += 2;\n\t\t\t/* Check whether we need a split at the beginning. */\n\t\t\tif (cpos == start_cpos &&\n\t\t\t    cpos != le64_to_cpu(rec.r_cpos))\n\t\t\t\trecs_add++;\n\n\t\t\t/* Check whether we need a split in the end. */\n\t\t\tif (cpos + clusters < le64_to_cpu(rec.r_cpos) +\n\t\t\t    le32_to_cpu(rec.r_clusters))\n\t\t\t\trecs_add++;\n\t\t} else\n\t\t\trecs_add++;\n\n\t\tbrelse(ref_leaf_bh);\n\t\tref_leaf_bh = NULL;\n\t\tclusters -= len;\n\t\tcpos += len;\n\t}\n\n\tif (prev_bh) {\n\t\trb = (struct ocfs2_refcount_block *)prev_bh->b_data;\n\n\t\tif (le16_to_cpu(rb->rf_records.rl_used) + recs_add >\n\t\t    le16_to_cpu(rb->rf_records.rl_count))\n\t\t\tref_blocks++;\n\n\t\t*credits += 1;\n\t}\n\n\tif (!ref_blocks)\n\t\tgoto out;\n\n\t*meta_add += ref_blocks;\n\t*credits += ref_blocks;\n\n\t/*\n\t * So we may need ref_blocks to insert into the tree.\n\t * That also means we need to change the b-tree and add that number\n\t * of records since we never merge them.\n\t * We need one more block for expansion since the new created leaf\n\t * block is also full and needs split.\n\t */\n\trb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\tif (le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL) {\n\t\tstruct ocfs2_extent_tree et;\n\n\t\tocfs2_init_refcount_extent_tree(&et, ci, ref_root_bh);\n\t\t*meta_add += ocfs2_extend_meta_needed(et.et_root_el);\n\t\t*credits += ocfs2_calc_extend_credits(sb,\n\t\t\t\t\t\t      et.et_root_el);\n\t} else {\n\t\t*credits += OCFS2_EXPAND_REFCOUNT_TREE_CREDITS;\n\t\t*meta_add += 1;\n\t}\n\nout:\n\n\ttrace_ocfs2_calc_refcount_meta_credits(\n\t\t(unsigned long long)start_cpos, clusters,\n\t\t*meta_add, *credits);\n\tbrelse(ref_leaf_bh);\n\tbrelse(prev_bh);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_calc_refcount_meta_credits(struct super_block *sb,\n\t\t\t\t\t    struct ocfs2_caching_info *ci,\n\t\t\t\t\t    struct buffer_head *ref_root_bh,\n\t\t\t\t\t    u64 start_cpos,\n\t\t\t\t\t    u32 clusters,\n\t\t\t\t\t    int *meta_add,\n\t\t\t\t\t    int *credits)\n{\n\tint ret = 0, index, ref_blocks = 0, recs_add = 0;\n\tu64 cpos = start_cpos;\n\tstruct ocfs2_refcount_block *rb;\n\tstruct ocfs2_refcount_rec rec;\n\tstruct buffer_head *ref_leaf_bh = NULL, *prev_bh = NULL;\n\tu32 len;\n\n\twhile (clusters) {\n\t\tret = ocfs2_get_refcount_rec(ci, ref_root_bh,\n\t\t\t\t\t     cpos, clusters, &rec,\n\t\t\t\t\t     &index, &ref_leaf_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (ref_leaf_bh != prev_bh) {\n\t\t\t/*\n\t\t\t * Now we encounter a new leaf block, so calculate\n\t\t\t * whether we need to extend the old leaf.\n\t\t\t */\n\t\t\tif (prev_bh) {\n\t\t\t\trb = (struct ocfs2_refcount_block *)\n\t\t\t\t\t\t\tprev_bh->b_data;\n\n\t\t\t\tif (le16_to_cpu(rb->rf_records.rl_used) +\n\t\t\t\t    recs_add >\n\t\t\t\t    le16_to_cpu(rb->rf_records.rl_count))\n\t\t\t\t\tref_blocks++;\n\t\t\t}\n\n\t\t\trecs_add = 0;\n\t\t\t*credits += 1;\n\t\t\tbrelse(prev_bh);\n\t\t\tprev_bh = ref_leaf_bh;\n\t\t\tget_bh(prev_bh);\n\t\t}\n\n\t\ttrace_ocfs2_calc_refcount_meta_credits_iterate(\n\t\t\t\trecs_add, (unsigned long long)cpos, clusters,\n\t\t\t\t(unsigned long long)le64_to_cpu(rec.r_cpos),\n\t\t\t\tle32_to_cpu(rec.r_clusters),\n\t\t\t\tle32_to_cpu(rec.r_refcount), index);\n\n\t\tlen = min((u64)cpos + clusters, le64_to_cpu(rec.r_cpos) +\n\t\t\t  le32_to_cpu(rec.r_clusters)) - cpos;\n\t\t/*\n\t\t * We record all the records which will be inserted to the\n\t\t * same refcount block, so that we can tell exactly whether\n\t\t * we need a new refcount block or not.\n\t\t *\n\t\t * If we will insert a new one, this is easy and only happens\n\t\t * during adding refcounted flag to the extent, so we don't\n\t\t * have a chance of spliting. We just need one record.\n\t\t *\n\t\t * If the refcount rec already exists, that would be a little\n\t\t * complicated. we may have to:\n\t\t * 1) split at the beginning if the start pos isn't aligned.\n\t\t *    we need 1 more record in this case.\n\t\t * 2) split int the end if the end pos isn't aligned.\n\t\t *    we need 1 more record in this case.\n\t\t * 3) split in the middle because of file system fragmentation.\n\t\t *    we need 2 more records in this case(we can't detect this\n\t\t *    beforehand, so always think of the worst case).\n\t\t */\n\t\tif (rec.r_refcount) {\n\t\t\trecs_add += 2;\n\t\t\t/* Check whether we need a split at the beginning. */\n\t\t\tif (cpos == start_cpos &&\n\t\t\t    cpos != le64_to_cpu(rec.r_cpos))\n\t\t\t\trecs_add++;\n\n\t\t\t/* Check whether we need a split in the end. */\n\t\t\tif (cpos + clusters < le64_to_cpu(rec.r_cpos) +\n\t\t\t    le32_to_cpu(rec.r_clusters))\n\t\t\t\trecs_add++;\n\t\t} else\n\t\t\trecs_add++;\n\n\t\tbrelse(ref_leaf_bh);\n\t\tref_leaf_bh = NULL;\n\t\tclusters -= len;\n\t\tcpos += len;\n\t}\n\n\tif (prev_bh) {\n\t\trb = (struct ocfs2_refcount_block *)prev_bh->b_data;\n\n\t\tif (le16_to_cpu(rb->rf_records.rl_used) + recs_add >\n\t\t    le16_to_cpu(rb->rf_records.rl_count))\n\t\t\tref_blocks++;\n\n\t\t*credits += 1;\n\t}\n\n\tif (!ref_blocks)\n\t\tgoto out;\n\n\t*meta_add += ref_blocks;\n\t*credits += ref_blocks;\n\n\t/*\n\t * So we may need ref_blocks to insert into the tree.\n\t * That also means we need to change the b-tree and add that number\n\t * of records since we never merge them.\n\t * We need one more block for expansion since the new created leaf\n\t * block is also full and needs split.\n\t */\n\trb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\tif (le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL) {\n\t\tstruct ocfs2_extent_tree et;\n\n\t\tocfs2_init_refcount_extent_tree(&et, ci, ref_root_bh);\n\t\t*meta_add += ocfs2_extend_meta_needed(et.et_root_el);\n\t\t*credits += ocfs2_calc_extend_credits(sb,\n\t\t\t\t\t\t      et.et_root_el);\n\t} else {\n\t\t*credits += OCFS2_EXPAND_REFCOUNT_TREE_CREDITS;\n\t\t*meta_add += 1;\n\t}\n\nout:\n\n\ttrace_ocfs2_calc_refcount_meta_credits(\n\t\t(unsigned long long)start_cpos, clusters,\n\t\t*meta_add, *credits);\n\tbrelse(ref_leaf_bh);\n\tbrelse(prev_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_calc_extend_credits",
          "args": [
            "sb",
            "et->et_root_el"
          ],
          "line": 2879
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_calc_extend_credits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "531-556",
          "snippet": "static inline int ocfs2_calc_extend_credits(struct super_block *sb,\n\t\t\t\t\t    struct ocfs2_extent_list *root_el)\n{\n\tint bitmap_blocks, sysfile_bitmap_blocks, extent_blocks;\n\n\t/* bitmap dinode, group desc. + relinked group. */\n\tbitmap_blocks = OCFS2_SUBALLOC_ALLOC;\n\n\t/* we might need to shift tree depth so lets assume an\n\t * absolute worst case of complete fragmentation.  Even with\n\t * that, we only need one update for the dinode, and then\n\t * however many metadata chunks needed * a remaining suballoc\n\t * alloc. */\n\tsysfile_bitmap_blocks = 1 +\n\t\t(OCFS2_SUBALLOC_ALLOC - 1) * ocfs2_extend_meta_needed(root_el);\n\n\t/* this does not include *new* metadata blocks, which are\n\t * accounted for in sysfile_bitmap_blocks. root_el +\n\t * prev. last_eb_blk + blocks along edge of tree.\n\t * calc_symlink_credits passes because we just need 1\n\t * credit for the dinode there. */\n\textent_blocks = 1 + 1 + le16_to_cpu(root_el->l_tree_depth);\n\n\treturn bitmap_blocks + sysfile_bitmap_blocks + extent_blocks +\n\t       ocfs2_quota_trans_credits(sb);\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_SUBALLOC_ALLOC (3)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\n#define OCFS2_SUBALLOC_ALLOC (3)\n\nstatic inline int ocfs2_calc_extend_credits(struct super_block *sb,\n\t\t\t\t\t    struct ocfs2_extent_list *root_el)\n{\n\tint bitmap_blocks, sysfile_bitmap_blocks, extent_blocks;\n\n\t/* bitmap dinode, group desc. + relinked group. */\n\tbitmap_blocks = OCFS2_SUBALLOC_ALLOC;\n\n\t/* we might need to shift tree depth so lets assume an\n\t * absolute worst case of complete fragmentation.  Even with\n\t * that, we only need one update for the dinode, and then\n\t * however many metadata chunks needed * a remaining suballoc\n\t * alloc. */\n\tsysfile_bitmap_blocks = 1 +\n\t\t(OCFS2_SUBALLOC_ALLOC - 1) * ocfs2_extend_meta_needed(root_el);\n\n\t/* this does not include *new* metadata blocks, which are\n\t * accounted for in sysfile_bitmap_blocks. root_el +\n\t * prev. last_eb_blk + blocks along edge of tree.\n\t * calc_symlink_credits passes because we just need 1\n\t * credit for the dinode there. */\n\textent_blocks = 1 + 1 + le16_to_cpu(root_el->l_tree_depth);\n\n\treturn bitmap_blocks + sysfile_bitmap_blocks + extent_blocks +\n\t       ocfs2_quota_trans_credits(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_extend_meta_needed",
          "args": [
            "et->et_root_el"
          ],
          "line": 2877
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extend_meta_needed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
          "lines": "157-168",
          "snippet": "static inline int ocfs2_extend_meta_needed(struct ocfs2_extent_list *root_el)\n{\n\t/*\n\t * Rather than do all the work of determining how much we need\n\t * (involves a ton of reads and locks), just ask for the\n\t * maximal limit.  That's a tree depth shift.  So, one block for\n\t * level of the tree (current l_tree_depth), one block for the\n\t * new tree_depth==0 extent_block, and one block at the new\n\t * top-of-the tree.\n\t */\n\treturn le16_to_cpu(root_el->l_tree_depth) + 2;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_extend_meta_needed(struct ocfs2_extent_list *root_el)\n{\n\t/*\n\t * Rather than do all the work of determining how much we need\n\t * (involves a ton of reads and locks), just ask for the\n\t * maximal limit.  That's a tree depth shift.  So, one block for\n\t * level of the tree (current l_tree_depth), one block for the\n\t * new tree_depth==0 extent_block, and one block at the new\n\t * top-of-the tree.\n\t */\n\treturn le16_to_cpu(root_el->l_tree_depth) + 2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_num_free_extents",
          "args": [
            "OCFS2_SB(sb)",
            "et"
          ],
          "line": 2867
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_num_free_extents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "959-990",
          "snippet": "int ocfs2_num_free_extents(struct ocfs2_super *osb,\n\t\t\t   struct ocfs2_extent_tree *et)\n{\n\tint retval;\n\tstruct ocfs2_extent_list *el = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct buffer_head *eb_bh = NULL;\n\tu64 last_eb_blk = 0;\n\n\tel = et->et_root_el;\n\tlast_eb_blk = ocfs2_et_get_last_eb_blk(et);\n\n\tif (last_eb_blk) {\n\t\tretval = ocfs2_read_extent_block(et->et_ci, last_eb_blk,\n\t\t\t\t\t\t &eb_bh);\n\t\tif (retval < 0) {\n\t\t\tmlog_errno(retval);\n\t\t\tgoto bail;\n\t\t}\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\t}\n\n\tBUG_ON(el->l_tree_depth != 0);\n\n\tretval = le16_to_cpu(el->l_count) - le16_to_cpu(el->l_next_free_rec);\nbail:\n\tbrelse(eb_bh);\n\n\ttrace_ocfs2_num_free_extents(retval);\n\treturn retval;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\t\t struct ocfs2_extent_block *eb);\n\nint ocfs2_num_free_extents(struct ocfs2_super *osb,\n\t\t\t   struct ocfs2_extent_tree *et)\n{\n\tint retval;\n\tstruct ocfs2_extent_list *el = NULL;\n\tstruct ocfs2_extent_block *eb;\n\tstruct buffer_head *eb_bh = NULL;\n\tu64 last_eb_blk = 0;\n\n\tel = et->et_root_el;\n\tlast_eb_blk = ocfs2_et_get_last_eb_blk(et);\n\n\tif (last_eb_blk) {\n\t\tretval = ocfs2_read_extent_block(et->et_ci, last_eb_blk,\n\t\t\t\t\t\t &eb_bh);\n\t\tif (retval < 0) {\n\t\t\tmlog_errno(retval);\n\t\t\tgoto bail;\n\t\t}\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\t}\n\n\tBUG_ON(el->l_tree_depth != 0);\n\n\tretval = le16_to_cpu(el->l_count) - le16_to_cpu(el->l_next_free_rec);\nbail:\n\tbrelse(eb_bh);\n\n\ttrace_ocfs2_num_free_extents(retval);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 2867
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_lock_refcount_allocators(struct super_block *sb,\n\t\t\t\t\tu32 p_cluster, u32 num_clusters,\n\t\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\t\tstruct ocfs2_caching_info *ref_ci,\n\t\t\t\t\tstruct buffer_head *ref_root_bh,\n\t\t\t\t\tstruct ocfs2_alloc_context **meta_ac,\n\t\t\t\t\tstruct ocfs2_alloc_context **data_ac,\n\t\t\t\t\tint *credits)\n{\n\tint ret = 0, meta_add = 0;\n\tint num_free_extents = ocfs2_num_free_extents(OCFS2_SB(sb), et);\n\n\tif (num_free_extents < 0) {\n\t\tret = num_free_extents;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (num_free_extents < num_clusters + 2)\n\t\tmeta_add =\n\t\t\tocfs2_extend_meta_needed(et->et_root_el);\n\n\t*credits += ocfs2_calc_extend_credits(sb, et->et_root_el);\n\n\tret = ocfs2_calc_refcount_meta_credits(sb, ref_ci, ref_root_bh,\n\t\t\t\t\t       p_cluster, num_clusters,\n\t\t\t\t\t       &meta_add, credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_lock_refcount_allocators(meta_add, *credits);\n\tret = ocfs2_reserve_new_metadata_blocks(OCFS2_SB(sb), meta_add,\n\t\t\t\t\t\tmeta_ac);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (data_ac) {\n\t\tret = ocfs2_reserve_clusters(OCFS2_SB(sb), num_clusters,\n\t\t\t\t\t     data_ac);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\nout:\n\tif (ret) {\n\t\tif (*meta_ac) {\n\t\t\tocfs2_free_alloc_context(*meta_ac);\n\t\t\t*meta_ac = NULL;\n\t\t}\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_refcount_cal_cow_clusters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "2647-2844",
    "snippet": "static int ocfs2_refcount_cal_cow_clusters(struct inode *inode,\n\t\t\t\t\t   struct ocfs2_extent_list *el,\n\t\t\t\t\t   u32 cpos,\n\t\t\t\t\t   u32 write_len,\n\t\t\t\t\t   u32 max_cpos,\n\t\t\t\t\t   u32 *cow_start,\n\t\t\t\t\t   u32 *cow_len)\n{\n\tint ret = 0;\n\tint tree_height = le16_to_cpu(el->l_tree_depth), i;\n\tstruct buffer_head *eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb = NULL;\n\tstruct ocfs2_extent_rec *rec;\n\tunsigned int want_clusters, rec_end = 0;\n\tint contig_clusters = ocfs2_cow_contig_clusters(inode->i_sb);\n\tint leaf_clusters;\n\n\tBUG_ON(cpos + write_len > max_cpos);\n\n\tif (tree_height > 0) {\n\t\tret = ocfs2_find_leaf(INODE_CACHE(inode), el, cpos, &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tocfs2_error(inode->i_sb,\n\t\t\t\t    \"Inode %lu has non zero tree depth in \"\n\t\t\t\t    \"leaf block %llu\\n\", inode->i_ino,\n\t\t\t\t    (unsigned long long)eb_bh->b_blocknr);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t*cow_len = 0;\n\tfor (i = 0; i < le16_to_cpu(el->l_next_free_rec); i++) {\n\t\trec = &el->l_recs[i];\n\n\t\tif (ocfs2_is_empty_extent(rec)) {\n\t\t\tmlog_bug_on_msg(i != 0, \"Inode %lu has empty record in \"\n\t\t\t\t\t\"index %d\\n\", inode->i_ino, i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (le32_to_cpu(rec->e_cpos) +\n\t\t    le16_to_cpu(rec->e_leaf_clusters) <= cpos)\n\t\t\tcontinue;\n\n\t\tif (*cow_len == 0) {\n\t\t\t/*\n\t\t\t * We should find a refcounted record in the\n\t\t\t * first pass.\n\t\t\t */\n\t\t\tBUG_ON(!(rec->e_flags & OCFS2_EXT_REFCOUNTED));\n\t\t\t*cow_start = le32_to_cpu(rec->e_cpos);\n\t\t}\n\n\t\t/*\n\t\t * If we encounter a hole, a non-refcounted record or\n\t\t * pass the max_cpos, stop the search.\n\t\t */\n\t\tif ((!(rec->e_flags & OCFS2_EXT_REFCOUNTED)) ||\n\t\t    (*cow_len && rec_end != le32_to_cpu(rec->e_cpos)) ||\n\t\t    (max_cpos <= le32_to_cpu(rec->e_cpos)))\n\t\t\tbreak;\n\n\t\tleaf_clusters = le16_to_cpu(rec->e_leaf_clusters);\n\t\trec_end = le32_to_cpu(rec->e_cpos) + leaf_clusters;\n\t\tif (rec_end > max_cpos) {\n\t\t\trec_end = max_cpos;\n\t\t\tleaf_clusters = rec_end - le32_to_cpu(rec->e_cpos);\n\t\t}\n\n\t\t/*\n\t\t * How many clusters do we actually need from\n\t\t * this extent?  First we see how many we actually\n\t\t * need to complete the write.  If that's smaller\n\t\t * than contig_clusters, we try for contig_clusters.\n\t\t */\n\t\tif (!*cow_len)\n\t\t\twant_clusters = write_len;\n\t\telse\n\t\t\twant_clusters = (cpos + write_len) -\n\t\t\t\t(*cow_start + *cow_len);\n\t\tif (want_clusters < contig_clusters)\n\t\t\twant_clusters = contig_clusters;\n\n\t\t/*\n\t\t * If the write does not cover the whole extent, we\n\t\t * need to calculate how we're going to split the extent.\n\t\t * We try to do it on contig_clusters boundaries.\n\t\t *\n\t\t * Any extent smaller than contig_clusters will be\n\t\t * CoWed in its entirety.\n\t\t */\n\t\tif (leaf_clusters <= contig_clusters)\n\t\t\t*cow_len += leaf_clusters;\n\t\telse if (*cow_len || (*cow_start == cpos)) {\n\t\t\t/*\n\t\t\t * This extent needs to be CoW'd from its\n\t\t\t * beginning, so all we have to do is compute\n\t\t\t * how many clusters to grab.  We align\n\t\t\t * want_clusters to the edge of contig_clusters\n\t\t\t * to get better I/O.\n\t\t\t */\n\t\t\twant_clusters = ocfs2_cow_align_length(inode->i_sb,\n\t\t\t\t\t\t\t       want_clusters);\n\n\t\t\tif (leaf_clusters < want_clusters)\n\t\t\t\t*cow_len += leaf_clusters;\n\t\t\telse\n\t\t\t\t*cow_len += want_clusters;\n\t\t} else if ((*cow_start + contig_clusters) >=\n\t\t\t   (cpos + write_len)) {\n\t\t\t/*\n\t\t\t * Breaking off contig_clusters at the front\n\t\t\t * of the extent will cover our write.  That's\n\t\t\t * easy.\n\t\t\t */\n\t\t\t*cow_len = contig_clusters;\n\t\t} else if ((rec_end - cpos) <= contig_clusters) {\n\t\t\t/*\n\t\t\t * Breaking off contig_clusters at the tail of\n\t\t\t * this extent will cover cpos.\n\t\t\t */\n\t\t\t*cow_start = rec_end - contig_clusters;\n\t\t\t*cow_len = contig_clusters;\n\t\t} else if ((rec_end - cpos) <= want_clusters) {\n\t\t\t/*\n\t\t\t * While we can't fit the entire write in this\n\t\t\t * extent, we know that the write goes from cpos\n\t\t\t * to the end of the extent.  Break that off.\n\t\t\t * We try to break it at some multiple of\n\t\t\t * contig_clusters from the front of the extent.\n\t\t\t * Failing that (ie, cpos is within\n\t\t\t * contig_clusters of the front), we'll CoW the\n\t\t\t * entire extent.\n\t\t\t */\n\t\t\t*cow_start = ocfs2_cow_align_start(inode->i_sb,\n\t\t\t\t\t\t\t   *cow_start, cpos);\n\t\t\t*cow_len = rec_end - *cow_start;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Ok, the entire write lives in the middle of\n\t\t\t * this extent.  Let's try to slice the extent up\n\t\t\t * nicely.  Optimally, our CoW region starts at\n\t\t\t * m*contig_clusters from the beginning of the\n\t\t\t * extent and goes for n*contig_clusters,\n\t\t\t * covering the entire write.\n\t\t\t */\n\t\t\t*cow_start = ocfs2_cow_align_start(inode->i_sb,\n\t\t\t\t\t\t\t   *cow_start, cpos);\n\n\t\t\twant_clusters = (cpos + write_len) - *cow_start;\n\t\t\twant_clusters = ocfs2_cow_align_length(inode->i_sb,\n\t\t\t\t\t\t\t       want_clusters);\n\t\t\tif (*cow_start + want_clusters <= rec_end)\n\t\t\t\t*cow_len = want_clusters;\n\t\t\telse\n\t\t\t\t*cow_len = rec_end - *cow_start;\n\t\t}\n\n\t\t/* Have we covered our entire write yet? */\n\t\tif ((*cow_start + *cow_len) >= (cpos + write_len))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * If we reach the end of the extent block and don't get enough\n\t\t * clusters, continue with the next extent block if possible.\n\t\t */\n\t\tif (i + 1 == le16_to_cpu(el->l_next_free_rec) &&\n\t\t    eb && eb->h_next_leaf_blk) {\n\t\t\tbrelse(eb_bh);\n\t\t\teb_bh = NULL;\n\n\t\t\tret = ocfs2_read_extent_block(INODE_CACHE(inode),\n\t\t\t\t\t       le64_to_cpu(eb->h_next_leaf_blk),\n\t\t\t\t\t       &eb_bh);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\t\tel = &eb->h_list;\n\t\t\ti = -1;\n\t\t}\n\t}\n\nout:\n\tbrelse(eb_bh);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "eb_bh"
          ],
          "line": 2842
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_extent_block",
          "args": [
            "INODE_CACHE(inode)",
            "le64_to_cpu(eb->h_next_leaf_blk)",
            "&eb_bh"
          ],
          "line": 2827
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_extent_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "939-953",
          "snippet": "int ocfs2_read_extent_block(struct ocfs2_caching_info *ci, u64 eb_blkno,\n\t\t\t    struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(ci, eb_blkno, &tmp,\n\t\t\t      ocfs2_validate_extent_block);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_extent_block(struct ocfs2_caching_info *ci, u64 eb_blkno,\n\t\t\t    struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(ci, eb_blkno, &tmp,\n\t\t\t      ocfs2_validate_extent_block);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "eb->h_next_leaf_blk"
          ],
          "line": 2828
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 2827
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "el->l_next_free_rec"
          ],
          "line": 2822
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_cow_align_length",
          "args": [
            "inode->i_sb",
            "want_clusters"
          ],
          "line": 2806
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_cow_align_length",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "2622-2634",
          "snippet": "static inline unsigned int ocfs2_cow_align_length(struct super_block *sb,\n\t\t\t\t\t\t  unsigned int len)\n{\n\tunsigned int padded =\n\t\t(len + (ocfs2_cow_contig_clusters(sb) - 1)) &\n\t\tocfs2_cow_contig_mask(sb);\n\n\t/* Did we wrap? */\n\tif (padded < len)\n\t\tpadded = UINT_MAX;\n\n\treturn padded;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic inline unsigned int ocfs2_cow_align_length(struct super_block *sb,\n\t\t\t\t\t\t  unsigned int len)\n{\n\tunsigned int padded =\n\t\t(len + (ocfs2_cow_contig_clusters(sb) - 1)) &\n\t\tocfs2_cow_contig_mask(sb);\n\n\t/* Did we wrap? */\n\tif (padded < len)\n\t\tpadded = UINT_MAX;\n\n\treturn padded;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_cow_align_start",
          "args": [
            "inode->i_sb",
            "*cow_start",
            "cpos"
          ],
          "line": 2802
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_cow_align_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "2609-2616",
          "snippet": "static inline unsigned int ocfs2_cow_align_start(struct super_block *sb,\n\t\t\t\t\t\t unsigned int start,\n\t\t\t\t\t\t unsigned int cpos)\n{\n\tBUG_ON(start > cpos);\n\n\treturn start + ((cpos - start) & ocfs2_cow_contig_mask(sb));\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic inline unsigned int ocfs2_cow_align_start(struct super_block *sb,\n\t\t\t\t\t\t unsigned int start,\n\t\t\t\t\t\t unsigned int cpos)\n{\n\tBUG_ON(start > cpos);\n\n\treturn start + ((cpos - start) & ocfs2_cow_contig_mask(sb));\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rec->e_cpos"
          ],
          "line": 2722
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(rec->e_flags & OCFS2_EXT_REFCOUNTED)"
          ],
          "line": 2705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_bug_on_msg",
          "args": [
            "i != 0",
            "\"Inode %lu has empty record in \"\n\t\t\t\t\t\"index %d\\n\"",
            "inode->i_ino",
            "i"
          ],
          "line": 2691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_is_empty_extent",
          "args": [
            "rec"
          ],
          "line": 2690
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_is_empty_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
          "lines": "266-269",
          "snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)\n{\n\treturn !rec->e_leaf_clusters;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_error",
          "args": [
            "inode->i_sb",
            "\"Inode %lu has non zero tree depth in \"\n\t\t\t\t    \"leaf block %llu\\n\"",
            "inode->i_ino",
            "(unsigned long long)eb_bh->b_blocknr"
          ],
          "line": 2677
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2568-2584",
          "snippet": "void __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic char error_buf[1024];\n\nvoid __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_leaf",
          "args": [
            "INODE_CACHE(inode)",
            "el",
            "cpos",
            "&eb_bh"
          ],
          "line": 2667
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "1917-1933",
          "snippet": "int ocfs2_find_leaf(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_extent_list *root_el, u32 cpos,\n\t\t    struct buffer_head **leaf_bh)\n{\n\tint ret;\n\tstruct buffer_head *bh = NULL;\n\n\tret = __ocfs2_find_path(ci, root_el, cpos, find_leaf_ins, &bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t*leaf_bh = bh;\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_find_leaf(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_extent_list *root_el, u32 cpos,\n\t\t    struct buffer_head **leaf_bh)\n{\n\tint ret;\n\tstruct buffer_head *bh = NULL;\n\n\tret = __ocfs2_find_path(ci, root_el, cpos, find_leaf_ins, &bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t*leaf_bh = bh;\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "cpos + write_len > max_cpos"
          ],
          "line": 2664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_cow_contig_clusters",
          "args": [
            "inode->i_sb"
          ],
          "line": 2661
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_cow_contig_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "2592-2595",
          "snippet": "static inline unsigned int ocfs2_cow_contig_clusters(struct super_block *sb)\n{\n\treturn ocfs2_clusters_for_bytes(sb, MAX_CONTIG_BYTES);\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [
            "#define\tMAX_CONTIG_BYTES\t1048576"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\n#define\tMAX_CONTIG_BYTES\t1048576\n\nstatic inline unsigned int ocfs2_cow_contig_clusters(struct super_block *sb)\n{\n\treturn ocfs2_clusters_for_bytes(sb, MAX_CONTIG_BYTES);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_refcount_cal_cow_clusters(struct inode *inode,\n\t\t\t\t\t   struct ocfs2_extent_list *el,\n\t\t\t\t\t   u32 cpos,\n\t\t\t\t\t   u32 write_len,\n\t\t\t\t\t   u32 max_cpos,\n\t\t\t\t\t   u32 *cow_start,\n\t\t\t\t\t   u32 *cow_len)\n{\n\tint ret = 0;\n\tint tree_height = le16_to_cpu(el->l_tree_depth), i;\n\tstruct buffer_head *eb_bh = NULL;\n\tstruct ocfs2_extent_block *eb = NULL;\n\tstruct ocfs2_extent_rec *rec;\n\tunsigned int want_clusters, rec_end = 0;\n\tint contig_clusters = ocfs2_cow_contig_clusters(inode->i_sb);\n\tint leaf_clusters;\n\n\tBUG_ON(cpos + write_len > max_cpos);\n\n\tif (tree_height > 0) {\n\t\tret = ocfs2_find_leaf(INODE_CACHE(inode), el, cpos, &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tocfs2_error(inode->i_sb,\n\t\t\t\t    \"Inode %lu has non zero tree depth in \"\n\t\t\t\t    \"leaf block %llu\\n\", inode->i_ino,\n\t\t\t\t    (unsigned long long)eb_bh->b_blocknr);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t*cow_len = 0;\n\tfor (i = 0; i < le16_to_cpu(el->l_next_free_rec); i++) {\n\t\trec = &el->l_recs[i];\n\n\t\tif (ocfs2_is_empty_extent(rec)) {\n\t\t\tmlog_bug_on_msg(i != 0, \"Inode %lu has empty record in \"\n\t\t\t\t\t\"index %d\\n\", inode->i_ino, i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (le32_to_cpu(rec->e_cpos) +\n\t\t    le16_to_cpu(rec->e_leaf_clusters) <= cpos)\n\t\t\tcontinue;\n\n\t\tif (*cow_len == 0) {\n\t\t\t/*\n\t\t\t * We should find a refcounted record in the\n\t\t\t * first pass.\n\t\t\t */\n\t\t\tBUG_ON(!(rec->e_flags & OCFS2_EXT_REFCOUNTED));\n\t\t\t*cow_start = le32_to_cpu(rec->e_cpos);\n\t\t}\n\n\t\t/*\n\t\t * If we encounter a hole, a non-refcounted record or\n\t\t * pass the max_cpos, stop the search.\n\t\t */\n\t\tif ((!(rec->e_flags & OCFS2_EXT_REFCOUNTED)) ||\n\t\t    (*cow_len && rec_end != le32_to_cpu(rec->e_cpos)) ||\n\t\t    (max_cpos <= le32_to_cpu(rec->e_cpos)))\n\t\t\tbreak;\n\n\t\tleaf_clusters = le16_to_cpu(rec->e_leaf_clusters);\n\t\trec_end = le32_to_cpu(rec->e_cpos) + leaf_clusters;\n\t\tif (rec_end > max_cpos) {\n\t\t\trec_end = max_cpos;\n\t\t\tleaf_clusters = rec_end - le32_to_cpu(rec->e_cpos);\n\t\t}\n\n\t\t/*\n\t\t * How many clusters do we actually need from\n\t\t * this extent?  First we see how many we actually\n\t\t * need to complete the write.  If that's smaller\n\t\t * than contig_clusters, we try for contig_clusters.\n\t\t */\n\t\tif (!*cow_len)\n\t\t\twant_clusters = write_len;\n\t\telse\n\t\t\twant_clusters = (cpos + write_len) -\n\t\t\t\t(*cow_start + *cow_len);\n\t\tif (want_clusters < contig_clusters)\n\t\t\twant_clusters = contig_clusters;\n\n\t\t/*\n\t\t * If the write does not cover the whole extent, we\n\t\t * need to calculate how we're going to split the extent.\n\t\t * We try to do it on contig_clusters boundaries.\n\t\t *\n\t\t * Any extent smaller than contig_clusters will be\n\t\t * CoWed in its entirety.\n\t\t */\n\t\tif (leaf_clusters <= contig_clusters)\n\t\t\t*cow_len += leaf_clusters;\n\t\telse if (*cow_len || (*cow_start == cpos)) {\n\t\t\t/*\n\t\t\t * This extent needs to be CoW'd from its\n\t\t\t * beginning, so all we have to do is compute\n\t\t\t * how many clusters to grab.  We align\n\t\t\t * want_clusters to the edge of contig_clusters\n\t\t\t * to get better I/O.\n\t\t\t */\n\t\t\twant_clusters = ocfs2_cow_align_length(inode->i_sb,\n\t\t\t\t\t\t\t       want_clusters);\n\n\t\t\tif (leaf_clusters < want_clusters)\n\t\t\t\t*cow_len += leaf_clusters;\n\t\t\telse\n\t\t\t\t*cow_len += want_clusters;\n\t\t} else if ((*cow_start + contig_clusters) >=\n\t\t\t   (cpos + write_len)) {\n\t\t\t/*\n\t\t\t * Breaking off contig_clusters at the front\n\t\t\t * of the extent will cover our write.  That's\n\t\t\t * easy.\n\t\t\t */\n\t\t\t*cow_len = contig_clusters;\n\t\t} else if ((rec_end - cpos) <= contig_clusters) {\n\t\t\t/*\n\t\t\t * Breaking off contig_clusters at the tail of\n\t\t\t * this extent will cover cpos.\n\t\t\t */\n\t\t\t*cow_start = rec_end - contig_clusters;\n\t\t\t*cow_len = contig_clusters;\n\t\t} else if ((rec_end - cpos) <= want_clusters) {\n\t\t\t/*\n\t\t\t * While we can't fit the entire write in this\n\t\t\t * extent, we know that the write goes from cpos\n\t\t\t * to the end of the extent.  Break that off.\n\t\t\t * We try to break it at some multiple of\n\t\t\t * contig_clusters from the front of the extent.\n\t\t\t * Failing that (ie, cpos is within\n\t\t\t * contig_clusters of the front), we'll CoW the\n\t\t\t * entire extent.\n\t\t\t */\n\t\t\t*cow_start = ocfs2_cow_align_start(inode->i_sb,\n\t\t\t\t\t\t\t   *cow_start, cpos);\n\t\t\t*cow_len = rec_end - *cow_start;\n\t\t} else {\n\t\t\t/*\n\t\t\t * Ok, the entire write lives in the middle of\n\t\t\t * this extent.  Let's try to slice the extent up\n\t\t\t * nicely.  Optimally, our CoW region starts at\n\t\t\t * m*contig_clusters from the beginning of the\n\t\t\t * extent and goes for n*contig_clusters,\n\t\t\t * covering the entire write.\n\t\t\t */\n\t\t\t*cow_start = ocfs2_cow_align_start(inode->i_sb,\n\t\t\t\t\t\t\t   *cow_start, cpos);\n\n\t\t\twant_clusters = (cpos + write_len) - *cow_start;\n\t\t\twant_clusters = ocfs2_cow_align_length(inode->i_sb,\n\t\t\t\t\t\t\t       want_clusters);\n\t\t\tif (*cow_start + want_clusters <= rec_end)\n\t\t\t\t*cow_len = want_clusters;\n\t\t\telse\n\t\t\t\t*cow_len = rec_end - *cow_start;\n\t\t}\n\n\t\t/* Have we covered our entire write yet? */\n\t\tif ((*cow_start + *cow_len) >= (cpos + write_len))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * If we reach the end of the extent block and don't get enough\n\t\t * clusters, continue with the next extent block if possible.\n\t\t */\n\t\tif (i + 1 == le16_to_cpu(el->l_next_free_rec) &&\n\t\t    eb && eb->h_next_leaf_blk) {\n\t\t\tbrelse(eb_bh);\n\t\t\teb_bh = NULL;\n\n\t\t\tret = ocfs2_read_extent_block(INODE_CACHE(inode),\n\t\t\t\t\t       le64_to_cpu(eb->h_next_leaf_blk),\n\t\t\t\t\t       &eb_bh);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\t\tel = &eb->h_list;\n\t\t\ti = -1;\n\t\t}\n\t}\n\nout:\n\tbrelse(eb_bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_cow_align_length",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "2622-2634",
    "snippet": "static inline unsigned int ocfs2_cow_align_length(struct super_block *sb,\n\t\t\t\t\t\t  unsigned int len)\n{\n\tunsigned int padded =\n\t\t(len + (ocfs2_cow_contig_clusters(sb) - 1)) &\n\t\tocfs2_cow_contig_mask(sb);\n\n\t/* Did we wrap? */\n\tif (padded < len)\n\t\tpadded = UINT_MAX;\n\n\treturn padded;\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_cow_contig_mask",
          "args": [
            "sb"
          ],
          "line": 2627
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_cow_contig_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "2597-2600",
          "snippet": "static inline unsigned int ocfs2_cow_contig_mask(struct super_block *sb)\n{\n\treturn ~(ocfs2_cow_contig_clusters(sb) - 1);\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic inline unsigned int ocfs2_cow_contig_mask(struct super_block *sb)\n{\n\treturn ~(ocfs2_cow_contig_clusters(sb) - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_cow_contig_clusters",
          "args": [
            "sb"
          ],
          "line": 2626
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_cow_contig_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "2592-2595",
          "snippet": "static inline unsigned int ocfs2_cow_contig_clusters(struct super_block *sb)\n{\n\treturn ocfs2_clusters_for_bytes(sb, MAX_CONTIG_BYTES);\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [
            "#define\tMAX_CONTIG_BYTES\t1048576"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\n#define\tMAX_CONTIG_BYTES\t1048576\n\nstatic inline unsigned int ocfs2_cow_contig_clusters(struct super_block *sb)\n{\n\treturn ocfs2_clusters_for_bytes(sb, MAX_CONTIG_BYTES);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic inline unsigned int ocfs2_cow_align_length(struct super_block *sb,\n\t\t\t\t\t\t  unsigned int len)\n{\n\tunsigned int padded =\n\t\t(len + (ocfs2_cow_contig_clusters(sb) - 1)) &\n\t\tocfs2_cow_contig_mask(sb);\n\n\t/* Did we wrap? */\n\tif (padded < len)\n\t\tpadded = UINT_MAX;\n\n\treturn padded;\n}"
  },
  {
    "function_name": "ocfs2_cow_align_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "2609-2616",
    "snippet": "static inline unsigned int ocfs2_cow_align_start(struct super_block *sb,\n\t\t\t\t\t\t unsigned int start,\n\t\t\t\t\t\t unsigned int cpos)\n{\n\tBUG_ON(start > cpos);\n\n\treturn start + ((cpos - start) & ocfs2_cow_contig_mask(sb));\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_cow_contig_mask",
          "args": [
            "sb"
          ],
          "line": 2615
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_cow_contig_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "2597-2600",
          "snippet": "static inline unsigned int ocfs2_cow_contig_mask(struct super_block *sb)\n{\n\treturn ~(ocfs2_cow_contig_clusters(sb) - 1);\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic inline unsigned int ocfs2_cow_contig_mask(struct super_block *sb)\n{\n\treturn ~(ocfs2_cow_contig_clusters(sb) - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "start > cpos"
          ],
          "line": 2613
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic inline unsigned int ocfs2_cow_align_start(struct super_block *sb,\n\t\t\t\t\t\t unsigned int start,\n\t\t\t\t\t\t unsigned int cpos)\n{\n\tBUG_ON(start > cpos);\n\n\treturn start + ((cpos - start) & ocfs2_cow_contig_mask(sb));\n}"
  },
  {
    "function_name": "ocfs2_cow_contig_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "2597-2600",
    "snippet": "static inline unsigned int ocfs2_cow_contig_mask(struct super_block *sb)\n{\n\treturn ~(ocfs2_cow_contig_clusters(sb) - 1);\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_cow_contig_clusters",
          "args": [
            "sb"
          ],
          "line": 2599
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_cow_contig_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "2592-2595",
          "snippet": "static inline unsigned int ocfs2_cow_contig_clusters(struct super_block *sb)\n{\n\treturn ocfs2_clusters_for_bytes(sb, MAX_CONTIG_BYTES);\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [
            "#define\tMAX_CONTIG_BYTES\t1048576"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\n#define\tMAX_CONTIG_BYTES\t1048576\n\nstatic inline unsigned int ocfs2_cow_contig_clusters(struct super_block *sb)\n{\n\treturn ocfs2_clusters_for_bytes(sb, MAX_CONTIG_BYTES);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic inline unsigned int ocfs2_cow_contig_mask(struct super_block *sb)\n{\n\treturn ~(ocfs2_cow_contig_clusters(sb) - 1);\n}"
  },
  {
    "function_name": "ocfs2_cow_contig_clusters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "2592-2595",
    "snippet": "static inline unsigned int ocfs2_cow_contig_clusters(struct super_block *sb)\n{\n\treturn ocfs2_clusters_for_bytes(sb, MAX_CONTIG_BYTES);\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [
      "#define\tMAX_CONTIG_BYTES\t1048576"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_clusters_for_bytes",
          "args": [
            "sb",
            "MAX_CONTIG_BYTES"
          ],
          "line": 2594
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_for_bytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "729-740",
          "snippet": "static inline unsigned int ocfs2_clusters_for_bytes(struct super_block *sb,\n\t\t\t\t\t\t    u64 bytes)\n{\n\tint cl_bits = OCFS2_SB(sb)->s_clustersize_bits;\n\tunsigned int clusters;\n\n\tbytes += OCFS2_SB(sb)->s_clustersize - 1;\n\t/* OCFS2 just cannot have enough clusters to overflow this */\n\tclusters = (unsigned int)(bytes >> cl_bits);\n\n\treturn clusters;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline unsigned int ocfs2_clusters_for_bytes(struct super_block *sb,\n\t\t\t\t\t\t    u64 bytes)\n{\n\tint cl_bits = OCFS2_SB(sb)->s_clustersize_bits;\n\tunsigned int clusters;\n\n\tbytes += OCFS2_SB(sb)->s_clustersize - 1;\n\t/* OCFS2 just cannot have enough clusters to overflow this */\n\tclusters = (unsigned int)(bytes >> cl_bits);\n\n\treturn clusters;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\n#define\tMAX_CONTIG_BYTES\t1048576\n\nstatic inline unsigned int ocfs2_cow_contig_clusters(struct super_block *sb)\n{\n\treturn ocfs2_clusters_for_bytes(sb, MAX_CONTIG_BYTES);\n}"
  },
  {
    "function_name": "ocfs2_prepare_refcount_change_for_del",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "2536-2588",
    "snippet": "int ocfs2_prepare_refcount_change_for_del(struct inode *inode,\n\t\t\t\t\t  u64 refcount_loc,\n\t\t\t\t\t  u64 phys_blkno,\n\t\t\t\t\t  u32 clusters,\n\t\t\t\t\t  int *credits,\n\t\t\t\t\t  int *ref_blocks)\n{\n\tint ret;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_tree *tree;\n\tu64 start_cpos = ocfs2_blocks_to_clusters(inode->i_sb, phys_blkno);\n\n\tif (!ocfs2_refcount_tree(OCFS2_SB(inode->i_sb))) {\n\t\tocfs2_error(inode->i_sb, \"Inode %lu want to use refcount \"\n\t\t\t    \"tree, but the feature bit is not set in the \"\n\t\t\t    \"super block.\", inode->i_ino);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\tBUG_ON(!(oi->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL));\n\n\tret = ocfs2_get_refcount_tree(OCFS2_SB(inode->i_sb),\n\t\t\t\t      refcount_loc, &tree);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_refcount_block(&tree->rf_ci, refcount_loc,\n\t\t\t\t\t&ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_calc_refcount_meta_credits(inode->i_sb,\n\t\t\t\t\t       &tree->rf_ci,\n\t\t\t\t\t       ref_root_bh,\n\t\t\t\t\t       start_cpos, clusters,\n\t\t\t\t\t       ref_blocks, credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_prepare_refcount_change_for_del(*ref_blocks, *credits);\n\nout:\n\tbrelse(ref_root_bh);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "ref_root_bh"
          ],
          "line": 2586
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_prepare_refcount_change_for_del",
          "args": [
            "*ref_blocks",
            "*credits"
          ],
          "line": 2583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_calc_refcount_meta_credits",
          "args": [
            "inode->i_sb",
            "&tree->rf_ci",
            "ref_root_bh",
            "start_cpos",
            "clusters",
            "ref_blocks",
            "credits"
          ],
          "line": 2573
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_calc_refcount_meta_credits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "2385-2522",
          "snippet": "static int ocfs2_calc_refcount_meta_credits(struct super_block *sb,\n\t\t\t\t\t    struct ocfs2_caching_info *ci,\n\t\t\t\t\t    struct buffer_head *ref_root_bh,\n\t\t\t\t\t    u64 start_cpos,\n\t\t\t\t\t    u32 clusters,\n\t\t\t\t\t    int *meta_add,\n\t\t\t\t\t    int *credits)\n{\n\tint ret = 0, index, ref_blocks = 0, recs_add = 0;\n\tu64 cpos = start_cpos;\n\tstruct ocfs2_refcount_block *rb;\n\tstruct ocfs2_refcount_rec rec;\n\tstruct buffer_head *ref_leaf_bh = NULL, *prev_bh = NULL;\n\tu32 len;\n\n\twhile (clusters) {\n\t\tret = ocfs2_get_refcount_rec(ci, ref_root_bh,\n\t\t\t\t\t     cpos, clusters, &rec,\n\t\t\t\t\t     &index, &ref_leaf_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (ref_leaf_bh != prev_bh) {\n\t\t\t/*\n\t\t\t * Now we encounter a new leaf block, so calculate\n\t\t\t * whether we need to extend the old leaf.\n\t\t\t */\n\t\t\tif (prev_bh) {\n\t\t\t\trb = (struct ocfs2_refcount_block *)\n\t\t\t\t\t\t\tprev_bh->b_data;\n\n\t\t\t\tif (le16_to_cpu(rb->rf_records.rl_used) +\n\t\t\t\t    recs_add >\n\t\t\t\t    le16_to_cpu(rb->rf_records.rl_count))\n\t\t\t\t\tref_blocks++;\n\t\t\t}\n\n\t\t\trecs_add = 0;\n\t\t\t*credits += 1;\n\t\t\tbrelse(prev_bh);\n\t\t\tprev_bh = ref_leaf_bh;\n\t\t\tget_bh(prev_bh);\n\t\t}\n\n\t\ttrace_ocfs2_calc_refcount_meta_credits_iterate(\n\t\t\t\trecs_add, (unsigned long long)cpos, clusters,\n\t\t\t\t(unsigned long long)le64_to_cpu(rec.r_cpos),\n\t\t\t\tle32_to_cpu(rec.r_clusters),\n\t\t\t\tle32_to_cpu(rec.r_refcount), index);\n\n\t\tlen = min((u64)cpos + clusters, le64_to_cpu(rec.r_cpos) +\n\t\t\t  le32_to_cpu(rec.r_clusters)) - cpos;\n\t\t/*\n\t\t * We record all the records which will be inserted to the\n\t\t * same refcount block, so that we can tell exactly whether\n\t\t * we need a new refcount block or not.\n\t\t *\n\t\t * If we will insert a new one, this is easy and only happens\n\t\t * during adding refcounted flag to the extent, so we don't\n\t\t * have a chance of spliting. We just need one record.\n\t\t *\n\t\t * If the refcount rec already exists, that would be a little\n\t\t * complicated. we may have to:\n\t\t * 1) split at the beginning if the start pos isn't aligned.\n\t\t *    we need 1 more record in this case.\n\t\t * 2) split int the end if the end pos isn't aligned.\n\t\t *    we need 1 more record in this case.\n\t\t * 3) split in the middle because of file system fragmentation.\n\t\t *    we need 2 more records in this case(we can't detect this\n\t\t *    beforehand, so always think of the worst case).\n\t\t */\n\t\tif (rec.r_refcount) {\n\t\t\trecs_add += 2;\n\t\t\t/* Check whether we need a split at the beginning. */\n\t\t\tif (cpos == start_cpos &&\n\t\t\t    cpos != le64_to_cpu(rec.r_cpos))\n\t\t\t\trecs_add++;\n\n\t\t\t/* Check whether we need a split in the end. */\n\t\t\tif (cpos + clusters < le64_to_cpu(rec.r_cpos) +\n\t\t\t    le32_to_cpu(rec.r_clusters))\n\t\t\t\trecs_add++;\n\t\t} else\n\t\t\trecs_add++;\n\n\t\tbrelse(ref_leaf_bh);\n\t\tref_leaf_bh = NULL;\n\t\tclusters -= len;\n\t\tcpos += len;\n\t}\n\n\tif (prev_bh) {\n\t\trb = (struct ocfs2_refcount_block *)prev_bh->b_data;\n\n\t\tif (le16_to_cpu(rb->rf_records.rl_used) + recs_add >\n\t\t    le16_to_cpu(rb->rf_records.rl_count))\n\t\t\tref_blocks++;\n\n\t\t*credits += 1;\n\t}\n\n\tif (!ref_blocks)\n\t\tgoto out;\n\n\t*meta_add += ref_blocks;\n\t*credits += ref_blocks;\n\n\t/*\n\t * So we may need ref_blocks to insert into the tree.\n\t * That also means we need to change the b-tree and add that number\n\t * of records since we never merge them.\n\t * We need one more block for expansion since the new created leaf\n\t * block is also full and needs split.\n\t */\n\trb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\tif (le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL) {\n\t\tstruct ocfs2_extent_tree et;\n\n\t\tocfs2_init_refcount_extent_tree(&et, ci, ref_root_bh);\n\t\t*meta_add += ocfs2_extend_meta_needed(et.et_root_el);\n\t\t*credits += ocfs2_calc_extend_credits(sb,\n\t\t\t\t\t\t      et.et_root_el);\n\t} else {\n\t\t*credits += OCFS2_EXPAND_REFCOUNT_TREE_CREDITS;\n\t\t*meta_add += 1;\n\t}\n\nout:\n\n\ttrace_ocfs2_calc_refcount_meta_credits(\n\t\t(unsigned long long)start_cpos, clusters,\n\t\t*meta_add, *credits);\n\tbrelse(ref_leaf_bh);\n\tbrelse(prev_bh);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_calc_refcount_meta_credits(struct super_block *sb,\n\t\t\t\t\t    struct ocfs2_caching_info *ci,\n\t\t\t\t\t    struct buffer_head *ref_root_bh,\n\t\t\t\t\t    u64 start_cpos,\n\t\t\t\t\t    u32 clusters,\n\t\t\t\t\t    int *meta_add,\n\t\t\t\t\t    int *credits)\n{\n\tint ret = 0, index, ref_blocks = 0, recs_add = 0;\n\tu64 cpos = start_cpos;\n\tstruct ocfs2_refcount_block *rb;\n\tstruct ocfs2_refcount_rec rec;\n\tstruct buffer_head *ref_leaf_bh = NULL, *prev_bh = NULL;\n\tu32 len;\n\n\twhile (clusters) {\n\t\tret = ocfs2_get_refcount_rec(ci, ref_root_bh,\n\t\t\t\t\t     cpos, clusters, &rec,\n\t\t\t\t\t     &index, &ref_leaf_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (ref_leaf_bh != prev_bh) {\n\t\t\t/*\n\t\t\t * Now we encounter a new leaf block, so calculate\n\t\t\t * whether we need to extend the old leaf.\n\t\t\t */\n\t\t\tif (prev_bh) {\n\t\t\t\trb = (struct ocfs2_refcount_block *)\n\t\t\t\t\t\t\tprev_bh->b_data;\n\n\t\t\t\tif (le16_to_cpu(rb->rf_records.rl_used) +\n\t\t\t\t    recs_add >\n\t\t\t\t    le16_to_cpu(rb->rf_records.rl_count))\n\t\t\t\t\tref_blocks++;\n\t\t\t}\n\n\t\t\trecs_add = 0;\n\t\t\t*credits += 1;\n\t\t\tbrelse(prev_bh);\n\t\t\tprev_bh = ref_leaf_bh;\n\t\t\tget_bh(prev_bh);\n\t\t}\n\n\t\ttrace_ocfs2_calc_refcount_meta_credits_iterate(\n\t\t\t\trecs_add, (unsigned long long)cpos, clusters,\n\t\t\t\t(unsigned long long)le64_to_cpu(rec.r_cpos),\n\t\t\t\tle32_to_cpu(rec.r_clusters),\n\t\t\t\tle32_to_cpu(rec.r_refcount), index);\n\n\t\tlen = min((u64)cpos + clusters, le64_to_cpu(rec.r_cpos) +\n\t\t\t  le32_to_cpu(rec.r_clusters)) - cpos;\n\t\t/*\n\t\t * We record all the records which will be inserted to the\n\t\t * same refcount block, so that we can tell exactly whether\n\t\t * we need a new refcount block or not.\n\t\t *\n\t\t * If we will insert a new one, this is easy and only happens\n\t\t * during adding refcounted flag to the extent, so we don't\n\t\t * have a chance of spliting. We just need one record.\n\t\t *\n\t\t * If the refcount rec already exists, that would be a little\n\t\t * complicated. we may have to:\n\t\t * 1) split at the beginning if the start pos isn't aligned.\n\t\t *    we need 1 more record in this case.\n\t\t * 2) split int the end if the end pos isn't aligned.\n\t\t *    we need 1 more record in this case.\n\t\t * 3) split in the middle because of file system fragmentation.\n\t\t *    we need 2 more records in this case(we can't detect this\n\t\t *    beforehand, so always think of the worst case).\n\t\t */\n\t\tif (rec.r_refcount) {\n\t\t\trecs_add += 2;\n\t\t\t/* Check whether we need a split at the beginning. */\n\t\t\tif (cpos == start_cpos &&\n\t\t\t    cpos != le64_to_cpu(rec.r_cpos))\n\t\t\t\trecs_add++;\n\n\t\t\t/* Check whether we need a split in the end. */\n\t\t\tif (cpos + clusters < le64_to_cpu(rec.r_cpos) +\n\t\t\t    le32_to_cpu(rec.r_clusters))\n\t\t\t\trecs_add++;\n\t\t} else\n\t\t\trecs_add++;\n\n\t\tbrelse(ref_leaf_bh);\n\t\tref_leaf_bh = NULL;\n\t\tclusters -= len;\n\t\tcpos += len;\n\t}\n\n\tif (prev_bh) {\n\t\trb = (struct ocfs2_refcount_block *)prev_bh->b_data;\n\n\t\tif (le16_to_cpu(rb->rf_records.rl_used) + recs_add >\n\t\t    le16_to_cpu(rb->rf_records.rl_count))\n\t\t\tref_blocks++;\n\n\t\t*credits += 1;\n\t}\n\n\tif (!ref_blocks)\n\t\tgoto out;\n\n\t*meta_add += ref_blocks;\n\t*credits += ref_blocks;\n\n\t/*\n\t * So we may need ref_blocks to insert into the tree.\n\t * That also means we need to change the b-tree and add that number\n\t * of records since we never merge them.\n\t * We need one more block for expansion since the new created leaf\n\t * block is also full and needs split.\n\t */\n\trb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\tif (le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL) {\n\t\tstruct ocfs2_extent_tree et;\n\n\t\tocfs2_init_refcount_extent_tree(&et, ci, ref_root_bh);\n\t\t*meta_add += ocfs2_extend_meta_needed(et.et_root_el);\n\t\t*credits += ocfs2_calc_extend_credits(sb,\n\t\t\t\t\t\t      et.et_root_el);\n\t} else {\n\t\t*credits += OCFS2_EXPAND_REFCOUNT_TREE_CREDITS;\n\t\t*meta_add += 1;\n\t}\n\nout:\n\n\ttrace_ocfs2_calc_refcount_meta_credits(\n\t\t(unsigned long long)start_cpos, clusters,\n\t\t*meta_add, *credits);\n\tbrelse(ref_leaf_bh);\n\tbrelse(prev_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_refcount_block",
          "args": [
            "&tree->rf_ci",
            "refcount_loc",
            "&ref_root_bh"
          ],
          "line": 2566
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_refcount_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "133-148",
          "snippet": "static int ocfs2_read_refcount_block(struct ocfs2_caching_info *ci,\n\t\t\t\t     u64 rb_blkno,\n\t\t\t\t     struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(ci, rb_blkno, &tmp,\n\t\t\t      ocfs2_validate_refcount_block);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_read_refcount_block(struct ocfs2_caching_info *ci,\n\t\t\t\t     u64 rb_blkno,\n\t\t\t\t     struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(ci, rb_blkno, &tmp,\n\t\t\t      ocfs2_validate_refcount_block);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_refcount_tree",
          "args": [
            "OCFS2_SB(inode->i_sb)",
            "refcount_loc",
            "&tree"
          ],
          "line": 2559
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_get_refcount_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "332-401",
          "snippet": "static int ocfs2_get_refcount_tree(struct ocfs2_super *osb, u64 rf_blkno,\n\t\t\t\t   struct ocfs2_refcount_tree **ret_tree)\n{\n\tint ret = 0;\n\tstruct ocfs2_refcount_tree *tree, *new = NULL;\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_block *ref_rb;\n\n\tspin_lock(&osb->osb_lock);\n\tif (osb->osb_ref_tree_lru &&\n\t    osb->osb_ref_tree_lru->rf_blkno == rf_blkno)\n\t\ttree = osb->osb_ref_tree_lru;\n\telse\n\t\ttree = ocfs2_find_refcount_tree(osb, rf_blkno);\n\tif (tree)\n\t\tgoto out;\n\n\tspin_unlock(&osb->osb_lock);\n\n\tnew = ocfs2_allocate_refcount_tree(osb, rf_blkno);\n\tif (!new) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\t/*\n\t * We need the generation to create the refcount tree lock and since\n\t * it isn't changed during the tree modification, we are safe here to\n\t * read without protection.\n\t * We also have to purge the cache after we create the lock since the\n\t * refcount block may have the stale data. It can only be trusted when\n\t * we hold the refcount lock.\n\t */\n\tret = ocfs2_read_refcount_block(&new->rf_ci, rf_blkno, &ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_metadata_cache_exit(&new->rf_ci);\n\t\tkfree(new);\n\t\treturn ret;\n\t}\n\n\tref_rb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\tnew->rf_generation = le32_to_cpu(ref_rb->rf_generation);\n\tocfs2_init_refcount_tree_lock(osb, new, rf_blkno,\n\t\t\t\t      new->rf_generation);\n\tocfs2_metadata_cache_purge(&new->rf_ci);\n\n\tspin_lock(&osb->osb_lock);\n\ttree = ocfs2_find_refcount_tree(osb, rf_blkno);\n\tif (tree)\n\t\tgoto out;\n\n\tocfs2_insert_refcount_tree(osb, new);\n\n\ttree = new;\n\tnew = NULL;\n\nout:\n\t*ret_tree = tree;\n\n\tosb->osb_ref_tree_lru = tree;\n\n\tspin_unlock(&osb->osb_lock);\n\n\tif (new)\n\t\tocfs2_free_refcount_tree(new);\n\n\tbrelse(ref_root_bh);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_get_refcount_tree(struct ocfs2_super *osb, u64 rf_blkno,\n\t\t\t\t   struct ocfs2_refcount_tree **ret_tree)\n{\n\tint ret = 0;\n\tstruct ocfs2_refcount_tree *tree, *new = NULL;\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_block *ref_rb;\n\n\tspin_lock(&osb->osb_lock);\n\tif (osb->osb_ref_tree_lru &&\n\t    osb->osb_ref_tree_lru->rf_blkno == rf_blkno)\n\t\ttree = osb->osb_ref_tree_lru;\n\telse\n\t\ttree = ocfs2_find_refcount_tree(osb, rf_blkno);\n\tif (tree)\n\t\tgoto out;\n\n\tspin_unlock(&osb->osb_lock);\n\n\tnew = ocfs2_allocate_refcount_tree(osb, rf_blkno);\n\tif (!new) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\t/*\n\t * We need the generation to create the refcount tree lock and since\n\t * it isn't changed during the tree modification, we are safe here to\n\t * read without protection.\n\t * We also have to purge the cache after we create the lock since the\n\t * refcount block may have the stale data. It can only be trusted when\n\t * we hold the refcount lock.\n\t */\n\tret = ocfs2_read_refcount_block(&new->rf_ci, rf_blkno, &ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_metadata_cache_exit(&new->rf_ci);\n\t\tkfree(new);\n\t\treturn ret;\n\t}\n\n\tref_rb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\tnew->rf_generation = le32_to_cpu(ref_rb->rf_generation);\n\tocfs2_init_refcount_tree_lock(osb, new, rf_blkno,\n\t\t\t\t      new->rf_generation);\n\tocfs2_metadata_cache_purge(&new->rf_ci);\n\n\tspin_lock(&osb->osb_lock);\n\ttree = ocfs2_find_refcount_tree(osb, rf_blkno);\n\tif (tree)\n\t\tgoto out;\n\n\tocfs2_insert_refcount_tree(osb, new);\n\n\ttree = new;\n\tnew = NULL;\n\nout:\n\t*ret_tree = tree;\n\n\tosb->osb_ref_tree_lru = tree;\n\n\tspin_unlock(&osb->osb_lock);\n\n\tif (new)\n\t\tocfs2_free_refcount_tree(new);\n\n\tbrelse(ref_root_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 2559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(oi->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL)"
          ],
          "line": 2557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_error",
          "args": [
            "inode->i_sb",
            "\"Inode %lu want to use refcount \"\n\t\t\t    \"tree, but the feature bit is not set in the \"\n\t\t\t    \"super block.\"",
            "inode->i_ino"
          ],
          "line": 2550
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2568-2584",
          "snippet": "void __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic char error_buf[1024];\n\nvoid __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_refcount_tree",
          "args": [
            "OCFS2_SB(inode->i_sb)"
          ],
          "line": 2549
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_refcount_tree_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "292-296",
          "snippet": "static inline void\nocfs2_refcount_tree_put(struct ocfs2_refcount_tree *tree)\n{\n\tkref_put(&tree->rf_getcnt, ocfs2_kref_remove_refcount_tree);\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic inline void\nocfs2_refcount_tree_put(struct ocfs2_refcount_tree *tree)\n{\n\tkref_put(&tree->rf_getcnt, ocfs2_kref_remove_refcount_tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 2549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_blocks_to_clusters",
          "args": [
            "inode->i_sb",
            "phys_blkno"
          ],
          "line": 2547
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_blocks_to_clusters",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "720-727",
          "snippet": "static inline u32 ocfs2_blocks_to_clusters(struct super_block *sb,\n\t\t\t\t\t   u64 blocks)\n{\n\tint b_to_c_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u32)(blocks >> b_to_c_bits);\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u32 ocfs2_blocks_to_clusters(struct super_block *sb,\n\t\t\t\t\t   u64 blocks)\n{\n\tint b_to_c_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u32)(blocks >> b_to_c_bits);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 2544
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nint ocfs2_prepare_refcount_change_for_del(struct inode *inode,\n\t\t\t\t\t  u64 refcount_loc,\n\t\t\t\t\t  u64 phys_blkno,\n\t\t\t\t\t  u32 clusters,\n\t\t\t\t\t  int *credits,\n\t\t\t\t\t  int *ref_blocks)\n{\n\tint ret;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_tree *tree;\n\tu64 start_cpos = ocfs2_blocks_to_clusters(inode->i_sb, phys_blkno);\n\n\tif (!ocfs2_refcount_tree(OCFS2_SB(inode->i_sb))) {\n\t\tocfs2_error(inode->i_sb, \"Inode %lu want to use refcount \"\n\t\t\t    \"tree, but the feature bit is not set in the \"\n\t\t\t    \"super block.\", inode->i_ino);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\tBUG_ON(!(oi->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL));\n\n\tret = ocfs2_get_refcount_tree(OCFS2_SB(inode->i_sb),\n\t\t\t\t      refcount_loc, &tree);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_refcount_block(&tree->rf_ci, refcount_loc,\n\t\t\t\t\t&ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_calc_refcount_meta_credits(inode->i_sb,\n\t\t\t\t\t       &tree->rf_ci,\n\t\t\t\t\t       ref_root_bh,\n\t\t\t\t\t       start_cpos, clusters,\n\t\t\t\t\t       ref_blocks, credits);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_prepare_refcount_change_for_del(*ref_blocks, *credits);\n\nout:\n\tbrelse(ref_root_bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_calc_refcount_meta_credits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "2385-2522",
    "snippet": "static int ocfs2_calc_refcount_meta_credits(struct super_block *sb,\n\t\t\t\t\t    struct ocfs2_caching_info *ci,\n\t\t\t\t\t    struct buffer_head *ref_root_bh,\n\t\t\t\t\t    u64 start_cpos,\n\t\t\t\t\t    u32 clusters,\n\t\t\t\t\t    int *meta_add,\n\t\t\t\t\t    int *credits)\n{\n\tint ret = 0, index, ref_blocks = 0, recs_add = 0;\n\tu64 cpos = start_cpos;\n\tstruct ocfs2_refcount_block *rb;\n\tstruct ocfs2_refcount_rec rec;\n\tstruct buffer_head *ref_leaf_bh = NULL, *prev_bh = NULL;\n\tu32 len;\n\n\twhile (clusters) {\n\t\tret = ocfs2_get_refcount_rec(ci, ref_root_bh,\n\t\t\t\t\t     cpos, clusters, &rec,\n\t\t\t\t\t     &index, &ref_leaf_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (ref_leaf_bh != prev_bh) {\n\t\t\t/*\n\t\t\t * Now we encounter a new leaf block, so calculate\n\t\t\t * whether we need to extend the old leaf.\n\t\t\t */\n\t\t\tif (prev_bh) {\n\t\t\t\trb = (struct ocfs2_refcount_block *)\n\t\t\t\t\t\t\tprev_bh->b_data;\n\n\t\t\t\tif (le16_to_cpu(rb->rf_records.rl_used) +\n\t\t\t\t    recs_add >\n\t\t\t\t    le16_to_cpu(rb->rf_records.rl_count))\n\t\t\t\t\tref_blocks++;\n\t\t\t}\n\n\t\t\trecs_add = 0;\n\t\t\t*credits += 1;\n\t\t\tbrelse(prev_bh);\n\t\t\tprev_bh = ref_leaf_bh;\n\t\t\tget_bh(prev_bh);\n\t\t}\n\n\t\ttrace_ocfs2_calc_refcount_meta_credits_iterate(\n\t\t\t\trecs_add, (unsigned long long)cpos, clusters,\n\t\t\t\t(unsigned long long)le64_to_cpu(rec.r_cpos),\n\t\t\t\tle32_to_cpu(rec.r_clusters),\n\t\t\t\tle32_to_cpu(rec.r_refcount), index);\n\n\t\tlen = min((u64)cpos + clusters, le64_to_cpu(rec.r_cpos) +\n\t\t\t  le32_to_cpu(rec.r_clusters)) - cpos;\n\t\t/*\n\t\t * We record all the records which will be inserted to the\n\t\t * same refcount block, so that we can tell exactly whether\n\t\t * we need a new refcount block or not.\n\t\t *\n\t\t * If we will insert a new one, this is easy and only happens\n\t\t * during adding refcounted flag to the extent, so we don't\n\t\t * have a chance of spliting. We just need one record.\n\t\t *\n\t\t * If the refcount rec already exists, that would be a little\n\t\t * complicated. we may have to:\n\t\t * 1) split at the beginning if the start pos isn't aligned.\n\t\t *    we need 1 more record in this case.\n\t\t * 2) split int the end if the end pos isn't aligned.\n\t\t *    we need 1 more record in this case.\n\t\t * 3) split in the middle because of file system fragmentation.\n\t\t *    we need 2 more records in this case(we can't detect this\n\t\t *    beforehand, so always think of the worst case).\n\t\t */\n\t\tif (rec.r_refcount) {\n\t\t\trecs_add += 2;\n\t\t\t/* Check whether we need a split at the beginning. */\n\t\t\tif (cpos == start_cpos &&\n\t\t\t    cpos != le64_to_cpu(rec.r_cpos))\n\t\t\t\trecs_add++;\n\n\t\t\t/* Check whether we need a split in the end. */\n\t\t\tif (cpos + clusters < le64_to_cpu(rec.r_cpos) +\n\t\t\t    le32_to_cpu(rec.r_clusters))\n\t\t\t\trecs_add++;\n\t\t} else\n\t\t\trecs_add++;\n\n\t\tbrelse(ref_leaf_bh);\n\t\tref_leaf_bh = NULL;\n\t\tclusters -= len;\n\t\tcpos += len;\n\t}\n\n\tif (prev_bh) {\n\t\trb = (struct ocfs2_refcount_block *)prev_bh->b_data;\n\n\t\tif (le16_to_cpu(rb->rf_records.rl_used) + recs_add >\n\t\t    le16_to_cpu(rb->rf_records.rl_count))\n\t\t\tref_blocks++;\n\n\t\t*credits += 1;\n\t}\n\n\tif (!ref_blocks)\n\t\tgoto out;\n\n\t*meta_add += ref_blocks;\n\t*credits += ref_blocks;\n\n\t/*\n\t * So we may need ref_blocks to insert into the tree.\n\t * That also means we need to change the b-tree and add that number\n\t * of records since we never merge them.\n\t * We need one more block for expansion since the new created leaf\n\t * block is also full and needs split.\n\t */\n\trb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\tif (le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL) {\n\t\tstruct ocfs2_extent_tree et;\n\n\t\tocfs2_init_refcount_extent_tree(&et, ci, ref_root_bh);\n\t\t*meta_add += ocfs2_extend_meta_needed(et.et_root_el);\n\t\t*credits += ocfs2_calc_extend_credits(sb,\n\t\t\t\t\t\t      et.et_root_el);\n\t} else {\n\t\t*credits += OCFS2_EXPAND_REFCOUNT_TREE_CREDITS;\n\t\t*meta_add += 1;\n\t}\n\nout:\n\n\ttrace_ocfs2_calc_refcount_meta_credits(\n\t\t(unsigned long long)start_cpos, clusters,\n\t\t*meta_add, *credits);\n\tbrelse(ref_leaf_bh);\n\tbrelse(prev_bh);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "prev_bh"
          ],
          "line": 2520
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_calc_refcount_meta_credits",
          "args": [
            "(unsigned long long)start_cpos",
            "clusters",
            "*meta_add",
            "*credits"
          ],
          "line": 2516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_calc_extend_credits",
          "args": [
            "sb",
            "et.et_root_el"
          ],
          "line": 2507
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_calc_extend_credits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.h",
          "lines": "531-556",
          "snippet": "static inline int ocfs2_calc_extend_credits(struct super_block *sb,\n\t\t\t\t\t    struct ocfs2_extent_list *root_el)\n{\n\tint bitmap_blocks, sysfile_bitmap_blocks, extent_blocks;\n\n\t/* bitmap dinode, group desc. + relinked group. */\n\tbitmap_blocks = OCFS2_SUBALLOC_ALLOC;\n\n\t/* we might need to shift tree depth so lets assume an\n\t * absolute worst case of complete fragmentation.  Even with\n\t * that, we only need one update for the dinode, and then\n\t * however many metadata chunks needed * a remaining suballoc\n\t * alloc. */\n\tsysfile_bitmap_blocks = 1 +\n\t\t(OCFS2_SUBALLOC_ALLOC - 1) * ocfs2_extend_meta_needed(root_el);\n\n\t/* this does not include *new* metadata blocks, which are\n\t * accounted for in sysfile_bitmap_blocks. root_el +\n\t * prev. last_eb_blk + blocks along edge of tree.\n\t * calc_symlink_credits passes because we just need 1\n\t * credit for the dinode there. */\n\textent_blocks = 1 + 1 + le16_to_cpu(root_el->l_tree_depth);\n\n\treturn bitmap_blocks + sysfile_bitmap_blocks + extent_blocks +\n\t       ocfs2_quota_trans_credits(sb);\n}",
          "includes": [
            "#include <linux/jbd2.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_SUBALLOC_ALLOC (3)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/jbd2.h>\n#include <linux/fs.h>\n\n#define OCFS2_SUBALLOC_ALLOC (3)\n\nstatic inline int ocfs2_calc_extend_credits(struct super_block *sb,\n\t\t\t\t\t    struct ocfs2_extent_list *root_el)\n{\n\tint bitmap_blocks, sysfile_bitmap_blocks, extent_blocks;\n\n\t/* bitmap dinode, group desc. + relinked group. */\n\tbitmap_blocks = OCFS2_SUBALLOC_ALLOC;\n\n\t/* we might need to shift tree depth so lets assume an\n\t * absolute worst case of complete fragmentation.  Even with\n\t * that, we only need one update for the dinode, and then\n\t * however many metadata chunks needed * a remaining suballoc\n\t * alloc. */\n\tsysfile_bitmap_blocks = 1 +\n\t\t(OCFS2_SUBALLOC_ALLOC - 1) * ocfs2_extend_meta_needed(root_el);\n\n\t/* this does not include *new* metadata blocks, which are\n\t * accounted for in sysfile_bitmap_blocks. root_el +\n\t * prev. last_eb_blk + blocks along edge of tree.\n\t * calc_symlink_credits passes because we just need 1\n\t * credit for the dinode there. */\n\textent_blocks = 1 + 1 + le16_to_cpu(root_el->l_tree_depth);\n\n\treturn bitmap_blocks + sysfile_bitmap_blocks + extent_blocks +\n\t       ocfs2_quota_trans_credits(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_extend_meta_needed",
          "args": [
            "et.et_root_el"
          ],
          "line": 2506
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extend_meta_needed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.h",
          "lines": "157-168",
          "snippet": "static inline int ocfs2_extend_meta_needed(struct ocfs2_extent_list *root_el)\n{\n\t/*\n\t * Rather than do all the work of determining how much we need\n\t * (involves a ton of reads and locks), just ask for the\n\t * maximal limit.  That's a tree depth shift.  So, one block for\n\t * level of the tree (current l_tree_depth), one block for the\n\t * new tree_depth==0 extent_block, and one block at the new\n\t * top-of-the tree.\n\t */\n\treturn le16_to_cpu(root_el->l_tree_depth) + 2;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int ocfs2_extend_meta_needed(struct ocfs2_extent_list *root_el)\n{\n\t/*\n\t * Rather than do all the work of determining how much we need\n\t * (involves a ton of reads and locks), just ask for the\n\t * maximal limit.  That's a tree depth shift.  So, one block for\n\t * level of the tree (current l_tree_depth), one block for the\n\t * new tree_depth==0 extent_block, and one block at the new\n\t * top-of-the tree.\n\t */\n\treturn le16_to_cpu(root_el->l_tree_depth) + 2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_init_refcount_extent_tree",
          "args": [
            "&et",
            "ci",
            "ref_root_bh"
          ],
          "line": 2505
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_refcount_extent_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "490-496",
          "snippet": "void ocfs2_init_refcount_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_rb,\n\t\t\t\t NULL, &ocfs2_refcount_tree_et_ops);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static struct ocfs2_extent_tree_operations ocfs2_refcount_tree_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_refcount_tree_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_refcount_tree_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_refcount_tree_update_clusters,\n\t.eo_fill_root_el\t= ocfs2_refcount_tree_fill_root_el,\n\t.eo_extent_contig\t= ocfs2_refcount_tree_extent_contig,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic struct ocfs2_extent_tree_operations ocfs2_refcount_tree_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_refcount_tree_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_refcount_tree_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_refcount_tree_update_clusters,\n\t.eo_fill_root_el\t= ocfs2_refcount_tree_fill_root_el,\n\t.eo_extent_contig\t= ocfs2_refcount_tree_extent_contig,\n};\n\nvoid ocfs2_init_refcount_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_rb,\n\t\t\t\t NULL, &ocfs2_refcount_tree_et_ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rb->rf_flags"
          ],
          "line": 2502
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "rb->rf_records.rl_count"
          ],
          "line": 2482
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "rec.r_cpos"
          ],
          "line": 2466
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "(u64)cpos + clusters",
            "le64_to_cpu(rec.r_cpos) +\n\t\t\t  le32_to_cpu(rec.r_clusters)"
          ],
          "line": 2437
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_hamming_encode_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
          "lines": "154-157",
          "snippet": "u32 ocfs2_hamming_encode_block(void *data, unsigned int blocksize)\n{\n\treturn ocfs2_hamming_encode(0, data, blocksize * 8, 0);\n}",
          "includes": [
            "#include \"blockcheck.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nu32 ocfs2_hamming_encode_block(void *data, unsigned int blocksize)\n{\n\treturn ocfs2_hamming_encode(0, data, blocksize * 8, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_calc_refcount_meta_credits_iterate",
          "args": [
            "recs_add",
            "(unsigned long long)cpos",
            "clusters",
            "(unsigned long long)le64_to_cpu(rec.r_cpos)",
            "le32_to_cpu(rec.r_clusters)",
            "le32_to_cpu(rec.r_refcount)",
            "index"
          ],
          "line": 2431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "prev_bh"
          ],
          "line": 2428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_refcount_rec",
          "args": [
            "ci",
            "ref_root_bh",
            "cpos",
            "clusters",
            "&rec",
            "&index",
            "&ref_leaf_bh"
          ],
          "line": 2401
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_get_refcount_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "1066-1150",
          "snippet": "static int ocfs2_get_refcount_rec(struct ocfs2_caching_info *ci,\n\t\t\t\t  struct buffer_head *ref_root_bh,\n\t\t\t\t  u64 cpos, unsigned int len,\n\t\t\t\t  struct ocfs2_refcount_rec *ret_rec,\n\t\t\t\t  int *index,\n\t\t\t\t  struct buffer_head **ret_bh)\n{\n\tint ret = 0, i, found;\n\tu32 low_cpos, uninitialized_var(cpos_end);\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec = NULL;\n\tstruct ocfs2_extent_block *eb = NULL;\n\tstruct buffer_head *eb_bh = NULL, *ref_leaf_bh = NULL;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\n\tstruct ocfs2_refcount_block *rb =\n\t\t\t(struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\n\tif (!(le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL)) {\n\t\tocfs2_find_refcount_rec_in_rl(ci, ref_root_bh, cpos, len,\n\t\t\t\t\t      ret_rec, index);\n\t\t*ret_bh = ref_root_bh;\n\t\tget_bh(ref_root_bh);\n\t\treturn 0;\n\t}\n\n\tel = &rb->rf_list;\n\tlow_cpos = cpos & OCFS2_32BIT_POS_MASK;\n\n\tif (el->l_tree_depth) {\n\t\tret = ocfs2_find_leaf(ci, el, low_cpos, &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tocfs2_error(sb,\n\t\t\t\"refcount tree %llu has non zero tree \"\n\t\t\t\"depth in leaf btree tree block %llu\\n\",\n\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t\t(unsigned long long)eb_bh->b_blocknr);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfound = 0;\n\tfor (i = le16_to_cpu(el->l_next_free_rec) - 1; i >= 0; i--) {\n\t\trec = &el->l_recs[i];\n\n\t\tif (le32_to_cpu(rec->e_cpos) <= low_cpos) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found) {\n\t\tret = ocfs2_get_refcount_cpos_end(ci, ref_root_bh,\n\t\t\t\t\t\t  eb, el, i, &cpos_end);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (cpos_end < low_cpos + len)\n\t\t\tlen = cpos_end - low_cpos;\n\t}\n\n\tret = ocfs2_read_refcount_block(ci, le64_to_cpu(rec->e_blkno),\n\t\t\t\t\t&ref_leaf_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_find_refcount_rec_in_rl(ci, ref_leaf_bh, cpos, len,\n\t\t\t\t      ret_rec, index);\n\t*ret_bh = ref_leaf_bh;\nout:\n\tbrelse(eb_bh);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_get_refcount_rec(struct ocfs2_caching_info *ci,\n\t\t\t\t  struct buffer_head *ref_root_bh,\n\t\t\t\t  u64 cpos, unsigned int len,\n\t\t\t\t  struct ocfs2_refcount_rec *ret_rec,\n\t\t\t\t  int *index,\n\t\t\t\t  struct buffer_head **ret_bh)\n{\n\tint ret = 0, i, found;\n\tu32 low_cpos, uninitialized_var(cpos_end);\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec = NULL;\n\tstruct ocfs2_extent_block *eb = NULL;\n\tstruct buffer_head *eb_bh = NULL, *ref_leaf_bh = NULL;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\n\tstruct ocfs2_refcount_block *rb =\n\t\t\t(struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\n\tif (!(le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL)) {\n\t\tocfs2_find_refcount_rec_in_rl(ci, ref_root_bh, cpos, len,\n\t\t\t\t\t      ret_rec, index);\n\t\t*ret_bh = ref_root_bh;\n\t\tget_bh(ref_root_bh);\n\t\treturn 0;\n\t}\n\n\tel = &rb->rf_list;\n\tlow_cpos = cpos & OCFS2_32BIT_POS_MASK;\n\n\tif (el->l_tree_depth) {\n\t\tret = ocfs2_find_leaf(ci, el, low_cpos, &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tocfs2_error(sb,\n\t\t\t\"refcount tree %llu has non zero tree \"\n\t\t\t\"depth in leaf btree tree block %llu\\n\",\n\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t\t(unsigned long long)eb_bh->b_blocknr);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfound = 0;\n\tfor (i = le16_to_cpu(el->l_next_free_rec) - 1; i >= 0; i--) {\n\t\trec = &el->l_recs[i];\n\n\t\tif (le32_to_cpu(rec->e_cpos) <= low_cpos) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found) {\n\t\tret = ocfs2_get_refcount_cpos_end(ci, ref_root_bh,\n\t\t\t\t\t\t  eb, el, i, &cpos_end);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (cpos_end < low_cpos + len)\n\t\t\tlen = cpos_end - low_cpos;\n\t}\n\n\tret = ocfs2_read_refcount_block(ci, le64_to_cpu(rec->e_blkno),\n\t\t\t\t\t&ref_leaf_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_find_refcount_rec_in_rl(ci, ref_leaf_bh, cpos, len,\n\t\t\t\t      ret_rec, index);\n\t*ret_bh = ref_leaf_bh;\nout:\n\tbrelse(eb_bh);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_calc_refcount_meta_credits(struct super_block *sb,\n\t\t\t\t\t    struct ocfs2_caching_info *ci,\n\t\t\t\t\t    struct buffer_head *ref_root_bh,\n\t\t\t\t\t    u64 start_cpos,\n\t\t\t\t\t    u32 clusters,\n\t\t\t\t\t    int *meta_add,\n\t\t\t\t\t    int *credits)\n{\n\tint ret = 0, index, ref_blocks = 0, recs_add = 0;\n\tu64 cpos = start_cpos;\n\tstruct ocfs2_refcount_block *rb;\n\tstruct ocfs2_refcount_rec rec;\n\tstruct buffer_head *ref_leaf_bh = NULL, *prev_bh = NULL;\n\tu32 len;\n\n\twhile (clusters) {\n\t\tret = ocfs2_get_refcount_rec(ci, ref_root_bh,\n\t\t\t\t\t     cpos, clusters, &rec,\n\t\t\t\t\t     &index, &ref_leaf_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (ref_leaf_bh != prev_bh) {\n\t\t\t/*\n\t\t\t * Now we encounter a new leaf block, so calculate\n\t\t\t * whether we need to extend the old leaf.\n\t\t\t */\n\t\t\tif (prev_bh) {\n\t\t\t\trb = (struct ocfs2_refcount_block *)\n\t\t\t\t\t\t\tprev_bh->b_data;\n\n\t\t\t\tif (le16_to_cpu(rb->rf_records.rl_used) +\n\t\t\t\t    recs_add >\n\t\t\t\t    le16_to_cpu(rb->rf_records.rl_count))\n\t\t\t\t\tref_blocks++;\n\t\t\t}\n\n\t\t\trecs_add = 0;\n\t\t\t*credits += 1;\n\t\t\tbrelse(prev_bh);\n\t\t\tprev_bh = ref_leaf_bh;\n\t\t\tget_bh(prev_bh);\n\t\t}\n\n\t\ttrace_ocfs2_calc_refcount_meta_credits_iterate(\n\t\t\t\trecs_add, (unsigned long long)cpos, clusters,\n\t\t\t\t(unsigned long long)le64_to_cpu(rec.r_cpos),\n\t\t\t\tle32_to_cpu(rec.r_clusters),\n\t\t\t\tle32_to_cpu(rec.r_refcount), index);\n\n\t\tlen = min((u64)cpos + clusters, le64_to_cpu(rec.r_cpos) +\n\t\t\t  le32_to_cpu(rec.r_clusters)) - cpos;\n\t\t/*\n\t\t * We record all the records which will be inserted to the\n\t\t * same refcount block, so that we can tell exactly whether\n\t\t * we need a new refcount block or not.\n\t\t *\n\t\t * If we will insert a new one, this is easy and only happens\n\t\t * during adding refcounted flag to the extent, so we don't\n\t\t * have a chance of spliting. We just need one record.\n\t\t *\n\t\t * If the refcount rec already exists, that would be a little\n\t\t * complicated. we may have to:\n\t\t * 1) split at the beginning if the start pos isn't aligned.\n\t\t *    we need 1 more record in this case.\n\t\t * 2) split int the end if the end pos isn't aligned.\n\t\t *    we need 1 more record in this case.\n\t\t * 3) split in the middle because of file system fragmentation.\n\t\t *    we need 2 more records in this case(we can't detect this\n\t\t *    beforehand, so always think of the worst case).\n\t\t */\n\t\tif (rec.r_refcount) {\n\t\t\trecs_add += 2;\n\t\t\t/* Check whether we need a split at the beginning. */\n\t\t\tif (cpos == start_cpos &&\n\t\t\t    cpos != le64_to_cpu(rec.r_cpos))\n\t\t\t\trecs_add++;\n\n\t\t\t/* Check whether we need a split in the end. */\n\t\t\tif (cpos + clusters < le64_to_cpu(rec.r_cpos) +\n\t\t\t    le32_to_cpu(rec.r_clusters))\n\t\t\t\trecs_add++;\n\t\t} else\n\t\t\trecs_add++;\n\n\t\tbrelse(ref_leaf_bh);\n\t\tref_leaf_bh = NULL;\n\t\tclusters -= len;\n\t\tcpos += len;\n\t}\n\n\tif (prev_bh) {\n\t\trb = (struct ocfs2_refcount_block *)prev_bh->b_data;\n\n\t\tif (le16_to_cpu(rb->rf_records.rl_used) + recs_add >\n\t\t    le16_to_cpu(rb->rf_records.rl_count))\n\t\t\tref_blocks++;\n\n\t\t*credits += 1;\n\t}\n\n\tif (!ref_blocks)\n\t\tgoto out;\n\n\t*meta_add += ref_blocks;\n\t*credits += ref_blocks;\n\n\t/*\n\t * So we may need ref_blocks to insert into the tree.\n\t * That also means we need to change the b-tree and add that number\n\t * of records since we never merge them.\n\t * We need one more block for expansion since the new created leaf\n\t * block is also full and needs split.\n\t */\n\trb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\tif (le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL) {\n\t\tstruct ocfs2_extent_tree et;\n\n\t\tocfs2_init_refcount_extent_tree(&et, ci, ref_root_bh);\n\t\t*meta_add += ocfs2_extend_meta_needed(et.et_root_el);\n\t\t*credits += ocfs2_calc_extend_credits(sb,\n\t\t\t\t\t\t      et.et_root_el);\n\t} else {\n\t\t*credits += OCFS2_EXPAND_REFCOUNT_TREE_CREDITS;\n\t\t*meta_add += 1;\n\t}\n\nout:\n\n\ttrace_ocfs2_calc_refcount_meta_credits(\n\t\t(unsigned long long)start_cpos, clusters,\n\t\t*meta_add, *credits);\n\tbrelse(ref_leaf_bh);\n\tbrelse(prev_bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_mark_extent_refcounted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "2351-2379",
    "snippet": "static int ocfs2_mark_extent_refcounted(struct inode *inode,\n\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\thandle_t *handle, u32 cpos,\n\t\t\t\tu32 len, u32 phys,\n\t\t\t\tstruct ocfs2_alloc_context *meta_ac,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret;\n\n\ttrace_ocfs2_mark_extent_refcounted(OCFS2_I(inode)->ip_blkno,\n\t\t\t\t\t   cpos, len, phys);\n\n\tif (!ocfs2_refcount_tree(OCFS2_SB(inode->i_sb))) {\n\t\tocfs2_error(inode->i_sb, \"Inode %lu want to use refcount \"\n\t\t\t    \"tree, but the feature bit is not set in the \"\n\t\t\t    \"super block.\", inode->i_ino);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_change_extent_flag(handle, et, cpos,\n\t\t\t\t       len, phys, meta_ac, dealloc,\n\t\t\t\t       OCFS2_EXT_REFCOUNTED, 0);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_change_extent_flag",
          "args": [
            "handle",
            "et",
            "cpos",
            "len",
            "phys",
            "meta_ac",
            "dealloc",
            "OCFS2_EXT_REFCOUNTED",
            "0"
          ],
          "line": 2371
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_change_extent_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "5117-5195",
          "snippet": "int ocfs2_change_extent_flag(handle_t *handle,\n\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t     u32 cpos, u32 len, u32 phys,\n\t\t\t     struct ocfs2_alloc_context *meta_ac,\n\t\t\t     struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t     int new_flags, int clear_flags)\n{\n\tint ret, index;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(et->et_ci);\n\tu64 start_blkno = ocfs2_clusters_to_blocks(sb, phys);\n\tstruct ocfs2_extent_rec split_rec;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\n\tleft_path = ocfs2_new_path_from_et(et);\n\tif (!left_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_path(et->et_ci, left_path, cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tel = path_leaf_el(left_path);\n\n\tindex = ocfs2_search_extent_list(el, cpos);\n\tif (index == -1) {\n\t\tocfs2_error(sb,\n\t\t\t    \"Owner %llu has an extent at cpos %u which can no \"\n\t\t\t    \"longer be found.\\n\",\n\t\t\t     (unsigned long long)\n\t\t\t     ocfs2_metadata_cache_owner(et->et_ci), cpos);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\tret = -EIO;\n\trec = &el->l_recs[index];\n\tif (new_flags && (rec->e_flags & new_flags)) {\n\t\tmlog(ML_ERROR, \"Owner %llu tried to set %d flags on an \"\n\t\t     \"extent that already had them\",\n\t\t     (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t     new_flags);\n\t\tgoto out;\n\t}\n\n\tif (clear_flags && !(rec->e_flags & clear_flags)) {\n\t\tmlog(ML_ERROR, \"Owner %llu tried to clear %d flags on an \"\n\t\t     \"extent that didn't have them\",\n\t\t     (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t     clear_flags);\n\t\tgoto out;\n\t}\n\n\tmemset(&split_rec, 0, sizeof(struct ocfs2_extent_rec));\n\tsplit_rec.e_cpos = cpu_to_le32(cpos);\n\tsplit_rec.e_leaf_clusters = cpu_to_le16(len);\n\tsplit_rec.e_blkno = cpu_to_le64(start_blkno);\n\tsplit_rec.e_flags = rec->e_flags;\n\tif (new_flags)\n\t\tsplit_rec.e_flags |= new_flags;\n\tif (clear_flags)\n\t\tsplit_rec.e_flags &= ~clear_flags;\n\n\tret = ocfs2_split_extent(handle, et, left_path,\n\t\t\t\t index, &split_rec, meta_ac,\n\t\t\t\t dealloc);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\tocfs2_free_path(left_path);\n\treturn ret;\n\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nint ocfs2_change_extent_flag(handle_t *handle,\n\t\t\t     struct ocfs2_extent_tree *et,\n\t\t\t     u32 cpos, u32 len, u32 phys,\n\t\t\t     struct ocfs2_alloc_context *meta_ac,\n\t\t\t     struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t     int new_flags, int clear_flags)\n{\n\tint ret, index;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(et->et_ci);\n\tu64 start_blkno = ocfs2_clusters_to_blocks(sb, phys);\n\tstruct ocfs2_extent_rec split_rec;\n\tstruct ocfs2_path *left_path = NULL;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec;\n\n\tleft_path = ocfs2_new_path_from_et(et);\n\tif (!left_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_path(et->et_ci, left_path, cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tel = path_leaf_el(left_path);\n\n\tindex = ocfs2_search_extent_list(el, cpos);\n\tif (index == -1) {\n\t\tocfs2_error(sb,\n\t\t\t    \"Owner %llu has an extent at cpos %u which can no \"\n\t\t\t    \"longer be found.\\n\",\n\t\t\t     (unsigned long long)\n\t\t\t     ocfs2_metadata_cache_owner(et->et_ci), cpos);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\tret = -EIO;\n\trec = &el->l_recs[index];\n\tif (new_flags && (rec->e_flags & new_flags)) {\n\t\tmlog(ML_ERROR, \"Owner %llu tried to set %d flags on an \"\n\t\t     \"extent that already had them\",\n\t\t     (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t     new_flags);\n\t\tgoto out;\n\t}\n\n\tif (clear_flags && !(rec->e_flags & clear_flags)) {\n\t\tmlog(ML_ERROR, \"Owner %llu tried to clear %d flags on an \"\n\t\t     \"extent that didn't have them\",\n\t\t     (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t     clear_flags);\n\t\tgoto out;\n\t}\n\n\tmemset(&split_rec, 0, sizeof(struct ocfs2_extent_rec));\n\tsplit_rec.e_cpos = cpu_to_le32(cpos);\n\tsplit_rec.e_leaf_clusters = cpu_to_le16(len);\n\tsplit_rec.e_blkno = cpu_to_le64(start_blkno);\n\tsplit_rec.e_flags = rec->e_flags;\n\tif (new_flags)\n\t\tsplit_rec.e_flags |= new_flags;\n\tif (clear_flags)\n\t\tsplit_rec.e_flags &= ~clear_flags;\n\n\tret = ocfs2_split_extent(handle, et, left_path,\n\t\t\t\t index, &split_rec, meta_ac,\n\t\t\t\t dealloc);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\tocfs2_free_path(left_path);\n\treturn ret;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_error",
          "args": [
            "inode->i_sb",
            "\"Inode %lu want to use refcount \"\n\t\t\t    \"tree, but the feature bit is not set in the \"\n\t\t\t    \"super block.\"",
            "inode->i_ino"
          ],
          "line": 2364
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2568-2584",
          "snippet": "void __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic char error_buf[1024];\n\nvoid __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_refcount_tree",
          "args": [
            "OCFS2_SB(inode->i_sb)"
          ],
          "line": 2363
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_refcount_tree_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "292-296",
          "snippet": "static inline void\nocfs2_refcount_tree_put(struct ocfs2_refcount_tree *tree)\n{\n\tkref_put(&tree->rf_getcnt, ocfs2_kref_remove_refcount_tree);\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic inline void\nocfs2_refcount_tree_put(struct ocfs2_refcount_tree *tree)\n{\n\tkref_put(&tree->rf_getcnt, ocfs2_kref_remove_refcount_tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 2363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_mark_extent_refcounted",
          "args": [
            "OCFS2_I(inode)->ip_blkno",
            "cpos",
            "len",
            "phys"
          ],
          "line": 2360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 2360
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_mark_extent_refcounted(struct inode *inode,\n\t\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\t\thandle_t *handle, u32 cpos,\n\t\t\t\tu32 len, u32 phys,\n\t\t\t\tstruct ocfs2_alloc_context *meta_ac,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret;\n\n\ttrace_ocfs2_mark_extent_refcounted(OCFS2_I(inode)->ip_blkno,\n\t\t\t\t\t   cpos, len, phys);\n\n\tif (!ocfs2_refcount_tree(OCFS2_SB(inode->i_sb))) {\n\t\tocfs2_error(inode->i_sb, \"Inode %lu want to use refcount \"\n\t\t\t    \"tree, but the feature bit is not set in the \"\n\t\t\t    \"super block.\", inode->i_ino);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_change_extent_flag(handle, et, cpos,\n\t\t\t\t       len, phys, meta_ac, dealloc,\n\t\t\t\t       OCFS2_EXT_REFCOUNTED, 0);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_decrease_refcount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "2300-2340",
    "snippet": "int ocfs2_decrease_refcount(struct inode *inode,\n\t\t\t    handle_t *handle, u32 cpos, u32 len,\n\t\t\t    struct ocfs2_alloc_context *meta_ac,\n\t\t\t    struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t    int delete)\n{\n\tint ret;\n\tu64 ref_blkno;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_tree *tree;\n\n\tBUG_ON(!(oi->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL));\n\n\tret = ocfs2_get_refcount_block(inode, &ref_blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_get_refcount_tree(OCFS2_SB(inode->i_sb), ref_blkno, &tree);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_refcount_block(&tree->rf_ci, tree->rf_blkno,\n\t\t\t\t\t&ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = __ocfs2_decrease_refcount(handle, &tree->rf_ci, ref_root_bh,\n\t\t\t\t\tcpos, len, meta_ac, dealloc, delete);\n\tif (ret)\n\t\tmlog_errno(ret);\nout:\n\tbrelse(ref_root_bh);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "ref_root_bh"
          ],
          "line": 2338
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ocfs2_decrease_refcount",
          "args": [
            "handle",
            "&tree->rf_ci",
            "ref_root_bh",
            "cpos",
            "len",
            "meta_ac",
            "dealloc",
            "delete"
          ],
          "line": 2333
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_decrease_refcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "2234-2297",
          "snippet": "static int __ocfs2_decrease_refcount(handle_t *handle,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *ref_root_bh,\n\t\t\t\t     u64 cpos, u32 len,\n\t\t\t\t     struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t     struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t\t     int delete)\n{\n\tint ret = 0, index = 0;\n\tstruct ocfs2_refcount_rec rec;\n\tunsigned int r_count = 0, r_len;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\n\tstruct buffer_head *ref_leaf_bh = NULL;\n\n\ttrace_ocfs2_decrease_refcount(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t(unsigned long long)cpos, len, delete);\n\n\twhile (len) {\n\t\tret = ocfs2_get_refcount_rec(ci, ref_root_bh,\n\t\t\t\t\t     cpos, len, &rec, &index,\n\t\t\t\t\t     &ref_leaf_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tr_count = le32_to_cpu(rec.r_refcount);\n\t\tBUG_ON(r_count == 0);\n\t\tif (!delete)\n\t\t\tBUG_ON(r_count > 1);\n\n\t\tr_len = min((u64)(cpos + len), le64_to_cpu(rec.r_cpos) +\n\t\t\t      le32_to_cpu(rec.r_clusters)) - cpos;\n\n\t\tret = ocfs2_decrease_refcount_rec(handle, ci, ref_root_bh,\n\t\t\t\t\t\t  ref_leaf_bh, index,\n\t\t\t\t\t\t  cpos, r_len,\n\t\t\t\t\t\t  meta_ac, dealloc);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (le32_to_cpu(rec.r_refcount) == 1 && delete) {\n\t\t\tret = ocfs2_cache_cluster_dealloc(dealloc,\n\t\t\t\t\t  ocfs2_clusters_to_blocks(sb, cpos),\n\t\t\t\t\t\t\t  r_len);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tcpos += r_len;\n\t\tlen -= r_len;\n\t\tbrelse(ref_leaf_bh);\n\t\tref_leaf_bh = NULL;\n\t}\n\nout:\n\tbrelse(ref_leaf_bh);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int __ocfs2_decrease_refcount(handle_t *handle,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *ref_root_bh,\n\t\t\t\t     u64 cpos, u32 len,\n\t\t\t\t     struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t     struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t\t     int delete)\n{\n\tint ret = 0, index = 0;\n\tstruct ocfs2_refcount_rec rec;\n\tunsigned int r_count = 0, r_len;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\n\tstruct buffer_head *ref_leaf_bh = NULL;\n\n\ttrace_ocfs2_decrease_refcount(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t(unsigned long long)cpos, len, delete);\n\n\twhile (len) {\n\t\tret = ocfs2_get_refcount_rec(ci, ref_root_bh,\n\t\t\t\t\t     cpos, len, &rec, &index,\n\t\t\t\t\t     &ref_leaf_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tr_count = le32_to_cpu(rec.r_refcount);\n\t\tBUG_ON(r_count == 0);\n\t\tif (!delete)\n\t\t\tBUG_ON(r_count > 1);\n\n\t\tr_len = min((u64)(cpos + len), le64_to_cpu(rec.r_cpos) +\n\t\t\t      le32_to_cpu(rec.r_clusters)) - cpos;\n\n\t\tret = ocfs2_decrease_refcount_rec(handle, ci, ref_root_bh,\n\t\t\t\t\t\t  ref_leaf_bh, index,\n\t\t\t\t\t\t  cpos, r_len,\n\t\t\t\t\t\t  meta_ac, dealloc);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (le32_to_cpu(rec.r_refcount) == 1 && delete) {\n\t\t\tret = ocfs2_cache_cluster_dealloc(dealloc,\n\t\t\t\t\t  ocfs2_clusters_to_blocks(sb, cpos),\n\t\t\t\t\t\t\t  r_len);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tcpos += r_len;\n\t\tlen -= r_len;\n\t\tbrelse(ref_leaf_bh);\n\t\tref_leaf_bh = NULL;\n\t}\n\nout:\n\tbrelse(ref_leaf_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_refcount_block",
          "args": [
            "&tree->rf_ci",
            "tree->rf_blkno",
            "&ref_root_bh"
          ],
          "line": 2326
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_refcount_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "133-148",
          "snippet": "static int ocfs2_read_refcount_block(struct ocfs2_caching_info *ci,\n\t\t\t\t     u64 rb_blkno,\n\t\t\t\t     struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(ci, rb_blkno, &tmp,\n\t\t\t      ocfs2_validate_refcount_block);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_read_refcount_block(struct ocfs2_caching_info *ci,\n\t\t\t\t     u64 rb_blkno,\n\t\t\t\t     struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(ci, rb_blkno, &tmp,\n\t\t\t      ocfs2_validate_refcount_block);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_refcount_tree",
          "args": [
            "OCFS2_SB(inode->i_sb)",
            "ref_blkno",
            "&tree"
          ],
          "line": 2320
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_get_refcount_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "332-401",
          "snippet": "static int ocfs2_get_refcount_tree(struct ocfs2_super *osb, u64 rf_blkno,\n\t\t\t\t   struct ocfs2_refcount_tree **ret_tree)\n{\n\tint ret = 0;\n\tstruct ocfs2_refcount_tree *tree, *new = NULL;\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_block *ref_rb;\n\n\tspin_lock(&osb->osb_lock);\n\tif (osb->osb_ref_tree_lru &&\n\t    osb->osb_ref_tree_lru->rf_blkno == rf_blkno)\n\t\ttree = osb->osb_ref_tree_lru;\n\telse\n\t\ttree = ocfs2_find_refcount_tree(osb, rf_blkno);\n\tif (tree)\n\t\tgoto out;\n\n\tspin_unlock(&osb->osb_lock);\n\n\tnew = ocfs2_allocate_refcount_tree(osb, rf_blkno);\n\tif (!new) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\t/*\n\t * We need the generation to create the refcount tree lock and since\n\t * it isn't changed during the tree modification, we are safe here to\n\t * read without protection.\n\t * We also have to purge the cache after we create the lock since the\n\t * refcount block may have the stale data. It can only be trusted when\n\t * we hold the refcount lock.\n\t */\n\tret = ocfs2_read_refcount_block(&new->rf_ci, rf_blkno, &ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_metadata_cache_exit(&new->rf_ci);\n\t\tkfree(new);\n\t\treturn ret;\n\t}\n\n\tref_rb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\tnew->rf_generation = le32_to_cpu(ref_rb->rf_generation);\n\tocfs2_init_refcount_tree_lock(osb, new, rf_blkno,\n\t\t\t\t      new->rf_generation);\n\tocfs2_metadata_cache_purge(&new->rf_ci);\n\n\tspin_lock(&osb->osb_lock);\n\ttree = ocfs2_find_refcount_tree(osb, rf_blkno);\n\tif (tree)\n\t\tgoto out;\n\n\tocfs2_insert_refcount_tree(osb, new);\n\n\ttree = new;\n\tnew = NULL;\n\nout:\n\t*ret_tree = tree;\n\n\tosb->osb_ref_tree_lru = tree;\n\n\tspin_unlock(&osb->osb_lock);\n\n\tif (new)\n\t\tocfs2_free_refcount_tree(new);\n\n\tbrelse(ref_root_bh);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_get_refcount_tree(struct ocfs2_super *osb, u64 rf_blkno,\n\t\t\t\t   struct ocfs2_refcount_tree **ret_tree)\n{\n\tint ret = 0;\n\tstruct ocfs2_refcount_tree *tree, *new = NULL;\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_block *ref_rb;\n\n\tspin_lock(&osb->osb_lock);\n\tif (osb->osb_ref_tree_lru &&\n\t    osb->osb_ref_tree_lru->rf_blkno == rf_blkno)\n\t\ttree = osb->osb_ref_tree_lru;\n\telse\n\t\ttree = ocfs2_find_refcount_tree(osb, rf_blkno);\n\tif (tree)\n\t\tgoto out;\n\n\tspin_unlock(&osb->osb_lock);\n\n\tnew = ocfs2_allocate_refcount_tree(osb, rf_blkno);\n\tif (!new) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\t/*\n\t * We need the generation to create the refcount tree lock and since\n\t * it isn't changed during the tree modification, we are safe here to\n\t * read without protection.\n\t * We also have to purge the cache after we create the lock since the\n\t * refcount block may have the stale data. It can only be trusted when\n\t * we hold the refcount lock.\n\t */\n\tret = ocfs2_read_refcount_block(&new->rf_ci, rf_blkno, &ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_metadata_cache_exit(&new->rf_ci);\n\t\tkfree(new);\n\t\treturn ret;\n\t}\n\n\tref_rb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\tnew->rf_generation = le32_to_cpu(ref_rb->rf_generation);\n\tocfs2_init_refcount_tree_lock(osb, new, rf_blkno,\n\t\t\t\t      new->rf_generation);\n\tocfs2_metadata_cache_purge(&new->rf_ci);\n\n\tspin_lock(&osb->osb_lock);\n\ttree = ocfs2_find_refcount_tree(osb, rf_blkno);\n\tif (tree)\n\t\tgoto out;\n\n\tocfs2_insert_refcount_tree(osb, new);\n\n\ttree = new;\n\tnew = NULL;\n\nout:\n\t*ret_tree = tree;\n\n\tosb->osb_ref_tree_lru = tree;\n\n\tspin_unlock(&osb->osb_lock);\n\n\tif (new)\n\t\tocfs2_free_refcount_tree(new);\n\n\tbrelse(ref_root_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 2320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_refcount_block",
          "args": [
            "inode",
            "&ref_blkno"
          ],
          "line": 2314
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_get_refcount_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "403-422",
          "snippet": "static int ocfs2_get_refcount_block(struct inode *inode, u64 *ref_blkno)\n{\n\tint ret;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\n\tret = ocfs2_read_inode_block(inode, &di_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tBUG_ON(!(OCFS2_I(inode)->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL));\n\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\t*ref_blkno = le64_to_cpu(di->i_refcount_loc);\n\tbrelse(di_bh);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_get_refcount_block(struct inode *inode, u64 *ref_blkno)\n{\n\tint ret;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\n\tret = ocfs2_read_inode_block(inode, &di_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tBUG_ON(!(OCFS2_I(inode)->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL));\n\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\t*ref_blkno = le64_to_cpu(di->i_refcount_loc);\n\tbrelse(di_bh);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(oi->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL)"
          ],
          "line": 2312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 2308
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nint ocfs2_decrease_refcount(struct inode *inode,\n\t\t\t    handle_t *handle, u32 cpos, u32 len,\n\t\t\t    struct ocfs2_alloc_context *meta_ac,\n\t\t\t    struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t    int delete)\n{\n\tint ret;\n\tu64 ref_blkno;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_tree *tree;\n\n\tBUG_ON(!(oi->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL));\n\n\tret = ocfs2_get_refcount_block(inode, &ref_blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_get_refcount_tree(OCFS2_SB(inode->i_sb), ref_blkno, &tree);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_refcount_block(&tree->rf_ci, tree->rf_blkno,\n\t\t\t\t\t&ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = __ocfs2_decrease_refcount(handle, &tree->rf_ci, ref_root_bh,\n\t\t\t\t\tcpos, len, meta_ac, dealloc, delete);\n\tif (ret)\n\t\tmlog_errno(ret);\nout:\n\tbrelse(ref_root_bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "__ocfs2_decrease_refcount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "2234-2297",
    "snippet": "static int __ocfs2_decrease_refcount(handle_t *handle,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *ref_root_bh,\n\t\t\t\t     u64 cpos, u32 len,\n\t\t\t\t     struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t     struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t\t     int delete)\n{\n\tint ret = 0, index = 0;\n\tstruct ocfs2_refcount_rec rec;\n\tunsigned int r_count = 0, r_len;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\n\tstruct buffer_head *ref_leaf_bh = NULL;\n\n\ttrace_ocfs2_decrease_refcount(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t(unsigned long long)cpos, len, delete);\n\n\twhile (len) {\n\t\tret = ocfs2_get_refcount_rec(ci, ref_root_bh,\n\t\t\t\t\t     cpos, len, &rec, &index,\n\t\t\t\t\t     &ref_leaf_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tr_count = le32_to_cpu(rec.r_refcount);\n\t\tBUG_ON(r_count == 0);\n\t\tif (!delete)\n\t\t\tBUG_ON(r_count > 1);\n\n\t\tr_len = min((u64)(cpos + len), le64_to_cpu(rec.r_cpos) +\n\t\t\t      le32_to_cpu(rec.r_clusters)) - cpos;\n\n\t\tret = ocfs2_decrease_refcount_rec(handle, ci, ref_root_bh,\n\t\t\t\t\t\t  ref_leaf_bh, index,\n\t\t\t\t\t\t  cpos, r_len,\n\t\t\t\t\t\t  meta_ac, dealloc);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (le32_to_cpu(rec.r_refcount) == 1 && delete) {\n\t\t\tret = ocfs2_cache_cluster_dealloc(dealloc,\n\t\t\t\t\t  ocfs2_clusters_to_blocks(sb, cpos),\n\t\t\t\t\t\t\t  r_len);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tcpos += r_len;\n\t\tlen -= r_len;\n\t\tbrelse(ref_leaf_bh);\n\t\tref_leaf_bh = NULL;\n\t}\n\nout:\n\tbrelse(ref_leaf_bh);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "ref_leaf_bh"
          ],
          "line": 2295
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_cache_cluster_dealloc",
          "args": [
            "dealloc",
            "ocfs2_clusters_to_blocks(sb, cpos)",
            "r_len"
          ],
          "line": 2279
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_cache_cluster_dealloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "6397-6418",
          "snippet": "int ocfs2_cache_cluster_dealloc(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\tu64 blkno, unsigned int bit)\n{\n\tint ret = 0;\n\tstruct ocfs2_cached_block_free *item;\n\n\titem = kzalloc(sizeof(*item), GFP_NOFS);\n\tif (item == NULL) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\ttrace_ocfs2_cache_cluster_dealloc((unsigned long long)blkno, bit);\n\n\titem->free_blk = blkno;\n\titem->free_bit = bit;\n\titem->free_next = ctxt->c_global_allocator;\n\n\tctxt->c_global_allocator = item;\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);\n\nint ocfs2_cache_cluster_dealloc(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t\tu64 blkno, unsigned int bit)\n{\n\tint ret = 0;\n\tstruct ocfs2_cached_block_free *item;\n\n\titem = kzalloc(sizeof(*item), GFP_NOFS);\n\tif (item == NULL) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\ttrace_ocfs2_cache_cluster_dealloc((unsigned long long)blkno, bit);\n\n\titem->free_blk = blkno;\n\titem->free_bit = bit;\n\titem->free_next = ctxt->c_global_allocator;\n\n\tctxt->c_global_allocator = item;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_clusters_to_blocks",
          "args": [
            "sb",
            "cpos"
          ],
          "line": 2280
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_clusters_to_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2.h",
          "lines": "711-718",
          "snippet": "static inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}",
          "includes": [
            "#include \"reservations.h\"",
            "#include \"blockcheck.h\"",
            "#include \"ocfs2_ioctl.h\"",
            "#include \"ocfs2_lockid.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"stackglue.h\"",
            "#include <linux/jbd2.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kref.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/llist.h>",
            "#include <linux/list.h>",
            "#include <linux/wait.h>",
            "#include <linux/sched.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"reservations.h\"\n#include \"blockcheck.h\"\n#include \"ocfs2_ioctl.h\"\n#include \"ocfs2_lockid.h\"\n#include \"ocfs2_fs.h\"\n#include \"stackglue.h\"\n#include <linux/jbd2.h>\n#include <linux/lockdep.h>\n#include <linux/mutex.h>\n#include <linux/kref.h>\n#include <linux/workqueue.h>\n#include <linux/rbtree.h>\n#include <linux/llist.h>\n#include <linux/list.h>\n#include <linux/wait.h>\n#include <linux/sched.h>\n#include <linux/spinlock.h>\n\nstatic inline u64 ocfs2_clusters_to_blocks(struct super_block *sb,\n\t\t\t\t\t   u32 clusters)\n{\n\tint c_to_b_bits = OCFS2_SB(sb)->s_clustersize_bits -\n\t\tsb->s_blocksize_bits;\n\n\treturn (u64)clusters << c_to_b_bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rec.r_refcount"
          ],
          "line": 2278
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_decrease_refcount_rec",
          "args": [
            "handle",
            "ci",
            "ref_root_bh",
            "ref_leaf_bh",
            "index",
            "cpos",
            "r_len",
            "meta_ac",
            "dealloc"
          ],
          "line": 2269
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_decrease_refcount_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "2178-2232",
          "snippet": "static int ocfs2_decrease_refcount_rec(handle_t *handle,\n\t\t\t\tstruct ocfs2_caching_info *ci,\n\t\t\t\tstruct buffer_head *ref_root_bh,\n\t\t\t\tstruct buffer_head *ref_leaf_bh,\n\t\t\t\tint index, u64 cpos, unsigned int len,\n\t\t\t\tstruct ocfs2_alloc_context *meta_ac,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret;\n\tstruct ocfs2_refcount_block *rb =\n\t\t\t(struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\n\tstruct ocfs2_refcount_rec *rec = &rb->rf_records.rl_recs[index];\n\n\tBUG_ON(cpos < le64_to_cpu(rec->r_cpos));\n\tBUG_ON(cpos + len >\n\t       le64_to_cpu(rec->r_cpos) + le32_to_cpu(rec->r_clusters));\n\n\ttrace_ocfs2_decrease_refcount_rec(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t(unsigned long long)cpos, len);\n\n\tif (cpos == le64_to_cpu(rec->r_cpos) &&\n\t    len == le32_to_cpu(rec->r_clusters))\n\t\tret = ocfs2_change_refcount_rec(handle, ci,\n\t\t\t\t\t\tref_leaf_bh, index, 1, -1);\n\telse {\n\t\tstruct ocfs2_refcount_rec split = *rec;\n\t\tsplit.r_cpos = cpu_to_le64(cpos);\n\t\tsplit.r_clusters = cpu_to_le32(len);\n\n\t\tle32_add_cpu(&split.r_refcount, -1);\n\n\t\tret = ocfs2_split_refcount_rec(handle, ci,\n\t\t\t\t\t       ref_root_bh, ref_leaf_bh,\n\t\t\t\t\t       &split, index, 1,\n\t\t\t\t\t       meta_ac, dealloc);\n\t}\n\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* Remove the leaf refcount block if it contains no refcount record. */\n\tif (!rb->rf_records.rl_used && ref_leaf_bh != ref_root_bh) {\n\t\tret = ocfs2_remove_refcount_extent(handle, ci, ref_root_bh,\n\t\t\t\t\t\t   ref_leaf_bh, meta_ac,\n\t\t\t\t\t\t   dealloc);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_decrease_refcount_rec(handle_t *handle,\n\t\t\t\tstruct ocfs2_caching_info *ci,\n\t\t\t\tstruct buffer_head *ref_root_bh,\n\t\t\t\tstruct buffer_head *ref_leaf_bh,\n\t\t\t\tint index, u64 cpos, unsigned int len,\n\t\t\t\tstruct ocfs2_alloc_context *meta_ac,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret;\n\tstruct ocfs2_refcount_block *rb =\n\t\t\t(struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\n\tstruct ocfs2_refcount_rec *rec = &rb->rf_records.rl_recs[index];\n\n\tBUG_ON(cpos < le64_to_cpu(rec->r_cpos));\n\tBUG_ON(cpos + len >\n\t       le64_to_cpu(rec->r_cpos) + le32_to_cpu(rec->r_clusters));\n\n\ttrace_ocfs2_decrease_refcount_rec(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t(unsigned long long)cpos, len);\n\n\tif (cpos == le64_to_cpu(rec->r_cpos) &&\n\t    len == le32_to_cpu(rec->r_clusters))\n\t\tret = ocfs2_change_refcount_rec(handle, ci,\n\t\t\t\t\t\tref_leaf_bh, index, 1, -1);\n\telse {\n\t\tstruct ocfs2_refcount_rec split = *rec;\n\t\tsplit.r_cpos = cpu_to_le64(cpos);\n\t\tsplit.r_clusters = cpu_to_le32(len);\n\n\t\tle32_add_cpu(&split.r_refcount, -1);\n\n\t\tret = ocfs2_split_refcount_rec(handle, ci,\n\t\t\t\t\t       ref_root_bh, ref_leaf_bh,\n\t\t\t\t\t       &split, index, 1,\n\t\t\t\t\t       meta_ac, dealloc);\n\t}\n\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* Remove the leaf refcount block if it contains no refcount record. */\n\tif (!rb->rf_records.rl_used && ref_leaf_bh != ref_root_bh) {\n\t\tret = ocfs2_remove_refcount_extent(handle, ci, ref_root_bh,\n\t\t\t\t\t\t   ref_leaf_bh, meta_ac,\n\t\t\t\t\t\t   dealloc);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "(u64)(cpos + len)",
            "le64_to_cpu(rec.r_cpos) +\n\t\t\t      le32_to_cpu(rec.r_clusters)"
          ],
          "line": 2266
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_hamming_encode_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
          "lines": "154-157",
          "snippet": "u32 ocfs2_hamming_encode_block(void *data, unsigned int blocksize)\n{\n\treturn ocfs2_hamming_encode(0, data, blocksize * 8, 0);\n}",
          "includes": [
            "#include \"blockcheck.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nu32 ocfs2_hamming_encode_block(void *data, unsigned int blocksize)\n{\n\treturn ocfs2_hamming_encode(0, data, blocksize * 8, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "rec.r_cpos"
          ],
          "line": 2266
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "cpos + len"
          ],
          "line": 2266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "r_count > 1"
          ],
          "line": 2264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "r_count == 0"
          ],
          "line": 2262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_refcount_rec",
          "args": [
            "ci",
            "ref_root_bh",
            "cpos",
            "len",
            "&rec",
            "&index",
            "&ref_leaf_bh"
          ],
          "line": 2253
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_get_refcount_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "1066-1150",
          "snippet": "static int ocfs2_get_refcount_rec(struct ocfs2_caching_info *ci,\n\t\t\t\t  struct buffer_head *ref_root_bh,\n\t\t\t\t  u64 cpos, unsigned int len,\n\t\t\t\t  struct ocfs2_refcount_rec *ret_rec,\n\t\t\t\t  int *index,\n\t\t\t\t  struct buffer_head **ret_bh)\n{\n\tint ret = 0, i, found;\n\tu32 low_cpos, uninitialized_var(cpos_end);\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec = NULL;\n\tstruct ocfs2_extent_block *eb = NULL;\n\tstruct buffer_head *eb_bh = NULL, *ref_leaf_bh = NULL;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\n\tstruct ocfs2_refcount_block *rb =\n\t\t\t(struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\n\tif (!(le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL)) {\n\t\tocfs2_find_refcount_rec_in_rl(ci, ref_root_bh, cpos, len,\n\t\t\t\t\t      ret_rec, index);\n\t\t*ret_bh = ref_root_bh;\n\t\tget_bh(ref_root_bh);\n\t\treturn 0;\n\t}\n\n\tel = &rb->rf_list;\n\tlow_cpos = cpos & OCFS2_32BIT_POS_MASK;\n\n\tif (el->l_tree_depth) {\n\t\tret = ocfs2_find_leaf(ci, el, low_cpos, &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tocfs2_error(sb,\n\t\t\t\"refcount tree %llu has non zero tree \"\n\t\t\t\"depth in leaf btree tree block %llu\\n\",\n\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t\t(unsigned long long)eb_bh->b_blocknr);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfound = 0;\n\tfor (i = le16_to_cpu(el->l_next_free_rec) - 1; i >= 0; i--) {\n\t\trec = &el->l_recs[i];\n\n\t\tif (le32_to_cpu(rec->e_cpos) <= low_cpos) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found) {\n\t\tret = ocfs2_get_refcount_cpos_end(ci, ref_root_bh,\n\t\t\t\t\t\t  eb, el, i, &cpos_end);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (cpos_end < low_cpos + len)\n\t\t\tlen = cpos_end - low_cpos;\n\t}\n\n\tret = ocfs2_read_refcount_block(ci, le64_to_cpu(rec->e_blkno),\n\t\t\t\t\t&ref_leaf_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_find_refcount_rec_in_rl(ci, ref_leaf_bh, cpos, len,\n\t\t\t\t      ret_rec, index);\n\t*ret_bh = ref_leaf_bh;\nout:\n\tbrelse(eb_bh);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_get_refcount_rec(struct ocfs2_caching_info *ci,\n\t\t\t\t  struct buffer_head *ref_root_bh,\n\t\t\t\t  u64 cpos, unsigned int len,\n\t\t\t\t  struct ocfs2_refcount_rec *ret_rec,\n\t\t\t\t  int *index,\n\t\t\t\t  struct buffer_head **ret_bh)\n{\n\tint ret = 0, i, found;\n\tu32 low_cpos, uninitialized_var(cpos_end);\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec = NULL;\n\tstruct ocfs2_extent_block *eb = NULL;\n\tstruct buffer_head *eb_bh = NULL, *ref_leaf_bh = NULL;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\n\tstruct ocfs2_refcount_block *rb =\n\t\t\t(struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\n\tif (!(le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL)) {\n\t\tocfs2_find_refcount_rec_in_rl(ci, ref_root_bh, cpos, len,\n\t\t\t\t\t      ret_rec, index);\n\t\t*ret_bh = ref_root_bh;\n\t\tget_bh(ref_root_bh);\n\t\treturn 0;\n\t}\n\n\tel = &rb->rf_list;\n\tlow_cpos = cpos & OCFS2_32BIT_POS_MASK;\n\n\tif (el->l_tree_depth) {\n\t\tret = ocfs2_find_leaf(ci, el, low_cpos, &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tocfs2_error(sb,\n\t\t\t\"refcount tree %llu has non zero tree \"\n\t\t\t\"depth in leaf btree tree block %llu\\n\",\n\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t\t(unsigned long long)eb_bh->b_blocknr);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfound = 0;\n\tfor (i = le16_to_cpu(el->l_next_free_rec) - 1; i >= 0; i--) {\n\t\trec = &el->l_recs[i];\n\n\t\tif (le32_to_cpu(rec->e_cpos) <= low_cpos) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found) {\n\t\tret = ocfs2_get_refcount_cpos_end(ci, ref_root_bh,\n\t\t\t\t\t\t  eb, el, i, &cpos_end);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (cpos_end < low_cpos + len)\n\t\t\tlen = cpos_end - low_cpos;\n\t}\n\n\tret = ocfs2_read_refcount_block(ci, le64_to_cpu(rec->e_blkno),\n\t\t\t\t\t&ref_leaf_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_find_refcount_rec_in_rl(ci, ref_leaf_bh, cpos, len,\n\t\t\t\t      ret_rec, index);\n\t*ret_bh = ref_leaf_bh;\nout:\n\tbrelse(eb_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_decrease_refcount",
          "args": [
            "(unsigned long long)ocfs2_metadata_cache_owner(ci)",
            "(unsigned long long)cpos",
            "len",
            "delete"
          ],
          "line": 2248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_owner",
          "args": [
            "ci"
          ],
          "line": 2249
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "72-77",
          "snippet": "u64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nu64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_get_super",
          "args": [
            "ci"
          ],
          "line": 2245
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_get_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "79-84",
          "snippet": "struct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int __ocfs2_decrease_refcount(handle_t *handle,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *ref_root_bh,\n\t\t\t\t     u64 cpos, u32 len,\n\t\t\t\t     struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t     struct ocfs2_cached_dealloc_ctxt *dealloc,\n\t\t\t\t     int delete)\n{\n\tint ret = 0, index = 0;\n\tstruct ocfs2_refcount_rec rec;\n\tunsigned int r_count = 0, r_len;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\n\tstruct buffer_head *ref_leaf_bh = NULL;\n\n\ttrace_ocfs2_decrease_refcount(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t(unsigned long long)cpos, len, delete);\n\n\twhile (len) {\n\t\tret = ocfs2_get_refcount_rec(ci, ref_root_bh,\n\t\t\t\t\t     cpos, len, &rec, &index,\n\t\t\t\t\t     &ref_leaf_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tr_count = le32_to_cpu(rec.r_refcount);\n\t\tBUG_ON(r_count == 0);\n\t\tif (!delete)\n\t\t\tBUG_ON(r_count > 1);\n\n\t\tr_len = min((u64)(cpos + len), le64_to_cpu(rec.r_cpos) +\n\t\t\t      le32_to_cpu(rec.r_clusters)) - cpos;\n\n\t\tret = ocfs2_decrease_refcount_rec(handle, ci, ref_root_bh,\n\t\t\t\t\t\t  ref_leaf_bh, index,\n\t\t\t\t\t\t  cpos, r_len,\n\t\t\t\t\t\t  meta_ac, dealloc);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (le32_to_cpu(rec.r_refcount) == 1 && delete) {\n\t\t\tret = ocfs2_cache_cluster_dealloc(dealloc,\n\t\t\t\t\t  ocfs2_clusters_to_blocks(sb, cpos),\n\t\t\t\t\t\t\t  r_len);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tcpos += r_len;\n\t\tlen -= r_len;\n\t\tbrelse(ref_leaf_bh);\n\t\tref_leaf_bh = NULL;\n\t}\n\nout:\n\tbrelse(ref_leaf_bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_decrease_refcount_rec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "2178-2232",
    "snippet": "static int ocfs2_decrease_refcount_rec(handle_t *handle,\n\t\t\t\tstruct ocfs2_caching_info *ci,\n\t\t\t\tstruct buffer_head *ref_root_bh,\n\t\t\t\tstruct buffer_head *ref_leaf_bh,\n\t\t\t\tint index, u64 cpos, unsigned int len,\n\t\t\t\tstruct ocfs2_alloc_context *meta_ac,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret;\n\tstruct ocfs2_refcount_block *rb =\n\t\t\t(struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\n\tstruct ocfs2_refcount_rec *rec = &rb->rf_records.rl_recs[index];\n\n\tBUG_ON(cpos < le64_to_cpu(rec->r_cpos));\n\tBUG_ON(cpos + len >\n\t       le64_to_cpu(rec->r_cpos) + le32_to_cpu(rec->r_clusters));\n\n\ttrace_ocfs2_decrease_refcount_rec(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t(unsigned long long)cpos, len);\n\n\tif (cpos == le64_to_cpu(rec->r_cpos) &&\n\t    len == le32_to_cpu(rec->r_clusters))\n\t\tret = ocfs2_change_refcount_rec(handle, ci,\n\t\t\t\t\t\tref_leaf_bh, index, 1, -1);\n\telse {\n\t\tstruct ocfs2_refcount_rec split = *rec;\n\t\tsplit.r_cpos = cpu_to_le64(cpos);\n\t\tsplit.r_clusters = cpu_to_le32(len);\n\n\t\tle32_add_cpu(&split.r_refcount, -1);\n\n\t\tret = ocfs2_split_refcount_rec(handle, ci,\n\t\t\t\t\t       ref_root_bh, ref_leaf_bh,\n\t\t\t\t\t       &split, index, 1,\n\t\t\t\t\t       meta_ac, dealloc);\n\t}\n\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* Remove the leaf refcount block if it contains no refcount record. */\n\tif (!rb->rf_records.rl_used && ref_leaf_bh != ref_root_bh) {\n\t\tret = ocfs2_remove_refcount_extent(handle, ci, ref_root_bh,\n\t\t\t\t\t\t   ref_leaf_bh, meta_ac,\n\t\t\t\t\t\t   dealloc);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_remove_refcount_extent",
          "args": [
            "handle",
            "ci",
            "ref_root_bh",
            "ref_leaf_bh",
            "meta_ac",
            "dealloc"
          ],
          "line": 2223
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_remove_refcount_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "2086-2164",
          "snippet": "static int ocfs2_remove_refcount_extent(handle_t *handle,\n\t\t\t\tstruct ocfs2_caching_info *ci,\n\t\t\t\tstruct buffer_head *ref_root_bh,\n\t\t\t\tstruct buffer_head *ref_leaf_bh,\n\t\t\t\tstruct ocfs2_alloc_context *meta_ac,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\n\tstruct ocfs2_refcount_block *rb =\n\t\t\t(struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\n\tstruct ocfs2_extent_tree et;\n\n\tBUG_ON(rb->rf_records.rl_used);\n\n\ttrace_ocfs2_remove_refcount_extent(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t(unsigned long long)ref_leaf_bh->b_blocknr,\n\t\tle32_to_cpu(rb->rf_cpos));\n\n\tocfs2_init_refcount_extent_tree(&et, ci, ref_root_bh);\n\tret = ocfs2_remove_extent(handle, &et, le32_to_cpu(rb->rf_cpos),\n\t\t\t\t  1, meta_ac, dealloc);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_remove_from_cache(ci, ref_leaf_bh);\n\n\t/*\n\t * add the freed block to the dealloc so that it will be freed\n\t * when we run dealloc.\n\t */\n\tret = ocfs2_cache_block_dealloc(dealloc, EXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\t\tle16_to_cpu(rb->rf_suballoc_slot),\n\t\t\t\t\tle64_to_cpu(rb->rf_suballoc_loc),\n\t\t\t\t\tle64_to_cpu(rb->rf_blkno),\n\t\t\t\t\tle16_to_cpu(rb->rf_suballoc_bit));\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_rb(handle, ci, ref_root_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\trb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\n\tle32_add_cpu(&rb->rf_clusters, -1);\n\n\t/*\n\t * check whether we need to restore the root refcount block if\n\t * there is no leaf extent block at atll.\n\t */\n\tif (!rb->rf_list.l_next_free_rec) {\n\t\tBUG_ON(rb->rf_clusters);\n\n\t\ttrace_ocfs2_restore_refcount_block(\n\t\t     (unsigned long long)ref_root_bh->b_blocknr);\n\n\t\trb->rf_flags = 0;\n\t\trb->rf_parent = 0;\n\t\trb->rf_cpos = 0;\n\t\tmemset(&rb->rf_records, 0, sb->s_blocksize -\n\t\t       offsetof(struct ocfs2_refcount_block, rf_records));\n\t\trb->rf_records.rl_count =\n\t\t\t\tcpu_to_le16(ocfs2_refcount_recs_per_rb(sb));\n\t}\n\n\tocfs2_journal_dirty(handle, ref_root_bh);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_remove_refcount_extent(handle_t *handle,\n\t\t\t\tstruct ocfs2_caching_info *ci,\n\t\t\t\tstruct buffer_head *ref_root_bh,\n\t\t\t\tstruct buffer_head *ref_leaf_bh,\n\t\t\t\tstruct ocfs2_alloc_context *meta_ac,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\n\tstruct ocfs2_refcount_block *rb =\n\t\t\t(struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\n\tstruct ocfs2_extent_tree et;\n\n\tBUG_ON(rb->rf_records.rl_used);\n\n\ttrace_ocfs2_remove_refcount_extent(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t(unsigned long long)ref_leaf_bh->b_blocknr,\n\t\tle32_to_cpu(rb->rf_cpos));\n\n\tocfs2_init_refcount_extent_tree(&et, ci, ref_root_bh);\n\tret = ocfs2_remove_extent(handle, &et, le32_to_cpu(rb->rf_cpos),\n\t\t\t\t  1, meta_ac, dealloc);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_remove_from_cache(ci, ref_leaf_bh);\n\n\t/*\n\t * add the freed block to the dealloc so that it will be freed\n\t * when we run dealloc.\n\t */\n\tret = ocfs2_cache_block_dealloc(dealloc, EXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\t\tle16_to_cpu(rb->rf_suballoc_slot),\n\t\t\t\t\tle64_to_cpu(rb->rf_suballoc_loc),\n\t\t\t\t\tle64_to_cpu(rb->rf_blkno),\n\t\t\t\t\tle16_to_cpu(rb->rf_suballoc_bit));\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_rb(handle, ci, ref_root_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\trb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\n\tle32_add_cpu(&rb->rf_clusters, -1);\n\n\t/*\n\t * check whether we need to restore the root refcount block if\n\t * there is no leaf extent block at atll.\n\t */\n\tif (!rb->rf_list.l_next_free_rec) {\n\t\tBUG_ON(rb->rf_clusters);\n\n\t\ttrace_ocfs2_restore_refcount_block(\n\t\t     (unsigned long long)ref_root_bh->b_blocknr);\n\n\t\trb->rf_flags = 0;\n\t\trb->rf_parent = 0;\n\t\trb->rf_cpos = 0;\n\t\tmemset(&rb->rf_records, 0, sb->s_blocksize -\n\t\t       offsetof(struct ocfs2_refcount_block, rf_records));\n\t\trb->rf_records.rl_count =\n\t\t\t\tcpu_to_le16(ocfs2_refcount_recs_per_rb(sb));\n\t}\n\n\tocfs2_journal_dirty(handle, ref_root_bh);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_split_refcount_rec",
          "args": [
            "handle",
            "ci",
            "ref_root_bh",
            "ref_leaf_bh",
            "&split",
            "index",
            "1",
            "meta_ac",
            "dealloc"
          ],
          "line": 2210
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_split_refcount_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "1836-1990",
          "snippet": "static int ocfs2_split_refcount_rec(handle_t *handle,\n\t\t\t\t    struct ocfs2_caching_info *ci,\n\t\t\t\t    struct buffer_head *ref_root_bh,\n\t\t\t\t    struct buffer_head *ref_leaf_bh,\n\t\t\t\t    struct ocfs2_refcount_rec *split_rec,\n\t\t\t\t    int index, int merge,\n\t\t\t\t    struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t    struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret, recs_need;\n\tu32 len;\n\tstruct ocfs2_refcount_block *rb =\n\t\t\t(struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\n\tstruct ocfs2_refcount_list *rf_list = &rb->rf_records;\n\tstruct ocfs2_refcount_rec *orig_rec = &rf_list->rl_recs[index];\n\tstruct ocfs2_refcount_rec *tail_rec = NULL;\n\tstruct buffer_head *new_bh = NULL;\n\n\tBUG_ON(le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL);\n\n\ttrace_ocfs2_split_refcount_rec(le64_to_cpu(orig_rec->r_cpos),\n\t\tle32_to_cpu(orig_rec->r_clusters),\n\t\tle32_to_cpu(orig_rec->r_refcount),\n\t\tle64_to_cpu(split_rec->r_cpos),\n\t\tle32_to_cpu(split_rec->r_clusters),\n\t\tle32_to_cpu(split_rec->r_refcount));\n\n\t/*\n\t * If we just need to split the header or tail clusters,\n\t * no more recs are needed, just split is OK.\n\t * Otherwise we at least need one new recs.\n\t */\n\tif (!split_rec->r_refcount &&\n\t    (split_rec->r_cpos == orig_rec->r_cpos ||\n\t     le64_to_cpu(split_rec->r_cpos) +\n\t     le32_to_cpu(split_rec->r_clusters) ==\n\t     le64_to_cpu(orig_rec->r_cpos) + le32_to_cpu(orig_rec->r_clusters)))\n\t\trecs_need = 0;\n\telse\n\t\trecs_need = 1;\n\n\t/*\n\t * We need one more rec if we split in the middle and the new rec have\n\t * some refcount in it.\n\t */\n\tif (split_rec->r_refcount &&\n\t    (split_rec->r_cpos != orig_rec->r_cpos &&\n\t     le64_to_cpu(split_rec->r_cpos) +\n\t     le32_to_cpu(split_rec->r_clusters) !=\n\t     le64_to_cpu(orig_rec->r_cpos) + le32_to_cpu(orig_rec->r_clusters)))\n\t\trecs_need++;\n\n\t/* If the leaf block don't have enough record, expand it. */\n\tif (le16_to_cpu(rf_list->rl_used) + recs_need >\n\t\t\t\t\t le16_to_cpu(rf_list->rl_count)) {\n\t\tstruct ocfs2_refcount_rec tmp_rec;\n\t\tu64 cpos = le64_to_cpu(orig_rec->r_cpos);\n\t\tlen = le32_to_cpu(orig_rec->r_clusters);\n\t\tret = ocfs2_expand_refcount_tree(handle, ci, ref_root_bh,\n\t\t\t\t\t\t ref_leaf_bh, meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * We have to re-get it since now cpos may be moved to\n\t\t * another leaf block.\n\t\t */\n\t\tret = ocfs2_get_refcount_rec(ci, ref_root_bh,\n\t\t\t\t\t     cpos, len, &tmp_rec, &index,\n\t\t\t\t\t     &new_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tref_leaf_bh = new_bh;\n\t\trb = (struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\n\t\trf_list = &rb->rf_records;\n\t\torig_rec = &rf_list->rl_recs[index];\n\t}\n\n\tret = ocfs2_journal_access_rb(handle, ci, ref_leaf_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We have calculated out how many new records we need and store\n\t * in recs_need, so spare enough space first by moving the records\n\t * after \"index\" to the end.\n\t */\n\tif (index != le16_to_cpu(rf_list->rl_used) - 1)\n\t\tmemmove(&rf_list->rl_recs[index + 1 + recs_need],\n\t\t\t&rf_list->rl_recs[index + 1],\n\t\t\t(le16_to_cpu(rf_list->rl_used) - index - 1) *\n\t\t\t sizeof(struct ocfs2_refcount_rec));\n\n\tlen = (le64_to_cpu(orig_rec->r_cpos) +\n\t      le32_to_cpu(orig_rec->r_clusters)) -\n\t      (le64_to_cpu(split_rec->r_cpos) +\n\t      le32_to_cpu(split_rec->r_clusters));\n\n\t/*\n\t * If we have \"len\", the we will split in the tail and move it\n\t * to the end of the space we have just spared.\n\t */\n\tif (len) {\n\t\ttail_rec = &rf_list->rl_recs[index + recs_need];\n\n\t\tmemcpy(tail_rec, orig_rec, sizeof(struct ocfs2_refcount_rec));\n\t\tle64_add_cpu(&tail_rec->r_cpos,\n\t\t\t     le32_to_cpu(tail_rec->r_clusters) - len);\n\t\ttail_rec->r_clusters = cpu_to_le32(len);\n\t}\n\n\t/*\n\t * If the split pos isn't the same as the original one, we need to\n\t * split in the head.\n\t *\n\t * Note: We have the chance that split_rec.r_refcount = 0,\n\t * recs_need = 0 and len > 0, which means we just cut the head from\n\t * the orig_rec and in that case we have done some modification in\n\t * orig_rec above, so the check for r_cpos is faked.\n\t */\n\tif (split_rec->r_cpos != orig_rec->r_cpos && tail_rec != orig_rec) {\n\t\tlen = le64_to_cpu(split_rec->r_cpos) -\n\t\t      le64_to_cpu(orig_rec->r_cpos);\n\t\torig_rec->r_clusters = cpu_to_le32(len);\n\t\tindex++;\n\t}\n\n\tle16_add_cpu(&rf_list->rl_used, recs_need);\n\n\tif (split_rec->r_refcount) {\n\t\trf_list->rl_recs[index] = *split_rec;\n\t\ttrace_ocfs2_split_refcount_rec_insert(\n\t\t\t(unsigned long long)ref_leaf_bh->b_blocknr, index,\n\t\t\t(unsigned long long)le64_to_cpu(split_rec->r_cpos),\n\t\t\tle32_to_cpu(split_rec->r_clusters),\n\t\t\tle32_to_cpu(split_rec->r_refcount));\n\n\t\tif (merge)\n\t\t\tocfs2_refcount_rec_merge(rb, index);\n\t}\n\n\tocfs2_journal_dirty(handle, ref_leaf_bh);\n\nout:\n\tbrelse(new_bh);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_split_refcount_rec(handle_t *handle,\n\t\t\t\t    struct ocfs2_caching_info *ci,\n\t\t\t\t    struct buffer_head *ref_root_bh,\n\t\t\t\t    struct buffer_head *ref_leaf_bh,\n\t\t\t\t    struct ocfs2_refcount_rec *split_rec,\n\t\t\t\t    int index, int merge,\n\t\t\t\t    struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t    struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret, recs_need;\n\tu32 len;\n\tstruct ocfs2_refcount_block *rb =\n\t\t\t(struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\n\tstruct ocfs2_refcount_list *rf_list = &rb->rf_records;\n\tstruct ocfs2_refcount_rec *orig_rec = &rf_list->rl_recs[index];\n\tstruct ocfs2_refcount_rec *tail_rec = NULL;\n\tstruct buffer_head *new_bh = NULL;\n\n\tBUG_ON(le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL);\n\n\ttrace_ocfs2_split_refcount_rec(le64_to_cpu(orig_rec->r_cpos),\n\t\tle32_to_cpu(orig_rec->r_clusters),\n\t\tle32_to_cpu(orig_rec->r_refcount),\n\t\tle64_to_cpu(split_rec->r_cpos),\n\t\tle32_to_cpu(split_rec->r_clusters),\n\t\tle32_to_cpu(split_rec->r_refcount));\n\n\t/*\n\t * If we just need to split the header or tail clusters,\n\t * no more recs are needed, just split is OK.\n\t * Otherwise we at least need one new recs.\n\t */\n\tif (!split_rec->r_refcount &&\n\t    (split_rec->r_cpos == orig_rec->r_cpos ||\n\t     le64_to_cpu(split_rec->r_cpos) +\n\t     le32_to_cpu(split_rec->r_clusters) ==\n\t     le64_to_cpu(orig_rec->r_cpos) + le32_to_cpu(orig_rec->r_clusters)))\n\t\trecs_need = 0;\n\telse\n\t\trecs_need = 1;\n\n\t/*\n\t * We need one more rec if we split in the middle and the new rec have\n\t * some refcount in it.\n\t */\n\tif (split_rec->r_refcount &&\n\t    (split_rec->r_cpos != orig_rec->r_cpos &&\n\t     le64_to_cpu(split_rec->r_cpos) +\n\t     le32_to_cpu(split_rec->r_clusters) !=\n\t     le64_to_cpu(orig_rec->r_cpos) + le32_to_cpu(orig_rec->r_clusters)))\n\t\trecs_need++;\n\n\t/* If the leaf block don't have enough record, expand it. */\n\tif (le16_to_cpu(rf_list->rl_used) + recs_need >\n\t\t\t\t\t le16_to_cpu(rf_list->rl_count)) {\n\t\tstruct ocfs2_refcount_rec tmp_rec;\n\t\tu64 cpos = le64_to_cpu(orig_rec->r_cpos);\n\t\tlen = le32_to_cpu(orig_rec->r_clusters);\n\t\tret = ocfs2_expand_refcount_tree(handle, ci, ref_root_bh,\n\t\t\t\t\t\t ref_leaf_bh, meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * We have to re-get it since now cpos may be moved to\n\t\t * another leaf block.\n\t\t */\n\t\tret = ocfs2_get_refcount_rec(ci, ref_root_bh,\n\t\t\t\t\t     cpos, len, &tmp_rec, &index,\n\t\t\t\t\t     &new_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tref_leaf_bh = new_bh;\n\t\trb = (struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\n\t\trf_list = &rb->rf_records;\n\t\torig_rec = &rf_list->rl_recs[index];\n\t}\n\n\tret = ocfs2_journal_access_rb(handle, ci, ref_leaf_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We have calculated out how many new records we need and store\n\t * in recs_need, so spare enough space first by moving the records\n\t * after \"index\" to the end.\n\t */\n\tif (index != le16_to_cpu(rf_list->rl_used) - 1)\n\t\tmemmove(&rf_list->rl_recs[index + 1 + recs_need],\n\t\t\t&rf_list->rl_recs[index + 1],\n\t\t\t(le16_to_cpu(rf_list->rl_used) - index - 1) *\n\t\t\t sizeof(struct ocfs2_refcount_rec));\n\n\tlen = (le64_to_cpu(orig_rec->r_cpos) +\n\t      le32_to_cpu(orig_rec->r_clusters)) -\n\t      (le64_to_cpu(split_rec->r_cpos) +\n\t      le32_to_cpu(split_rec->r_clusters));\n\n\t/*\n\t * If we have \"len\", the we will split in the tail and move it\n\t * to the end of the space we have just spared.\n\t */\n\tif (len) {\n\t\ttail_rec = &rf_list->rl_recs[index + recs_need];\n\n\t\tmemcpy(tail_rec, orig_rec, sizeof(struct ocfs2_refcount_rec));\n\t\tle64_add_cpu(&tail_rec->r_cpos,\n\t\t\t     le32_to_cpu(tail_rec->r_clusters) - len);\n\t\ttail_rec->r_clusters = cpu_to_le32(len);\n\t}\n\n\t/*\n\t * If the split pos isn't the same as the original one, we need to\n\t * split in the head.\n\t *\n\t * Note: We have the chance that split_rec.r_refcount = 0,\n\t * recs_need = 0 and len > 0, which means we just cut the head from\n\t * the orig_rec and in that case we have done some modification in\n\t * orig_rec above, so the check for r_cpos is faked.\n\t */\n\tif (split_rec->r_cpos != orig_rec->r_cpos && tail_rec != orig_rec) {\n\t\tlen = le64_to_cpu(split_rec->r_cpos) -\n\t\t      le64_to_cpu(orig_rec->r_cpos);\n\t\torig_rec->r_clusters = cpu_to_le32(len);\n\t\tindex++;\n\t}\n\n\tle16_add_cpu(&rf_list->rl_used, recs_need);\n\n\tif (split_rec->r_refcount) {\n\t\trf_list->rl_recs[index] = *split_rec;\n\t\ttrace_ocfs2_split_refcount_rec_insert(\n\t\t\t(unsigned long long)ref_leaf_bh->b_blocknr, index,\n\t\t\t(unsigned long long)le64_to_cpu(split_rec->r_cpos),\n\t\t\tle32_to_cpu(split_rec->r_clusters),\n\t\t\tle32_to_cpu(split_rec->r_refcount));\n\n\t\tif (merge)\n\t\t\tocfs2_refcount_rec_merge(rb, index);\n\t}\n\n\tocfs2_journal_dirty(handle, ref_leaf_bh);\n\nout:\n\tbrelse(new_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&split.r_refcount",
            "-1"
          ],
          "line": 2208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "len"
          ],
          "line": 2206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "cpos"
          ],
          "line": 2205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_change_refcount_rec",
          "args": [
            "handle",
            "ci",
            "ref_leaf_bh",
            "index",
            "1",
            "-1"
          ],
          "line": 2201
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_change_refcount_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "1245-1284",
          "snippet": "static int ocfs2_change_refcount_rec(handle_t *handle,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *ref_leaf_bh,\n\t\t\t\t     int index, int merge, int change)\n{\n\tint ret;\n\tstruct ocfs2_refcount_block *rb =\n\t\t\t(struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\n\tstruct ocfs2_refcount_list *rl = &rb->rf_records;\n\tstruct ocfs2_refcount_rec *rec = &rl->rl_recs[index];\n\n\tret = ocfs2_journal_access_rb(handle, ci, ref_leaf_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_change_refcount_rec(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\tindex, le32_to_cpu(rec->r_refcount), change);\n\tle32_add_cpu(&rec->r_refcount, change);\n\n\tif (!rec->r_refcount) {\n\t\tif (index != le16_to_cpu(rl->rl_used) - 1) {\n\t\t\tmemmove(rec, rec + 1,\n\t\t\t\t(le16_to_cpu(rl->rl_used) - index - 1) *\n\t\t\t\tsizeof(struct ocfs2_refcount_rec));\n\t\t\tmemset(&rl->rl_recs[le16_to_cpu(rl->rl_used) - 1],\n\t\t\t       0, sizeof(struct ocfs2_refcount_rec));\n\t\t}\n\n\t\tle16_add_cpu(&rl->rl_used, -1);\n\t} else if (merge)\n\t\tocfs2_refcount_rec_merge(rb, index);\n\n\tocfs2_journal_dirty(handle, ref_leaf_bh);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_change_refcount_rec(handle_t *handle,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *ref_leaf_bh,\n\t\t\t\t     int index, int merge, int change)\n{\n\tint ret;\n\tstruct ocfs2_refcount_block *rb =\n\t\t\t(struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\n\tstruct ocfs2_refcount_list *rl = &rb->rf_records;\n\tstruct ocfs2_refcount_rec *rec = &rl->rl_recs[index];\n\n\tret = ocfs2_journal_access_rb(handle, ci, ref_leaf_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_change_refcount_rec(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\tindex, le32_to_cpu(rec->r_refcount), change);\n\tle32_add_cpu(&rec->r_refcount, change);\n\n\tif (!rec->r_refcount) {\n\t\tif (index != le16_to_cpu(rl->rl_used) - 1) {\n\t\t\tmemmove(rec, rec + 1,\n\t\t\t\t(le16_to_cpu(rl->rl_used) - index - 1) *\n\t\t\t\tsizeof(struct ocfs2_refcount_rec));\n\t\t\tmemset(&rl->rl_recs[le16_to_cpu(rl->rl_used) - 1],\n\t\t\t       0, sizeof(struct ocfs2_refcount_rec));\n\t\t}\n\n\t\tle16_add_cpu(&rl->rl_used, -1);\n\t} else if (merge)\n\t\tocfs2_refcount_rec_merge(rb, index);\n\n\tocfs2_journal_dirty(handle, ref_leaf_bh);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rec->r_clusters"
          ],
          "line": 2200
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "rec->r_cpos"
          ],
          "line": 2199
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_decrease_refcount_rec",
          "args": [
            "(unsigned long long)ocfs2_metadata_cache_owner(ci)",
            "(unsigned long long)cpos",
            "len"
          ],
          "line": 2195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_owner",
          "args": [
            "ci"
          ],
          "line": 2196
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "72-77",
          "snippet": "u64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nu64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "cpos + len >\n\t       le64_to_cpu(rec->r_cpos) + le32_to_cpu(rec->r_clusters)"
          ],
          "line": 2192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "cpos < le64_to_cpu(rec->r_cpos)"
          ],
          "line": 2191
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_decrease_refcount_rec(handle_t *handle,\n\t\t\t\tstruct ocfs2_caching_info *ci,\n\t\t\t\tstruct buffer_head *ref_root_bh,\n\t\t\t\tstruct buffer_head *ref_leaf_bh,\n\t\t\t\tint index, u64 cpos, unsigned int len,\n\t\t\t\tstruct ocfs2_alloc_context *meta_ac,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret;\n\tstruct ocfs2_refcount_block *rb =\n\t\t\t(struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\n\tstruct ocfs2_refcount_rec *rec = &rb->rf_records.rl_recs[index];\n\n\tBUG_ON(cpos < le64_to_cpu(rec->r_cpos));\n\tBUG_ON(cpos + len >\n\t       le64_to_cpu(rec->r_cpos) + le32_to_cpu(rec->r_clusters));\n\n\ttrace_ocfs2_decrease_refcount_rec(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t(unsigned long long)cpos, len);\n\n\tif (cpos == le64_to_cpu(rec->r_cpos) &&\n\t    len == le32_to_cpu(rec->r_clusters))\n\t\tret = ocfs2_change_refcount_rec(handle, ci,\n\t\t\t\t\t\tref_leaf_bh, index, 1, -1);\n\telse {\n\t\tstruct ocfs2_refcount_rec split = *rec;\n\t\tsplit.r_cpos = cpu_to_le64(cpos);\n\t\tsplit.r_clusters = cpu_to_le32(len);\n\n\t\tle32_add_cpu(&split.r_refcount, -1);\n\n\t\tret = ocfs2_split_refcount_rec(handle, ci,\n\t\t\t\t\t       ref_root_bh, ref_leaf_bh,\n\t\t\t\t\t       &split, index, 1,\n\t\t\t\t\t       meta_ac, dealloc);\n\t}\n\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* Remove the leaf refcount block if it contains no refcount record. */\n\tif (!rb->rf_records.rl_used && ref_leaf_bh != ref_root_bh) {\n\t\tret = ocfs2_remove_refcount_extent(handle, ci, ref_root_bh,\n\t\t\t\t\t\t   ref_leaf_bh, meta_ac,\n\t\t\t\t\t\t   dealloc);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_increase_refcount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "2166-2176",
    "snippet": "int ocfs2_increase_refcount(handle_t *handle,\n\t\t\t    struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *ref_root_bh,\n\t\t\t    u64 cpos, u32 len,\n\t\t\t    struct ocfs2_alloc_context *meta_ac,\n\t\t\t    struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\treturn __ocfs2_increase_refcount(handle, ci, ref_root_bh,\n\t\t\t\t\t cpos, len, 1,\n\t\t\t\t\t meta_ac, dealloc);\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ocfs2_increase_refcount",
          "args": [
            "handle",
            "ci",
            "ref_root_bh",
            "cpos",
            "len",
            "1",
            "meta_ac",
            "dealloc"
          ],
          "line": 2173
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_increase_refcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "1992-2084",
          "snippet": "static int __ocfs2_increase_refcount(handle_t *handle,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *ref_root_bh,\n\t\t\t\t     u64 cpos, u32 len, int merge,\n\t\t\t\t     struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t     struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret = 0, index;\n\tstruct buffer_head *ref_leaf_bh = NULL;\n\tstruct ocfs2_refcount_rec rec;\n\tunsigned int set_len = 0;\n\n\ttrace_ocfs2_increase_refcount_begin(\n\t     (unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t     (unsigned long long)cpos, len);\n\n\twhile (len) {\n\t\tret = ocfs2_get_refcount_rec(ci, ref_root_bh,\n\t\t\t\t\t     cpos, len, &rec, &index,\n\t\t\t\t\t     &ref_leaf_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tset_len = le32_to_cpu(rec.r_clusters);\n\n\t\t/*\n\t\t * Here we may meet with 3 situations:\n\t\t *\n\t\t * 1. If we find an already existing record, and the length\n\t\t *    is the same, cool, we just need to increase the r_refcount\n\t\t *    and it is OK.\n\t\t * 2. If we find a hole, just insert it with r_refcount = 1.\n\t\t * 3. If we are in the middle of one extent record, split\n\t\t *    it.\n\t\t */\n\t\tif (rec.r_refcount && le64_to_cpu(rec.r_cpos) == cpos &&\n\t\t    set_len <= len) {\n\t\t\ttrace_ocfs2_increase_refcount_change(\n\t\t\t\t(unsigned long long)cpos, set_len,\n\t\t\t\tle32_to_cpu(rec.r_refcount));\n\t\t\tret = ocfs2_change_refcount_rec(handle, ci,\n\t\t\t\t\t\t\tref_leaf_bh, index,\n\t\t\t\t\t\t\tmerge, 1);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else if (!rec.r_refcount) {\n\t\t\trec.r_refcount = cpu_to_le32(1);\n\n\t\t\ttrace_ocfs2_increase_refcount_insert(\n\t\t\t     (unsigned long long)le64_to_cpu(rec.r_cpos),\n\t\t\t     set_len);\n\t\t\tret = ocfs2_insert_refcount_rec(handle, ci, ref_root_bh,\n\t\t\t\t\t\t\tref_leaf_bh,\n\t\t\t\t\t\t\t&rec, index,\n\t\t\t\t\t\t\tmerge, meta_ac);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else  {\n\t\t\tset_len = min((u64)(cpos + len),\n\t\t\t\t      le64_to_cpu(rec.r_cpos) + set_len) - cpos;\n\t\t\trec.r_cpos = cpu_to_le64(cpos);\n\t\t\trec.r_clusters = cpu_to_le32(set_len);\n\t\t\tle32_add_cpu(&rec.r_refcount, 1);\n\n\t\t\ttrace_ocfs2_increase_refcount_split(\n\t\t\t     (unsigned long long)le64_to_cpu(rec.r_cpos),\n\t\t\t     set_len, le32_to_cpu(rec.r_refcount));\n\t\t\tret = ocfs2_split_refcount_rec(handle, ci,\n\t\t\t\t\t\t       ref_root_bh, ref_leaf_bh,\n\t\t\t\t\t\t       &rec, index, merge,\n\t\t\t\t\t\t       meta_ac, dealloc);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tcpos += set_len;\n\t\tlen -= set_len;\n\t\tbrelse(ref_leaf_bh);\n\t\tref_leaf_bh = NULL;\n\t}\n\nout:\n\tbrelse(ref_leaf_bh);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int __ocfs2_increase_refcount(handle_t *handle,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *ref_root_bh,\n\t\t\t\t     u64 cpos, u32 len, int merge,\n\t\t\t\t     struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t     struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret = 0, index;\n\tstruct buffer_head *ref_leaf_bh = NULL;\n\tstruct ocfs2_refcount_rec rec;\n\tunsigned int set_len = 0;\n\n\ttrace_ocfs2_increase_refcount_begin(\n\t     (unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t     (unsigned long long)cpos, len);\n\n\twhile (len) {\n\t\tret = ocfs2_get_refcount_rec(ci, ref_root_bh,\n\t\t\t\t\t     cpos, len, &rec, &index,\n\t\t\t\t\t     &ref_leaf_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tset_len = le32_to_cpu(rec.r_clusters);\n\n\t\t/*\n\t\t * Here we may meet with 3 situations:\n\t\t *\n\t\t * 1. If we find an already existing record, and the length\n\t\t *    is the same, cool, we just need to increase the r_refcount\n\t\t *    and it is OK.\n\t\t * 2. If we find a hole, just insert it with r_refcount = 1.\n\t\t * 3. If we are in the middle of one extent record, split\n\t\t *    it.\n\t\t */\n\t\tif (rec.r_refcount && le64_to_cpu(rec.r_cpos) == cpos &&\n\t\t    set_len <= len) {\n\t\t\ttrace_ocfs2_increase_refcount_change(\n\t\t\t\t(unsigned long long)cpos, set_len,\n\t\t\t\tle32_to_cpu(rec.r_refcount));\n\t\t\tret = ocfs2_change_refcount_rec(handle, ci,\n\t\t\t\t\t\t\tref_leaf_bh, index,\n\t\t\t\t\t\t\tmerge, 1);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else if (!rec.r_refcount) {\n\t\t\trec.r_refcount = cpu_to_le32(1);\n\n\t\t\ttrace_ocfs2_increase_refcount_insert(\n\t\t\t     (unsigned long long)le64_to_cpu(rec.r_cpos),\n\t\t\t     set_len);\n\t\t\tret = ocfs2_insert_refcount_rec(handle, ci, ref_root_bh,\n\t\t\t\t\t\t\tref_leaf_bh,\n\t\t\t\t\t\t\t&rec, index,\n\t\t\t\t\t\t\tmerge, meta_ac);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else  {\n\t\t\tset_len = min((u64)(cpos + len),\n\t\t\t\t      le64_to_cpu(rec.r_cpos) + set_len) - cpos;\n\t\t\trec.r_cpos = cpu_to_le64(cpos);\n\t\t\trec.r_clusters = cpu_to_le32(set_len);\n\t\t\tle32_add_cpu(&rec.r_refcount, 1);\n\n\t\t\ttrace_ocfs2_increase_refcount_split(\n\t\t\t     (unsigned long long)le64_to_cpu(rec.r_cpos),\n\t\t\t     set_len, le32_to_cpu(rec.r_refcount));\n\t\t\tret = ocfs2_split_refcount_rec(handle, ci,\n\t\t\t\t\t\t       ref_root_bh, ref_leaf_bh,\n\t\t\t\t\t\t       &rec, index, merge,\n\t\t\t\t\t\t       meta_ac, dealloc);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tcpos += set_len;\n\t\tlen -= set_len;\n\t\tbrelse(ref_leaf_bh);\n\t\tref_leaf_bh = NULL;\n\t}\n\nout:\n\tbrelse(ref_leaf_bh);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nint ocfs2_increase_refcount(handle_t *handle,\n\t\t\t    struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *ref_root_bh,\n\t\t\t    u64 cpos, u32 len,\n\t\t\t    struct ocfs2_alloc_context *meta_ac,\n\t\t\t    struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\treturn __ocfs2_increase_refcount(handle, ci, ref_root_bh,\n\t\t\t\t\t cpos, len, 1,\n\t\t\t\t\t meta_ac, dealloc);\n}"
  },
  {
    "function_name": "ocfs2_remove_refcount_extent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "2086-2164",
    "snippet": "static int ocfs2_remove_refcount_extent(handle_t *handle,\n\t\t\t\tstruct ocfs2_caching_info *ci,\n\t\t\t\tstruct buffer_head *ref_root_bh,\n\t\t\t\tstruct buffer_head *ref_leaf_bh,\n\t\t\t\tstruct ocfs2_alloc_context *meta_ac,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\n\tstruct ocfs2_refcount_block *rb =\n\t\t\t(struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\n\tstruct ocfs2_extent_tree et;\n\n\tBUG_ON(rb->rf_records.rl_used);\n\n\ttrace_ocfs2_remove_refcount_extent(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t(unsigned long long)ref_leaf_bh->b_blocknr,\n\t\tle32_to_cpu(rb->rf_cpos));\n\n\tocfs2_init_refcount_extent_tree(&et, ci, ref_root_bh);\n\tret = ocfs2_remove_extent(handle, &et, le32_to_cpu(rb->rf_cpos),\n\t\t\t\t  1, meta_ac, dealloc);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_remove_from_cache(ci, ref_leaf_bh);\n\n\t/*\n\t * add the freed block to the dealloc so that it will be freed\n\t * when we run dealloc.\n\t */\n\tret = ocfs2_cache_block_dealloc(dealloc, EXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\t\tle16_to_cpu(rb->rf_suballoc_slot),\n\t\t\t\t\tle64_to_cpu(rb->rf_suballoc_loc),\n\t\t\t\t\tle64_to_cpu(rb->rf_blkno),\n\t\t\t\t\tle16_to_cpu(rb->rf_suballoc_bit));\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_rb(handle, ci, ref_root_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\trb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\n\tle32_add_cpu(&rb->rf_clusters, -1);\n\n\t/*\n\t * check whether we need to restore the root refcount block if\n\t * there is no leaf extent block at atll.\n\t */\n\tif (!rb->rf_list.l_next_free_rec) {\n\t\tBUG_ON(rb->rf_clusters);\n\n\t\ttrace_ocfs2_restore_refcount_block(\n\t\t     (unsigned long long)ref_root_bh->b_blocknr);\n\n\t\trb->rf_flags = 0;\n\t\trb->rf_parent = 0;\n\t\trb->rf_cpos = 0;\n\t\tmemset(&rb->rf_records, 0, sb->s_blocksize -\n\t\t       offsetof(struct ocfs2_refcount_block, rf_records));\n\t\trb->rf_records.rl_count =\n\t\t\t\tcpu_to_le16(ocfs2_refcount_recs_per_rb(sb));\n\t}\n\n\tocfs2_journal_dirty(handle, ref_root_bh);\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "ref_root_bh"
          ],
          "line": 2160
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "ocfs2_refcount_recs_per_rb(sb)"
          ],
          "line": 2157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_refcount_recs_per_rb",
          "args": [
            "sb"
          ],
          "line": 2157
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_refcount_recs_per_rb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1464-1472",
          "snippet": "static inline u16 ocfs2_refcount_recs_per_rb(struct super_block *sb)\n{\n\tint size;\n\n\tsize = sb->s_blocksize -\n\t\toffsetof(struct ocfs2_refcount_block, rf_records.rl_recs);\n\n\treturn size / sizeof(struct ocfs2_refcount_rec);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u16 ocfs2_refcount_recs_per_rb(struct super_block *sb)\n{\n\tint size;\n\n\tsize = sb->s_blocksize -\n\t\toffsetof(struct ocfs2_refcount_block, rf_records.rl_recs);\n\n\treturn size / sizeof(struct ocfs2_refcount_rec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&rb->rf_records",
            "0",
            "sb->s_blocksize -\n\t\t       offsetof(struct ocfs2_refcount_block, rf_records)"
          ],
          "line": 2154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_restore_refcount_block",
          "args": [
            "(unsigned long long)ref_root_bh->b_blocknr"
          ],
          "line": 2148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "rb->rf_clusters"
          ],
          "line": 2146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&rb->rf_clusters",
            "-1"
          ],
          "line": 2139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_rb",
          "args": [
            "handle",
            "ci",
            "ref_root_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 2130
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_rb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "722-727",
          "snippet": "int ocfs2_journal_access_rb(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &rb_triggers,\n\t\t\t\t      type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers rb_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_refcount_block, rf_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers rb_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_refcount_block, rf_check),\n};\n\nint ocfs2_journal_access_rb(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &rb_triggers,\n\t\t\t\t      type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_cache_block_dealloc",
          "args": [
            "dealloc",
            "EXTENT_ALLOC_SYSTEM_INODE",
            "le16_to_cpu(rb->rf_suballoc_slot)",
            "le64_to_cpu(rb->rf_suballoc_loc)",
            "le64_to_cpu(rb->rf_blkno)",
            "le16_to_cpu(rb->rf_suballoc_bit)"
          ],
          "line": 2120
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_cache_block_dealloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "6541-6577",
          "snippet": "int ocfs2_cache_block_dealloc(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t      int type, int slot, u64 suballoc,\n\t\t\t      u64 blkno, unsigned int bit)\n{\n\tint ret;\n\tstruct ocfs2_per_slot_free_list *fl;\n\tstruct ocfs2_cached_block_free *item;\n\n\tfl = ocfs2_find_per_slot_free_list(type, slot, ctxt);\n\tif (fl == NULL) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\titem = kzalloc(sizeof(*item), GFP_NOFS);\n\tif (item == NULL) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_cache_block_dealloc(type, slot,\n\t\t\t\t\t(unsigned long long)suballoc,\n\t\t\t\t\t(unsigned long long)blkno, bit);\n\n\titem->free_bg = suballoc;\n\titem->free_blk = blkno;\n\titem->free_bit = bit;\n\titem->free_next = fl->f_first;\n\n\tfl->f_first = item;\n\n\tret = 0;\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);\n\nint ocfs2_cache_block_dealloc(struct ocfs2_cached_dealloc_ctxt *ctxt,\n\t\t\t      int type, int slot, u64 suballoc,\n\t\t\t      u64 blkno, unsigned int bit)\n{\n\tint ret;\n\tstruct ocfs2_per_slot_free_list *fl;\n\tstruct ocfs2_cached_block_free *item;\n\n\tfl = ocfs2_find_per_slot_free_list(type, slot, ctxt);\n\tif (fl == NULL) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\titem = kzalloc(sizeof(*item), GFP_NOFS);\n\tif (item == NULL) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_cache_block_dealloc(type, slot,\n\t\t\t\t\t(unsigned long long)suballoc,\n\t\t\t\t\t(unsigned long long)blkno, bit);\n\n\titem->free_bg = suballoc;\n\titem->free_blk = blkno;\n\titem->free_bit = bit;\n\titem->free_next = fl->f_first;\n\n\tfl->f_first = item;\n\n\tret = 0;\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "rb->rf_suballoc_bit"
          ],
          "line": 2124
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "rb->rf_blkno"
          ],
          "line": 2123
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_remove_from_cache",
          "args": [
            "ci",
            "ref_leaf_bh"
          ],
          "line": 2114
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_remove_from_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "603-609",
          "snippet": "void ocfs2_remove_from_cache(struct ocfs2_caching_info *ci,\n\t\t\t     struct buffer_head *bh)\n{\n\tsector_t block = bh->b_blocknr;\n\n\tocfs2_remove_block_from_cache(ci, block);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_remove_from_cache(struct ocfs2_caching_info *ci,\n\t\t\t     struct buffer_head *bh)\n{\n\tsector_t block = bh->b_blocknr;\n\n\tocfs2_remove_block_from_cache(ci, block);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_remove_extent",
          "args": [
            "handle",
            "&et",
            "le32_to_cpu(rb->rf_cpos)",
            "1",
            "meta_ac",
            "dealloc"
          ],
          "line": 2107
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_remove_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "5470-5607",
          "snippet": "int ocfs2_remove_extent(handle_t *handle,\n\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\tu32 cpos, u32 len,\n\t\t\tstruct ocfs2_alloc_context *meta_ac,\n\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret, index;\n\tu32 rec_range, trunc_range;\n\tstruct ocfs2_extent_rec *rec;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_path *path = NULL;\n\n\t/*\n\t * XXX: Why are we truncating to 0 instead of wherever this\n\t * affects us?\n\t */\n\tocfs2_et_extent_map_truncate(et, 0);\n\n\tpath = ocfs2_new_path_from_et(et);\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_path(et->et_ci, path, cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tel = path_leaf_el(path);\n\tindex = ocfs2_search_extent_list(el, cpos);\n\tif (index == -1) {\n\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t    \"Owner %llu has an extent at cpos %u which can no \"\n\t\t\t    \"longer be found.\\n\",\n\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t    cpos);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We have 3 cases of extent removal:\n\t *   1) Range covers the entire extent rec\n\t *   2) Range begins or ends on one edge of the extent rec\n\t *   3) Range is in the middle of the extent rec (no shared edges)\n\t *\n\t * For case 1 we remove the extent rec and left rotate to\n\t * fill the hole.\n\t *\n\t * For case 2 we just shrink the existing extent rec, with a\n\t * tree update if the shrinking edge is also the edge of an\n\t * extent block.\n\t *\n\t * For case 3 we do a right split to turn the extent rec into\n\t * something case 2 can handle.\n\t */\n\trec = &el->l_recs[index];\n\trec_range = le32_to_cpu(rec->e_cpos) + ocfs2_rec_clusters(el, rec);\n\ttrunc_range = cpos + len;\n\n\tBUG_ON(cpos < le32_to_cpu(rec->e_cpos) || trunc_range > rec_range);\n\n\ttrace_ocfs2_remove_extent(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\tcpos, len, index, le32_to_cpu(rec->e_cpos),\n\t\tocfs2_rec_clusters(el, rec));\n\n\tif (le32_to_cpu(rec->e_cpos) == cpos || rec_range == trunc_range) {\n\t\tret = ocfs2_truncate_rec(handle, et, path, index, dealloc,\n\t\t\t\t\t cpos, len);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tret = ocfs2_split_tree(handle, et, path, index,\n\t\t\t\t       trunc_range, meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * The split could have manipulated the tree enough to\n\t\t * move the record location, so we have to look for it again.\n\t\t */\n\t\tocfs2_reinit_path(path, 1);\n\n\t\tret = ocfs2_find_path(et->et_ci, path, cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tel = path_leaf_el(path);\n\t\tindex = ocfs2_search_extent_list(el, cpos);\n\t\tif (index == -1) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t    \"Owner %llu: split at cpos %u lost record.\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\t    cpos);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Double check our values here. If anything is fishy,\n\t\t * it's easier to catch it at the top level.\n\t\t */\n\t\trec = &el->l_recs[index];\n\t\trec_range = le32_to_cpu(rec->e_cpos) +\n\t\t\tocfs2_rec_clusters(el, rec);\n\t\tif (rec_range != trunc_range) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t    \"Owner %llu: error after split at cpos %u\"\n\t\t\t\t    \"trunc len %u, existing record is (%u,%u)\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\t    cpos, len, le32_to_cpu(rec->e_cpos),\n\t\t\t\t    ocfs2_rec_clusters(el, rec));\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_truncate_rec(handle, et, path, index, dealloc,\n\t\t\t\t\t cpos, len);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tocfs2_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nint ocfs2_remove_extent(handle_t *handle,\n\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\tu32 cpos, u32 len,\n\t\t\tstruct ocfs2_alloc_context *meta_ac,\n\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret, index;\n\tu32 rec_range, trunc_range;\n\tstruct ocfs2_extent_rec *rec;\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_path *path = NULL;\n\n\t/*\n\t * XXX: Why are we truncating to 0 instead of wherever this\n\t * affects us?\n\t */\n\tocfs2_et_extent_map_truncate(et, 0);\n\n\tpath = ocfs2_new_path_from_et(et);\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_path(et->et_ci, path, cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tel = path_leaf_el(path);\n\tindex = ocfs2_search_extent_list(el, cpos);\n\tif (index == -1) {\n\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t    \"Owner %llu has an extent at cpos %u which can no \"\n\t\t\t    \"longer be found.\\n\",\n\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t    cpos);\n\t\tret = -EROFS;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We have 3 cases of extent removal:\n\t *   1) Range covers the entire extent rec\n\t *   2) Range begins or ends on one edge of the extent rec\n\t *   3) Range is in the middle of the extent rec (no shared edges)\n\t *\n\t * For case 1 we remove the extent rec and left rotate to\n\t * fill the hole.\n\t *\n\t * For case 2 we just shrink the existing extent rec, with a\n\t * tree update if the shrinking edge is also the edge of an\n\t * extent block.\n\t *\n\t * For case 3 we do a right split to turn the extent rec into\n\t * something case 2 can handle.\n\t */\n\trec = &el->l_recs[index];\n\trec_range = le32_to_cpu(rec->e_cpos) + ocfs2_rec_clusters(el, rec);\n\ttrunc_range = cpos + len;\n\n\tBUG_ON(cpos < le32_to_cpu(rec->e_cpos) || trunc_range > rec_range);\n\n\ttrace_ocfs2_remove_extent(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\tcpos, len, index, le32_to_cpu(rec->e_cpos),\n\t\tocfs2_rec_clusters(el, rec));\n\n\tif (le32_to_cpu(rec->e_cpos) == cpos || rec_range == trunc_range) {\n\t\tret = ocfs2_truncate_rec(handle, et, path, index, dealloc,\n\t\t\t\t\t cpos, len);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tret = ocfs2_split_tree(handle, et, path, index,\n\t\t\t\t       trunc_range, meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * The split could have manipulated the tree enough to\n\t\t * move the record location, so we have to look for it again.\n\t\t */\n\t\tocfs2_reinit_path(path, 1);\n\n\t\tret = ocfs2_find_path(et->et_ci, path, cpos);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tel = path_leaf_el(path);\n\t\tindex = ocfs2_search_extent_list(el, cpos);\n\t\tif (index == -1) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t    \"Owner %llu: split at cpos %u lost record.\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\t    cpos);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * Double check our values here. If anything is fishy,\n\t\t * it's easier to catch it at the top level.\n\t\t */\n\t\trec = &el->l_recs[index];\n\t\trec_range = le32_to_cpu(rec->e_cpos) +\n\t\t\tocfs2_rec_clusters(el, rec);\n\t\tif (rec_range != trunc_range) {\n\t\t\tocfs2_error(ocfs2_metadata_cache_get_super(et->et_ci),\n\t\t\t\t    \"Owner %llu: error after split at cpos %u\"\n\t\t\t\t    \"trunc len %u, existing record is (%u,%u)\",\n\t\t\t\t    (unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\t    cpos, len, le32_to_cpu(rec->e_cpos),\n\t\t\t\t    ocfs2_rec_clusters(el, rec));\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_truncate_rec(handle, et, path, index, dealloc,\n\t\t\t\t\t cpos, len);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tocfs2_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rb->rf_cpos"
          ],
          "line": 2107
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_init_refcount_extent_tree",
          "args": [
            "&et",
            "ci",
            "ref_root_bh"
          ],
          "line": 2106
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_refcount_extent_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "490-496",
          "snippet": "void ocfs2_init_refcount_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_rb,\n\t\t\t\t NULL, &ocfs2_refcount_tree_et_ops);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static struct ocfs2_extent_tree_operations ocfs2_refcount_tree_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_refcount_tree_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_refcount_tree_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_refcount_tree_update_clusters,\n\t.eo_fill_root_el\t= ocfs2_refcount_tree_fill_root_el,\n\t.eo_extent_contig\t= ocfs2_refcount_tree_extent_contig,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic struct ocfs2_extent_tree_operations ocfs2_refcount_tree_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_refcount_tree_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_refcount_tree_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_refcount_tree_update_clusters,\n\t.eo_fill_root_el\t= ocfs2_refcount_tree_fill_root_el,\n\t.eo_extent_contig\t= ocfs2_refcount_tree_extent_contig,\n};\n\nvoid ocfs2_init_refcount_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_rb,\n\t\t\t\t NULL, &ocfs2_refcount_tree_et_ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_remove_refcount_extent",
          "args": [
            "(unsigned long long)ocfs2_metadata_cache_owner(ci)",
            "(unsigned long long)ref_leaf_bh->b_blocknr",
            "le32_to_cpu(rb->rf_cpos)"
          ],
          "line": 2101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_owner",
          "args": [
            "ci"
          ],
          "line": 2102
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "72-77",
          "snippet": "u64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nu64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "rb->rf_records.rl_used"
          ],
          "line": 2099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_get_super",
          "args": [
            "ci"
          ],
          "line": 2094
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_get_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "79-84",
          "snippet": "struct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_remove_refcount_extent(handle_t *handle,\n\t\t\t\tstruct ocfs2_caching_info *ci,\n\t\t\t\tstruct buffer_head *ref_root_bh,\n\t\t\t\tstruct buffer_head *ref_leaf_bh,\n\t\t\t\tstruct ocfs2_alloc_context *meta_ac,\n\t\t\t\tstruct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\n\tstruct ocfs2_refcount_block *rb =\n\t\t\t(struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\n\tstruct ocfs2_extent_tree et;\n\n\tBUG_ON(rb->rf_records.rl_used);\n\n\ttrace_ocfs2_remove_refcount_extent(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t(unsigned long long)ref_leaf_bh->b_blocknr,\n\t\tle32_to_cpu(rb->rf_cpos));\n\n\tocfs2_init_refcount_extent_tree(&et, ci, ref_root_bh);\n\tret = ocfs2_remove_extent(handle, &et, le32_to_cpu(rb->rf_cpos),\n\t\t\t\t  1, meta_ac, dealloc);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_remove_from_cache(ci, ref_leaf_bh);\n\n\t/*\n\t * add the freed block to the dealloc so that it will be freed\n\t * when we run dealloc.\n\t */\n\tret = ocfs2_cache_block_dealloc(dealloc, EXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\t\tle16_to_cpu(rb->rf_suballoc_slot),\n\t\t\t\t\tle64_to_cpu(rb->rf_suballoc_loc),\n\t\t\t\t\tle64_to_cpu(rb->rf_blkno),\n\t\t\t\t\tle16_to_cpu(rb->rf_suballoc_bit));\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_rb(handle, ci, ref_root_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\trb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\n\tle32_add_cpu(&rb->rf_clusters, -1);\n\n\t/*\n\t * check whether we need to restore the root refcount block if\n\t * there is no leaf extent block at atll.\n\t */\n\tif (!rb->rf_list.l_next_free_rec) {\n\t\tBUG_ON(rb->rf_clusters);\n\n\t\ttrace_ocfs2_restore_refcount_block(\n\t\t     (unsigned long long)ref_root_bh->b_blocknr);\n\n\t\trb->rf_flags = 0;\n\t\trb->rf_parent = 0;\n\t\trb->rf_cpos = 0;\n\t\tmemset(&rb->rf_records, 0, sb->s_blocksize -\n\t\t       offsetof(struct ocfs2_refcount_block, rf_records));\n\t\trb->rf_records.rl_count =\n\t\t\t\tcpu_to_le16(ocfs2_refcount_recs_per_rb(sb));\n\t}\n\n\tocfs2_journal_dirty(handle, ref_root_bh);\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "__ocfs2_increase_refcount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "1992-2084",
    "snippet": "static int __ocfs2_increase_refcount(handle_t *handle,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *ref_root_bh,\n\t\t\t\t     u64 cpos, u32 len, int merge,\n\t\t\t\t     struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t     struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret = 0, index;\n\tstruct buffer_head *ref_leaf_bh = NULL;\n\tstruct ocfs2_refcount_rec rec;\n\tunsigned int set_len = 0;\n\n\ttrace_ocfs2_increase_refcount_begin(\n\t     (unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t     (unsigned long long)cpos, len);\n\n\twhile (len) {\n\t\tret = ocfs2_get_refcount_rec(ci, ref_root_bh,\n\t\t\t\t\t     cpos, len, &rec, &index,\n\t\t\t\t\t     &ref_leaf_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tset_len = le32_to_cpu(rec.r_clusters);\n\n\t\t/*\n\t\t * Here we may meet with 3 situations:\n\t\t *\n\t\t * 1. If we find an already existing record, and the length\n\t\t *    is the same, cool, we just need to increase the r_refcount\n\t\t *    and it is OK.\n\t\t * 2. If we find a hole, just insert it with r_refcount = 1.\n\t\t * 3. If we are in the middle of one extent record, split\n\t\t *    it.\n\t\t */\n\t\tif (rec.r_refcount && le64_to_cpu(rec.r_cpos) == cpos &&\n\t\t    set_len <= len) {\n\t\t\ttrace_ocfs2_increase_refcount_change(\n\t\t\t\t(unsigned long long)cpos, set_len,\n\t\t\t\tle32_to_cpu(rec.r_refcount));\n\t\t\tret = ocfs2_change_refcount_rec(handle, ci,\n\t\t\t\t\t\t\tref_leaf_bh, index,\n\t\t\t\t\t\t\tmerge, 1);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else if (!rec.r_refcount) {\n\t\t\trec.r_refcount = cpu_to_le32(1);\n\n\t\t\ttrace_ocfs2_increase_refcount_insert(\n\t\t\t     (unsigned long long)le64_to_cpu(rec.r_cpos),\n\t\t\t     set_len);\n\t\t\tret = ocfs2_insert_refcount_rec(handle, ci, ref_root_bh,\n\t\t\t\t\t\t\tref_leaf_bh,\n\t\t\t\t\t\t\t&rec, index,\n\t\t\t\t\t\t\tmerge, meta_ac);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else  {\n\t\t\tset_len = min((u64)(cpos + len),\n\t\t\t\t      le64_to_cpu(rec.r_cpos) + set_len) - cpos;\n\t\t\trec.r_cpos = cpu_to_le64(cpos);\n\t\t\trec.r_clusters = cpu_to_le32(set_len);\n\t\t\tle32_add_cpu(&rec.r_refcount, 1);\n\n\t\t\ttrace_ocfs2_increase_refcount_split(\n\t\t\t     (unsigned long long)le64_to_cpu(rec.r_cpos),\n\t\t\t     set_len, le32_to_cpu(rec.r_refcount));\n\t\t\tret = ocfs2_split_refcount_rec(handle, ci,\n\t\t\t\t\t\t       ref_root_bh, ref_leaf_bh,\n\t\t\t\t\t\t       &rec, index, merge,\n\t\t\t\t\t\t       meta_ac, dealloc);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tcpos += set_len;\n\t\tlen -= set_len;\n\t\tbrelse(ref_leaf_bh);\n\t\tref_leaf_bh = NULL;\n\t}\n\nout:\n\tbrelse(ref_leaf_bh);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "ref_leaf_bh"
          ],
          "line": 2082
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_split_refcount_rec",
          "args": [
            "handle",
            "ci",
            "ref_root_bh",
            "ref_leaf_bh",
            "&rec",
            "index",
            "merge",
            "meta_ac",
            "dealloc"
          ],
          "line": 2065
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_split_refcount_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "1836-1990",
          "snippet": "static int ocfs2_split_refcount_rec(handle_t *handle,\n\t\t\t\t    struct ocfs2_caching_info *ci,\n\t\t\t\t    struct buffer_head *ref_root_bh,\n\t\t\t\t    struct buffer_head *ref_leaf_bh,\n\t\t\t\t    struct ocfs2_refcount_rec *split_rec,\n\t\t\t\t    int index, int merge,\n\t\t\t\t    struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t    struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret, recs_need;\n\tu32 len;\n\tstruct ocfs2_refcount_block *rb =\n\t\t\t(struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\n\tstruct ocfs2_refcount_list *rf_list = &rb->rf_records;\n\tstruct ocfs2_refcount_rec *orig_rec = &rf_list->rl_recs[index];\n\tstruct ocfs2_refcount_rec *tail_rec = NULL;\n\tstruct buffer_head *new_bh = NULL;\n\n\tBUG_ON(le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL);\n\n\ttrace_ocfs2_split_refcount_rec(le64_to_cpu(orig_rec->r_cpos),\n\t\tle32_to_cpu(orig_rec->r_clusters),\n\t\tle32_to_cpu(orig_rec->r_refcount),\n\t\tle64_to_cpu(split_rec->r_cpos),\n\t\tle32_to_cpu(split_rec->r_clusters),\n\t\tle32_to_cpu(split_rec->r_refcount));\n\n\t/*\n\t * If we just need to split the header or tail clusters,\n\t * no more recs are needed, just split is OK.\n\t * Otherwise we at least need one new recs.\n\t */\n\tif (!split_rec->r_refcount &&\n\t    (split_rec->r_cpos == orig_rec->r_cpos ||\n\t     le64_to_cpu(split_rec->r_cpos) +\n\t     le32_to_cpu(split_rec->r_clusters) ==\n\t     le64_to_cpu(orig_rec->r_cpos) + le32_to_cpu(orig_rec->r_clusters)))\n\t\trecs_need = 0;\n\telse\n\t\trecs_need = 1;\n\n\t/*\n\t * We need one more rec if we split in the middle and the new rec have\n\t * some refcount in it.\n\t */\n\tif (split_rec->r_refcount &&\n\t    (split_rec->r_cpos != orig_rec->r_cpos &&\n\t     le64_to_cpu(split_rec->r_cpos) +\n\t     le32_to_cpu(split_rec->r_clusters) !=\n\t     le64_to_cpu(orig_rec->r_cpos) + le32_to_cpu(orig_rec->r_clusters)))\n\t\trecs_need++;\n\n\t/* If the leaf block don't have enough record, expand it. */\n\tif (le16_to_cpu(rf_list->rl_used) + recs_need >\n\t\t\t\t\t le16_to_cpu(rf_list->rl_count)) {\n\t\tstruct ocfs2_refcount_rec tmp_rec;\n\t\tu64 cpos = le64_to_cpu(orig_rec->r_cpos);\n\t\tlen = le32_to_cpu(orig_rec->r_clusters);\n\t\tret = ocfs2_expand_refcount_tree(handle, ci, ref_root_bh,\n\t\t\t\t\t\t ref_leaf_bh, meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * We have to re-get it since now cpos may be moved to\n\t\t * another leaf block.\n\t\t */\n\t\tret = ocfs2_get_refcount_rec(ci, ref_root_bh,\n\t\t\t\t\t     cpos, len, &tmp_rec, &index,\n\t\t\t\t\t     &new_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tref_leaf_bh = new_bh;\n\t\trb = (struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\n\t\trf_list = &rb->rf_records;\n\t\torig_rec = &rf_list->rl_recs[index];\n\t}\n\n\tret = ocfs2_journal_access_rb(handle, ci, ref_leaf_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We have calculated out how many new records we need and store\n\t * in recs_need, so spare enough space first by moving the records\n\t * after \"index\" to the end.\n\t */\n\tif (index != le16_to_cpu(rf_list->rl_used) - 1)\n\t\tmemmove(&rf_list->rl_recs[index + 1 + recs_need],\n\t\t\t&rf_list->rl_recs[index + 1],\n\t\t\t(le16_to_cpu(rf_list->rl_used) - index - 1) *\n\t\t\t sizeof(struct ocfs2_refcount_rec));\n\n\tlen = (le64_to_cpu(orig_rec->r_cpos) +\n\t      le32_to_cpu(orig_rec->r_clusters)) -\n\t      (le64_to_cpu(split_rec->r_cpos) +\n\t      le32_to_cpu(split_rec->r_clusters));\n\n\t/*\n\t * If we have \"len\", the we will split in the tail and move it\n\t * to the end of the space we have just spared.\n\t */\n\tif (len) {\n\t\ttail_rec = &rf_list->rl_recs[index + recs_need];\n\n\t\tmemcpy(tail_rec, orig_rec, sizeof(struct ocfs2_refcount_rec));\n\t\tle64_add_cpu(&tail_rec->r_cpos,\n\t\t\t     le32_to_cpu(tail_rec->r_clusters) - len);\n\t\ttail_rec->r_clusters = cpu_to_le32(len);\n\t}\n\n\t/*\n\t * If the split pos isn't the same as the original one, we need to\n\t * split in the head.\n\t *\n\t * Note: We have the chance that split_rec.r_refcount = 0,\n\t * recs_need = 0 and len > 0, which means we just cut the head from\n\t * the orig_rec and in that case we have done some modification in\n\t * orig_rec above, so the check for r_cpos is faked.\n\t */\n\tif (split_rec->r_cpos != orig_rec->r_cpos && tail_rec != orig_rec) {\n\t\tlen = le64_to_cpu(split_rec->r_cpos) -\n\t\t      le64_to_cpu(orig_rec->r_cpos);\n\t\torig_rec->r_clusters = cpu_to_le32(len);\n\t\tindex++;\n\t}\n\n\tle16_add_cpu(&rf_list->rl_used, recs_need);\n\n\tif (split_rec->r_refcount) {\n\t\trf_list->rl_recs[index] = *split_rec;\n\t\ttrace_ocfs2_split_refcount_rec_insert(\n\t\t\t(unsigned long long)ref_leaf_bh->b_blocknr, index,\n\t\t\t(unsigned long long)le64_to_cpu(split_rec->r_cpos),\n\t\t\tle32_to_cpu(split_rec->r_clusters),\n\t\t\tle32_to_cpu(split_rec->r_refcount));\n\n\t\tif (merge)\n\t\t\tocfs2_refcount_rec_merge(rb, index);\n\t}\n\n\tocfs2_journal_dirty(handle, ref_leaf_bh);\n\nout:\n\tbrelse(new_bh);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_split_refcount_rec(handle_t *handle,\n\t\t\t\t    struct ocfs2_caching_info *ci,\n\t\t\t\t    struct buffer_head *ref_root_bh,\n\t\t\t\t    struct buffer_head *ref_leaf_bh,\n\t\t\t\t    struct ocfs2_refcount_rec *split_rec,\n\t\t\t\t    int index, int merge,\n\t\t\t\t    struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t    struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret, recs_need;\n\tu32 len;\n\tstruct ocfs2_refcount_block *rb =\n\t\t\t(struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\n\tstruct ocfs2_refcount_list *rf_list = &rb->rf_records;\n\tstruct ocfs2_refcount_rec *orig_rec = &rf_list->rl_recs[index];\n\tstruct ocfs2_refcount_rec *tail_rec = NULL;\n\tstruct buffer_head *new_bh = NULL;\n\n\tBUG_ON(le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL);\n\n\ttrace_ocfs2_split_refcount_rec(le64_to_cpu(orig_rec->r_cpos),\n\t\tle32_to_cpu(orig_rec->r_clusters),\n\t\tle32_to_cpu(orig_rec->r_refcount),\n\t\tle64_to_cpu(split_rec->r_cpos),\n\t\tle32_to_cpu(split_rec->r_clusters),\n\t\tle32_to_cpu(split_rec->r_refcount));\n\n\t/*\n\t * If we just need to split the header or tail clusters,\n\t * no more recs are needed, just split is OK.\n\t * Otherwise we at least need one new recs.\n\t */\n\tif (!split_rec->r_refcount &&\n\t    (split_rec->r_cpos == orig_rec->r_cpos ||\n\t     le64_to_cpu(split_rec->r_cpos) +\n\t     le32_to_cpu(split_rec->r_clusters) ==\n\t     le64_to_cpu(orig_rec->r_cpos) + le32_to_cpu(orig_rec->r_clusters)))\n\t\trecs_need = 0;\n\telse\n\t\trecs_need = 1;\n\n\t/*\n\t * We need one more rec if we split in the middle and the new rec have\n\t * some refcount in it.\n\t */\n\tif (split_rec->r_refcount &&\n\t    (split_rec->r_cpos != orig_rec->r_cpos &&\n\t     le64_to_cpu(split_rec->r_cpos) +\n\t     le32_to_cpu(split_rec->r_clusters) !=\n\t     le64_to_cpu(orig_rec->r_cpos) + le32_to_cpu(orig_rec->r_clusters)))\n\t\trecs_need++;\n\n\t/* If the leaf block don't have enough record, expand it. */\n\tif (le16_to_cpu(rf_list->rl_used) + recs_need >\n\t\t\t\t\t le16_to_cpu(rf_list->rl_count)) {\n\t\tstruct ocfs2_refcount_rec tmp_rec;\n\t\tu64 cpos = le64_to_cpu(orig_rec->r_cpos);\n\t\tlen = le32_to_cpu(orig_rec->r_clusters);\n\t\tret = ocfs2_expand_refcount_tree(handle, ci, ref_root_bh,\n\t\t\t\t\t\t ref_leaf_bh, meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * We have to re-get it since now cpos may be moved to\n\t\t * another leaf block.\n\t\t */\n\t\tret = ocfs2_get_refcount_rec(ci, ref_root_bh,\n\t\t\t\t\t     cpos, len, &tmp_rec, &index,\n\t\t\t\t\t     &new_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tref_leaf_bh = new_bh;\n\t\trb = (struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\n\t\trf_list = &rb->rf_records;\n\t\torig_rec = &rf_list->rl_recs[index];\n\t}\n\n\tret = ocfs2_journal_access_rb(handle, ci, ref_leaf_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We have calculated out how many new records we need and store\n\t * in recs_need, so spare enough space first by moving the records\n\t * after \"index\" to the end.\n\t */\n\tif (index != le16_to_cpu(rf_list->rl_used) - 1)\n\t\tmemmove(&rf_list->rl_recs[index + 1 + recs_need],\n\t\t\t&rf_list->rl_recs[index + 1],\n\t\t\t(le16_to_cpu(rf_list->rl_used) - index - 1) *\n\t\t\t sizeof(struct ocfs2_refcount_rec));\n\n\tlen = (le64_to_cpu(orig_rec->r_cpos) +\n\t      le32_to_cpu(orig_rec->r_clusters)) -\n\t      (le64_to_cpu(split_rec->r_cpos) +\n\t      le32_to_cpu(split_rec->r_clusters));\n\n\t/*\n\t * If we have \"len\", the we will split in the tail and move it\n\t * to the end of the space we have just spared.\n\t */\n\tif (len) {\n\t\ttail_rec = &rf_list->rl_recs[index + recs_need];\n\n\t\tmemcpy(tail_rec, orig_rec, sizeof(struct ocfs2_refcount_rec));\n\t\tle64_add_cpu(&tail_rec->r_cpos,\n\t\t\t     le32_to_cpu(tail_rec->r_clusters) - len);\n\t\ttail_rec->r_clusters = cpu_to_le32(len);\n\t}\n\n\t/*\n\t * If the split pos isn't the same as the original one, we need to\n\t * split in the head.\n\t *\n\t * Note: We have the chance that split_rec.r_refcount = 0,\n\t * recs_need = 0 and len > 0, which means we just cut the head from\n\t * the orig_rec and in that case we have done some modification in\n\t * orig_rec above, so the check for r_cpos is faked.\n\t */\n\tif (split_rec->r_cpos != orig_rec->r_cpos && tail_rec != orig_rec) {\n\t\tlen = le64_to_cpu(split_rec->r_cpos) -\n\t\t      le64_to_cpu(orig_rec->r_cpos);\n\t\torig_rec->r_clusters = cpu_to_le32(len);\n\t\tindex++;\n\t}\n\n\tle16_add_cpu(&rf_list->rl_used, recs_need);\n\n\tif (split_rec->r_refcount) {\n\t\trf_list->rl_recs[index] = *split_rec;\n\t\ttrace_ocfs2_split_refcount_rec_insert(\n\t\t\t(unsigned long long)ref_leaf_bh->b_blocknr, index,\n\t\t\t(unsigned long long)le64_to_cpu(split_rec->r_cpos),\n\t\t\tle32_to_cpu(split_rec->r_clusters),\n\t\t\tle32_to_cpu(split_rec->r_refcount));\n\n\t\tif (merge)\n\t\t\tocfs2_refcount_rec_merge(rb, index);\n\t}\n\n\tocfs2_journal_dirty(handle, ref_leaf_bh);\n\nout:\n\tbrelse(new_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_increase_refcount_split",
          "args": [
            "(unsigned long long)le64_to_cpu(rec.r_cpos)",
            "set_len",
            "le32_to_cpu(rec.r_refcount)"
          ],
          "line": 2062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rec.r_refcount"
          ],
          "line": 2064
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "rec.r_cpos"
          ],
          "line": 2063
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&rec.r_refcount",
            "1"
          ],
          "line": 2060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "set_len"
          ],
          "line": 2059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "cpos"
          ],
          "line": 2058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "(u64)(cpos + len)",
            "le64_to_cpu(rec.r_cpos) + set_len"
          ],
          "line": 2056
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_hamming_encode_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
          "lines": "154-157",
          "snippet": "u32 ocfs2_hamming_encode_block(void *data, unsigned int blocksize)\n{\n\treturn ocfs2_hamming_encode(0, data, blocksize * 8, 0);\n}",
          "includes": [
            "#include \"blockcheck.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nu32 ocfs2_hamming_encode_block(void *data, unsigned int blocksize)\n{\n\treturn ocfs2_hamming_encode(0, data, blocksize * 8, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "cpos + len"
          ],
          "line": 2056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_insert_refcount_rec",
          "args": [
            "handle",
            "ci",
            "ref_root_bh",
            "ref_leaf_bh",
            "&rec",
            "index",
            "merge",
            "meta_ac"
          ],
          "line": 2047
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_insert_refcount_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "1748-1825",
          "snippet": "static int ocfs2_insert_refcount_rec(handle_t *handle,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *ref_root_bh,\n\t\t\t\t     struct buffer_head *ref_leaf_bh,\n\t\t\t\t     struct ocfs2_refcount_rec *rec,\n\t\t\t\t     int index, int merge,\n\t\t\t\t     struct ocfs2_alloc_context *meta_ac)\n{\n\tint ret;\n\tstruct ocfs2_refcount_block *rb =\n\t\t\t(struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\n\tstruct ocfs2_refcount_list *rf_list = &rb->rf_records;\n\tstruct buffer_head *new_bh = NULL;\n\n\tBUG_ON(le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL);\n\n\tif (rf_list->rl_used == rf_list->rl_count) {\n\t\tu64 cpos = le64_to_cpu(rec->r_cpos);\n\t\tu32 len = le32_to_cpu(rec->r_clusters);\n\n\t\tret = ocfs2_expand_refcount_tree(handle, ci, ref_root_bh,\n\t\t\t\t\t\t ref_leaf_bh, meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_get_refcount_rec(ci, ref_root_bh,\n\t\t\t\t\t     cpos, len, NULL, &index,\n\t\t\t\t\t     &new_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tref_leaf_bh = new_bh;\n\t\trb = (struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\n\t\trf_list = &rb->rf_records;\n\t}\n\n\tret = ocfs2_journal_access_rb(handle, ci, ref_leaf_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (index < le16_to_cpu(rf_list->rl_used))\n\t\tmemmove(&rf_list->rl_recs[index + 1],\n\t\t\t&rf_list->rl_recs[index],\n\t\t\t(le16_to_cpu(rf_list->rl_used) - index) *\n\t\t\t sizeof(struct ocfs2_refcount_rec));\n\n\ttrace_ocfs2_insert_refcount_rec(\n\t\t(unsigned long long)ref_leaf_bh->b_blocknr, index,\n\t\t(unsigned long long)le64_to_cpu(rec->r_cpos),\n\t\tle32_to_cpu(rec->r_clusters), le32_to_cpu(rec->r_refcount));\n\n\trf_list->rl_recs[index] = *rec;\n\n\tle16_add_cpu(&rf_list->rl_used, 1);\n\n\tif (merge)\n\t\tocfs2_refcount_rec_merge(rb, index);\n\n\tocfs2_journal_dirty(handle, ref_leaf_bh);\n\n\tif (index == 0) {\n\t\tret = ocfs2_adjust_refcount_rec(handle, ci,\n\t\t\t\t\t\tref_root_bh,\n\t\t\t\t\t\tref_leaf_bh, rec);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\nout:\n\tbrelse(new_bh);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_insert_refcount_rec(handle_t *handle,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *ref_root_bh,\n\t\t\t\t     struct buffer_head *ref_leaf_bh,\n\t\t\t\t     struct ocfs2_refcount_rec *rec,\n\t\t\t\t     int index, int merge,\n\t\t\t\t     struct ocfs2_alloc_context *meta_ac)\n{\n\tint ret;\n\tstruct ocfs2_refcount_block *rb =\n\t\t\t(struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\n\tstruct ocfs2_refcount_list *rf_list = &rb->rf_records;\n\tstruct buffer_head *new_bh = NULL;\n\n\tBUG_ON(le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL);\n\n\tif (rf_list->rl_used == rf_list->rl_count) {\n\t\tu64 cpos = le64_to_cpu(rec->r_cpos);\n\t\tu32 len = le32_to_cpu(rec->r_clusters);\n\n\t\tret = ocfs2_expand_refcount_tree(handle, ci, ref_root_bh,\n\t\t\t\t\t\t ref_leaf_bh, meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_get_refcount_rec(ci, ref_root_bh,\n\t\t\t\t\t     cpos, len, NULL, &index,\n\t\t\t\t\t     &new_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tref_leaf_bh = new_bh;\n\t\trb = (struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\n\t\trf_list = &rb->rf_records;\n\t}\n\n\tret = ocfs2_journal_access_rb(handle, ci, ref_leaf_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (index < le16_to_cpu(rf_list->rl_used))\n\t\tmemmove(&rf_list->rl_recs[index + 1],\n\t\t\t&rf_list->rl_recs[index],\n\t\t\t(le16_to_cpu(rf_list->rl_used) - index) *\n\t\t\t sizeof(struct ocfs2_refcount_rec));\n\n\ttrace_ocfs2_insert_refcount_rec(\n\t\t(unsigned long long)ref_leaf_bh->b_blocknr, index,\n\t\t(unsigned long long)le64_to_cpu(rec->r_cpos),\n\t\tle32_to_cpu(rec->r_clusters), le32_to_cpu(rec->r_refcount));\n\n\trf_list->rl_recs[index] = *rec;\n\n\tle16_add_cpu(&rf_list->rl_used, 1);\n\n\tif (merge)\n\t\tocfs2_refcount_rec_merge(rb, index);\n\n\tocfs2_journal_dirty(handle, ref_leaf_bh);\n\n\tif (index == 0) {\n\t\tret = ocfs2_adjust_refcount_rec(handle, ci,\n\t\t\t\t\t\tref_root_bh,\n\t\t\t\t\t\tref_leaf_bh, rec);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\nout:\n\tbrelse(new_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_increase_refcount_insert",
          "args": [
            "(unsigned long long)le64_to_cpu(rec.r_cpos)",
            "set_len"
          ],
          "line": 2044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "1"
          ],
          "line": 2042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_change_refcount_rec",
          "args": [
            "handle",
            "ci",
            "ref_leaf_bh",
            "index",
            "merge",
            "1"
          ],
          "line": 2034
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_change_refcount_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "1245-1284",
          "snippet": "static int ocfs2_change_refcount_rec(handle_t *handle,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *ref_leaf_bh,\n\t\t\t\t     int index, int merge, int change)\n{\n\tint ret;\n\tstruct ocfs2_refcount_block *rb =\n\t\t\t(struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\n\tstruct ocfs2_refcount_list *rl = &rb->rf_records;\n\tstruct ocfs2_refcount_rec *rec = &rl->rl_recs[index];\n\n\tret = ocfs2_journal_access_rb(handle, ci, ref_leaf_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_change_refcount_rec(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\tindex, le32_to_cpu(rec->r_refcount), change);\n\tle32_add_cpu(&rec->r_refcount, change);\n\n\tif (!rec->r_refcount) {\n\t\tif (index != le16_to_cpu(rl->rl_used) - 1) {\n\t\t\tmemmove(rec, rec + 1,\n\t\t\t\t(le16_to_cpu(rl->rl_used) - index - 1) *\n\t\t\t\tsizeof(struct ocfs2_refcount_rec));\n\t\t\tmemset(&rl->rl_recs[le16_to_cpu(rl->rl_used) - 1],\n\t\t\t       0, sizeof(struct ocfs2_refcount_rec));\n\t\t}\n\n\t\tle16_add_cpu(&rl->rl_used, -1);\n\t} else if (merge)\n\t\tocfs2_refcount_rec_merge(rb, index);\n\n\tocfs2_journal_dirty(handle, ref_leaf_bh);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_change_refcount_rec(handle_t *handle,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *ref_leaf_bh,\n\t\t\t\t     int index, int merge, int change)\n{\n\tint ret;\n\tstruct ocfs2_refcount_block *rb =\n\t\t\t(struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\n\tstruct ocfs2_refcount_list *rl = &rb->rf_records;\n\tstruct ocfs2_refcount_rec *rec = &rl->rl_recs[index];\n\n\tret = ocfs2_journal_access_rb(handle, ci, ref_leaf_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_change_refcount_rec(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\tindex, le32_to_cpu(rec->r_refcount), change);\n\tle32_add_cpu(&rec->r_refcount, change);\n\n\tif (!rec->r_refcount) {\n\t\tif (index != le16_to_cpu(rl->rl_used) - 1) {\n\t\t\tmemmove(rec, rec + 1,\n\t\t\t\t(le16_to_cpu(rl->rl_used) - index - 1) *\n\t\t\t\tsizeof(struct ocfs2_refcount_rec));\n\t\t\tmemset(&rl->rl_recs[le16_to_cpu(rl->rl_used) - 1],\n\t\t\t       0, sizeof(struct ocfs2_refcount_rec));\n\t\t}\n\n\t\tle16_add_cpu(&rl->rl_used, -1);\n\t} else if (merge)\n\t\tocfs2_refcount_rec_merge(rb, index);\n\n\tocfs2_journal_dirty(handle, ref_leaf_bh);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_increase_refcount_change",
          "args": [
            "(unsigned long long)cpos",
            "set_len",
            "le32_to_cpu(rec.r_refcount)"
          ],
          "line": 2031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 2013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_refcount_rec",
          "args": [
            "ci",
            "ref_root_bh",
            "cpos",
            "len",
            "&rec",
            "&index",
            "&ref_leaf_bh"
          ],
          "line": 2009
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_get_refcount_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "1066-1150",
          "snippet": "static int ocfs2_get_refcount_rec(struct ocfs2_caching_info *ci,\n\t\t\t\t  struct buffer_head *ref_root_bh,\n\t\t\t\t  u64 cpos, unsigned int len,\n\t\t\t\t  struct ocfs2_refcount_rec *ret_rec,\n\t\t\t\t  int *index,\n\t\t\t\t  struct buffer_head **ret_bh)\n{\n\tint ret = 0, i, found;\n\tu32 low_cpos, uninitialized_var(cpos_end);\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec = NULL;\n\tstruct ocfs2_extent_block *eb = NULL;\n\tstruct buffer_head *eb_bh = NULL, *ref_leaf_bh = NULL;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\n\tstruct ocfs2_refcount_block *rb =\n\t\t\t(struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\n\tif (!(le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL)) {\n\t\tocfs2_find_refcount_rec_in_rl(ci, ref_root_bh, cpos, len,\n\t\t\t\t\t      ret_rec, index);\n\t\t*ret_bh = ref_root_bh;\n\t\tget_bh(ref_root_bh);\n\t\treturn 0;\n\t}\n\n\tel = &rb->rf_list;\n\tlow_cpos = cpos & OCFS2_32BIT_POS_MASK;\n\n\tif (el->l_tree_depth) {\n\t\tret = ocfs2_find_leaf(ci, el, low_cpos, &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tocfs2_error(sb,\n\t\t\t\"refcount tree %llu has non zero tree \"\n\t\t\t\"depth in leaf btree tree block %llu\\n\",\n\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t\t(unsigned long long)eb_bh->b_blocknr);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfound = 0;\n\tfor (i = le16_to_cpu(el->l_next_free_rec) - 1; i >= 0; i--) {\n\t\trec = &el->l_recs[i];\n\n\t\tif (le32_to_cpu(rec->e_cpos) <= low_cpos) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found) {\n\t\tret = ocfs2_get_refcount_cpos_end(ci, ref_root_bh,\n\t\t\t\t\t\t  eb, el, i, &cpos_end);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (cpos_end < low_cpos + len)\n\t\t\tlen = cpos_end - low_cpos;\n\t}\n\n\tret = ocfs2_read_refcount_block(ci, le64_to_cpu(rec->e_blkno),\n\t\t\t\t\t&ref_leaf_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_find_refcount_rec_in_rl(ci, ref_leaf_bh, cpos, len,\n\t\t\t\t      ret_rec, index);\n\t*ret_bh = ref_leaf_bh;\nout:\n\tbrelse(eb_bh);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_get_refcount_rec(struct ocfs2_caching_info *ci,\n\t\t\t\t  struct buffer_head *ref_root_bh,\n\t\t\t\t  u64 cpos, unsigned int len,\n\t\t\t\t  struct ocfs2_refcount_rec *ret_rec,\n\t\t\t\t  int *index,\n\t\t\t\t  struct buffer_head **ret_bh)\n{\n\tint ret = 0, i, found;\n\tu32 low_cpos, uninitialized_var(cpos_end);\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec = NULL;\n\tstruct ocfs2_extent_block *eb = NULL;\n\tstruct buffer_head *eb_bh = NULL, *ref_leaf_bh = NULL;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\n\tstruct ocfs2_refcount_block *rb =\n\t\t\t(struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\n\tif (!(le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL)) {\n\t\tocfs2_find_refcount_rec_in_rl(ci, ref_root_bh, cpos, len,\n\t\t\t\t\t      ret_rec, index);\n\t\t*ret_bh = ref_root_bh;\n\t\tget_bh(ref_root_bh);\n\t\treturn 0;\n\t}\n\n\tel = &rb->rf_list;\n\tlow_cpos = cpos & OCFS2_32BIT_POS_MASK;\n\n\tif (el->l_tree_depth) {\n\t\tret = ocfs2_find_leaf(ci, el, low_cpos, &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tocfs2_error(sb,\n\t\t\t\"refcount tree %llu has non zero tree \"\n\t\t\t\"depth in leaf btree tree block %llu\\n\",\n\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t\t(unsigned long long)eb_bh->b_blocknr);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfound = 0;\n\tfor (i = le16_to_cpu(el->l_next_free_rec) - 1; i >= 0; i--) {\n\t\trec = &el->l_recs[i];\n\n\t\tif (le32_to_cpu(rec->e_cpos) <= low_cpos) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found) {\n\t\tret = ocfs2_get_refcount_cpos_end(ci, ref_root_bh,\n\t\t\t\t\t\t  eb, el, i, &cpos_end);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (cpos_end < low_cpos + len)\n\t\t\tlen = cpos_end - low_cpos;\n\t}\n\n\tret = ocfs2_read_refcount_block(ci, le64_to_cpu(rec->e_blkno),\n\t\t\t\t\t&ref_leaf_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_find_refcount_rec_in_rl(ci, ref_leaf_bh, cpos, len,\n\t\t\t\t      ret_rec, index);\n\t*ret_bh = ref_leaf_bh;\nout:\n\tbrelse(eb_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_increase_refcount_begin",
          "args": [
            "(unsigned long long)ocfs2_metadata_cache_owner(ci)",
            "(unsigned long long)cpos",
            "len"
          ],
          "line": 2004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_owner",
          "args": [
            "ci"
          ],
          "line": 2005
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "72-77",
          "snippet": "u64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nu64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int __ocfs2_increase_refcount(handle_t *handle,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *ref_root_bh,\n\t\t\t\t     u64 cpos, u32 len, int merge,\n\t\t\t\t     struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t     struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret = 0, index;\n\tstruct buffer_head *ref_leaf_bh = NULL;\n\tstruct ocfs2_refcount_rec rec;\n\tunsigned int set_len = 0;\n\n\ttrace_ocfs2_increase_refcount_begin(\n\t     (unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t     (unsigned long long)cpos, len);\n\n\twhile (len) {\n\t\tret = ocfs2_get_refcount_rec(ci, ref_root_bh,\n\t\t\t\t\t     cpos, len, &rec, &index,\n\t\t\t\t\t     &ref_leaf_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tset_len = le32_to_cpu(rec.r_clusters);\n\n\t\t/*\n\t\t * Here we may meet with 3 situations:\n\t\t *\n\t\t * 1. If we find an already existing record, and the length\n\t\t *    is the same, cool, we just need to increase the r_refcount\n\t\t *    and it is OK.\n\t\t * 2. If we find a hole, just insert it with r_refcount = 1.\n\t\t * 3. If we are in the middle of one extent record, split\n\t\t *    it.\n\t\t */\n\t\tif (rec.r_refcount && le64_to_cpu(rec.r_cpos) == cpos &&\n\t\t    set_len <= len) {\n\t\t\ttrace_ocfs2_increase_refcount_change(\n\t\t\t\t(unsigned long long)cpos, set_len,\n\t\t\t\tle32_to_cpu(rec.r_refcount));\n\t\t\tret = ocfs2_change_refcount_rec(handle, ci,\n\t\t\t\t\t\t\tref_leaf_bh, index,\n\t\t\t\t\t\t\tmerge, 1);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else if (!rec.r_refcount) {\n\t\t\trec.r_refcount = cpu_to_le32(1);\n\n\t\t\ttrace_ocfs2_increase_refcount_insert(\n\t\t\t     (unsigned long long)le64_to_cpu(rec.r_cpos),\n\t\t\t     set_len);\n\t\t\tret = ocfs2_insert_refcount_rec(handle, ci, ref_root_bh,\n\t\t\t\t\t\t\tref_leaf_bh,\n\t\t\t\t\t\t\t&rec, index,\n\t\t\t\t\t\t\tmerge, meta_ac);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else  {\n\t\t\tset_len = min((u64)(cpos + len),\n\t\t\t\t      le64_to_cpu(rec.r_cpos) + set_len) - cpos;\n\t\t\trec.r_cpos = cpu_to_le64(cpos);\n\t\t\trec.r_clusters = cpu_to_le32(set_len);\n\t\t\tle32_add_cpu(&rec.r_refcount, 1);\n\n\t\t\ttrace_ocfs2_increase_refcount_split(\n\t\t\t     (unsigned long long)le64_to_cpu(rec.r_cpos),\n\t\t\t     set_len, le32_to_cpu(rec.r_refcount));\n\t\t\tret = ocfs2_split_refcount_rec(handle, ci,\n\t\t\t\t\t\t       ref_root_bh, ref_leaf_bh,\n\t\t\t\t\t\t       &rec, index, merge,\n\t\t\t\t\t\t       meta_ac, dealloc);\n\t\t\tif (ret) {\n\t\t\t\tmlog_errno(ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\tcpos += set_len;\n\t\tlen -= set_len;\n\t\tbrelse(ref_leaf_bh);\n\t\tref_leaf_bh = NULL;\n\t}\n\nout:\n\tbrelse(ref_leaf_bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_split_refcount_rec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "1836-1990",
    "snippet": "static int ocfs2_split_refcount_rec(handle_t *handle,\n\t\t\t\t    struct ocfs2_caching_info *ci,\n\t\t\t\t    struct buffer_head *ref_root_bh,\n\t\t\t\t    struct buffer_head *ref_leaf_bh,\n\t\t\t\t    struct ocfs2_refcount_rec *split_rec,\n\t\t\t\t    int index, int merge,\n\t\t\t\t    struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t    struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret, recs_need;\n\tu32 len;\n\tstruct ocfs2_refcount_block *rb =\n\t\t\t(struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\n\tstruct ocfs2_refcount_list *rf_list = &rb->rf_records;\n\tstruct ocfs2_refcount_rec *orig_rec = &rf_list->rl_recs[index];\n\tstruct ocfs2_refcount_rec *tail_rec = NULL;\n\tstruct buffer_head *new_bh = NULL;\n\n\tBUG_ON(le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL);\n\n\ttrace_ocfs2_split_refcount_rec(le64_to_cpu(orig_rec->r_cpos),\n\t\tle32_to_cpu(orig_rec->r_clusters),\n\t\tle32_to_cpu(orig_rec->r_refcount),\n\t\tle64_to_cpu(split_rec->r_cpos),\n\t\tle32_to_cpu(split_rec->r_clusters),\n\t\tle32_to_cpu(split_rec->r_refcount));\n\n\t/*\n\t * If we just need to split the header or tail clusters,\n\t * no more recs are needed, just split is OK.\n\t * Otherwise we at least need one new recs.\n\t */\n\tif (!split_rec->r_refcount &&\n\t    (split_rec->r_cpos == orig_rec->r_cpos ||\n\t     le64_to_cpu(split_rec->r_cpos) +\n\t     le32_to_cpu(split_rec->r_clusters) ==\n\t     le64_to_cpu(orig_rec->r_cpos) + le32_to_cpu(orig_rec->r_clusters)))\n\t\trecs_need = 0;\n\telse\n\t\trecs_need = 1;\n\n\t/*\n\t * We need one more rec if we split in the middle and the new rec have\n\t * some refcount in it.\n\t */\n\tif (split_rec->r_refcount &&\n\t    (split_rec->r_cpos != orig_rec->r_cpos &&\n\t     le64_to_cpu(split_rec->r_cpos) +\n\t     le32_to_cpu(split_rec->r_clusters) !=\n\t     le64_to_cpu(orig_rec->r_cpos) + le32_to_cpu(orig_rec->r_clusters)))\n\t\trecs_need++;\n\n\t/* If the leaf block don't have enough record, expand it. */\n\tif (le16_to_cpu(rf_list->rl_used) + recs_need >\n\t\t\t\t\t le16_to_cpu(rf_list->rl_count)) {\n\t\tstruct ocfs2_refcount_rec tmp_rec;\n\t\tu64 cpos = le64_to_cpu(orig_rec->r_cpos);\n\t\tlen = le32_to_cpu(orig_rec->r_clusters);\n\t\tret = ocfs2_expand_refcount_tree(handle, ci, ref_root_bh,\n\t\t\t\t\t\t ref_leaf_bh, meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * We have to re-get it since now cpos may be moved to\n\t\t * another leaf block.\n\t\t */\n\t\tret = ocfs2_get_refcount_rec(ci, ref_root_bh,\n\t\t\t\t\t     cpos, len, &tmp_rec, &index,\n\t\t\t\t\t     &new_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tref_leaf_bh = new_bh;\n\t\trb = (struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\n\t\trf_list = &rb->rf_records;\n\t\torig_rec = &rf_list->rl_recs[index];\n\t}\n\n\tret = ocfs2_journal_access_rb(handle, ci, ref_leaf_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We have calculated out how many new records we need and store\n\t * in recs_need, so spare enough space first by moving the records\n\t * after \"index\" to the end.\n\t */\n\tif (index != le16_to_cpu(rf_list->rl_used) - 1)\n\t\tmemmove(&rf_list->rl_recs[index + 1 + recs_need],\n\t\t\t&rf_list->rl_recs[index + 1],\n\t\t\t(le16_to_cpu(rf_list->rl_used) - index - 1) *\n\t\t\t sizeof(struct ocfs2_refcount_rec));\n\n\tlen = (le64_to_cpu(orig_rec->r_cpos) +\n\t      le32_to_cpu(orig_rec->r_clusters)) -\n\t      (le64_to_cpu(split_rec->r_cpos) +\n\t      le32_to_cpu(split_rec->r_clusters));\n\n\t/*\n\t * If we have \"len\", the we will split in the tail and move it\n\t * to the end of the space we have just spared.\n\t */\n\tif (len) {\n\t\ttail_rec = &rf_list->rl_recs[index + recs_need];\n\n\t\tmemcpy(tail_rec, orig_rec, sizeof(struct ocfs2_refcount_rec));\n\t\tle64_add_cpu(&tail_rec->r_cpos,\n\t\t\t     le32_to_cpu(tail_rec->r_clusters) - len);\n\t\ttail_rec->r_clusters = cpu_to_le32(len);\n\t}\n\n\t/*\n\t * If the split pos isn't the same as the original one, we need to\n\t * split in the head.\n\t *\n\t * Note: We have the chance that split_rec.r_refcount = 0,\n\t * recs_need = 0 and len > 0, which means we just cut the head from\n\t * the orig_rec and in that case we have done some modification in\n\t * orig_rec above, so the check for r_cpos is faked.\n\t */\n\tif (split_rec->r_cpos != orig_rec->r_cpos && tail_rec != orig_rec) {\n\t\tlen = le64_to_cpu(split_rec->r_cpos) -\n\t\t      le64_to_cpu(orig_rec->r_cpos);\n\t\torig_rec->r_clusters = cpu_to_le32(len);\n\t\tindex++;\n\t}\n\n\tle16_add_cpu(&rf_list->rl_used, recs_need);\n\n\tif (split_rec->r_refcount) {\n\t\trf_list->rl_recs[index] = *split_rec;\n\t\ttrace_ocfs2_split_refcount_rec_insert(\n\t\t\t(unsigned long long)ref_leaf_bh->b_blocknr, index,\n\t\t\t(unsigned long long)le64_to_cpu(split_rec->r_cpos),\n\t\t\tle32_to_cpu(split_rec->r_clusters),\n\t\t\tle32_to_cpu(split_rec->r_refcount));\n\n\t\tif (merge)\n\t\t\tocfs2_refcount_rec_merge(rb, index);\n\t}\n\n\tocfs2_journal_dirty(handle, ref_leaf_bh);\n\nout:\n\tbrelse(new_bh);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "new_bh"
          ],
          "line": 1988
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "ref_leaf_bh"
          ],
          "line": 1985
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_refcount_rec_merge",
          "args": [
            "rb",
            "index"
          ],
          "line": 1982
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_refcount_rec_merge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "1221-1239",
          "snippet": "static void ocfs2_refcount_rec_merge(struct ocfs2_refcount_block *rb,\n\t\t\t\t     int index)\n{\n\tenum ocfs2_ref_rec_contig contig =\n\t\t\t\tocfs2_refcount_rec_contig(rb, index);\n\n\tif (contig == REF_CONTIG_NONE)\n\t\treturn;\n\n\tif (contig == REF_CONTIG_LEFT || contig == REF_CONTIG_LEFTRIGHT) {\n\t\tBUG_ON(index == 0);\n\t\tindex--;\n\t}\n\n\tocfs2_rotate_refcount_rec_left(rb, index);\n\n\tif (contig == REF_CONTIG_LEFTRIGHT)\n\t\tocfs2_rotate_refcount_rec_left(rb, index);\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic void ocfs2_refcount_rec_merge(struct ocfs2_refcount_block *rb,\n\t\t\t\t     int index)\n{\n\tenum ocfs2_ref_rec_contig contig =\n\t\t\t\tocfs2_refcount_rec_contig(rb, index);\n\n\tif (contig == REF_CONTIG_NONE)\n\t\treturn;\n\n\tif (contig == REF_CONTIG_LEFT || contig == REF_CONTIG_LEFTRIGHT) {\n\t\tBUG_ON(index == 0);\n\t\tindex--;\n\t}\n\n\tocfs2_rotate_refcount_rec_left(rb, index);\n\n\tif (contig == REF_CONTIG_LEFTRIGHT)\n\t\tocfs2_rotate_refcount_rec_left(rb, index);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_split_refcount_rec_insert",
          "args": [
            "(unsigned long long)ref_leaf_bh->b_blocknr",
            "index",
            "(unsigned long long)le64_to_cpu(split_rec->r_cpos)",
            "le32_to_cpu(split_rec->r_clusters)",
            "le32_to_cpu(split_rec->r_refcount)"
          ],
          "line": 1975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "split_rec->r_refcount"
          ],
          "line": 1979
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "split_rec->r_cpos"
          ],
          "line": 1977
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&rf_list->rl_used",
            "recs_need"
          ],
          "line": 1971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "len"
          ],
          "line": 1967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "len"
          ],
          "line": 1952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_add_cpu",
          "args": [
            "&tail_rec->r_cpos",
            "le32_to_cpu(tail_rec->r_clusters) - len"
          ],
          "line": 1950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "tail_rec",
            "orig_rec",
            "sizeof(struct ocfs2_refcount_rec)"
          ],
          "line": 1949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&rf_list->rl_recs[index + 1 + recs_need]",
            "&rf_list->rl_recs[index + 1]",
            "(le16_to_cpu(rf_list->rl_used) - index - 1) *\n\t\t\t sizeof(struct ocfs2_refcount_rec)"
          ],
          "line": 1932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "rf_list->rl_used"
          ],
          "line": 1934
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_rb",
          "args": [
            "handle",
            "ci",
            "ref_leaf_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 1919
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_rb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "722-727",
          "snippet": "int ocfs2_journal_access_rb(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &rb_triggers,\n\t\t\t\t      type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers rb_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_refcount_block, rf_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers rb_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_refcount_block, rf_check),\n};\n\nint ocfs2_journal_access_rb(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &rb_triggers,\n\t\t\t\t      type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_refcount_rec",
          "args": [
            "ci",
            "ref_root_bh",
            "cpos",
            "len",
            "&tmp_rec",
            "&index",
            "&new_bh"
          ],
          "line": 1905
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_get_refcount_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "1066-1150",
          "snippet": "static int ocfs2_get_refcount_rec(struct ocfs2_caching_info *ci,\n\t\t\t\t  struct buffer_head *ref_root_bh,\n\t\t\t\t  u64 cpos, unsigned int len,\n\t\t\t\t  struct ocfs2_refcount_rec *ret_rec,\n\t\t\t\t  int *index,\n\t\t\t\t  struct buffer_head **ret_bh)\n{\n\tint ret = 0, i, found;\n\tu32 low_cpos, uninitialized_var(cpos_end);\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec = NULL;\n\tstruct ocfs2_extent_block *eb = NULL;\n\tstruct buffer_head *eb_bh = NULL, *ref_leaf_bh = NULL;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\n\tstruct ocfs2_refcount_block *rb =\n\t\t\t(struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\n\tif (!(le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL)) {\n\t\tocfs2_find_refcount_rec_in_rl(ci, ref_root_bh, cpos, len,\n\t\t\t\t\t      ret_rec, index);\n\t\t*ret_bh = ref_root_bh;\n\t\tget_bh(ref_root_bh);\n\t\treturn 0;\n\t}\n\n\tel = &rb->rf_list;\n\tlow_cpos = cpos & OCFS2_32BIT_POS_MASK;\n\n\tif (el->l_tree_depth) {\n\t\tret = ocfs2_find_leaf(ci, el, low_cpos, &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tocfs2_error(sb,\n\t\t\t\"refcount tree %llu has non zero tree \"\n\t\t\t\"depth in leaf btree tree block %llu\\n\",\n\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t\t(unsigned long long)eb_bh->b_blocknr);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfound = 0;\n\tfor (i = le16_to_cpu(el->l_next_free_rec) - 1; i >= 0; i--) {\n\t\trec = &el->l_recs[i];\n\n\t\tif (le32_to_cpu(rec->e_cpos) <= low_cpos) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found) {\n\t\tret = ocfs2_get_refcount_cpos_end(ci, ref_root_bh,\n\t\t\t\t\t\t  eb, el, i, &cpos_end);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (cpos_end < low_cpos + len)\n\t\t\tlen = cpos_end - low_cpos;\n\t}\n\n\tret = ocfs2_read_refcount_block(ci, le64_to_cpu(rec->e_blkno),\n\t\t\t\t\t&ref_leaf_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_find_refcount_rec_in_rl(ci, ref_leaf_bh, cpos, len,\n\t\t\t\t      ret_rec, index);\n\t*ret_bh = ref_leaf_bh;\nout:\n\tbrelse(eb_bh);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_get_refcount_rec(struct ocfs2_caching_info *ci,\n\t\t\t\t  struct buffer_head *ref_root_bh,\n\t\t\t\t  u64 cpos, unsigned int len,\n\t\t\t\t  struct ocfs2_refcount_rec *ret_rec,\n\t\t\t\t  int *index,\n\t\t\t\t  struct buffer_head **ret_bh)\n{\n\tint ret = 0, i, found;\n\tu32 low_cpos, uninitialized_var(cpos_end);\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec = NULL;\n\tstruct ocfs2_extent_block *eb = NULL;\n\tstruct buffer_head *eb_bh = NULL, *ref_leaf_bh = NULL;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\n\tstruct ocfs2_refcount_block *rb =\n\t\t\t(struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\n\tif (!(le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL)) {\n\t\tocfs2_find_refcount_rec_in_rl(ci, ref_root_bh, cpos, len,\n\t\t\t\t\t      ret_rec, index);\n\t\t*ret_bh = ref_root_bh;\n\t\tget_bh(ref_root_bh);\n\t\treturn 0;\n\t}\n\n\tel = &rb->rf_list;\n\tlow_cpos = cpos & OCFS2_32BIT_POS_MASK;\n\n\tif (el->l_tree_depth) {\n\t\tret = ocfs2_find_leaf(ci, el, low_cpos, &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tocfs2_error(sb,\n\t\t\t\"refcount tree %llu has non zero tree \"\n\t\t\t\"depth in leaf btree tree block %llu\\n\",\n\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t\t(unsigned long long)eb_bh->b_blocknr);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfound = 0;\n\tfor (i = le16_to_cpu(el->l_next_free_rec) - 1; i >= 0; i--) {\n\t\trec = &el->l_recs[i];\n\n\t\tif (le32_to_cpu(rec->e_cpos) <= low_cpos) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found) {\n\t\tret = ocfs2_get_refcount_cpos_end(ci, ref_root_bh,\n\t\t\t\t\t\t  eb, el, i, &cpos_end);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (cpos_end < low_cpos + len)\n\t\t\tlen = cpos_end - low_cpos;\n\t}\n\n\tret = ocfs2_read_refcount_block(ci, le64_to_cpu(rec->e_blkno),\n\t\t\t\t\t&ref_leaf_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_find_refcount_rec_in_rl(ci, ref_leaf_bh, cpos, len,\n\t\t\t\t      ret_rec, index);\n\t*ret_bh = ref_leaf_bh;\nout:\n\tbrelse(eb_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_expand_refcount_tree",
          "args": [
            "handle",
            "ci",
            "ref_root_bh",
            "ref_leaf_bh",
            "meta_ac"
          ],
          "line": 1894
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_expand_refcount_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "1622-1656",
          "snippet": "static int ocfs2_expand_refcount_tree(handle_t *handle,\n\t\t\t\t      struct ocfs2_caching_info *ci,\n\t\t\t\t      struct buffer_head *ref_root_bh,\n\t\t\t\t      struct buffer_head *ref_leaf_bh,\n\t\t\t\t      struct ocfs2_alloc_context *meta_ac)\n{\n\tint ret;\n\tstruct buffer_head *expand_bh = NULL;\n\n\tif (ref_root_bh == ref_leaf_bh) {\n\t\t/*\n\t\t * the old root bh hasn't been expanded to a b-tree,\n\t\t * so expand it first.\n\t\t */\n\t\tret = ocfs2_expand_inline_ref_root(handle, ci, ref_root_bh,\n\t\t\t\t\t\t   &expand_bh, meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\texpand_bh = ref_leaf_bh;\n\t\tget_bh(expand_bh);\n\t}\n\n\n\t/* Now add a new refcount block into the tree.*/\n\tret = ocfs2_new_leaf_refcount_block(handle, ci, ref_root_bh,\n\t\t\t\t\t    expand_bh, meta_ac);\n\tif (ret)\n\t\tmlog_errno(ret);\nout:\n\tbrelse(expand_bh);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_expand_refcount_tree(handle_t *handle,\n\t\t\t\t      struct ocfs2_caching_info *ci,\n\t\t\t\t      struct buffer_head *ref_root_bh,\n\t\t\t\t      struct buffer_head *ref_leaf_bh,\n\t\t\t\t      struct ocfs2_alloc_context *meta_ac)\n{\n\tint ret;\n\tstruct buffer_head *expand_bh = NULL;\n\n\tif (ref_root_bh == ref_leaf_bh) {\n\t\t/*\n\t\t * the old root bh hasn't been expanded to a b-tree,\n\t\t * so expand it first.\n\t\t */\n\t\tret = ocfs2_expand_inline_ref_root(handle, ci, ref_root_bh,\n\t\t\t\t\t\t   &expand_bh, meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\texpand_bh = ref_leaf_bh;\n\t\tget_bh(expand_bh);\n\t}\n\n\n\t/* Now add a new refcount block into the tree.*/\n\tret = ocfs2_new_leaf_refcount_block(handle, ci, ref_root_bh,\n\t\t\t\t\t    expand_bh, meta_ac);\n\tif (ret)\n\t\tmlog_errno(ret);\nout:\n\tbrelse(expand_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_split_refcount_rec",
          "args": [
            "le64_to_cpu(orig_rec->r_cpos)",
            "le32_to_cpu(orig_rec->r_clusters)",
            "le32_to_cpu(orig_rec->r_refcount)",
            "le64_to_cpu(split_rec->r_cpos)",
            "le32_to_cpu(split_rec->r_clusters)",
            "le32_to_cpu(split_rec->r_refcount)"
          ],
          "line": 1856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL"
          ],
          "line": 1854
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_split_refcount_rec(handle_t *handle,\n\t\t\t\t    struct ocfs2_caching_info *ci,\n\t\t\t\t    struct buffer_head *ref_root_bh,\n\t\t\t\t    struct buffer_head *ref_leaf_bh,\n\t\t\t\t    struct ocfs2_refcount_rec *split_rec,\n\t\t\t\t    int index, int merge,\n\t\t\t\t    struct ocfs2_alloc_context *meta_ac,\n\t\t\t\t    struct ocfs2_cached_dealloc_ctxt *dealloc)\n{\n\tint ret, recs_need;\n\tu32 len;\n\tstruct ocfs2_refcount_block *rb =\n\t\t\t(struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\n\tstruct ocfs2_refcount_list *rf_list = &rb->rf_records;\n\tstruct ocfs2_refcount_rec *orig_rec = &rf_list->rl_recs[index];\n\tstruct ocfs2_refcount_rec *tail_rec = NULL;\n\tstruct buffer_head *new_bh = NULL;\n\n\tBUG_ON(le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL);\n\n\ttrace_ocfs2_split_refcount_rec(le64_to_cpu(orig_rec->r_cpos),\n\t\tle32_to_cpu(orig_rec->r_clusters),\n\t\tle32_to_cpu(orig_rec->r_refcount),\n\t\tle64_to_cpu(split_rec->r_cpos),\n\t\tle32_to_cpu(split_rec->r_clusters),\n\t\tle32_to_cpu(split_rec->r_refcount));\n\n\t/*\n\t * If we just need to split the header or tail clusters,\n\t * no more recs are needed, just split is OK.\n\t * Otherwise we at least need one new recs.\n\t */\n\tif (!split_rec->r_refcount &&\n\t    (split_rec->r_cpos == orig_rec->r_cpos ||\n\t     le64_to_cpu(split_rec->r_cpos) +\n\t     le32_to_cpu(split_rec->r_clusters) ==\n\t     le64_to_cpu(orig_rec->r_cpos) + le32_to_cpu(orig_rec->r_clusters)))\n\t\trecs_need = 0;\n\telse\n\t\trecs_need = 1;\n\n\t/*\n\t * We need one more rec if we split in the middle and the new rec have\n\t * some refcount in it.\n\t */\n\tif (split_rec->r_refcount &&\n\t    (split_rec->r_cpos != orig_rec->r_cpos &&\n\t     le64_to_cpu(split_rec->r_cpos) +\n\t     le32_to_cpu(split_rec->r_clusters) !=\n\t     le64_to_cpu(orig_rec->r_cpos) + le32_to_cpu(orig_rec->r_clusters)))\n\t\trecs_need++;\n\n\t/* If the leaf block don't have enough record, expand it. */\n\tif (le16_to_cpu(rf_list->rl_used) + recs_need >\n\t\t\t\t\t le16_to_cpu(rf_list->rl_count)) {\n\t\tstruct ocfs2_refcount_rec tmp_rec;\n\t\tu64 cpos = le64_to_cpu(orig_rec->r_cpos);\n\t\tlen = le32_to_cpu(orig_rec->r_clusters);\n\t\tret = ocfs2_expand_refcount_tree(handle, ci, ref_root_bh,\n\t\t\t\t\t\t ref_leaf_bh, meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * We have to re-get it since now cpos may be moved to\n\t\t * another leaf block.\n\t\t */\n\t\tret = ocfs2_get_refcount_rec(ci, ref_root_bh,\n\t\t\t\t\t     cpos, len, &tmp_rec, &index,\n\t\t\t\t\t     &new_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tref_leaf_bh = new_bh;\n\t\trb = (struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\n\t\trf_list = &rb->rf_records;\n\t\torig_rec = &rf_list->rl_recs[index];\n\t}\n\n\tret = ocfs2_journal_access_rb(handle, ci, ref_leaf_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * We have calculated out how many new records we need and store\n\t * in recs_need, so spare enough space first by moving the records\n\t * after \"index\" to the end.\n\t */\n\tif (index != le16_to_cpu(rf_list->rl_used) - 1)\n\t\tmemmove(&rf_list->rl_recs[index + 1 + recs_need],\n\t\t\t&rf_list->rl_recs[index + 1],\n\t\t\t(le16_to_cpu(rf_list->rl_used) - index - 1) *\n\t\t\t sizeof(struct ocfs2_refcount_rec));\n\n\tlen = (le64_to_cpu(orig_rec->r_cpos) +\n\t      le32_to_cpu(orig_rec->r_clusters)) -\n\t      (le64_to_cpu(split_rec->r_cpos) +\n\t      le32_to_cpu(split_rec->r_clusters));\n\n\t/*\n\t * If we have \"len\", the we will split in the tail and move it\n\t * to the end of the space we have just spared.\n\t */\n\tif (len) {\n\t\ttail_rec = &rf_list->rl_recs[index + recs_need];\n\n\t\tmemcpy(tail_rec, orig_rec, sizeof(struct ocfs2_refcount_rec));\n\t\tle64_add_cpu(&tail_rec->r_cpos,\n\t\t\t     le32_to_cpu(tail_rec->r_clusters) - len);\n\t\ttail_rec->r_clusters = cpu_to_le32(len);\n\t}\n\n\t/*\n\t * If the split pos isn't the same as the original one, we need to\n\t * split in the head.\n\t *\n\t * Note: We have the chance that split_rec.r_refcount = 0,\n\t * recs_need = 0 and len > 0, which means we just cut the head from\n\t * the orig_rec and in that case we have done some modification in\n\t * orig_rec above, so the check for r_cpos is faked.\n\t */\n\tif (split_rec->r_cpos != orig_rec->r_cpos && tail_rec != orig_rec) {\n\t\tlen = le64_to_cpu(split_rec->r_cpos) -\n\t\t      le64_to_cpu(orig_rec->r_cpos);\n\t\torig_rec->r_clusters = cpu_to_le32(len);\n\t\tindex++;\n\t}\n\n\tle16_add_cpu(&rf_list->rl_used, recs_need);\n\n\tif (split_rec->r_refcount) {\n\t\trf_list->rl_recs[index] = *split_rec;\n\t\ttrace_ocfs2_split_refcount_rec_insert(\n\t\t\t(unsigned long long)ref_leaf_bh->b_blocknr, index,\n\t\t\t(unsigned long long)le64_to_cpu(split_rec->r_cpos),\n\t\t\tle32_to_cpu(split_rec->r_clusters),\n\t\t\tle32_to_cpu(split_rec->r_refcount));\n\n\t\tif (merge)\n\t\t\tocfs2_refcount_rec_merge(rb, index);\n\t}\n\n\tocfs2_journal_dirty(handle, ref_leaf_bh);\n\nout:\n\tbrelse(new_bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_insert_refcount_rec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "1748-1825",
    "snippet": "static int ocfs2_insert_refcount_rec(handle_t *handle,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *ref_root_bh,\n\t\t\t\t     struct buffer_head *ref_leaf_bh,\n\t\t\t\t     struct ocfs2_refcount_rec *rec,\n\t\t\t\t     int index, int merge,\n\t\t\t\t     struct ocfs2_alloc_context *meta_ac)\n{\n\tint ret;\n\tstruct ocfs2_refcount_block *rb =\n\t\t\t(struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\n\tstruct ocfs2_refcount_list *rf_list = &rb->rf_records;\n\tstruct buffer_head *new_bh = NULL;\n\n\tBUG_ON(le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL);\n\n\tif (rf_list->rl_used == rf_list->rl_count) {\n\t\tu64 cpos = le64_to_cpu(rec->r_cpos);\n\t\tu32 len = le32_to_cpu(rec->r_clusters);\n\n\t\tret = ocfs2_expand_refcount_tree(handle, ci, ref_root_bh,\n\t\t\t\t\t\t ref_leaf_bh, meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_get_refcount_rec(ci, ref_root_bh,\n\t\t\t\t\t     cpos, len, NULL, &index,\n\t\t\t\t\t     &new_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tref_leaf_bh = new_bh;\n\t\trb = (struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\n\t\trf_list = &rb->rf_records;\n\t}\n\n\tret = ocfs2_journal_access_rb(handle, ci, ref_leaf_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (index < le16_to_cpu(rf_list->rl_used))\n\t\tmemmove(&rf_list->rl_recs[index + 1],\n\t\t\t&rf_list->rl_recs[index],\n\t\t\t(le16_to_cpu(rf_list->rl_used) - index) *\n\t\t\t sizeof(struct ocfs2_refcount_rec));\n\n\ttrace_ocfs2_insert_refcount_rec(\n\t\t(unsigned long long)ref_leaf_bh->b_blocknr, index,\n\t\t(unsigned long long)le64_to_cpu(rec->r_cpos),\n\t\tle32_to_cpu(rec->r_clusters), le32_to_cpu(rec->r_refcount));\n\n\trf_list->rl_recs[index] = *rec;\n\n\tle16_add_cpu(&rf_list->rl_used, 1);\n\n\tif (merge)\n\t\tocfs2_refcount_rec_merge(rb, index);\n\n\tocfs2_journal_dirty(handle, ref_leaf_bh);\n\n\tif (index == 0) {\n\t\tret = ocfs2_adjust_refcount_rec(handle, ci,\n\t\t\t\t\t\tref_root_bh,\n\t\t\t\t\t\tref_leaf_bh, rec);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\nout:\n\tbrelse(new_bh);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "new_bh"
          ],
          "line": 1823
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_adjust_refcount_rec",
          "args": [
            "handle",
            "ci",
            "ref_root_bh",
            "ref_leaf_bh",
            "rec"
          ],
          "line": 1816
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_adjust_refcount_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "1664-1746",
          "snippet": "static int ocfs2_adjust_refcount_rec(handle_t *handle,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *ref_root_bh,\n\t\t\t\t     struct buffer_head *ref_leaf_bh,\n\t\t\t\t     struct ocfs2_refcount_rec *rec)\n{\n\tint ret = 0, i;\n\tu32 new_cpos, old_cpos;\n\tstruct ocfs2_path *path = NULL;\n\tstruct ocfs2_extent_tree et;\n\tstruct ocfs2_refcount_block *rb =\n\t\t(struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\tstruct ocfs2_extent_list *el;\n\n\tif (!(le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL))\n\t\tgoto out;\n\n\trb = (struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\n\told_cpos = le32_to_cpu(rb->rf_cpos);\n\tnew_cpos = le64_to_cpu(rec->r_cpos) & OCFS2_32BIT_POS_MASK;\n\tif (old_cpos <= new_cpos)\n\t\tgoto out;\n\n\tocfs2_init_refcount_extent_tree(&et, ci, ref_root_bh);\n\n\tpath = ocfs2_new_path_from_et(&et);\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_path(ci, path, old_cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * 2 more credits, one for the leaf refcount block, one for\n\t * the extent block contains the extent rec.\n\t */\n\tret = ocfs2_extend_trans(handle, 2);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_rb(handle, ci, ref_leaf_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_eb(handle, ci, path_leaf_bh(path),\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* change the leaf extent block first. */\n\tel = path_leaf_el(path);\n\n\tfor (i = 0; i < le16_to_cpu(el->l_next_free_rec); i++)\n\t\tif (le32_to_cpu(el->l_recs[i].e_cpos) == old_cpos)\n\t\t\tbreak;\n\n\tBUG_ON(i == le16_to_cpu(el->l_next_free_rec));\n\n\tel->l_recs[i].e_cpos = cpu_to_le32(new_cpos);\n\n\t/* change the r_cpos in the leaf block. */\n\trb->rf_cpos = cpu_to_le32(new_cpos);\n\n\tocfs2_journal_dirty(handle, path_leaf_bh(path));\n\tocfs2_journal_dirty(handle, ref_leaf_bh);\n\nout:\n\tocfs2_free_path(path);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_adjust_refcount_rec(handle_t *handle,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *ref_root_bh,\n\t\t\t\t     struct buffer_head *ref_leaf_bh,\n\t\t\t\t     struct ocfs2_refcount_rec *rec)\n{\n\tint ret = 0, i;\n\tu32 new_cpos, old_cpos;\n\tstruct ocfs2_path *path = NULL;\n\tstruct ocfs2_extent_tree et;\n\tstruct ocfs2_refcount_block *rb =\n\t\t(struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\tstruct ocfs2_extent_list *el;\n\n\tif (!(le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL))\n\t\tgoto out;\n\n\trb = (struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\n\told_cpos = le32_to_cpu(rb->rf_cpos);\n\tnew_cpos = le64_to_cpu(rec->r_cpos) & OCFS2_32BIT_POS_MASK;\n\tif (old_cpos <= new_cpos)\n\t\tgoto out;\n\n\tocfs2_init_refcount_extent_tree(&et, ci, ref_root_bh);\n\n\tpath = ocfs2_new_path_from_et(&et);\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_path(ci, path, old_cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * 2 more credits, one for the leaf refcount block, one for\n\t * the extent block contains the extent rec.\n\t */\n\tret = ocfs2_extend_trans(handle, 2);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_rb(handle, ci, ref_leaf_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_eb(handle, ci, path_leaf_bh(path),\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* change the leaf extent block first. */\n\tel = path_leaf_el(path);\n\n\tfor (i = 0; i < le16_to_cpu(el->l_next_free_rec); i++)\n\t\tif (le32_to_cpu(el->l_recs[i].e_cpos) == old_cpos)\n\t\t\tbreak;\n\n\tBUG_ON(i == le16_to_cpu(el->l_next_free_rec));\n\n\tel->l_recs[i].e_cpos = cpu_to_le32(new_cpos);\n\n\t/* change the r_cpos in the leaf block. */\n\trb->rf_cpos = cpu_to_le32(new_cpos);\n\n\tocfs2_journal_dirty(handle, path_leaf_bh(path));\n\tocfs2_journal_dirty(handle, ref_leaf_bh);\n\nout:\n\tocfs2_free_path(path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "ref_leaf_bh"
          ],
          "line": 1813
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_refcount_rec_merge",
          "args": [
            "rb",
            "index"
          ],
          "line": 1811
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_refcount_rec_merge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "1221-1239",
          "snippet": "static void ocfs2_refcount_rec_merge(struct ocfs2_refcount_block *rb,\n\t\t\t\t     int index)\n{\n\tenum ocfs2_ref_rec_contig contig =\n\t\t\t\tocfs2_refcount_rec_contig(rb, index);\n\n\tif (contig == REF_CONTIG_NONE)\n\t\treturn;\n\n\tif (contig == REF_CONTIG_LEFT || contig == REF_CONTIG_LEFTRIGHT) {\n\t\tBUG_ON(index == 0);\n\t\tindex--;\n\t}\n\n\tocfs2_rotate_refcount_rec_left(rb, index);\n\n\tif (contig == REF_CONTIG_LEFTRIGHT)\n\t\tocfs2_rotate_refcount_rec_left(rb, index);\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic void ocfs2_refcount_rec_merge(struct ocfs2_refcount_block *rb,\n\t\t\t\t     int index)\n{\n\tenum ocfs2_ref_rec_contig contig =\n\t\t\t\tocfs2_refcount_rec_contig(rb, index);\n\n\tif (contig == REF_CONTIG_NONE)\n\t\treturn;\n\n\tif (contig == REF_CONTIG_LEFT || contig == REF_CONTIG_LEFTRIGHT) {\n\t\tBUG_ON(index == 0);\n\t\tindex--;\n\t}\n\n\tocfs2_rotate_refcount_rec_left(rb, index);\n\n\tif (contig == REF_CONTIG_LEFTRIGHT)\n\t\tocfs2_rotate_refcount_rec_left(rb, index);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&rf_list->rl_used",
            "1"
          ],
          "line": 1808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_insert_refcount_rec",
          "args": [
            "(unsigned long long)ref_leaf_bh->b_blocknr",
            "index",
            "(unsigned long long)le64_to_cpu(rec->r_cpos)",
            "le32_to_cpu(rec->r_clusters)",
            "le32_to_cpu(rec->r_refcount)"
          ],
          "line": 1801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rec->r_refcount"
          ],
          "line": 1804
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "rec->r_cpos"
          ],
          "line": 1803
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&rf_list->rl_recs[index + 1]",
            "&rf_list->rl_recs[index]",
            "(le16_to_cpu(rf_list->rl_used) - index) *\n\t\t\t sizeof(struct ocfs2_refcount_rec)"
          ],
          "line": 1796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "rf_list->rl_used"
          ],
          "line": 1798
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_rb",
          "args": [
            "handle",
            "ci",
            "ref_leaf_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 1788
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_rb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "722-727",
          "snippet": "int ocfs2_journal_access_rb(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &rb_triggers,\n\t\t\t\t      type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers rb_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_refcount_block, rf_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers rb_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_refcount_block, rf_check),\n};\n\nint ocfs2_journal_access_rb(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &rb_triggers,\n\t\t\t\t      type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_refcount_rec",
          "args": [
            "ci",
            "ref_root_bh",
            "cpos",
            "len",
            "NULL",
            "&index",
            "&new_bh"
          ],
          "line": 1775
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_get_refcount_rec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "1066-1150",
          "snippet": "static int ocfs2_get_refcount_rec(struct ocfs2_caching_info *ci,\n\t\t\t\t  struct buffer_head *ref_root_bh,\n\t\t\t\t  u64 cpos, unsigned int len,\n\t\t\t\t  struct ocfs2_refcount_rec *ret_rec,\n\t\t\t\t  int *index,\n\t\t\t\t  struct buffer_head **ret_bh)\n{\n\tint ret = 0, i, found;\n\tu32 low_cpos, uninitialized_var(cpos_end);\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec = NULL;\n\tstruct ocfs2_extent_block *eb = NULL;\n\tstruct buffer_head *eb_bh = NULL, *ref_leaf_bh = NULL;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\n\tstruct ocfs2_refcount_block *rb =\n\t\t\t(struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\n\tif (!(le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL)) {\n\t\tocfs2_find_refcount_rec_in_rl(ci, ref_root_bh, cpos, len,\n\t\t\t\t\t      ret_rec, index);\n\t\t*ret_bh = ref_root_bh;\n\t\tget_bh(ref_root_bh);\n\t\treturn 0;\n\t}\n\n\tel = &rb->rf_list;\n\tlow_cpos = cpos & OCFS2_32BIT_POS_MASK;\n\n\tif (el->l_tree_depth) {\n\t\tret = ocfs2_find_leaf(ci, el, low_cpos, &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tocfs2_error(sb,\n\t\t\t\"refcount tree %llu has non zero tree \"\n\t\t\t\"depth in leaf btree tree block %llu\\n\",\n\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t\t(unsigned long long)eb_bh->b_blocknr);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfound = 0;\n\tfor (i = le16_to_cpu(el->l_next_free_rec) - 1; i >= 0; i--) {\n\t\trec = &el->l_recs[i];\n\n\t\tif (le32_to_cpu(rec->e_cpos) <= low_cpos) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found) {\n\t\tret = ocfs2_get_refcount_cpos_end(ci, ref_root_bh,\n\t\t\t\t\t\t  eb, el, i, &cpos_end);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (cpos_end < low_cpos + len)\n\t\t\tlen = cpos_end - low_cpos;\n\t}\n\n\tret = ocfs2_read_refcount_block(ci, le64_to_cpu(rec->e_blkno),\n\t\t\t\t\t&ref_leaf_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_find_refcount_rec_in_rl(ci, ref_leaf_bh, cpos, len,\n\t\t\t\t      ret_rec, index);\n\t*ret_bh = ref_leaf_bh;\nout:\n\tbrelse(eb_bh);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_get_refcount_rec(struct ocfs2_caching_info *ci,\n\t\t\t\t  struct buffer_head *ref_root_bh,\n\t\t\t\t  u64 cpos, unsigned int len,\n\t\t\t\t  struct ocfs2_refcount_rec *ret_rec,\n\t\t\t\t  int *index,\n\t\t\t\t  struct buffer_head **ret_bh)\n{\n\tint ret = 0, i, found;\n\tu32 low_cpos, uninitialized_var(cpos_end);\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec = NULL;\n\tstruct ocfs2_extent_block *eb = NULL;\n\tstruct buffer_head *eb_bh = NULL, *ref_leaf_bh = NULL;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\n\tstruct ocfs2_refcount_block *rb =\n\t\t\t(struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\n\tif (!(le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL)) {\n\t\tocfs2_find_refcount_rec_in_rl(ci, ref_root_bh, cpos, len,\n\t\t\t\t\t      ret_rec, index);\n\t\t*ret_bh = ref_root_bh;\n\t\tget_bh(ref_root_bh);\n\t\treturn 0;\n\t}\n\n\tel = &rb->rf_list;\n\tlow_cpos = cpos & OCFS2_32BIT_POS_MASK;\n\n\tif (el->l_tree_depth) {\n\t\tret = ocfs2_find_leaf(ci, el, low_cpos, &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tocfs2_error(sb,\n\t\t\t\"refcount tree %llu has non zero tree \"\n\t\t\t\"depth in leaf btree tree block %llu\\n\",\n\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t\t(unsigned long long)eb_bh->b_blocknr);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfound = 0;\n\tfor (i = le16_to_cpu(el->l_next_free_rec) - 1; i >= 0; i--) {\n\t\trec = &el->l_recs[i];\n\n\t\tif (le32_to_cpu(rec->e_cpos) <= low_cpos) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found) {\n\t\tret = ocfs2_get_refcount_cpos_end(ci, ref_root_bh,\n\t\t\t\t\t\t  eb, el, i, &cpos_end);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (cpos_end < low_cpos + len)\n\t\t\tlen = cpos_end - low_cpos;\n\t}\n\n\tret = ocfs2_read_refcount_block(ci, le64_to_cpu(rec->e_blkno),\n\t\t\t\t\t&ref_leaf_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_find_refcount_rec_in_rl(ci, ref_leaf_bh, cpos, len,\n\t\t\t\t      ret_rec, index);\n\t*ret_bh = ref_leaf_bh;\nout:\n\tbrelse(eb_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_expand_refcount_tree",
          "args": [
            "handle",
            "ci",
            "ref_root_bh",
            "ref_leaf_bh",
            "meta_ac"
          ],
          "line": 1768
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_expand_refcount_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "1622-1656",
          "snippet": "static int ocfs2_expand_refcount_tree(handle_t *handle,\n\t\t\t\t      struct ocfs2_caching_info *ci,\n\t\t\t\t      struct buffer_head *ref_root_bh,\n\t\t\t\t      struct buffer_head *ref_leaf_bh,\n\t\t\t\t      struct ocfs2_alloc_context *meta_ac)\n{\n\tint ret;\n\tstruct buffer_head *expand_bh = NULL;\n\n\tif (ref_root_bh == ref_leaf_bh) {\n\t\t/*\n\t\t * the old root bh hasn't been expanded to a b-tree,\n\t\t * so expand it first.\n\t\t */\n\t\tret = ocfs2_expand_inline_ref_root(handle, ci, ref_root_bh,\n\t\t\t\t\t\t   &expand_bh, meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\texpand_bh = ref_leaf_bh;\n\t\tget_bh(expand_bh);\n\t}\n\n\n\t/* Now add a new refcount block into the tree.*/\n\tret = ocfs2_new_leaf_refcount_block(handle, ci, ref_root_bh,\n\t\t\t\t\t    expand_bh, meta_ac);\n\tif (ret)\n\t\tmlog_errno(ret);\nout:\n\tbrelse(expand_bh);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_expand_refcount_tree(handle_t *handle,\n\t\t\t\t      struct ocfs2_caching_info *ci,\n\t\t\t\t      struct buffer_head *ref_root_bh,\n\t\t\t\t      struct buffer_head *ref_leaf_bh,\n\t\t\t\t      struct ocfs2_alloc_context *meta_ac)\n{\n\tint ret;\n\tstruct buffer_head *expand_bh = NULL;\n\n\tif (ref_root_bh == ref_leaf_bh) {\n\t\t/*\n\t\t * the old root bh hasn't been expanded to a b-tree,\n\t\t * so expand it first.\n\t\t */\n\t\tret = ocfs2_expand_inline_ref_root(handle, ci, ref_root_bh,\n\t\t\t\t\t\t   &expand_bh, meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\texpand_bh = ref_leaf_bh;\n\t\tget_bh(expand_bh);\n\t}\n\n\n\t/* Now add a new refcount block into the tree.*/\n\tret = ocfs2_new_leaf_refcount_block(handle, ci, ref_root_bh,\n\t\t\t\t\t    expand_bh, meta_ac);\n\tif (ret)\n\t\tmlog_errno(ret);\nout:\n\tbrelse(expand_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL"
          ],
          "line": 1762
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_insert_refcount_rec(handle_t *handle,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *ref_root_bh,\n\t\t\t\t     struct buffer_head *ref_leaf_bh,\n\t\t\t\t     struct ocfs2_refcount_rec *rec,\n\t\t\t\t     int index, int merge,\n\t\t\t\t     struct ocfs2_alloc_context *meta_ac)\n{\n\tint ret;\n\tstruct ocfs2_refcount_block *rb =\n\t\t\t(struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\n\tstruct ocfs2_refcount_list *rf_list = &rb->rf_records;\n\tstruct buffer_head *new_bh = NULL;\n\n\tBUG_ON(le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL);\n\n\tif (rf_list->rl_used == rf_list->rl_count) {\n\t\tu64 cpos = le64_to_cpu(rec->r_cpos);\n\t\tu32 len = le32_to_cpu(rec->r_clusters);\n\n\t\tret = ocfs2_expand_refcount_tree(handle, ci, ref_root_bh,\n\t\t\t\t\t\t ref_leaf_bh, meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ocfs2_get_refcount_rec(ci, ref_root_bh,\n\t\t\t\t\t     cpos, len, NULL, &index,\n\t\t\t\t\t     &new_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tref_leaf_bh = new_bh;\n\t\trb = (struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\n\t\trf_list = &rb->rf_records;\n\t}\n\n\tret = ocfs2_journal_access_rb(handle, ci, ref_leaf_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (index < le16_to_cpu(rf_list->rl_used))\n\t\tmemmove(&rf_list->rl_recs[index + 1],\n\t\t\t&rf_list->rl_recs[index],\n\t\t\t(le16_to_cpu(rf_list->rl_used) - index) *\n\t\t\t sizeof(struct ocfs2_refcount_rec));\n\n\ttrace_ocfs2_insert_refcount_rec(\n\t\t(unsigned long long)ref_leaf_bh->b_blocknr, index,\n\t\t(unsigned long long)le64_to_cpu(rec->r_cpos),\n\t\tle32_to_cpu(rec->r_clusters), le32_to_cpu(rec->r_refcount));\n\n\trf_list->rl_recs[index] = *rec;\n\n\tle16_add_cpu(&rf_list->rl_used, 1);\n\n\tif (merge)\n\t\tocfs2_refcount_rec_merge(rb, index);\n\n\tocfs2_journal_dirty(handle, ref_leaf_bh);\n\n\tif (index == 0) {\n\t\tret = ocfs2_adjust_refcount_rec(handle, ci,\n\t\t\t\t\t\tref_root_bh,\n\t\t\t\t\t\tref_leaf_bh, rec);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\nout:\n\tbrelse(new_bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_adjust_refcount_rec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "1664-1746",
    "snippet": "static int ocfs2_adjust_refcount_rec(handle_t *handle,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *ref_root_bh,\n\t\t\t\t     struct buffer_head *ref_leaf_bh,\n\t\t\t\t     struct ocfs2_refcount_rec *rec)\n{\n\tint ret = 0, i;\n\tu32 new_cpos, old_cpos;\n\tstruct ocfs2_path *path = NULL;\n\tstruct ocfs2_extent_tree et;\n\tstruct ocfs2_refcount_block *rb =\n\t\t(struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\tstruct ocfs2_extent_list *el;\n\n\tif (!(le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL))\n\t\tgoto out;\n\n\trb = (struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\n\told_cpos = le32_to_cpu(rb->rf_cpos);\n\tnew_cpos = le64_to_cpu(rec->r_cpos) & OCFS2_32BIT_POS_MASK;\n\tif (old_cpos <= new_cpos)\n\t\tgoto out;\n\n\tocfs2_init_refcount_extent_tree(&et, ci, ref_root_bh);\n\n\tpath = ocfs2_new_path_from_et(&et);\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_path(ci, path, old_cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * 2 more credits, one for the leaf refcount block, one for\n\t * the extent block contains the extent rec.\n\t */\n\tret = ocfs2_extend_trans(handle, 2);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_rb(handle, ci, ref_leaf_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_eb(handle, ci, path_leaf_bh(path),\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* change the leaf extent block first. */\n\tel = path_leaf_el(path);\n\n\tfor (i = 0; i < le16_to_cpu(el->l_next_free_rec); i++)\n\t\tif (le32_to_cpu(el->l_recs[i].e_cpos) == old_cpos)\n\t\t\tbreak;\n\n\tBUG_ON(i == le16_to_cpu(el->l_next_free_rec));\n\n\tel->l_recs[i].e_cpos = cpu_to_le32(new_cpos);\n\n\t/* change the r_cpos in the leaf block. */\n\trb->rf_cpos = cpu_to_le32(new_cpos);\n\n\tocfs2_journal_dirty(handle, path_leaf_bh(path));\n\tocfs2_journal_dirty(handle, ref_leaf_bh);\n\nout:\n\tocfs2_free_path(path);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_free_path",
          "args": [
            "path"
          ],
          "line": 1744
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "609-615",
          "snippet": "void ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "ref_leaf_bh"
          ],
          "line": 1741
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_bh",
          "args": [
            "path"
          ],
          "line": 1740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "new_cpos"
          ],
          "line": 1738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "new_cpos"
          ],
          "line": 1735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "i == le16_to_cpu(el->l_next_free_rec)"
          ],
          "line": 1733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "el->l_next_free_rec"
          ],
          "line": 1733
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "el->l_recs[i].e_cpos"
          ],
          "line": 1730
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_el",
          "args": [
            "path"
          ],
          "line": 1727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_eb",
          "args": [
            "handle",
            "ci",
            "path_leaf_bh(path)",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 1719
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_eb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "716-720",
          "snippet": "int ocfs2_journal_access_eb(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &eb_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers eb_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_extent_block, h_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers eb_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_extent_block, h_check),\n};\n\nint ocfs2_journal_access_eb(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &eb_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_leaf_bh",
          "args": [
            "path"
          ],
          "line": 1719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_rb",
          "args": [
            "handle",
            "ci",
            "ref_leaf_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 1712
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_rb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "722-727",
          "snippet": "int ocfs2_journal_access_rb(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &rb_triggers,\n\t\t\t\t      type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers rb_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_refcount_block, rf_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers rb_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_refcount_block, rf_check),\n};\n\nint ocfs2_journal_access_rb(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &rb_triggers,\n\t\t\t\t      type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_extend_trans",
          "args": [
            "handle",
            "2"
          ],
          "line": 1706
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extend_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "426-463",
          "snippet": "int ocfs2_extend_trans(handle_t *handle, int nblocks)\n{\n\tint status, old_nblocks;\n\n\tBUG_ON(!handle);\n\tBUG_ON(nblocks < 0);\n\n\tif (!nblocks)\n\t\treturn 0;\n\n\told_nblocks = handle->h_buffer_credits;\n\n\ttrace_ocfs2_extend_trans(old_nblocks, nblocks);\n\n#ifdef CONFIG_OCFS2_DEBUG_FS\n\tstatus = 1;\n#else\n\tstatus = jbd2_journal_extend(handle, nblocks);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n#endif\n\n\tif (status > 0) {\n\t\ttrace_ocfs2_extend_trans_restart(old_nblocks + nblocks);\n\t\tstatus = jbd2_journal_restart(handle,\n\t\t\t\t\t      old_nblocks + nblocks);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = 0;\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_extend_trans(handle_t *handle, int nblocks)\n{\n\tint status, old_nblocks;\n\n\tBUG_ON(!handle);\n\tBUG_ON(nblocks < 0);\n\n\tif (!nblocks)\n\t\treturn 0;\n\n\told_nblocks = handle->h_buffer_credits;\n\n\ttrace_ocfs2_extend_trans(old_nblocks, nblocks);\n\n#ifdef CONFIG_OCFS2_DEBUG_FS\n\tstatus = 1;\n#else\n\tstatus = jbd2_journal_extend(handle, nblocks);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n#endif\n\n\tif (status > 0) {\n\t\ttrace_ocfs2_extend_trans_restart(old_nblocks + nblocks);\n\t\tstatus = jbd2_journal_restart(handle,\n\t\t\t\t\t      old_nblocks + nblocks);\n\t\tif (status < 0) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tstatus = 0;\nbail:\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_path",
          "args": [
            "ci",
            "path",
            "old_cpos"
          ],
          "line": 1696
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "1885-1894",
          "snippet": "int ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_new_path_from_et",
          "args": [
            "&et"
          ],
          "line": 1689
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_new_path_from_et",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "713-717",
          "snippet": "struct ocfs2_path *ocfs2_new_path_from_et(struct ocfs2_extent_tree *et)\n{\n\treturn ocfs2_new_path(et->et_root_bh, et->et_root_el,\n\t\t\t      et->et_root_journal_access);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstruct ocfs2_path *ocfs2_new_path_from_et(struct ocfs2_extent_tree *et)\n{\n\treturn ocfs2_new_path(et->et_root_bh, et->et_root_el,\n\t\t\t      et->et_root_journal_access);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_init_refcount_extent_tree",
          "args": [
            "&et",
            "ci",
            "ref_root_bh"
          ],
          "line": 1687
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_refcount_extent_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "490-496",
          "snippet": "void ocfs2_init_refcount_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_rb,\n\t\t\t\t NULL, &ocfs2_refcount_tree_et_ops);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static struct ocfs2_extent_tree_operations ocfs2_refcount_tree_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_refcount_tree_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_refcount_tree_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_refcount_tree_update_clusters,\n\t.eo_fill_root_el\t= ocfs2_refcount_tree_fill_root_el,\n\t.eo_extent_contig\t= ocfs2_refcount_tree_extent_contig,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic struct ocfs2_extent_tree_operations ocfs2_refcount_tree_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_refcount_tree_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_refcount_tree_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_refcount_tree_update_clusters,\n\t.eo_fill_root_el\t= ocfs2_refcount_tree_fill_root_el,\n\t.eo_extent_contig\t= ocfs2_refcount_tree_extent_contig,\n};\n\nvoid ocfs2_init_refcount_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_rb,\n\t\t\t\t NULL, &ocfs2_refcount_tree_et_ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "rec->r_cpos"
          ],
          "line": 1683
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_adjust_refcount_rec(handle_t *handle,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *ref_root_bh,\n\t\t\t\t     struct buffer_head *ref_leaf_bh,\n\t\t\t\t     struct ocfs2_refcount_rec *rec)\n{\n\tint ret = 0, i;\n\tu32 new_cpos, old_cpos;\n\tstruct ocfs2_path *path = NULL;\n\tstruct ocfs2_extent_tree et;\n\tstruct ocfs2_refcount_block *rb =\n\t\t(struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\tstruct ocfs2_extent_list *el;\n\n\tif (!(le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL))\n\t\tgoto out;\n\n\trb = (struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\n\told_cpos = le32_to_cpu(rb->rf_cpos);\n\tnew_cpos = le64_to_cpu(rec->r_cpos) & OCFS2_32BIT_POS_MASK;\n\tif (old_cpos <= new_cpos)\n\t\tgoto out;\n\n\tocfs2_init_refcount_extent_tree(&et, ci, ref_root_bh);\n\n\tpath = ocfs2_new_path_from_et(&et);\n\tif (!path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_path(ci, path, old_cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * 2 more credits, one for the leaf refcount block, one for\n\t * the extent block contains the extent rec.\n\t */\n\tret = ocfs2_extend_trans(handle, 2);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_rb(handle, ci, ref_leaf_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_eb(handle, ci, path_leaf_bh(path),\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* change the leaf extent block first. */\n\tel = path_leaf_el(path);\n\n\tfor (i = 0; i < le16_to_cpu(el->l_next_free_rec); i++)\n\t\tif (le32_to_cpu(el->l_recs[i].e_cpos) == old_cpos)\n\t\t\tbreak;\n\n\tBUG_ON(i == le16_to_cpu(el->l_next_free_rec));\n\n\tel->l_recs[i].e_cpos = cpu_to_le32(new_cpos);\n\n\t/* change the r_cpos in the leaf block. */\n\trb->rf_cpos = cpu_to_le32(new_cpos);\n\n\tocfs2_journal_dirty(handle, path_leaf_bh(path));\n\tocfs2_journal_dirty(handle, ref_leaf_bh);\n\nout:\n\tocfs2_free_path(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_expand_refcount_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "1622-1656",
    "snippet": "static int ocfs2_expand_refcount_tree(handle_t *handle,\n\t\t\t\t      struct ocfs2_caching_info *ci,\n\t\t\t\t      struct buffer_head *ref_root_bh,\n\t\t\t\t      struct buffer_head *ref_leaf_bh,\n\t\t\t\t      struct ocfs2_alloc_context *meta_ac)\n{\n\tint ret;\n\tstruct buffer_head *expand_bh = NULL;\n\n\tif (ref_root_bh == ref_leaf_bh) {\n\t\t/*\n\t\t * the old root bh hasn't been expanded to a b-tree,\n\t\t * so expand it first.\n\t\t */\n\t\tret = ocfs2_expand_inline_ref_root(handle, ci, ref_root_bh,\n\t\t\t\t\t\t   &expand_bh, meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\texpand_bh = ref_leaf_bh;\n\t\tget_bh(expand_bh);\n\t}\n\n\n\t/* Now add a new refcount block into the tree.*/\n\tret = ocfs2_new_leaf_refcount_block(handle, ci, ref_root_bh,\n\t\t\t\t\t    expand_bh, meta_ac);\n\tif (ret)\n\t\tmlog_errno(ret);\nout:\n\tbrelse(expand_bh);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "expand_bh"
          ],
          "line": 1654
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_new_leaf_refcount_block",
          "args": [
            "handle",
            "ci",
            "ref_root_bh",
            "expand_bh",
            "meta_ac"
          ],
          "line": 1649
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_new_leaf_refcount_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "1526-1620",
          "snippet": "static int ocfs2_new_leaf_refcount_block(handle_t *handle,\n\t\t\t\t\t struct ocfs2_caching_info *ci,\n\t\t\t\t\t struct buffer_head *ref_root_bh,\n\t\t\t\t\t struct buffer_head *ref_leaf_bh,\n\t\t\t\t\t struct ocfs2_alloc_context *meta_ac)\n{\n\tint ret;\n\tu16 suballoc_bit_start;\n\tu32 num_got, new_cpos;\n\tu64 suballoc_loc, blkno;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\n\tstruct ocfs2_refcount_block *root_rb =\n\t\t\t(struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\tstruct buffer_head *new_bh = NULL;\n\tstruct ocfs2_refcount_block *new_rb;\n\tstruct ocfs2_extent_tree ref_et;\n\n\tBUG_ON(!(le32_to_cpu(root_rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL));\n\n\tret = ocfs2_journal_access_rb(handle, ci, ref_root_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_rb(handle, ci, ref_leaf_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_claim_metadata(handle, meta_ac, 1, &suballoc_loc,\n\t\t\t\t   &suballoc_bit_start, &num_got,\n\t\t\t\t   &blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tnew_bh = sb_getblk(sb, blkno);\n\tif (new_bh == NULL) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tocfs2_set_new_buffer_uptodate(ci, new_bh);\n\n\tret = ocfs2_journal_access_rb(handle, ci, new_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* Initialize ocfs2_refcount_block. */\n\tnew_rb = (struct ocfs2_refcount_block *)new_bh->b_data;\n\tmemset(new_rb, 0, sb->s_blocksize);\n\tstrcpy((void *)new_rb, OCFS2_REFCOUNT_BLOCK_SIGNATURE);\n\tnew_rb->rf_suballoc_slot = cpu_to_le16(meta_ac->ac_alloc_slot);\n\tnew_rb->rf_suballoc_loc = cpu_to_le64(suballoc_loc);\n\tnew_rb->rf_suballoc_bit = cpu_to_le16(suballoc_bit_start);\n\tnew_rb->rf_fs_generation = cpu_to_le32(OCFS2_SB(sb)->fs_generation);\n\tnew_rb->rf_blkno = cpu_to_le64(blkno);\n\tnew_rb->rf_parent = cpu_to_le64(ref_root_bh->b_blocknr);\n\tnew_rb->rf_flags = cpu_to_le32(OCFS2_REFCOUNT_LEAF_FL);\n\tnew_rb->rf_records.rl_count =\n\t\t\t\tcpu_to_le16(ocfs2_refcount_recs_per_rb(sb));\n\tnew_rb->rf_generation = root_rb->rf_generation;\n\n\tret = ocfs2_divide_leaf_refcount_block(ref_leaf_bh, new_bh, &new_cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_journal_dirty(handle, ref_leaf_bh);\n\tocfs2_journal_dirty(handle, new_bh);\n\n\tocfs2_init_refcount_extent_tree(&ref_et, ci, ref_root_bh);\n\n\ttrace_ocfs2_new_leaf_refcount_block(\n\t\t\t(unsigned long long)new_bh->b_blocknr, new_cpos);\n\n\t/* Insert the new leaf block with the specific offset cpos. */\n\tret = ocfs2_insert_extent(handle, &ref_et, new_cpos, new_bh->b_blocknr,\n\t\t\t\t  1, 0, meta_ac);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\tbrelse(new_bh);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_new_leaf_refcount_block(handle_t *handle,\n\t\t\t\t\t struct ocfs2_caching_info *ci,\n\t\t\t\t\t struct buffer_head *ref_root_bh,\n\t\t\t\t\t struct buffer_head *ref_leaf_bh,\n\t\t\t\t\t struct ocfs2_alloc_context *meta_ac)\n{\n\tint ret;\n\tu16 suballoc_bit_start;\n\tu32 num_got, new_cpos;\n\tu64 suballoc_loc, blkno;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\n\tstruct ocfs2_refcount_block *root_rb =\n\t\t\t(struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\tstruct buffer_head *new_bh = NULL;\n\tstruct ocfs2_refcount_block *new_rb;\n\tstruct ocfs2_extent_tree ref_et;\n\n\tBUG_ON(!(le32_to_cpu(root_rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL));\n\n\tret = ocfs2_journal_access_rb(handle, ci, ref_root_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_rb(handle, ci, ref_leaf_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_claim_metadata(handle, meta_ac, 1, &suballoc_loc,\n\t\t\t\t   &suballoc_bit_start, &num_got,\n\t\t\t\t   &blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tnew_bh = sb_getblk(sb, blkno);\n\tif (new_bh == NULL) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tocfs2_set_new_buffer_uptodate(ci, new_bh);\n\n\tret = ocfs2_journal_access_rb(handle, ci, new_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* Initialize ocfs2_refcount_block. */\n\tnew_rb = (struct ocfs2_refcount_block *)new_bh->b_data;\n\tmemset(new_rb, 0, sb->s_blocksize);\n\tstrcpy((void *)new_rb, OCFS2_REFCOUNT_BLOCK_SIGNATURE);\n\tnew_rb->rf_suballoc_slot = cpu_to_le16(meta_ac->ac_alloc_slot);\n\tnew_rb->rf_suballoc_loc = cpu_to_le64(suballoc_loc);\n\tnew_rb->rf_suballoc_bit = cpu_to_le16(suballoc_bit_start);\n\tnew_rb->rf_fs_generation = cpu_to_le32(OCFS2_SB(sb)->fs_generation);\n\tnew_rb->rf_blkno = cpu_to_le64(blkno);\n\tnew_rb->rf_parent = cpu_to_le64(ref_root_bh->b_blocknr);\n\tnew_rb->rf_flags = cpu_to_le32(OCFS2_REFCOUNT_LEAF_FL);\n\tnew_rb->rf_records.rl_count =\n\t\t\t\tcpu_to_le16(ocfs2_refcount_recs_per_rb(sb));\n\tnew_rb->rf_generation = root_rb->rf_generation;\n\n\tret = ocfs2_divide_leaf_refcount_block(ref_leaf_bh, new_bh, &new_cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_journal_dirty(handle, ref_leaf_bh);\n\tocfs2_journal_dirty(handle, new_bh);\n\n\tocfs2_init_refcount_extent_tree(&ref_et, ci, ref_root_bh);\n\n\ttrace_ocfs2_new_leaf_refcount_block(\n\t\t\t(unsigned long long)new_bh->b_blocknr, new_cpos);\n\n\t/* Insert the new leaf block with the specific offset cpos. */\n\tret = ocfs2_insert_extent(handle, &ref_et, new_cpos, new_bh->b_blocknr,\n\t\t\t\t  1, 0, meta_ac);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\tbrelse(new_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "expand_bh"
          ],
          "line": 1644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_expand_inline_ref_root",
          "args": [
            "handle",
            "ci",
            "ref_root_bh",
            "&expand_bh",
            "meta_ac"
          ],
          "line": 1636
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_expand_inline_ref_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "1286-1369",
          "snippet": "static int ocfs2_expand_inline_ref_root(handle_t *handle,\n\t\t\t\t\tstruct ocfs2_caching_info *ci,\n\t\t\t\t\tstruct buffer_head *ref_root_bh,\n\t\t\t\t\tstruct buffer_head **ref_leaf_bh,\n\t\t\t\t\tstruct ocfs2_alloc_context *meta_ac)\n{\n\tint ret;\n\tu16 suballoc_bit_start;\n\tu32 num_got;\n\tu64 suballoc_loc, blkno;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\n\tstruct buffer_head *new_bh = NULL;\n\tstruct ocfs2_refcount_block *new_rb;\n\tstruct ocfs2_refcount_block *root_rb =\n\t\t\t(struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\n\tret = ocfs2_journal_access_rb(handle, ci, ref_root_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_claim_metadata(handle, meta_ac, 1, &suballoc_loc,\n\t\t\t\t   &suballoc_bit_start, &num_got,\n\t\t\t\t   &blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tnew_bh = sb_getblk(sb, blkno);\n\tif (new_bh == NULL) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tocfs2_set_new_buffer_uptodate(ci, new_bh);\n\n\tret = ocfs2_journal_access_rb(handle, ci, new_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Initialize ocfs2_refcount_block.\n\t * It should contain the same information as the old root.\n\t * so just memcpy it and change the corresponding field.\n\t */\n\tmemcpy(new_bh->b_data, ref_root_bh->b_data, sb->s_blocksize);\n\n\tnew_rb = (struct ocfs2_refcount_block *)new_bh->b_data;\n\tnew_rb->rf_suballoc_slot = cpu_to_le16(meta_ac->ac_alloc_slot);\n\tnew_rb->rf_suballoc_loc = cpu_to_le64(suballoc_loc);\n\tnew_rb->rf_suballoc_bit = cpu_to_le16(suballoc_bit_start);\n\tnew_rb->rf_blkno = cpu_to_le64(blkno);\n\tnew_rb->rf_cpos = cpu_to_le32(0);\n\tnew_rb->rf_parent = cpu_to_le64(ref_root_bh->b_blocknr);\n\tnew_rb->rf_flags = cpu_to_le32(OCFS2_REFCOUNT_LEAF_FL);\n\tocfs2_journal_dirty(handle, new_bh);\n\n\t/* Now change the root. */\n\tmemset(&root_rb->rf_list, 0, sb->s_blocksize -\n\t       offsetof(struct ocfs2_refcount_block, rf_list));\n\troot_rb->rf_list.l_count = cpu_to_le16(ocfs2_extent_recs_per_rb(sb));\n\troot_rb->rf_clusters = cpu_to_le32(1);\n\troot_rb->rf_list.l_next_free_rec = cpu_to_le16(1);\n\troot_rb->rf_list.l_recs[0].e_blkno = cpu_to_le64(blkno);\n\troot_rb->rf_list.l_recs[0].e_leaf_clusters = cpu_to_le16(1);\n\troot_rb->rf_flags = cpu_to_le32(OCFS2_REFCOUNT_TREE_FL);\n\n\tocfs2_journal_dirty(handle, ref_root_bh);\n\n\ttrace_ocfs2_expand_inline_ref_root((unsigned long long)blkno,\n\t\tle16_to_cpu(new_rb->rf_records.rl_used));\n\n\t*ref_leaf_bh = new_bh;\n\tnew_bh = NULL;\nout:\n\tbrelse(new_bh);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_expand_inline_ref_root(handle_t *handle,\n\t\t\t\t\tstruct ocfs2_caching_info *ci,\n\t\t\t\t\tstruct buffer_head *ref_root_bh,\n\t\t\t\t\tstruct buffer_head **ref_leaf_bh,\n\t\t\t\t\tstruct ocfs2_alloc_context *meta_ac)\n{\n\tint ret;\n\tu16 suballoc_bit_start;\n\tu32 num_got;\n\tu64 suballoc_loc, blkno;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\n\tstruct buffer_head *new_bh = NULL;\n\tstruct ocfs2_refcount_block *new_rb;\n\tstruct ocfs2_refcount_block *root_rb =\n\t\t\t(struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\n\tret = ocfs2_journal_access_rb(handle, ci, ref_root_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_claim_metadata(handle, meta_ac, 1, &suballoc_loc,\n\t\t\t\t   &suballoc_bit_start, &num_got,\n\t\t\t\t   &blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tnew_bh = sb_getblk(sb, blkno);\n\tif (new_bh == NULL) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tocfs2_set_new_buffer_uptodate(ci, new_bh);\n\n\tret = ocfs2_journal_access_rb(handle, ci, new_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Initialize ocfs2_refcount_block.\n\t * It should contain the same information as the old root.\n\t * so just memcpy it and change the corresponding field.\n\t */\n\tmemcpy(new_bh->b_data, ref_root_bh->b_data, sb->s_blocksize);\n\n\tnew_rb = (struct ocfs2_refcount_block *)new_bh->b_data;\n\tnew_rb->rf_suballoc_slot = cpu_to_le16(meta_ac->ac_alloc_slot);\n\tnew_rb->rf_suballoc_loc = cpu_to_le64(suballoc_loc);\n\tnew_rb->rf_suballoc_bit = cpu_to_le16(suballoc_bit_start);\n\tnew_rb->rf_blkno = cpu_to_le64(blkno);\n\tnew_rb->rf_cpos = cpu_to_le32(0);\n\tnew_rb->rf_parent = cpu_to_le64(ref_root_bh->b_blocknr);\n\tnew_rb->rf_flags = cpu_to_le32(OCFS2_REFCOUNT_LEAF_FL);\n\tocfs2_journal_dirty(handle, new_bh);\n\n\t/* Now change the root. */\n\tmemset(&root_rb->rf_list, 0, sb->s_blocksize -\n\t       offsetof(struct ocfs2_refcount_block, rf_list));\n\troot_rb->rf_list.l_count = cpu_to_le16(ocfs2_extent_recs_per_rb(sb));\n\troot_rb->rf_clusters = cpu_to_le32(1);\n\troot_rb->rf_list.l_next_free_rec = cpu_to_le16(1);\n\troot_rb->rf_list.l_recs[0].e_blkno = cpu_to_le64(blkno);\n\troot_rb->rf_list.l_recs[0].e_leaf_clusters = cpu_to_le16(1);\n\troot_rb->rf_flags = cpu_to_le32(OCFS2_REFCOUNT_TREE_FL);\n\n\tocfs2_journal_dirty(handle, ref_root_bh);\n\n\ttrace_ocfs2_expand_inline_ref_root((unsigned long long)blkno,\n\t\tle16_to_cpu(new_rb->rf_records.rl_used));\n\n\t*ref_leaf_bh = new_bh;\n\tnew_bh = NULL;\nout:\n\tbrelse(new_bh);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_expand_refcount_tree(handle_t *handle,\n\t\t\t\t      struct ocfs2_caching_info *ci,\n\t\t\t\t      struct buffer_head *ref_root_bh,\n\t\t\t\t      struct buffer_head *ref_leaf_bh,\n\t\t\t\t      struct ocfs2_alloc_context *meta_ac)\n{\n\tint ret;\n\tstruct buffer_head *expand_bh = NULL;\n\n\tif (ref_root_bh == ref_leaf_bh) {\n\t\t/*\n\t\t * the old root bh hasn't been expanded to a b-tree,\n\t\t * so expand it first.\n\t\t */\n\t\tret = ocfs2_expand_inline_ref_root(handle, ci, ref_root_bh,\n\t\t\t\t\t\t   &expand_bh, meta_ac);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\texpand_bh = ref_leaf_bh;\n\t\tget_bh(expand_bh);\n\t}\n\n\n\t/* Now add a new refcount block into the tree.*/\n\tret = ocfs2_new_leaf_refcount_block(handle, ci, ref_root_bh,\n\t\t\t\t\t    expand_bh, meta_ac);\n\tif (ret)\n\t\tmlog_errno(ret);\nout:\n\tbrelse(expand_bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_new_leaf_refcount_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "1526-1620",
    "snippet": "static int ocfs2_new_leaf_refcount_block(handle_t *handle,\n\t\t\t\t\t struct ocfs2_caching_info *ci,\n\t\t\t\t\t struct buffer_head *ref_root_bh,\n\t\t\t\t\t struct buffer_head *ref_leaf_bh,\n\t\t\t\t\t struct ocfs2_alloc_context *meta_ac)\n{\n\tint ret;\n\tu16 suballoc_bit_start;\n\tu32 num_got, new_cpos;\n\tu64 suballoc_loc, blkno;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\n\tstruct ocfs2_refcount_block *root_rb =\n\t\t\t(struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\tstruct buffer_head *new_bh = NULL;\n\tstruct ocfs2_refcount_block *new_rb;\n\tstruct ocfs2_extent_tree ref_et;\n\n\tBUG_ON(!(le32_to_cpu(root_rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL));\n\n\tret = ocfs2_journal_access_rb(handle, ci, ref_root_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_rb(handle, ci, ref_leaf_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_claim_metadata(handle, meta_ac, 1, &suballoc_loc,\n\t\t\t\t   &suballoc_bit_start, &num_got,\n\t\t\t\t   &blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tnew_bh = sb_getblk(sb, blkno);\n\tif (new_bh == NULL) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tocfs2_set_new_buffer_uptodate(ci, new_bh);\n\n\tret = ocfs2_journal_access_rb(handle, ci, new_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* Initialize ocfs2_refcount_block. */\n\tnew_rb = (struct ocfs2_refcount_block *)new_bh->b_data;\n\tmemset(new_rb, 0, sb->s_blocksize);\n\tstrcpy((void *)new_rb, OCFS2_REFCOUNT_BLOCK_SIGNATURE);\n\tnew_rb->rf_suballoc_slot = cpu_to_le16(meta_ac->ac_alloc_slot);\n\tnew_rb->rf_suballoc_loc = cpu_to_le64(suballoc_loc);\n\tnew_rb->rf_suballoc_bit = cpu_to_le16(suballoc_bit_start);\n\tnew_rb->rf_fs_generation = cpu_to_le32(OCFS2_SB(sb)->fs_generation);\n\tnew_rb->rf_blkno = cpu_to_le64(blkno);\n\tnew_rb->rf_parent = cpu_to_le64(ref_root_bh->b_blocknr);\n\tnew_rb->rf_flags = cpu_to_le32(OCFS2_REFCOUNT_LEAF_FL);\n\tnew_rb->rf_records.rl_count =\n\t\t\t\tcpu_to_le16(ocfs2_refcount_recs_per_rb(sb));\n\tnew_rb->rf_generation = root_rb->rf_generation;\n\n\tret = ocfs2_divide_leaf_refcount_block(ref_leaf_bh, new_bh, &new_cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_journal_dirty(handle, ref_leaf_bh);\n\tocfs2_journal_dirty(handle, new_bh);\n\n\tocfs2_init_refcount_extent_tree(&ref_et, ci, ref_root_bh);\n\n\ttrace_ocfs2_new_leaf_refcount_block(\n\t\t\t(unsigned long long)new_bh->b_blocknr, new_cpos);\n\n\t/* Insert the new leaf block with the specific offset cpos. */\n\tret = ocfs2_insert_extent(handle, &ref_et, new_cpos, new_bh->b_blocknr,\n\t\t\t\t  1, 0, meta_ac);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\tbrelse(new_bh);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "new_bh"
          ],
          "line": 1618
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_insert_extent",
          "args": [
            "handle",
            "&ref_et",
            "new_cpos",
            "new_bh->b_blocknr",
            "1",
            "0",
            "meta_ac"
          ],
          "line": 1612
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_insert_extent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "4665-4726",
          "snippet": "int ocfs2_insert_extent(handle_t *handle,\n\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\tu32 cpos,\n\t\t\tu64 start_blk,\n\t\t\tu32 new_clusters,\n\t\t\tu8 flags,\n\t\t\tstruct ocfs2_alloc_context *meta_ac)\n{\n\tint status;\n\tint uninitialized_var(free_records);\n\tstruct buffer_head *last_eb_bh = NULL;\n\tstruct ocfs2_insert_type insert = {0, };\n\tstruct ocfs2_extent_rec rec;\n\n\ttrace_ocfs2_insert_extent_start(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\tcpos, new_clusters);\n\n\tmemset(&rec, 0, sizeof(rec));\n\trec.e_cpos = cpu_to_le32(cpos);\n\trec.e_blkno = cpu_to_le64(start_blk);\n\trec.e_leaf_clusters = cpu_to_le16(new_clusters);\n\trec.e_flags = flags;\n\tstatus = ocfs2_et_insert_check(et, &rec);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_figure_insert_type(et, &last_eb_bh, &rec,\n\t\t\t\t\t  &free_records, &insert);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_insert_extent(insert.ins_appending, insert.ins_contig,\n\t\t\t\t  insert.ins_contig_index, free_records,\n\t\t\t\t  insert.ins_tree_depth);\n\n\tif (insert.ins_contig == CONTIG_NONE && free_records == 0) {\n\t\tstatus = ocfs2_grow_tree(handle, et,\n\t\t\t\t\t &insert.ins_tree_depth, &last_eb_bh,\n\t\t\t\t\t meta_ac);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* Finally, we can add clusters. This might rotate the tree for us. */\n\tstatus = ocfs2_do_insert_extent(handle, et, &rec, &insert);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\telse\n\t\tocfs2_et_extent_map_insert(et, &rec);\n\nbail:\n\tbrelse(last_eb_bh);\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);",
            "static void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);",
            "static void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);",
            "static int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_update_clusters(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u32 clusters);\nstatic void ocfs2_dinode_extent_map_insert(struct ocfs2_extent_tree *et,\n\t\t\t\t\t   struct ocfs2_extent_rec *rec);\nstatic void ocfs2_dinode_extent_map_truncate(struct ocfs2_extent_tree *et,\n\t\t\t\t\t     u32 clusters);\nstatic int ocfs2_dinode_insert_check(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_extent_rec *rec);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nint ocfs2_insert_extent(handle_t *handle,\n\t\t\tstruct ocfs2_extent_tree *et,\n\t\t\tu32 cpos,\n\t\t\tu64 start_blk,\n\t\t\tu32 new_clusters,\n\t\t\tu8 flags,\n\t\t\tstruct ocfs2_alloc_context *meta_ac)\n{\n\tint status;\n\tint uninitialized_var(free_records);\n\tstruct buffer_head *last_eb_bh = NULL;\n\tstruct ocfs2_insert_type insert = {0, };\n\tstruct ocfs2_extent_rec rec;\n\n\ttrace_ocfs2_insert_extent_start(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\tcpos, new_clusters);\n\n\tmemset(&rec, 0, sizeof(rec));\n\trec.e_cpos = cpu_to_le32(cpos);\n\trec.e_blkno = cpu_to_le64(start_blk);\n\trec.e_leaf_clusters = cpu_to_le16(new_clusters);\n\trec.e_flags = flags;\n\tstatus = ocfs2_et_insert_check(et, &rec);\n\tif (status) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = ocfs2_figure_insert_type(et, &last_eb_bh, &rec,\n\t\t\t\t\t  &free_records, &insert);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\ttrace_ocfs2_insert_extent(insert.ins_appending, insert.ins_contig,\n\t\t\t\t  insert.ins_contig_index, free_records,\n\t\t\t\t  insert.ins_tree_depth);\n\n\tif (insert.ins_contig == CONTIG_NONE && free_records == 0) {\n\t\tstatus = ocfs2_grow_tree(handle, et,\n\t\t\t\t\t &insert.ins_tree_depth, &last_eb_bh,\n\t\t\t\t\t meta_ac);\n\t\tif (status) {\n\t\t\tmlog_errno(status);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\t/* Finally, we can add clusters. This might rotate the tree for us. */\n\tstatus = ocfs2_do_insert_extent(handle, et, &rec, &insert);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\telse\n\t\tocfs2_et_extent_map_insert(et, &rec);\n\nbail:\n\tbrelse(last_eb_bh);\n\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_new_leaf_refcount_block",
          "args": [
            "(unsigned long long)new_bh->b_blocknr",
            "new_cpos"
          ],
          "line": 1608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_init_refcount_extent_tree",
          "args": [
            "&ref_et",
            "ci",
            "ref_root_bh"
          ],
          "line": 1606
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_refcount_extent_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "490-496",
          "snippet": "void ocfs2_init_refcount_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_rb,\n\t\t\t\t NULL, &ocfs2_refcount_tree_et_ops);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static struct ocfs2_extent_tree_operations ocfs2_refcount_tree_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_refcount_tree_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_refcount_tree_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_refcount_tree_update_clusters,\n\t.eo_fill_root_el\t= ocfs2_refcount_tree_fill_root_el,\n\t.eo_extent_contig\t= ocfs2_refcount_tree_extent_contig,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic struct ocfs2_extent_tree_operations ocfs2_refcount_tree_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_refcount_tree_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_refcount_tree_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_refcount_tree_update_clusters,\n\t.eo_fill_root_el\t= ocfs2_refcount_tree_fill_root_el,\n\t.eo_extent_contig\t= ocfs2_refcount_tree_extent_contig,\n};\n\nvoid ocfs2_init_refcount_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_rb,\n\t\t\t\t NULL, &ocfs2_refcount_tree_et_ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "new_bh"
          ],
          "line": 1604
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_divide_leaf_refcount_block",
          "args": [
            "ref_leaf_bh",
            "new_bh",
            "&new_cpos"
          ],
          "line": 1597
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_divide_leaf_refcount_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "1460-1524",
          "snippet": "static int ocfs2_divide_leaf_refcount_block(struct buffer_head *ref_leaf_bh,\n\t\t\t\t\t    struct buffer_head *new_bh,\n\t\t\t\t\t    u32 *split_cpos)\n{\n\tint split_index = 0, num_moved, ret;\n\tu32 cpos = 0;\n\tstruct ocfs2_refcount_block *rb =\n\t\t\t(struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\n\tstruct ocfs2_refcount_list *rl = &rb->rf_records;\n\tstruct ocfs2_refcount_block *new_rb =\n\t\t\t(struct ocfs2_refcount_block *)new_bh->b_data;\n\tstruct ocfs2_refcount_list *new_rl = &new_rb->rf_records;\n\n\ttrace_ocfs2_divide_leaf_refcount_block(\n\t\t(unsigned long long)ref_leaf_bh->b_blocknr,\n\t\tle16_to_cpu(rl->rl_count), le16_to_cpu(rl->rl_used));\n\n\t/*\n\t * XXX: Improvement later.\n\t * If we know all the high 32 bit cpos is the same, no need to sort.\n\t *\n\t * In order to make the whole process safe, we do:\n\t * 1. sort the entries by their low 32 bit cpos first so that we can\n\t *    find the split cpos easily.\n\t * 2. call ocfs2_insert_extent to insert the new refcount block.\n\t * 3. move the refcount rec to the new block.\n\t * 4. sort the entries by their 64 bit cpos.\n\t * 5. dirty the new_rb and rb.\n\t */\n\tsort(&rl->rl_recs, le16_to_cpu(rl->rl_used),\n\t     sizeof(struct ocfs2_refcount_rec),\n\t     cmp_refcount_rec_by_low_cpos, swap_refcount_rec);\n\n\tret = ocfs2_find_refcount_split_pos(rl, &cpos, &split_index);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tnew_rb->rf_cpos = cpu_to_le32(cpos);\n\n\t/* move refcount records starting from split_index to the new block. */\n\tnum_moved = le16_to_cpu(rl->rl_used) - split_index;\n\tmemcpy(new_rl->rl_recs, &rl->rl_recs[split_index],\n\t       num_moved * sizeof(struct ocfs2_refcount_rec));\n\n\t/*ok, remove the entries we just moved over to the other block. */\n\tmemset(&rl->rl_recs[split_index], 0,\n\t       num_moved * sizeof(struct ocfs2_refcount_rec));\n\n\t/* change old and new rl_used accordingly. */\n\tle16_add_cpu(&rl->rl_used, -num_moved);\n\tnew_rl->rl_used = cpu_to_le16(num_moved);\n\n\tsort(&rl->rl_recs, le16_to_cpu(rl->rl_used),\n\t     sizeof(struct ocfs2_refcount_rec),\n\t     cmp_refcount_rec_by_cpos, swap_refcount_rec);\n\n\tsort(&new_rl->rl_recs, le16_to_cpu(new_rl->rl_used),\n\t     sizeof(struct ocfs2_refcount_rec),\n\t     cmp_refcount_rec_by_cpos, swap_refcount_rec);\n\n\t*split_cpos = cpos;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_divide_leaf_refcount_block(struct buffer_head *ref_leaf_bh,\n\t\t\t\t\t    struct buffer_head *new_bh,\n\t\t\t\t\t    u32 *split_cpos)\n{\n\tint split_index = 0, num_moved, ret;\n\tu32 cpos = 0;\n\tstruct ocfs2_refcount_block *rb =\n\t\t\t(struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\n\tstruct ocfs2_refcount_list *rl = &rb->rf_records;\n\tstruct ocfs2_refcount_block *new_rb =\n\t\t\t(struct ocfs2_refcount_block *)new_bh->b_data;\n\tstruct ocfs2_refcount_list *new_rl = &new_rb->rf_records;\n\n\ttrace_ocfs2_divide_leaf_refcount_block(\n\t\t(unsigned long long)ref_leaf_bh->b_blocknr,\n\t\tle16_to_cpu(rl->rl_count), le16_to_cpu(rl->rl_used));\n\n\t/*\n\t * XXX: Improvement later.\n\t * If we know all the high 32 bit cpos is the same, no need to sort.\n\t *\n\t * In order to make the whole process safe, we do:\n\t * 1. sort the entries by their low 32 bit cpos first so that we can\n\t *    find the split cpos easily.\n\t * 2. call ocfs2_insert_extent to insert the new refcount block.\n\t * 3. move the refcount rec to the new block.\n\t * 4. sort the entries by their 64 bit cpos.\n\t * 5. dirty the new_rb and rb.\n\t */\n\tsort(&rl->rl_recs, le16_to_cpu(rl->rl_used),\n\t     sizeof(struct ocfs2_refcount_rec),\n\t     cmp_refcount_rec_by_low_cpos, swap_refcount_rec);\n\n\tret = ocfs2_find_refcount_split_pos(rl, &cpos, &split_index);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tnew_rb->rf_cpos = cpu_to_le32(cpos);\n\n\t/* move refcount records starting from split_index to the new block. */\n\tnum_moved = le16_to_cpu(rl->rl_used) - split_index;\n\tmemcpy(new_rl->rl_recs, &rl->rl_recs[split_index],\n\t       num_moved * sizeof(struct ocfs2_refcount_rec));\n\n\t/*ok, remove the entries we just moved over to the other block. */\n\tmemset(&rl->rl_recs[split_index], 0,\n\t       num_moved * sizeof(struct ocfs2_refcount_rec));\n\n\t/* change old and new rl_used accordingly. */\n\tle16_add_cpu(&rl->rl_used, -num_moved);\n\tnew_rl->rl_used = cpu_to_le16(num_moved);\n\n\tsort(&rl->rl_recs, le16_to_cpu(rl->rl_used),\n\t     sizeof(struct ocfs2_refcount_rec),\n\t     cmp_refcount_rec_by_cpos, swap_refcount_rec);\n\n\tsort(&new_rl->rl_recs, le16_to_cpu(new_rl->rl_used),\n\t     sizeof(struct ocfs2_refcount_rec),\n\t     cmp_refcount_rec_by_cpos, swap_refcount_rec);\n\n\t*split_cpos = cpos;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "ocfs2_refcount_recs_per_rb(sb)"
          ],
          "line": 1594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_refcount_recs_per_rb",
          "args": [
            "sb"
          ],
          "line": 1594
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_refcount_recs_per_rb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1464-1472",
          "snippet": "static inline u16 ocfs2_refcount_recs_per_rb(struct super_block *sb)\n{\n\tint size;\n\n\tsize = sb->s_blocksize -\n\t\toffsetof(struct ocfs2_refcount_block, rf_records.rl_recs);\n\n\treturn size / sizeof(struct ocfs2_refcount_rec);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u16 ocfs2_refcount_recs_per_rb(struct super_block *sb)\n{\n\tint size;\n\n\tsize = sb->s_blocksize -\n\t\toffsetof(struct ocfs2_refcount_block, rf_records.rl_recs);\n\n\treturn size / sizeof(struct ocfs2_refcount_rec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "OCFS2_REFCOUNT_LEAF_FL"
          ],
          "line": 1592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "ref_root_bh->b_blocknr"
          ],
          "line": 1591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "blkno"
          ],
          "line": 1590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "OCFS2_SB(sb)->fs_generation"
          ],
          "line": 1589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 1589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "suballoc_bit_start"
          ],
          "line": 1588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "suballoc_loc"
          ],
          "line": 1587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "meta_ac->ac_alloc_slot"
          ],
          "line": 1586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "(void *)new_rb",
            "OCFS2_REFCOUNT_BLOCK_SIGNATURE"
          ],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "new_rb",
            "0",
            "sb->s_blocksize"
          ],
          "line": 1584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_rb",
          "args": [
            "handle",
            "ci",
            "new_bh",
            "OCFS2_JOURNAL_ACCESS_CREATE"
          ],
          "line": 1575
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_rb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "722-727",
          "snippet": "int ocfs2_journal_access_rb(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &rb_triggers,\n\t\t\t\t      type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers rb_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_refcount_block, rf_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers rb_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_refcount_block, rf_check),\n};\n\nint ocfs2_journal_access_rb(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &rb_triggers,\n\t\t\t\t      type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_set_new_buffer_uptodate",
          "args": [
            "ci",
            "new_bh"
          ],
          "line": 1573
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_new_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "521-532",
          "snippet": "void ocfs2_set_new_buffer_uptodate(struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t/* This should definitely *not* exist in our cache */\n\tBUG_ON(ocfs2_buffer_cached(ci, bh));\n\n\tset_buffer_uptodate(bh);\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tocfs2_set_buffer_uptodate(ci, bh);\n\tocfs2_metadata_cache_io_unlock(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_set_new_buffer_uptodate(struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t/* This should definitely *not* exist in our cache */\n\tBUG_ON(ocfs2_buffer_cached(ci, bh));\n\n\tset_buffer_uptodate(bh);\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tocfs2_set_buffer_uptodate(ci, bh);\n\tocfs2_metadata_cache_io_unlock(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "sb",
            "blkno"
          ],
          "line": 1567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_claim_metadata",
          "args": [
            "handle",
            "meta_ac",
            "1",
            "&suballoc_loc",
            "&suballoc_bit_start",
            "&num_got",
            "&blkno"
          ],
          "line": 1559
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_claim_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "1993-2029",
          "snippet": "int ocfs2_claim_metadata(handle_t *handle,\n\t\t\t struct ocfs2_alloc_context *ac,\n\t\t\t u32 bits_wanted,\n\t\t\t u64 *suballoc_loc,\n\t\t\t u16 *suballoc_bit_start,\n\t\t\t unsigned int *num_bits,\n\t\t\t u64 *blkno_start)\n{\n\tint status;\n\tstruct ocfs2_suballoc_result res = { .sr_blkno = 0, };\n\n\tBUG_ON(!ac);\n\tBUG_ON(ac->ac_bits_wanted < (ac->ac_bits_given + bits_wanted));\n\tBUG_ON(ac->ac_which != OCFS2_AC_USE_META);\n\n\tstatus = ocfs2_claim_suballoc_bits(ac,\n\t\t\t\t\t   handle,\n\t\t\t\t\t   bits_wanted,\n\t\t\t\t\t   1,\n\t\t\t\t\t   &res);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tatomic_inc(&OCFS2_SB(ac->ac_inode->i_sb)->alloc_stats.bg_allocs);\n\n\t*suballoc_loc = res.sr_bg_blkno;\n\t*suballoc_bit_start = res.sr_bit_offset;\n\t*blkno_start = res.sr_blkno;\n\tac->ac_bits_given += res.sr_bits;\n\t*num_bits = res.sr_bits;\n\tstatus = 0;\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);",
            "static int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);",
            "static int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);",
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);\nstatic int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);\nstatic int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint ocfs2_claim_metadata(handle_t *handle,\n\t\t\t struct ocfs2_alloc_context *ac,\n\t\t\t u32 bits_wanted,\n\t\t\t u64 *suballoc_loc,\n\t\t\t u16 *suballoc_bit_start,\n\t\t\t unsigned int *num_bits,\n\t\t\t u64 *blkno_start)\n{\n\tint status;\n\tstruct ocfs2_suballoc_result res = { .sr_blkno = 0, };\n\n\tBUG_ON(!ac);\n\tBUG_ON(ac->ac_bits_wanted < (ac->ac_bits_given + bits_wanted));\n\tBUG_ON(ac->ac_which != OCFS2_AC_USE_META);\n\n\tstatus = ocfs2_claim_suballoc_bits(ac,\n\t\t\t\t\t   handle,\n\t\t\t\t\t   bits_wanted,\n\t\t\t\t\t   1,\n\t\t\t\t\t   &res);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tatomic_inc(&OCFS2_SB(ac->ac_inode->i_sb)->alloc_stats.bg_allocs);\n\n\t*suballoc_loc = res.sr_bg_blkno;\n\t*suballoc_bit_start = res.sr_bit_offset;\n\t*blkno_start = res.sr_blkno;\n\tac->ac_bits_given += res.sr_bits;\n\t*num_bits = res.sr_bits;\n\tstatus = 0;\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(le32_to_cpu(root_rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL)"
          ],
          "line": 1543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "root_rb->rf_flags"
          ],
          "line": 1543
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_get_super",
          "args": [
            "ci"
          ],
          "line": 1536
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_get_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "79-84",
          "snippet": "struct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_new_leaf_refcount_block(handle_t *handle,\n\t\t\t\t\t struct ocfs2_caching_info *ci,\n\t\t\t\t\t struct buffer_head *ref_root_bh,\n\t\t\t\t\t struct buffer_head *ref_leaf_bh,\n\t\t\t\t\t struct ocfs2_alloc_context *meta_ac)\n{\n\tint ret;\n\tu16 suballoc_bit_start;\n\tu32 num_got, new_cpos;\n\tu64 suballoc_loc, blkno;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\n\tstruct ocfs2_refcount_block *root_rb =\n\t\t\t(struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\tstruct buffer_head *new_bh = NULL;\n\tstruct ocfs2_refcount_block *new_rb;\n\tstruct ocfs2_extent_tree ref_et;\n\n\tBUG_ON(!(le32_to_cpu(root_rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL));\n\n\tret = ocfs2_journal_access_rb(handle, ci, ref_root_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_rb(handle, ci, ref_leaf_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_claim_metadata(handle, meta_ac, 1, &suballoc_loc,\n\t\t\t\t   &suballoc_bit_start, &num_got,\n\t\t\t\t   &blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tnew_bh = sb_getblk(sb, blkno);\n\tif (new_bh == NULL) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tocfs2_set_new_buffer_uptodate(ci, new_bh);\n\n\tret = ocfs2_journal_access_rb(handle, ci, new_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/* Initialize ocfs2_refcount_block. */\n\tnew_rb = (struct ocfs2_refcount_block *)new_bh->b_data;\n\tmemset(new_rb, 0, sb->s_blocksize);\n\tstrcpy((void *)new_rb, OCFS2_REFCOUNT_BLOCK_SIGNATURE);\n\tnew_rb->rf_suballoc_slot = cpu_to_le16(meta_ac->ac_alloc_slot);\n\tnew_rb->rf_suballoc_loc = cpu_to_le64(suballoc_loc);\n\tnew_rb->rf_suballoc_bit = cpu_to_le16(suballoc_bit_start);\n\tnew_rb->rf_fs_generation = cpu_to_le32(OCFS2_SB(sb)->fs_generation);\n\tnew_rb->rf_blkno = cpu_to_le64(blkno);\n\tnew_rb->rf_parent = cpu_to_le64(ref_root_bh->b_blocknr);\n\tnew_rb->rf_flags = cpu_to_le32(OCFS2_REFCOUNT_LEAF_FL);\n\tnew_rb->rf_records.rl_count =\n\t\t\t\tcpu_to_le16(ocfs2_refcount_recs_per_rb(sb));\n\tnew_rb->rf_generation = root_rb->rf_generation;\n\n\tret = ocfs2_divide_leaf_refcount_block(ref_leaf_bh, new_bh, &new_cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_journal_dirty(handle, ref_leaf_bh);\n\tocfs2_journal_dirty(handle, new_bh);\n\n\tocfs2_init_refcount_extent_tree(&ref_et, ci, ref_root_bh);\n\n\ttrace_ocfs2_new_leaf_refcount_block(\n\t\t\t(unsigned long long)new_bh->b_blocknr, new_cpos);\n\n\t/* Insert the new leaf block with the specific offset cpos. */\n\tret = ocfs2_insert_extent(handle, &ref_et, new_cpos, new_bh->b_blocknr,\n\t\t\t\t  1, 0, meta_ac);\n\tif (ret)\n\t\tmlog_errno(ret);\n\nout:\n\tbrelse(new_bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_divide_leaf_refcount_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "1460-1524",
    "snippet": "static int ocfs2_divide_leaf_refcount_block(struct buffer_head *ref_leaf_bh,\n\t\t\t\t\t    struct buffer_head *new_bh,\n\t\t\t\t\t    u32 *split_cpos)\n{\n\tint split_index = 0, num_moved, ret;\n\tu32 cpos = 0;\n\tstruct ocfs2_refcount_block *rb =\n\t\t\t(struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\n\tstruct ocfs2_refcount_list *rl = &rb->rf_records;\n\tstruct ocfs2_refcount_block *new_rb =\n\t\t\t(struct ocfs2_refcount_block *)new_bh->b_data;\n\tstruct ocfs2_refcount_list *new_rl = &new_rb->rf_records;\n\n\ttrace_ocfs2_divide_leaf_refcount_block(\n\t\t(unsigned long long)ref_leaf_bh->b_blocknr,\n\t\tle16_to_cpu(rl->rl_count), le16_to_cpu(rl->rl_used));\n\n\t/*\n\t * XXX: Improvement later.\n\t * If we know all the high 32 bit cpos is the same, no need to sort.\n\t *\n\t * In order to make the whole process safe, we do:\n\t * 1. sort the entries by their low 32 bit cpos first so that we can\n\t *    find the split cpos easily.\n\t * 2. call ocfs2_insert_extent to insert the new refcount block.\n\t * 3. move the refcount rec to the new block.\n\t * 4. sort the entries by their 64 bit cpos.\n\t * 5. dirty the new_rb and rb.\n\t */\n\tsort(&rl->rl_recs, le16_to_cpu(rl->rl_used),\n\t     sizeof(struct ocfs2_refcount_rec),\n\t     cmp_refcount_rec_by_low_cpos, swap_refcount_rec);\n\n\tret = ocfs2_find_refcount_split_pos(rl, &cpos, &split_index);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tnew_rb->rf_cpos = cpu_to_le32(cpos);\n\n\t/* move refcount records starting from split_index to the new block. */\n\tnum_moved = le16_to_cpu(rl->rl_used) - split_index;\n\tmemcpy(new_rl->rl_recs, &rl->rl_recs[split_index],\n\t       num_moved * sizeof(struct ocfs2_refcount_rec));\n\n\t/*ok, remove the entries we just moved over to the other block. */\n\tmemset(&rl->rl_recs[split_index], 0,\n\t       num_moved * sizeof(struct ocfs2_refcount_rec));\n\n\t/* change old and new rl_used accordingly. */\n\tle16_add_cpu(&rl->rl_used, -num_moved);\n\tnew_rl->rl_used = cpu_to_le16(num_moved);\n\n\tsort(&rl->rl_recs, le16_to_cpu(rl->rl_used),\n\t     sizeof(struct ocfs2_refcount_rec),\n\t     cmp_refcount_rec_by_cpos, swap_refcount_rec);\n\n\tsort(&new_rl->rl_recs, le16_to_cpu(new_rl->rl_used),\n\t     sizeof(struct ocfs2_refcount_rec),\n\t     cmp_refcount_rec_by_cpos, swap_refcount_rec);\n\n\t*split_cpos = cpos;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sort",
          "args": [
            "&new_rl->rl_recs",
            "le16_to_cpu(new_rl->rl_used)",
            "sizeof(struct ocfs2_refcount_rec)",
            "cmp_refcount_rec_by_cpos",
            "swap_refcount_rec"
          ],
          "line": 1518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "new_rl->rl_used"
          ],
          "line": 1518
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sort",
          "args": [
            "&rl->rl_recs",
            "le16_to_cpu(rl->rl_used)",
            "sizeof(struct ocfs2_refcount_rec)",
            "cmp_refcount_rec_by_cpos",
            "swap_refcount_rec"
          ],
          "line": 1514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "num_moved"
          ],
          "line": 1512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&rl->rl_used",
            "-num_moved"
          ],
          "line": 1511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&rl->rl_recs[split_index]",
            "0",
            "num_moved * sizeof(struct ocfs2_refcount_rec)"
          ],
          "line": 1507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "new_rl->rl_recs",
            "&rl->rl_recs[split_index]",
            "num_moved * sizeof(struct ocfs2_refcount_rec)"
          ],
          "line": 1503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "cpos"
          ],
          "line": 1499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_refcount_split_pos",
          "args": [
            "rl",
            "&cpos",
            "&split_index"
          ],
          "line": 1493
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_refcount_split_pos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "1425-1458",
          "snippet": "static int ocfs2_find_refcount_split_pos(struct ocfs2_refcount_list *rl,\n\t\t\t\t\t u32 *split_pos, int *split_index)\n{\n\tint num_used = le16_to_cpu(rl->rl_used);\n\tint delta, middle = num_used / 2;\n\n\tfor (delta = 0; delta < middle; delta++) {\n\t\t/* Let's check delta earlier than middle */\n\t\tif (ocfs2_refcount_rec_no_intersect(\n\t\t\t\t\t&rl->rl_recs[middle - delta - 1],\n\t\t\t\t\t&rl->rl_recs[middle - delta])) {\n\t\t\t*split_index = middle - delta;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* For even counts, don't walk off the end */\n\t\tif ((middle + delta + 1) == num_used)\n\t\t\tcontinue;\n\n\t\t/* Now try delta past middle */\n\t\tif (ocfs2_refcount_rec_no_intersect(\n\t\t\t\t\t&rl->rl_recs[middle + delta],\n\t\t\t\t\t&rl->rl_recs[middle + delta + 1])) {\n\t\t\t*split_index = middle + delta + 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (delta >= middle)\n\t\treturn -ENOSPC;\n\n\t*split_pos = ocfs2_get_ref_rec_low_cpos(&rl->rl_recs[*split_index]);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_find_refcount_split_pos(struct ocfs2_refcount_list *rl,\n\t\t\t\t\t u32 *split_pos, int *split_index)\n{\n\tint num_used = le16_to_cpu(rl->rl_used);\n\tint delta, middle = num_used / 2;\n\n\tfor (delta = 0; delta < middle; delta++) {\n\t\t/* Let's check delta earlier than middle */\n\t\tif (ocfs2_refcount_rec_no_intersect(\n\t\t\t\t\t&rl->rl_recs[middle - delta - 1],\n\t\t\t\t\t&rl->rl_recs[middle - delta])) {\n\t\t\t*split_index = middle - delta;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* For even counts, don't walk off the end */\n\t\tif ((middle + delta + 1) == num_used)\n\t\t\tcontinue;\n\n\t\t/* Now try delta past middle */\n\t\tif (ocfs2_refcount_rec_no_intersect(\n\t\t\t\t\t&rl->rl_recs[middle + delta],\n\t\t\t\t\t&rl->rl_recs[middle + delta + 1])) {\n\t\t\t*split_index = middle + delta + 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (delta >= middle)\n\t\treturn -ENOSPC;\n\n\t*split_pos = ocfs2_get_ref_rec_low_cpos(&rl->rl_recs[*split_index]);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sort",
          "args": [
            "&rl->rl_recs",
            "le16_to_cpu(rl->rl_used)",
            "sizeof(struct ocfs2_refcount_rec)",
            "cmp_refcount_rec_by_low_cpos",
            "swap_refcount_rec"
          ],
          "line": 1489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_divide_leaf_refcount_block",
          "args": [
            "(unsigned long long)ref_leaf_bh->b_blocknr",
            "le16_to_cpu(rl->rl_count)",
            "le16_to_cpu(rl->rl_used)"
          ],
          "line": 1473
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_divide_leaf_refcount_block(struct buffer_head *ref_leaf_bh,\n\t\t\t\t\t    struct buffer_head *new_bh,\n\t\t\t\t\t    u32 *split_cpos)\n{\n\tint split_index = 0, num_moved, ret;\n\tu32 cpos = 0;\n\tstruct ocfs2_refcount_block *rb =\n\t\t\t(struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\n\tstruct ocfs2_refcount_list *rl = &rb->rf_records;\n\tstruct ocfs2_refcount_block *new_rb =\n\t\t\t(struct ocfs2_refcount_block *)new_bh->b_data;\n\tstruct ocfs2_refcount_list *new_rl = &new_rb->rf_records;\n\n\ttrace_ocfs2_divide_leaf_refcount_block(\n\t\t(unsigned long long)ref_leaf_bh->b_blocknr,\n\t\tle16_to_cpu(rl->rl_count), le16_to_cpu(rl->rl_used));\n\n\t/*\n\t * XXX: Improvement later.\n\t * If we know all the high 32 bit cpos is the same, no need to sort.\n\t *\n\t * In order to make the whole process safe, we do:\n\t * 1. sort the entries by their low 32 bit cpos first so that we can\n\t *    find the split cpos easily.\n\t * 2. call ocfs2_insert_extent to insert the new refcount block.\n\t * 3. move the refcount rec to the new block.\n\t * 4. sort the entries by their 64 bit cpos.\n\t * 5. dirty the new_rb and rb.\n\t */\n\tsort(&rl->rl_recs, le16_to_cpu(rl->rl_used),\n\t     sizeof(struct ocfs2_refcount_rec),\n\t     cmp_refcount_rec_by_low_cpos, swap_refcount_rec);\n\n\tret = ocfs2_find_refcount_split_pos(rl, &cpos, &split_index);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tnew_rb->rf_cpos = cpu_to_le32(cpos);\n\n\t/* move refcount records starting from split_index to the new block. */\n\tnum_moved = le16_to_cpu(rl->rl_used) - split_index;\n\tmemcpy(new_rl->rl_recs, &rl->rl_recs[split_index],\n\t       num_moved * sizeof(struct ocfs2_refcount_rec));\n\n\t/*ok, remove the entries we just moved over to the other block. */\n\tmemset(&rl->rl_recs[split_index], 0,\n\t       num_moved * sizeof(struct ocfs2_refcount_rec));\n\n\t/* change old and new rl_used accordingly. */\n\tle16_add_cpu(&rl->rl_used, -num_moved);\n\tnew_rl->rl_used = cpu_to_le16(num_moved);\n\n\tsort(&rl->rl_recs, le16_to_cpu(rl->rl_used),\n\t     sizeof(struct ocfs2_refcount_rec),\n\t     cmp_refcount_rec_by_cpos, swap_refcount_rec);\n\n\tsort(&new_rl->rl_recs, le16_to_cpu(new_rl->rl_used),\n\t     sizeof(struct ocfs2_refcount_rec),\n\t     cmp_refcount_rec_by_cpos, swap_refcount_rec);\n\n\t*split_cpos = cpos;\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_find_refcount_split_pos",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "1425-1458",
    "snippet": "static int ocfs2_find_refcount_split_pos(struct ocfs2_refcount_list *rl,\n\t\t\t\t\t u32 *split_pos, int *split_index)\n{\n\tint num_used = le16_to_cpu(rl->rl_used);\n\tint delta, middle = num_used / 2;\n\n\tfor (delta = 0; delta < middle; delta++) {\n\t\t/* Let's check delta earlier than middle */\n\t\tif (ocfs2_refcount_rec_no_intersect(\n\t\t\t\t\t&rl->rl_recs[middle - delta - 1],\n\t\t\t\t\t&rl->rl_recs[middle - delta])) {\n\t\t\t*split_index = middle - delta;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* For even counts, don't walk off the end */\n\t\tif ((middle + delta + 1) == num_used)\n\t\t\tcontinue;\n\n\t\t/* Now try delta past middle */\n\t\tif (ocfs2_refcount_rec_no_intersect(\n\t\t\t\t\t&rl->rl_recs[middle + delta],\n\t\t\t\t\t&rl->rl_recs[middle + delta + 1])) {\n\t\t\t*split_index = middle + delta + 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (delta >= middle)\n\t\treturn -ENOSPC;\n\n\t*split_pos = ocfs2_get_ref_rec_low_cpos(&rl->rl_recs[*split_index]);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_get_ref_rec_low_cpos",
          "args": [
            "&rl->rl_recs[*split_index]"
          ],
          "line": 1456
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_get_ref_rec_low_cpos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1474-1478",
          "snippet": "static inline u32\nocfs2_get_ref_rec_low_cpos(const struct ocfs2_refcount_rec *rec)\n{\n\treturn le64_to_cpu(rec->r_cpos) & OCFS2_32BIT_POS_MASK;\n}",
          "includes": [],
          "macros_used": [
            "#define OCFS2_32BIT_POS_MASK\t\t(0xffffffffULL)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define OCFS2_32BIT_POS_MASK\t\t(0xffffffffULL)\n\nstatic inline u32\nocfs2_get_ref_rec_low_cpos(const struct ocfs2_refcount_rec *rec)\n{\n\treturn le64_to_cpu(rec->r_cpos) & OCFS2_32BIT_POS_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_refcount_rec_no_intersect",
          "args": [
            "&rl->rl_recs[middle + delta]",
            "&rl->rl_recs[middle + delta + 1]"
          ],
          "line": 1445
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_refcount_rec_no_intersect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "1371-1379",
          "snippet": "static int ocfs2_refcount_rec_no_intersect(struct ocfs2_refcount_rec *prev,\n\t\t\t\t\t   struct ocfs2_refcount_rec *next)\n{\n\tif (ocfs2_get_ref_rec_low_cpos(prev) + le32_to_cpu(prev->r_clusters) <=\n\t\tocfs2_get_ref_rec_low_cpos(next))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_refcount_rec_no_intersect(struct ocfs2_refcount_rec *prev,\n\t\t\t\t\t   struct ocfs2_refcount_rec *next)\n{\n\tif (ocfs2_get_ref_rec_low_cpos(prev) + le32_to_cpu(prev->r_clusters) <=\n\t\tocfs2_get_ref_rec_low_cpos(next))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "rl->rl_used"
          ],
          "line": 1428
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_find_refcount_split_pos(struct ocfs2_refcount_list *rl,\n\t\t\t\t\t u32 *split_pos, int *split_index)\n{\n\tint num_used = le16_to_cpu(rl->rl_used);\n\tint delta, middle = num_used / 2;\n\n\tfor (delta = 0; delta < middle; delta++) {\n\t\t/* Let's check delta earlier than middle */\n\t\tif (ocfs2_refcount_rec_no_intersect(\n\t\t\t\t\t&rl->rl_recs[middle - delta - 1],\n\t\t\t\t\t&rl->rl_recs[middle - delta])) {\n\t\t\t*split_index = middle - delta;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* For even counts, don't walk off the end */\n\t\tif ((middle + delta + 1) == num_used)\n\t\t\tcontinue;\n\n\t\t/* Now try delta past middle */\n\t\tif (ocfs2_refcount_rec_no_intersect(\n\t\t\t\t\t&rl->rl_recs[middle + delta],\n\t\t\t\t\t&rl->rl_recs[middle + delta + 1])) {\n\t\t\t*split_index = middle + delta + 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (delta >= middle)\n\t\treturn -ENOSPC;\n\n\t*split_pos = ocfs2_get_ref_rec_low_cpos(&rl->rl_recs[*split_index]);\n\treturn 0;\n}"
  },
  {
    "function_name": "swap_refcount_rec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "1407-1414",
    "snippet": "static void swap_refcount_rec(void *a, void *b, int size)\n{\n\tstruct ocfs2_refcount_rec *l = a, *r = b, tmp;\n\n\ttmp = *l;\n\t*l = *r;\n\t*r = tmp;\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic void swap_refcount_rec(void *a, void *b, int size)\n{\n\tstruct ocfs2_refcount_rec *l = a, *r = b, tmp;\n\n\ttmp = *l;\n\t*l = *r;\n\t*r = tmp;\n}"
  },
  {
    "function_name": "cmp_refcount_rec_by_cpos",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "1394-1405",
    "snippet": "static int cmp_refcount_rec_by_cpos(const void *a, const void *b)\n{\n\tconst struct ocfs2_refcount_rec *l = a, *r = b;\n\tu64 l_cpos = le64_to_cpu(l->r_cpos);\n\tu64 r_cpos = le64_to_cpu(r->r_cpos);\n\n\tif (l_cpos > r_cpos)\n\t\treturn 1;\n\tif (l_cpos < r_cpos)\n\t\treturn -1;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "r->r_cpos"
          ],
          "line": 1398
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int cmp_refcount_rec_by_cpos(const void *a, const void *b)\n{\n\tconst struct ocfs2_refcount_rec *l = a, *r = b;\n\tu64 l_cpos = le64_to_cpu(l->r_cpos);\n\tu64 r_cpos = le64_to_cpu(r->r_cpos);\n\n\tif (l_cpos > r_cpos)\n\t\treturn 1;\n\tif (l_cpos < r_cpos)\n\t\treturn -1;\n\treturn 0;\n}"
  },
  {
    "function_name": "cmp_refcount_rec_by_low_cpos",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "1381-1392",
    "snippet": "static int cmp_refcount_rec_by_low_cpos(const void *a, const void *b)\n{\n\tconst struct ocfs2_refcount_rec *l = a, *r = b;\n\tu32 l_cpos = ocfs2_get_ref_rec_low_cpos(l);\n\tu32 r_cpos = ocfs2_get_ref_rec_low_cpos(r);\n\n\tif (l_cpos > r_cpos)\n\t\treturn 1;\n\tif (l_cpos < r_cpos)\n\t\treturn -1;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_get_ref_rec_low_cpos",
          "args": [
            "r"
          ],
          "line": 1385
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_get_ref_rec_low_cpos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1474-1478",
          "snippet": "static inline u32\nocfs2_get_ref_rec_low_cpos(const struct ocfs2_refcount_rec *rec)\n{\n\treturn le64_to_cpu(rec->r_cpos) & OCFS2_32BIT_POS_MASK;\n}",
          "includes": [],
          "macros_used": [
            "#define OCFS2_32BIT_POS_MASK\t\t(0xffffffffULL)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define OCFS2_32BIT_POS_MASK\t\t(0xffffffffULL)\n\nstatic inline u32\nocfs2_get_ref_rec_low_cpos(const struct ocfs2_refcount_rec *rec)\n{\n\treturn le64_to_cpu(rec->r_cpos) & OCFS2_32BIT_POS_MASK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int cmp_refcount_rec_by_low_cpos(const void *a, const void *b)\n{\n\tconst struct ocfs2_refcount_rec *l = a, *r = b;\n\tu32 l_cpos = ocfs2_get_ref_rec_low_cpos(l);\n\tu32 r_cpos = ocfs2_get_ref_rec_low_cpos(r);\n\n\tif (l_cpos > r_cpos)\n\t\treturn 1;\n\tif (l_cpos < r_cpos)\n\t\treturn -1;\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_refcount_rec_no_intersect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "1371-1379",
    "snippet": "static int ocfs2_refcount_rec_no_intersect(struct ocfs2_refcount_rec *prev,\n\t\t\t\t\t   struct ocfs2_refcount_rec *next)\n{\n\tif (ocfs2_get_ref_rec_low_cpos(prev) + le32_to_cpu(prev->r_clusters) <=\n\t\tocfs2_get_ref_rec_low_cpos(next))\n\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_get_ref_rec_low_cpos",
          "args": [
            "next"
          ],
          "line": 1375
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_get_ref_rec_low_cpos",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1474-1478",
          "snippet": "static inline u32\nocfs2_get_ref_rec_low_cpos(const struct ocfs2_refcount_rec *rec)\n{\n\treturn le64_to_cpu(rec->r_cpos) & OCFS2_32BIT_POS_MASK;\n}",
          "includes": [],
          "macros_used": [
            "#define OCFS2_32BIT_POS_MASK\t\t(0xffffffffULL)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#define OCFS2_32BIT_POS_MASK\t\t(0xffffffffULL)\n\nstatic inline u32\nocfs2_get_ref_rec_low_cpos(const struct ocfs2_refcount_rec *rec)\n{\n\treturn le64_to_cpu(rec->r_cpos) & OCFS2_32BIT_POS_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "prev->r_clusters"
          ],
          "line": 1374
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_refcount_rec_no_intersect(struct ocfs2_refcount_rec *prev,\n\t\t\t\t\t   struct ocfs2_refcount_rec *next)\n{\n\tif (ocfs2_get_ref_rec_low_cpos(prev) + le32_to_cpu(prev->r_clusters) <=\n\t\tocfs2_get_ref_rec_low_cpos(next))\n\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_expand_inline_ref_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "1286-1369",
    "snippet": "static int ocfs2_expand_inline_ref_root(handle_t *handle,\n\t\t\t\t\tstruct ocfs2_caching_info *ci,\n\t\t\t\t\tstruct buffer_head *ref_root_bh,\n\t\t\t\t\tstruct buffer_head **ref_leaf_bh,\n\t\t\t\t\tstruct ocfs2_alloc_context *meta_ac)\n{\n\tint ret;\n\tu16 suballoc_bit_start;\n\tu32 num_got;\n\tu64 suballoc_loc, blkno;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\n\tstruct buffer_head *new_bh = NULL;\n\tstruct ocfs2_refcount_block *new_rb;\n\tstruct ocfs2_refcount_block *root_rb =\n\t\t\t(struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\n\tret = ocfs2_journal_access_rb(handle, ci, ref_root_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_claim_metadata(handle, meta_ac, 1, &suballoc_loc,\n\t\t\t\t   &suballoc_bit_start, &num_got,\n\t\t\t\t   &blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tnew_bh = sb_getblk(sb, blkno);\n\tif (new_bh == NULL) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tocfs2_set_new_buffer_uptodate(ci, new_bh);\n\n\tret = ocfs2_journal_access_rb(handle, ci, new_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Initialize ocfs2_refcount_block.\n\t * It should contain the same information as the old root.\n\t * so just memcpy it and change the corresponding field.\n\t */\n\tmemcpy(new_bh->b_data, ref_root_bh->b_data, sb->s_blocksize);\n\n\tnew_rb = (struct ocfs2_refcount_block *)new_bh->b_data;\n\tnew_rb->rf_suballoc_slot = cpu_to_le16(meta_ac->ac_alloc_slot);\n\tnew_rb->rf_suballoc_loc = cpu_to_le64(suballoc_loc);\n\tnew_rb->rf_suballoc_bit = cpu_to_le16(suballoc_bit_start);\n\tnew_rb->rf_blkno = cpu_to_le64(blkno);\n\tnew_rb->rf_cpos = cpu_to_le32(0);\n\tnew_rb->rf_parent = cpu_to_le64(ref_root_bh->b_blocknr);\n\tnew_rb->rf_flags = cpu_to_le32(OCFS2_REFCOUNT_LEAF_FL);\n\tocfs2_journal_dirty(handle, new_bh);\n\n\t/* Now change the root. */\n\tmemset(&root_rb->rf_list, 0, sb->s_blocksize -\n\t       offsetof(struct ocfs2_refcount_block, rf_list));\n\troot_rb->rf_list.l_count = cpu_to_le16(ocfs2_extent_recs_per_rb(sb));\n\troot_rb->rf_clusters = cpu_to_le32(1);\n\troot_rb->rf_list.l_next_free_rec = cpu_to_le16(1);\n\troot_rb->rf_list.l_recs[0].e_blkno = cpu_to_le64(blkno);\n\troot_rb->rf_list.l_recs[0].e_leaf_clusters = cpu_to_le16(1);\n\troot_rb->rf_flags = cpu_to_le32(OCFS2_REFCOUNT_TREE_FL);\n\n\tocfs2_journal_dirty(handle, ref_root_bh);\n\n\ttrace_ocfs2_expand_inline_ref_root((unsigned long long)blkno,\n\t\tle16_to_cpu(new_rb->rf_records.rl_used));\n\n\t*ref_leaf_bh = new_bh;\n\tnew_bh = NULL;\nout:\n\tbrelse(new_bh);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "new_bh"
          ],
          "line": 1367
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_expand_inline_ref_root",
          "args": [
            "(unsigned long long)blkno",
            "le16_to_cpu(new_rb->rf_records.rl_used)"
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "new_rb->rf_records.rl_used"
          ],
          "line": 1362
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "ref_root_bh"
          ],
          "line": 1359
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "OCFS2_REFCOUNT_TREE_FL"
          ],
          "line": 1357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "1"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "blkno"
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "1"
          ],
          "line": 1354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "1"
          ],
          "line": 1353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "ocfs2_extent_recs_per_rb(sb)"
          ],
          "line": 1352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_extent_recs_per_rb",
          "args": [
            "sb"
          ],
          "line": 1352
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_extent_recs_per_rb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1454-1462",
          "snippet": "static inline u16 ocfs2_extent_recs_per_rb(struct super_block *sb)\n{\n\tint size;\n\n\tsize = sb->s_blocksize -\n\t\toffsetof(struct ocfs2_refcount_block, rf_list.l_recs);\n\n\treturn size / sizeof(struct ocfs2_extent_rec);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u16 ocfs2_extent_recs_per_rb(struct super_block *sb)\n{\n\tint size;\n\n\tsize = sb->s_blocksize -\n\t\toffsetof(struct ocfs2_refcount_block, rf_list.l_recs);\n\n\treturn size / sizeof(struct ocfs2_extent_rec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&root_rb->rf_list",
            "0",
            "sb->s_blocksize -\n\t       offsetof(struct ocfs2_refcount_block, rf_list)"
          ],
          "line": 1350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "OCFS2_REFCOUNT_LEAF_FL"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "ref_root_bh->b_blocknr"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "0"
          ],
          "line": 1344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "blkno"
          ],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "suballoc_bit_start"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "suballoc_loc"
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "meta_ac->ac_alloc_slot"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "new_bh->b_data",
            "ref_root_bh->b_data",
            "sb->s_blocksize"
          ],
          "line": 1337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_rb",
          "args": [
            "handle",
            "ci",
            "new_bh",
            "OCFS2_JOURNAL_ACCESS_CREATE"
          ],
          "line": 1325
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_rb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "722-727",
          "snippet": "int ocfs2_journal_access_rb(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &rb_triggers,\n\t\t\t\t      type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers rb_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_refcount_block, rf_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers rb_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_refcount_block, rf_check),\n};\n\nint ocfs2_journal_access_rb(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &rb_triggers,\n\t\t\t\t      type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_set_new_buffer_uptodate",
          "args": [
            "ci",
            "new_bh"
          ],
          "line": 1323
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_new_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "521-532",
          "snippet": "void ocfs2_set_new_buffer_uptodate(struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t/* This should definitely *not* exist in our cache */\n\tBUG_ON(ocfs2_buffer_cached(ci, bh));\n\n\tset_buffer_uptodate(bh);\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tocfs2_set_buffer_uptodate(ci, bh);\n\tocfs2_metadata_cache_io_unlock(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_set_new_buffer_uptodate(struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t/* This should definitely *not* exist in our cache */\n\tBUG_ON(ocfs2_buffer_cached(ci, bh));\n\n\tset_buffer_uptodate(bh);\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tocfs2_set_buffer_uptodate(ci, bh);\n\tocfs2_metadata_cache_io_unlock(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "sb",
            "blkno"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_claim_metadata",
          "args": [
            "handle",
            "meta_ac",
            "1",
            "&suballoc_loc",
            "&suballoc_bit_start",
            "&num_got",
            "&blkno"
          ],
          "line": 1309
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_claim_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "1993-2029",
          "snippet": "int ocfs2_claim_metadata(handle_t *handle,\n\t\t\t struct ocfs2_alloc_context *ac,\n\t\t\t u32 bits_wanted,\n\t\t\t u64 *suballoc_loc,\n\t\t\t u16 *suballoc_bit_start,\n\t\t\t unsigned int *num_bits,\n\t\t\t u64 *blkno_start)\n{\n\tint status;\n\tstruct ocfs2_suballoc_result res = { .sr_blkno = 0, };\n\n\tBUG_ON(!ac);\n\tBUG_ON(ac->ac_bits_wanted < (ac->ac_bits_given + bits_wanted));\n\tBUG_ON(ac->ac_which != OCFS2_AC_USE_META);\n\n\tstatus = ocfs2_claim_suballoc_bits(ac,\n\t\t\t\t\t   handle,\n\t\t\t\t\t   bits_wanted,\n\t\t\t\t\t   1,\n\t\t\t\t\t   &res);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tatomic_inc(&OCFS2_SB(ac->ac_inode->i_sb)->alloc_stats.bg_allocs);\n\n\t*suballoc_loc = res.sr_bg_blkno;\n\t*suballoc_bit_start = res.sr_bit_offset;\n\t*blkno_start = res.sr_blkno;\n\tac->ac_bits_given += res.sr_bits;\n\t*num_bits = res.sr_bits;\n\tstatus = 0;\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);",
            "static int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);",
            "static int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);",
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);\nstatic int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);\nstatic int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint ocfs2_claim_metadata(handle_t *handle,\n\t\t\t struct ocfs2_alloc_context *ac,\n\t\t\t u32 bits_wanted,\n\t\t\t u64 *suballoc_loc,\n\t\t\t u16 *suballoc_bit_start,\n\t\t\t unsigned int *num_bits,\n\t\t\t u64 *blkno_start)\n{\n\tint status;\n\tstruct ocfs2_suballoc_result res = { .sr_blkno = 0, };\n\n\tBUG_ON(!ac);\n\tBUG_ON(ac->ac_bits_wanted < (ac->ac_bits_given + bits_wanted));\n\tBUG_ON(ac->ac_which != OCFS2_AC_USE_META);\n\n\tstatus = ocfs2_claim_suballoc_bits(ac,\n\t\t\t\t\t   handle,\n\t\t\t\t\t   bits_wanted,\n\t\t\t\t\t   1,\n\t\t\t\t\t   &res);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tatomic_inc(&OCFS2_SB(ac->ac_inode->i_sb)->alloc_stats.bg_allocs);\n\n\t*suballoc_loc = res.sr_bg_blkno;\n\t*suballoc_bit_start = res.sr_bit_offset;\n\t*blkno_start = res.sr_blkno;\n\tac->ac_bits_given += res.sr_bits;\n\t*num_bits = res.sr_bits;\n\tstatus = 0;\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_get_super",
          "args": [
            "ci"
          ],
          "line": 1296
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_get_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "79-84",
          "snippet": "struct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_expand_inline_ref_root(handle_t *handle,\n\t\t\t\t\tstruct ocfs2_caching_info *ci,\n\t\t\t\t\tstruct buffer_head *ref_root_bh,\n\t\t\t\t\tstruct buffer_head **ref_leaf_bh,\n\t\t\t\t\tstruct ocfs2_alloc_context *meta_ac)\n{\n\tint ret;\n\tu16 suballoc_bit_start;\n\tu32 num_got;\n\tu64 suballoc_loc, blkno;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\n\tstruct buffer_head *new_bh = NULL;\n\tstruct ocfs2_refcount_block *new_rb;\n\tstruct ocfs2_refcount_block *root_rb =\n\t\t\t(struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\n\tret = ocfs2_journal_access_rb(handle, ci, ref_root_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_claim_metadata(handle, meta_ac, 1, &suballoc_loc,\n\t\t\t\t   &suballoc_bit_start, &num_got,\n\t\t\t\t   &blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tnew_bh = sb_getblk(sb, blkno);\n\tif (new_bh == NULL) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\tocfs2_set_new_buffer_uptodate(ci, new_bh);\n\n\tret = ocfs2_journal_access_rb(handle, ci, new_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * Initialize ocfs2_refcount_block.\n\t * It should contain the same information as the old root.\n\t * so just memcpy it and change the corresponding field.\n\t */\n\tmemcpy(new_bh->b_data, ref_root_bh->b_data, sb->s_blocksize);\n\n\tnew_rb = (struct ocfs2_refcount_block *)new_bh->b_data;\n\tnew_rb->rf_suballoc_slot = cpu_to_le16(meta_ac->ac_alloc_slot);\n\tnew_rb->rf_suballoc_loc = cpu_to_le64(suballoc_loc);\n\tnew_rb->rf_suballoc_bit = cpu_to_le16(suballoc_bit_start);\n\tnew_rb->rf_blkno = cpu_to_le64(blkno);\n\tnew_rb->rf_cpos = cpu_to_le32(0);\n\tnew_rb->rf_parent = cpu_to_le64(ref_root_bh->b_blocknr);\n\tnew_rb->rf_flags = cpu_to_le32(OCFS2_REFCOUNT_LEAF_FL);\n\tocfs2_journal_dirty(handle, new_bh);\n\n\t/* Now change the root. */\n\tmemset(&root_rb->rf_list, 0, sb->s_blocksize -\n\t       offsetof(struct ocfs2_refcount_block, rf_list));\n\troot_rb->rf_list.l_count = cpu_to_le16(ocfs2_extent_recs_per_rb(sb));\n\troot_rb->rf_clusters = cpu_to_le32(1);\n\troot_rb->rf_list.l_next_free_rec = cpu_to_le16(1);\n\troot_rb->rf_list.l_recs[0].e_blkno = cpu_to_le64(blkno);\n\troot_rb->rf_list.l_recs[0].e_leaf_clusters = cpu_to_le16(1);\n\troot_rb->rf_flags = cpu_to_le32(OCFS2_REFCOUNT_TREE_FL);\n\n\tocfs2_journal_dirty(handle, ref_root_bh);\n\n\ttrace_ocfs2_expand_inline_ref_root((unsigned long long)blkno,\n\t\tle16_to_cpu(new_rb->rf_records.rl_used));\n\n\t*ref_leaf_bh = new_bh;\n\tnew_bh = NULL;\nout:\n\tbrelse(new_bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_change_refcount_rec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "1245-1284",
    "snippet": "static int ocfs2_change_refcount_rec(handle_t *handle,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *ref_leaf_bh,\n\t\t\t\t     int index, int merge, int change)\n{\n\tint ret;\n\tstruct ocfs2_refcount_block *rb =\n\t\t\t(struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\n\tstruct ocfs2_refcount_list *rl = &rb->rf_records;\n\tstruct ocfs2_refcount_rec *rec = &rl->rl_recs[index];\n\n\tret = ocfs2_journal_access_rb(handle, ci, ref_leaf_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_change_refcount_rec(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\tindex, le32_to_cpu(rec->r_refcount), change);\n\tle32_add_cpu(&rec->r_refcount, change);\n\n\tif (!rec->r_refcount) {\n\t\tif (index != le16_to_cpu(rl->rl_used) - 1) {\n\t\t\tmemmove(rec, rec + 1,\n\t\t\t\t(le16_to_cpu(rl->rl_used) - index - 1) *\n\t\t\t\tsizeof(struct ocfs2_refcount_rec));\n\t\t\tmemset(&rl->rl_recs[le16_to_cpu(rl->rl_used) - 1],\n\t\t\t       0, sizeof(struct ocfs2_refcount_rec));\n\t\t}\n\n\t\tle16_add_cpu(&rl->rl_used, -1);\n\t} else if (merge)\n\t\tocfs2_refcount_rec_merge(rb, index);\n\n\tocfs2_journal_dirty(handle, ref_leaf_bh);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "ref_leaf_bh"
          ],
          "line": 1281
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_refcount_rec_merge",
          "args": [
            "rb",
            "index"
          ],
          "line": 1279
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_refcount_rec_merge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "1221-1239",
          "snippet": "static void ocfs2_refcount_rec_merge(struct ocfs2_refcount_block *rb,\n\t\t\t\t     int index)\n{\n\tenum ocfs2_ref_rec_contig contig =\n\t\t\t\tocfs2_refcount_rec_contig(rb, index);\n\n\tif (contig == REF_CONTIG_NONE)\n\t\treturn;\n\n\tif (contig == REF_CONTIG_LEFT || contig == REF_CONTIG_LEFTRIGHT) {\n\t\tBUG_ON(index == 0);\n\t\tindex--;\n\t}\n\n\tocfs2_rotate_refcount_rec_left(rb, index);\n\n\tif (contig == REF_CONTIG_LEFTRIGHT)\n\t\tocfs2_rotate_refcount_rec_left(rb, index);\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic void ocfs2_refcount_rec_merge(struct ocfs2_refcount_block *rb,\n\t\t\t\t     int index)\n{\n\tenum ocfs2_ref_rec_contig contig =\n\t\t\t\tocfs2_refcount_rec_contig(rb, index);\n\n\tif (contig == REF_CONTIG_NONE)\n\t\treturn;\n\n\tif (contig == REF_CONTIG_LEFT || contig == REF_CONTIG_LEFTRIGHT) {\n\t\tBUG_ON(index == 0);\n\t\tindex--;\n\t}\n\n\tocfs2_rotate_refcount_rec_left(rb, index);\n\n\tif (contig == REF_CONTIG_LEFTRIGHT)\n\t\tocfs2_rotate_refcount_rec_left(rb, index);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&rl->rl_used",
            "-1"
          ],
          "line": 1277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&rl->rl_recs[le16_to_cpu(rl->rl_used) - 1]",
            "0",
            "sizeof(struct ocfs2_refcount_rec)"
          ],
          "line": 1273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "rl->rl_used"
          ],
          "line": 1273
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "rec",
            "rec + 1",
            "(le16_to_cpu(rl->rl_used) - index - 1) *\n\t\t\t\tsizeof(struct ocfs2_refcount_rec)"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&rec->r_refcount",
            "change"
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_change_refcount_rec",
          "args": [
            "(unsigned long long)ocfs2_metadata_cache_owner(ci)",
            "index",
            "le32_to_cpu(rec->r_refcount)",
            "change"
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rec->r_refcount"
          ],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_owner",
          "args": [
            "ci"
          ],
          "line": 1264
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "72-77",
          "snippet": "u64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nu64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_rb",
          "args": [
            "handle",
            "ci",
            "ref_leaf_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 1256
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_rb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "722-727",
          "snippet": "int ocfs2_journal_access_rb(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &rb_triggers,\n\t\t\t\t      type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers rb_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_refcount_block, rf_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers rb_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_refcount_block, rf_check),\n};\n\nint ocfs2_journal_access_rb(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &rb_triggers,\n\t\t\t\t      type);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_change_refcount_rec(handle_t *handle,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *ref_leaf_bh,\n\t\t\t\t     int index, int merge, int change)\n{\n\tint ret;\n\tstruct ocfs2_refcount_block *rb =\n\t\t\t(struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\n\tstruct ocfs2_refcount_list *rl = &rb->rf_records;\n\tstruct ocfs2_refcount_rec *rec = &rl->rl_recs[index];\n\n\tret = ocfs2_journal_access_rb(handle, ci, ref_leaf_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\ttrace_ocfs2_change_refcount_rec(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\tindex, le32_to_cpu(rec->r_refcount), change);\n\tle32_add_cpu(&rec->r_refcount, change);\n\n\tif (!rec->r_refcount) {\n\t\tif (index != le16_to_cpu(rl->rl_used) - 1) {\n\t\t\tmemmove(rec, rec + 1,\n\t\t\t\t(le16_to_cpu(rl->rl_used) - index - 1) *\n\t\t\t\tsizeof(struct ocfs2_refcount_rec));\n\t\t\tmemset(&rl->rl_recs[le16_to_cpu(rl->rl_used) - 1],\n\t\t\t       0, sizeof(struct ocfs2_refcount_rec));\n\t\t}\n\n\t\tle16_add_cpu(&rl->rl_used, -1);\n\t} else if (merge)\n\t\tocfs2_refcount_rec_merge(rb, index);\n\n\tocfs2_journal_dirty(handle, ref_leaf_bh);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_refcount_rec_merge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "1221-1239",
    "snippet": "static void ocfs2_refcount_rec_merge(struct ocfs2_refcount_block *rb,\n\t\t\t\t     int index)\n{\n\tenum ocfs2_ref_rec_contig contig =\n\t\t\t\tocfs2_refcount_rec_contig(rb, index);\n\n\tif (contig == REF_CONTIG_NONE)\n\t\treturn;\n\n\tif (contig == REF_CONTIG_LEFT || contig == REF_CONTIG_LEFTRIGHT) {\n\t\tBUG_ON(index == 0);\n\t\tindex--;\n\t}\n\n\tocfs2_rotate_refcount_rec_left(rb, index);\n\n\tif (contig == REF_CONTIG_LEFTRIGHT)\n\t\tocfs2_rotate_refcount_rec_left(rb, index);\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_rotate_refcount_rec_left",
          "args": [
            "rb",
            "index"
          ],
          "line": 1238
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_rotate_refcount_rec_left",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "1198-1216",
          "snippet": "static void ocfs2_rotate_refcount_rec_left(struct ocfs2_refcount_block *rb,\n\t\t\t\t\t   int index)\n{\n\tBUG_ON(rb->rf_records.rl_recs[index].r_refcount !=\n\t       rb->rf_records.rl_recs[index+1].r_refcount);\n\n\tle32_add_cpu(&rb->rf_records.rl_recs[index].r_clusters,\n\t\t     le32_to_cpu(rb->rf_records.rl_recs[index+1].r_clusters));\n\n\tif (index < le16_to_cpu(rb->rf_records.rl_used) - 2)\n\t\tmemmove(&rb->rf_records.rl_recs[index + 1],\n\t\t\t&rb->rf_records.rl_recs[index + 2],\n\t\t\tsizeof(struct ocfs2_refcount_rec) *\n\t\t\t(le16_to_cpu(rb->rf_records.rl_used) - index - 2));\n\n\tmemset(&rb->rf_records.rl_recs[le16_to_cpu(rb->rf_records.rl_used) - 1],\n\t       0, sizeof(struct ocfs2_refcount_rec));\n\tle16_add_cpu(&rb->rf_records.rl_used, -1);\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic void ocfs2_rotate_refcount_rec_left(struct ocfs2_refcount_block *rb,\n\t\t\t\t\t   int index)\n{\n\tBUG_ON(rb->rf_records.rl_recs[index].r_refcount !=\n\t       rb->rf_records.rl_recs[index+1].r_refcount);\n\n\tle32_add_cpu(&rb->rf_records.rl_recs[index].r_clusters,\n\t\t     le32_to_cpu(rb->rf_records.rl_recs[index+1].r_clusters));\n\n\tif (index < le16_to_cpu(rb->rf_records.rl_used) - 2)\n\t\tmemmove(&rb->rf_records.rl_recs[index + 1],\n\t\t\t&rb->rf_records.rl_recs[index + 2],\n\t\t\tsizeof(struct ocfs2_refcount_rec) *\n\t\t\t(le16_to_cpu(rb->rf_records.rl_used) - index - 2));\n\n\tmemset(&rb->rf_records.rl_recs[le16_to_cpu(rb->rf_records.rl_used) - 1],\n\t       0, sizeof(struct ocfs2_refcount_rec));\n\tle16_add_cpu(&rb->rf_records.rl_used, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "index == 0"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_refcount_rec_contig",
          "args": [
            "rb",
            "index"
          ],
          "line": 1225
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_refcount_rec_contig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "1173-1196",
          "snippet": "static enum ocfs2_ref_rec_contig\n\tocfs2_refcount_rec_contig(struct ocfs2_refcount_block *rb,\n\t\t\t\t  int index)\n{\n\tenum ocfs2_ref_rec_contig ret = REF_CONTIG_NONE;\n\n\tif (index < le16_to_cpu(rb->rf_records.rl_used) - 1)\n\t\tret = ocfs2_refcount_rec_adjacent(rb, index);\n\n\tif (index > 0) {\n\t\tenum ocfs2_ref_rec_contig tmp;\n\n\t\ttmp = ocfs2_refcount_rec_adjacent(rb, index - 1);\n\n\t\tif (tmp == REF_CONTIG_RIGHT) {\n\t\t\tif (ret == REF_CONTIG_RIGHT)\n\t\t\t\tret = REF_CONTIG_LEFTRIGHT;\n\t\t\telse\n\t\t\t\tret = REF_CONTIG_LEFT;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic enum ocfs2_ref_rec_contig\n\tocfs2_refcount_rec_contig(struct ocfs2_refcount_block *rb,\n\t\t\t\t  int index)\n{\n\tenum ocfs2_ref_rec_contig ret = REF_CONTIG_NONE;\n\n\tif (index < le16_to_cpu(rb->rf_records.rl_used) - 1)\n\t\tret = ocfs2_refcount_rec_adjacent(rb, index);\n\n\tif (index > 0) {\n\t\tenum ocfs2_ref_rec_contig tmp;\n\n\t\ttmp = ocfs2_refcount_rec_adjacent(rb, index - 1);\n\n\t\tif (tmp == REF_CONTIG_RIGHT) {\n\t\t\tif (ret == REF_CONTIG_RIGHT)\n\t\t\t\tret = REF_CONTIG_LEFTRIGHT;\n\t\t\telse\n\t\t\t\tret = REF_CONTIG_LEFT;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic void ocfs2_refcount_rec_merge(struct ocfs2_refcount_block *rb,\n\t\t\t\t     int index)\n{\n\tenum ocfs2_ref_rec_contig contig =\n\t\t\t\tocfs2_refcount_rec_contig(rb, index);\n\n\tif (contig == REF_CONTIG_NONE)\n\t\treturn;\n\n\tif (contig == REF_CONTIG_LEFT || contig == REF_CONTIG_LEFTRIGHT) {\n\t\tBUG_ON(index == 0);\n\t\tindex--;\n\t}\n\n\tocfs2_rotate_refcount_rec_left(rb, index);\n\n\tif (contig == REF_CONTIG_LEFTRIGHT)\n\t\tocfs2_rotate_refcount_rec_left(rb, index);\n}"
  },
  {
    "function_name": "ocfs2_rotate_refcount_rec_left",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "1198-1216",
    "snippet": "static void ocfs2_rotate_refcount_rec_left(struct ocfs2_refcount_block *rb,\n\t\t\t\t\t   int index)\n{\n\tBUG_ON(rb->rf_records.rl_recs[index].r_refcount !=\n\t       rb->rf_records.rl_recs[index+1].r_refcount);\n\n\tle32_add_cpu(&rb->rf_records.rl_recs[index].r_clusters,\n\t\t     le32_to_cpu(rb->rf_records.rl_recs[index+1].r_clusters));\n\n\tif (index < le16_to_cpu(rb->rf_records.rl_used) - 2)\n\t\tmemmove(&rb->rf_records.rl_recs[index + 1],\n\t\t\t&rb->rf_records.rl_recs[index + 2],\n\t\t\tsizeof(struct ocfs2_refcount_rec) *\n\t\t\t(le16_to_cpu(rb->rf_records.rl_used) - index - 2));\n\n\tmemset(&rb->rf_records.rl_recs[le16_to_cpu(rb->rf_records.rl_used) - 1],\n\t       0, sizeof(struct ocfs2_refcount_rec));\n\tle16_add_cpu(&rb->rf_records.rl_used, -1);\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le16_add_cpu",
          "args": [
            "&rb->rf_records.rl_used",
            "-1"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&rb->rf_records.rl_recs[le16_to_cpu(rb->rf_records.rl_used) - 1]",
            "0",
            "sizeof(struct ocfs2_refcount_rec)"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "rb->rf_records.rl_used"
          ],
          "line": 1213
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "&rb->rf_records.rl_recs[index + 1]",
            "&rb->rf_records.rl_recs[index + 2]",
            "sizeof(struct ocfs2_refcount_rec) *\n\t\t\t(le16_to_cpu(rb->rf_records.rl_used) - index - 2)"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&rb->rf_records.rl_recs[index].r_clusters",
            "le32_to_cpu(rb->rf_records.rl_recs[index+1].r_clusters)"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rb->rf_records.rl_recs[index+1].r_clusters"
          ],
          "line": 1205
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "rb->rf_records.rl_recs[index].r_refcount !=\n\t       rb->rf_records.rl_recs[index+1].r_refcount"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic void ocfs2_rotate_refcount_rec_left(struct ocfs2_refcount_block *rb,\n\t\t\t\t\t   int index)\n{\n\tBUG_ON(rb->rf_records.rl_recs[index].r_refcount !=\n\t       rb->rf_records.rl_recs[index+1].r_refcount);\n\n\tle32_add_cpu(&rb->rf_records.rl_recs[index].r_clusters,\n\t\t     le32_to_cpu(rb->rf_records.rl_recs[index+1].r_clusters));\n\n\tif (index < le16_to_cpu(rb->rf_records.rl_used) - 2)\n\t\tmemmove(&rb->rf_records.rl_recs[index + 1],\n\t\t\t&rb->rf_records.rl_recs[index + 2],\n\t\t\tsizeof(struct ocfs2_refcount_rec) *\n\t\t\t(le16_to_cpu(rb->rf_records.rl_used) - index - 2));\n\n\tmemset(&rb->rf_records.rl_recs[le16_to_cpu(rb->rf_records.rl_used) - 1],\n\t       0, sizeof(struct ocfs2_refcount_rec));\n\tle16_add_cpu(&rb->rf_records.rl_used, -1);\n}"
  },
  {
    "function_name": "ocfs2_refcount_rec_contig",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "1173-1196",
    "snippet": "static enum ocfs2_ref_rec_contig\n\tocfs2_refcount_rec_contig(struct ocfs2_refcount_block *rb,\n\t\t\t\t  int index)\n{\n\tenum ocfs2_ref_rec_contig ret = REF_CONTIG_NONE;\n\n\tif (index < le16_to_cpu(rb->rf_records.rl_used) - 1)\n\t\tret = ocfs2_refcount_rec_adjacent(rb, index);\n\n\tif (index > 0) {\n\t\tenum ocfs2_ref_rec_contig tmp;\n\n\t\ttmp = ocfs2_refcount_rec_adjacent(rb, index - 1);\n\n\t\tif (tmp == REF_CONTIG_RIGHT) {\n\t\t\tif (ret == REF_CONTIG_RIGHT)\n\t\t\t\tret = REF_CONTIG_LEFTRIGHT;\n\t\t\telse\n\t\t\t\tret = REF_CONTIG_LEFT;\n\t\t}\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_refcount_rec_adjacent",
          "args": [
            "rb",
            "index - 1"
          ],
          "line": 1185
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_refcount_rec_adjacent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "1159-1171",
          "snippet": "static enum ocfs2_ref_rec_contig\n\tocfs2_refcount_rec_adjacent(struct ocfs2_refcount_block *rb,\n\t\t\t\t    int index)\n{\n\tif ((rb->rf_records.rl_recs[index].r_refcount ==\n\t    rb->rf_records.rl_recs[index + 1].r_refcount) &&\n\t    (le64_to_cpu(rb->rf_records.rl_recs[index].r_cpos) +\n\t    le32_to_cpu(rb->rf_records.rl_recs[index].r_clusters) ==\n\t    le64_to_cpu(rb->rf_records.rl_recs[index + 1].r_cpos)))\n\t\treturn REF_CONTIG_RIGHT;\n\n\treturn REF_CONTIG_NONE;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic enum ocfs2_ref_rec_contig\n\tocfs2_refcount_rec_adjacent(struct ocfs2_refcount_block *rb,\n\t\t\t\t    int index)\n{\n\tif ((rb->rf_records.rl_recs[index].r_refcount ==\n\t    rb->rf_records.rl_recs[index + 1].r_refcount) &&\n\t    (le64_to_cpu(rb->rf_records.rl_recs[index].r_cpos) +\n\t    le32_to_cpu(rb->rf_records.rl_recs[index].r_clusters) ==\n\t    le64_to_cpu(rb->rf_records.rl_recs[index + 1].r_cpos)))\n\t\treturn REF_CONTIG_RIGHT;\n\n\treturn REF_CONTIG_NONE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "rb->rf_records.rl_used"
          ],
          "line": 1179
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic enum ocfs2_ref_rec_contig\n\tocfs2_refcount_rec_contig(struct ocfs2_refcount_block *rb,\n\t\t\t\t  int index)\n{\n\tenum ocfs2_ref_rec_contig ret = REF_CONTIG_NONE;\n\n\tif (index < le16_to_cpu(rb->rf_records.rl_used) - 1)\n\t\tret = ocfs2_refcount_rec_adjacent(rb, index);\n\n\tif (index > 0) {\n\t\tenum ocfs2_ref_rec_contig tmp;\n\n\t\ttmp = ocfs2_refcount_rec_adjacent(rb, index - 1);\n\n\t\tif (tmp == REF_CONTIG_RIGHT) {\n\t\t\tif (ret == REF_CONTIG_RIGHT)\n\t\t\t\tret = REF_CONTIG_LEFTRIGHT;\n\t\t\telse\n\t\t\t\tret = REF_CONTIG_LEFT;\n\t\t}\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_refcount_rec_adjacent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "1159-1171",
    "snippet": "static enum ocfs2_ref_rec_contig\n\tocfs2_refcount_rec_adjacent(struct ocfs2_refcount_block *rb,\n\t\t\t\t    int index)\n{\n\tif ((rb->rf_records.rl_recs[index].r_refcount ==\n\t    rb->rf_records.rl_recs[index + 1].r_refcount) &&\n\t    (le64_to_cpu(rb->rf_records.rl_recs[index].r_cpos) +\n\t    le32_to_cpu(rb->rf_records.rl_recs[index].r_clusters) ==\n\t    le64_to_cpu(rb->rf_records.rl_recs[index + 1].r_cpos)))\n\t\treturn REF_CONTIG_RIGHT;\n\n\treturn REF_CONTIG_NONE;\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "rb->rf_records.rl_recs[index + 1].r_cpos"
          ],
          "line": 1167
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rb->rf_records.rl_recs[index].r_clusters"
          ],
          "line": 1166
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic enum ocfs2_ref_rec_contig\n\tocfs2_refcount_rec_adjacent(struct ocfs2_refcount_block *rb,\n\t\t\t\t    int index)\n{\n\tif ((rb->rf_records.rl_recs[index].r_refcount ==\n\t    rb->rf_records.rl_recs[index + 1].r_refcount) &&\n\t    (le64_to_cpu(rb->rf_records.rl_recs[index].r_cpos) +\n\t    le32_to_cpu(rb->rf_records.rl_recs[index].r_clusters) ==\n\t    le64_to_cpu(rb->rf_records.rl_recs[index + 1].r_cpos)))\n\t\treturn REF_CONTIG_RIGHT;\n\n\treturn REF_CONTIG_NONE;\n}"
  },
  {
    "function_name": "ocfs2_get_refcount_rec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "1066-1150",
    "snippet": "static int ocfs2_get_refcount_rec(struct ocfs2_caching_info *ci,\n\t\t\t\t  struct buffer_head *ref_root_bh,\n\t\t\t\t  u64 cpos, unsigned int len,\n\t\t\t\t  struct ocfs2_refcount_rec *ret_rec,\n\t\t\t\t  int *index,\n\t\t\t\t  struct buffer_head **ret_bh)\n{\n\tint ret = 0, i, found;\n\tu32 low_cpos, uninitialized_var(cpos_end);\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec = NULL;\n\tstruct ocfs2_extent_block *eb = NULL;\n\tstruct buffer_head *eb_bh = NULL, *ref_leaf_bh = NULL;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\n\tstruct ocfs2_refcount_block *rb =\n\t\t\t(struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\n\tif (!(le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL)) {\n\t\tocfs2_find_refcount_rec_in_rl(ci, ref_root_bh, cpos, len,\n\t\t\t\t\t      ret_rec, index);\n\t\t*ret_bh = ref_root_bh;\n\t\tget_bh(ref_root_bh);\n\t\treturn 0;\n\t}\n\n\tel = &rb->rf_list;\n\tlow_cpos = cpos & OCFS2_32BIT_POS_MASK;\n\n\tif (el->l_tree_depth) {\n\t\tret = ocfs2_find_leaf(ci, el, low_cpos, &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tocfs2_error(sb,\n\t\t\t\"refcount tree %llu has non zero tree \"\n\t\t\t\"depth in leaf btree tree block %llu\\n\",\n\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t\t(unsigned long long)eb_bh->b_blocknr);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfound = 0;\n\tfor (i = le16_to_cpu(el->l_next_free_rec) - 1; i >= 0; i--) {\n\t\trec = &el->l_recs[i];\n\n\t\tif (le32_to_cpu(rec->e_cpos) <= low_cpos) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found) {\n\t\tret = ocfs2_get_refcount_cpos_end(ci, ref_root_bh,\n\t\t\t\t\t\t  eb, el, i, &cpos_end);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (cpos_end < low_cpos + len)\n\t\t\tlen = cpos_end - low_cpos;\n\t}\n\n\tret = ocfs2_read_refcount_block(ci, le64_to_cpu(rec->e_blkno),\n\t\t\t\t\t&ref_leaf_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_find_refcount_rec_in_rl(ci, ref_leaf_bh, cpos, len,\n\t\t\t\t      ret_rec, index);\n\t*ret_bh = ref_leaf_bh;\nout:\n\tbrelse(eb_bh);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "eb_bh"
          ],
          "line": 1148
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_find_refcount_rec_in_rl",
          "args": [
            "ci",
            "ref_leaf_bh",
            "cpos",
            "len",
            "ret_rec",
            "index"
          ],
          "line": 1144
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_refcount_rec_in_rl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "884-924",
          "snippet": "static void ocfs2_find_refcount_rec_in_rl(struct ocfs2_caching_info *ci,\n\t\t\t\t\t  struct buffer_head *ref_leaf_bh,\n\t\t\t\t\t  u64 cpos, unsigned int len,\n\t\t\t\t\t  struct ocfs2_refcount_rec *ret_rec,\n\t\t\t\t\t  int *index)\n{\n\tint i = 0;\n\tstruct ocfs2_refcount_block *rb =\n\t\t(struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\n\tstruct ocfs2_refcount_rec *rec = NULL;\n\n\tfor (; i < le16_to_cpu(rb->rf_records.rl_used); i++) {\n\t\trec = &rb->rf_records.rl_recs[i];\n\n\t\tif (le64_to_cpu(rec->r_cpos) +\n\t\t    le32_to_cpu(rec->r_clusters) <= cpos)\n\t\t\tcontinue;\n\t\telse if (le64_to_cpu(rec->r_cpos) > cpos)\n\t\t\tbreak;\n\n\t\t/* ok, cpos fail in this rec. Just return. */\n\t\tif (ret_rec)\n\t\t\t*ret_rec = *rec;\n\t\tgoto out;\n\t}\n\n\tif (ret_rec) {\n\t\t/* We meet with a hole here, so fake the rec. */\n\t\tret_rec->r_cpos = cpu_to_le64(cpos);\n\t\tret_rec->r_refcount = 0;\n\t\tif (i < le16_to_cpu(rb->rf_records.rl_used) &&\n\t\t    le64_to_cpu(rec->r_cpos) < cpos + len)\n\t\t\tret_rec->r_clusters =\n\t\t\t\tcpu_to_le32(le64_to_cpu(rec->r_cpos) - cpos);\n\t\telse\n\t\t\tret_rec->r_clusters = cpu_to_le32(len);\n\t}\n\nout:\n\t*index = i;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic void ocfs2_find_refcount_rec_in_rl(struct ocfs2_caching_info *ci,\n\t\t\t\t\t  struct buffer_head *ref_leaf_bh,\n\t\t\t\t\t  u64 cpos, unsigned int len,\n\t\t\t\t\t  struct ocfs2_refcount_rec *ret_rec,\n\t\t\t\t\t  int *index)\n{\n\tint i = 0;\n\tstruct ocfs2_refcount_block *rb =\n\t\t(struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\n\tstruct ocfs2_refcount_rec *rec = NULL;\n\n\tfor (; i < le16_to_cpu(rb->rf_records.rl_used); i++) {\n\t\trec = &rb->rf_records.rl_recs[i];\n\n\t\tif (le64_to_cpu(rec->r_cpos) +\n\t\t    le32_to_cpu(rec->r_clusters) <= cpos)\n\t\t\tcontinue;\n\t\telse if (le64_to_cpu(rec->r_cpos) > cpos)\n\t\t\tbreak;\n\n\t\t/* ok, cpos fail in this rec. Just return. */\n\t\tif (ret_rec)\n\t\t\t*ret_rec = *rec;\n\t\tgoto out;\n\t}\n\n\tif (ret_rec) {\n\t\t/* We meet with a hole here, so fake the rec. */\n\t\tret_rec->r_cpos = cpu_to_le64(cpos);\n\t\tret_rec->r_refcount = 0;\n\t\tif (i < le16_to_cpu(rb->rf_records.rl_used) &&\n\t\t    le64_to_cpu(rec->r_cpos) < cpos + len)\n\t\t\tret_rec->r_clusters =\n\t\t\t\tcpu_to_le32(le64_to_cpu(rec->r_cpos) - cpos);\n\t\telse\n\t\t\tret_rec->r_clusters = cpu_to_le32(len);\n\t}\n\nout:\n\t*index = i;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_refcount_block",
          "args": [
            "ci",
            "le64_to_cpu(rec->e_blkno)",
            "&ref_leaf_bh"
          ],
          "line": 1137
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_refcount_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "133-148",
          "snippet": "static int ocfs2_read_refcount_block(struct ocfs2_caching_info *ci,\n\t\t\t\t     u64 rb_blkno,\n\t\t\t\t     struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(ci, rb_blkno, &tmp,\n\t\t\t      ocfs2_validate_refcount_block);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_read_refcount_block(struct ocfs2_caching_info *ci,\n\t\t\t\t     u64 rb_blkno,\n\t\t\t\t     struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(ci, rb_blkno, &tmp,\n\t\t\t      ocfs2_validate_refcount_block);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "rec->e_blkno"
          ],
          "line": 1137
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_refcount_cpos_end",
          "args": [
            "ci",
            "ref_root_bh",
            "eb",
            "el",
            "i",
            "&cpos_end"
          ],
          "line": 1126
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_get_refcount_cpos_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "966-1057",
          "snippet": "static int ocfs2_get_refcount_cpos_end(struct ocfs2_caching_info *ci,\n\t\t\t\t       struct buffer_head *ref_root_bh,\n\t\t\t\t       struct ocfs2_extent_block *eb,\n\t\t\t\t       struct ocfs2_extent_list *el,\n\t\t\t\t       int index,  u32 *cpos_end)\n{\n\tint ret, i, subtree_root;\n\tu32 cpos;\n\tu64 blkno;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\n\tstruct ocfs2_path *left_path = NULL, *right_path = NULL;\n\tstruct ocfs2_extent_tree et;\n\tstruct ocfs2_extent_list *tmp_el;\n\n\tif (index < le16_to_cpu(el->l_next_free_rec) - 1) {\n\t\t/*\n\t\t * We have a extent rec after index, so just use the e_cpos\n\t\t * of the next extent rec.\n\t\t */\n\t\t*cpos_end = le32_to_cpu(el->l_recs[index+1].e_cpos);\n\t\treturn 0;\n\t}\n\n\tif (!eb || (eb && !eb->h_next_leaf_blk)) {\n\t\t/*\n\t\t * We are the last extent rec, so any high cpos should\n\t\t * be stored in this leaf refcount block.\n\t\t */\n\t\t*cpos_end = UINT_MAX;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the extent block isn't the last one, we have to find\n\t * the subtree root between this extent block and the next\n\t * leaf extent block and get the corresponding e_cpos from\n\t * the subroot. Otherwise we may corrupt the b-tree.\n\t */\n\tocfs2_init_refcount_extent_tree(&et, ci, ref_root_bh);\n\n\tleft_path = ocfs2_new_path_from_et(&et);\n\tif (!left_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tcpos = le32_to_cpu(eb->h_list.l_recs[index].e_cpos);\n\tret = ocfs2_find_path(ci, left_path, cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tright_path = ocfs2_new_path_from_path(left_path);\n\tif (!right_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_cpos_for_right_leaf(sb, left_path, &cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_path(ci, right_path, cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tsubtree_root = ocfs2_find_subtree_root(&et, left_path,\n\t\t\t\t\t       right_path);\n\n\ttmp_el = left_path->p_node[subtree_root].el;\n\tblkno = left_path->p_node[subtree_root+1].bh->b_blocknr;\n\tfor (i = 0; i < le16_to_cpu(tmp_el->l_next_free_rec); i++) {\n\t\tif (le64_to_cpu(tmp_el->l_recs[i].e_blkno) == blkno) {\n\t\t\t*cpos_end = le32_to_cpu(tmp_el->l_recs[i+1].e_cpos);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tBUG_ON(i == le16_to_cpu(tmp_el->l_next_free_rec));\n\nout:\n\tocfs2_free_path(left_path);\n\tocfs2_free_path(right_path);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_get_refcount_cpos_end(struct ocfs2_caching_info *ci,\n\t\t\t\t       struct buffer_head *ref_root_bh,\n\t\t\t\t       struct ocfs2_extent_block *eb,\n\t\t\t\t       struct ocfs2_extent_list *el,\n\t\t\t\t       int index,  u32 *cpos_end)\n{\n\tint ret, i, subtree_root;\n\tu32 cpos;\n\tu64 blkno;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\n\tstruct ocfs2_path *left_path = NULL, *right_path = NULL;\n\tstruct ocfs2_extent_tree et;\n\tstruct ocfs2_extent_list *tmp_el;\n\n\tif (index < le16_to_cpu(el->l_next_free_rec) - 1) {\n\t\t/*\n\t\t * We have a extent rec after index, so just use the e_cpos\n\t\t * of the next extent rec.\n\t\t */\n\t\t*cpos_end = le32_to_cpu(el->l_recs[index+1].e_cpos);\n\t\treturn 0;\n\t}\n\n\tif (!eb || (eb && !eb->h_next_leaf_blk)) {\n\t\t/*\n\t\t * We are the last extent rec, so any high cpos should\n\t\t * be stored in this leaf refcount block.\n\t\t */\n\t\t*cpos_end = UINT_MAX;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the extent block isn't the last one, we have to find\n\t * the subtree root between this extent block and the next\n\t * leaf extent block and get the corresponding e_cpos from\n\t * the subroot. Otherwise we may corrupt the b-tree.\n\t */\n\tocfs2_init_refcount_extent_tree(&et, ci, ref_root_bh);\n\n\tleft_path = ocfs2_new_path_from_et(&et);\n\tif (!left_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tcpos = le32_to_cpu(eb->h_list.l_recs[index].e_cpos);\n\tret = ocfs2_find_path(ci, left_path, cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tright_path = ocfs2_new_path_from_path(left_path);\n\tif (!right_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_cpos_for_right_leaf(sb, left_path, &cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_path(ci, right_path, cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tsubtree_root = ocfs2_find_subtree_root(&et, left_path,\n\t\t\t\t\t       right_path);\n\n\ttmp_el = left_path->p_node[subtree_root].el;\n\tblkno = left_path->p_node[subtree_root+1].bh->b_blocknr;\n\tfor (i = 0; i < le16_to_cpu(tmp_el->l_next_free_rec); i++) {\n\t\tif (le64_to_cpu(tmp_el->l_recs[i].e_blkno) == blkno) {\n\t\t\t*cpos_end = le32_to_cpu(tmp_el->l_recs[i+1].e_cpos);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tBUG_ON(i == le16_to_cpu(tmp_el->l_next_free_rec));\n\nout:\n\tocfs2_free_path(left_path);\n\tocfs2_free_path(right_path);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rec->e_cpos"
          ],
          "line": 1119
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "el->l_next_free_rec"
          ],
          "line": 1116
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_error",
          "args": [
            "sb",
            "\"refcount tree %llu has non zero tree \"\n\t\t\t\"depth in leaf btree tree block %llu\\n\"",
            "(unsigned long long)ocfs2_metadata_cache_owner(ci)",
            "(unsigned long long)eb_bh->b_blocknr"
          ],
          "line": 1105
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2568-2584",
          "snippet": "void __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic char error_buf[1024];\n\nvoid __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_owner",
          "args": [
            "ci"
          ],
          "line": 1108
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "72-77",
          "snippet": "u64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nu64 ocfs2_metadata_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_owner(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_leaf",
          "args": [
            "ci",
            "el",
            "low_cpos",
            "&eb_bh"
          ],
          "line": 1095
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "1917-1933",
          "snippet": "int ocfs2_find_leaf(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_extent_list *root_el, u32 cpos,\n\t\t    struct buffer_head **leaf_bh)\n{\n\tint ret;\n\tstruct buffer_head *bh = NULL;\n\n\tret = __ocfs2_find_path(ci, root_el, cpos, find_leaf_ins, &bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t*leaf_bh = bh;\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_find_leaf(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_extent_list *root_el, u32 cpos,\n\t\t    struct buffer_head **leaf_bh)\n{\n\tint ret;\n\tstruct buffer_head *bh = NULL;\n\n\tret = __ocfs2_find_path(ci, root_el, cpos, find_leaf_ins, &bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\t*leaf_bh = bh;\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_bh",
          "args": [
            "ref_root_bh"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_get_super",
          "args": [
            "ci"
          ],
          "line": 1079
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_get_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "79-84",
          "snippet": "struct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_get_refcount_rec(struct ocfs2_caching_info *ci,\n\t\t\t\t  struct buffer_head *ref_root_bh,\n\t\t\t\t  u64 cpos, unsigned int len,\n\t\t\t\t  struct ocfs2_refcount_rec *ret_rec,\n\t\t\t\t  int *index,\n\t\t\t\t  struct buffer_head **ret_bh)\n{\n\tint ret = 0, i, found;\n\tu32 low_cpos, uninitialized_var(cpos_end);\n\tstruct ocfs2_extent_list *el;\n\tstruct ocfs2_extent_rec *rec = NULL;\n\tstruct ocfs2_extent_block *eb = NULL;\n\tstruct buffer_head *eb_bh = NULL, *ref_leaf_bh = NULL;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\n\tstruct ocfs2_refcount_block *rb =\n\t\t\t(struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\n\tif (!(le32_to_cpu(rb->rf_flags) & OCFS2_REFCOUNT_TREE_FL)) {\n\t\tocfs2_find_refcount_rec_in_rl(ci, ref_root_bh, cpos, len,\n\t\t\t\t\t      ret_rec, index);\n\t\t*ret_bh = ref_root_bh;\n\t\tget_bh(ref_root_bh);\n\t\treturn 0;\n\t}\n\n\tel = &rb->rf_list;\n\tlow_cpos = cpos & OCFS2_32BIT_POS_MASK;\n\n\tif (el->l_tree_depth) {\n\t\tret = ocfs2_find_leaf(ci, el, low_cpos, &eb_bh);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\teb = (struct ocfs2_extent_block *) eb_bh->b_data;\n\t\tel = &eb->h_list;\n\n\t\tif (el->l_tree_depth) {\n\t\t\tocfs2_error(sb,\n\t\t\t\"refcount tree %llu has non zero tree \"\n\t\t\t\"depth in leaf btree tree block %llu\\n\",\n\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t\t(unsigned long long)eb_bh->b_blocknr);\n\t\t\tret = -EROFS;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfound = 0;\n\tfor (i = le16_to_cpu(el->l_next_free_rec) - 1; i >= 0; i--) {\n\t\trec = &el->l_recs[i];\n\n\t\tif (le32_to_cpu(rec->e_cpos) <= low_cpos) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found) {\n\t\tret = ocfs2_get_refcount_cpos_end(ci, ref_root_bh,\n\t\t\t\t\t\t  eb, el, i, &cpos_end);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (cpos_end < low_cpos + len)\n\t\t\tlen = cpos_end - low_cpos;\n\t}\n\n\tret = ocfs2_read_refcount_block(ci, le64_to_cpu(rec->e_blkno),\n\t\t\t\t\t&ref_leaf_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tocfs2_find_refcount_rec_in_rl(ci, ref_leaf_bh, cpos, len,\n\t\t\t\t      ret_rec, index);\n\t*ret_bh = ref_leaf_bh;\nout:\n\tbrelse(eb_bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_get_refcount_cpos_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "966-1057",
    "snippet": "static int ocfs2_get_refcount_cpos_end(struct ocfs2_caching_info *ci,\n\t\t\t\t       struct buffer_head *ref_root_bh,\n\t\t\t\t       struct ocfs2_extent_block *eb,\n\t\t\t\t       struct ocfs2_extent_list *el,\n\t\t\t\t       int index,  u32 *cpos_end)\n{\n\tint ret, i, subtree_root;\n\tu32 cpos;\n\tu64 blkno;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\n\tstruct ocfs2_path *left_path = NULL, *right_path = NULL;\n\tstruct ocfs2_extent_tree et;\n\tstruct ocfs2_extent_list *tmp_el;\n\n\tif (index < le16_to_cpu(el->l_next_free_rec) - 1) {\n\t\t/*\n\t\t * We have a extent rec after index, so just use the e_cpos\n\t\t * of the next extent rec.\n\t\t */\n\t\t*cpos_end = le32_to_cpu(el->l_recs[index+1].e_cpos);\n\t\treturn 0;\n\t}\n\n\tif (!eb || (eb && !eb->h_next_leaf_blk)) {\n\t\t/*\n\t\t * We are the last extent rec, so any high cpos should\n\t\t * be stored in this leaf refcount block.\n\t\t */\n\t\t*cpos_end = UINT_MAX;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the extent block isn't the last one, we have to find\n\t * the subtree root between this extent block and the next\n\t * leaf extent block and get the corresponding e_cpos from\n\t * the subroot. Otherwise we may corrupt the b-tree.\n\t */\n\tocfs2_init_refcount_extent_tree(&et, ci, ref_root_bh);\n\n\tleft_path = ocfs2_new_path_from_et(&et);\n\tif (!left_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tcpos = le32_to_cpu(eb->h_list.l_recs[index].e_cpos);\n\tret = ocfs2_find_path(ci, left_path, cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tright_path = ocfs2_new_path_from_path(left_path);\n\tif (!right_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_cpos_for_right_leaf(sb, left_path, &cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_path(ci, right_path, cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tsubtree_root = ocfs2_find_subtree_root(&et, left_path,\n\t\t\t\t\t       right_path);\n\n\ttmp_el = left_path->p_node[subtree_root].el;\n\tblkno = left_path->p_node[subtree_root+1].bh->b_blocknr;\n\tfor (i = 0; i < le16_to_cpu(tmp_el->l_next_free_rec); i++) {\n\t\tif (le64_to_cpu(tmp_el->l_recs[i].e_blkno) == blkno) {\n\t\t\t*cpos_end = le32_to_cpu(tmp_el->l_recs[i+1].e_cpos);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tBUG_ON(i == le16_to_cpu(tmp_el->l_next_free_rec));\n\nout:\n\tocfs2_free_path(left_path);\n\tocfs2_free_path(right_path);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_free_path",
          "args": [
            "right_path"
          ],
          "line": 1055
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "609-615",
          "snippet": "void ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_free_path(struct ocfs2_path *path)\n{\n\tif (path) {\n\t\tocfs2_reinit_path(path, 0);\n\t\tkfree(path);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "i == le16_to_cpu(tmp_el->l_next_free_rec)"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "tmp_el->l_next_free_rec"
          ],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "tmp_el->l_recs[i+1].e_cpos"
          ],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "tmp_el->l_recs[i].e_blkno"
          ],
          "line": 1045
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_find_subtree_root",
          "args": [
            "&et",
            "left_path",
            "right_path"
          ],
          "line": 1039
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_subtree_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "1737-1765",
          "snippet": "int ocfs2_find_subtree_root(struct ocfs2_extent_tree *et,\n\t\t\t    struct ocfs2_path *left,\n\t\t\t    struct ocfs2_path *right)\n{\n\tint i = 0;\n\n\t/*\n\t * Check that the caller passed in two paths from the same tree.\n\t */\n\tBUG_ON(path_root_bh(left) != path_root_bh(right));\n\n\tdo {\n\t\ti++;\n\n\t\t/*\n\t\t * The caller didn't pass two adjacent paths.\n\t\t */\n\t\tmlog_bug_on_msg(i > left->p_tree_depth,\n\t\t\t\t\"Owner %llu, left depth %u, right depth %u\\n\"\n\t\t\t\t\"left leaf blk %llu, right leaf blk %llu\\n\",\n\t\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\tleft->p_tree_depth, right->p_tree_depth,\n\t\t\t\t(unsigned long long)path_leaf_bh(left)->b_blocknr,\n\t\t\t\t(unsigned long long)path_leaf_bh(right)->b_blocknr);\n\t} while (left->p_node[i].bh->b_blocknr ==\n\t\t right->p_node[i].bh->b_blocknr);\n\n\treturn i - 1;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nint ocfs2_find_subtree_root(struct ocfs2_extent_tree *et,\n\t\t\t    struct ocfs2_path *left,\n\t\t\t    struct ocfs2_path *right)\n{\n\tint i = 0;\n\n\t/*\n\t * Check that the caller passed in two paths from the same tree.\n\t */\n\tBUG_ON(path_root_bh(left) != path_root_bh(right));\n\n\tdo {\n\t\ti++;\n\n\t\t/*\n\t\t * The caller didn't pass two adjacent paths.\n\t\t */\n\t\tmlog_bug_on_msg(i > left->p_tree_depth,\n\t\t\t\t\"Owner %llu, left depth %u, right depth %u\\n\"\n\t\t\t\t\"left leaf blk %llu, right leaf blk %llu\\n\",\n\t\t\t\t(unsigned long long)ocfs2_metadata_cache_owner(et->et_ci),\n\t\t\t\tleft->p_tree_depth, right->p_tree_depth,\n\t\t\t\t(unsigned long long)path_leaf_bh(left)->b_blocknr,\n\t\t\t\t(unsigned long long)path_leaf_bh(right)->b_blocknr);\n\t} while (left->p_node[i].bh->b_blocknr ==\n\t\t right->p_node[i].bh->b_blocknr);\n\n\treturn i - 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_path",
          "args": [
            "ci",
            "right_path",
            "cpos"
          ],
          "line": 1033
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "1885-1894",
          "snippet": "int ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_find_path(struct ocfs2_caching_info *ci,\n\t\t    struct ocfs2_path *path, u32 cpos)\n{\n\tstruct find_path_data data;\n\n\tdata.index = 1;\n\tdata.path = path;\n\treturn __ocfs2_find_path(ci, path_root_el(path), cpos,\n\t\t\t\t find_path_ins, &data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_cpos_for_right_leaf",
          "args": [
            "sb",
            "left_path",
            "&cpos"
          ],
          "line": 1027
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_cpos_for_right_leaf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "2820-2888",
          "snippet": "int ocfs2_find_cpos_for_right_leaf(struct super_block *sb,\n\t\t\t\t   struct ocfs2_path *path, u32 *cpos)\n{\n\tint i, j, ret = 0;\n\tu64 blkno;\n\tstruct ocfs2_extent_list *el;\n\n\t*cpos = 0;\n\n\tif (path->p_tree_depth == 0)\n\t\treturn 0;\n\n\tblkno = path_leaf_bh(path)->b_blocknr;\n\n\t/* Start at the tree node just above the leaf and work our way up. */\n\ti = path->p_tree_depth - 1;\n\twhile (i >= 0) {\n\t\tint next_free;\n\n\t\tel = path->p_node[i].el;\n\n\t\t/*\n\t\t * Find the extent record just after the one in our\n\t\t * path.\n\t\t */\n\t\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\t\tfor(j = 0; j < le16_to_cpu(el->l_next_free_rec); j++) {\n\t\t\tif (le64_to_cpu(el->l_recs[j].e_blkno) == blkno) {\n\t\t\t\tif (j == (next_free - 1)) {\n\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * We've determined that the\n\t\t\t\t\t\t * path specified is already\n\t\t\t\t\t\t * the rightmost one - return a\n\t\t\t\t\t\t * cpos of zero.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * The rightmost record points to our\n\t\t\t\t\t * leaf - we need to travel up the\n\t\t\t\t\t * tree one level.\n\t\t\t\t\t */\n\t\t\t\t\tgoto next_node;\n\t\t\t\t}\n\n\t\t\t\t*cpos = le32_to_cpu(el->l_recs[j + 1].e_cpos);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If we got here, we never found a valid node where\n\t\t * the tree indicated one should be.\n\t\t */\n\t\tocfs2_error(sb,\n\t\t\t    \"Invalid extent tree at extent block %llu\\n\",\n\t\t\t    (unsigned long long)blkno);\n\t\tret = -EROFS;\n\t\tgoto out;\n\nnext_node:\n\t\tblkno = path->p_node[i].bh->b_blocknr;\n\t\ti--;\n\t}\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,\n\t\t\t\t\t u64 blkno);\n\nint ocfs2_find_cpos_for_right_leaf(struct super_block *sb,\n\t\t\t\t   struct ocfs2_path *path, u32 *cpos)\n{\n\tint i, j, ret = 0;\n\tu64 blkno;\n\tstruct ocfs2_extent_list *el;\n\n\t*cpos = 0;\n\n\tif (path->p_tree_depth == 0)\n\t\treturn 0;\n\n\tblkno = path_leaf_bh(path)->b_blocknr;\n\n\t/* Start at the tree node just above the leaf and work our way up. */\n\ti = path->p_tree_depth - 1;\n\twhile (i >= 0) {\n\t\tint next_free;\n\n\t\tel = path->p_node[i].el;\n\n\t\t/*\n\t\t * Find the extent record just after the one in our\n\t\t * path.\n\t\t */\n\t\tnext_free = le16_to_cpu(el->l_next_free_rec);\n\t\tfor(j = 0; j < le16_to_cpu(el->l_next_free_rec); j++) {\n\t\t\tif (le64_to_cpu(el->l_recs[j].e_blkno) == blkno) {\n\t\t\t\tif (j == (next_free - 1)) {\n\t\t\t\t\tif (i == 0) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * We've determined that the\n\t\t\t\t\t\t * path specified is already\n\t\t\t\t\t\t * the rightmost one - return a\n\t\t\t\t\t\t * cpos of zero.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\t * The rightmost record points to our\n\t\t\t\t\t * leaf - we need to travel up the\n\t\t\t\t\t * tree one level.\n\t\t\t\t\t */\n\t\t\t\t\tgoto next_node;\n\t\t\t\t}\n\n\t\t\t\t*cpos = le32_to_cpu(el->l_recs[j + 1].e_cpos);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If we got here, we never found a valid node where\n\t\t * the tree indicated one should be.\n\t\t */\n\t\tocfs2_error(sb,\n\t\t\t    \"Invalid extent tree at extent block %llu\\n\",\n\t\t\t    (unsigned long long)blkno);\n\t\tret = -EROFS;\n\t\tgoto out;\n\nnext_node:\n\t\tblkno = path->p_node[i].bh->b_blocknr;\n\t\ti--;\n\t}\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_new_path_from_path",
          "args": [
            "left_path"
          ],
          "line": 1020
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_new_path_from_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "707-711",
          "snippet": "struct ocfs2_path *ocfs2_new_path_from_path(struct ocfs2_path *path)\n{\n\treturn ocfs2_new_path(path_root_bh(path), path_root_el(path),\n\t\t\t      path_root_access(path));\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct ocfs2_path *ocfs2_new_path_from_path(struct ocfs2_path *path)\n{\n\treturn ocfs2_new_path(path_root_bh(path), path_root_el(path),\n\t\t\t      path_root_access(path));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_new_path_from_et",
          "args": [
            "&et"
          ],
          "line": 1006
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_new_path_from_et",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "713-717",
          "snippet": "struct ocfs2_path *ocfs2_new_path_from_et(struct ocfs2_extent_tree *et)\n{\n\treturn ocfs2_new_path(et->et_root_bh, et->et_root_el,\n\t\t\t      et->et_root_journal_access);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\n\nstruct ocfs2_path *ocfs2_new_path_from_et(struct ocfs2_extent_tree *et)\n{\n\treturn ocfs2_new_path(et->et_root_bh, et->et_root_el,\n\t\t\t      et->et_root_journal_access);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_init_refcount_extent_tree",
          "args": [
            "&et",
            "ci",
            "ref_root_bh"
          ],
          "line": 1004
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_refcount_extent_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/alloc.c",
          "lines": "490-496",
          "snippet": "void ocfs2_init_refcount_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_rb,\n\t\t\t\t NULL, &ocfs2_refcount_tree_et_ops);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"file.h\"",
            "#include \"sysfile.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/swap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);",
            "static int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);",
            "static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);",
            "static struct ocfs2_extent_tree_operations ocfs2_refcount_tree_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_refcount_tree_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_refcount_tree_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_refcount_tree_update_clusters,\n\t.eo_fill_root_el\t= ocfs2_refcount_tree_fill_root_el,\n\t.eo_extent_contig\t= ocfs2_refcount_tree_extent_contig,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"file.h\"\n#include \"sysfile.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/blkdev.h>\n#include <linux/quotaops.h>\n#include <linux/swap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);\nstatic int ocfs2_dinode_sanity_check(struct ocfs2_extent_tree *et);\nstatic void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);\nstatic struct ocfs2_extent_tree_operations ocfs2_refcount_tree_et_ops = {\n\t.eo_set_last_eb_blk\t= ocfs2_refcount_tree_set_last_eb_blk,\n\t.eo_get_last_eb_blk\t= ocfs2_refcount_tree_get_last_eb_blk,\n\t.eo_update_clusters\t= ocfs2_refcount_tree_update_clusters,\n\t.eo_fill_root_el\t= ocfs2_refcount_tree_fill_root_el,\n\t.eo_extent_contig\t= ocfs2_refcount_tree_extent_contig,\n};\n\nvoid ocfs2_init_refcount_extent_tree(struct ocfs2_extent_tree *et,\n\t\t\t\t     struct ocfs2_caching_info *ci,\n\t\t\t\t     struct buffer_head *bh)\n{\n\t__ocfs2_init_extent_tree(et, ci, bh, ocfs2_journal_access_rb,\n\t\t\t\t NULL, &ocfs2_refcount_tree_et_ops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_get_super",
          "args": [
            "ci"
          ],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_get_super",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "79-84",
          "snippet": "struct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstruct super_block *ocfs2_metadata_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\treturn ci->ci_ops->co_get_super(ci);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_get_refcount_cpos_end(struct ocfs2_caching_info *ci,\n\t\t\t\t       struct buffer_head *ref_root_bh,\n\t\t\t\t       struct ocfs2_extent_block *eb,\n\t\t\t\t       struct ocfs2_extent_list *el,\n\t\t\t\t       int index,  u32 *cpos_end)\n{\n\tint ret, i, subtree_root;\n\tu32 cpos;\n\tu64 blkno;\n\tstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\n\tstruct ocfs2_path *left_path = NULL, *right_path = NULL;\n\tstruct ocfs2_extent_tree et;\n\tstruct ocfs2_extent_list *tmp_el;\n\n\tif (index < le16_to_cpu(el->l_next_free_rec) - 1) {\n\t\t/*\n\t\t * We have a extent rec after index, so just use the e_cpos\n\t\t * of the next extent rec.\n\t\t */\n\t\t*cpos_end = le32_to_cpu(el->l_recs[index+1].e_cpos);\n\t\treturn 0;\n\t}\n\n\tif (!eb || (eb && !eb->h_next_leaf_blk)) {\n\t\t/*\n\t\t * We are the last extent rec, so any high cpos should\n\t\t * be stored in this leaf refcount block.\n\t\t */\n\t\t*cpos_end = UINT_MAX;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the extent block isn't the last one, we have to find\n\t * the subtree root between this extent block and the next\n\t * leaf extent block and get the corresponding e_cpos from\n\t * the subroot. Otherwise we may corrupt the b-tree.\n\t */\n\tocfs2_init_refcount_extent_tree(&et, ci, ref_root_bh);\n\n\tleft_path = ocfs2_new_path_from_et(&et);\n\tif (!left_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tcpos = le32_to_cpu(eb->h_list.l_recs[index].e_cpos);\n\tret = ocfs2_find_path(ci, left_path, cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tright_path = ocfs2_new_path_from_path(left_path);\n\tif (!right_path) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_cpos_for_right_leaf(sb, left_path, &cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_find_path(ci, right_path, cpos);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tsubtree_root = ocfs2_find_subtree_root(&et, left_path,\n\t\t\t\t\t       right_path);\n\n\ttmp_el = left_path->p_node[subtree_root].el;\n\tblkno = left_path->p_node[subtree_root+1].bh->b_blocknr;\n\tfor (i = 0; i < le16_to_cpu(tmp_el->l_next_free_rec); i++) {\n\t\tif (le64_to_cpu(tmp_el->l_recs[i].e_blkno) == blkno) {\n\t\t\t*cpos_end = le32_to_cpu(tmp_el->l_recs[i+1].e_cpos);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tBUG_ON(i == le16_to_cpu(tmp_el->l_next_free_rec));\n\nout:\n\tocfs2_free_path(left_path);\n\tocfs2_free_path(right_path);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_try_remove_refcount_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "933-960",
    "snippet": "int ocfs2_try_remove_refcount_tree(struct inode *inode,\n\t\t\t\t   struct buffer_head *di_bh)\n{\n\tint ret;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tdown_write(&oi->ip_xattr_sem);\n\tdown_write(&oi->ip_alloc_sem);\n\n\tif (oi->ip_clusters)\n\t\tgoto out;\n\n\tif ((oi->ip_dyn_features & OCFS2_HAS_XATTR_FL) && di->i_xattr_loc)\n\t\tgoto out;\n\n\tif (oi->ip_dyn_features & OCFS2_INLINE_XATTR_FL &&\n\t    ocfs2_has_inline_xattr_value_outside(inode, di))\n\t\tgoto out;\n\n\tret = ocfs2_remove_refcount_tree(inode, di_bh);\n\tif (ret)\n\t\tmlog_errno(ret);\nout:\n\tup_write(&oi->ip_alloc_sem);\n\tup_write(&oi->ip_xattr_sem);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&oi->ip_xattr_sem"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&oi->ip_alloc_sem"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_remove_refcount_tree",
          "args": [
            "inode",
            "di_bh"
          ],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_remove_refcount_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "764-882",
          "snippet": "int ocfs2_remove_refcount_tree(struct inode *inode, struct buffer_head *di_bh)\n{\n\tint ret, delete_tree = 0;\n\thandle_t *handle = NULL;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_refcount_block *rb;\n\tstruct inode *alloc_inode = NULL;\n\tstruct buffer_head *alloc_bh = NULL;\n\tstruct buffer_head *blk_bh = NULL;\n\tstruct ocfs2_refcount_tree *ref_tree;\n\tint credits = OCFS2_REFCOUNT_TREE_REMOVE_CREDITS;\n\tu64 blk = 0, bg_blkno = 0, ref_blkno = le64_to_cpu(di->i_refcount_loc);\n\tu16 bit = 0;\n\n\tif (!(oi->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL))\n\t\treturn 0;\n\n\tBUG_ON(!ref_blkno);\n\tret = ocfs2_lock_refcount_tree(osb, ref_blkno, 1, &ref_tree, &blk_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\trb = (struct ocfs2_refcount_block *)blk_bh->b_data;\n\n\t/*\n\t * If we are the last user, we need to free the block.\n\t * So lock the allocator ahead.\n\t */\n\tif (le32_to_cpu(rb->rf_count) == 1) {\n\t\tblk = le64_to_cpu(rb->rf_blkno);\n\t\tbit = le16_to_cpu(rb->rf_suballoc_bit);\n\t\tif (rb->rf_suballoc_loc)\n\t\t\tbg_blkno = le64_to_cpu(rb->rf_suballoc_loc);\n\t\telse\n\t\t\tbg_blkno = ocfs2_which_suballoc_group(blk, bit);\n\n\t\talloc_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\tEXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\t\tle16_to_cpu(rb->rf_suballoc_slot));\n\t\tif (!alloc_inode) {\n\t\t\tret = -ENOMEM;\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\tmutex_lock(&alloc_inode->i_mutex);\n\n\t\tret = ocfs2_inode_lock(alloc_inode, &alloc_bh, 1);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_mutex;\n\t\t}\n\n\t\tcredits += OCFS2_SUBALLOC_FREE;\n\t}\n\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out_unlock;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tret = ocfs2_journal_access_rb(handle, &ref_tree->rf_ci, blk_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tspin_lock(&oi->ip_lock);\n\toi->ip_dyn_features &= ~OCFS2_HAS_REFCOUNT_FL;\n\tdi->i_dyn_features = cpu_to_le16(oi->ip_dyn_features);\n\tdi->i_refcount_loc = 0;\n\tspin_unlock(&oi->ip_lock);\n\tocfs2_journal_dirty(handle, di_bh);\n\n\tle32_add_cpu(&rb->rf_count , -1);\n\tocfs2_journal_dirty(handle, blk_bh);\n\n\tif (!rb->rf_count) {\n\t\tdelete_tree = 1;\n\t\tocfs2_erase_refcount_tree_from_list(osb, ref_tree);\n\t\tret = ocfs2_free_suballoc_bits(handle, alloc_inode,\n\t\t\t\t\t       alloc_bh, bit, bg_blkno, 1);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\nout_unlock:\n\tif (alloc_inode) {\n\t\tocfs2_inode_unlock(alloc_inode, 1);\n\t\tbrelse(alloc_bh);\n\t}\nout_mutex:\n\tif (alloc_inode) {\n\t\tmutex_unlock(&alloc_inode->i_mutex);\n\t\tiput(alloc_inode);\n\t}\nout:\n\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\tif (delete_tree)\n\t\tocfs2_refcount_tree_put(ref_tree);\n\tbrelse(blk_bh);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nint ocfs2_remove_refcount_tree(struct inode *inode, struct buffer_head *di_bh)\n{\n\tint ret, delete_tree = 0;\n\thandle_t *handle = NULL;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_refcount_block *rb;\n\tstruct inode *alloc_inode = NULL;\n\tstruct buffer_head *alloc_bh = NULL;\n\tstruct buffer_head *blk_bh = NULL;\n\tstruct ocfs2_refcount_tree *ref_tree;\n\tint credits = OCFS2_REFCOUNT_TREE_REMOVE_CREDITS;\n\tu64 blk = 0, bg_blkno = 0, ref_blkno = le64_to_cpu(di->i_refcount_loc);\n\tu16 bit = 0;\n\n\tif (!(oi->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL))\n\t\treturn 0;\n\n\tBUG_ON(!ref_blkno);\n\tret = ocfs2_lock_refcount_tree(osb, ref_blkno, 1, &ref_tree, &blk_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\trb = (struct ocfs2_refcount_block *)blk_bh->b_data;\n\n\t/*\n\t * If we are the last user, we need to free the block.\n\t * So lock the allocator ahead.\n\t */\n\tif (le32_to_cpu(rb->rf_count) == 1) {\n\t\tblk = le64_to_cpu(rb->rf_blkno);\n\t\tbit = le16_to_cpu(rb->rf_suballoc_bit);\n\t\tif (rb->rf_suballoc_loc)\n\t\t\tbg_blkno = le64_to_cpu(rb->rf_suballoc_loc);\n\t\telse\n\t\t\tbg_blkno = ocfs2_which_suballoc_group(blk, bit);\n\n\t\talloc_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\tEXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\t\tle16_to_cpu(rb->rf_suballoc_slot));\n\t\tif (!alloc_inode) {\n\t\t\tret = -ENOMEM;\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\tmutex_lock(&alloc_inode->i_mutex);\n\n\t\tret = ocfs2_inode_lock(alloc_inode, &alloc_bh, 1);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_mutex;\n\t\t}\n\n\t\tcredits += OCFS2_SUBALLOC_FREE;\n\t}\n\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out_unlock;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tret = ocfs2_journal_access_rb(handle, &ref_tree->rf_ci, blk_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tspin_lock(&oi->ip_lock);\n\toi->ip_dyn_features &= ~OCFS2_HAS_REFCOUNT_FL;\n\tdi->i_dyn_features = cpu_to_le16(oi->ip_dyn_features);\n\tdi->i_refcount_loc = 0;\n\tspin_unlock(&oi->ip_lock);\n\tocfs2_journal_dirty(handle, di_bh);\n\n\tle32_add_cpu(&rb->rf_count , -1);\n\tocfs2_journal_dirty(handle, blk_bh);\n\n\tif (!rb->rf_count) {\n\t\tdelete_tree = 1;\n\t\tocfs2_erase_refcount_tree_from_list(osb, ref_tree);\n\t\tret = ocfs2_free_suballoc_bits(handle, alloc_inode,\n\t\t\t\t\t       alloc_bh, bit, bg_blkno, 1);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\nout_unlock:\n\tif (alloc_inode) {\n\t\tocfs2_inode_unlock(alloc_inode, 1);\n\t\tbrelse(alloc_bh);\n\t}\nout_mutex:\n\tif (alloc_inode) {\n\t\tmutex_unlock(&alloc_inode->i_mutex);\n\t\tiput(alloc_inode);\n\t}\nout:\n\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\tif (delete_tree)\n\t\tocfs2_refcount_tree_put(ref_tree);\n\tbrelse(blk_bh);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_has_inline_xattr_value_outside",
          "args": [
            "inode",
            "di"
          ],
          "line": 950
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_has_inline_xattr_value_outside",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/xattr.c",
          "lines": "945-960",
          "snippet": "int ocfs2_has_inline_xattr_value_outside(struct inode *inode,\n\t\t\t\t\t struct ocfs2_dinode *di)\n{\n\tstruct ocfs2_xattr_header *xh;\n\tint i;\n\n\txh = (struct ocfs2_xattr_header *)\n\t\t ((void *)di + inode->i_sb->s_blocksize -\n\t\t le16_to_cpu(di->i_xattr_inline_size));\n\n\tfor (i = 0; i < le16_to_cpu(xh->xh_count); i++)\n\t\tif (!ocfs2_xattr_is_local(&xh->xh_entries[i]))\n\t\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"acl.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"super.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"suballoc.h\"",
            "#include \"ocfs2_fs.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"file.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/security.h>",
            "#include <linux/string.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/sort.h>",
            "#include <linux/falloc.h>",
            "#include <linux/writeback.h>",
            "#include <linux/mount.h>",
            "#include <linux/splice.h>",
            "#include <linux/sched.h>",
            "#include <linux/uio.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"acl.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"super.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"suballoc.h\"\n#include \"ocfs2_fs.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"file.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/security.h>\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/sort.h>\n#include <linux/falloc.h>\n#include <linux/writeback.h>\n#include <linux/mount.h>\n#include <linux/splice.h>\n#include <linux/sched.h>\n#include <linux/uio.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/capability.h>\n\nint ocfs2_has_inline_xattr_value_outside(struct inode *inode,\n\t\t\t\t\t struct ocfs2_dinode *di)\n{\n\tstruct ocfs2_xattr_header *xh;\n\tint i;\n\n\txh = (struct ocfs2_xattr_header *)\n\t\t ((void *)di + inode->i_sb->s_blocksize -\n\t\t le16_to_cpu(di->i_xattr_inline_size));\n\n\tfor (i = 0; i < le16_to_cpu(xh->xh_count); i++)\n\t\tif (!ocfs2_xattr_is_local(&xh->xh_entries[i]))\n\t\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&oi->ip_alloc_sem"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&oi->ip_xattr_sem"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 937
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nint ocfs2_try_remove_refcount_tree(struct inode *inode,\n\t\t\t\t   struct buffer_head *di_bh)\n{\n\tint ret;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\n\tdown_write(&oi->ip_xattr_sem);\n\tdown_write(&oi->ip_alloc_sem);\n\n\tif (oi->ip_clusters)\n\t\tgoto out;\n\n\tif ((oi->ip_dyn_features & OCFS2_HAS_XATTR_FL) && di->i_xattr_loc)\n\t\tgoto out;\n\n\tif (oi->ip_dyn_features & OCFS2_INLINE_XATTR_FL &&\n\t    ocfs2_has_inline_xattr_value_outside(inode, di))\n\t\tgoto out;\n\n\tret = ocfs2_remove_refcount_tree(inode, di_bh);\n\tif (ret)\n\t\tmlog_errno(ret);\nout:\n\tup_write(&oi->ip_alloc_sem);\n\tup_write(&oi->ip_xattr_sem);\n\treturn 0;\n}"
  },
  {
    "function_name": "ocfs2_find_refcount_rec_in_rl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "884-924",
    "snippet": "static void ocfs2_find_refcount_rec_in_rl(struct ocfs2_caching_info *ci,\n\t\t\t\t\t  struct buffer_head *ref_leaf_bh,\n\t\t\t\t\t  u64 cpos, unsigned int len,\n\t\t\t\t\t  struct ocfs2_refcount_rec *ret_rec,\n\t\t\t\t\t  int *index)\n{\n\tint i = 0;\n\tstruct ocfs2_refcount_block *rb =\n\t\t(struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\n\tstruct ocfs2_refcount_rec *rec = NULL;\n\n\tfor (; i < le16_to_cpu(rb->rf_records.rl_used); i++) {\n\t\trec = &rb->rf_records.rl_recs[i];\n\n\t\tif (le64_to_cpu(rec->r_cpos) +\n\t\t    le32_to_cpu(rec->r_clusters) <= cpos)\n\t\t\tcontinue;\n\t\telse if (le64_to_cpu(rec->r_cpos) > cpos)\n\t\t\tbreak;\n\n\t\t/* ok, cpos fail in this rec. Just return. */\n\t\tif (ret_rec)\n\t\t\t*ret_rec = *rec;\n\t\tgoto out;\n\t}\n\n\tif (ret_rec) {\n\t\t/* We meet with a hole here, so fake the rec. */\n\t\tret_rec->r_cpos = cpu_to_le64(cpos);\n\t\tret_rec->r_refcount = 0;\n\t\tif (i < le16_to_cpu(rb->rf_records.rl_used) &&\n\t\t    le64_to_cpu(rec->r_cpos) < cpos + len)\n\t\t\tret_rec->r_clusters =\n\t\t\t\tcpu_to_le32(le64_to_cpu(rec->r_cpos) - cpos);\n\t\telse\n\t\t\tret_rec->r_clusters = cpu_to_le32(len);\n\t}\n\nout:\n\t*index = i;\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "len"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "le64_to_cpu(rec->r_cpos) - cpos"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "rec->r_cpos"
          ],
          "line": 917
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "rb->rf_records.rl_used"
          ],
          "line": 914
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "cpos"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rec->r_clusters"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic void ocfs2_find_refcount_rec_in_rl(struct ocfs2_caching_info *ci,\n\t\t\t\t\t  struct buffer_head *ref_leaf_bh,\n\t\t\t\t\t  u64 cpos, unsigned int len,\n\t\t\t\t\t  struct ocfs2_refcount_rec *ret_rec,\n\t\t\t\t\t  int *index)\n{\n\tint i = 0;\n\tstruct ocfs2_refcount_block *rb =\n\t\t(struct ocfs2_refcount_block *)ref_leaf_bh->b_data;\n\tstruct ocfs2_refcount_rec *rec = NULL;\n\n\tfor (; i < le16_to_cpu(rb->rf_records.rl_used); i++) {\n\t\trec = &rb->rf_records.rl_recs[i];\n\n\t\tif (le64_to_cpu(rec->r_cpos) +\n\t\t    le32_to_cpu(rec->r_clusters) <= cpos)\n\t\t\tcontinue;\n\t\telse if (le64_to_cpu(rec->r_cpos) > cpos)\n\t\t\tbreak;\n\n\t\t/* ok, cpos fail in this rec. Just return. */\n\t\tif (ret_rec)\n\t\t\t*ret_rec = *rec;\n\t\tgoto out;\n\t}\n\n\tif (ret_rec) {\n\t\t/* We meet with a hole here, so fake the rec. */\n\t\tret_rec->r_cpos = cpu_to_le64(cpos);\n\t\tret_rec->r_refcount = 0;\n\t\tif (i < le16_to_cpu(rb->rf_records.rl_used) &&\n\t\t    le64_to_cpu(rec->r_cpos) < cpos + len)\n\t\t\tret_rec->r_clusters =\n\t\t\t\tcpu_to_le32(le64_to_cpu(rec->r_cpos) - cpos);\n\t\telse\n\t\t\tret_rec->r_clusters = cpu_to_le32(len);\n\t}\n\nout:\n\t*index = i;\n}"
  },
  {
    "function_name": "ocfs2_remove_refcount_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "764-882",
    "snippet": "int ocfs2_remove_refcount_tree(struct inode *inode, struct buffer_head *di_bh)\n{\n\tint ret, delete_tree = 0;\n\thandle_t *handle = NULL;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_refcount_block *rb;\n\tstruct inode *alloc_inode = NULL;\n\tstruct buffer_head *alloc_bh = NULL;\n\tstruct buffer_head *blk_bh = NULL;\n\tstruct ocfs2_refcount_tree *ref_tree;\n\tint credits = OCFS2_REFCOUNT_TREE_REMOVE_CREDITS;\n\tu64 blk = 0, bg_blkno = 0, ref_blkno = le64_to_cpu(di->i_refcount_loc);\n\tu16 bit = 0;\n\n\tif (!(oi->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL))\n\t\treturn 0;\n\n\tBUG_ON(!ref_blkno);\n\tret = ocfs2_lock_refcount_tree(osb, ref_blkno, 1, &ref_tree, &blk_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\trb = (struct ocfs2_refcount_block *)blk_bh->b_data;\n\n\t/*\n\t * If we are the last user, we need to free the block.\n\t * So lock the allocator ahead.\n\t */\n\tif (le32_to_cpu(rb->rf_count) == 1) {\n\t\tblk = le64_to_cpu(rb->rf_blkno);\n\t\tbit = le16_to_cpu(rb->rf_suballoc_bit);\n\t\tif (rb->rf_suballoc_loc)\n\t\t\tbg_blkno = le64_to_cpu(rb->rf_suballoc_loc);\n\t\telse\n\t\t\tbg_blkno = ocfs2_which_suballoc_group(blk, bit);\n\n\t\talloc_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\tEXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\t\tle16_to_cpu(rb->rf_suballoc_slot));\n\t\tif (!alloc_inode) {\n\t\t\tret = -ENOMEM;\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\tmutex_lock(&alloc_inode->i_mutex);\n\n\t\tret = ocfs2_inode_lock(alloc_inode, &alloc_bh, 1);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_mutex;\n\t\t}\n\n\t\tcredits += OCFS2_SUBALLOC_FREE;\n\t}\n\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out_unlock;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tret = ocfs2_journal_access_rb(handle, &ref_tree->rf_ci, blk_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tspin_lock(&oi->ip_lock);\n\toi->ip_dyn_features &= ~OCFS2_HAS_REFCOUNT_FL;\n\tdi->i_dyn_features = cpu_to_le16(oi->ip_dyn_features);\n\tdi->i_refcount_loc = 0;\n\tspin_unlock(&oi->ip_lock);\n\tocfs2_journal_dirty(handle, di_bh);\n\n\tle32_add_cpu(&rb->rf_count , -1);\n\tocfs2_journal_dirty(handle, blk_bh);\n\n\tif (!rb->rf_count) {\n\t\tdelete_tree = 1;\n\t\tocfs2_erase_refcount_tree_from_list(osb, ref_tree);\n\t\tret = ocfs2_free_suballoc_bits(handle, alloc_inode,\n\t\t\t\t\t       alloc_bh, bit, bg_blkno, 1);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\nout_unlock:\n\tif (alloc_inode) {\n\t\tocfs2_inode_unlock(alloc_inode, 1);\n\t\tbrelse(alloc_bh);\n\t}\nout_mutex:\n\tif (alloc_inode) {\n\t\tmutex_unlock(&alloc_inode->i_mutex);\n\t\tiput(alloc_inode);\n\t}\nout:\n\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\tif (delete_tree)\n\t\tocfs2_refcount_tree_put(ref_tree);\n\tbrelse(blk_bh);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "blk_bh"
          ],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_refcount_tree_put",
          "args": [
            "ref_tree"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_refcount_tree_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "292-296",
          "snippet": "static inline void\nocfs2_refcount_tree_put(struct ocfs2_refcount_tree *tree)\n{\n\tkref_put(&tree->rf_getcnt, ocfs2_kref_remove_refcount_tree);\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic inline void\nocfs2_refcount_tree_put(struct ocfs2_refcount_tree *tree)\n{\n\tkref_put(&tree->rf_getcnt, ocfs2_kref_remove_refcount_tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_unlock_refcount_tree",
          "args": [
            "osb",
            "ref_tree",
            "1"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_refcount_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "526-536",
          "snippet": "void ocfs2_unlock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_refcount_tree *tree, int rw)\n{\n\tif (rw)\n\t\tup_write(&tree->rf_sem);\n\telse\n\t\tup_read(&tree->rf_sem);\n\n\tocfs2_refcount_unlock(tree, rw);\n\tocfs2_refcount_tree_put(tree);\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nvoid ocfs2_unlock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_refcount_tree *tree, int rw)\n{\n\tif (rw)\n\t\tup_write(&tree->rf_sem);\n\telse\n\t\tup_read(&tree->rf_sem);\n\n\tocfs2_refcount_unlock(tree, rw);\n\tocfs2_refcount_tree_put(tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iput",
          "args": [
            "alloc_inode"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "dentry_iput",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/dcache.c",
          "lines": "308-327",
          "snippet": "static void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}",
          "includes": [
            "#include <asm/word-at-a-time.h>",
            "#include \"mount.h\"",
            "#include \"internal.h\"",
            "#include <linux/kasan.h>",
            "#include <linux/list_lru.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/rculist_bl.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/bootmem.h>",
            "#include <linux/swap.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/security.h>",
            "#include <asm/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/mount.h>",
            "#include <linux/export.h>",
            "#include <linux/cache.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/fs.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/syscalls.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/word-at-a-time.h>\n#include \"mount.h\"\n#include \"internal.h\"\n#include <linux/kasan.h>\n#include <linux/list_lru.h>\n#include <linux/ratelimit.h>\n#include <linux/prefetch.h>\n#include <linux/rculist_bl.h>\n#include <linux/bit_spinlock.h>\n#include <linux/hardirq.h>\n#include <linux/fs_struct.h>\n#include <linux/bootmem.h>\n#include <linux/swap.h>\n#include <linux/seqlock.h>\n#include <linux/security.h>\n#include <asm/uaccess.h>\n#include <linux/file.h>\n#include <linux/mount.h>\n#include <linux/export.h>\n#include <linux/cache.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/fsnotify.h>\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/syscalls.h>\n\nstatic void dentry_iput(struct dentry * dentry)\n\t__releases(dentry->d_lock)\n\t__releases(dentry->d_inode->i_lock)\n{\n\tstruct inode *inode = dentry->d_inode;\n\tif (inode) {\n\t\tdentry->d_inode = NULL;\n\t\thlist_del_init(&dentry->d_u.d_alias);\n\t\tspin_unlock(&dentry->d_lock);\n\t\tspin_unlock(&inode->i_lock);\n\t\tif (!inode->i_nlink)\n\t\t\tfsnotify_inoderemove(inode);\n\t\tif (dentry->d_op && dentry->d_op->d_iput)\n\t\t\tdentry->d_op->d_iput(dentry, inode);\n\t\telse\n\t\t\tiput(inode);\n\t} else {\n\t\tspin_unlock(&dentry->d_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&alloc_inode->i_mutex"
          ],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_unlock",
          "args": [
            "alloc_inode",
            "1"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2491-2505",
          "snippet": "void ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_inode_unlock(struct inode *inode,\n\t\t       int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\n\tmlog(0, \"inode %llu drop %s META lock\\n\",\n\t     (unsigned long long)OCFS2_I(inode)->ip_blkno,\n\t     ex ? \"EXMODE\" : \"PRMODE\");\n\n\tif (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&\n\t    !ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "handle"
          ],
          "line": 864
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_free_suballoc_bits",
          "args": [
            "handle",
            "alloc_inode",
            "alloc_bh",
            "bit",
            "bg_blkno",
            "1"
          ],
          "line": 857
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_suballoc_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "2519-2528",
          "snippet": "int ocfs2_free_suballoc_bits(handle_t *handle,\n\t\t\t     struct inode *alloc_inode,\n\t\t\t     struct buffer_head *alloc_bh,\n\t\t\t     unsigned int start_bit,\n\t\t\t     u64 bg_blkno,\n\t\t\t     unsigned int count)\n{\n\treturn _ocfs2_free_suballoc_bits(handle, alloc_inode, alloc_bh,\n\t\t\t\t\t start_bit, bg_blkno, count, NULL);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_free_suballoc_bits(handle_t *handle,\n\t\t\t     struct inode *alloc_inode,\n\t\t\t     struct buffer_head *alloc_bh,\n\t\t\t     unsigned int start_bit,\n\t\t\t     u64 bg_blkno,\n\t\t\t     unsigned int count)\n{\n\treturn _ocfs2_free_suballoc_bits(handle, alloc_inode, alloc_bh,\n\t\t\t\t\t start_bit, bg_blkno, count, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_erase_refcount_tree_from_list",
          "args": [
            "osb",
            "ref_tree"
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_erase_refcount_tree_from_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "270-276",
          "snippet": "static void ocfs2_erase_refcount_tree_from_list(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_refcount_tree *tree)\n{\n\tspin_lock(&osb->osb_lock);\n\tocfs2_erase_refcount_tree_from_list_no_lock(osb, tree);\n\tspin_unlock(&osb->osb_lock);\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic void ocfs2_erase_refcount_tree_from_list(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_refcount_tree *tree)\n{\n\tspin_lock(&osb->osb_lock);\n\tocfs2_erase_refcount_tree_from_list_no_lock(osb, tree);\n\tspin_unlock(&osb->osb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "blk_bh"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&rb->rf_count",
            "-1"
          ],
          "line": 851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&oi->ip_lock"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "oi->ip_dyn_features"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&oi->ip_lock"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_rb",
          "args": [
            "handle",
            "&ref_tree->rf_ci",
            "blk_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_rb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "722-727",
          "snippet": "int ocfs2_journal_access_rb(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &rb_triggers,\n\t\t\t\t      type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers rb_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_refcount_block, rf_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers rb_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_refcount_block, rf_check),\n};\n\nint ocfs2_journal_access_rb(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &rb_triggers,\n\t\t\t\t      type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_di",
          "args": [
            "handle",
            "INODE_CACHE(inode)",
            "di_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_di",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "710-714",
          "snippet": "int ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};\n\nint ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "credits"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_inode_lock",
          "args": [
            "alloc_inode",
            "&alloc_bh",
            "1"
          ],
          "line": 814
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_inode_lock_atime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "2455-2489",
          "snippet": "int ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);",
            "static inline int ocfs2_highest_compat_lock_level(int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic int ocfs2_inode_lock_update(struct inode *inode,\n\t\t\t\t  struct buffer_head **bh);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\n\nint ocfs2_inode_lock_atime(struct inode *inode,\n\t\t\t  struct vfsmount *vfsmnt,\n\t\t\t  int *level)\n{\n\tint ret;\n\n\tret = ocfs2_inode_lock(inode, NULL, 0);\n\tif (ret < 0) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * If we should update atime, we will get EX lock,\n\t * otherwise we just get PR lock.\n\t */\n\tif (ocfs2_should_update_atime(inode, vfsmnt)) {\n\t\tstruct buffer_head *bh = NULL;\n\n\t\tocfs2_inode_unlock(inode, 0);\n\t\tret = ocfs2_inode_lock(inode, &bh, 1);\n\t\tif (ret < 0) {\n\t\t\tmlog_errno(ret);\n\t\t\treturn ret;\n\t\t}\n\t\t*level = 1;\n\t\tif (ocfs2_should_update_atime(inode, vfsmnt))\n\t\t\tocfs2_update_inode_atime(inode, bh);\n\t\tif (bh)\n\t\t\tbrelse(bh);\n\t} else\n\t\t*level = 0;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&alloc_inode->i_mutex"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_system_file_inode",
          "args": [
            "osb",
            "EXTENT_ALLOC_SYSTEM_INODE",
            "le16_to_cpu(rb->rf_suballoc_slot)"
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "_ocfs2_get_system_file_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/sysfile.c",
          "lines": "138-181",
          "snippet": "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"sysfile.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"sysfile.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot);\n\nstatic struct inode * _ocfs2_get_system_file_inode(struct ocfs2_super *osb,\n\t\t\t\t\t\t   int type,\n\t\t\t\t\t\t   u32 slot)\n{\n\tchar namebuf[40];\n\tstruct inode *inode = NULL;\n\tu64 blkno;\n\tint status = 0;\n\n\tocfs2_sprintf_system_inode_name(namebuf,\n\t\t\t\t\tsizeof(namebuf),\n\t\t\t\t\ttype, slot);\n\n\tstatus = ocfs2_lookup_ino_from_name(osb->sys_root_inode, namebuf,\n\t\t\t\t\t    strlen(namebuf), &blkno);\n\tif (status < 0) {\n\t\tgoto bail;\n\t}\n\n\tinode = ocfs2_iget(osb, blkno, OCFS2_FI_FLAG_SYSFILE, type);\n\tif (IS_ERR(inode)) {\n\t\tmlog_errno(PTR_ERR(inode));\n\t\tinode = NULL;\n\t\tgoto bail;\n\t}\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tif (type == LOCAL_USER_QUOTA_SYSTEM_INODE ||\n\t    type == LOCAL_GROUP_QUOTA_SYSTEM_INODE ||\n\t    type == JOURNAL_SYSTEM_INODE) {\n\t\t/* Ignore inode lock on these inodes as the lock does not\n\t\t * really belong to any process and lockdep cannot handle\n\t\t * that */\n\t\tOCFS2_I(inode)->ip_inode_lockres.l_lockdep_map.key = NULL;\n\t} else {\n\t\tlockdep_init_map(&OCFS2_I(inode)->ip_inode_lockres.\n\t\t\t\t\t\t\t\tl_lockdep_map,\n\t\t\t\t ocfs2_system_inodes[type].si_name,\n\t\t\t\t &ocfs2_sysfile_cluster_lock_key[type], 0);\n\t}\n#endif\nbail:\n\n\treturn inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "rb->rf_suballoc_slot"
          ],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "sle16_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "48-51",
          "snippet": "static inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s16 sle16_to_cpup(sle16 *x)\n{\n\treturn le16_to_cpu(*(__force le16*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_which_suballoc_group",
          "args": [
            "blk",
            "bit"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_which_suballoc_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.h",
          "lines": "156-161",
          "snippet": "static inline u64 ocfs2_which_suballoc_group(u64 block, unsigned int bit)\n{\n\tu64 group = block - (u64) bit;\n\n\treturn group;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u64 ocfs2_which_suballoc_group(u64 block, unsigned int bit)\n{\n\tu64 group = block - (u64) bit;\n\n\treturn group;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "rb->rf_suballoc_loc"
          ],
          "line": 800
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rb->rf_count"
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_lock_refcount_tree",
          "args": [
            "osb",
            "ref_blkno",
            "1",
            "&ref_tree",
            "&blk_bh"
          ],
          "line": 784
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_refcount_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "452-524",
          "snippet": "int ocfs2_lock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t     u64 ref_blkno, int rw,\n\t\t\t     struct ocfs2_refcount_tree **ret_tree,\n\t\t\t     struct buffer_head **ref_bh)\n{\n\tint ret, delete_tree = 0;\n\tstruct ocfs2_refcount_tree *tree = NULL;\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_block *rb;\n\nagain:\n\tret = ocfs2_get_refcount_tree(osb, ref_blkno, &tree);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tocfs2_refcount_tree_get(tree);\n\n\tret = __ocfs2_lock_refcount_tree(osb, tree, rw);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_refcount_tree_put(tree);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_refcount_block(&tree->rf_ci, tree->rf_blkno,\n\t\t\t\t\t&ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_unlock_refcount_tree(osb, tree, rw);\n\t\tocfs2_refcount_tree_put(tree);\n\t\tgoto out;\n\t}\n\n\trb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\t/*\n\t * If the refcount block has been freed and re-created, we may need\n\t * to recreate the refcount tree also.\n\t *\n\t * Here we just remove the tree from the rb-tree, and the last\n\t * kref holder will unlock and delete this refcount_tree.\n\t * Then we goto \"again\" and ocfs2_get_refcount_tree will create\n\t * the new refcount tree for us.\n\t */\n\tif (tree->rf_generation != le32_to_cpu(rb->rf_generation)) {\n\t\tif (!tree->rf_removed) {\n\t\t\tocfs2_erase_refcount_tree_from_list(osb, tree);\n\t\t\ttree->rf_removed = 1;\n\t\t\tdelete_tree = 1;\n\t\t}\n\n\t\tocfs2_unlock_refcount_tree(osb, tree, rw);\n\t\t/*\n\t\t * We get an extra reference when we create the refcount\n\t\t * tree, so another put will destroy it.\n\t\t */\n\t\tif (delete_tree)\n\t\t\tocfs2_refcount_tree_put(tree);\n\t\tbrelse(ref_root_bh);\n\t\tref_root_bh = NULL;\n\t\tgoto again;\n\t}\n\n\t*ret_tree = tree;\n\tif (ref_bh) {\n\t\t*ref_bh = ref_root_bh;\n\t\tref_root_bh = NULL;\n\t}\nout:\n\tbrelse(ref_root_bh);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nint ocfs2_lock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t     u64 ref_blkno, int rw,\n\t\t\t     struct ocfs2_refcount_tree **ret_tree,\n\t\t\t     struct buffer_head **ref_bh)\n{\n\tint ret, delete_tree = 0;\n\tstruct ocfs2_refcount_tree *tree = NULL;\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_block *rb;\n\nagain:\n\tret = ocfs2_get_refcount_tree(osb, ref_blkno, &tree);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tocfs2_refcount_tree_get(tree);\n\n\tret = __ocfs2_lock_refcount_tree(osb, tree, rw);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_refcount_tree_put(tree);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_refcount_block(&tree->rf_ci, tree->rf_blkno,\n\t\t\t\t\t&ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_unlock_refcount_tree(osb, tree, rw);\n\t\tocfs2_refcount_tree_put(tree);\n\t\tgoto out;\n\t}\n\n\trb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\t/*\n\t * If the refcount block has been freed and re-created, we may need\n\t * to recreate the refcount tree also.\n\t *\n\t * Here we just remove the tree from the rb-tree, and the last\n\t * kref holder will unlock and delete this refcount_tree.\n\t * Then we goto \"again\" and ocfs2_get_refcount_tree will create\n\t * the new refcount tree for us.\n\t */\n\tif (tree->rf_generation != le32_to_cpu(rb->rf_generation)) {\n\t\tif (!tree->rf_removed) {\n\t\t\tocfs2_erase_refcount_tree_from_list(osb, tree);\n\t\t\ttree->rf_removed = 1;\n\t\t\tdelete_tree = 1;\n\t\t}\n\n\t\tocfs2_unlock_refcount_tree(osb, tree, rw);\n\t\t/*\n\t\t * We get an extra reference when we create the refcount\n\t\t * tree, so another put will destroy it.\n\t\t */\n\t\tif (delete_tree)\n\t\t\tocfs2_refcount_tree_put(tree);\n\t\tbrelse(ref_root_bh);\n\t\tref_root_bh = NULL;\n\t\tgoto again;\n\t}\n\n\t*ret_tree = tree;\n\tif (ref_bh) {\n\t\t*ref_bh = ref_root_bh;\n\t\tref_root_bh = NULL;\n\t}\nout:\n\tbrelse(ref_root_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!ref_blkno"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nint ocfs2_remove_refcount_tree(struct inode *inode, struct buffer_head *di_bh)\n{\n\tint ret, delete_tree = 0;\n\thandle_t *handle = NULL;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct ocfs2_refcount_block *rb;\n\tstruct inode *alloc_inode = NULL;\n\tstruct buffer_head *alloc_bh = NULL;\n\tstruct buffer_head *blk_bh = NULL;\n\tstruct ocfs2_refcount_tree *ref_tree;\n\tint credits = OCFS2_REFCOUNT_TREE_REMOVE_CREDITS;\n\tu64 blk = 0, bg_blkno = 0, ref_blkno = le64_to_cpu(di->i_refcount_loc);\n\tu16 bit = 0;\n\n\tif (!(oi->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL))\n\t\treturn 0;\n\n\tBUG_ON(!ref_blkno);\n\tret = ocfs2_lock_refcount_tree(osb, ref_blkno, 1, &ref_tree, &blk_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\trb = (struct ocfs2_refcount_block *)blk_bh->b_data;\n\n\t/*\n\t * If we are the last user, we need to free the block.\n\t * So lock the allocator ahead.\n\t */\n\tif (le32_to_cpu(rb->rf_count) == 1) {\n\t\tblk = le64_to_cpu(rb->rf_blkno);\n\t\tbit = le16_to_cpu(rb->rf_suballoc_bit);\n\t\tif (rb->rf_suballoc_loc)\n\t\t\tbg_blkno = le64_to_cpu(rb->rf_suballoc_loc);\n\t\telse\n\t\t\tbg_blkno = ocfs2_which_suballoc_group(blk, bit);\n\n\t\talloc_inode = ocfs2_get_system_file_inode(osb,\n\t\t\t\t\tEXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\t\tle16_to_cpu(rb->rf_suballoc_slot));\n\t\tif (!alloc_inode) {\n\t\t\tret = -ENOMEM;\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out;\n\t\t}\n\t\tmutex_lock(&alloc_inode->i_mutex);\n\n\t\tret = ocfs2_inode_lock(alloc_inode, &alloc_bh, 1);\n\t\tif (ret) {\n\t\t\tmlog_errno(ret);\n\t\t\tgoto out_mutex;\n\t\t}\n\n\t\tcredits += OCFS2_SUBALLOC_FREE;\n\t}\n\n\thandle = ocfs2_start_trans(osb, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out_unlock;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tret = ocfs2_journal_access_rb(handle, &ref_tree->rf_ci, blk_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tspin_lock(&oi->ip_lock);\n\toi->ip_dyn_features &= ~OCFS2_HAS_REFCOUNT_FL;\n\tdi->i_dyn_features = cpu_to_le16(oi->ip_dyn_features);\n\tdi->i_refcount_loc = 0;\n\tspin_unlock(&oi->ip_lock);\n\tocfs2_journal_dirty(handle, di_bh);\n\n\tle32_add_cpu(&rb->rf_count , -1);\n\tocfs2_journal_dirty(handle, blk_bh);\n\n\tif (!rb->rf_count) {\n\t\tdelete_tree = 1;\n\t\tocfs2_erase_refcount_tree_from_list(osb, ref_tree);\n\t\tret = ocfs2_free_suballoc_bits(handle, alloc_inode,\n\t\t\t\t\t       alloc_bh, bit, bg_blkno, 1);\n\t\tif (ret)\n\t\t\tmlog_errno(ret);\n\t}\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\nout_unlock:\n\tif (alloc_inode) {\n\t\tocfs2_inode_unlock(alloc_inode, 1);\n\t\tbrelse(alloc_bh);\n\t}\nout_mutex:\n\tif (alloc_inode) {\n\t\tmutex_unlock(&alloc_inode->i_mutex);\n\t\tiput(alloc_inode);\n\t}\nout:\n\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\tif (delete_tree)\n\t\tocfs2_refcount_tree_put(ref_tree);\n\tbrelse(blk_bh);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_set_refcount_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "700-762",
    "snippet": "static int ocfs2_set_refcount_tree(struct inode *inode,\n\t\t\t\t   struct buffer_head *di_bh,\n\t\t\t\t   u64 refcount_loc)\n{\n\tint ret;\n\thandle_t *handle = NULL;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_block *rb;\n\tstruct ocfs2_refcount_tree *ref_tree;\n\n\tBUG_ON(oi->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL);\n\n\tret = ocfs2_lock_refcount_tree(osb, refcount_loc, 1,\n\t\t\t\t       &ref_tree, &ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_REFCOUNT_TREE_SET_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tret = ocfs2_journal_access_rb(handle, &ref_tree->rf_ci, ref_root_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\trb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\tle32_add_cpu(&rb->rf_count, 1);\n\n\tocfs2_journal_dirty(handle, ref_root_bh);\n\n\tspin_lock(&oi->ip_lock);\n\toi->ip_dyn_features |= OCFS2_HAS_REFCOUNT_FL;\n\tdi->i_dyn_features = cpu_to_le16(oi->ip_dyn_features);\n\tdi->i_refcount_loc = cpu_to_le64(refcount_loc);\n\tspin_unlock(&oi->ip_lock);\n\tocfs2_journal_dirty(handle, di_bh);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\nout:\n\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\tbrelse(ref_root_bh);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "ref_root_bh"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_unlock_refcount_tree",
          "args": [
            "osb",
            "ref_tree",
            "1"
          ],
          "line": 758
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_refcount_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "526-536",
          "snippet": "void ocfs2_unlock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_refcount_tree *tree, int rw)\n{\n\tif (rw)\n\t\tup_write(&tree->rf_sem);\n\telse\n\t\tup_read(&tree->rf_sem);\n\n\tocfs2_refcount_unlock(tree, rw);\n\tocfs2_refcount_tree_put(tree);\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nvoid ocfs2_unlock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_refcount_tree *tree, int rw)\n{\n\tif (rw)\n\t\tup_write(&tree->rf_sem);\n\telse\n\t\tup_read(&tree->rf_sem);\n\n\tocfs2_refcount_unlock(tree, rw);\n\tocfs2_refcount_tree_put(tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "handle"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "di_bh"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&oi->ip_lock"
          ],
          "line": 752
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "refcount_loc"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "oi->ip_dyn_features"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&oi->ip_lock"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_add_cpu",
          "args": [
            "&rb->rf_count",
            "1"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_rb",
          "args": [
            "handle",
            "&ref_tree->rf_ci",
            "ref_root_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_rb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "722-727",
          "snippet": "int ocfs2_journal_access_rb(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &rb_triggers,\n\t\t\t\t      type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers rb_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_refcount_block, rf_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers rb_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_refcount_block, rf_check),\n};\n\nint ocfs2_journal_access_rb(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &rb_triggers,\n\t\t\t\t      type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_di",
          "args": [
            "handle",
            "INODE_CACHE(inode)",
            "di_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_di",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "710-714",
          "snippet": "int ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};\n\nint ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "OCFS2_REFCOUNT_TREE_SET_CREDITS"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_lock_refcount_tree",
          "args": [
            "osb",
            "refcount_loc",
            "1",
            "&ref_tree",
            "&ref_root_bh"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_refcount_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "452-524",
          "snippet": "int ocfs2_lock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t     u64 ref_blkno, int rw,\n\t\t\t     struct ocfs2_refcount_tree **ret_tree,\n\t\t\t     struct buffer_head **ref_bh)\n{\n\tint ret, delete_tree = 0;\n\tstruct ocfs2_refcount_tree *tree = NULL;\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_block *rb;\n\nagain:\n\tret = ocfs2_get_refcount_tree(osb, ref_blkno, &tree);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tocfs2_refcount_tree_get(tree);\n\n\tret = __ocfs2_lock_refcount_tree(osb, tree, rw);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_refcount_tree_put(tree);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_refcount_block(&tree->rf_ci, tree->rf_blkno,\n\t\t\t\t\t&ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_unlock_refcount_tree(osb, tree, rw);\n\t\tocfs2_refcount_tree_put(tree);\n\t\tgoto out;\n\t}\n\n\trb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\t/*\n\t * If the refcount block has been freed and re-created, we may need\n\t * to recreate the refcount tree also.\n\t *\n\t * Here we just remove the tree from the rb-tree, and the last\n\t * kref holder will unlock and delete this refcount_tree.\n\t * Then we goto \"again\" and ocfs2_get_refcount_tree will create\n\t * the new refcount tree for us.\n\t */\n\tif (tree->rf_generation != le32_to_cpu(rb->rf_generation)) {\n\t\tif (!tree->rf_removed) {\n\t\t\tocfs2_erase_refcount_tree_from_list(osb, tree);\n\t\t\ttree->rf_removed = 1;\n\t\t\tdelete_tree = 1;\n\t\t}\n\n\t\tocfs2_unlock_refcount_tree(osb, tree, rw);\n\t\t/*\n\t\t * We get an extra reference when we create the refcount\n\t\t * tree, so another put will destroy it.\n\t\t */\n\t\tif (delete_tree)\n\t\t\tocfs2_refcount_tree_put(tree);\n\t\tbrelse(ref_root_bh);\n\t\tref_root_bh = NULL;\n\t\tgoto again;\n\t}\n\n\t*ret_tree = tree;\n\tif (ref_bh) {\n\t\t*ref_bh = ref_root_bh;\n\t\tref_root_bh = NULL;\n\t}\nout:\n\tbrelse(ref_root_bh);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nint ocfs2_lock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t     u64 ref_blkno, int rw,\n\t\t\t     struct ocfs2_refcount_tree **ret_tree,\n\t\t\t     struct buffer_head **ref_bh)\n{\n\tint ret, delete_tree = 0;\n\tstruct ocfs2_refcount_tree *tree = NULL;\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_block *rb;\n\nagain:\n\tret = ocfs2_get_refcount_tree(osb, ref_blkno, &tree);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tocfs2_refcount_tree_get(tree);\n\n\tret = __ocfs2_lock_refcount_tree(osb, tree, rw);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_refcount_tree_put(tree);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_refcount_block(&tree->rf_ci, tree->rf_blkno,\n\t\t\t\t\t&ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_unlock_refcount_tree(osb, tree, rw);\n\t\tocfs2_refcount_tree_put(tree);\n\t\tgoto out;\n\t}\n\n\trb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\t/*\n\t * If the refcount block has been freed and re-created, we may need\n\t * to recreate the refcount tree also.\n\t *\n\t * Here we just remove the tree from the rb-tree, and the last\n\t * kref holder will unlock and delete this refcount_tree.\n\t * Then we goto \"again\" and ocfs2_get_refcount_tree will create\n\t * the new refcount tree for us.\n\t */\n\tif (tree->rf_generation != le32_to_cpu(rb->rf_generation)) {\n\t\tif (!tree->rf_removed) {\n\t\t\tocfs2_erase_refcount_tree_from_list(osb, tree);\n\t\t\ttree->rf_removed = 1;\n\t\t\tdelete_tree = 1;\n\t\t}\n\n\t\tocfs2_unlock_refcount_tree(osb, tree, rw);\n\t\t/*\n\t\t * We get an extra reference when we create the refcount\n\t\t * tree, so another put will destroy it.\n\t\t */\n\t\tif (delete_tree)\n\t\t\tocfs2_refcount_tree_put(tree);\n\t\tbrelse(ref_root_bh);\n\t\tref_root_bh = NULL;\n\t\tgoto again;\n\t}\n\n\t*ret_tree = tree;\n\tif (ref_bh) {\n\t\t*ref_bh = ref_root_bh;\n\t\tref_root_bh = NULL;\n\t}\nout:\n\tbrelse(ref_root_bh);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "oi->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_set_refcount_tree(struct inode *inode,\n\t\t\t\t   struct buffer_head *di_bh,\n\t\t\t\t   u64 refcount_loc)\n{\n\tint ret;\n\thandle_t *handle = NULL;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_block *rb;\n\tstruct ocfs2_refcount_tree *ref_tree;\n\n\tBUG_ON(oi->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL);\n\n\tret = ocfs2_lock_refcount_tree(osb, refcount_loc, 1,\n\t\t\t\t       &ref_tree, &ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_REFCOUNT_TREE_SET_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tret = ocfs2_journal_access_rb(handle, &ref_tree->rf_ci, ref_root_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\trb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\tle32_add_cpu(&rb->rf_count, 1);\n\n\tocfs2_journal_dirty(handle, ref_root_bh);\n\n\tspin_lock(&oi->ip_lock);\n\toi->ip_dyn_features |= OCFS2_HAS_REFCOUNT_FL;\n\tdi->i_dyn_features = cpu_to_le16(oi->ip_dyn_features);\n\tdi->i_refcount_loc = cpu_to_le64(refcount_loc);\n\tspin_unlock(&oi->ip_lock);\n\tocfs2_journal_dirty(handle, di_bh);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\nout:\n\tocfs2_unlock_refcount_tree(osb, ref_tree, 1);\n\tbrelse(ref_root_bh);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_create_refcount_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "559-698",
    "snippet": "static int ocfs2_create_refcount_tree(struct inode *inode,\n\t\t\t\t      struct buffer_head *di_bh)\n{\n\tint ret;\n\thandle_t *handle = NULL;\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct buffer_head *new_bh = NULL;\n\tstruct ocfs2_refcount_block *rb;\n\tstruct ocfs2_refcount_tree *new_tree = NULL, *tree = NULL;\n\tu16 suballoc_bit_start;\n\tu32 num_got;\n\tu64 suballoc_loc, first_blkno;\n\n\tBUG_ON(oi->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL);\n\n\ttrace_ocfs2_create_refcount_tree(\n\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tret = ocfs2_reserve_new_metadata_blocks(osb, 1, &meta_ac);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_REFCOUNT_TREE_CREATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tret = ocfs2_claim_metadata(handle, meta_ac, 1, &suballoc_loc,\n\t\t\t\t   &suballoc_bit_start, &num_got,\n\t\t\t\t   &first_blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tnew_tree = ocfs2_allocate_refcount_tree(osb, first_blkno);\n\tif (!new_tree) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tnew_bh = sb_getblk(inode->i_sb, first_blkno);\n\tif (!new_bh) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\tocfs2_set_new_buffer_uptodate(&new_tree->rf_ci, new_bh);\n\n\tret = ocfs2_journal_access_rb(handle, &new_tree->rf_ci, new_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\t/* Initialize ocfs2_refcount_block. */\n\trb = (struct ocfs2_refcount_block *)new_bh->b_data;\n\tmemset(rb, 0, inode->i_sb->s_blocksize);\n\tstrcpy((void *)rb, OCFS2_REFCOUNT_BLOCK_SIGNATURE);\n\trb->rf_suballoc_slot = cpu_to_le16(meta_ac->ac_alloc_slot);\n\trb->rf_suballoc_loc = cpu_to_le64(suballoc_loc);\n\trb->rf_suballoc_bit = cpu_to_le16(suballoc_bit_start);\n\trb->rf_fs_generation = cpu_to_le32(osb->fs_generation);\n\trb->rf_blkno = cpu_to_le64(first_blkno);\n\trb->rf_count = cpu_to_le32(1);\n\trb->rf_records.rl_count =\n\t\t\tcpu_to_le16(ocfs2_refcount_recs_per_rb(osb->sb));\n\tspin_lock(&osb->osb_lock);\n\trb->rf_generation = osb->s_next_generation++;\n\tspin_unlock(&osb->osb_lock);\n\n\tocfs2_journal_dirty(handle, new_bh);\n\n\tspin_lock(&oi->ip_lock);\n\toi->ip_dyn_features |= OCFS2_HAS_REFCOUNT_FL;\n\tdi->i_dyn_features = cpu_to_le16(oi->ip_dyn_features);\n\tdi->i_refcount_loc = cpu_to_le64(first_blkno);\n\tspin_unlock(&oi->ip_lock);\n\n\ttrace_ocfs2_create_refcount_tree_blkno((unsigned long long)first_blkno);\n\n\tocfs2_journal_dirty(handle, di_bh);\n\n\t/*\n\t * We have to init the tree lock here since it will use\n\t * the generation number to create it.\n\t */\n\tnew_tree->rf_generation = le32_to_cpu(rb->rf_generation);\n\tocfs2_init_refcount_tree_lock(osb, new_tree, first_blkno,\n\t\t\t\t      new_tree->rf_generation);\n\n\tspin_lock(&osb->osb_lock);\n\ttree = ocfs2_find_refcount_tree(osb, first_blkno);\n\n\t/*\n\t * We've just created a new refcount tree in this block.  If\n\t * we found a refcount tree on the ocfs2_super, it must be\n\t * one we just deleted.  We free the old tree before\n\t * inserting the new tree.\n\t */\n\tBUG_ON(tree && tree->rf_generation == new_tree->rf_generation);\n\tif (tree)\n\t\tocfs2_erase_refcount_tree_from_list_no_lock(osb, tree);\n\tocfs2_insert_refcount_tree(osb, new_tree);\n\tspin_unlock(&osb->osb_lock);\n\tnew_tree = NULL;\n\tif (tree)\n\t\tocfs2_refcount_tree_put(tree);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\n\nout:\n\tif (new_tree) {\n\t\tocfs2_metadata_cache_exit(&new_tree->rf_ci);\n\t\tkfree(new_tree);\n\t}\n\n\tbrelse(new_bh);\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_free_alloc_context",
          "args": [
            "meta_ac"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_alloc_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "158-162",
          "snippet": "void ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nvoid ocfs2_free_alloc_context(struct ocfs2_alloc_context *ac)\n{\n\tocfs2_free_ac_resource(ac);\n\tkfree(ac);\n}"
        }
      },
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "new_bh"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "new_tree"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_exit",
          "args": [
            "&new_tree->rf_ci"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "136-140",
          "snippet": "void ocfs2_metadata_cache_exit(struct ocfs2_caching_info *ci)\n{\n\tocfs2_metadata_cache_purge(ci);\n\tocfs2_metadata_cache_reset(ci, 1);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_metadata_cache_exit(struct ocfs2_caching_info *ci)\n{\n\tocfs2_metadata_cache_purge(ci);\n\tocfs2_metadata_cache_reset(ci, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_commit_trans",
          "args": [
            "osb",
            "handle"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_commit_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "388-407",
          "snippet": "int ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nint ocfs2_commit_trans(struct ocfs2_super *osb,\n\t\t       handle_t *handle)\n{\n\tint ret, nested;\n\tstruct ocfs2_journal *journal = osb->journal;\n\n\tBUG_ON(!handle);\n\n\tnested = handle->h_ref > 1;\n\tret = jbd2_journal_stop(handle);\n\tif (ret < 0)\n\t\tmlog_errno(ret);\n\n\tif (!nested) {\n\t\tup_read(&journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_refcount_tree_put",
          "args": [
            "tree"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_refcount_tree_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "292-296",
          "snippet": "static inline void\nocfs2_refcount_tree_put(struct ocfs2_refcount_tree *tree)\n{\n\tkref_put(&tree->rf_getcnt, ocfs2_kref_remove_refcount_tree);\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic inline void\nocfs2_refcount_tree_put(struct ocfs2_refcount_tree *tree)\n{\n\tkref_put(&tree->rf_getcnt, ocfs2_kref_remove_refcount_tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_insert_refcount_tree",
          "args": [
            "osb",
            "new_tree"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_insert_refcount_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "223-251",
          "snippet": "static void ocfs2_insert_refcount_tree(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_refcount_tree *new)\n{\n\tu64 rf_blkno = new->rf_blkno;\n\tstruct rb_node *parent = NULL;\n\tstruct rb_node **p = &osb->osb_rf_lock_tree.rb_node;\n\tstruct ocfs2_refcount_tree *tmp;\n\n\twhile (*p) {\n\t\tparent = *p;\n\n\t\ttmp = rb_entry(parent, struct ocfs2_refcount_tree,\n\t\t\t       rf_node);\n\n\t\tif (rf_blkno < tmp->rf_blkno)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (rf_blkno > tmp->rf_blkno)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\t/* This should never happen! */\n\t\t\tmlog(ML_ERROR, \"Duplicate refcount block %llu found!\\n\",\n\t\t\t     (unsigned long long)rf_blkno);\n\t\t\tBUG();\n\t\t}\n\t}\n\n\trb_link_node(&new->rf_node, parent, p);\n\trb_insert_color(&new->rf_node, &osb->osb_rf_lock_tree);\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic void ocfs2_insert_refcount_tree(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_refcount_tree *new)\n{\n\tu64 rf_blkno = new->rf_blkno;\n\tstruct rb_node *parent = NULL;\n\tstruct rb_node **p = &osb->osb_rf_lock_tree.rb_node;\n\tstruct ocfs2_refcount_tree *tmp;\n\n\twhile (*p) {\n\t\tparent = *p;\n\n\t\ttmp = rb_entry(parent, struct ocfs2_refcount_tree,\n\t\t\t       rf_node);\n\n\t\tif (rf_blkno < tmp->rf_blkno)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (rf_blkno > tmp->rf_blkno)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\t/* This should never happen! */\n\t\t\tmlog(ML_ERROR, \"Duplicate refcount block %llu found!\\n\",\n\t\t\t     (unsigned long long)rf_blkno);\n\t\t\tBUG();\n\t\t}\n\t}\n\n\trb_link_node(&new->rf_node, parent, p);\n\trb_insert_color(&new->rf_node, &osb->osb_rf_lock_tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_erase_refcount_tree_from_list_no_lock",
          "args": [
            "osb",
            "tree"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_erase_refcount_tree_from_list_no_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "261-268",
          "snippet": "static inline void\nocfs2_erase_refcount_tree_from_list_no_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_refcount_tree *tree)\n{\n\trb_erase(&tree->rf_node, &osb->osb_rf_lock_tree);\n\tif (osb->osb_ref_tree_lru && osb->osb_ref_tree_lru == tree)\n\t\tosb->osb_ref_tree_lru = NULL;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic inline void\nocfs2_erase_refcount_tree_from_list_no_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_refcount_tree *tree)\n{\n\trb_erase(&tree->rf_node, &osb->osb_rf_lock_tree);\n\tif (osb->osb_ref_tree_lru && osb->osb_ref_tree_lru == tree)\n\t\tosb->osb_ref_tree_lru = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "tree && tree->rf_generation == new_tree->rf_generation"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_find_refcount_tree",
          "args": [
            "osb",
            "first_blkno"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_refcount_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "202-220",
          "snippet": "static struct ocfs2_refcount_tree *\nocfs2_find_refcount_tree(struct ocfs2_super *osb, u64 blkno)\n{\n\tstruct rb_node *n = osb->osb_rf_lock_tree.rb_node;\n\tstruct ocfs2_refcount_tree *tree = NULL;\n\n\twhile (n) {\n\t\ttree = rb_entry(n, struct ocfs2_refcount_tree, rf_node);\n\n\t\tif (blkno < tree->rf_blkno)\n\t\t\tn = n->rb_left;\n\t\telse if (blkno > tree->rf_blkno)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn tree;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic struct ocfs2_refcount_tree *\nocfs2_find_refcount_tree(struct ocfs2_super *osb, u64 blkno)\n{\n\tstruct rb_node *n = osb->osb_rf_lock_tree.rb_node;\n\tstruct ocfs2_refcount_tree *tree = NULL;\n\n\twhile (n) {\n\t\ttree = rb_entry(n, struct ocfs2_refcount_tree, rf_node);\n\n\t\tif (blkno < tree->rf_blkno)\n\t\t\tn = n->rb_left;\n\t\telse if (blkno > tree->rf_blkno)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn tree;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_init_refcount_tree_lock",
          "args": [
            "osb",
            "new_tree",
            "first_blkno",
            "new_tree->rf_generation"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_refcount_tree_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "307-314",
          "snippet": "static inline void ocfs2_init_refcount_tree_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_refcount_tree *new,\n\t\t\t\t\tu64 rf_blkno, u32 generation)\n{\n\tinit_rwsem(&new->rf_sem);\n\tocfs2_refcount_lock_res_init(&new->rf_lockres, osb,\n\t\t\t\t     rf_blkno, generation);\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic inline void ocfs2_init_refcount_tree_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_refcount_tree *new,\n\t\t\t\t\tu64 rf_blkno, u32 generation)\n{\n\tinit_rwsem(&new->rf_sem);\n\tocfs2_refcount_lock_res_init(&new->rf_lockres, osb,\n\t\t\t\t     rf_blkno, generation);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rb->rf_generation"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_dirty",
          "args": [
            "handle",
            "di_bh"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_dirty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "771-779",
          "snippet": "void ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_journal_dirty(handle_t *handle, struct buffer_head *bh)\n{\n\tint status;\n\n\ttrace_ocfs2_journal_dirty((unsigned long long)bh->b_blocknr);\n\n\tstatus = jbd2_journal_dirty_metadata(handle, bh);\n\tBUG_ON(status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_create_refcount_tree_blkno",
          "args": [
            "(unsigned long long)first_blkno"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "first_blkno"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "oi->ip_dyn_features"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "ocfs2_refcount_recs_per_rb(osb->sb)"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_refcount_recs_per_rb",
          "args": [
            "osb->sb"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_refcount_recs_per_rb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/ocfs2_fs.h",
          "lines": "1464-1472",
          "snippet": "static inline u16 ocfs2_refcount_recs_per_rb(struct super_block *sb)\n{\n\tint size;\n\n\tsize = sb->s_blocksize -\n\t\toffsetof(struct ocfs2_refcount_block, rf_records.rl_recs);\n\n\treturn size / sizeof(struct ocfs2_refcount_rec);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline u16 ocfs2_refcount_recs_per_rb(struct super_block *sb)\n{\n\tint size;\n\n\tsize = sb->s_blocksize -\n\t\toffsetof(struct ocfs2_refcount_block, rf_records.rl_recs);\n\n\treturn size / sizeof(struct ocfs2_refcount_rec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "1"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "first_blkno"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "osb->fs_generation"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "suballoc_bit_start"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "suballoc_loc"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "meta_ac->ac_alloc_slot"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "(void *)rb",
            "OCFS2_REFCOUNT_BLOCK_SIGNATURE"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "rb",
            "0",
            "inode->i_sb->s_blocksize"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_rb",
          "args": [
            "handle",
            "&new_tree->rf_ci",
            "new_bh",
            "OCFS2_JOURNAL_ACCESS_CREATE"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_rb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "722-727",
          "snippet": "int ocfs2_journal_access_rb(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &rb_triggers,\n\t\t\t\t      type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers rb_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_refcount_block, rf_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers rb_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_refcount_block, rf_check),\n};\n\nint ocfs2_journal_access_rb(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &rb_triggers,\n\t\t\t\t      type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_set_new_buffer_uptodate",
          "args": [
            "&new_tree->rf_ci",
            "new_bh"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_set_new_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "521-532",
          "snippet": "void ocfs2_set_new_buffer_uptodate(struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t/* This should definitely *not* exist in our cache */\n\tBUG_ON(ocfs2_buffer_cached(ci, bh));\n\n\tset_buffer_uptodate(bh);\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tocfs2_set_buffer_uptodate(ci, bh);\n\tocfs2_metadata_cache_io_unlock(ci);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_set_new_buffer_uptodate(struct ocfs2_caching_info *ci,\n\t\t\t\t   struct buffer_head *bh)\n{\n\t/* This should definitely *not* exist in our cache */\n\tBUG_ON(ocfs2_buffer_cached(ci, bh));\n\n\tset_buffer_uptodate(bh);\n\n\tocfs2_metadata_cache_io_lock(ci);\n\tocfs2_set_buffer_uptodate(ci, bh);\n\tocfs2_metadata_cache_io_unlock(ci);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sb_getblk",
          "args": [
            "inode->i_sb",
            "first_blkno"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_allocate_refcount_tree",
          "args": [
            "osb",
            "first_blkno"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_allocate_refcount_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "316-330",
          "snippet": "static struct ocfs2_refcount_tree*\nocfs2_allocate_refcount_tree(struct ocfs2_super *osb, u64 rf_blkno)\n{\n\tstruct ocfs2_refcount_tree *new;\n\n\tnew = kzalloc(sizeof(struct ocfs2_refcount_tree), GFP_NOFS);\n\tif (!new)\n\t\treturn NULL;\n\n\tnew->rf_blkno = rf_blkno;\n\tkref_init(&new->rf_getcnt);\n\tocfs2_init_refcount_tree_ci(new, osb->sb);\n\n\treturn new;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic struct ocfs2_refcount_tree*\nocfs2_allocate_refcount_tree(struct ocfs2_super *osb, u64 rf_blkno)\n{\n\tstruct ocfs2_refcount_tree *new;\n\n\tnew = kzalloc(sizeof(struct ocfs2_refcount_tree), GFP_NOFS);\n\tif (!new)\n\t\treturn NULL;\n\n\tnew->rf_blkno = rf_blkno;\n\tkref_init(&new->rf_getcnt);\n\tocfs2_init_refcount_tree_ci(new, osb->sb);\n\n\treturn new;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_claim_metadata",
          "args": [
            "handle",
            "meta_ac",
            "1",
            "&suballoc_loc",
            "&suballoc_bit_start",
            "&num_got",
            "&first_blkno"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_claim_metadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "1993-2029",
          "snippet": "int ocfs2_claim_metadata(handle_t *handle,\n\t\t\t struct ocfs2_alloc_context *ac,\n\t\t\t u32 bits_wanted,\n\t\t\t u64 *suballoc_loc,\n\t\t\t u16 *suballoc_bit_start,\n\t\t\t unsigned int *num_bits,\n\t\t\t u64 *blkno_start)\n{\n\tint status;\n\tstruct ocfs2_suballoc_result res = { .sr_blkno = 0, };\n\n\tBUG_ON(!ac);\n\tBUG_ON(ac->ac_bits_wanted < (ac->ac_bits_given + bits_wanted));\n\tBUG_ON(ac->ac_which != OCFS2_AC_USE_META);\n\n\tstatus = ocfs2_claim_suballoc_bits(ac,\n\t\t\t\t\t   handle,\n\t\t\t\t\t   bits_wanted,\n\t\t\t\t\t   1,\n\t\t\t\t\t   &res);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tatomic_inc(&OCFS2_SB(ac->ac_inode->i_sb)->alloc_stats.bg_allocs);\n\n\t*suballoc_loc = res.sr_bg_blkno;\n\t*suballoc_bit_start = res.sr_bit_offset;\n\t*blkno_start = res.sr_blkno;\n\tac->ac_bits_given += res.sr_bits;\n\t*num_bits = res.sr_bits;\n\tstatus = 0;\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);",
            "static int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);",
            "static int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);",
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_cluster_group_search(struct inode *inode,\n\t\t\t\t      struct buffer_head *group_bh,\n\t\t\t\t      u32 bits_wanted, u32 min_bits,\n\t\t\t\t      u64 max_block,\n\t\t\t\t      struct ocfs2_suballoc_result *res);\nstatic int ocfs2_block_group_search(struct inode *inode,\n\t\t\t\t    struct buffer_head *group_bh,\n\t\t\t\t    u32 bits_wanted, u32 min_bits,\n\t\t\t\t    u64 max_block,\n\t\t\t\t    struct ocfs2_suballoc_result *res);\nstatic int ocfs2_claim_suballoc_bits(struct ocfs2_alloc_context *ac,\n\t\t\t\t     handle_t *handle,\n\t\t\t\t     u32 bits_wanted,\n\t\t\t\t     u32 min_bits,\n\t\t\t\t     struct ocfs2_suballoc_result *res);\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint ocfs2_claim_metadata(handle_t *handle,\n\t\t\t struct ocfs2_alloc_context *ac,\n\t\t\t u32 bits_wanted,\n\t\t\t u64 *suballoc_loc,\n\t\t\t u16 *suballoc_bit_start,\n\t\t\t unsigned int *num_bits,\n\t\t\t u64 *blkno_start)\n{\n\tint status;\n\tstruct ocfs2_suballoc_result res = { .sr_blkno = 0, };\n\n\tBUG_ON(!ac);\n\tBUG_ON(ac->ac_bits_wanted < (ac->ac_bits_given + bits_wanted));\n\tBUG_ON(ac->ac_which != OCFS2_AC_USE_META);\n\n\tstatus = ocfs2_claim_suballoc_bits(ac,\n\t\t\t\t\t   handle,\n\t\t\t\t\t   bits_wanted,\n\t\t\t\t\t   1,\n\t\t\t\t\t   &res);\n\tif (status < 0) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\tatomic_inc(&OCFS2_SB(ac->ac_inode->i_sb)->alloc_stats.bg_allocs);\n\n\t*suballoc_loc = res.sr_bg_blkno;\n\t*suballoc_bit_start = res.sr_bit_offset;\n\t*blkno_start = res.sr_blkno;\n\tac->ac_bits_given += res.sr_bits;\n\t*num_bits = res.sr_bits;\n\tstatus = 0;\nbail:\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_journal_access_di",
          "args": [
            "handle",
            "INODE_CACHE(inode)",
            "di_bh",
            "OCFS2_JOURNAL_ACCESS_WRITE"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_journal_access_di",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "710-714",
          "snippet": "int ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic struct ocfs2_triggers di_triggers = {\n\t.ot_triggers = {\n\t\t.t_frozen = ocfs2_frozen_trigger,\n\t\t.t_abort = ocfs2_abort_trigger,\n\t},\n\t.ot_offset\t= offsetof(struct ocfs2_dinode, i_check),\n};\n\nint ocfs2_journal_access_di(handle_t *handle, struct ocfs2_caching_info *ci,\n\t\t\t    struct buffer_head *bh, int type)\n{\n\treturn __ocfs2_journal_access(handle, ci, bh, &di_triggers, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INODE_CACHE",
          "args": [
            "inode"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "INODE_CACHE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "131-134",
          "snippet": "static inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_caching_info *INODE_CACHE(struct inode *inode)\n{\n\treturn &OCFS2_I(inode)->ip_metadata_cache;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "handle"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "handle"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_start_trans",
          "args": [
            "osb",
            "OCFS2_REFCOUNT_TREE_CREATE_CREDITS"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_start_trans",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/journal.c",
          "lines": "348-386",
          "snippet": "handle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"namei.h\"",
            "#include \"file.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dir.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/delay.h>",
            "#include <linux/random.h>",
            "#include <linux/time.h>",
            "#include <linux/kthread.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ocfs2_commit_cache(struct ocfs2_super *osb);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"namei.h\"\n#include \"file.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dir.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/time.h>\n#include <linux/kthread.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nstatic int ocfs2_commit_cache(struct ocfs2_super *osb);\n\nhandle_t *ocfs2_start_trans(struct ocfs2_super *osb, int max_buffs)\n{\n\tjournal_t *journal = osb->journal->j_journal;\n\thandle_t *handle;\n\n\tBUG_ON(!osb || !osb->journal->j_journal);\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn ERR_PTR(-EROFS);\n\n\tBUG_ON(osb->journal->j_state == OCFS2_JOURNAL_FREE);\n\tBUG_ON(max_buffs <= 0);\n\n\t/* Nested transaction? Just return the handle... */\n\tif (journal_current_handle())\n\t\treturn jbd2_journal_start(journal, max_buffs);\n\n\tsb_start_intwrite(osb->sb);\n\n\tdown_read(&osb->journal->j_trans_barrier);\n\n\thandle = jbd2_journal_start(journal, max_buffs);\n\tif (IS_ERR(handle)) {\n\t\tup_read(&osb->journal->j_trans_barrier);\n\t\tsb_end_intwrite(osb->sb);\n\n\t\tmlog_errno(PTR_ERR(handle));\n\n\t\tif (is_journal_aborted(journal)) {\n\t\t\tocfs2_abort(osb->sb, \"Detected aborted journal\");\n\t\t\thandle = ERR_PTR(-EROFS);\n\t\t}\n\t} else {\n\t\tif (!ocfs2_mount_local(osb))\n\t\t\tatomic_inc(&(osb->journal->j_num_trans));\n\t}\n\n\treturn handle;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_reserve_new_metadata_blocks",
          "args": [
            "osb",
            "1",
            "&meta_ac"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_reserve_new_metadata_blocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/suballoc.c",
          "lines": "989-1049",
          "snippet": "int ocfs2_reserve_new_metadata_blocks(struct ocfs2_super *osb,\n\t\t\t\t      int blocks,\n\t\t\t\t      struct ocfs2_alloc_context **ac)\n{\n\tint status;\n\tint slot = ocfs2_get_meta_steal_slot(osb);\n\n\t*ac = kzalloc(sizeof(struct ocfs2_alloc_context), GFP_KERNEL);\n\tif (!(*ac)) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t(*ac)->ac_bits_wanted = blocks;\n\t(*ac)->ac_which = OCFS2_AC_USE_META;\n\t(*ac)->ac_group_search = ocfs2_block_group_search;\n\n\tif (slot != OCFS2_INVALID_SLOT &&\n\t\tatomic_read(&osb->s_num_meta_stolen) < OCFS2_MAX_TO_STEAL)\n\t\tgoto extent_steal;\n\n\tatomic_set(&osb->s_num_meta_stolen, 0);\n\tstatus = ocfs2_reserve_suballoc_bits(osb, (*ac),\n\t\t\t\t\t     EXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t     (u32)osb->slot_num, NULL,\n\t\t\t\t\t     ALLOC_GROUPS_FROM_GLOBAL|ALLOC_NEW_GROUP);\n\n\n\tif (status >= 0) {\n\t\tstatus = 0;\n\t\tif (slot != OCFS2_INVALID_SLOT)\n\t\t\tocfs2_init_meta_steal_slot(osb);\n\t\tgoto bail;\n\t} else if (status < 0 && status != -ENOSPC) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_free_ac_resource(*ac);\n\nextent_steal:\n\tstatus = ocfs2_steal_meta(osb, *ac);\n\tatomic_inc(&osb->s_num_meta_stolen);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = 0;\nbail:\n\tif ((status < 0) && *ac) {\n\t\tocfs2_free_alloc_context(*ac);\n\t\t*ac = NULL;\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define OCFS2_MAX_TO_STEAL\t\t1024",
            "#define ALLOC_GROUPS_FROM_GLOBAL\t0x2",
            "#define ALLOC_NEW_GROUP\t\t\t0x1"
          ],
          "globals_used": [
            "static int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\n#define OCFS2_MAX_TO_STEAL\t\t1024\n#define ALLOC_GROUPS_FROM_GLOBAL\t0x2\n#define ALLOC_NEW_GROUP\t\t\t0x1\n\nstatic int ocfs2_reserve_clusters_with_limit(struct ocfs2_super *osb,\n\t\t\t\t\t     u32 bits_wanted, u64 max_block,\n\t\t\t\t\t     int flags,\n\t\t\t\t\t     struct ocfs2_alloc_context **ac);\n\nint ocfs2_reserve_new_metadata_blocks(struct ocfs2_super *osb,\n\t\t\t\t      int blocks,\n\t\t\t\t      struct ocfs2_alloc_context **ac)\n{\n\tint status;\n\tint slot = ocfs2_get_meta_steal_slot(osb);\n\n\t*ac = kzalloc(sizeof(struct ocfs2_alloc_context), GFP_KERNEL);\n\tif (!(*ac)) {\n\t\tstatus = -ENOMEM;\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\t(*ac)->ac_bits_wanted = blocks;\n\t(*ac)->ac_which = OCFS2_AC_USE_META;\n\t(*ac)->ac_group_search = ocfs2_block_group_search;\n\n\tif (slot != OCFS2_INVALID_SLOT &&\n\t\tatomic_read(&osb->s_num_meta_stolen) < OCFS2_MAX_TO_STEAL)\n\t\tgoto extent_steal;\n\n\tatomic_set(&osb->s_num_meta_stolen, 0);\n\tstatus = ocfs2_reserve_suballoc_bits(osb, (*ac),\n\t\t\t\t\t     EXTENT_ALLOC_SYSTEM_INODE,\n\t\t\t\t\t     (u32)osb->slot_num, NULL,\n\t\t\t\t\t     ALLOC_GROUPS_FROM_GLOBAL|ALLOC_NEW_GROUP);\n\n\n\tif (status >= 0) {\n\t\tstatus = 0;\n\t\tif (slot != OCFS2_INVALID_SLOT)\n\t\t\tocfs2_init_meta_steal_slot(osb);\n\t\tgoto bail;\n\t} else if (status < 0 && status != -ENOSPC) {\n\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tocfs2_free_ac_resource(*ac);\n\nextent_steal:\n\tstatus = ocfs2_steal_meta(osb, *ac);\n\tatomic_inc(&osb->s_num_meta_stolen);\n\tif (status < 0) {\n\t\tif (status != -ENOSPC)\n\t\t\tmlog_errno(status);\n\t\tgoto bail;\n\t}\n\n\tstatus = 0;\nbail:\n\tif ((status < 0) && *ac) {\n\t\tocfs2_free_alloc_context(*ac);\n\t\t*ac = NULL;\n\t}\n\n\tif (status)\n\t\tmlog_errno(status);\n\treturn status;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_create_refcount_tree",
          "args": [
            "(unsigned long long)OCFS2_I(inode)->ip_blkno"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "oi->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "inode->i_sb"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_create_refcount_tree(struct inode *inode,\n\t\t\t\t      struct buffer_head *di_bh)\n{\n\tint ret;\n\thandle_t *handle = NULL;\n\tstruct ocfs2_alloc_context *meta_ac = NULL;\n\tstruct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;\n\tstruct ocfs2_inode_info *oi = OCFS2_I(inode);\n\tstruct ocfs2_super *osb = OCFS2_SB(inode->i_sb);\n\tstruct buffer_head *new_bh = NULL;\n\tstruct ocfs2_refcount_block *rb;\n\tstruct ocfs2_refcount_tree *new_tree = NULL, *tree = NULL;\n\tu16 suballoc_bit_start;\n\tu32 num_got;\n\tu64 suballoc_loc, first_blkno;\n\n\tBUG_ON(oi->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL);\n\n\ttrace_ocfs2_create_refcount_tree(\n\t\t(unsigned long long)OCFS2_I(inode)->ip_blkno);\n\n\tret = ocfs2_reserve_new_metadata_blocks(osb, 1, &meta_ac);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\thandle = ocfs2_start_trans(osb, OCFS2_REFCOUNT_TREE_CREATE_CREDITS);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_journal_access_di(handle, INODE_CACHE(inode), di_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_WRITE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tret = ocfs2_claim_metadata(handle, meta_ac, 1, &suballoc_loc,\n\t\t\t\t   &suballoc_bit_start, &num_got,\n\t\t\t\t   &first_blkno);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tnew_tree = ocfs2_allocate_refcount_tree(osb, first_blkno);\n\tif (!new_tree) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\tnew_bh = sb_getblk(inode->i_sb, first_blkno);\n\tif (!new_bh) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\tocfs2_set_new_buffer_uptodate(&new_tree->rf_ci, new_bh);\n\n\tret = ocfs2_journal_access_rb(handle, &new_tree->rf_ci, new_bh,\n\t\t\t\t      OCFS2_JOURNAL_ACCESS_CREATE);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out_commit;\n\t}\n\n\t/* Initialize ocfs2_refcount_block. */\n\trb = (struct ocfs2_refcount_block *)new_bh->b_data;\n\tmemset(rb, 0, inode->i_sb->s_blocksize);\n\tstrcpy((void *)rb, OCFS2_REFCOUNT_BLOCK_SIGNATURE);\n\trb->rf_suballoc_slot = cpu_to_le16(meta_ac->ac_alloc_slot);\n\trb->rf_suballoc_loc = cpu_to_le64(suballoc_loc);\n\trb->rf_suballoc_bit = cpu_to_le16(suballoc_bit_start);\n\trb->rf_fs_generation = cpu_to_le32(osb->fs_generation);\n\trb->rf_blkno = cpu_to_le64(first_blkno);\n\trb->rf_count = cpu_to_le32(1);\n\trb->rf_records.rl_count =\n\t\t\tcpu_to_le16(ocfs2_refcount_recs_per_rb(osb->sb));\n\tspin_lock(&osb->osb_lock);\n\trb->rf_generation = osb->s_next_generation++;\n\tspin_unlock(&osb->osb_lock);\n\n\tocfs2_journal_dirty(handle, new_bh);\n\n\tspin_lock(&oi->ip_lock);\n\toi->ip_dyn_features |= OCFS2_HAS_REFCOUNT_FL;\n\tdi->i_dyn_features = cpu_to_le16(oi->ip_dyn_features);\n\tdi->i_refcount_loc = cpu_to_le64(first_blkno);\n\tspin_unlock(&oi->ip_lock);\n\n\ttrace_ocfs2_create_refcount_tree_blkno((unsigned long long)first_blkno);\n\n\tocfs2_journal_dirty(handle, di_bh);\n\n\t/*\n\t * We have to init the tree lock here since it will use\n\t * the generation number to create it.\n\t */\n\tnew_tree->rf_generation = le32_to_cpu(rb->rf_generation);\n\tocfs2_init_refcount_tree_lock(osb, new_tree, first_blkno,\n\t\t\t\t      new_tree->rf_generation);\n\n\tspin_lock(&osb->osb_lock);\n\ttree = ocfs2_find_refcount_tree(osb, first_blkno);\n\n\t/*\n\t * We've just created a new refcount tree in this block.  If\n\t * we found a refcount tree on the ocfs2_super, it must be\n\t * one we just deleted.  We free the old tree before\n\t * inserting the new tree.\n\t */\n\tBUG_ON(tree && tree->rf_generation == new_tree->rf_generation);\n\tif (tree)\n\t\tocfs2_erase_refcount_tree_from_list_no_lock(osb, tree);\n\tocfs2_insert_refcount_tree(osb, new_tree);\n\tspin_unlock(&osb->osb_lock);\n\tnew_tree = NULL;\n\tif (tree)\n\t\tocfs2_refcount_tree_put(tree);\n\nout_commit:\n\tocfs2_commit_trans(osb, handle);\n\nout:\n\tif (new_tree) {\n\t\tocfs2_metadata_cache_exit(&new_tree->rf_ci);\n\t\tkfree(new_tree);\n\t}\n\n\tbrelse(new_bh);\n\tif (meta_ac)\n\t\tocfs2_free_alloc_context(meta_ac);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_purge_refcount_trees",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "538-553",
    "snippet": "void ocfs2_purge_refcount_trees(struct ocfs2_super *osb)\n{\n\tstruct rb_node *node;\n\tstruct ocfs2_refcount_tree *tree;\n\tstruct rb_root *root = &osb->osb_rf_lock_tree;\n\n\twhile ((node = rb_last(root)) != NULL) {\n\t\ttree = rb_entry(node, struct ocfs2_refcount_tree, rf_node);\n\n\t\ttrace_ocfs2_purge_refcount_trees(\n\t\t\t\t(unsigned long long) tree->rf_blkno);\n\n\t\trb_erase(&tree->rf_node, root);\n\t\tocfs2_free_refcount_tree(tree);\n\t}\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_free_refcount_tree",
          "args": [
            "tree"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_refcount_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "253-259",
          "snippet": "static void ocfs2_free_refcount_tree(struct ocfs2_refcount_tree *tree)\n{\n\tocfs2_metadata_cache_exit(&tree->rf_ci);\n\tocfs2_simple_drop_lockres(OCFS2_SB(tree->rf_sb), &tree->rf_lockres);\n\tocfs2_lock_res_free(&tree->rf_lockres);\n\tkfree(tree);\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic void ocfs2_free_refcount_tree(struct ocfs2_refcount_tree *tree)\n{\n\tocfs2_metadata_cache_exit(&tree->rf_ci);\n\tocfs2_simple_drop_lockres(OCFS2_SB(tree->rf_sb), &tree->rf_lockres);\n\tocfs2_lock_res_free(&tree->rf_lockres);\n\tkfree(tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&tree->rf_node",
            "root"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_purge_refcount_trees",
          "args": [
            "(unsigned long long) tree->rf_blkno"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "node",
            "structocfs2_refcount_tree",
            "rf_node"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_last",
          "args": [
            "root"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nvoid ocfs2_purge_refcount_trees(struct ocfs2_super *osb)\n{\n\tstruct rb_node *node;\n\tstruct ocfs2_refcount_tree *tree;\n\tstruct rb_root *root = &osb->osb_rf_lock_tree;\n\n\twhile ((node = rb_last(root)) != NULL) {\n\t\ttree = rb_entry(node, struct ocfs2_refcount_tree, rf_node);\n\n\t\ttrace_ocfs2_purge_refcount_trees(\n\t\t\t\t(unsigned long long) tree->rf_blkno);\n\n\t\trb_erase(&tree->rf_node, root);\n\t\tocfs2_free_refcount_tree(tree);\n\t}\n}"
  },
  {
    "function_name": "ocfs2_unlock_refcount_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "526-536",
    "snippet": "void ocfs2_unlock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_refcount_tree *tree, int rw)\n{\n\tif (rw)\n\t\tup_write(&tree->rf_sem);\n\telse\n\t\tup_read(&tree->rf_sem);\n\n\tocfs2_refcount_unlock(tree, rw);\n\tocfs2_refcount_tree_put(tree);\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_refcount_tree_put",
          "args": [
            "tree"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_refcount_tree_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "292-296",
          "snippet": "static inline void\nocfs2_refcount_tree_put(struct ocfs2_refcount_tree *tree)\n{\n\tkref_put(&tree->rf_getcnt, ocfs2_kref_remove_refcount_tree);\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic inline void\nocfs2_refcount_tree_put(struct ocfs2_refcount_tree *tree)\n{\n\tkref_put(&tree->rf_getcnt, ocfs2_kref_remove_refcount_tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_refcount_unlock",
          "args": [
            "tree",
            "rw"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_refcount_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "3928-3936",
          "snippet": "void ocfs2_refcount_unlock(struct ocfs2_refcount_tree *ref_tree, int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &ref_tree->rf_lockres;\n\tstruct ocfs2_super *osb = lockres->l_priv;\n\n\tif (!ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(osb, lockres, level);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_refcount_unlock(struct ocfs2_refcount_tree *ref_tree, int ex)\n{\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &ref_tree->rf_lockres;\n\tstruct ocfs2_super *osb = lockres->l_priv;\n\n\tif (!ocfs2_mount_local(osb))\n\t\tocfs2_cluster_unlock(osb, lockres, level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&tree->rf_sem"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&tree->rf_sem"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nvoid ocfs2_unlock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_refcount_tree *tree, int rw)\n{\n\tif (rw)\n\t\tup_write(&tree->rf_sem);\n\telse\n\t\tup_read(&tree->rf_sem);\n\n\tocfs2_refcount_unlock(tree, rw);\n\tocfs2_refcount_tree_put(tree);\n}"
  },
  {
    "function_name": "ocfs2_lock_refcount_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "452-524",
    "snippet": "int ocfs2_lock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t     u64 ref_blkno, int rw,\n\t\t\t     struct ocfs2_refcount_tree **ret_tree,\n\t\t\t     struct buffer_head **ref_bh)\n{\n\tint ret, delete_tree = 0;\n\tstruct ocfs2_refcount_tree *tree = NULL;\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_block *rb;\n\nagain:\n\tret = ocfs2_get_refcount_tree(osb, ref_blkno, &tree);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tocfs2_refcount_tree_get(tree);\n\n\tret = __ocfs2_lock_refcount_tree(osb, tree, rw);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_refcount_tree_put(tree);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_refcount_block(&tree->rf_ci, tree->rf_blkno,\n\t\t\t\t\t&ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_unlock_refcount_tree(osb, tree, rw);\n\t\tocfs2_refcount_tree_put(tree);\n\t\tgoto out;\n\t}\n\n\trb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\t/*\n\t * If the refcount block has been freed and re-created, we may need\n\t * to recreate the refcount tree also.\n\t *\n\t * Here we just remove the tree from the rb-tree, and the last\n\t * kref holder will unlock and delete this refcount_tree.\n\t * Then we goto \"again\" and ocfs2_get_refcount_tree will create\n\t * the new refcount tree for us.\n\t */\n\tif (tree->rf_generation != le32_to_cpu(rb->rf_generation)) {\n\t\tif (!tree->rf_removed) {\n\t\t\tocfs2_erase_refcount_tree_from_list(osb, tree);\n\t\t\ttree->rf_removed = 1;\n\t\t\tdelete_tree = 1;\n\t\t}\n\n\t\tocfs2_unlock_refcount_tree(osb, tree, rw);\n\t\t/*\n\t\t * We get an extra reference when we create the refcount\n\t\t * tree, so another put will destroy it.\n\t\t */\n\t\tif (delete_tree)\n\t\t\tocfs2_refcount_tree_put(tree);\n\t\tbrelse(ref_root_bh);\n\t\tref_root_bh = NULL;\n\t\tgoto again;\n\t}\n\n\t*ret_tree = tree;\n\tif (ref_bh) {\n\t\t*ref_bh = ref_root_bh;\n\t\tref_root_bh = NULL;\n\t}\nout:\n\tbrelse(ref_root_bh);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "ref_root_bh"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_refcount_tree_put",
          "args": [
            "tree"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_refcount_tree_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "292-296",
          "snippet": "static inline void\nocfs2_refcount_tree_put(struct ocfs2_refcount_tree *tree)\n{\n\tkref_put(&tree->rf_getcnt, ocfs2_kref_remove_refcount_tree);\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic inline void\nocfs2_refcount_tree_put(struct ocfs2_refcount_tree *tree)\n{\n\tkref_put(&tree->rf_getcnt, ocfs2_kref_remove_refcount_tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_unlock_refcount_tree",
          "args": [
            "osb",
            "tree",
            "rw"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_unlock_refcount_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "526-536",
          "snippet": "void ocfs2_unlock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_refcount_tree *tree, int rw)\n{\n\tif (rw)\n\t\tup_write(&tree->rf_sem);\n\telse\n\t\tup_read(&tree->rf_sem);\n\n\tocfs2_refcount_unlock(tree, rw);\n\tocfs2_refcount_tree_put(tree);\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nvoid ocfs2_unlock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_refcount_tree *tree, int rw)\n{\n\tif (rw)\n\t\tup_write(&tree->rf_sem);\n\telse\n\t\tup_read(&tree->rf_sem);\n\n\tocfs2_refcount_unlock(tree, rw);\n\tocfs2_refcount_tree_put(tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_erase_refcount_tree_from_list",
          "args": [
            "osb",
            "tree"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_erase_refcount_tree_from_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "270-276",
          "snippet": "static void ocfs2_erase_refcount_tree_from_list(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_refcount_tree *tree)\n{\n\tspin_lock(&osb->osb_lock);\n\tocfs2_erase_refcount_tree_from_list_no_lock(osb, tree);\n\tspin_unlock(&osb->osb_lock);\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic void ocfs2_erase_refcount_tree_from_list(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_refcount_tree *tree)\n{\n\tspin_lock(&osb->osb_lock);\n\tocfs2_erase_refcount_tree_from_list_no_lock(osb, tree);\n\tspin_unlock(&osb->osb_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rb->rf_generation"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_refcount_block",
          "args": [
            "&tree->rf_ci",
            "tree->rf_blkno",
            "&ref_root_bh"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_refcount_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "133-148",
          "snippet": "static int ocfs2_read_refcount_block(struct ocfs2_caching_info *ci,\n\t\t\t\t     u64 rb_blkno,\n\t\t\t\t     struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(ci, rb_blkno, &tmp,\n\t\t\t      ocfs2_validate_refcount_block);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_read_refcount_block(struct ocfs2_caching_info *ci,\n\t\t\t\t     u64 rb_blkno,\n\t\t\t\t     struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(ci, rb_blkno, &tmp,\n\t\t\t      ocfs2_validate_refcount_block);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ocfs2_lock_refcount_tree",
          "args": [
            "osb",
            "tree",
            "rw"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_lock_refcount_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "424-442",
          "snippet": "static int __ocfs2_lock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t\t      struct ocfs2_refcount_tree *tree, int rw)\n{\n\tint ret;\n\n\tret = ocfs2_refcount_lock(tree, rw);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (rw)\n\t\tdown_write(&tree->rf_sem);\n\telse\n\t\tdown_read(&tree->rf_sem);\n\nout:\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int __ocfs2_lock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t\t      struct ocfs2_refcount_tree *tree, int rw)\n{\n\tint ret;\n\n\tret = ocfs2_refcount_lock(tree, rw);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (rw)\n\t\tdown_write(&tree->rf_sem);\n\telse\n\t\tdown_read(&tree->rf_sem);\n\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_refcount_tree_get",
          "args": [
            "tree"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_refcount_tree_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "286-290",
          "snippet": "static inline void\nocfs2_refcount_tree_get(struct ocfs2_refcount_tree *tree)\n{\n\tkref_get(&tree->rf_getcnt);\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic inline void\nocfs2_refcount_tree_get(struct ocfs2_refcount_tree *tree)\n{\n\tkref_get(&tree->rf_getcnt);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_get_refcount_tree",
          "args": [
            "osb",
            "ref_blkno",
            "&tree"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_get_refcount_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "332-401",
          "snippet": "static int ocfs2_get_refcount_tree(struct ocfs2_super *osb, u64 rf_blkno,\n\t\t\t\t   struct ocfs2_refcount_tree **ret_tree)\n{\n\tint ret = 0;\n\tstruct ocfs2_refcount_tree *tree, *new = NULL;\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_block *ref_rb;\n\n\tspin_lock(&osb->osb_lock);\n\tif (osb->osb_ref_tree_lru &&\n\t    osb->osb_ref_tree_lru->rf_blkno == rf_blkno)\n\t\ttree = osb->osb_ref_tree_lru;\n\telse\n\t\ttree = ocfs2_find_refcount_tree(osb, rf_blkno);\n\tif (tree)\n\t\tgoto out;\n\n\tspin_unlock(&osb->osb_lock);\n\n\tnew = ocfs2_allocate_refcount_tree(osb, rf_blkno);\n\tif (!new) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\t/*\n\t * We need the generation to create the refcount tree lock and since\n\t * it isn't changed during the tree modification, we are safe here to\n\t * read without protection.\n\t * We also have to purge the cache after we create the lock since the\n\t * refcount block may have the stale data. It can only be trusted when\n\t * we hold the refcount lock.\n\t */\n\tret = ocfs2_read_refcount_block(&new->rf_ci, rf_blkno, &ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_metadata_cache_exit(&new->rf_ci);\n\t\tkfree(new);\n\t\treturn ret;\n\t}\n\n\tref_rb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\tnew->rf_generation = le32_to_cpu(ref_rb->rf_generation);\n\tocfs2_init_refcount_tree_lock(osb, new, rf_blkno,\n\t\t\t\t      new->rf_generation);\n\tocfs2_metadata_cache_purge(&new->rf_ci);\n\n\tspin_lock(&osb->osb_lock);\n\ttree = ocfs2_find_refcount_tree(osb, rf_blkno);\n\tif (tree)\n\t\tgoto out;\n\n\tocfs2_insert_refcount_tree(osb, new);\n\n\ttree = new;\n\tnew = NULL;\n\nout:\n\t*ret_tree = tree;\n\n\tosb->osb_ref_tree_lru = tree;\n\n\tspin_unlock(&osb->osb_lock);\n\n\tif (new)\n\t\tocfs2_free_refcount_tree(new);\n\n\tbrelse(ref_root_bh);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_get_refcount_tree(struct ocfs2_super *osb, u64 rf_blkno,\n\t\t\t\t   struct ocfs2_refcount_tree **ret_tree)\n{\n\tint ret = 0;\n\tstruct ocfs2_refcount_tree *tree, *new = NULL;\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_block *ref_rb;\n\n\tspin_lock(&osb->osb_lock);\n\tif (osb->osb_ref_tree_lru &&\n\t    osb->osb_ref_tree_lru->rf_blkno == rf_blkno)\n\t\ttree = osb->osb_ref_tree_lru;\n\telse\n\t\ttree = ocfs2_find_refcount_tree(osb, rf_blkno);\n\tif (tree)\n\t\tgoto out;\n\n\tspin_unlock(&osb->osb_lock);\n\n\tnew = ocfs2_allocate_refcount_tree(osb, rf_blkno);\n\tif (!new) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\t/*\n\t * We need the generation to create the refcount tree lock and since\n\t * it isn't changed during the tree modification, we are safe here to\n\t * read without protection.\n\t * We also have to purge the cache after we create the lock since the\n\t * refcount block may have the stale data. It can only be trusted when\n\t * we hold the refcount lock.\n\t */\n\tret = ocfs2_read_refcount_block(&new->rf_ci, rf_blkno, &ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_metadata_cache_exit(&new->rf_ci);\n\t\tkfree(new);\n\t\treturn ret;\n\t}\n\n\tref_rb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\tnew->rf_generation = le32_to_cpu(ref_rb->rf_generation);\n\tocfs2_init_refcount_tree_lock(osb, new, rf_blkno,\n\t\t\t\t      new->rf_generation);\n\tocfs2_metadata_cache_purge(&new->rf_ci);\n\n\tspin_lock(&osb->osb_lock);\n\ttree = ocfs2_find_refcount_tree(osb, rf_blkno);\n\tif (tree)\n\t\tgoto out;\n\n\tocfs2_insert_refcount_tree(osb, new);\n\n\ttree = new;\n\tnew = NULL;\n\nout:\n\t*ret_tree = tree;\n\n\tosb->osb_ref_tree_lru = tree;\n\n\tspin_unlock(&osb->osb_lock);\n\n\tif (new)\n\t\tocfs2_free_refcount_tree(new);\n\n\tbrelse(ref_root_bh);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nint ocfs2_lock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t     u64 ref_blkno, int rw,\n\t\t\t     struct ocfs2_refcount_tree **ret_tree,\n\t\t\t     struct buffer_head **ref_bh)\n{\n\tint ret, delete_tree = 0;\n\tstruct ocfs2_refcount_tree *tree = NULL;\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_block *rb;\n\nagain:\n\tret = ocfs2_get_refcount_tree(osb, ref_blkno, &tree);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\n\tocfs2_refcount_tree_get(tree);\n\n\tret = __ocfs2_lock_refcount_tree(osb, tree, rw);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_refcount_tree_put(tree);\n\t\tgoto out;\n\t}\n\n\tret = ocfs2_read_refcount_block(&tree->rf_ci, tree->rf_blkno,\n\t\t\t\t\t&ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_unlock_refcount_tree(osb, tree, rw);\n\t\tocfs2_refcount_tree_put(tree);\n\t\tgoto out;\n\t}\n\n\trb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\t/*\n\t * If the refcount block has been freed and re-created, we may need\n\t * to recreate the refcount tree also.\n\t *\n\t * Here we just remove the tree from the rb-tree, and the last\n\t * kref holder will unlock and delete this refcount_tree.\n\t * Then we goto \"again\" and ocfs2_get_refcount_tree will create\n\t * the new refcount tree for us.\n\t */\n\tif (tree->rf_generation != le32_to_cpu(rb->rf_generation)) {\n\t\tif (!tree->rf_removed) {\n\t\t\tocfs2_erase_refcount_tree_from_list(osb, tree);\n\t\t\ttree->rf_removed = 1;\n\t\t\tdelete_tree = 1;\n\t\t}\n\n\t\tocfs2_unlock_refcount_tree(osb, tree, rw);\n\t\t/*\n\t\t * We get an extra reference when we create the refcount\n\t\t * tree, so another put will destroy it.\n\t\t */\n\t\tif (delete_tree)\n\t\t\tocfs2_refcount_tree_put(tree);\n\t\tbrelse(ref_root_bh);\n\t\tref_root_bh = NULL;\n\t\tgoto again;\n\t}\n\n\t*ret_tree = tree;\n\tif (ref_bh) {\n\t\t*ref_bh = ref_root_bh;\n\t\tref_root_bh = NULL;\n\t}\nout:\n\tbrelse(ref_root_bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "__ocfs2_lock_refcount_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "424-442",
    "snippet": "static int __ocfs2_lock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t\t      struct ocfs2_refcount_tree *tree, int rw)\n{\n\tint ret;\n\n\tret = ocfs2_refcount_lock(tree, rw);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (rw)\n\t\tdown_write(&tree->rf_sem);\n\telse\n\t\tdown_read(&tree->rf_sem);\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&tree->rf_sem"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&tree->rf_sem"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_refcount_lock",
          "args": [
            "tree",
            "rw"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_refcount_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "3907-3926",
          "snippet": "int ocfs2_refcount_lock(struct ocfs2_refcount_tree *ref_tree, int ex)\n{\n\tint status;\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &ref_tree->rf_lockres;\n\tstruct ocfs2_super *osb = lockres->l_priv;\n\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn -EROFS;\n\n\tif (ocfs2_mount_local(osb))\n\t\treturn 0;\n\n\tstatus = ocfs2_cluster_lock(osb, lockres, level, 0, 0);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\treturn status;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static inline int ocfs2_highest_compat_lock_level(int level);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic int ocfs2_generic_handle_bast(struct ocfs2_lock_res *lockres, int level);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic inline int ocfs2_highest_compat_lock_level(int level);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nint ocfs2_refcount_lock(struct ocfs2_refcount_tree *ref_tree, int ex)\n{\n\tint status;\n\tint level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;\n\tstruct ocfs2_lock_res *lockres = &ref_tree->rf_lockres;\n\tstruct ocfs2_super *osb = lockres->l_priv;\n\n\n\tif (ocfs2_is_hard_readonly(osb))\n\t\treturn -EROFS;\n\n\tif (ocfs2_mount_local(osb))\n\t\treturn 0;\n\n\tstatus = ocfs2_cluster_lock(osb, lockres, level, 0, 0);\n\tif (status < 0)\n\t\tmlog_errno(status);\n\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int __ocfs2_lock_refcount_tree(struct ocfs2_super *osb,\n\t\t\t\t      struct ocfs2_refcount_tree *tree, int rw)\n{\n\tint ret;\n\n\tret = ocfs2_refcount_lock(tree, rw);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tif (rw)\n\t\tdown_write(&tree->rf_sem);\n\telse\n\t\tdown_read(&tree->rf_sem);\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_get_refcount_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "403-422",
    "snippet": "static int ocfs2_get_refcount_block(struct inode *inode, u64 *ref_blkno)\n{\n\tint ret;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\n\tret = ocfs2_read_inode_block(inode, &di_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tBUG_ON(!(OCFS2_I(inode)->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL));\n\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\t*ref_blkno = le64_to_cpu(di->i_refcount_loc);\n\tbrelse(di_bh);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "di_bh"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "di->i_refcount_loc"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(OCFS2_I(inode)->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL)"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OCFS2_I",
          "args": [
            "inode"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "OCFS2_I",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.h",
          "lines": "118-121",
          "snippet": "static inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}",
          "includes": [
            "#include \"extent_map.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"extent_map.h\"\n\nstatic inline struct ocfs2_inode_info *OCFS2_I(struct inode *inode)\n{\n\treturn container_of(inode, struct ocfs2_inode_info, vfs_inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_inode_block",
          "args": [
            "inode",
            "&di_bh"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_inode_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/inode.c",
          "lines": "1404-1407",
          "snippet": "int ocfs2_read_inode_block(struct inode *inode, struct buffer_head **bh)\n{\n\treturn ocfs2_read_inode_block_full(inode, bh, 0);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"ocfs2_trace.h\"",
            "#include \"refcounttree.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"symlink.h\"",
            "#include \"super.h\"",
            "#include \"suballoc.h\"",
            "#include \"namei.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"dir.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"ocfs2_trace.h\"\n#include \"refcounttree.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"symlink.h\"\n#include \"super.h\"\n#include \"suballoc.h\"\n#include \"namei.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"dir.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/quotaops.h>\n#include <linux/pagemap.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_inode_block(struct inode *inode, struct buffer_head **bh)\n{\n\treturn ocfs2_read_inode_block_full(inode, bh, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_get_refcount_block(struct inode *inode, u64 *ref_blkno)\n{\n\tint ret;\n\tstruct buffer_head *di_bh = NULL;\n\tstruct ocfs2_dinode *di;\n\n\tret = ocfs2_read_inode_block(inode, &di_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tgoto out;\n\t}\n\n\tBUG_ON(!(OCFS2_I(inode)->ip_dyn_features & OCFS2_HAS_REFCOUNT_FL));\n\n\tdi = (struct ocfs2_dinode *)di_bh->b_data;\n\t*ref_blkno = le64_to_cpu(di->i_refcount_loc);\n\tbrelse(di_bh);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_get_refcount_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "332-401",
    "snippet": "static int ocfs2_get_refcount_tree(struct ocfs2_super *osb, u64 rf_blkno,\n\t\t\t\t   struct ocfs2_refcount_tree **ret_tree)\n{\n\tint ret = 0;\n\tstruct ocfs2_refcount_tree *tree, *new = NULL;\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_block *ref_rb;\n\n\tspin_lock(&osb->osb_lock);\n\tif (osb->osb_ref_tree_lru &&\n\t    osb->osb_ref_tree_lru->rf_blkno == rf_blkno)\n\t\ttree = osb->osb_ref_tree_lru;\n\telse\n\t\ttree = ocfs2_find_refcount_tree(osb, rf_blkno);\n\tif (tree)\n\t\tgoto out;\n\n\tspin_unlock(&osb->osb_lock);\n\n\tnew = ocfs2_allocate_refcount_tree(osb, rf_blkno);\n\tif (!new) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\t/*\n\t * We need the generation to create the refcount tree lock and since\n\t * it isn't changed during the tree modification, we are safe here to\n\t * read without protection.\n\t * We also have to purge the cache after we create the lock since the\n\t * refcount block may have the stale data. It can only be trusted when\n\t * we hold the refcount lock.\n\t */\n\tret = ocfs2_read_refcount_block(&new->rf_ci, rf_blkno, &ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_metadata_cache_exit(&new->rf_ci);\n\t\tkfree(new);\n\t\treturn ret;\n\t}\n\n\tref_rb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\tnew->rf_generation = le32_to_cpu(ref_rb->rf_generation);\n\tocfs2_init_refcount_tree_lock(osb, new, rf_blkno,\n\t\t\t\t      new->rf_generation);\n\tocfs2_metadata_cache_purge(&new->rf_ci);\n\n\tspin_lock(&osb->osb_lock);\n\ttree = ocfs2_find_refcount_tree(osb, rf_blkno);\n\tif (tree)\n\t\tgoto out;\n\n\tocfs2_insert_refcount_tree(osb, new);\n\n\ttree = new;\n\tnew = NULL;\n\nout:\n\t*ret_tree = tree;\n\n\tosb->osb_ref_tree_lru = tree;\n\n\tspin_unlock(&osb->osb_lock);\n\n\tif (new)\n\t\tocfs2_free_refcount_tree(new);\n\n\tbrelse(ref_root_bh);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "brelse",
          "args": [
            "ref_root_bh"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "__brelse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/buffer.c",
          "lines": "1177-1184",
          "snippet": "void __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}",
          "includes": [
            "#include <trace/events/block.h>",
            "#include <linux/bit_spinlock.h>",
            "#include <linux/mpage.h>",
            "#include <linux/bitops.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/bio.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/suspend.h>",
            "#include <linux/hash.h>",
            "#include <linux/writeback.h>",
            "#include <linux/export.h>",
            "#include <linux/highmem.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/file.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/capability.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/block.h>\n#include <linux/bit_spinlock.h>\n#include <linux/mpage.h>\n#include <linux/bitops.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/bio.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/buffer_head.h>\n#include <linux/suspend.h>\n#include <linux/hash.h>\n#include <linux/writeback.h>\n#include <linux/export.h>\n#include <linux/highmem.h>\n#include <linux/quotaops.h>\n#include <linux/file.h>\n#include <linux/blkdev.h>\n#include <linux/capability.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n\nvoid __brelse(struct buffer_head * buf)\n{\n\tif (atomic_read(&buf->b_count)) {\n\t\tput_bh(buf);\n\t\treturn;\n\t}\n\tWARN(1, KERN_ERR \"VFS: brelse: Trying to free free buffer\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_free_refcount_tree",
          "args": [
            "new"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_refcount_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "253-259",
          "snippet": "static void ocfs2_free_refcount_tree(struct ocfs2_refcount_tree *tree)\n{\n\tocfs2_metadata_cache_exit(&tree->rf_ci);\n\tocfs2_simple_drop_lockres(OCFS2_SB(tree->rf_sb), &tree->rf_lockres);\n\tocfs2_lock_res_free(&tree->rf_lockres);\n\tkfree(tree);\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic void ocfs2_free_refcount_tree(struct ocfs2_refcount_tree *tree)\n{\n\tocfs2_metadata_cache_exit(&tree->rf_ci);\n\tocfs2_simple_drop_lockres(OCFS2_SB(tree->rf_sb), &tree->rf_lockres);\n\tocfs2_lock_res_free(&tree->rf_lockres);\n\tkfree(tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_insert_refcount_tree",
          "args": [
            "osb",
            "new"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_insert_refcount_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "223-251",
          "snippet": "static void ocfs2_insert_refcount_tree(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_refcount_tree *new)\n{\n\tu64 rf_blkno = new->rf_blkno;\n\tstruct rb_node *parent = NULL;\n\tstruct rb_node **p = &osb->osb_rf_lock_tree.rb_node;\n\tstruct ocfs2_refcount_tree *tmp;\n\n\twhile (*p) {\n\t\tparent = *p;\n\n\t\ttmp = rb_entry(parent, struct ocfs2_refcount_tree,\n\t\t\t       rf_node);\n\n\t\tif (rf_blkno < tmp->rf_blkno)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (rf_blkno > tmp->rf_blkno)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\t/* This should never happen! */\n\t\t\tmlog(ML_ERROR, \"Duplicate refcount block %llu found!\\n\",\n\t\t\t     (unsigned long long)rf_blkno);\n\t\t\tBUG();\n\t\t}\n\t}\n\n\trb_link_node(&new->rf_node, parent, p);\n\trb_insert_color(&new->rf_node, &osb->osb_rf_lock_tree);\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic void ocfs2_insert_refcount_tree(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_refcount_tree *new)\n{\n\tu64 rf_blkno = new->rf_blkno;\n\tstruct rb_node *parent = NULL;\n\tstruct rb_node **p = &osb->osb_rf_lock_tree.rb_node;\n\tstruct ocfs2_refcount_tree *tmp;\n\n\twhile (*p) {\n\t\tparent = *p;\n\n\t\ttmp = rb_entry(parent, struct ocfs2_refcount_tree,\n\t\t\t       rf_node);\n\n\t\tif (rf_blkno < tmp->rf_blkno)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (rf_blkno > tmp->rf_blkno)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\t/* This should never happen! */\n\t\t\tmlog(ML_ERROR, \"Duplicate refcount block %llu found!\\n\",\n\t\t\t     (unsigned long long)rf_blkno);\n\t\t\tBUG();\n\t\t}\n\t}\n\n\trb_link_node(&new->rf_node, parent, p);\n\trb_insert_color(&new->rf_node, &osb->osb_rf_lock_tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_find_refcount_tree",
          "args": [
            "osb",
            "rf_blkno"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_find_refcount_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "202-220",
          "snippet": "static struct ocfs2_refcount_tree *\nocfs2_find_refcount_tree(struct ocfs2_super *osb, u64 blkno)\n{\n\tstruct rb_node *n = osb->osb_rf_lock_tree.rb_node;\n\tstruct ocfs2_refcount_tree *tree = NULL;\n\n\twhile (n) {\n\t\ttree = rb_entry(n, struct ocfs2_refcount_tree, rf_node);\n\n\t\tif (blkno < tree->rf_blkno)\n\t\t\tn = n->rb_left;\n\t\telse if (blkno > tree->rf_blkno)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn tree;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic struct ocfs2_refcount_tree *\nocfs2_find_refcount_tree(struct ocfs2_super *osb, u64 blkno)\n{\n\tstruct rb_node *n = osb->osb_rf_lock_tree.rb_node;\n\tstruct ocfs2_refcount_tree *tree = NULL;\n\n\twhile (n) {\n\t\ttree = rb_entry(n, struct ocfs2_refcount_tree, rf_node);\n\n\t\tif (blkno < tree->rf_blkno)\n\t\t\tn = n->rb_left;\n\t\telse if (blkno > tree->rf_blkno)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn tree;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_purge",
          "args": [
            "&new->rf_ci"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_purge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "171-203",
          "snippet": "void ocfs2_metadata_cache_purge(struct ocfs2_caching_info *ci)\n{\n\tunsigned int tree, to_purge, purged;\n\tstruct rb_root root = RB_ROOT;\n\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\tocfs2_metadata_cache_lock(ci);\n\ttree = !(ci->ci_flags & OCFS2_CACHE_FL_INLINE);\n\tto_purge = ci->ci_num_cached;\n\n\ttrace_ocfs2_metadata_cache_purge(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\tto_purge, tree);\n\n\t/* If we're a tree, save off the root so that we can safely\n\t * initialize the cache. We do the work to free tree members\n\t * without the spinlock. */\n\tif (tree)\n\t\troot = ci->ci_cache.ci_tree;\n\n\tocfs2_metadata_cache_reset(ci, 0);\n\tocfs2_metadata_cache_unlock(ci);\n\n\tpurged = ocfs2_purge_copied_metadata_tree(&root);\n\t/* If possible, track the number wiped so that we can more\n\t * easily detect counting errors. Unfortunately, this is only\n\t * meaningful for trees. */\n\tif (tree && purged != to_purge)\n\t\tmlog(ML_ERROR, \"Owner %llu, count = %u, purged = %u\\n\",\n\t\t     (unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t     to_purge, purged);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_metadata_cache_purge(struct ocfs2_caching_info *ci)\n{\n\tunsigned int tree, to_purge, purged;\n\tstruct rb_root root = RB_ROOT;\n\n\tBUG_ON(!ci || !ci->ci_ops);\n\n\tocfs2_metadata_cache_lock(ci);\n\ttree = !(ci->ci_flags & OCFS2_CACHE_FL_INLINE);\n\tto_purge = ci->ci_num_cached;\n\n\ttrace_ocfs2_metadata_cache_purge(\n\t\t(unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\tto_purge, tree);\n\n\t/* If we're a tree, save off the root so that we can safely\n\t * initialize the cache. We do the work to free tree members\n\t * without the spinlock. */\n\tif (tree)\n\t\troot = ci->ci_cache.ci_tree;\n\n\tocfs2_metadata_cache_reset(ci, 0);\n\tocfs2_metadata_cache_unlock(ci);\n\n\tpurged = ocfs2_purge_copied_metadata_tree(&root);\n\t/* If possible, track the number wiped so that we can more\n\t * easily detect counting errors. Unfortunately, this is only\n\t * meaningful for trees. */\n\tif (tree && purged != to_purge)\n\t\tmlog(ML_ERROR, \"Owner %llu, count = %u, purged = %u\\n\",\n\t\t     (unsigned long long)ocfs2_metadata_cache_owner(ci),\n\t\t     to_purge, purged);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_init_refcount_tree_lock",
          "args": [
            "osb",
            "new",
            "rf_blkno",
            "new->rf_generation"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_refcount_tree_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "307-314",
          "snippet": "static inline void ocfs2_init_refcount_tree_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_refcount_tree *new,\n\t\t\t\t\tu64 rf_blkno, u32 generation)\n{\n\tinit_rwsem(&new->rf_sem);\n\tocfs2_refcount_lock_res_init(&new->rf_lockres, osb,\n\t\t\t\t     rf_blkno, generation);\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic inline void ocfs2_init_refcount_tree_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_refcount_tree *new,\n\t\t\t\t\tu64 rf_blkno, u32 generation)\n{\n\tinit_rwsem(&new->rf_sem);\n\tocfs2_refcount_lock_res_init(&new->rf_lockres, osb,\n\t\t\t\t     rf_blkno, generation);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "ref_rb->rf_generation"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "new"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_exit",
          "args": [
            "&new->rf_ci"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "136-140",
          "snippet": "void ocfs2_metadata_cache_exit(struct ocfs2_caching_info *ci)\n{\n\tocfs2_metadata_cache_purge(ci);\n\tocfs2_metadata_cache_reset(ci, 1);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_metadata_cache_exit(struct ocfs2_caching_info *ci)\n{\n\tocfs2_metadata_cache_purge(ci);\n\tocfs2_metadata_cache_reset(ci, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_read_refcount_block",
          "args": [
            "&new->rf_ci",
            "rf_blkno",
            "&ref_root_bh"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_refcount_block",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "133-148",
          "snippet": "static int ocfs2_read_refcount_block(struct ocfs2_caching_info *ci,\n\t\t\t\t     u64 rb_blkno,\n\t\t\t\t     struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(ci, rb_blkno, &tmp,\n\t\t\t      ocfs2_validate_refcount_block);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_read_refcount_block(struct ocfs2_caching_info *ci,\n\t\t\t\t     u64 rb_blkno,\n\t\t\t\t     struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(ci, rb_blkno, &tmp,\n\t\t\t      ocfs2_validate_refcount_block);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mlog_errno",
          "args": [
            "ret"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_allocate_refcount_tree",
          "args": [
            "osb",
            "rf_blkno"
          ],
          "line": 351
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_allocate_refcount_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "316-330",
          "snippet": "static struct ocfs2_refcount_tree*\nocfs2_allocate_refcount_tree(struct ocfs2_super *osb, u64 rf_blkno)\n{\n\tstruct ocfs2_refcount_tree *new;\n\n\tnew = kzalloc(sizeof(struct ocfs2_refcount_tree), GFP_NOFS);\n\tif (!new)\n\t\treturn NULL;\n\n\tnew->rf_blkno = rf_blkno;\n\tkref_init(&new->rf_getcnt);\n\tocfs2_init_refcount_tree_ci(new, osb->sb);\n\n\treturn new;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic struct ocfs2_refcount_tree*\nocfs2_allocate_refcount_tree(struct ocfs2_super *osb, u64 rf_blkno)\n{\n\tstruct ocfs2_refcount_tree *new;\n\n\tnew = kzalloc(sizeof(struct ocfs2_refcount_tree), GFP_NOFS);\n\tif (!new)\n\t\treturn NULL;\n\n\tnew->rf_blkno = rf_blkno;\n\tkref_init(&new->rf_getcnt);\n\tocfs2_init_refcount_tree_ci(new, osb->sb);\n\n\treturn new;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_get_refcount_tree(struct ocfs2_super *osb, u64 rf_blkno,\n\t\t\t\t   struct ocfs2_refcount_tree **ret_tree)\n{\n\tint ret = 0;\n\tstruct ocfs2_refcount_tree *tree, *new = NULL;\n\tstruct buffer_head *ref_root_bh = NULL;\n\tstruct ocfs2_refcount_block *ref_rb;\n\n\tspin_lock(&osb->osb_lock);\n\tif (osb->osb_ref_tree_lru &&\n\t    osb->osb_ref_tree_lru->rf_blkno == rf_blkno)\n\t\ttree = osb->osb_ref_tree_lru;\n\telse\n\t\ttree = ocfs2_find_refcount_tree(osb, rf_blkno);\n\tif (tree)\n\t\tgoto out;\n\n\tspin_unlock(&osb->osb_lock);\n\n\tnew = ocfs2_allocate_refcount_tree(osb, rf_blkno);\n\tif (!new) {\n\t\tret = -ENOMEM;\n\t\tmlog_errno(ret);\n\t\treturn ret;\n\t}\n\t/*\n\t * We need the generation to create the refcount tree lock and since\n\t * it isn't changed during the tree modification, we are safe here to\n\t * read without protection.\n\t * We also have to purge the cache after we create the lock since the\n\t * refcount block may have the stale data. It can only be trusted when\n\t * we hold the refcount lock.\n\t */\n\tret = ocfs2_read_refcount_block(&new->rf_ci, rf_blkno, &ref_root_bh);\n\tif (ret) {\n\t\tmlog_errno(ret);\n\t\tocfs2_metadata_cache_exit(&new->rf_ci);\n\t\tkfree(new);\n\t\treturn ret;\n\t}\n\n\tref_rb = (struct ocfs2_refcount_block *)ref_root_bh->b_data;\n\tnew->rf_generation = le32_to_cpu(ref_rb->rf_generation);\n\tocfs2_init_refcount_tree_lock(osb, new, rf_blkno,\n\t\t\t\t      new->rf_generation);\n\tocfs2_metadata_cache_purge(&new->rf_ci);\n\n\tspin_lock(&osb->osb_lock);\n\ttree = ocfs2_find_refcount_tree(osb, rf_blkno);\n\tif (tree)\n\t\tgoto out;\n\n\tocfs2_insert_refcount_tree(osb, new);\n\n\ttree = new;\n\tnew = NULL;\n\nout:\n\t*ret_tree = tree;\n\n\tosb->osb_ref_tree_lru = tree;\n\n\tspin_unlock(&osb->osb_lock);\n\n\tif (new)\n\t\tocfs2_free_refcount_tree(new);\n\n\tbrelse(ref_root_bh);\n\treturn ret;\n}"
  },
  {
    "function_name": "ocfs2_allocate_refcount_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "316-330",
    "snippet": "static struct ocfs2_refcount_tree*\nocfs2_allocate_refcount_tree(struct ocfs2_super *osb, u64 rf_blkno)\n{\n\tstruct ocfs2_refcount_tree *new;\n\n\tnew = kzalloc(sizeof(struct ocfs2_refcount_tree), GFP_NOFS);\n\tif (!new)\n\t\treturn NULL;\n\n\tnew->rf_blkno = rf_blkno;\n\tkref_init(&new->rf_getcnt);\n\tocfs2_init_refcount_tree_ci(new, osb->sb);\n\n\treturn new;\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_init_refcount_tree_ci",
          "args": [
            "new",
            "osb->sb"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_init_refcount_tree_ci",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "298-305",
          "snippet": "static inline void ocfs2_init_refcount_tree_ci(struct ocfs2_refcount_tree *new,\n\t\t\t\t\t       struct super_block *sb)\n{\n\tocfs2_metadata_cache_init(&new->rf_ci, &ocfs2_refcount_caching_ops);\n\tmutex_init(&new->rf_io_mutex);\n\tnew->rf_sb = sb;\n\tspin_lock_init(&new->rf_lock);\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct ocfs2_caching_operations ocfs2_refcount_caching_ops = {\n\t.co_owner\t\t= ocfs2_refcount_cache_owner,\n\t.co_get_super\t\t= ocfs2_refcount_cache_get_super,\n\t.co_cache_lock\t\t= ocfs2_refcount_cache_lock,\n\t.co_cache_unlock\t= ocfs2_refcount_cache_unlock,\n\t.co_io_lock\t\t= ocfs2_refcount_cache_io_lock,\n\t.co_io_unlock\t\t= ocfs2_refcount_cache_io_unlock,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic const struct ocfs2_caching_operations ocfs2_refcount_caching_ops = {\n\t.co_owner\t\t= ocfs2_refcount_cache_owner,\n\t.co_get_super\t\t= ocfs2_refcount_cache_get_super,\n\t.co_cache_lock\t\t= ocfs2_refcount_cache_lock,\n\t.co_cache_unlock\t= ocfs2_refcount_cache_unlock,\n\t.co_io_lock\t\t= ocfs2_refcount_cache_io_lock,\n\t.co_io_unlock\t\t= ocfs2_refcount_cache_io_unlock,\n};\n\nstatic inline void ocfs2_init_refcount_tree_ci(struct ocfs2_refcount_tree *new,\n\t\t\t\t\t       struct super_block *sb)\n{\n\tocfs2_metadata_cache_init(&new->rf_ci, &ocfs2_refcount_caching_ops);\n\tmutex_init(&new->rf_io_mutex);\n\tnew->rf_sb = sb;\n\tspin_lock_init(&new->rf_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kref_init",
          "args": [
            "&new->rf_getcnt"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct ocfs2_refcount_tree)",
            "GFP_NOFS"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic struct ocfs2_refcount_tree*\nocfs2_allocate_refcount_tree(struct ocfs2_super *osb, u64 rf_blkno)\n{\n\tstruct ocfs2_refcount_tree *new;\n\n\tnew = kzalloc(sizeof(struct ocfs2_refcount_tree), GFP_NOFS);\n\tif (!new)\n\t\treturn NULL;\n\n\tnew->rf_blkno = rf_blkno;\n\tkref_init(&new->rf_getcnt);\n\tocfs2_init_refcount_tree_ci(new, osb->sb);\n\n\treturn new;\n}"
  },
  {
    "function_name": "ocfs2_init_refcount_tree_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "307-314",
    "snippet": "static inline void ocfs2_init_refcount_tree_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_refcount_tree *new,\n\t\t\t\t\tu64 rf_blkno, u32 generation)\n{\n\tinit_rwsem(&new->rf_sem);\n\tocfs2_refcount_lock_res_init(&new->rf_lockres, osb,\n\t\t\t\t     rf_blkno, generation);\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_refcount_lock_res_init",
          "args": [
            "&new->rf_lockres",
            "osb",
            "rf_blkno",
            "generation"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_refcount_lock_res_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "711-720",
          "snippet": "void ocfs2_refcount_lock_res_init(struct ocfs2_lock_res *lockres,\n\t\t\t\t  struct ocfs2_super *osb, u64 ref_blkno,\n\t\t\t\t  unsigned int generation)\n{\n\tocfs2_lock_res_init_once(lockres);\n\tocfs2_build_lock_name(OCFS2_LOCK_TYPE_REFCOUNT, ref_blkno,\n\t\t\t      generation, lockres->l_name);\n\tocfs2_lock_res_init_common(osb, lockres, OCFS2_LOCK_TYPE_REFCOUNT,\n\t\t\t\t   &ocfs2_refcount_block_lops, osb);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_lock_res_ops ocfs2_refcount_block_lops = {\n\t.check_downconvert = ocfs2_check_refcount_downconvert,\n\t.downconvert_worker = ocfs2_refcount_convert_worker,\n\t.flags\t\t= 0,\n};",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static int ocfs2_downconvert_lock(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_lock_res *lockres,\n\t\t\t\t  int new_level,\n\t\t\t\t  int lvb,\n\t\t\t\t  unsigned int generation);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_lock_res_ops ocfs2_refcount_block_lops = {\n\t.check_downconvert = ocfs2_check_refcount_downconvert,\n\t.downconvert_worker = ocfs2_refcount_convert_worker,\n\t.flags\t\t= 0,\n};\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_downconvert_lock(struct ocfs2_super *osb,\n\t\t\t\t  struct ocfs2_lock_res *lockres,\n\t\t\t\t  int new_level,\n\t\t\t\t  int lvb,\n\t\t\t\t  unsigned int generation);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_refcount_lock_res_init(struct ocfs2_lock_res *lockres,\n\t\t\t\t  struct ocfs2_super *osb, u64 ref_blkno,\n\t\t\t\t  unsigned int generation)\n{\n\tocfs2_lock_res_init_once(lockres);\n\tocfs2_build_lock_name(OCFS2_LOCK_TYPE_REFCOUNT, ref_blkno,\n\t\t\t      generation, lockres->l_name);\n\tocfs2_lock_res_init_common(osb, lockres, OCFS2_LOCK_TYPE_REFCOUNT,\n\t\t\t\t   &ocfs2_refcount_block_lops, osb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_rwsem",
          "args": [
            "&new->rf_sem"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic inline void ocfs2_init_refcount_tree_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_refcount_tree *new,\n\t\t\t\t\tu64 rf_blkno, u32 generation)\n{\n\tinit_rwsem(&new->rf_sem);\n\tocfs2_refcount_lock_res_init(&new->rf_lockres, osb,\n\t\t\t\t     rf_blkno, generation);\n}"
  },
  {
    "function_name": "ocfs2_init_refcount_tree_ci",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "298-305",
    "snippet": "static inline void ocfs2_init_refcount_tree_ci(struct ocfs2_refcount_tree *new,\n\t\t\t\t\t       struct super_block *sb)\n{\n\tocfs2_metadata_cache_init(&new->rf_ci, &ocfs2_refcount_caching_ops);\n\tmutex_init(&new->rf_io_mutex);\n\tnew->rf_sb = sb;\n\tspin_lock_init(&new->rf_lock);\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct ocfs2_caching_operations ocfs2_refcount_caching_ops = {\n\t.co_owner\t\t= ocfs2_refcount_cache_owner,\n\t.co_get_super\t\t= ocfs2_refcount_cache_get_super,\n\t.co_cache_lock\t\t= ocfs2_refcount_cache_lock,\n\t.co_cache_unlock\t= ocfs2_refcount_cache_unlock,\n\t.co_io_lock\t\t= ocfs2_refcount_cache_io_lock,\n\t.co_io_unlock\t\t= ocfs2_refcount_cache_io_unlock,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&new->rf_lock"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&new->rf_io_mutex"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_init",
          "args": [
            "&new->rf_ci",
            "&ocfs2_refcount_caching_ops"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "127-134",
          "snippet": "void ocfs2_metadata_cache_init(struct ocfs2_caching_info *ci,\n\t\t\t       const struct ocfs2_caching_operations *ops)\n{\n\tBUG_ON(!ops);\n\n\tci->ci_ops = ops;\n\tocfs2_metadata_cache_reset(ci, 1);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_metadata_cache_init(struct ocfs2_caching_info *ci,\n\t\t\t       const struct ocfs2_caching_operations *ops)\n{\n\tBUG_ON(!ops);\n\n\tci->ci_ops = ops;\n\tocfs2_metadata_cache_reset(ci, 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic const struct ocfs2_caching_operations ocfs2_refcount_caching_ops = {\n\t.co_owner\t\t= ocfs2_refcount_cache_owner,\n\t.co_get_super\t\t= ocfs2_refcount_cache_get_super,\n\t.co_cache_lock\t\t= ocfs2_refcount_cache_lock,\n\t.co_cache_unlock\t= ocfs2_refcount_cache_unlock,\n\t.co_io_lock\t\t= ocfs2_refcount_cache_io_lock,\n\t.co_io_unlock\t\t= ocfs2_refcount_cache_io_unlock,\n};\n\nstatic inline void ocfs2_init_refcount_tree_ci(struct ocfs2_refcount_tree *new,\n\t\t\t\t\t       struct super_block *sb)\n{\n\tocfs2_metadata_cache_init(&new->rf_ci, &ocfs2_refcount_caching_ops);\n\tmutex_init(&new->rf_io_mutex);\n\tnew->rf_sb = sb;\n\tspin_lock_init(&new->rf_lock);\n}"
  },
  {
    "function_name": "ocfs2_refcount_tree_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "292-296",
    "snippet": "static inline void\nocfs2_refcount_tree_put(struct ocfs2_refcount_tree *tree)\n{\n\tkref_put(&tree->rf_getcnt, ocfs2_kref_remove_refcount_tree);\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&tree->rf_getcnt",
            "ocfs2_kref_remove_refcount_tree"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic inline void\nocfs2_refcount_tree_put(struct ocfs2_refcount_tree *tree)\n{\n\tkref_put(&tree->rf_getcnt, ocfs2_kref_remove_refcount_tree);\n}"
  },
  {
    "function_name": "ocfs2_refcount_tree_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "286-290",
    "snippet": "static inline void\nocfs2_refcount_tree_get(struct ocfs2_refcount_tree *tree)\n{\n\tkref_get(&tree->rf_getcnt);\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kref_get",
          "args": [
            "&tree->rf_getcnt"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic inline void\nocfs2_refcount_tree_get(struct ocfs2_refcount_tree *tree)\n{\n\tkref_get(&tree->rf_getcnt);\n}"
  },
  {
    "function_name": "ocfs2_kref_remove_refcount_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "278-284",
    "snippet": "static void ocfs2_kref_remove_refcount_tree(struct kref *kref)\n{\n\tstruct ocfs2_refcount_tree *tree =\n\t\tcontainer_of(kref, struct ocfs2_refcount_tree, rf_getcnt);\n\n\tocfs2_free_refcount_tree(tree);\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_free_refcount_tree",
          "args": [
            "tree"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_free_refcount_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "253-259",
          "snippet": "static void ocfs2_free_refcount_tree(struct ocfs2_refcount_tree *tree)\n{\n\tocfs2_metadata_cache_exit(&tree->rf_ci);\n\tocfs2_simple_drop_lockres(OCFS2_SB(tree->rf_sb), &tree->rf_lockres);\n\tocfs2_lock_res_free(&tree->rf_lockres);\n\tkfree(tree);\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic void ocfs2_free_refcount_tree(struct ocfs2_refcount_tree *tree)\n{\n\tocfs2_metadata_cache_exit(&tree->rf_ci);\n\tocfs2_simple_drop_lockres(OCFS2_SB(tree->rf_sb), &tree->rf_lockres);\n\tocfs2_lock_res_free(&tree->rf_lockres);\n\tkfree(tree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "kref",
            "structocfs2_refcount_tree",
            "rf_getcnt"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic void ocfs2_kref_remove_refcount_tree(struct kref *kref)\n{\n\tstruct ocfs2_refcount_tree *tree =\n\t\tcontainer_of(kref, struct ocfs2_refcount_tree, rf_getcnt);\n\n\tocfs2_free_refcount_tree(tree);\n}"
  },
  {
    "function_name": "ocfs2_erase_refcount_tree_from_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "270-276",
    "snippet": "static void ocfs2_erase_refcount_tree_from_list(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_refcount_tree *tree)\n{\n\tspin_lock(&osb->osb_lock);\n\tocfs2_erase_refcount_tree_from_list_no_lock(osb, tree);\n\tspin_unlock(&osb->osb_lock);\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_erase_refcount_tree_from_list_no_lock",
          "args": [
            "osb",
            "tree"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_erase_refcount_tree_from_list_no_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "261-268",
          "snippet": "static inline void\nocfs2_erase_refcount_tree_from_list_no_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_refcount_tree *tree)\n{\n\trb_erase(&tree->rf_node, &osb->osb_rf_lock_tree);\n\tif (osb->osb_ref_tree_lru && osb->osb_ref_tree_lru == tree)\n\t\tosb->osb_ref_tree_lru = NULL;\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic inline void\nocfs2_erase_refcount_tree_from_list_no_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_refcount_tree *tree)\n{\n\trb_erase(&tree->rf_node, &osb->osb_rf_lock_tree);\n\tif (osb->osb_ref_tree_lru && osb->osb_ref_tree_lru == tree)\n\t\tosb->osb_ref_tree_lru = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&osb->osb_lock"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic void ocfs2_erase_refcount_tree_from_list(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_refcount_tree *tree)\n{\n\tspin_lock(&osb->osb_lock);\n\tocfs2_erase_refcount_tree_from_list_no_lock(osb, tree);\n\tspin_unlock(&osb->osb_lock);\n}"
  },
  {
    "function_name": "ocfs2_erase_refcount_tree_from_list_no_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "261-268",
    "snippet": "static inline void\nocfs2_erase_refcount_tree_from_list_no_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_refcount_tree *tree)\n{\n\trb_erase(&tree->rf_node, &osb->osb_rf_lock_tree);\n\tif (osb->osb_ref_tree_lru && osb->osb_ref_tree_lru == tree)\n\t\tosb->osb_ref_tree_lru = NULL;\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_erase",
          "args": [
            "&tree->rf_node",
            "&osb->osb_rf_lock_tree"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic inline void\nocfs2_erase_refcount_tree_from_list_no_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_refcount_tree *tree)\n{\n\trb_erase(&tree->rf_node, &osb->osb_rf_lock_tree);\n\tif (osb->osb_ref_tree_lru && osb->osb_ref_tree_lru == tree)\n\t\tosb->osb_ref_tree_lru = NULL;\n}"
  },
  {
    "function_name": "ocfs2_free_refcount_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "253-259",
    "snippet": "static void ocfs2_free_refcount_tree(struct ocfs2_refcount_tree *tree)\n{\n\tocfs2_metadata_cache_exit(&tree->rf_ci);\n\tocfs2_simple_drop_lockres(OCFS2_SB(tree->rf_sb), &tree->rf_lockres);\n\tocfs2_lock_res_free(&tree->rf_lockres);\n\tkfree(tree);\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tree"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_lock_res_free",
          "args": [
            "&tree->rf_lockres"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_lock_res_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "722-749",
          "snippet": "void ocfs2_lock_res_free(struct ocfs2_lock_res *res)\n{\n\tif (!(res->l_flags & OCFS2_LOCK_INITIALIZED))\n\t\treturn;\n\n\tocfs2_remove_lockres_tracking(res);\n\n\tmlog_bug_on_msg(!list_empty(&res->l_blocked_list),\n\t\t\t\"Lockres %s is on the blocked list\\n\",\n\t\t\tres->l_name);\n\tmlog_bug_on_msg(!list_empty(&res->l_mask_waiters),\n\t\t\t\"Lockres %s has mask waiters pending\\n\",\n\t\t\tres->l_name);\n\tmlog_bug_on_msg(spin_is_locked(&res->l_lock),\n\t\t\t\"Lockres %s is locked\\n\",\n\t\t\tres->l_name);\n\tmlog_bug_on_msg(res->l_ro_holders,\n\t\t\t\"Lockres %s has %u ro holders\\n\",\n\t\t\tres->l_name, res->l_ro_holders);\n\tmlog_bug_on_msg(res->l_ex_holders,\n\t\t\t\"Lockres %s has %u ex holders\\n\",\n\t\t\tres->l_name, res->l_ex_holders);\n\n\t/* Need to clear out the lock status block for the dlm */\n\tmemset(&res->l_lksb, 0, sizeof(res->l_lksb));\n\n\tres->l_flags = 0UL;\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nvoid ocfs2_lock_res_free(struct ocfs2_lock_res *res)\n{\n\tif (!(res->l_flags & OCFS2_LOCK_INITIALIZED))\n\t\treturn;\n\n\tocfs2_remove_lockres_tracking(res);\n\n\tmlog_bug_on_msg(!list_empty(&res->l_blocked_list),\n\t\t\t\"Lockres %s is on the blocked list\\n\",\n\t\t\tres->l_name);\n\tmlog_bug_on_msg(!list_empty(&res->l_mask_waiters),\n\t\t\t\"Lockres %s has mask waiters pending\\n\",\n\t\t\tres->l_name);\n\tmlog_bug_on_msg(spin_is_locked(&res->l_lock),\n\t\t\t\"Lockres %s is locked\\n\",\n\t\t\tres->l_name);\n\tmlog_bug_on_msg(res->l_ro_holders,\n\t\t\t\"Lockres %s has %u ro holders\\n\",\n\t\t\tres->l_name, res->l_ro_holders);\n\tmlog_bug_on_msg(res->l_ex_holders,\n\t\t\t\"Lockres %s has %u ex holders\\n\",\n\t\t\tres->l_name, res->l_ex_holders);\n\n\t/* Need to clear out the lock status block for the dlm */\n\tmemset(&res->l_lksb, 0, sizeof(res->l_lksb));\n\n\tres->l_flags = 0UL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_simple_drop_lockres",
          "args": [
            "OCFS2_SB(tree->rf_sb)",
            "&tree->rf_lockres"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_simple_drop_lockres",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/dlmglue.c",
          "lines": "3223-3232",
          "snippet": "void ocfs2_simple_drop_lockres(struct ocfs2_super *osb,\n\t\t\t       struct ocfs2_lock_res *lockres)\n{\n\tint ret;\n\n\tocfs2_mark_lockres_freeing(osb, lockres);\n\tret = ocfs2_drop_lock(osb, lockres);\n\tif (ret)\n\t\tmlog_errno(ret);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"uptodate.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"stackglue.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"file.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"dcache.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2_lockingver.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/time.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mm.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);",
            "static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);",
            "static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);",
            "static inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);",
            "static void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_drop_osb_locks(struct ocfs2_super *osb);",
            "static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);",
            "static int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);",
            "static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"uptodate.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"stackglue.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"file.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"dcache.h\"\n#include \"alloc.h\"\n#include \"ocfs2_lockingver.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/quotaops.h>\n#include <linux/time.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/pagemap.h>\n#include <linux/kthread.h>\n#include <linux/mm.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);\nstatic struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,\n\t\t\t\t     struct ocfs2_lock_res *lockres);\nstatic void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_downconvert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_convert_action(struct ocfs2_lock_res *lockres);\nstatic inline void ocfs2_generic_handle_attach_action(struct ocfs2_lock_res *lockres);\nstatic void ocfs2_schedule_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,\n\t\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_drop_osb_locks(struct ocfs2_super *osb);\nstatic int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\t        struct ocfs2_lock_res *lockres);\nstatic int ocfs2_cancel_convert(struct ocfs2_super *osb,\n\t\t\t\tstruct ocfs2_lock_res *lockres);\nstatic void ocfs2_process_blocked_lock(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_lock_res *lockres);\n\nvoid ocfs2_simple_drop_lockres(struct ocfs2_super *osb,\n\t\t\t       struct ocfs2_lock_res *lockres)\n{\n\tint ret;\n\n\tocfs2_mark_lockres_freeing(osb, lockres);\n\tret = ocfs2_drop_lock(osb, lockres);\n\tif (ret)\n\t\tmlog_errno(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "tree->rf_sb"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ocfs2_metadata_cache_exit",
          "args": [
            "&tree->rf_ci"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_metadata_cache_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/uptodate.c",
          "lines": "136-140",
          "snippet": "void ocfs2_metadata_cache_exit(struct ocfs2_caching_info *ci)\n{\n\tocfs2_metadata_cache_purge(ci);\n\tocfs2_metadata_cache_reset(ci, 1);\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"uptodate.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"uptodate.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/rbtree.h>\n#include <linux/buffer_head.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nvoid ocfs2_metadata_cache_exit(struct ocfs2_caching_info *ci)\n{\n\tocfs2_metadata_cache_purge(ci);\n\tocfs2_metadata_cache_reset(ci, 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic void ocfs2_free_refcount_tree(struct ocfs2_refcount_tree *tree)\n{\n\tocfs2_metadata_cache_exit(&tree->rf_ci);\n\tocfs2_simple_drop_lockres(OCFS2_SB(tree->rf_sb), &tree->rf_lockres);\n\tocfs2_lock_res_free(&tree->rf_lockres);\n\tkfree(tree);\n}"
  },
  {
    "function_name": "ocfs2_insert_refcount_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "223-251",
    "snippet": "static void ocfs2_insert_refcount_tree(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_refcount_tree *new)\n{\n\tu64 rf_blkno = new->rf_blkno;\n\tstruct rb_node *parent = NULL;\n\tstruct rb_node **p = &osb->osb_rf_lock_tree.rb_node;\n\tstruct ocfs2_refcount_tree *tmp;\n\n\twhile (*p) {\n\t\tparent = *p;\n\n\t\ttmp = rb_entry(parent, struct ocfs2_refcount_tree,\n\t\t\t       rf_node);\n\n\t\tif (rf_blkno < tmp->rf_blkno)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (rf_blkno > tmp->rf_blkno)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\t/* This should never happen! */\n\t\t\tmlog(ML_ERROR, \"Duplicate refcount block %llu found!\\n\",\n\t\t\t     (unsigned long long)rf_blkno);\n\t\t\tBUG();\n\t\t}\n\t}\n\n\trb_link_node(&new->rf_node, parent, p);\n\trb_insert_color(&new->rf_node, &osb->osb_rf_lock_tree);\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_insert_color",
          "args": [
            "&new->rf_node",
            "&osb->osb_rf_lock_tree"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "&new->rf_node",
            "parent",
            "p"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Duplicate refcount block %llu found!\\n\"",
            "(unsigned long long)rf_blkno"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "parent",
            "structocfs2_refcount_tree",
            "rf_node"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic void ocfs2_insert_refcount_tree(struct ocfs2_super *osb,\n\t\t\t\t       struct ocfs2_refcount_tree *new)\n{\n\tu64 rf_blkno = new->rf_blkno;\n\tstruct rb_node *parent = NULL;\n\tstruct rb_node **p = &osb->osb_rf_lock_tree.rb_node;\n\tstruct ocfs2_refcount_tree *tmp;\n\n\twhile (*p) {\n\t\tparent = *p;\n\n\t\ttmp = rb_entry(parent, struct ocfs2_refcount_tree,\n\t\t\t       rf_node);\n\n\t\tif (rf_blkno < tmp->rf_blkno)\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (rf_blkno > tmp->rf_blkno)\n\t\t\tp = &(*p)->rb_right;\n\t\telse {\n\t\t\t/* This should never happen! */\n\t\t\tmlog(ML_ERROR, \"Duplicate refcount block %llu found!\\n\",\n\t\t\t     (unsigned long long)rf_blkno);\n\t\t\tBUG();\n\t\t}\n\t}\n\n\trb_link_node(&new->rf_node, parent, p);\n\trb_insert_color(&new->rf_node, &osb->osb_rf_lock_tree);\n}"
  },
  {
    "function_name": "ocfs2_find_refcount_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "202-220",
    "snippet": "static struct ocfs2_refcount_tree *\nocfs2_find_refcount_tree(struct ocfs2_super *osb, u64 blkno)\n{\n\tstruct rb_node *n = osb->osb_rf_lock_tree.rb_node;\n\tstruct ocfs2_refcount_tree *tree = NULL;\n\n\twhile (n) {\n\t\ttree = rb_entry(n, struct ocfs2_refcount_tree, rf_node);\n\n\t\tif (blkno < tree->rf_blkno)\n\t\t\tn = n->rb_left;\n\t\telse if (blkno > tree->rf_blkno)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn tree;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structocfs2_refcount_tree",
            "rf_node"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic struct ocfs2_refcount_tree *\nocfs2_find_refcount_tree(struct ocfs2_super *osb, u64 blkno)\n{\n\tstruct rb_node *n = osb->osb_rf_lock_tree.rb_node;\n\tstruct ocfs2_refcount_tree *tree = NULL;\n\n\twhile (n) {\n\t\ttree = rb_entry(n, struct ocfs2_refcount_tree, rf_node);\n\n\t\tif (blkno < tree->rf_blkno)\n\t\t\tn = n->rb_left;\n\t\telse if (blkno > tree->rf_blkno)\n\t\t\tn = n->rb_right;\n\t\telse\n\t\t\treturn tree;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "ocfs2_refcount_cache_io_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "186-191",
    "snippet": "static void ocfs2_refcount_cache_io_unlock(struct ocfs2_caching_info *ci)\n{\n\tstruct ocfs2_refcount_tree *rf = cache_info_to_refcount(ci);\n\n\tmutex_unlock(&rf->rf_io_mutex);\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&rf->rf_io_mutex"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_info_to_refcount",
          "args": [
            "ci"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "cache_info_to_refcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "74-78",
          "snippet": "static inline struct ocfs2_refcount_tree *\ncache_info_to_refcount(struct ocfs2_caching_info *ci)\n{\n\treturn container_of(ci, struct ocfs2_refcount_tree, rf_ci);\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic inline struct ocfs2_refcount_tree *\ncache_info_to_refcount(struct ocfs2_caching_info *ci)\n{\n\treturn container_of(ci, struct ocfs2_refcount_tree, rf_ci);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic void ocfs2_refcount_cache_io_unlock(struct ocfs2_caching_info *ci)\n{\n\tstruct ocfs2_refcount_tree *rf = cache_info_to_refcount(ci);\n\n\tmutex_unlock(&rf->rf_io_mutex);\n}"
  },
  {
    "function_name": "ocfs2_refcount_cache_io_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "179-184",
    "snippet": "static void ocfs2_refcount_cache_io_lock(struct ocfs2_caching_info *ci)\n{\n\tstruct ocfs2_refcount_tree *rf = cache_info_to_refcount(ci);\n\n\tmutex_lock(&rf->rf_io_mutex);\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&rf->rf_io_mutex"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cache_info_to_refcount",
          "args": [
            "ci"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "cache_info_to_refcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "74-78",
          "snippet": "static inline struct ocfs2_refcount_tree *\ncache_info_to_refcount(struct ocfs2_caching_info *ci)\n{\n\treturn container_of(ci, struct ocfs2_refcount_tree, rf_ci);\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic inline struct ocfs2_refcount_tree *\ncache_info_to_refcount(struct ocfs2_caching_info *ci)\n{\n\treturn container_of(ci, struct ocfs2_refcount_tree, rf_ci);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic void ocfs2_refcount_cache_io_lock(struct ocfs2_caching_info *ci)\n{\n\tstruct ocfs2_refcount_tree *rf = cache_info_to_refcount(ci);\n\n\tmutex_lock(&rf->rf_io_mutex);\n}"
  },
  {
    "function_name": "ocfs2_refcount_cache_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "172-177",
    "snippet": "static void ocfs2_refcount_cache_unlock(struct ocfs2_caching_info *ci)\n{\n\tstruct ocfs2_refcount_tree *rf = cache_info_to_refcount(ci);\n\n\tspin_unlock(&rf->rf_lock);\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&rf->rf_lock"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_unlock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "139-144",
          "snippet": "static inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_unlock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_unlock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cache_info_to_refcount",
          "args": [
            "ci"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "cache_info_to_refcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "74-78",
          "snippet": "static inline struct ocfs2_refcount_tree *\ncache_info_to_refcount(struct ocfs2_caching_info *ci)\n{\n\treturn container_of(ci, struct ocfs2_refcount_tree, rf_ci);\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic inline struct ocfs2_refcount_tree *\ncache_info_to_refcount(struct ocfs2_caching_info *ci)\n{\n\treturn container_of(ci, struct ocfs2_refcount_tree, rf_ci);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic void ocfs2_refcount_cache_unlock(struct ocfs2_caching_info *ci)\n{\n\tstruct ocfs2_refcount_tree *rf = cache_info_to_refcount(ci);\n\n\tspin_unlock(&rf->rf_lock);\n}"
  },
  {
    "function_name": "ocfs2_refcount_cache_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "165-170",
    "snippet": "static void ocfs2_refcount_cache_lock(struct ocfs2_caching_info *ci)\n{\n\tstruct ocfs2_refcount_tree *rf = cache_info_to_refcount(ci);\n\n\tspin_lock(&rf->rf_lock);\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&rf->rf_lock"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "__spin_lock_mb_cache_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/mbcache.c",
          "lines": "132-137",
          "snippet": "static inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}",
          "includes": [
            "#include <linux/log2.h>",
            "#include <linux/blockgroup_lock.h>",
            "#include <linux/init.h>",
            "#include <linux/mbcache.h>",
            "#include <linux/list_bl.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hash.h>",
            "#include <linux/module.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct blockgroup_lock *mb_cache_bg_lock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/log2.h>\n#include <linux/blockgroup_lock.h>\n#include <linux/init.h>\n#include <linux/mbcache.h>\n#include <linux/list_bl.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hash.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic struct blockgroup_lock *mb_cache_bg_lock;\n\nstatic inline void\n__spin_lock_mb_cache_entry(struct mb_cache_entry *ce)\n{\n\tspin_lock(bgl_lock_ptr(mb_cache_bg_lock,\n\t\tMB_CACHE_ENTRY_LOCK_INDEX(ce)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "cache_info_to_refcount",
          "args": [
            "ci"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "cache_info_to_refcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "74-78",
          "snippet": "static inline struct ocfs2_refcount_tree *\ncache_info_to_refcount(struct ocfs2_caching_info *ci)\n{\n\treturn container_of(ci, struct ocfs2_refcount_tree, rf_ci);\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic inline struct ocfs2_refcount_tree *\ncache_info_to_refcount(struct ocfs2_caching_info *ci)\n{\n\treturn container_of(ci, struct ocfs2_refcount_tree, rf_ci);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic void ocfs2_refcount_cache_lock(struct ocfs2_caching_info *ci)\n{\n\tstruct ocfs2_refcount_tree *rf = cache_info_to_refcount(ci);\n\n\tspin_lock(&rf->rf_lock);\n}"
  },
  {
    "function_name": "ocfs2_refcount_cache_get_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "157-163",
    "snippet": "static struct super_block *\nocfs2_refcount_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tstruct ocfs2_refcount_tree *rf = cache_info_to_refcount(ci);\n\n\treturn rf->rf_sb;\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cache_info_to_refcount",
          "args": [
            "ci"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "cache_info_to_refcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "74-78",
          "snippet": "static inline struct ocfs2_refcount_tree *\ncache_info_to_refcount(struct ocfs2_caching_info *ci)\n{\n\treturn container_of(ci, struct ocfs2_refcount_tree, rf_ci);\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic inline struct ocfs2_refcount_tree *\ncache_info_to_refcount(struct ocfs2_caching_info *ci)\n{\n\treturn container_of(ci, struct ocfs2_refcount_tree, rf_ci);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic struct super_block *\nocfs2_refcount_cache_get_super(struct ocfs2_caching_info *ci)\n{\n\tstruct ocfs2_refcount_tree *rf = cache_info_to_refcount(ci);\n\n\treturn rf->rf_sb;\n}"
  },
  {
    "function_name": "ocfs2_refcount_cache_owner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "150-155",
    "snippet": "static u64 ocfs2_refcount_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tstruct ocfs2_refcount_tree *rf = cache_info_to_refcount(ci);\n\n\treturn rf->rf_blkno;\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cache_info_to_refcount",
          "args": [
            "ci"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "cache_info_to_refcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
          "lines": "74-78",
          "snippet": "static inline struct ocfs2_refcount_tree *\ncache_info_to_refcount(struct ocfs2_caching_info *ci)\n{\n\treturn container_of(ci, struct ocfs2_refcount_tree, rf_ci);\n}",
          "includes": [
            "#include <linux/posix_acl.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/security.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagevec.h>",
            "#include <linux/writeback.h>",
            "#include <linux/slab.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/bio.h>",
            "#include \"ocfs2_trace.h\"",
            "#include \"namei.h\"",
            "#include \"xattr.h\"",
            "#include \"aops.h\"",
            "#include \"extent_map.h\"",
            "#include \"dlmglue.h\"",
            "#include \"sysfile.h\"",
            "#include \"refcounttree.h\"",
            "#include \"blockcheck.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"super.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"suballoc.h\"",
            "#include \"alloc.h\"",
            "#include \"inode.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/sort.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic inline struct ocfs2_refcount_tree *\ncache_info_to_refcount(struct ocfs2_caching_info *ci)\n{\n\treturn container_of(ci, struct ocfs2_refcount_tree, rf_ci);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic u64 ocfs2_refcount_cache_owner(struct ocfs2_caching_info *ci)\n{\n\tstruct ocfs2_refcount_tree *rf = cache_info_to_refcount(ci);\n\n\treturn rf->rf_blkno;\n}"
  },
  {
    "function_name": "ocfs2_read_refcount_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "133-148",
    "snippet": "static int ocfs2_read_refcount_block(struct ocfs2_caching_info *ci,\n\t\t\t\t     u64 rb_blkno,\n\t\t\t\t     struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(ci, rb_blkno, &tmp,\n\t\t\t      ocfs2_validate_refcount_block);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_read_block",
          "args": [
            "ci",
            "rb_blkno",
            "&tmp",
            "ocfs2_validate_refcount_block"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_read_blocks_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/buffer_head_io.c",
          "lines": "101-174",
          "snippet": "int ocfs2_read_blocks_sync(struct ocfs2_super *osb, u64 block,\n\t\t\t   unsigned int nr, struct buffer_head *bhs[])\n{\n\tint status = 0;\n\tunsigned int i;\n\tstruct buffer_head *bh;\n\n\ttrace_ocfs2_read_blocks_sync((unsigned long long)block, nr);\n\n\tif (!nr)\n\t\tgoto bail;\n\n\tfor (i = 0 ; i < nr ; i++) {\n\t\tif (bhs[i] == NULL) {\n\t\t\tbhs[i] = sb_getblk(osb->sb, block++);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tbh = bhs[i];\n\n\t\tif (buffer_jbd(bh)) {\n\t\t\ttrace_ocfs2_read_blocks_sync_jbd(\n\t\t\t\t\t(unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (buffer_dirty(bh)) {\n\t\t\t/* This should probably be a BUG, or\n\t\t\t * at least return an error. */\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"trying to sync read a dirty \"\n\t\t\t     \"buffer! (blocknr = %llu), skipping\\n\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlock_buffer(bh);\n\t\tif (buffer_jbd(bh)) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"block %llu had the JBD bit set \"\n\t\t\t     \"while I was in lock_buffer!\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tBUG();\n\t\t}\n\n\t\tclear_buffer_uptodate(bh);\n\t\tget_bh(bh); /* for end_buffer_read_sync() */\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(READ, bh);\n\t}\n\n\tfor (i = nr; i > 0; i--) {\n\t\tbh = bhs[i - 1];\n\n\t\t/* No need to wait on the buffer if it's managed by JBD. */\n\t\tif (!buffer_jbd(bh))\n\t\t\twait_on_buffer(bh);\n\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* Status won't be cleared from here on out,\n\t\t\t * so we can safely record this and loop back\n\t\t\t * to cleanup the other buffers. */\n\t\t\tstatus = -EIO;\n\t\t\tput_bh(bh);\n\t\t\tbhs[i - 1] = NULL;\n\t\t}\n\t}\n\nbail:\n\treturn status;\n}",
          "includes": [
            "#include \"ocfs2_trace.h\"",
            "#include \"buffer_head_io.h\"",
            "#include \"uptodate.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <linux/highmem.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ocfs2_trace.h\"\n#include \"buffer_head_io.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"alloc.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/highmem.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n\nint ocfs2_read_blocks_sync(struct ocfs2_super *osb, u64 block,\n\t\t\t   unsigned int nr, struct buffer_head *bhs[])\n{\n\tint status = 0;\n\tunsigned int i;\n\tstruct buffer_head *bh;\n\n\ttrace_ocfs2_read_blocks_sync((unsigned long long)block, nr);\n\n\tif (!nr)\n\t\tgoto bail;\n\n\tfor (i = 0 ; i < nr ; i++) {\n\t\tif (bhs[i] == NULL) {\n\t\t\tbhs[i] = sb_getblk(osb->sb, block++);\n\t\t\tif (bhs[i] == NULL) {\n\t\t\t\tstatus = -ENOMEM;\n\t\t\t\tmlog_errno(status);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t\tbh = bhs[i];\n\n\t\tif (buffer_jbd(bh)) {\n\t\t\ttrace_ocfs2_read_blocks_sync_jbd(\n\t\t\t\t\t(unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (buffer_dirty(bh)) {\n\t\t\t/* This should probably be a BUG, or\n\t\t\t * at least return an error. */\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"trying to sync read a dirty \"\n\t\t\t     \"buffer! (blocknr = %llu), skipping\\n\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlock_buffer(bh);\n\t\tif (buffer_jbd(bh)) {\n\t\t\tmlog(ML_ERROR,\n\t\t\t     \"block %llu had the JBD bit set \"\n\t\t\t     \"while I was in lock_buffer!\",\n\t\t\t     (unsigned long long)bh->b_blocknr);\n\t\t\tBUG();\n\t\t}\n\n\t\tclear_buffer_uptodate(bh);\n\t\tget_bh(bh); /* for end_buffer_read_sync() */\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(READ, bh);\n\t}\n\n\tfor (i = nr; i > 0; i--) {\n\t\tbh = bhs[i - 1];\n\n\t\t/* No need to wait on the buffer if it's managed by JBD. */\n\t\tif (!buffer_jbd(bh))\n\t\t\twait_on_buffer(bh);\n\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\t/* Status won't be cleared from here on out,\n\t\t\t * so we can safely record this and loop back\n\t\t\t * to cleanup the other buffers. */\n\t\t\tstatus = -EIO;\n\t\t\tput_bh(bh);\n\t\t\tbhs[i - 1] = NULL;\n\t\t}\n\t}\n\nbail:\n\treturn status;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_read_refcount_block(struct ocfs2_caching_info *ci,\n\t\t\t\t     u64 rb_blkno,\n\t\t\t\t     struct buffer_head **bh)\n{\n\tint rc;\n\tstruct buffer_head *tmp = *bh;\n\n\trc = ocfs2_read_block(ci, rb_blkno, &tmp,\n\t\t\t      ocfs2_validate_refcount_block);\n\n\t/* If ocfs2_read_block() got us a new bh, pass it up. */\n\tif (!rc && !*bh)\n\t\t*bh = tmp;\n\n\treturn rc;\n}"
  },
  {
    "function_name": "ocfs2_validate_refcount_block",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "80-131",
    "snippet": "static int ocfs2_validate_refcount_block(struct super_block *sb,\n\t\t\t\t\t struct buffer_head *bh)\n{\n\tint rc;\n\tstruct ocfs2_refcount_block *rb =\n\t\t(struct ocfs2_refcount_block *)bh->b_data;\n\n\ttrace_ocfs2_validate_refcount_block((unsigned long long)bh->b_blocknr);\n\n\tBUG_ON(!buffer_uptodate(bh));\n\n\t/*\n\t * If the ecc fails, we return the error but otherwise\n\t * leave the filesystem running.  We know any error is\n\t * local to this block.\n\t */\n\trc = ocfs2_validate_meta_ecc(sb, bh->b_data, &rb->rf_check);\n\tif (rc) {\n\t\tmlog(ML_ERROR, \"Checksum failed for refcount block %llu\\n\",\n\t\t     (unsigned long long)bh->b_blocknr);\n\t\treturn rc;\n\t}\n\n\n\tif (!OCFS2_IS_VALID_REFCOUNT_BLOCK(rb)) {\n\t\tocfs2_error(sb,\n\t\t\t    \"Refcount block #%llu has bad signature %.*s\",\n\t\t\t    (unsigned long long)bh->b_blocknr, 7,\n\t\t\t    rb->rf_signature);\n\t\treturn -EINVAL;\n\t}\n\n\tif (le64_to_cpu(rb->rf_blkno) != bh->b_blocknr) {\n\t\tocfs2_error(sb,\n\t\t\t    \"Refcount block #%llu has an invalid rf_blkno \"\n\t\t\t    \"of %llu\",\n\t\t\t    (unsigned long long)bh->b_blocknr,\n\t\t\t    (unsigned long long)le64_to_cpu(rb->rf_blkno));\n\t\treturn -EINVAL;\n\t}\n\n\tif (le32_to_cpu(rb->rf_fs_generation) != OCFS2_SB(sb)->fs_generation) {\n\t\tocfs2_error(sb,\n\t\t\t    \"Refcount block #%llu has an invalid \"\n\t\t\t    \"rf_fs_generation of #%u\",\n\t\t\t    (unsigned long long)bh->b_blocknr,\n\t\t\t    le32_to_cpu(rb->rf_fs_generation));\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ocfs2_error",
          "args": [
            "sb",
            "\"Refcount block #%llu has an invalid \"\n\t\t\t    \"rf_fs_generation of #%u\"",
            "(unsigned long long)bh->b_blocknr",
            "le32_to_cpu(rb->rf_fs_generation)"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "__ocfs2_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/super.c",
          "lines": "2568-2584",
          "snippet": "void __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}",
          "includes": [
            "#include \"buffer_head_io.h\"",
            "#include \"suballoc.h\"",
            "#include \"refcounttree.h\"",
            "#include \"quota.h\"",
            "#include \"xattr.h\"",
            "#include \"uptodate.h\"",
            "#include \"sysfile.h\"",
            "#include \"super.h\"",
            "#include \"slot_map.h\"",
            "#include \"namei.h\"",
            "#include \"localalloc.h\"",
            "#include \"journal.h\"",
            "#include \"inode.h\"",
            "#include \"heartbeat.h\"",
            "#include \"extent_map.h\"",
            "#include \"export.h\"",
            "#include \"dlmglue.h\"",
            "#include \"blockcheck.h\"",
            "#include \"aops.h\"",
            "#include \"alloc.h\"",
            "#include \"ocfs1_fs_compat.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include \"ocfs2_trace.h\"",
            "#include <linux/cleancache.h>",
            "#include <linux/quotaops.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/mount.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/crc32.h>",
            "#include <linux/parser.h>",
            "#include <linux/inet.h>",
            "#include <linux/socket.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/statfs.h>",
            "#include <linux/random.h>",
            "#include <linux/init.h>",
            "#include <linux/highmem.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ocfs2_put_super(struct super_block *sb);",
            "static int ocfs2_mount_volume(struct super_block *sb);",
            "static struct inode *ocfs2_alloc_inode(struct super_block *sb);",
            "static char error_buf[1024];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"buffer_head_io.h\"\n#include \"suballoc.h\"\n#include \"refcounttree.h\"\n#include \"quota.h\"\n#include \"xattr.h\"\n#include \"uptodate.h\"\n#include \"sysfile.h\"\n#include \"super.h\"\n#include \"slot_map.h\"\n#include \"namei.h\"\n#include \"localalloc.h\"\n#include \"journal.h\"\n#include \"inode.h\"\n#include \"heartbeat.h\"\n#include \"extent_map.h\"\n#include \"export.h\"\n#include \"dlmglue.h\"\n#include \"blockcheck.h\"\n#include \"aops.h\"\n#include \"alloc.h\"\n#include \"ocfs1_fs_compat.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include \"ocfs2_trace.h\"\n#include <linux/cleancache.h>\n#include <linux/quotaops.h>\n#include <linux/seq_file.h>\n#include <linux/mount.h>\n#include <linux/debugfs.h>\n#include <linux/crc32.h>\n#include <linux/parser.h>\n#include <linux/inet.h>\n#include <linux/socket.h>\n#include <linux/blkdev.h>\n#include <linux/moduleparam.h>\n#include <linux/statfs.h>\n#include <linux/random.h>\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void ocfs2_put_super(struct super_block *sb);\nstatic int ocfs2_mount_volume(struct super_block *sb);\nstatic struct inode *ocfs2_alloc_inode(struct super_block *sb);\nstatic char error_buf[1024];\n\nvoid __ocfs2_error(struct super_block *sb,\n\t\t   const char *function,\n\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(error_buf, sizeof(error_buf), fmt, args);\n\tva_end(args);\n\n\t/* Not using mlog here because we want to show the actual\n\t * function the error came from. */\n\tprintk(KERN_CRIT \"OCFS2: ERROR (device %s): %s: %s\\n\",\n\t       sb->s_id, function, error_buf);\n\n\tocfs2_handle_error(sb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "rb->rf_fs_generation"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "sle32_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "53-56",
          "snippet": "static inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s32 sle32_to_cpup(sle32 *x)\n{\n\treturn le32_to_cpu(*(__force le32*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_SB",
          "args": [
            "sb"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "rb->rf_blkno"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "sle64_to_cpup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ntfs/endian.h",
          "lines": "58-61",
          "snippet": "static inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}",
          "includes": [
            "#include \"types.h\"",
            "#include <asm/byteorder.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"types.h\"\n#include <asm/byteorder.h>\n\nstatic inline s64 sle64_to_cpup(sle64 *x)\n{\n\treturn le64_to_cpu(*(__force le64*)x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "OCFS2_IS_VALID_REFCOUNT_BLOCK",
          "args": [
            "rb"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlog",
          "args": [
            "ML_ERROR",
            "\"Checksum failed for refcount block %llu\\n\"",
            "(unsigned long long)bh->b_blocknr"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "mlog_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/cluster/masklog.c",
          "lines": "107-113",
          "snippet": "static ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}",
          "includes": [
            "#include \"masklog.h\"",
            "#include <asm/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kernel.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"masklog.h\"\n#include <asm/uaccess.h>\n#include <linux/string.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n\nstatic ssize_t mlog_show(struct kobject *obj, struct attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct mlog_attribute *mlog_attr = to_mlog_attr(attr);\n\n\treturn mlog_mask_show(mlog_attr->mask, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ocfs2_validate_meta_ecc",
          "args": [
            "sb",
            "bh->b_data",
            "&rb->rf_check"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "ocfs2_validate_meta_ecc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/blockcheck.c",
          "lines": "613-624",
          "snippet": "int ocfs2_validate_meta_ecc(struct super_block *sb, void *data,\n\t\t\t    struct ocfs2_block_check *bc)\n{\n\tint rc = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tif (ocfs2_meta_ecc(osb))\n\t\trc = ocfs2_block_check_validate(data, sb->s_blocksize, bc,\n\t\t\t\t\t\t&osb->osb_ecc_stats);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"blockcheck.h\"",
            "#include \"ocfs2.h\"",
            "#include <cluster/masklog.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/bitops.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/crc32.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"blockcheck.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <asm/byteorder.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/bitops.h>\n#include <linux/buffer_head.h>\n#include <linux/crc32.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nint ocfs2_validate_meta_ecc(struct super_block *sb, void *data,\n\t\t\t    struct ocfs2_block_check *bc)\n{\n\tint rc = 0;\n\tstruct ocfs2_super *osb = OCFS2_SB(sb);\n\n\tif (ocfs2_meta_ecc(osb))\n\t\trc = ocfs2_block_check_validate(data, sb->s_blocksize, bc,\n\t\t\t\t\t\t&osb->osb_ecc_stats);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!buffer_uptodate(bh)"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "buffer_uptodate",
          "args": [
            "bh"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "btrfs_set_buffer_uptodate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/btrfs/disk-io.c",
          "lines": "3758-3761",
          "snippet": "int btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}",
          "includes": [
            "#include <asm/cpufeature.h>",
            "#include \"qgroup.h\"",
            "#include \"sysfs.h\"",
            "#include \"raid56.h\"",
            "#include \"dev-replace.h\"",
            "#include \"rcu-string.h\"",
            "#include \"check-integrity.h\"",
            "#include \"inode-map.h\"",
            "#include \"free-space-cache.h\"",
            "#include \"tree-log.h\"",
            "#include \"locking.h\"",
            "#include \"print-tree.h\"",
            "#include \"volumes.h\"",
            "#include \"btrfs_inode.h\"",
            "#include \"transaction.h\"",
            "#include \"hash.h\"",
            "#include \"disk-io.h\"",
            "#include \"ctree.h\"",
            "#include <asm/unaligned.h>",
            "#include <linux/semaphore.h>",
            "#include <linux/uuid.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/migrate.h>",
            "#include <linux/slab.h>",
            "#include <linux/freezer.h>",
            "#include <linux/kthread.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/buffer_head.h>",
            "#include <linux/writeback.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/swap.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/cpufeature.h>\n#include \"qgroup.h\"\n#include \"sysfs.h\"\n#include \"raid56.h\"\n#include \"dev-replace.h\"\n#include \"rcu-string.h\"\n#include \"check-integrity.h\"\n#include \"inode-map.h\"\n#include \"free-space-cache.h\"\n#include \"tree-log.h\"\n#include \"locking.h\"\n#include \"print-tree.h\"\n#include \"volumes.h\"\n#include \"btrfs_inode.h\"\n#include \"transaction.h\"\n#include \"hash.h\"\n#include \"disk-io.h\"\n#include \"ctree.h\"\n#include <asm/unaligned.h>\n#include <linux/semaphore.h>\n#include <linux/uuid.h>\n#include <linux/ratelimit.h>\n#include <linux/migrate.h>\n#include <linux/slab.h>\n#include <linux/freezer.h>\n#include <linux/kthread.h>\n#include <linux/workqueue.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/radix-tree.h>\n#include <linux/swap.h>\n#include <linux/scatterlist.h>\n#include <linux/blkdev.h>\n#include <linux/fs.h>\n\nint btrfs_set_buffer_uptodate(struct extent_buffer *buf)\n{\n\treturn set_extent_buffer_uptodate(buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_ocfs2_validate_refcount_block",
          "args": [
            "(unsigned long long)bh->b_blocknr"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic int ocfs2_validate_refcount_block(struct super_block *sb,\n\t\t\t\t\t struct buffer_head *bh)\n{\n\tint rc;\n\tstruct ocfs2_refcount_block *rb =\n\t\t(struct ocfs2_refcount_block *)bh->b_data;\n\n\ttrace_ocfs2_validate_refcount_block((unsigned long long)bh->b_blocknr);\n\n\tBUG_ON(!buffer_uptodate(bh));\n\n\t/*\n\t * If the ecc fails, we return the error but otherwise\n\t * leave the filesystem running.  We know any error is\n\t * local to this block.\n\t */\n\trc = ocfs2_validate_meta_ecc(sb, bh->b_data, &rb->rf_check);\n\tif (rc) {\n\t\tmlog(ML_ERROR, \"Checksum failed for refcount block %llu\\n\",\n\t\t     (unsigned long long)bh->b_blocknr);\n\t\treturn rc;\n\t}\n\n\n\tif (!OCFS2_IS_VALID_REFCOUNT_BLOCK(rb)) {\n\t\tocfs2_error(sb,\n\t\t\t    \"Refcount block #%llu has bad signature %.*s\",\n\t\t\t    (unsigned long long)bh->b_blocknr, 7,\n\t\t\t    rb->rf_signature);\n\t\treturn -EINVAL;\n\t}\n\n\tif (le64_to_cpu(rb->rf_blkno) != bh->b_blocknr) {\n\t\tocfs2_error(sb,\n\t\t\t    \"Refcount block #%llu has an invalid rf_blkno \"\n\t\t\t    \"of %llu\",\n\t\t\t    (unsigned long long)bh->b_blocknr,\n\t\t\t    (unsigned long long)le64_to_cpu(rb->rf_blkno));\n\t\treturn -EINVAL;\n\t}\n\n\tif (le32_to_cpu(rb->rf_fs_generation) != OCFS2_SB(sb)->fs_generation) {\n\t\tocfs2_error(sb,\n\t\t\t    \"Refcount block #%llu has an invalid \"\n\t\t\t    \"rf_fs_generation of #%u\",\n\t\t\t    (unsigned long long)bh->b_blocknr,\n\t\t\t    le32_to_cpu(rb->rf_fs_generation));\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cache_info_to_refcount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9717/repo/fs/ocfs2/refcounttree.c",
    "lines": "74-78",
    "snippet": "static inline struct ocfs2_refcount_tree *\ncache_info_to_refcount(struct ocfs2_caching_info *ci)\n{\n\treturn container_of(ci, struct ocfs2_refcount_tree, rf_ci);\n}",
    "includes": [
      "#include <linux/posix_acl.h>",
      "#include <linux/mount.h>",
      "#include <linux/namei.h>",
      "#include <linux/quotaops.h>",
      "#include <linux/fsnotify.h>",
      "#include <linux/security.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagevec.h>",
      "#include <linux/writeback.h>",
      "#include <linux/slab.h>",
      "#include <linux/blkdev.h>",
      "#include <linux/bio.h>",
      "#include \"ocfs2_trace.h\"",
      "#include \"namei.h\"",
      "#include \"xattr.h\"",
      "#include \"aops.h\"",
      "#include \"extent_map.h\"",
      "#include \"dlmglue.h\"",
      "#include \"sysfile.h\"",
      "#include \"refcounttree.h\"",
      "#include \"blockcheck.h\"",
      "#include \"buffer_head_io.h\"",
      "#include \"super.h\"",
      "#include \"uptodate.h\"",
      "#include \"journal.h\"",
      "#include \"suballoc.h\"",
      "#include \"alloc.h\"",
      "#include \"inode.h\"",
      "#include \"ocfs2.h\"",
      "#include <cluster/masklog.h>",
      "#include <linux/sort.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ci",
            "structocfs2_refcount_tree",
            "rf_ci"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/posix_acl.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/quotaops.h>\n#include <linux/fsnotify.h>\n#include <linux/security.h>\n#include <linux/swap.h>\n#include <linux/pagevec.h>\n#include <linux/writeback.h>\n#include <linux/slab.h>\n#include <linux/blkdev.h>\n#include <linux/bio.h>\n#include \"ocfs2_trace.h\"\n#include \"namei.h\"\n#include \"xattr.h\"\n#include \"aops.h\"\n#include \"extent_map.h\"\n#include \"dlmglue.h\"\n#include \"sysfile.h\"\n#include \"refcounttree.h\"\n#include \"blockcheck.h\"\n#include \"buffer_head_io.h\"\n#include \"super.h\"\n#include \"uptodate.h\"\n#include \"journal.h\"\n#include \"suballoc.h\"\n#include \"alloc.h\"\n#include \"inode.h\"\n#include \"ocfs2.h\"\n#include <cluster/masklog.h>\n#include <linux/sort.h>\n\nstatic inline struct ocfs2_refcount_tree *\ncache_info_to_refcount(struct ocfs2_caching_info *ci)\n{\n\treturn container_of(ci, struct ocfs2_refcount_tree, rf_ci);\n}"
  }
]